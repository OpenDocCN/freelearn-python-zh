- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Conditionals and Iteration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件和迭代
- en: ”Would you tell me, please, which way I ought to go from here?”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “你能告诉我，请，我应该从这里走哪条路吗？”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “That depends a good deal on where you want to get to.”
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “这很大程度上取决于你想要去哪里。”
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Lewis Carroll, from Alice’s Adventures in Wonderland
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——刘易斯·卡罗尔，《爱丽丝梦游仙境》
- en: In the previous chapter, we looked at Python’s built-in data types. Now that
    you are familiar with data in its many forms and shapes, it is time to start looking
    at how a program can use it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Python 的内置数据类型。现在你已经熟悉了各种形式和形状的数据，是时候开始了解程序如何使用它了。
- en: 'According to Wikipedia:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: In computer science, **control flow** (or **flow of control** ) is the order
    in which individual statements, instructions, or function calls of an imperative
    program are executed or evaluated.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机科学中，**控制流**（或**控制流程**）是指 imperative 程序中各个语句、指令或函数调用的执行或评估的顺序。
- en: The two main ways of controlling the flow of a program are **conditional programming**
    (also known as **branching** ) and **looping** . These techniques can be combined
    to produce an endless variety of programs. Rather than attempting to document
    all the ways of combining looping and branching, we will give you an overview
    of the flow control constructs available in Python. Then, we will walk you through
    a couple of example programs. This way, you should get a better feeling of how
    conditional programming and looping can be used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流程的两种主要方式是**条件编程**（也称为**分支**）和**循环**。这些技术可以组合起来产生无数种程序。我们不会尝试记录所有组合循环和分支的方法，而是会给你一个概述
    Python 中可用的流程控制结构。然后，我们将带你通过几个示例程序。这样，你应该能更好地理解条件编程和循环是如何被使用的。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Conditional programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件编程
- en: Looping in Python
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的循环
- en: Assignment expressions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: A quick peek at the `itertools` module
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速浏览 `itertools` 模块
- en: Conditional programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编程
- en: 'Conditional programming, or branching, is something you do every moment of
    every day. Essentially, it consists of evaluating conditions and deciding what
    action to take: *if the light is green, then I can cross* ; *if it is raining,
    then I am taking the umbrella* ; and *if I am late for work, then I will call
    my manager* .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编程，或分支，是你每天每时每刻都在做的事情。本质上，它包括评估条件和决定采取什么行动：*如果绿灯亮了，那么我可以过马路*；*如果下雨了，那么我会带伞*；*如果我上班迟到了，那么我会给经理打电话*。
- en: The if statement
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The main tool for conditional programming in Python is the `if` statement.
    Its function is to evaluate an expression and, based on the result, choose which
    part of the code to execute. As usual, let us look at an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中条件编程的主要工具是 `if` 语句。它的功能是评估一个表达式，并根据结果选择执行代码的哪个部分。像往常一样，让我们来看一个例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the simplest example possible: the `if` statement evaluates the expression
    `late` in a Boolean context (exactly as if we were calling `bool(late)` ). If
    the result of the evaluation is `True` , then we enter the body of the code immediately
    after the `if` statement. Notice that the `print` instruction is indented, which
    means that it belongs to a scope defined by the `if` clause. Execution of this
    code yields:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的例子：if 语句在布尔上下文中评估 `late` 表达式（就像我们调用 `bool(late)` 一样）。如果评估结果为 `True`，则立即进入
    if 语句之后的代码体。注意，`print` 指令是缩进的，这意味着它属于由 if 子句定义的作用域。执行此代码会产生以下结果：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since `late` is `True` , the `print()` statement was executed. We can expand
    on the basic `if` statement, by adding an `else` clause. This provides an alternative
    set of instructions to execute when the expression in the `if` clause evaluates
    to `False` .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `late` 是 `True`，执行了 `print()` 语句。我们可以通过添加 `else` 子句来扩展基本的 `if` 语句。这提供了一组替代指令，在
    if 子句中的表达式评估为 `False` 时执行。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time, we set `late = False` , so when we execute the code, the result
    is different:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们设置 `late = False`，因此当我们执行代码时，结果会有所不同：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Depending on the result of evaluating `late` , we can either enter block `#
    1` or block `# 2` , *but not both* . Block `# 1` is executed when `late` evaluates
    to `True` , while block `# 2` is executed when `late` evaluates to `False` . Try
    assigning `False` / `True` values to `late` and see how the output changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `late` 的评估结果，我们可以进入块 `# 1` 或块 `# 2`，但不能同时进入。当 `late` 评估为 `True` 时，执行块 `#
    1`，而当 `late` 评估为 `False` 时，执行块 `# 2`。尝试将 `False` / `True` 值分配给 `late` 并观察输出如何变化。
- en: 'A specialized else: elif'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '特殊的 else: elif'
- en: What we have seen so far is sufficient when you have only one condition to evaluate
    and, at most, two alternative paths to take (the `if` and `else` clauses). Sometimes,
    however, there are situations where you have to evaluate more than one condition
    to choose from among multiple paths. To demonstrate this, we will need an example
    with a few more options to choose from.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当你只有一个条件要评估，并且最多只有两条替代路径（`if`和`else`子句）时，我们所看到的是足够的。然而，有时你可能需要评估多个条件以从多个路径中选择。为了演示这一点，我们需要一个有更多选项可供选择的例子。
- en: 'This time, we will create a simple tax calculator. Suppose that taxes are determined
    as follows: if your income is less than $10,000, you do not need to pay any taxes.
    If it is between $10,000 and $30,000, you must pay 20% in taxes. If it is between
    $30,000 and $100,000, you pay 35% in taxes, and if you are fortunate enough to
    earn over $100,000, you must pay 45% in taxes. Let us translate this into Python
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将创建一个简单的税务计算器。假设税收是这样确定的：如果你的收入低于$10,000，你不需要支付任何税款。如果它在$10,000和$30,000之间，你必须支付20%的税款。如果它在$30,000和$100,000之间，你支付35%的税款，如果你有幸赚得超过$100,000，你必须支付45%的税款。让我们把这个翻译成Python代码：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we execute this code, we get the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这段代码时，会得到以下输出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let us go through the example one line at a time. We start by setting up the
    income value. In the example, your income is $15,000. We enter the `if` statement.
    Notice that, this time, we also introduced the `elif` clause, which is a contraction
    of `else-if.` It differs from a plain `else` clause in that it also has its own
    condition. The `if` expression of `income < 10000` evaluates to `False` ; therefore,
    block `# 1` is not executed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个例子。我们首先设置收入值。在这个例子中，你的收入是$15,000。我们进入`if`语句。注意，这次我们还引入了`elif`子句，它是`else-if`的缩写。它与普通的`else`子句不同，因为它也有自己的条件。`income
    < 10000`的`if`表达式评估为`False`；因此，代码块`# 1`没有被执行。
- en: 'The control passes to the next condition: `elif income < 30000` . This one
    evaluates to `True` ; therefore, block `# 2` is executed, and because of this,
    Python then resumes execution after the whole `if` / `elif` / `elif` / `else`
    construct (which we can just call the `if` statement from now on). There is only
    one instruction after the `if` statement: the `print()` call, which produces output
    telling us that we will pay `$3000.0` in taxes this year ( *15,000 * 20%* ). Notice
    that the order is mandatory: `if` comes first, then (optionally) as many `elif`
    clauses as you may need, and then (optionally) a single `else` clause.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 控制权传递到下一个条件：`elif income < 30000`。这个条件评估为`True`；因此，代码块`# 2`被执行，因此Python随后在完整的`if`
    / `elif` / `elif` / `else`结构（从现在起我们可以简单地称之为`if`语句）之后继续执行。`if`语句之后只有一个指令：`print()`调用，它产生输出告诉我们今年我们将支付$3000.0的税款（*15,000
    * 20%*）。注意，顺序是强制性的：`if`首先，然后（可选地）尽可能多的`elif`子句，最后（可选地）一个单独的`else`子句。
- en: No matter how many lines of code you may have within each block, when one of
    the conditions evaluates to `True` , the associated block is executed, and then
    execution resumes after the whole clause. If none of the conditions evaluates
    to `True` (for example, `income = 200000` ), then the body of the `else` clause
    would be executed (block `# 4` ). This example expands our understanding of the
    behavior of the `else` clause. Its block of code is executed when none of the
    preceding `if` / `elif` /.../ `elif` expressions have evaluated to `True` .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论每个代码块中有多少行代码，只要其中一个条件评估为`True`，相关的代码块就会被执行，然后执行会继续到整个子句之后。如果没有条件评估为`True`（例如，`income
    = 200000`），则`else`子句的主体将被执行（代码块`# 4`）。这个例子扩展了我们对于`else`子句行为的理解。它的代码块会在前面的`if`
    / `elif` /.../ `elif`表达式都没有评估为`True`时执行。
- en: Try to modify the value of `income` until you can comfortably execute any of
    the blocks at will. Also, test the behavior at the **boundaries** where the values
    of the Boolean expressions in the `if` and `elif` clauses change. It is crucial
    to test boundaries thoroughly to ensure the correctness of your code. Should we
    allow you to drive at 18 or 17? Are we checking your age with `age < 18` or `age
    <= 18` ? You cannot imagine how many times we have had to fix subtle bugs that
    stemmed from using the wrong operator, so go ahead and experiment with the code.
    Change some instances of `<` to `<=` , and set `income` to be one of the boundary
    values (10,000, 30,000, or 100,000), as well as any value in between. See how
    the result changes, and get a good understanding of it before proceeding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改 `income` 的值，直到你可以随意执行任何代码块。还要测试在 `if` 和 `elif` 子句中布尔表达式的值发生变化的 **边界** 上的行为。彻底测试边界对于确保代码的正确性至关重要。我们应该允许你在
    18 岁或 17 岁时驾驶吗？我们是用 `age < 18` 还是 `age <= 18` 来检查你的年龄？你无法想象我们有多少次不得不修复由使用错误的运算符引起的微妙错误，所以请继续实验代码。将一些
    `<` 改为 `<=`，并将 `income` 设置为边界值之一（10,000、30,000 或 100,000），以及任何介于这些值之间的值。看看结果如何变化，并在继续之前对其有一个良好的理解。
- en: Nesting if statements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套 `if` 语句
- en: You can also nest `if` statements. Let us look at another example to show you
    how. Let us say, for example, that your program encounters an error. If the alert
    system is the console, we print the error.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以嵌套 `if` 语句。让我们看看另一个例子来展示如何做到这一点。比如说，如果你的程序遇到了错误。如果警报系统是控制台，我们就打印错误信息。
- en: 'If the alert system is an email, the severity of the error determines which
    address we should send the alert to. If the alert system is anything other than
    the console or email, we do not know what to do, so we do nothing. Let us put
    this into code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果警报系统是电子邮件，错误的严重性决定了我们应该将警报发送到哪个地址。如果警报系统不是控制台或电子邮件，我们不知道该怎么做，所以我们什么也不做。让我们把这个写成代码：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have an *inner* `if` statement nested within the body of the `elif`
    clause of an *outer* `if` statement. Notice that the nesting is achieved by indenting
    the inner `if` statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个嵌套在 *外部* `if` 语句的 `elif` 子句体中的 *内部* `if` 语句。注意，嵌套是通过缩进内部 `if` 语句来实现的。
- en: Let us step through the code and see what happens. We start by assigning values
    to `alert_system` , `error_severity` , and `error_message` . When we enter the
    outer `if` statement, if `alert_system == "console"` evaluates to `True` , body
    `# 1` is executed, and nothing else happens. On the other hand, if `alert_system
    == "email"` evaluates to `True` , then we enter the inner `if` statement. In the
    inner `if` statement, the `error_severity` determines whether we send an email
    to an admin, first-level support, or second-level support (blocks `# 2` , `# 3`
    , and `# 4` ). The `send_email()` function is not defined in this example, so
    trying to run it would give you an error. In the `errorsalert.py` module, which
    you can find in the source code of this book, we included a trick to redirect
    that call to a regular `print()` function, just so you can experiment on the console
    without actually sending an email. Try changing the values and see how it all
    works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步执行代码，看看会发生什么。我们首先为 `alert_system`、`error_severity` 和 `error_message` 赋值。当我们进入外部
    `if` 语句时，如果 `alert_system == "console"` 评估为 `True`，则执行代码块 `# 1`，然后不再发生其他事情。另一方面，如果
    `alert_system == "email"` 评估为 `True`，那么我们就进入内部 `if` 语句。在内部 `if` 语句中，`error_severity`
    决定了我们应该向管理员、一级支持还是二级支持发送电子邮件（代码块 `# 2`、`# 3` 和 `# 4`）。在这个例子中，`send_email()` 函数没有定义，所以尝试运行它会给你一个错误。在本书源代码中可以找到的
    `errorsalert.py` 模块中，我们包括了一个技巧来将那个调用重定向到一个普通的 `print()` 函数，这样你就可以在控制台上进行实验，而实际上并不发送电子邮件。尝试更改值，看看它如何工作。
- en: The ternary operator
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'The next thing we would like to show you is the **ternary operator.** In Python,
    this is also known as a **conditional expression** . It looks and behaves like
    a short, in-line version of an `if` statement. When you just want to choose between
    two values, depending on some condition, it is sometimes easier and more readable
    to use the ternary operator instead of a full `if` statement. For example, instead
    of:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想展示的是 **三元运算符**。在 Python 中，这也被称为 **条件表达式**。它看起来和表现就像是一个简短的、内联的 `if` 语句。当你只想根据某个条件在两个值之间进行选择时，使用三元运算符有时比使用完整的
    `if` 语句更容易和更易读。例如，而不是：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could write:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写成：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For simple cases like this, we find it convenient to be able to express that
    logic in one line instead of four. Remember that, as a coder, you spend much more
    time reading code than writing it, so Python’s conciseness is invaluable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单的情况，我们觉得能够用一行而不是四行来表示这种逻辑非常方便。记住，作为一个程序员，你花在阅读代码上的时间要比编写代码的时间多得多，所以Python的简洁性是无价的。
- en: 'In some languages (like C or JavaScript), the ternary operator is even more
    concise. For example, the above could be written as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言（如C或JavaScript）中，三元运算符甚至更加简洁。例如，上面的代码可以写成：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although Python’s version is slightly more verbose, we think it more than makes
    up for that by being easier to read and understand.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python的版本稍微有点冗长，但我们认为它通过更容易阅读和理解来弥补了这一点。
- en: Are you clear on how the ternary operator works? It is quite simple; `something
    if condition else something-else` evaluates to something `if` condition evaluates
    to `True` . Otherwise, if `condition` is `False` , the expression evaluates to
    `something-else` .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你清楚三元运算符的工作原理吗？它相当简单；`something if condition else something-else`在条件`condition`评估为`True`时评估为`something`。否则，如果`condition`是`False`，表达式评估为`something-else`。
- en: Pattern matching
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '**Structural pattern matching** , often just called **pattern matching** ,
    is a relatively new feature that was introduced in Python 3.10 via PEP 634 ( [https://peps.python.org/pep-0634](https://peps.python.org/pep-0634)
    ). It was partly inspired by the pattern matching capabilities of languages like
    Haskel, Erlang, Scala, Elixir, and Ruby.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化模式匹配**，通常简称为**模式匹配**，是一个相对较新的特性，它是在Python 3.10版本中通过PEP 634（[https://peps.python.org/pep-0634](https://peps.python.org/pep-0634)）引入的。它部分受到了像Haskel、Erlang、Scala、Elixir和Ruby等语言的模式匹配能力的影响。'
- en: 'Simply put, the `match` statement compares a value against one or more *patterns*
    , and then it executes the code block associated with the first pattern that matches.
    Let us see a simple example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`match`语句将一个值与一个或多个**模式**进行比较，然后执行与第一个匹配的模式关联的代码块。让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start by initializing `day_number` before entering the `match` statement.
    The `match` statement will attempt to match the value of `day_number` against
    a series of patterns, each of which is introduced by the **case** keyword. In
    our example, we have four patterns. The first `1 | 2 | 3 | 4 | 5` will match any
    of the values `1` , `2` , `3` , `4` , or `5` . This is known as an **OR pattern**
    ; it consists of a number of sub-patterns separated by `|` . It matches when any
    of the sub-patterns (in this case, the literal values `1` , `2` , `3` , `4` ,
    and `5` ) match. The second and third patterns in our example just consist of
    the integer literals `6` and `7` , respectively. The final pattern, `_` , is a
    **wildcard pattern** ; it is a catch-all that matches any value. A `match` statement
    can have at most one catch-all pattern, and if one is present, it must be the
    last pattern.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进入`match`语句之前初始化`day_number`。`match`语句将尝试将`day_number`的值与一系列模式匹配，每个模式都由**case**关键字引入。在我们的例子中，我们有四个模式。第一个`1
    | 2 | 3 | 4 | 5`将匹配任何值`1`、`2`、`3`、`4`或`5`。这被称为**或模式**；它由多个通过`|`分隔的子模式组成。当任何子模式（在本例中，是字面值`1`、`2`、`3`、`4`和`5`）匹配时，它就会匹配。我们例子中的第二个和第三个模式分别只包含整数字面量`6`和`7`。最后一个模式`_`是一个**通配符模式**；它是一个通用的匹配任何值的模式。一个`match`语句最多只能有一个通配符模式，如果存在，它必须是最后一个模式。
- en: The body of the first case block whose pattern matches will be executed. Afterward,
    execution resumes below the `match` statement without evaluating any of the remaining
    patterns. If none of the patterns match, execution resumes below the `match` statement
    without executing any of the case bodies. In our example, the first pattern matches,
    so `print("Weekday")` is executed. Take some time to experiment with this example.
    Try changing the value of `day_number` and see what happens when you run it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将会执行第一个与模式匹配的case块的主体。之后，执行将继续在`match`语句下方进行，而不会评估任何剩余的模式。如果没有任何模式匹配，执行将继续在`match`语句下方进行，而不会执行任何case主体。在我们的例子中，第一个模式匹配，所以`print("Weekday")`被执行。花点时间实验这个例子。尝试改变`day_number`的值，看看运行时会发生什么。
- en: The `match` statement resembles the `switch` / `case` statements of languages
    like C++ and JavaScript. However, it is much more powerful than that. The variety
    of different kinds of patterns available and the ability to compose patterns allow
    you to do much more than a simple C++ `switch` statement. For example, Python
    allows you to match sequences, dictionaries, or even custom classes. You can also
    capture and assign values to names in patterns. We do not have space here to cover
    everything you can do with pattern matching, but we encourage you to study the
    tutorial in PEP 636 ( [https://peps.python.org/pep-0636](https://peps.python.org/pep-0636)
    ) to learn more.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 语句类似于 C++ 和 JavaScript 等语言中的 `switch` / `case` 语句。然而，它比这更强大。可用的不同类型的模式种类繁多，以及组合模式的能力，让你能够做比简单的
    C++ `switch` 语句更多的事情。例如，Python 允许你匹配序列、字典，甚至自定义类。你还可以在模式中捕获并将值分配给名称。我们在这里没有足够的空间涵盖你可以用模式匹配做的一切，但我们鼓励你学习
    PEP 636 中的教程（[https://peps.python.org/pep-0636](https://peps.python.org/pep-0636)）以了解更多信息。'
- en: 'Now that you know everything about controlling the path of the code, let us
    move on to the next subject: *looping* .'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了关于控制代码路径的一切，让我们继续下一个主题：*循环*。
- en: Looping
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: If you have any experience with looping in other programming languages, you
    will find Python’s way of looping a bit different. First of all, what is looping?
    **Looping** means being able to repeat the execution of a code block more than
    once, according to the loop parameters given. There are different looping constructs
    that serve different purposes, and Python has distilled all of them down to just
    two, which you can use to achieve everything you need. These are the `for` and
    `while` statements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他编程语言中有任何循环的经验，你会发现 Python 的循环方式略有不同。首先，什么是循环？**循环**意味着能够根据循环参数重复执行代码块多次。有不同的循环结构，用于不同的目的，Python
    将它们简化为只有两个，你可以使用它们来实现你需要的一切。这些是 `for` 和 `while` 语句。
- en: Although it is technically possible to use either of them for any task that
    requires looping, they do serve different purposes. We will explore this difference
    thoroughly in this chapter. By the end of it, you will know when to use a `for`
    loop and when to use a `while` loop.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可以使用任何一个来完成需要循环的任务，但它们确实有不同的用途。我们将在本章中彻底探讨这种差异。到本章结束时，你将知道何时使用 `for` 循环，何时使用
    `while` 循环。
- en: The for loop
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 循环
- en: 'The `for` loop is used when looping over a sequence, such as a list, tuple,
    or collection of objects. Let us start with a simple example and expand on the
    concept to see what the Python syntax allows us to do:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要遍历序列，如列表、元组或对象集合时，使用 `for` 循环。让我们从一个简单的例子开始，并在此基础上扩展概念，看看 Python 语法允许我们做什么：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This simple snippet of code, when executed, prints all numbers from `0` to `4`
    . The body of the `for` loop (the `print()` line) is executed once for each value
    in the list `[0, 1, 2, 3, 4]` . In the first iteration, `number` is assigned the
    first value from the sequence; in the second iteration, `number` takes the second
    value; and so on. After the last item in the sequence, the loop terminates, and
    execution resumes normally with the code after the loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码，当执行时，会打印出从 `0` 到 `4` 的所有数字。`for` 循环的主体（`print()` 行）对于列表 `[0, 1, 2, 3,
    4]` 中的每个值都会执行一次。在第一次迭代中，`number` 被分配给序列中的第一个值；在第二次迭代中，`number` 取第二个值；依此类推。在序列的最后一个项目之后，循环结束，执行恢复正常，继续执行循环之后的代码。
- en: Iterating over a range
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历范围
- en: 'We often need to iterate over a range of numbers, and it would be quite tedious
    to have to do so by hard coding the list somewhere. In such cases, the `range()`
    function comes to the rescue. Let us see the equivalent of the previous snippet
    of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要遍历一系列数字，如果必须通过硬编码列表来这样做，将会非常繁琐。在这种情况下，`range()` 函数就派上用场了。让我们看看之前代码片段的等效代码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `range()` function is used extensively to create sequences in Python programs.
    You can call it with a single value, which acts as `stop` (counting will start
    from `0` ). You can also pass two values ( `start` and `stop` ), or even three
    ( `start` , `stop` , and `step` ). Check out the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数在 Python 程序中广泛用于创建序列。你可以用单个值调用它，该值作为 `stop`（计数将从 `0` 开始）。你也可以传递两个值（`start`
    和 `stop`），甚至三个（`start`、`stop` 和 `step`）。查看以下示例：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the moment, ignore that we need to wrap `range(...)` within a list. We
    will explain the reasons for this in *Chapter 5* , *Comprehensions and Generators*
    . You can see that the behavior is analogous to slicing (which we described in
    the previous chapter): `start` is included, `stop` is excluded, and you can add
    an optional `step` parameter, which by default is `1` .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，忽略我们需要将 `range(...)` 包裹在一个列表中。我们将在 *第五章* *列表推导式和生成器* 中解释这样做的原因。你可以看到，其行为类似于切片（我们在上一章中描述过）：`start`
    包含在内，`stop` 不包含，你可以添加一个可选的 `step` 参数，默认为 `1`。
- en: Try modifying the parameters of the `range()` call in our `simple.for.py` code
    and see what it prints.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改 `simple.for.py` 代码中 `range()` 调用的参数，看看它会打印出什么。
- en: Iterating over a sequence
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历一个序列
- en: 'We now have all the tools to iterate over a sequence, so let us build on that
    example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了遍历序列的所有工具，让我们在此基础上构建一个例子：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code adds a little bit of complexity to the game. Execution will
    show this result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码给游戏增加了一点点复杂性。执行结果将显示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let us use the **inside-out** technique to break it down. We start from the
    innermost part of what we are trying to understand, and we expand outward. So
    `len(surnames)` is the length of the surnames list: `3` . Therefore, `range(len(surnames))`
    is actually transformed into `range(3)` . This gives us the range `[0, 3)` , which
    is the sequence `(0, 1, 2)` . This means that the `for` loop will run for three
    iterations. In the first one, `position` will take the value `0` , while in the
    second one, it will take the value `1` , and the value `2` in the third and final
    iteration. Here, `(0, 1, 2)` represents the possible indexing positions for the
    `surnames` list. At position `0` , we find `"Rivest"` ; at position `1` , `"Shamir"`
    ; and at position `2` , `"Adleman"` . If you are curious about what these three
    men created together, change `print(position, surnames[position])` to `print(surnames[position][0],
    end="")` , add a final `print()` outside of the loop, and run the code again.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**由内而外**的技术来分解它。我们从我们试图理解的内部最深处开始，然后向外扩展。所以 `len(surnames)` 是姓氏列表的长度：`3`。因此，`range(len(surnames))`
    实际上被转换成了 `range(3)`。这给我们 `[0, 3)` 的范围，即序列 `(0, 1, 2)`。这意味着 `for` 循环将运行三次迭代。在第一次迭代中，`position`
    将取值为 `0`，在第二次迭代中，它将取值为 `1`，在第三次和最后一次迭代中取值为 `2`。在这里，`(0, 1, 2)` 代表 `surnames` 列表可能的索引位置。在位置
    `0` 处，我们找到 `"Rivest"`；在位置 `1` 处，`"Shamir"`；在位置 `2` 处，`"Adleman"`。如果你对这三位男士共同创造了什么感到好奇，将
    `print(position, surnames[position])` 改为 `print(surnames[position][0], end="")`，在循环外部添加一个
    `print()`，然后再次运行代码。
- en: 'Now, this style of looping is much closer to languages such as Java or C. In
    Python, it is quite rare to see code like this. You can just iterate over any
    sequence or collection, so there is no need to get the list of positions and retrieve
    elements from a sequence at each iteration. Let us change the example into a more
    Pythonic form:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种循环风格更接近于 Java 或 C 等语言。在 Python 中，很少看到这样的代码。你可以直接遍历任何序列或集合，因此没有必要在每次迭代中获取位置列表并从序列中检索元素。让我们将示例改为更
    Pythonic 的形式：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `for` loop can iterate over the `surnames` list, and it gives back each
    element in order at each iteration. Running this code will print the three surnames,
    one at a time, which is much easier to read.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环可以遍历 `surnames` 列表，并在每次迭代中按顺序返回每个元素。运行此代码将逐个打印出三个姓氏，这使阅读更加容易。'
- en: 'However, what if you wanted to print the position as well? Or what if you needed
    it? Should you go back to the `range(len(...))` form? No. You can use the `enumerate()`
    built-in function, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要打印位置呢？或者如果你需要它呢？你应该回到 `range(len(...))` 的形式吗？不。你可以使用内置的 `enumerate()`
    函数，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is quite interesting as well. Notice that `enumerate()` gives back
    a two-tuple `(position, surname)` at each iteration, but still, it is more readable
    (and more efficient) than the `range(len(...))` example. You can call `enumerate()`
    with a `start` parameter, such as `enumerate(iterable, start)` , and it will start
    from `start` , rather than `0` . Just another little thing that shows you how
    much thought has been given to designing Python so that it makes your life easier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也非常有趣。注意，`enumerate()` 在每次迭代中返回一个包含 `(position, surname)` 的二元组，但它仍然比 `range(len(...))`
    例子更易读（并且更高效）。你可以使用 `start` 参数调用 `enumerate()`，例如 `enumerate(iterable, start)`，它将从
    `start` 开始，而不是 `0`。这只是另一个小细节，展示了在设计 Python 时投入了多少思考，以便让生活更轻松。
- en: You can use a `for` loop to iterate over lists, tuples, and, in general, anything
    that Python calls **iterable** . This is an important concept, so let us discuss
    it in more detail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环遍历列表、元组，以及在Python中称为**可迭代对象**的任何东西。这是一个重要的概念，所以让我们更详细地讨论它。
- en: Iterators and iterables
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器和可迭代对象
- en: 'According to the Python documentation ( [https://docs.python.org/3.12/glossary.html#term-iterable](https://docs.python.org/3.12/glossary.html#term-iterable)
    ), an **iterable** is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3.12/glossary.html#term-iterable](https://docs.python.org/3.12/glossary.html#term-iterable)），**可迭代对象**是：
- en: An object capable of returning its members one at a time. Examples of iterables
    include all sequence types (such as list, str, and tuple) and some non-sequence
    types like dict, file objects.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 能够一次返回其成员的一个对象。可迭代对象包括所有序列类型（如列表、str和tuple）以及一些非序列类型，如dict和文件对象。
- en: 'Simply put, what happens when you write `for k in sequence: ... body ...` is
    that the `for` loop asks `sequence` for the next element, gets something back,
    calls that something `k` , and then executes its body. Then, once again, the `for`
    loop asks `sequence` for the next element, calls it `k` again, executes the body
    again, and so on, until the sequence is exhausted. Empty sequences will result
    in zero executions of the body.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '简而言之，当你写下`for k in sequence: ... body ...`时，`for`循环会请求`sequence`的下一个元素，得到一些东西，将其称为`k`，然后执行其主体。然后，再次，`for`循环会请求`sequence`的下一个元素，再次将其称为`k`，再次执行主体，依此类推，直到序列耗尽。空序列将导致主体执行零次。'
- en: Some data structures, when iterated over, produce their elements in order, such
    as lists, tuples, dictionaries, and strings, while others, such as sets, do not.
    Python gives us the ability to iterate over iterables, using a type of object
    called an **iterator** , which is an object that represents a stream of data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构在迭代时按顺序产生它们的元素，例如列表、元组、字典和字符串，而其他数据结构，如集合，则不按顺序。Python通过一种称为**迭代器**的对象类型为我们提供了遍历可迭代对象的能力，迭代器是一个表示数据流的对象。
- en: In practice, the whole iterable/iterator mechanism is hidden behind the code.
    Unless you need to code your own iterable or iterator for some reason, you will
    not have to worry about this too much. However, it is important to understand
    how Python handles this key aspect of control flow because it shapes the way in
    which we write code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，整个可迭代/迭代器机制都隐藏在代码背后。除非你需要出于某种原因编写自己的可迭代或迭代器，否则你不必过多担心这一点。然而，了解Python如何处理这个关键的控制流方面非常重要，因为它决定了我们编写代码的方式。
- en: We are going to cover iteration in more detail in *Chapter 5* , *Comprehensions
    and Generators* , and *Chapter 6* , *OOP, Decorators, and Iterators* .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第5章*理解与生成器*和第6章*面向对象编程、装饰器和迭代器*中更详细地介绍迭代。
- en: Iterating over multiple sequences
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历多个序列
- en: 'Let us see another example of how to iterate over two sequences of the same
    length and work on their respective elements in pairs. Say we have a list of people’s
    names and a second list of numbers representing their ages. We want to print the
    pair person/age on one line for each of them. Let us start with an example, which
    we will refine gradually:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个如何遍历相同长度的两个序列并成对处理它们各自的元素的例子。假设我们有一个包含人名的列表和一个表示他们年龄的数字列表。我们想要为每个人打印一行包含人名/年龄的配对。让我们从一个例子开始，我们将逐步对其进行改进：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By now, this code should be straightforward. We iterate over the list of positions
    ( `0` , `1` , `2` , `3` ) because we want to retrieve elements from two different
    lists. Executing it, we get the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码应该是直截了当的。我们遍历位置列表（`0`、`1`、`2`、`3`），因为我们想要从两个不同的列表中检索元素。执行它，我们得到以下结果：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code works, but it is not very Pythonic. It is cumbersome to have to get
    the length of `people` , construct a `range` , and then iterate over that. For
    some data structures, it may also be expensive to retrieve items by their position.
    It would be better if we could iterate over the sequences directly, as we do for
    a single sequence. Let us try to improve it by using `enumerate()` :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是可行的，但并不非常符合Python风格。必须获取`people`的长度、构造一个`range`，然后遍历它，这显得有些繁琐。对于某些数据结构，按位置检索项目可能也很昂贵。如果能直接遍历序列，就像处理单个序列一样，那就更好了。让我们尝试使用`enumerate()`来改进它：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is better, but still not perfect. We are iterating properly on `people`
    , but we are still fetching `age` using positional indexing, which we want to
    lose as well. We can achieve that by using the `zip()` function, which we encountered
    in the previous chapter. Let us use it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，但仍然不完美。我们正确地迭代了`people`，但我们仍然使用位置索引获取`age`，这是我们想要丢弃的。我们可以通过使用我们在上一章中遇到的`zip()`函数来实现这一点。让我们使用它：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That is much more elegant than the original version. When the `for` loop asks
    `zip(sequenceA, sequenceB)` for the next element, it gets back a tuple, which
    is unpacked into `person` and `age` . The tuple will have as many elements as
    the number of sequences we feed to the `zip()` function. Let us expand a little
    on the previous example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这比原始版本要优雅得多。当`for`循环请求`zip(sequenceA, sequenceB)`的下一个元素时，它得到一个元组，该元组被解包到`person`和`age`中。元组将包含与提供给`zip()`函数的序列数量一样多的元素。让我们在先前的例子上稍作扩展：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we added the `instruments` list. Now that we feed three
    sequences to the `zip()` function, the `for` loop gets back a *three-tuple* at
    each iteration. The elements of the tuple are unpacked and assigned to `person`
    , `age` , and `instrument` . Notice that the position of the elements in the tuple
    respects the position of the sequences in the `zip()` call. Executing the code
    will yield the following result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了`instruments`列表。现在，我们向`zip()`函数提供了三个序列，每次迭代`for`循环都会返回一个*三元组*。元组的元素被解包并分配给`person`、`age`和`instrument`。请注意，元组中元素的顺序与`zip()`调用中序列的顺序一致。执行代码将产生以下结果：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that it is not necessary to unpack the tuples when iterating over multiple
    sequences like this. You may need to operate on the tuple as a whole within the
    body of the `for` loop. It is, of course, perfectly possible to do so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在遍历多个序列时，不需要解包元组。你可能在`for`循环体内部将元组作为一个整体进行操作。当然，这样做是完全可能的：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is almost identical to the previous example. The difference is that instead
    of unpacking the tuple we get from `zip(...)` , we assign the entire tuple to
    `data` .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与先前的例子相同。不同之处在于，我们不是解包从`zip(...)`得到的元组，而是将整个元组赋值给`data`。
- en: The while loop
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: In the preceding pages, we saw the `for` loop in action. It is useful when you
    need to loop over a sequence or a collection. The key point to keep in mind when
    you need to decide which looping construct to use is that the `for` loop is best
    suited in cases where you have to iterate over the elements of a container object
    or other iterable object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们看到了`for`循环的实际应用。当你需要遍历一个序列或集合时，它很有用。当你需要决定使用哪种循环结构时，要记住的关键点是`for`循环最适合在必须遍历容器对象或其他可迭代对象的元素的情况下使用。
- en: However, there are other cases when you just need to loop until some condition
    is satisfied, or even loop indefinitely until the application is stopped. In such
    cases, we do not have something to iterate on, so the `for` loop would be a poor
    choice. For situations like this, the `while` loop is more appropriate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他情况，你可能只需要循环直到满足某个条件，或者无限循环直到应用程序停止。在这种情况下，我们没有可以迭代的，所以`for`循环可能不是一个好的选择。对于这种情况，`while`循环更为合适。
- en: The `while` loop is similar to the `for` loop in that both repeatedly execute
    a body of instructions. The difference is that the `while` loop does not loop
    over a sequence. Instead, it loops as long as a certain condition is satisfied.
    When the condition is no longer satisfied, the loop ends.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环与`for`循环类似，因为两者都会重复执行一系列指令。不同之处在于`while`循环不是遍历一个序列。相反，只要满足某个条件，它就会循环。当条件不再满足时，循环结束。'
- en: 'As usual, let us see an example that will clarify everything for us. We want
    to print the binary representation of a positive number. To do so, we can use
    a simple algorithm that divides by two until we reach zero and collects the remainders.
    When we reverse the list of remainders we collected, we get the binary representation
    of the number we started with. For example, if we want a binary representation
    of the decimal number 6, the steps would be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，让我们看一个例子，以帮助我们更清晰地理解。我们想要打印一个正数的二进制表示。为此，我们可以使用一个简单的算法，通过不断除以二直到为零，并收集余数。当我们反转收集到的余数列表时，我们得到我们开始时的数字的二进制表示。例如，如果我们想要十进制数6的二进制表示，步骤如下：
- en: '*6 / 2 = 3* with remainder *0* .'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*6 / 2 = 3* 余 *0* 。'
- en: '*3 / 2 = 1* with remainder *1* .'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*3 / 2 = 1* 余 *1* 。'
- en: '*1 / 2 = 0* with remainder *1* .'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*1 / 2 = 0* 余 *1* 。'
- en: The list of remainders is *0, 1, 1* .
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余数列表是*0, 1, 1*。
- en: 'Reversing this, we get *1, 1, 0* , which is also the binary representation
    of *6* : *110* .'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转这个结果，我们得到*1, 1, 0*，这也是*6*的二进制表示*110*。
- en: 'Let us translate this into Python code. We will calculate the binary representation
    of the number 39, which is 100111:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个例子翻译成Python代码。我们将计算数字39的二进制表示，它是100111：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we highlighted `n > 0` , which is the condition to keep
    looping. Notice how the code matches the algorithm we described: as long as `n`
    is greater than `0` , we divide by `2` and add the remainder to a list. At the
    end (when `n` has reached `0` ), we reverse the list of remainders to get the
    binary representation of the original value of `n` .'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们突出了`n > 0`，这是保持循环的条件。注意代码如何与我们所描述的算法相匹配：只要`n`大于`0`，我们就除以`2`并将余数添加到列表中。在最后（当`n`达到`0`时），我们反转余数列表以获取`n`原始值的二进制表示。
- en: We can use the `divmod()` function to make the code a little shorter (and more
    Pythonic). The `divmod()` function takes a number and a divisor and returns a
    tuple, with the result of the integer division and its remainder. For example,
    `divmod(13, 5)` would return `(2, 3)` and, indeed, *5 * 2 + 3 = 13* .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`divmod()`函数使代码更简洁（并且更符合Python风格）。`divmod()`函数接受一个数和一个除数，并返回一个元组，包含整数除法的结果及其余数。例如，`divmod(13,
    5)`将返回`(2, 3)`，确实，*5 * 2 + 3 = 13*。
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we reassign `n` to the result of the division by `2` and remainder to the
    list of remainders in a single line.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`n`重新赋值为除以`2`的结果，并将余数添加到余数列表中，这一行就完成了。
- en: The built-in function `bin()` returns a binary representation of a number. So,
    apart from examples, or as an exercise, there is no need to implement this yourself
    in Python.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`bin()`返回一个数的二进制表示。所以，除了示例或作为练习，你不需要在Python中自己实现它。
- en: 'Note that the condition in a `while` loop is a condition to continue looping.
    If it evaluates to `True` , then the body is executed, another evaluation follows,
    and so on, until the condition evaluates to `False` . When that happens, the loop
    stops immediately without executing its body. If the condition never evaluates
    to `False` , the loop becomes a so-called **infinite loop** . Infinite loops are
    used, for example, when polling from network devices: you ask the socket whether
    there is any data, you do something with it if there is any, then you sleep for
    a small amount of time, and then you ask the socket again, over and over, without
    ever stopping.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`while`循环中的条件是继续循环的条件。如果它评估为`True`，则执行主体，然后进行另一个评估，依此类推，直到条件评估为`False`。当这种情况发生时，循环会立即停止，而不会执行其主体。如果条件永远不会评估为`False`，则循环会变成所谓的**无限循环**。无限循环在从网络设备轮询时使用，例如：你询问套接字是否有数据，如果有，你将对其进行一些操作，然后你等待一小段时间，然后再次询问套接字，如此反复，永远不会停止。
- en: 'To better illustrate the differences between for and while loops, let us adapt
    one of the previous examples ( `multiple.sequences.py` ) using a `while` loop:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明`for`循环和`while`循环之间的区别，让我们使用`while`循环修改之前的例子（`multiple.sequences.py`）：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we have highlighted the *initialization* , *condition*
    , and *update* of the `position` variable, which makes it possible to simulate
    the equivalent `for` loop code by handling the iteration manually. Everything
    that can be done with a `for` loop can also be done with a `while` loop, even
    though you can see there is a bit of boilerplate you have to go through to achieve
    the same result. The opposite is also true, but unless you have a reason to do
    so, you ought to use the right tool for the job.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们突出了`position`变量的*初始化*、*条件*和*更新*，这使得通过手动处理迭代来模拟等效的`for`循环代码成为可能。任何可以用`for`循环完成的事情也可以用`while`循环完成，尽管你可以看到为了达到相同的结果，你需要经过一些样板代码。反之亦然，但除非你有这样做的原因，否则你应该使用适合的工具来完成工作。
- en: To recap, use a `for` loop when you need to iterate over an iterable, and use
    a `while` loop when you need to loop according to whether a condition is satisfied
    or not. If you keep in mind the difference between the two purposes, you will
    never choose the wrong looping construct.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当你需要遍历可迭代对象时使用`for`循环，当你需要根据条件是否满足来循环时使用`while`循环。如果你记住这两个目的之间的区别，你就永远不会选择错误的循环结构。
- en: Let us now see how to alter the normal flow of a loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何改变循环的正常流程。
- en: The break and continue statements
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break和continue语句
- en: There are scenarios where you will need to alter the regular flow of a loop.
    You can either skip a single iteration (as many times as you want), or you can
    break out of the loop entirely. A common use case for skipping iterations is,
    for example, when you are iterating over a list of items, but you only need to
    work on those that satisfy some condition. On the other hand, if you are iterating
    over a collection to search for an item that meets some requirement, you may want
    to break out of the loop as soon as you find what you are looking for. There are
    countless possible scenarios; let us work through a couple of examples together
    to show you how this works in practice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要改变循环的正常流程。你可以跳过单个迭代（你想跳过多少次就跳过多少次），或者你可以完全跳出循环。跳过迭代的常见用例是，例如，当你正在遍历一个项目列表，但你只需要处理满足某些条件的那些项目。另一方面，如果你正在遍历一个集合以搜索满足某些要求的项，你可能想在找到你想要的东西时立即跳出循环。有无数可能的情况；让我们一起分析几个例子，以展示这在实践中是如何工作的。
- en: 'Suppose that you want to apply a 20% discount on all products that have an
    expiration date of today. You can achieve this by using the `continue` statement,
    which tells the looping construct ( `for` or `while` ) to stop executing the body
    immediately and go to the next iteration, if any:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要对今天到期的所有产品应用20%的折扣。你可以通过使用`continue`语句来实现这一点，它告诉循环结构（`for`或`while`）立即停止执行体并转到下一个迭代（如果有的话）：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start by importing the `date` and `timedelta` objects, and then we set up
    our products. Those with `sku` `1` and `3` have an expiration date of `today`
    , which means that we want to apply a 20% discount on them. We loop over each
    `product` and inspect the expiration date. If the expiration date does not match
    `today` , we do not want to execute the rest of the body, so we execute the `continue`
    statement. Execution of the loop body stops and goes on to the next iteration.
    If we run the `discount.py` module, this is the output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`date`和`timedelta`对象，然后设置我们的产品。那些`sku`为`1`和`3`的产品有一个到期日期为`today`，这意味着我们想要对它们应用20%的折扣。我们遍历每个`product`并检查到期日期。如果到期日期不匹配`today`，我们不想执行体中的其余部分，所以我们执行`continue`语句。循环体的执行停止，继续到下一个迭代。如果我们运行`discount.py`模块，这是输出：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the last two lines of the body have not been executed for `sku`
    number `2` .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于`sku`编号为`2`，体中的最后两行并没有被执行。
- en: 'Let us now see an example of breaking out of a loop. Say we want to tell whether
    at least one of the elements in a list evaluates to `True` when fed to the `bool()`
    function. Given that we need to know whether there is at least one, when we find
    it, we do not need to keep scanning the list any further. In Python code, this
    translates to using the `break` statement. Let us write this down into code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个跳出循环的例子。假设我们想知道列表中的至少一个元素在传递给`bool()`函数时是否评估为`True`。既然我们需要知道是否至少有一个，当我们找到它时，我们就不需要继续扫描列表了。在Python代码中，这相当于使用`break`语句。让我们把这个写下来：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code makes use of a common programming pattern; you set up a
    **flag** variable before starting the inspection of the items. If you find an
    element that matches your criteria (in this example, that evaluates to `True`
    ), you update the flag and stop iterating. After iteration, you inspect the flag
    and act accordingly. Execution yields:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了常见的编程模式；你在开始检查项目之前设置一个**标志**变量。如果你找到一个符合你标准的元素（在这个例子中，评估为`True`），你更新标志并停止迭代。迭代完成后，你检查标志并根据情况采取行动。执行结果如下：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See how execution stopped after `True` was found? The `break` statement is similar
    to `continue` , in that it immediately stops executing the body of the loop, but
    it also prevents any further iterations from running, effectively breaking out
    of the loop.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看执行在找到`True`后是如何停止的？`break`语句与`continue`类似，因为它立即停止执行循环体，但它还阻止了进一步的迭代运行，实际上是从循环中跳出的。
- en: There is no need to write code to detect whether there is at least one element
    in a sequence that evaluates to `True` , as the built-in function `any()` does
    exactly this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要编写代码来检测序列中是否至少有一个元素评估为`True`，因为内置函数`any()`正是做这个。
- en: You can use as many `continue` or `break` statements as you need, anywhere in
    a loop body ( `for` or `while` ). You can even use both in the same loop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在循环体（`for`或`while`）的任何地方使用你需要的任意多个`continue`或`break`语句，你甚至可以在同一个循环中使用两者。
- en: A special else clause
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊的else子句
- en: One of the features we have seen only in the Python language is the ability
    to have an `else` clause after a loop. It is very rarely used, but it is useful
    to have. If the loop ends normally, because of exhaustion of the iterator ( `for`
    loop) or because the condition is finally not met ( `while` loop), then the `else`
    suite (if present) is executed. If execution is interrupted by a `break` statement,
    the `else` clause is not executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python语言中看到的一个独特功能是在循环之后有一个`else`子句。它很少被使用，但很有用。如果循环正常结束，因为迭代器（`for`循环）耗尽或因为条件最终没有满足（`while`循环），那么（如果存在）`else`子句将被执行。如果执行被`break`语句中断，则不会执行`else`子句。
- en: Let us take an example of a `for` loop that iterates over a group of items,
    looking for one that would match some condition. If we do not find at least one
    that satisfies the condition, we want to raise an **exception** . This means that
    we want to arrest the regular execution of the program and signal that there was
    an error, or exception. Exceptions will be the subject of *Chapter 7* , *Exceptions
    and Context Managers* , so do not worry if you do not fully understand them for
    now. Just bear in mind that they alter the regular flow of the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个`for`循环为例，它遍历一组项目，寻找符合某些条件的一个。如果我们找不到至少一个满足条件的，我们希望抛出一个**异常**。这意味着我们希望阻止程序的正常执行，并发出错误或异常的信号。异常将是*第7章*，*异常和上下文管理器*的主题，所以如果你现在不完全理解它们，不要担心。只需记住，它们会改变代码的正常流程。
- en: 'Let us first see how we would do this without the `for...else` syntax. Say
    that we want to find, among a collection of people, one that could drive a car:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看在没有`for...else`语法的情况下会如何做。假设我们想在人群中发现一个能够开车的人：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice the *flag* pattern again. We set the driver to be `None` , and then if
    we find one, we update the `driver` flag. At the end of the loop, we inspect it
    to see whether one was found. Notice that if a driver is not found, `DriverException`
    is raised, signaling to the program that execution cannot continue (we are lacking
    the driver).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意*标志*模式。我们将`driver`设置为`None`，然后如果我们找到一个人，我们更新`driver`标志。在循环结束时，我们检查它以查看是否找到了一个人。注意，如果没有找到驾驶员，将抛出`DriverException`，向程序发出信号，表示无法继续执行（我们缺少驾驶员）。
- en: 'Now, let us see how to do this with an `else` clause on the `for` loop:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`for`循环中使用`else`子句来完成这个操作：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we no longer need the *flag* pattern. The exception is raised as
    part of the loop logic, which makes good sense because the loop checks for some
    condition. All we need to do is set up a `driver` object in case we find one;
    this way the rest of the code uses the `driver` object for further processing.
    Notice that the code is shorter and more elegant because the logic is now correctly
    grouped together, where it belongs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再需要*标志*模式。异常作为循环逻辑的一部分被抛出，这很有意义，因为循环会检查某些条件。我们唯一需要做的是设置一个`driver`对象，以防我们找到它；这样，其余的代码就可以使用`driver`对象进行进一步处理。注意，代码变得更短、更优雅，因为逻辑现在被正确地组合在一起，放在了合适的位置。
- en: 'In his *Transforming Code into Beautiful, Idiomatic Python* video, Raymond
    Hettinger suggests a much better name for the `else` statement associated with
    a `for` loop: `nobreak` . If you struggle with remembering how the `else` works
    for a `for` loop, simply remembering this fact should help you.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的*将代码转换为优美、惯用Python*视频中，Raymond Hettinger建议为与`for`循环关联的`else`语句起一个更好的名字：`nobreak`。如果你在记住`for`循环的`else`是如何工作的方面有困难，只需记住这个事实应该就能帮助你。
- en: Assignment expressions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: Before we look at some more complicated examples, we would like to briefly introduce
    you to a feature that was added to the language in Python 3.8, via PEP 572 ( [https://peps.python.org/pep-0572](https://peps.python.org/pep-0572)
    ). Assignment expressions allow us to bind a value to a name in places where normal
    assignment statements are not allowed. Instead of the normal assignment operator
    `=` , assignment expressions use `:=` (known as the **walrus operator** because
    it resembles the eyes and tusks of a walrus).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些更复杂的例子之前，我们想简要介绍一下Python 3.8中添加的一个功能，该功能通过PEP 572（[https://peps.python.org/pep-0572](https://peps.python.org/pep-0572)）实现。赋值表达式允许我们在不允许正常赋值语句的地方将值绑定到名称上。而不是正常的赋值运算符`=`，赋值表达式使用`:=`（被称为**海象运算符**，因为它与海象的眼睛和獠牙相似）。
- en: Statements and expressions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: 'To understand the difference between normal assignments and assignment expressions,
    we need to understand the difference between statements and expressions. According
    to the Python documentation ( [https://docs.python.org/3.12/glossary.html#term-statement](https://docs.python.org/3.12/glossary.html#term-statement)
    ), a **statement** is:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解正常赋值和赋值表达式之间的区别，我们需要理解语句和表达式之间的区别。根据 Python 文档（[https://docs.python.org/3.12/glossary.html#term-statement](https://docs.python.org/3.12/glossary.html#term-statement)），一个
    **语句** 是：
- en: …part of a suite (a “block” of code). A statement is either an expression or
    one of several constructs with a keyword, such as `if` , `while` or `for` .
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …是代码块（一个“代码块”）的一部分。一个语句要么是一个表达式，要么是具有关键字的一些构造之一，例如 `if`、`while` 或 `for`。
- en: 'An **expression** , on the other hand, is:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个 **表达式** 是：
- en: A piece of syntax which can be evaluated to some value. In other words, an expression
    is an accumulation of expression elements like literals, names, attribute access,
    operators or function calls which all return a value.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个可以评估为某个值的语法。换句话说，一个表达式是像字面量、名字、属性访问、运算符或函数调用这样的表达式元素的累积，所有这些都会返回一个值。
- en: The key distinguishing feature of an expression is that it has a value. Notice
    that an expression can be a statement, but not all statements are expressions.
    In particular, assignments like `name = "heinrich"` are not expressions, so they
    do not have a value. This means that you cannot use an assignment statement in
    the condition expression of a `while` loop or `if` statement (or any other place
    where a value is required).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的关键区分特征是它有一个值。注意，一个表达式可以是一个语句，但并不是所有的语句都是表达式。特别是，像 `name = "heinrich"` 这样的赋值不是表达式，因此它们没有值。这意味着你不能在
    `while` 循环或 `if` 语句的条件表达式中（或任何需要值的地方）使用赋值语句。
- en: 'This explains why the Python console does not print a value when you assign
    a value to a name. For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当你在 Python 控制台中给一个名字赋值时，它不会打印值的原因。例如：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: is a statement, which does not have a return value to print.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个语句，它没有返回值以打印。
- en: Using the walrus operator
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 walrus 运算符
- en: 'Without assignment expressions, you would have to use two separate statements
    if you wanted to bind a value to a name and use that value in an expression. For
    example, it is quite common to see code like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将一个值绑定到一个名字并使用该值在一个表达式中，没有赋值表达式，你就必须使用两个独立的语句。例如，我们经常看到这样的代码：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With assignment expressions, we could rewrite this as:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用赋值表达式，我们可以将这段代码重写为：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Assignment expressions allow us to write fewer lines of code. Used with care,
    they can also lead to cleaner, more understandable code. Let us look at a slightly
    bigger example to see how an assignment expression can simplify a `while` loop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式允许我们编写更少的代码行。谨慎使用，它们还可以使代码更简洁、更易于理解。让我们看一个稍微大一点的例子，看看赋值表达式如何简化 `while`
    循环。
- en: 'In interactive scripts, we often need to ask a user to choose between a number
    of options. For example, suppose we are writing an interactive script that allows
    customers at an ice cream shop to choose what flavor they want. To avoid confusion
    when preparing orders, we want to ensure that the user chooses one of the available
    flavors. Without assignment expressions, we might write something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式脚本中，我们经常需要让用户在多个选项之间进行选择。例如，假设我们正在编写一个交互式脚本，允许冰淇淋店的顾客选择他们想要的口味。为了避免在准备订单时产生混淆，我们希望确保用户选择了一个可用的口味。如果没有赋值表达式，我们可能会写出类似这样的代码：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Take a moment to read this code carefully. Note the condition on the loop:
    `while True` means “loop forever,” which is not what we want. We want to stop
    the loop when the user inputs a valid flavor ( `choice in flavors` ). To achieve
    that, we have an `if` statement and a `break` inside the loop. The logic to control
    the loop is not immediately obvious. Despite that, this is actually quite a common
    pattern when the value needed to control the loop can only be obtained inside
    it.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间仔细阅读这段代码。注意循环的条件：`while True` 表示“无限循环”，这并不是我们想要的。我们希望在用户输入一个有效的口味（`choice
    in flavors`）时停止循环。为了实现这一点，我们在循环中有一个 `if` 语句和一个 `break`。控制循环的逻辑并不立即明显。尽管如此，当需要控制循环的值只能在循环内部获得时，这实际上是一种相当常见的模式。
- en: The `input()` function is very useful in interactive scripts. It prompts the
    user for input and returns it as a string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数在交互式脚本中非常有用。它提示用户输入并返回一个字符串。'
- en: 'How can we improve on this? Let us try to use an assignment expression:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进这一点？让我们尝试使用赋值表达式：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, the loop conditional says exactly what we want. That is much easier to
    understand. The code is also three lines shorter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环条件正好是我们想要的。这要容易理解得多。代码也短了三行。
- en: We need parentheses around the assignment expression in this example because
    the `:=` operator has lower precedence than the `not in` operator. Try removing
    them and see what happens.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要在赋值表达式周围加上括号，因为 `:=` 运算符的优先级低于 `not in` 运算符。试着去掉它们，看看会发生什么。
- en: We have seen examples of using assignment expressions in `if` and `while` statements.
    Besides these use cases, assignment expressions are also useful in *lambda expressions*
    (which you will meet in *Chapter 4* , *Functions, the Building Blocks of Code*
    ), as well as *comprehensions* and *generators* (which you will learn about in
    *Chapter 5* , *Comprehensions and Generators* ).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在`if`和`while`语句中使用赋值表达式的例子。除了这些用例之外，赋值表达式在*lambda表达式*（你将在*第4章*，*函数，代码的构建块*中遇到）以及*推导式*和*生成器*（你将在*第5章*，*推导式和生成器*中学习）中也非常有用。
- en: A word of warning
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个警告
- en: The introduction of the walrus operator in Python was somewhat controversial.
    Some people feared that it would make it too easy to write ugly, non-Pythonic
    code. We think that these fears are not entirely justified. As you saw above,
    the walrus operator can *improve* code and make it easier to read. Like any powerful
    feature, it can, however, be abused to write *obfuscated* code. We would advise
    you to use it sparingly. Always think carefully about how it impacts the readability
    of your code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python中引入walrus运算符有些有争议。有些人担心这会让编写丑陋的非Pythonic代码变得过于容易。我们认为这些担忧并不完全合理。正如你上面看到的，walrus运算符可以*改进*代码并使其更容易阅读。然而，像任何强大的功能一样，它也可能被滥用来编写*晦涩难懂*的代码。我们建议你谨慎使用。始终仔细思考它对你的代码可读性的影响。
- en: Putting all this together
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有这些放在一起
- en: Now that we have covered the basics of conditionals and loops, we can move on
    to the example programs we promised at the beginning of this chapter. We will
    mix and match here so that you can see how you can use all these concepts together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了条件语句和循环的基础，我们可以继续到本章开头承诺的示例程序。我们将混合使用，这样你就可以看到如何将这些概念一起使用。
- en: A prime generator
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个素数生成器
- en: Let us start by writing some code to generate a list of prime numbers up to
    (and including) some limit. Please bear in mind that we are going to write a very
    inefficient and rudimentary algorithm to find prime numbers. The important thing
    is to concentrate on those bits in the code that belong to this chapter’s subject.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写一些代码来生成一个包含素数的列表，直到（包括）某个限制。请记住，我们将编写一个非常低效和原始的算法来寻找素数。重要的是要专注于代码中属于本章主题的部分。
- en: 'According to Wolfram MathWorld:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Wolfram MathWorld：
- en: A **prime number** (or prime integer, often simply called a “ **prime** ” for
    short) is a positive integer p>1 that has no positive integer divisors other than
    1 and p itself. More concisely, a prime number p is a positive integer having
    exactly one positive divisor other than 1, meaning it is a number that cannot
    be factored.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**素数**（或素整数，通常简称为“**素数**”）是一个大于1的正整数p，它除了1和它本身之外没有其他正整数除数。更简洁地说，素数p是一个只有一个正除数（除了1）的正整数，这意味着它是一个不能分解的数。'
- en: Based on this definition, if we consider the first 10 natural numbers, we can
    see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, and 10 are not. To determine
    whether a number, *N* , is prime, you can divide it by each of the natural numbers
    in the range *[2, N)* . If the remainder of any division is zero, then the number
    is not a prime.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，如果我们考虑前10个自然数，我们可以看到2、3、5和7是素数，而1、4、6、8、9和10不是。要确定一个数，*N*，是否为素数，你可以将它除以范围*[2,
    N)*内的每一个自然数。如果任何除法的余数为零，则该数不是素数。
- en: 'To generate the sequence of prime numbers, we will consider each natural number,
    starting from two, up to the limit, and test whether it is a prime. We will write
    two versions of this, the second of which will exploit the `for...else` syntax:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成素数的序列，我们将考虑从2开始的自然数，直到限制，并测试它是否是素数。我们将编写两个版本，第二个版本将利用`for...else`语法：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is quite a lot happening in this code. We start by setting up an empty
    `primes` list, which will contain the primes at the end. We set the limit to `100`
    , and because we want it to be inclusive, we have to iterate over `range(2, upto
    + 1)` in our outer `for` loop (remember that `range(2, upto)` *would stop at upto
    - 1* ). The outer loop iterates over the candidate primes—that is, all natural
    numbers from `2` to `upto` . Each iteration of this loop tests one number to determine
    whether it is a prime. In each iteration of the outer loop, we set up a flag (which
    is set to `True` at each iteration), and then start dividing the current value
    of `n` by all numbers from `2` to `n - 1` . If we find a proper divisor for `n`
    , it means `n` is composite, so we set the flag to `False` and break the loop.
    Notice that when we break the inner loop, the outer one keeps on going as normal.
    The reason we break after having found a proper divisor for `n` is that we do
    not need any further information to be able to tell that `n` is not a prime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中发生了很多事情。我们首先设置一个空的`primes`列表，它将包含最后的素数。我们将限制设置为`100`，因为我们希望它是包含的，所以我们必须在最外层`for`循环中遍历`range(2,
    upto + 1)`（记住`range(2, upto)`*将停止在`upto - 1`*）。最外层循环遍历候选素数——即从`2`到`upto`的所有自然数。这个循环的每次迭代都会测试一个数字，以确定它是否是素数。在最外层循环的每次迭代中，我们设置一个标志（每次迭代都设置为`True`），然后开始将当前值`n`除以从`2`到`n
    - 1`的所有数字。如果我们找到`n`的一个合适的除数，这意味着`n`是合数，因此我们将标志设置为`False`并退出循环。请注意，当我们退出内层循环时，外层循环会像往常一样继续进行。我们在找到`n`的合适除数后退出是因为我们不需要任何进一步的信息就能判断出`n`不是素数。
- en: When we check the `is_prime` flag after the inner loop, if it is still `True`
    , it means we could not find any number in *[2, n)* that is a proper divisor for
    `n` ; therefore, `n` is a prime. We append `n` to the `primes` list and proceed
    to the next iteration, until `n` equals `100` .
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在内层循环之后检查`is_prime`标志，如果它仍然是`True`，这意味着我们在*[2, n)*范围内没有找到任何是`n`的合适除数的数字；因此，`n`是素数。我们将`n`添加到`primes`列表中，并继续下一次迭代，直到`n`等于`100`。
- en: 'Running this code outputs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会输出：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Before proceeding, we will pose the following question: one of the iterations
    of the outer loop is different from the rest. Can you tell which iteration this
    is—and why? Think about it for a moment, go back to the code, try to work it out
    for yourself, and then keep reading.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将提出以下问题：外层循环的某次迭代与其他迭代不同。你能指出这是哪一次迭代——为什么？花一点时间思考一下，回到代码中，尝试自己解决它，然后再继续阅读。
- en: 'Did you find the answer? Do not feel bad if you did not, the skill to understand
    what the code does by simply looking at it takes time and experience to learn.
    It is an important skill to have as a programmer though, so try to exercise it
    whenever you can. We will tell you the answer now: the first iteration behaves
    differently from all the others. The reason is that in the first iteration, `n`
    is `2` . Therefore, the innermost `for` loop will not run at all because it is
    a `for` loop that iterates over `range(2, 2)` , which is an empty range. Try it
    yourself, write a simple `for` loop with that iterable, put a `print` in the body,
    and see what happens when you run it.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到答案了吗？如果你没有找到，请不要感到难过，仅通过观察代码就能理解其功能的技能需要时间和经验来学习。尽管如此，这对于程序员来说是一个重要的技能，所以尽量在可能的情况下练习它。现在我们将告诉你答案：第一次迭代与其他所有迭代的行为不同。原因是第一次迭代中，`n`是`2`。因此，最内层的`for`循环根本不会运行，因为它是一个遍历`range(2,
    2)`的`for`循环，这是一个空的范围。自己试一试，写一个简单的`for`循环，使用那个可迭代对象，在循环体中放一个`print`语句，看看运行时会发生什么。
- en: 'We are not going to try to make this code more efficient from an algorithmic
    point of view. But let us use some of what we learned in this chapter to at least
    make it easier to read:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会尝试从算法的角度使此代码更高效。但让我们利用本章所学的一些知识，至少让它更容易阅读：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using an `else` clause on the inner loop allows us to get rid of the `is_prime`
    flag. Instead, we append `n` to the `primes` list when we know that the inner
    loop has not encountered any `break` statements. It is only two lines shorter,
    but the code is simpler, cleaner, and reads better. This is important, as simplicity
    and readability count for a lot in programming. Always look for ways to simplify
    your code and make it easier to read. You will thank yourself when you return
    to it months later and have to try to understand what you did before.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在内层循环中使用`else`子句，我们可以去除`is_prime`标志。相反，当我们知道内层循环没有遇到任何`break`语句时，我们将`n`添加到`primes`列表中。这仅仅减少了两个代码行，但代码更简单、更干净，也更易于阅读。这在编程中非常重要，因为简洁性和可读性非常重要。始终寻找简化代码并使其更容易阅读的方法。当你几个月后再次回到它时，你将感谢自己当时所做的努力，以便试图理解你之前做了什么。
- en: Applying discounts
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用折扣
- en: 'In this example, we want to show you a technique called a **lookup table**
    , which we are very fond of. We will start by simply writing some code that assigns
    a discount to customers based on their coupon value. We will keep the logic down
    to a minimum here—remember that all we really care about is understanding conditionals
    and loops:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想向您展示一种称为**查找表**的技术，我们非常喜欢。我们将从简单地编写一些代码开始，根据客户的优惠券价值为它们分配折扣。我们将尽量简化逻辑——记住，我们真正关心的是理解条件语句和循环：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We start by setting up some customers. They have an order total, a coupon code,
    and an ID. We made up four types of coupons: two are for fixed amounts and two
    are percentage-based. We use a `match` statement, with a `case` for each coupon
    code and a wildcard to handle invalid coupons. We compute the discount and set
    it as the `"discount"` key in the `customer` dictionary.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些客户。他们有一个订单总额、一个优惠券代码和一个ID。我们编造了四种类型的优惠券：两种是固定金额的，两种是基于百分比的。我们使用一个`match`语句，每个优惠券代码都有一个`case`，以及一个通配符来处理无效的优惠券。我们计算折扣，并将其设置为`customer`字典中的`"discount"`键。
- en: 'Finally, we just print out part of the data to see whether our code works properly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只打印出部分数据，以查看我们的代码是否正常工作：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code is simple to understand, but all those `match` cases are cluttering
    the logic. Adding more coupon codes requires adding additional cases and implementing
    the discount calculation for each case. The discount calculation is very similar
    in most cases, which makes the code repetitive and violates the **Don’t Repeat
    Yourself** ( **DRY** ) principle. In cases like this, you can use a dictionary
    to your advantage, like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码易于理解，但所有这些`match`情况都在逻辑上造成了混乱。添加更多优惠券代码需要添加额外的案例，并为每个案例实现折扣计算。在大多数情况下，折扣计算非常相似，这使得代码重复，违反了**不要重复自己**（**DRY**）原则。在这种情况下，你可以利用字典的优势，如下所示：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Running the preceding code produces exactly the same output as the snippet before
    it. The code is two lines shorter, but more importantly, we gained a lot in readability,
    as the body of the `for` loop is now just three lines long and easy to understand.
    The key idea here is to use a dictionary as a **lookup table** . In other words,
    we try to fetch something (the parameters for the discount calculation) from the
    dictionary based on a code (our `coupon_code` ). We use `dict.get(key, default)`
    to ensure that we can handle codes that are not in the dictionary, by supplying
    a default value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生与之前代码片段完全相同的输出。代码减少了两个代码行，但更重要的是，我们在可读性方面取得了很大的进步，因为`for`循环的主体现在只有三行长，易于理解。这里的关键思想是使用字典作为**查找表**。换句话说，我们尝试根据代码（我们的`coupon_code`）从字典中获取一些东西（折扣计算的参数）。我们使用`dict.get(key,
    default)`来确保我们可以处理不在字典中的代码，并提供一个默认值。
- en: Aside from readability, another major advantage of this approach is that we
    can easily add new coupon codes (or remove old ones) without changing the implementation;
    we only need to change the *data* in the lookup table. In a real-world application,
    we could even store the lookup table in a database and provide an interface for
    users to add or remove coupon codes at runtime.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可读性之外，这种方法的另一个主要优点是，我们可以轻松地添加新的优惠券代码（或删除旧的代码），而无需更改实现；我们只需要更改查找表中的`*数据*`。在实际应用中，我们甚至可以将查找表存储在数据库中，并为用户提供一个界面，以便在运行时添加或删除优惠券代码。
- en: Notice that we had to apply some simple linear algebra to calculate the discount.
    Each discount has a percentage and fixed part in the dictionary, represented by
    a two-tuple. By applying `percent * total + fixed` , we get the correct discount.
    When `percent` is `0` , the formula just gives the fixed amount, and it gives
    `percent * total` when `fixed` is `0` .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不应用一些简单的线性代数来计算折扣。每个折扣在字典中都有一个百分比和固定部分，由一个二元组表示。通过应用 `percent * total
    + fixed`，我们得到正确的折扣。当 `percent` 为 `0` 时，公式仅给出固定金额；当 `fixed` 为 `0` 时，它给出 `percent
    * total`。
- en: This technique is closely related to **dispatch tables** , which store functions
    as values in a table. This allows for even greater flexibility. Some object-oriented
    programming languages use this technique internally to implement features such
    as virtual methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与 **调度表** 非常相关，调度表将函数作为表中的值存储。这提供了更大的灵活性。一些面向对象的编程语言在内部使用这种技术来实现诸如虚拟方法等特性。
- en: If you are still unclear as to how this works, we suggest you take your time
    and experiment with it. Change values and add `print()` statements to see what
    is going on while the program is running.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚这是如何工作的，我们建议你花些时间亲自实验。更改值并添加 `print()` 语句，以查看程序运行时的具体情况。
- en: A quick peek at the itertools module
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览 itertools 模块
- en: 'A chapter about iterables, iterators, conditional logic, and looping would
    not be complete without a few words about the `itertools` module. According to
    the Python official documentation ( [https://docs.python.org/3.12/library/itertools.html](https://docs.python.org/3.12/library/itertools.html)
    ), the `itertools` module:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一章关于可迭代对象、迭代器、条件逻辑和循环的内容，如果没有几句话关于 `itertools` 模块，就不会完整。根据 Python 官方文档（[https://docs.python.org/3.12/library/itertools.html](https://docs.python.org/3.12/library/itertools.html)），`itertools`
    模块：
- en: …implements a number of iterator building blocks inspired by constructs from
    APL, Haskell, and SML. Each has been recast in a form suitable for Python.
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …实现了许多由 APL、Haskell 和 SML 构造启发的迭代器构建块。每个构建块都已被重新塑形，以适应 Python。
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The module standardizes a core set of fast, memory efficient tools that are
    useful by themselves or in combination. Together, they form an “iterator algebra”
    making it possible to construct specialized tools succinctly and efficiently in
    pure Python.
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该模块标准化了一组快速、内存高效的工具，这些工具本身或组合使用都很有用。它们共同构成了一种“迭代器代数”，使得在纯 Python 中简洁且高效地构建专用工具成为可能。
- en: We do not have room here to show you everything this module has to offer, so
    we encourage you to explore it further for yourself. However, we can promise that
    you will enjoy it. It provides you with three broad categories of iterators. As
    an introduction, we shall give you a small example of one iterator taken from
    each category.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有足够的空间向您展示这个模块所能提供的一切，所以我们鼓励您自己进一步探索。然而，我们可以保证您会喜欢它。它为您提供了三种广泛的迭代器类别。作为介绍，我们将给出每个类别中一个迭代器的小示例。
- en: Infinite iterators
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限迭代器
- en: 'Infinite iterators allow you to use a `for` loop as an infinite loop, iterating
    over a sequence that never ends:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器允许你使用 `for` 循环作为无限循环，遍历一个永远不会结束的序列：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the code outputs:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码输出：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `count` factory class makes an iterator that simply goes on and on counting.
    In this example, it starts from `5` and keeps adding `3` at every iteration. We
    need to break it manually if we do not want to get stuck in an infinite loop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 工厂类创建一个简单的迭代器，它不断地计数。在这个例子中，它从 `5` 开始，每次迭代都增加 `3`。如果我们不想陷入无限循环，我们需要手动停止它。'
- en: Iterators terminating on the shortest input sequence
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入序列最短时终止的迭代器
- en: 'This category is quite interesting. It allows you to create an iterator based
    on multiple iterators, combining their values according to some logic. The key
    point here is that the resulting iterator will not break if one of the input iterators
    is shorter than the rest. It will simply stop as soon as the shortest iterator
    is exhausted. This may seem rather abstract, so let us give you an example using
    `compress()` . This iterator takes a sequence of *data* and a sequence of *selectors*
    , yielding only those values from the data sequence that correspond to `True`
    values in the selectors sequence. For example, `compress("ABC", (1, 0, 1))` would
    give back `"A"` and `"C"` because they correspond to `1` . Let us see a simple
    example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别非常有趣。它允许您基于多个迭代器创建一个迭代器，根据某些逻辑组合它们的值。关键点在于，如果其中一个输入迭代器比其他迭代器短，结果迭代器不会中断。它会在最短的迭代器耗尽时停止。这听起来可能相当抽象，所以让我们用一个
    `compress()` 的例子来说明。这个迭代器接受一个 *data* 序列和一个 *selectors* 序列，只产生与 selectors 序列中的
    `True` 值相对应的数据序列中的值。例如，`compress("ABC", (1, 0, 1))` 会返回 `"A"` 和 `"C"`，因为它们对应于
    `1`。让我们看看一个简单的例子：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that `odd_selector` and `even_selector` are 20 elements in length, while
    `data` is only 10. `compress()` will stop as soon as `data` has yielded its last
    element. Running this code produces the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `odd_selector` 和 `even_selector` 的长度都是 20 个元素，而 `data` 只有 10 个。`compress()`
    函数会在 `data` 产生最后一个元素时停止。运行此代码会产生以下结果：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is a fast and convenient way of selecting elements out of an iterable. The
    code is simple, but notice that instead of using a `for` loop to iterate over
    each value that is given back by the `compress()` calls, we used `list()` , which
    does the same, but instead of executing a body of instructions, it puts all the
    values into a list and returns it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速方便地从可迭代对象中选择元素的方法。代码很简单，但请注意，我们不是使用 `for` 循环来遍历 `compress()` 调用返回的每个值，而是使用了
    `list()`，它做的是同样的事情，但它不是执行一系列指令，而是将所有值放入一个列表中并返回它。
- en: Combinatoric generators
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合生成器
- en: 'The third category of iterators from `itertools` is combinatoric generators.
    Let us look at a simple example of permutations. According to Wolfram MathWorld:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 的第三类迭代器是组合生成器。让我们看看排列的一个简单例子。根据 Wolfram MathWorld：'
- en: A permutation, also called an “arrangement number” or “order,” is a rearrangement
    of the elements of an ordered list S into a one-to-one correspondence with S itself.
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 排列，也称为“排列数”或“顺序”，是将有序列表 S 的元素重新排列，使其与 S 本身形成一一对应关系。
- en: 'For example, there are six permutations of `ABC` : `ABC` , `ACB` , `BAC` ,
    `BCA` , `CAB` , and `CBA` .'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ABC` 有六种排列：`ABC`、`ACB`、`BAC`、`BCA`、`CAB` 和 `CBA`。
- en: 'If a set has *N* elements, then the number of permutations of them is *N!*
    ( *N* factorial). For example, the string `ABC` has *3! = 3 * 2 * 1 = 6* permutations.
    Let us see this in Python:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个集合有 *N* 个元素，那么这些元素的排列数是 *N!*（*N* 的阶乘）。例如，字符串 `ABC` 有 *3! = 3 * 2 * 1 = 6*
    种排列。让我们用 Python 来看看这个例子：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This short snippet of code produces the following result:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的代码会产生以下结果：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Be careful when you play with permutations. Their number grows at a rate that
    is proportional to the factorial of the number of elements you are permuting,
    and that number can get really big, really fast.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩排列时请小心。它们的数量以与您正在排列的元素数量的阶乘成比例的速度增长，而且这个数字可以变得非常大，非常快。
- en: There is a third-party library that expands on the `itertools` module, called
    `more-itertools` . You can find its documentation at [https://more-itertools.readthedocs.io/](https://more-itertools.readthedocs.io/)
    .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `more-itertools` 的第三方库扩展了 `itertools` 模块。您可以在 [https://more-itertools.readthedocs.io/](https://more-itertools.readthedocs.io/)
    找到它的文档。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken another step toward expanding our Python vocabulary.
    We have seen how to drive the execution of code by evaluating conditions, along
    with how to loop and iterate over sequences and collections of objects. This gives
    us the power to control what happens when our code is run, which means we get
    an idea of how to shape it so that it does what we want, having it react to data
    that changes dynamically.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们朝着扩展我们的 Python 词汇表又迈出了另一步。我们看到了如何通过评估条件来驱动代码的执行，以及如何循环遍历序列和对象集合。这赋予了我们控制代码运行时发生什么的能力，这意味着我们得到了如何塑造它以实现我们想要的功能，并使其能够对动态变化的数据做出反应的想法。
- en: We have also seen how to combine everything together in a couple of simple examples,
    and finally, we took a brief look at the `itertools` module, which is full of
    interesting iterators that can enrich our abilities with Python to a greater degree.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了如何在几个简单的例子中将所有内容结合起来，最后，我们简要地浏览了 `itertools` 模块，它充满了有趣的迭代器，可以让我们用 Python
    的能力得到更大的丰富。
- en: Now, it is time to switch gears, take another step forward, and talk about functions.
    The next chapter is all about them, and they are extremely important. Make sure
    you are comfortable with what has been covered so far. We want to provide you
    with interesting examples, so let’s go.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候转换方向，再迈出一步，来谈谈函数。下一章全部都是关于它们的，它们非常重要。确保你对到目前为止的内容感到舒适。我们想给你提供一些有趣的例子，让我们开始吧。
- en: Join our community on Discord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_3.xhtml)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_3.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
