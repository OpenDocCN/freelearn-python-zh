- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP, Decorators, and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”La classe non è acqua.” (“Class will out.”)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Italian saying
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Object-oriented programming (OOP)** is such a vast topic that entire books
    have been written about it. In this chapter, we face the challenge of finding
    the balance between breadth and depth. There are simply too many things to discuss,
    and plenty of them would take more than this whole chapter if we described them
    in depth. Therefore, we will try to give you what we think is a good panoramic
    view of the fundamentals, plus a few things that may come in handy in the next
    chapters. Python’s official documentation will help to fill the gaps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5* , *Comprehensions and Generators* , we measured the execution
    time of various expressions.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we had to capture the start time and subtract it from the current
    time after execution to calculate the elapsed time. We also printed it on the
    console after each measurement. That was impractical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we find ourselves repeating things, an alarm bell should go off.
    Can we put that code in a function and avoid repetition? Most of the time, the
    answer is, *yes* , so let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined two functions, `f()` and `g()` , which do
    nothing but sleep (for 0.3 and 0.5 seconds, respectively). We used the `sleep()`
    function to suspend the execution for the desired amount of time. Notice how the
    time measure is pretty accurate. Now, how do we avoid repeating that code and
    those calculations? One first potential approach could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better. The whole timing mechanism has been encapsulated in a function,
    so we do not repeat code. We print the function name dynamically and the code
    is straightforward. What if we needed to pass any arguments to the function we
    measure? This code would get just a bit more complex. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, `f()` expects to be fed `sleep_time` (with a default value of 0.1), so
    we do not need `g()` anymore. We also had to change the `measure()` function so
    that it now accepts a function, any variable positional arguments, and any variable
    keyword arguments. This way, whatever we call `measure()` with, we redirect those
    arguments to the call to `func()` that we do inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, but we can improve it a little. Let us say that we somehow want
    to have that timing behavior built into the `f()` function, enabling us to just
    call it and have that measure taken. Here is how we could do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is not so straightforward. Let us see what happens here.
    The magic is in the *decoration point* . We reassign `f()` with whatever is returned
    by `measure()` when we call it with `f()` as an argument. Within `measure()` ,
    we define another function, `wrapper()` , and then we return it. So the net effect
    is that after the decoration point, when we call `f()` , we are actually calling
    `wrapper()` (you can witness this in the last line of code). Since the `wrapper()`
    inside calls `func()` , which in this case is a reference to `f()` , we close
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `wrapper()` function is, not surprisingly, a wrapper. It takes variable
    positional and keyword arguments and calls `f()` with them. It also does the time
    measurement calculation around the call.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is called **decoration** , and `measure()` is, effectively, a
    **decorator** . This paradigm became so popular and widely used that, in version
    2.4, Python added a special syntax for it. You can read the specifics in PEP 318
    ( [https://peps.python.org/pep-0318/](https://peps.python.org/pep-0318/) ). In
    Python 3.0, we saw PEP 3129 ( [https://peps.python.org/pep-3129/](https://peps.python.org/pep-3129/)
    ) defining class decorators. Finally, in Python 3.9, the decorator syntax was
    slightly amended to relax some grammar restrictions; this change was brought about
    in PEP 614 ( [https://peps.python.org/pep-0614/](https://peps.python.org/pep-0614/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now explore three cases: one decorator, two decorators, and one decorator
    that takes arguments. First, the single decorator case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of manually reassigning the function to what was returned by the decorator,
    we prepend the definition of the function with the special syntax, `@decorator_name`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply multiple decorators to the same function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When applying multiple decorators, it is important to pay attention to the order.
    In the preceding example, `func()` is decorated with `deco2()` first, and the
    result is decorated with `deco1()` . A good rule of thumb is *the closer the decorator
    is to the function, the sooner it is applied* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we give you another example, let us fix the issue with the function
    name. Take a look at the highlighted section in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t want to lose the original function’s name and docstring when we decorate
    it. But because `f` , the decorated function, is reassigned to `wrapper` , its
    original attributes are lost, replaced with those of `wrapper()` . There is an
    easy fix for that from the `functools` module. We will fix the issue and rewrite
    the code to use the `@` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All looks good. As you can see, all we need to do is to tell Python that `wrapper`
    actually wraps `func()` (by means of the `wraps()` function in the highlighted
    portion of the code above), and you can see that the original name and docstring
    are maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the full list of function attributes that are reassigned by `func()` ,
    please check the official documentation for the `functools.update_wrapper()` function
    here: [https://docs.python.org/3/library/functools.html?#functools.update_wrapper](https://docs.python.org/3/library/functools.html?#functools.update_wrapper)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see another example. We want a decorator that prints an error message
    when the result of a function is greater than a certain threshold. We will also
    take this opportunity to show you how to apply two decorators at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We had to enhance the `measure()` decorator so that its `wrapper()` now returns
    the result of the call to `func()` . The `max_result()` decorator does that as
    well, but before returning, it checks that `result` is not greater than `100`
    , which is the maximum allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We decorated `cube()` with both of them. First, `max_result()` is applied,
    and then `measure()` . Running this code yields this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For your convenience, we have separated the results of the two calls with a
    blank line. In the first call, the result is 8, which passes the threshold check.
    The running time is measured and printed. Finally, we print the result ( `8` ).
  prefs: []
  type: TYPE_NORMAL
- en: On the second call, the result is 125, so the error message is printed and the
    result returned; then it is the turn of `measure()` , which prints the running
    time again, and finally, we print the result ( `125` ).
  prefs: []
  type: TYPE_NORMAL
- en: Had we decorated the `cube()` function with the same two decorators but in a
    different order, the order of the printed messages would also have been different.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some decorators can take arguments. This technique is generally used to produce
    another decorator (in which case, the object could be called a **decorator factory**
    ). Let us look at the syntax, and then we will see an example of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this case is a bit different. First, `decoarg()` is called with
    the given arguments, and then its return value (the actual decorator) is called
    with `func()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us improve on the example now. We are going back to a single decorator:
    `max_result()` . We want to make it so that we can decorate different functions
    with different thresholds, as we do not want to have to write one decorator for
    each threshold. Therefore, let us amend `max_result()` so that it allows us to
    decorate functions by specifying the threshold dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows you how to write a decorator factory. If you recall,
    decorating a function with a decorator that takes arguments is the same as writing
    `func = decorator(argA, argB)(func)` , so when we decorate `cube()` with `max_result(75)`
    , we are doing `cube = max_result(75)(cube)` .
  prefs: []
  type: TYPE_NORMAL
- en: Let us go through what happens, step by step. When we call `max_result(75)`
    , we enter its body. A `decorator()` function is defined inside the `max_result(75)`
    function, which takes a function as its only argument. Inside that function, we
    find the usual decoration pattern. We define `wrapper()` , inside of which we
    check the result of the original function’s call. The beauty of this approach
    is that from the innermost level, we can still refer to both `func()` and `threshold`
    , which allows us to set the threshold dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: The `wrapper()` function returns `result` , `decorator()` returns `wrapper()`
    , and `max_result()` returns `decorator()` . This means that the `cube = max_result(75)(cube)`
    instruction actually becomes `cube = decorator(cube)` . However, it’s not just
    any `decorator()` but one for which `threshold` has a value of `75` . This is
    achieved by a mechanism called **closure** .
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically created functions that are returned by other functions are called
    **closures** . Their main feature is that they have full access to the variables
    and names defined in the local namespace at the time of their creation, even though
    the enclosing in which they were defined has returned and finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the last example produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code allows us to use the `max_result()` decorator with different
    thresholds, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that every decoration uses a different `threshold` value.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are very popular in Python. They are used quite often, and they make
    code simpler and more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the basics of the decoration pattern have been covered, it is time
    to explore OOP. We will use the definition from *Kindler, E.; Krivy, I. (2011).
    Object-oriented simulation of systems with sophisticated control (International
    Journal of General Systems)* , and adapt it to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** ( **OOP** ) is a programming paradigm based
    on the concept of “objects,” which are data structures that contain data, in the
    form of attributes, and code, in the form of functions known as methods. A distinguishing
    feature of objects is that an object’s method can access and often modify the
    data attributes of the object with which they are associated (objects have a notion
    of “self”). In OO programming, computer programs are designed by making them out
    of objects that interact with one another.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python has full support for this paradigm. Actually, as we have already said,
    *everything in Python is an object* , so this shows that OOP is not just supported
    by Python but is also a core feature of the language.
  prefs: []
  type: TYPE_NORMAL
- en: The two main players in OOP are **objects** and **classes** . Classes are used
    to create objects, and we say that objects are **instances** of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you struggle to understand the difference between objects and classes, think
    of it like this. When you hear the word “pen,” you know exactly what the type
    (or class) of object that the word represents is. However, if we say “this pen,”
    then we’re not referring to a class of objects but, rather, to an “instance” of
    that class: a real object.'
  prefs: []
  type: TYPE_NORMAL
- en: When objects are created from a class, they inherit the class attributes and
    methods. They represent concrete items in the program’s domain.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest Python class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the simplest class you could ever write in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us run the preceding code and explain it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Simplest` class we defined has only the `pass` instruction in its body,
    which means it doesn’t have any custom attributes or methods. We will print its
    type ( `__main__` is the name of the scope in which top-level code executes),
    and we are aware that, in the highlighted comment, we wrote *object* instead of
    *class* . As you can see by the result of that `print` statement, *classes are
    in fact objects themselves* . To be precise, they are instances of `type` . Explaining
    this concept would lead us to a talk about **metaclasses** and **metaprogramming**
    , advanced concepts that require a solid grasp of the fundamentals to be understood
    and are beyond the scope of this chapter. As usual, we mentioned it to leave a
    pointer for you, for when you are ready to explore more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go back to the example: we created `simp` , an instance of the `Simplest`
    class. You can see that the syntax to create an instance is the same as the syntax
    for calling a function. Next, we print what type `simp` belongs to, and we verify
    that `simp` is, in fact, an instance of `Simplest` . We will show you a better
    way of doing this later on in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it has all been very simple. However, what happens when we write `class
    ClassName(): pass` ? Well, what Python does is to create a class object and assign
    it a name. This is very similar to what happens when we declare a function using
    `def` .'
  prefs: []
  type: TYPE_NORMAL
- en: Class and object namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a class object has been created (which usually happens when the module
    is first imported), it represents a namespace. We can call that class to create
    its instances. Each instance inherits the class attributes and methods and is
    given its own namespace. We already know that in order to walk a namespace, all
    we need to do is to use the dot ( `.` ) operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined a **class attribute** called `species`
    . Any name defined in the body of a class becomes an attribute that belongs to
    that class. In the code, we also defined `Person.alive` , which is another class
    attribute. You can see that there is no restriction on accessing that attribute
    from the class. You can see that `man` , which is an instance of `Person` , inherits
    both of them, reflecting them instantly when they change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `man` instance also has two attributes that belong to its own namespace
    and are, therefore, called **instance attributes** : `name` and `surname` .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class attributes** are shared among all instances, while **instance attributes**
    are not; therefore, you should use class attributes to provide the states and
    behaviors to be shared by all instances, and use instance attributes for data
    that will be specific to each individual object.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute shadowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you search for an attribute on an object and cannot find it, Python extends
    the search to the attributes on the object’s class (and keeps searching until
    the attribute is either found or the end of the inheritance chain is reached—more
    on inheritance later). This leads to an interesting shadowing behavior. Let us
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is interesting. We defined a class called `Point` with two
    class attributes, `x` and `y` . When we create an instance of `Point` , `p` ,
    you can see that we can access both `x` and `y` from the `p` namespace ( `p.x`
    and `p.y` ). What happens when we do that is that Python doesn’t find any `x`
    or `y` attributes on the instance, and therefore, it searches the class and finds
    them there.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we give `p` its own `x` attribute by assigning `p.x = 12` . This behavior
    may appear a bit weird at first, but if you think about it, it is exactly the
    same as what happens in a function that declares `x = 12` when there is a global
    `x = 10` outside (see the section about scopes in *Chapter 4* , *Functions, the
    Building Blocks of Code* , for a refresher). We know that `x = 12` won’t affect
    the global one, and for class and instance attributes, it is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: After assigning `p.x = 12` , when we print it, the search does not need to reach
    the class attributes because `x` is found on the instance, so we get `12` printed
    out. We also print `Point.x` , which refers to `x` in the class namespace, to
    show that it is still 10.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delete `x` from the namespace of `p` , which means that, on the next
    line, when we print it again, Python will have to search for it in the class because
    it is no longer found on the instance.
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines show you that assigning attributes to an instance doesn’t
    mean that they will be found in the class. Instances get whatever is in the class,
    but the opposite is not true.
  prefs: []
  type: TYPE_NORMAL
- en: What do you think about putting the `x` and `y` coordinates as class attributes?
    Do you think it was a good idea? What if we created another instance of `Point`
    ? Would that help to show why instance attributes are needed?
  prefs: []
  type: TYPE_NORMAL
- en: The self argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From within a class method, we can refer to an instance by means of a special
    argument, called `self` by convention. `self` is always the first attribute of
    an instance method. Let us examine this behavior, together with how we can share
    not just attributes but also methods with all instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `area()` method is used by `sq` . The two calls, `Square.area(sq)`
    and `sq.area()` , are equivalent, and they teach us how the mechanism works. Either
    you pass the instance to the method call ( `Square.area(sq)` ), which within the
    method will take the name `self` , or you can use a more comfortable syntax, `sq.area()`
    , and Python will translate that for you behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a better example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows us that nothing prevents us from using arguments when
    declaring methods. We can use the exact same syntax as we used with the function,
    but we need to remember that the first argument will always be the instance that
    the method will be bound to. We don’t need to necessarily call it `self` , but
    it is the convention, and this is one of the few cases where it is very important
    to abide by it.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing an instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have you noticed how, before calling `p1.final_price()` in the code above,
    we had to assign `net_price` to `p1` ? There is a better way to do it. In other
    languages, this would be called a **constructor** , but in Python, it is not.
    It is actually an **initializer** , since it works on an already created instance,
    and therefore, it is called `__init__()` . It is a **magic method** , which is
    run right after the object is created. Python objects also have a `__new__()`
    method, which is the actual constructor. However, in practice, it is not so common
    to have to override it; that is a technique that is mostly used when writing metaclasses.
    Let us now see an example of how to initialize objects in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Things are finally starting to take shape. When an object is created, the `__init__()`
    method is run for us automatically. In this case, we wrote it so that when we
    create a `Rectangle` object (by calling the class name like a function), we pass
    arguments to the creation call, like we would on any regular function call. The
    way we pass parameters follows the signature of the `__init__()` method, and therefore,
    in the two creation statements, `10` and `4` will be `side_a` and `side_b` for
    `r1` , while `7` and `3` will be `side_a` and `side_b` for `r2` . You can see
    that the call to `area()` from `r1` and `r2` reflects that they have different
    instance arguments. Setting up objects in this way is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is about code reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, it should be clear: *OOP is all about code reuse* . We define a class,
    we create instances, and those instances can use the methods that are defined
    in the class. They will behave differently according to how the instances have
    been set up by the initializer.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, this is just half of the story; OOP is more than just this. We have
    two main design constructs to use: inheritance and composition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance** means that two objects are related by means of an **Is-A**
    type of relationship. On the other hand, **composition** means that two objects
    are related by means of a **Has-A** relationship. Let us explain with an example,
    where we declare classes for engine types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to declare some car types that will use those engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows you both the **Is-A** and **Has-A** types of relationships.
    First of all, let us consider `Engine` . It is a simple class with two methods,
    `start()` and `stop()` . We then define `ElectricEngine` and `V8Engine` , which
    both inherit from it. You can see this from their definition, which includes `Engine`
    within brackets after the name.
  prefs: []
  type: TYPE_NORMAL
- en: This means that both `ElectricEngine` and `V8Engine` inherit attributes and
    methods from the `Engine` class, which is said to be their **base class** (or
    **parent class** ).
  prefs: []
  type: TYPE_NORMAL
- en: The same happens with cars. `Car` is a base class for both `RaceCar` and `CityCar`
    . `RaceCar` is also the base class of `F1Car` . Another way of saying this is
    that `F1Car` inherits from `RaceCar` , which inherits from `Car` . Therefore,
    `F1Car` *Is-A* `RaceCar` , and `RaceCar` *Is-A* `Car` . Because of the transitive
    property, we can say that `F1Car` *Is-A* `Car` as well. `CityCar` , too, *Is-A*
    `Car` .
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define `class A(B): pass` , we say that `A` is the *child* of `B` ,
    and `B` is the *parent* of `A` . The *parent* and *base* classes are synonyms,
    and so are *child of* and *derived from* . Also, we say that a class *inherits*
    from another class, or that it *extends* it.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the inheritance mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now go back to the code. Each class has a class attribute, `engine_cls`
    , which is a reference to the engine class that we want to assign to each type
    of car. `Car` has a generic `Engine` , the two race cars have a V8 engine, and
    the city car has an electric one.
  prefs: []
  type: TYPE_NORMAL
- en: When a car is created in the initializer method, `__init__()` , we create an
    instance of whatever engine class is assigned to the car and set it as the `engine`
    instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to have `engine_cls` shared among all class instances because
    it is quite likely that all instances of the same car class will have the same
    kind of engine. On the other hand, it would not be good to have a single engine
    (an instance of any `Engine` class) as a class attribute because that would mean
    sharing one engine among all car instances, which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: The type of relationship between a car and its engine is a *Has-A* type. A car
    *Has-A* engine. This is called **composition** and reflects the fact that objects
    can be composed of many other objects. A car *Has-A* engine, gears, wheels, a
    frame, doors, seats, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When using OOP, it is important to describe objects in this way so that we can
    properly structure our code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we had to avoid having dots in the `class_inheritance.py` script
    name, as dots in module names make imports difficult. Most modules in the source
    code of the book are meant to be run as standalone scripts, so we chose to add
    dots to enhance readability when possible, but in general, you want to avoid dots
    in your module names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave this paragraph, let us verify the correctness of what we stated
    above with another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `car` is just an instance of `Car` , while `racecar` is an instance
    of `RaceCar` (and by extension of `Car` ), and `f1car` is an instance of `F1Car`
    (and of both `RaceCar` and `Car` , by extension). Similarly, a *banana* is an
    instance of *Banana* . But, also, it is a *Fruit* . Also, it is *Food* , right?
    Same concept. To check whether an object is an instance of a class, use the `isinstance()`
    function. It is recommended over sheer type comparison ( `type(object) is Class`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have left out the prints you get when instantiating the cars.
    We saw them in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us also check inheritance. Same setup, but different logic in the `for`
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, we learn that *a class is a subclass of itself* . Check the output
    of the preceding example to see that it matches the explanation we provided.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, by convention, class names are written using *CapWords* , which means
    *ThisWayIsCorrect* , as opposed to functions and methods, which are written in
    snake case, like *this_way_is_correct* . Also, if you want to use a name in your
    code that clashes with a Python-reserved keyword or a built-in function or class,
    the convention is to add a trailing underscore to the name. In the first *for
    loop* example, we loop through the class names using `for class_ in ...` because
    `class` is a reserved word. You can refresh your knowledge about conventions by
    reading PEP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help illustrate the difference between *Is-A* and *Has-A* , look at the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Is-A versus Has-A relationships'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a base class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen class declarations, such as `class ClassA: pass` and `class
    ClassB(BaseClassName): pass` . When we don’t specify a base class explicitly,
    Python will set the built-in **object** class as the base class. Ultimately, all
    classes derive from `object` . Please remember that, if you do not specify a base
    class, brackets are optional and, in practice, are never used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, writing `class A: pass` or `class A(): pass` or `class A(object):
    pass` are all equivalent. The `object` class is a special class in that it hosts
    the methods that are common to all Python classes, and it does not allow you to
    set any attributes on it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how we can access a base class from within a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the preceding code. Three of the input parameters for `Book`
    are duplicated in `Ebook` . This is bad practice because we now have two sets
    of instructions that are doing the same thing. Moreover, any change in the signature
    of `Book.__init__()` will not be reflected in `Ebook` . Normally, we want changes
    in a base class to be reflected in its children. Let us see one way to fix this
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Much better. We have removed that code duplication. In this example, we tell
    Python to call the `__init__()` method of the `Book` class; we feed `self` to
    that call, making sure that we bind it to the present instance.
  prefs: []
  type: TYPE_NORMAL
- en: If we modify the logic within the `__init__()` method of `Book` , we do not
    need to touch `Ebook` ; the change will transfer automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is good, but it still suffers from a minor issue. Say that we
    change the name of `Book` to `Liber` , which is the Latin word for “book.” We
    would then have to change the `__init__()` method of `Ebook` to reflect that change.
    This can be avoided by using `super` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`super()` is a function that returns a proxy object that delegates method calls
    to a parent or sibling class.'
  prefs: []
  type: TYPE_NORMAL
- en: Two classes are siblings if they share the same parents.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `super()` will delegate the call to `Book.__init__()` , and the
    beauty of this approach is that now we are free to change `Book` to `Liber` without
    having to touch the logic in the `__init__()` method of `Ebook` at all.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to access a base class from its child, let us explore Python’s
    multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, we are allowed to define classes that inherit from more than one
    base class. This is called **multiple inheritance** . When a class has more than
    one base class, attribute search can follow more than one path. Take a look at
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: A class inheritance diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `Shape` and `Plotter` act as base classes for all the others.
    `Polygon` inherits directly from them, `RegularPolygon` inherits from `Polygon`
    , and both `RegularHexagon` and `Square` inherit from `RegularPolygon` . Note
    also that `Shape` and `Plotter` implicitly inherit from `object` , so from `Polygon`
    up to `object` , we have what is known as a **diamond.** In simpler terms, we
    have more than one path to reach a base class. We will see why this matters in
    a few moments. Let us translate the diagram into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the preceding code: the `Shape` class has one attribute, `geometric_type`
    , and two methods, `area()` and `get_geometric_type()` . It is quite common to
    use base classes (such as `Shape` , in our example) to define an **interface**
    , a set of methods for which children must provide an implementation. There are
    different and better ways to do this, but we want to keep this example as simple
    as possible for the time being.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `Plotter` class, which adds the `plot()` method, thereby providing
    plotting capabilities for any class that inherits from it. Of course, the `plot()`
    implementation is just a dummy `print()` in this example. The first interesting
    class is `Polygon` , which inherits from both `Shape` and `Plotter` .
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of polygons, one of which is the regular one, which is
    both equiangular (all angles are equal) and equilateral (all sides are equal),
    so we create the `RegularPolygon` class that inherits from `Polygon` . For a regular
    polygon, where all sides are equal, we can implement a simple `__init__()` method,
    which just takes the length of the side. We create the `RegularHexagon` and `Square`
    classes, which both inherit from `RegularPolygon` .
  prefs: []
  type: TYPE_NORMAL
- en: This structure is quite long, but hopefully, it gives you an idea of how to
    specialize the classification of your objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, please take a look at the last eight lines of code. Note that when we call
    the `area()` method on `hexagon` and `square` , we get the correct area for both.
    This is because they both provide the correct implementation logic for it. Also,
    we can call `get_geometric_type()` on both of them, even though it is not defined
    in their classes, and Python goes all the way up to `Shape` to find an implementation
    for it. Note that, even though the implementation is provided in the `Shape` class,
    the `self.geometric_type()` used for the return value is correctly taken from
    the caller instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot()` method calls are also interesting and show you how you can enrich
    your objects with capabilities they would not otherwise have. This technique is
    very popular in web frameworks such as Django, which provides special classes
    called **mixins** , whose capabilities you can just use out of the box. All you
    need is to define the desired mixin as one of the base classes for your class.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance is powerful, but at the same time, it can get a bit messy,
    so we need to make sure we understand what happens when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: Method resolution order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, we know that when we ask for `someobject.attribute` and `attribute`
    is not found on that object, Python starts searching in the class that `someobject`
    was created from. If it is not there either, Python searches up the inheritance
    chain until either `attribute` is found or the `object` class is reached. This
    is quite simple to understand if the inheritance chain is only made of single-inheritance
    steps, which means that classes have only one parent, all the way up to `object`
    . However, when multiple inheritance is involved, there are cases when it is not
    straightforward to predict which class will be searched next if an attribute is
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides a way to always know the order in which classes are searched
    on attribute lookup: the **method resolution order** ( **MRO** ).'
  prefs: []
  type: TYPE_NORMAL
- en: The MRO is the order in which base classes are searched for a member during
    lookup. Since version 2.3, Python uses an algorithm called **C3** , which guarantees
    monotonicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the MRO for the `Square` class from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To get to the MRO of a class, we can go from the instance to its `__class__`
    attribute, and from that to its `__mro__` attribute. Alternatively, we could have
    used `Square.__mro__` , or `Square.mro()` directly, but if you need to access
    the MRO from an instance, you will have to derive its class dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the only point of doubt is the branching after `Polygon` , where
    the inheritance chain creates two paths: one leads to `Shape` and the other to
    `Plotter` . We know by scanning the MRO for the `Square` class that `Shape` is
    searched before `Plotter` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this important? Well, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Both `B` and `C` inherit from `A` , and `D` inherits from both `B` and `C` .
    This means that the lookup for the `label` attribute can reach the top ( `A` )
    through either `B` or `C` . Depending on which is reached first, we get a different
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this preceding example, we get `''b''` , which is what we were expecting,
    since `B` is the leftmost among the base classes of `D` . But what happens if
    we remove the `label` attribute from `B` ? This would be a confusing situation:
    will the algorithm go all the way up to `A` or will it get to `C` first? Let us
    find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So we learn that the MRO is `D->B->C->A->object` , which means that when we
    ask for `d.label` , we get `'c'` .
  prefs: []
  type: TYPE_NORMAL
- en: In day-to-day programming, it is not common to have to deal with the MRO, but
    we felt it was important to at least mention it in this paragraph so that, should
    you get entangled in a complex mixins structure, you will be able to find your
    way out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Class and static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have written classes with attributes in the form of data and instance
    methods, but there are two other types of methods that we can find in a class
    definition: **static methods** and **class methods** .'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you create a class object, Python assigns a name to it. That name acts
    as a namespace, and sometimes, it makes sense to group functionalities under it.
    Static methods are perfect for this use case. Unlike instance methods, they do
    not need to be passed an instance when called. Let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite interesting. First, we learn that static methods
    are created by simply applying the `staticmethod` decorator to them. You can see
    that they don’t require any extra arguments, so apart from the decoration, they
    just look like functions.
  prefs: []
  type: TYPE_NORMAL
- en: We have a class, `StringUtil` , that acts as a container for functions. Another
    approach would be to have a separate module with functions inside. It is really
    a matter of style, most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: The logic inside `is_palindrome()` should be straightforward for you by now,
    but just in case, let us go through it. First, we remove all characters from `s`
    that are neither letters nor numbers. We use the `join()` method of a string object
    to do this. By calling `join()` on an empty string, the result is that all elements
    in the iterable you pass to `join()` will be concatenated together. We feed `join()`
    a generator expression that produces all alphanumeric characters in `s` in order.
    This is a normal procedure when analyzing palindromes.
  prefs: []
  type: TYPE_NORMAL
- en: If `case_insensitive` is `True` , we lowercase `s` . Finally, we proceed to
    check whether `s` is a palindrome. To do this, we compare the first and last characters,
    then the second and the second to last, and so on. If, at any point, we find a
    difference, it means the string isn’t a palindrome, and therefore, we can return
    `False` . On the other hand, if we exit the `for` loop normally, it means no differences
    were found, and we can, therefore, say the string is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this code works correctly regardless of the length of the string—that
    is, if the length is odd or even. The measure `len(s) // 2` reaches half of `s`
    , and if `s` is an odd number of characters long, the middle one won’t be checked
    (for instance, in *RaDaR* , *D* is not checked), but we don’t care, as it would
    be compared to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_unique_words()` method is much simpler: it just returns a set to which
    we feed a list with the words from a sentence. The `set` class removes any duplication
    for us, so we don’t need to do anything else.'
  prefs: []
  type: TYPE_NORMAL
- en: The `StringUtil` class provides us with a container namespace for methods that
    are meant to work on strings. Another example could have been a `MathUtil` class
    with some static methods to work on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Class methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class methods are slightly different from static methods in that, like instance
    methods, they also receive a special first argument. In their case, it is the
    class object itself, rather than the instance. A very common use case for class
    methods is to provide factory capability to a class, which means having alternative
    ways to create instances of the class. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we show you how to use a class method to create a factory
    for the `Point` class. In this case, we want to create a `Point` instance by passing
    both coordinates (regular creation `p = Point(3, 7)` ), but we also want to be
    able to create an instance by passing a tuple ( `Point.from_tuple()` ) or another
    instance ( `Point.from_point()` ).
  prefs: []
  type: TYPE_NORMAL
- en: Within each class method, the `cls` argument refers to the `Point` class. As
    with the instance method, which takes `self` as the first argument, the class
    method takes a `cls` argument. Both `self` and `cls` are named after a convention
    that you are not forced to follow but are strongly encouraged to respect. This
    is something that no professional Python coder would change; it is so strong a
    convention that plenty of tools, such as parsers, linters, and the like, rely
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Class and static methods play well together. Static methods are particularly
    useful for breaking up the logic of a class method to improve its layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example by refactoring the `StringUtil` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this code with the previous version. First of all, note that even though
    `is_palindrome()` is now a class method, we call it in the same way we called
    it when it was a static one. The reason why we changed it to a class method is
    that after factoring out some of its logic (to `_strip_string()` and `_is_palindrome()`
    ), we need to get a reference to those methods, and if we have no `cls` in our
    method, the only option would be to call them by using the name of the class itself,
    like so: `StringUtil._strip_string()` and `StringUtil._is_palindrome()` .'
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not good practice because we would hardcode the class name
    in the `is_palindrome()` method, thereby putting ourselves in the position of
    having to modify it whenever we want to change the class name. Using `cls` means
    it will act as the class name, which means our code won’t need any modifications
    should the class name change.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the new logic reads much better than the previous version. Moreover,
    notice that, by naming the *factored-out* methods with a leading underscore, we
    hint that those methods are not supposed to be called from outside the class,
    but this will be the subject of the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Private methods and name mangling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have any background in languages like Java, C#, or C++, then you know
    that they allow the programmer to assign a privacy status to attributes (both
    data and methods). Each language has its own slightly different flavor for this,
    but the gist is that public attributes are accessible from any point in the code,
    while private ones are accessible only within the scope they are defined in.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is no such thing. Everything is public; therefore, we rely
    on conventions and, for privacy, on a mechanism called **name mangling** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention is as follows: if an attribute’s name has no leading underscores,
    it is considered public. This means you can access it and modify it freely. When
    the name has one leading underscore, the attribute is considered private, which
    means it is intended to be used internally, and you should not modify it or call
    it from the outside. A very common use case for private attributes is helper methods
    that are supposed to be used by public ones (possibly in call chains in conjunction
    with other methods). Another use case is internal data, such as scaling factors,
    or any other data that we would ideally put in a constant, a variable that, once
    defined, cannot change. However, Python has no concept of constants.'
  prefs: []
  type: TYPE_NORMAL
- en: We know some programmers who don’t feel at ease with this aspect of Python.
    In our experience, we have never encountered situations in which we had bugs because
    Python lacks private attributes. It is a matter of discipline, best practices,
    and following conventions.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of freedom Python offers to a developer is the reason why, sometimes,
    it is referred to as a *language for adults* . And of course, there are pros and
    cons to every design choice. At the end of the day, some people prefer languages
    that allow more power and might require a bit more responsibility, while others
    prefer languages that are more constrictive. To each their own; it’s not a matter
    of right or wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, the call for privacy actually makes sense because, without it, you
    risk introducing bugs into your code for real. Let us show you what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have an attribute called `_factor` , and let us pretend
    it is so important that it shouldn’t be modified at runtime after the instance
    is created because `op1()` depends on it to function correctly. We’ve named it
    with a leading underscore, but the issue here is that the call `obj.op2(42)` modifies
    it, and this is then reflected in subsequent calls to `op1()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this undesired behavior by adding a second leading underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is working as desired. Python is kind of magic, and in this case, what
    is happening is that the name-mangling mechanism has kicked in.
  prefs: []
  type: TYPE_NORMAL
- en: Name mangling means that any attribute name that has at least two leading underscores
    and at most one trailing underscore, such as `__my_attr` , is replaced with a
    name that includes an underscore and the class name before the actual name, such
    as `_ClassName__my_attr` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that when you inherit from a class, the mangling mechanism gives
    your private attribute two different names in the base and child classes so that
    name collision is avoided. Every class and instance object stores references to
    their attributes in a special attribute, called `__dict__` . Let us inspect `obj.__dict__`
    to see name mangling in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `_factor` attribute that we find in the problematic version of
    this example, but look at the one that uses `__factor` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` has two attributes now, `_A__factor` (mangled within the `A` class) and
    `_B__factor` (mangled within the `B` class). This is the mechanism that ensures
    that when you execute `obj.__factor = 42` , `__factor` in `A` isn’t changed because
    you’re actually touching `_B__factor` , which has no effect on `_A__factor` .'
  prefs: []
  type: TYPE_NORMAL
- en: If you are designing a library with classes that are meant to be used and extended
    by other developers, you will need to keep this in mind in order to avoid the
    unintentional overriding of your attributes. Bugs like these can be subtle and
    hard to spot.
  prefs: []
  type: TYPE_NORMAL
- en: The property decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing that would be a crime not to mention is the **property** decorator.
    Imagine that you have an `age` attribute in a `Person` class and, at some point,
    you want to make sure that when you change its value, you also check that `age`
    is within a proper range, such as [18, 99]. You could write accessor methods,
    such as `get_age()` and `set_age()` (also called **getters** and **setters** ),
    and put the logic there. `get_age()` will most likely just return `age` , while
    `set_age()` will set its value after checking its validity. The problem is that
    you may already have some code accessing the `age` attribute directly, which means
    you’re now ready for some refactoring. Languages like Java overcome this problem
    by using the accessor pattern basically by default. Many Java **Integrated Development
    Environments** ( **IDEs** ) autocomplete an attribute declaration by writing getter
    and setter accessor method stubs for you on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: But we are not learning Java. Python achieves the same result with the `property`
    decorator. When you decorate a method with `property` , you can use the name of
    the method as if it were a data attribute. Because of this, it is always best
    to refrain from putting logic that would take a while to complete in such methods
    because, by accessing them as attributes, we do not expect to wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Person` class may be the first version we write. Then, we realize we need
    to put the range logic in place, so with another language, we would have to rewrite
    `Person` as the `PersonWithAccessors` class and refactor the code that uses `Person.age`
    . In Python, we rewrite `Person` as `PersonPythonic` (you normally wouldn’t change
    the name, of course; this is just for the sake of illustration). In `PersonPythonic`
    the age is stored in a *private* `_age` variable, and we define property getters
    and setters using the decoration shown, which allows us to keep using the `person`
    instances as before. A **getter** is a method that is called when we access an
    attribute for reading. On the other hand, a **setter** is a method that is called
    when we access an attribute to write it.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike languages that use the getter/setter paradigm, Python allows us to start
    writing simple code and refactor later, only when we need it; there is no need
    to pollute the code with accessor methods only because they may be helpful in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `property` decorator also allows read-only data (by not writing the setter
    counterpart) and for special actions when the attribute is deleted. Please refer
    to the official documentation to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: The cached_property decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One convenient use of properties is when we need to run some code to set up
    the object we want to use. For example, let us say we needed to connect to a database
    (or to an API).
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, we might have to set up a client object that knows how to talk
    to the database (or the API). It is quite common to use a property, in these cases,
    so that we can hide away the complexity of having to set the client up, and simply
    use it. Let us show you a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a dummy `Client` class, which prints the string
    `"Setting up the client…"` every time we create a new instance. It also has a
    pretend `query()` method that prints a string as well. We then have a class, `Manager`
    , which has a `client` property that creates a new instance of `Client` every
    time it is called (for example, by a call to `perform_query()` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to run this code, we would notice that every time we call `perform_query()`
    on the manager, we see the string `"Setting up the client…"` being printed. When
    creating a client is expensive, this code would be wasting resources, so it might
    be better to cache that client, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ManualCacheManager` class is a bit smarter: the `client` property first
    checks if the attribute `_client` exists on the instance, by calling the built-in
    `hasattr()` function. If not, it assigns `_client` to a new instance of `Client`
    . Finally, it simply returns it. Repeatedly accessing the `client` property on
    this class will only create one instance of `Client` , the first time. From the
    second call on, `_client` is simply returned with no creation of new instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is such a common need that, in Python 3.8, the `functools` module added
    the `cached_property` decorator. The beauty of using that, instead of our manual
    solution, is that if we need to refresh the client, we can simply delete the `client`
    property, and the next time we call it, it will recreate a brand new `Client`
    for us. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is only after we manually delete the `manager.client` attribute
    that we get a new one, when we invoke `manager.perform_query()` again.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.9 introduced a `cache` decorator, which can be used in conjunction
    with the `property` decorator, to cover scenarios for which `cached_property`
    is not suitable. As always, we encourage you to read up on all the details in
    the official Python documentation and experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python’s approach to **operator overloading** is brilliant. To overload an operator
    means giving it a meaning according to the context in which it is used. For example,
    the `+` operator means addition when we deal with numbers but concatenation when
    we deal with sequences.
  prefs: []
  type: TYPE_NORMAL
- en: When using operators, Python calls special methods behind the scenes. For example,
    the `a[k]` call on a dictionary roughly translates to `type(a).__getitem__(a,
    k)` . We can override these special methods for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let us create a class that stores a string and evaluates to
    `True` if `''42''` is part of that string, and `False` otherwise. Also, let us
    give the class a length property that corresponds to the length of the stored
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For the complete list of magic methods that you can override to provide your
    custom implementation of operators for your classes, please refer to the Python
    data model in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism—a brief overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word **polymorphism** comes from the Greek *polys* (many, much) and *morphē*
    (form, shape), and its meaning is the provision of a single interface for entities
    of different types.
  prefs: []
  type: TYPE_NORMAL
- en: In our car example, we call `engine.start()` , regardless of what kind of engine
    it is. As long as it exposes the start method, we can call it. That’s polymorphism
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: In other languages, such as Java, in order to give a function the ability to
    accept different types and call a method on them, those types need to be coded
    in such a way that they share an interface. In this way, the compiler knows that
    the method will be available regardless of the type of the object the function
    is fed (as long as it extends the specific interface, of course).
  prefs: []
  type: TYPE_NORMAL
- en: In Python, things are different. Polymorphism is implicit, and nothing prevents
    you from calling a method of an object; therefore, technically, there is no need
    to implement interfaces or other patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special kind of polymorphism called **ad hoc polymorphism** , which
    is what we saw in the last section on operator overloading. This is the ability
    of an operator to change shape according to the type of data it is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism also allows Python programmers to simply use the interface (methods
    and properties) exposed from an object, rather than having to check which class
    it was instantiated from. This allows the code to be more compact and feel more
    natural.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot spend too much time on polymorphism, but we encourage you to check
    it out by yourself; it will expand your understanding of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we leave the OOP realm, there is one last thing we want to mention:
    **data classes** . Introduced in Python 3.7 by PEP 557 ( [https://peps.python.org/pep-0557/](https://peps.python.org/pep-0557/)
    ), they can be described as *mutable named tuples with defaults* . You can brush
    up on named tuples in *Chapter 2* , *Built-In Data Types* . Let us dive straight
    into an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we created a class to represent a physical body, with
    one method that allows us to calculate its kinetic energy (using the formula *E*
    [k] *=½mv* ² ). Notice that `name` is supposed to be a string, while `mass` and
    `speed` are both floats, and both are given a default value. It is also interesting
    that we didn’t have to write any `__init__()` method; it is done for us by the
    `dataclass` decorator, along with methods for comparison and to produce the string
    representation of the object (implicitly called on the last line by `print` ).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to notice is how `name` , `mass` , and `speed` are defined. This
    technique is called **type hinting** and will be the subject of *Chapter 12* ,
    *Introduction to Type Hinting* .
  prefs: []
  type: TYPE_NORMAL
- en: You can read all the specifications in PEP 557 if you are curious, but for now,
    just remember that data classes might offer a nicer, slightly more powerful alternative
    to named tuples, if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have all the tools to appreciate how we can write our own custom iterator.
    Let us first define what iterable and iterator mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterable** : An object is said to be iterable if it can return its members
    one at a time. Lists, tuples, strings, and dictionaries are all iterables. Custom
    objects that define either of the `__iter__()` or `__getitem__()` methods are
    also iterables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator** : An object is said to be an iterator if it represents a stream
    of data. A custom iterator is required to provide an implementation for the `__iter__()`
    method that returns the object itself, as well as an implementation for the `__next__()`
    method that returns the next item of the data stream until the stream is exhausted,
    at which point all successive calls to `__next__()` simply raise a `StopIteration`
    exception. Built-in functions, such as `iter()` and `next()` , are mapped to call
    the `__iter__()` and `__next__()` methods on an object, behind the scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions will be the subject of *Chapter 7* , *Exceptions and Context Managers*
    . They can represent errors during code execution but are also used to regulate
    the flow of execution, and Python relies on them for mechanisms such as the iteration
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us write an iterator that returns all the odd characters from a string
    first, and then the even ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: So, we provide an implementation for `__iter__()` that returns the object itself,
    and one for `__next__()` . Let us go through it. What needs to happen is the return
    of `_data[0]` , `_data[2]` , `_data[4]` , `...` , `_data[1]` , `_data[3]` , `_data[5]`
    , and so on until we have returned every item in the data. To do that, we prepare
    a list of indexes, such as [0, 2, 4, 6, ..., 1, 3, 5, ...], and while there is
    at least one element in the list, we pop the first one out and return the corresponding
    element from the data list, thereby achieving our goal. When `indexes` is empty,
    we raise `StopIteration` , as required by the iterator protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to achieve the same result, so go ahead and try to code
    a different one yourself. Make sure that the end result works for all edge cases,
    empty sequences, and sequences of lengths of 1, 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at decorators, discovered their purpose, and covered
    a few examples, using one or more at the same time. We also saw decorators that
    take arguments, which are usually used as decorator factories.
  prefs: []
  type: TYPE_NORMAL
- en: We have scratched the surface of OOP in Python. We covered all the basics, so
    you should now be able to understand the code that will come in future chapters.
    We talked about all kinds of methods and attributes that you can write in a class;
    we explored inheritance versus composition, method overriding, properties, operator
    overloading, and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we very briefly touched on iterators, which should enrich your understanding
    of generators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about exceptions and context managers.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_6.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
