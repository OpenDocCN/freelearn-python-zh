["```py\n$ pip install fastapi uvicorn\n```", "```py\nimport logging\nlogger = logging.getLogger(\"uvicorn\")\n```", "```py\nfrom starlette.types import (\n    ASGIApp, Scope, Receive, Send\n)\nclass ASGIMiddleware:\n    def __init__(\n        self, app: ASGIApp, parameter: str = \"default\"\n):\n        self.app = app\n        self.parameter = parameter\n    async def __call__(\n        self,\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ):\n        logger.info(\"Entering ASGI middleware\")\n        logger.info(\n            f\"The parameter is: {self.parameter}\"\n        )\n        await self.app(scope, receive, send)\n        logger.info(\"Exiting ASGI middleware\")\n```", "```py\nfrom fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom middleware.asgi_middleware import ASGIMiddleware\napp = FastAPI(\n    title=\"Middleware Application\",\n    middleware=[\n        Middleware(\n            ASGIMiddleware,\n            parameter=\"example_parameter\",\n        ),\n    ]\n)\n```", "```py\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"Middleware World\"}\n```", "```py\nINFO:    Started server process [2064]\nINFO:    Waiting for application startup.\nINFO:    Entering ASGI middleware\nINFO:    The parameter is: example_parameter\n```", "```py\nINFO:    Entering ASGI middleware\nINFO:    The parameter is: example_parameter\nINFO:    127.0.0.1:55750 - \"GET / HTTP/1.1\" 200 OK\nINFO:    Exiting ASGI middleware\n```", "```py\nclass ASGIMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        parameter: str = \"default\",\n    ):\n    # method content\n    async def __call__(\n        self,\n        scope: Scope,\n        receive: Receive,\n        send: Send,\n    ):\n        # previous logs\n        logger.info(\n            f\"event scope: {scope.get('type')}\"\n        )\n        await self.app(scope, receive, send)\n```", "```py\ndef asgi_middleware(\n    app: ASGIApp, parameter: str = \"default\"\n):\n    @functools.wraps(app)\n    async def wrapped_app(\n        scope: Scope, receive: Receive, send: Send\n    ):\n        logger.info(\n            \"Entering second ASGI middleware\"\n        )\n        logger.info(\n            f\"The parameter you proved is: {parameter}\"\n        )\n        logger.info(\n            f\"event scope: {scope.get('type')}\"\n        )\n        await app(scope, receive, send)\n        logger.info(\"Exiting second ASGI middleware\")\n    return wrapped_app\n```", "```py\nfrom middleware.asgi_middleware import asgi_middleware\napp = FastAPI(\n    title=\"Middleware Application\",\n    middleware=[\n        Middleware(\n            asgi_middleware,\n            parameter=\"example_parameter\",\n        ),\n    ]\n```", "```py\nimport logging\nlogger = logging.getLogger(\"uvicorn\")\n@app.post(\"/send\")\nasync def send(message: str = Body()):\n    logger.info(f\"Message: {message}\")\n    return message\n```", "```py\n    from starlette.types import (\n        ASGIApp, Scope, Receive, Send, Message,\n    )\n    from hashlib import sha1\n    ```", "```py\n    class HashBodyContentMiddleWare:\n        def __init__(\n            self, app: ASGIApp, allowed_paths: list[str]\n        ):\n            self.app = app\n            self.allowed_paths = allowed_paths\n    ```", "```py\n        async def __call__(\n            self,\n            scope: Scope,\n            receive: Receive,\n            send: Send,\n        ):\n            if (\n                scope[\"type\"] != \"http\"\n                or scope[\"path\"]\n                not in self.allowed_paths\n            ):\n                await self.app(scope, receive, send)\n                return\n    ```", "```py\n            # continue the __call__ method content\n            async def receive_with_new_body() -> Message:\n                message = await receive()\n                assert message[\"type\"] == \"http.request\"\n                body = message.get(\"body\", b\"\")\n                message[\"body\"] = (\n                    f'\"{sha1(body).hexdigest()}\"'.encode()\n                )\n                return message\n            await self.app(\n                scope,\n                receive_with_new_body,\n                send,\n            )\n    ```", "```py\n    app.add_middleware(\n        HashBodyContentMiddleWare,\n        allowed_paths=[\"/send\"],\n    )\n    ```", "```py\n$ uvicorn main:app\n```", "```py\n\"hello middleware\"\n```", "```py\n\"14bb256ec4a292037c01bdbdd3eac61f328515f3\"\n```", "```py\n    from typing import Sequence\n    from starlette.datastructures import MutableHeaders\n    from starlette.types import (\n        ASGIApp, Receive, Scope, Send, Message\n    )\n    ```", "```py\n    class ExtraHeadersResponseMiddleware:\n        def __init__(\n            self,\n            app: ASGIApp,\n            headers: Sequence[tuple[str, str]],\n        ):\n            self.app = app\n            self.headers = headers\n    ```", "```py\n        async def __call__(\n            self,\n            scope: Scope,\n            receive: Receive,\n            send: Send,\n        ):\n            if scope[\"type\"] != \"http\":\n                return await self.app(\n                    scope, receive, send\n                )\n    ```", "```py\n            async def send_with_extra_headers(\n                message: Message\n            ):\n                if (\n                    message[\"type\"]\n                    == \"http.response.start\"\n                ):\n                    headers = MutableHeaders(\n                        scope=message\n                    )\n                    for key, value in self.headers:\n                        headers.append(key, value)\n                await send(message)\n            await self.app(\n                scope, receive, send_with_extra_headers\n            )\n    ```", "```py\n    app.add_middleware(\n        ExtraHeadersResponseMiddleware,\n        headers=(\n            (\"new-header\", \"fastapi-cookbook\"),\n            (\n                \"another-header\",\n                \"fastapi-cookbook\",\n            ),\n        ),\n    )\n    ```", "```py\n    another-header: fastapi-cookbook\n    content-length: 28\n    content-type: application/json\n    date: Thu,23 May 2024 09:24:41 GMT\n    new-header: fastapi-cookbook\n    server: uvicorn\n    ```", "```py\nAccess to fetch at 'http://localhost:8000/' from origin 'null' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n```", "```py\nfrom fastapi.middleware.cors import CORSMiddleware\n# rest of the module\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```", "```py\nfrom fastapi.middleware.trustedhost import (\n    TrustedHostMiddleware,\n)\n# rest of the module\napp.add_middleware(\n    TrustedHostMiddleware,\n    allowed_hosts=[\"localhost\"],\n)\n```", "```py\n$ uvicorn main:app --host=0.0.0.0\n```", "```py\nInvalid host header\n```", "```py\nINFO: <client ip>:57312 - \"GET / HTTP/1.1\" 400 Bad Request\n```", "```py\n$ pip install fastapi uvicorn\n```", "```py\n    from contextlib import asynccontextmanager\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        yield {\"webhook_urls\": []}\n    ```", "```py\n    app = FastAPI(\n        lifespan=lifespan,\n    # rest of the parameters\n    )\n    ```", "```py\n    @app.post(\"/register-webhook-url\")\n    async def add_webhook_url(\n        request: Request, url: str = Body()\n    ):\n        if not url.startswith(\"http\"):\n            url = f\"http://{url}\"\n        request.state.webhook_urls.append(url)\n        return {\"url added\": url}\n    ```", "```py\n    from pydantic import BaseModel\n    class Event(BaseModel):\n        host: str\n        path: str\n        time: str\n        body: str | None = None\n    ```", "```py\n    import logging\n    from httpx import AsyncClient\n    client = AsyncClient()\n    logger = logging.getLogger(\"uvicorn\")\n    async def send_event_to_url(\n        url: str, event: Event\n    ):\n        logger.info(f\"Sending event to {url}\")\n        try:\n            await client.post(\n                f\"{url}/fastapi-webhook\",\n                json=event.model_dump(),\n            )\n        except Exception as e:\n            logger.error(\n                \"Error sending webhook event \"\n                f\"to {url}: {e}\"\n            )\n    ```", "```py\n    from asyncio import create_task\n    from datetime import datetime\n    from fastapi import Request\n    from starlette.types import (\n        ASGIApp, Receive, Scope, Send,\n    )\n    ```", "```py\n    class WebhookSenderMiddleWare:\n        def __init__(self, app: ASGIApp):\n            self.app = app\n        async def __call__(\n            self,\n            scope: Scope,\n            receive: Receive,\n            send: Send,\n        ):\n    ```", "```py\n            if scope[\"type\"] == \"http\":\n                message = await receive()\n                body = message.get(\"body\", b\"\")\n                request = Request(scope=scope)\n    ```", "```py\n                event = Event(\n                    host=request.client.host,\n                    path=request.url.path,\n                    time=datetime.now().isoformat(),\n                    body=body,\n                )\n    ```", "```py\n                urls = request.state.webhook_urls\n                for url in urls:\n                    await create_task(\n                        send_event_to_url(url, event)\n                    )\n    ```", "```py\n                async def continue_receive():\n                    return message\n                await self.app(\n                    scope, continue_receive, send\n                )\n                return\n            await self.app(scope, receive, send)\n    ```", "```py\n    from middleware.webhook import (\n    WebhookSenderMiddleWare\n    )\n    # rest of the code\n    app.add_middleware(WebhookSenderMiddleWare)\n    ```", "```py\n@app.webhooks.post(\"/fastapi-webhook\")\ndef fastapi_webhook(event: Event):\n    \"\"\"_summary_\n    Args:\n        event (Event): Received event from webhook\n        It contains information about the\n        host, path, timestamp and body of the request\n    \"\"\"\n```", "```py\nclass Event(BaseModel):\n    host: str\n    path: str\n    time: str\n    body: str | None = None\n    model_config = {\n        \"json_schema_extra\": {\n            \"examples\": [\n                {\n                    \"host\": \"127.0.0.1\",\n                    \"path\": \"/send\",\n                    \"time\": \"2024-05-22T14:24:28.847663\",\n                    \"body\": '\"body content\"',\n}\n            ]\n        }\nuvicorn main:app command and opening the browser at http://localhost:8000/docs, you will find the documentation for POST /fastapi-webhook in the POST register-webhook-url endpoint.\nHow it works…\nTo test the webhook, you can set up a simple server running locally on a specific port. You can create one yourself or download the `http_server.py` file from the GitHub repository. This server will run on port `8080`.\nOnce you have set up the server, you can run it from the command line:\n\n```", "```py\n\n Leave the server running and make sure the FastAPI application is running on a separate terminal.\nOpen the interactive documentation at `http://localhost:8000/docs`. Using the `POST /register-webhook-url` endpoint, add the `\"localhost:8080\"` address. Make sure you specify the correct port in the URL.\nNow try to call any of the endpoints to the API. The FastAPI application will make a call to the server listening at port `8080`. If you check the service terminal, you will see the messages streaming on the terminal containing the information for each call.\nThere’s more…\nWhile the basic implementation of webhooks is powerful, several advanced concepts and enhancements can make your webhook system more robust, secure, and efficient. Some of the most relevant ones are as follows:\n\n*   **Authentication**: To ensure that your API can securely communicate with a webhook endpoint, you can implement any sort of authentication, from API to OAuth.\n*   **Retry mechanism**: Webhooks rely on HTTP, which is not always reliable. There may be instances where the webhook delivery fails due to network issues, server downtime, or other transient errors. Implementing a retry mechanism ensures that webhook events are eventually delivered even if the initial attempt fails.\n*   **Persistent storage**: Storing webhook events in a database allows you to keep an audit trail, troubleshoot issues, and replay events if necessary. You can use SQLAlchemy, a SQL toolkit and **object-relational mapping** library for Python, to save webhook events in a relational database.\n*   **WebSocket webhook**: For real-time updates, you can set up a WebSocket server in FastAPI and notify clients through WebSocket connections when webhooks are received.\n*   **Rate limiting**: To prevent abuse and server overload, rate limiting can be applied to the webhook endpoint. This ensures that a single client cannot overwhelm the server with too many requests in a short period.\n\nWebhooks are crucial for constructing interactive, event-driven applications that seamlessly integrate with third-party systems. Utilize them to their fullest potential.\nSee also\nIf you want to learn more about webhook applications, check out the **Red Hat** blog page explaining what it is and how it is used in modern applications:\n\n*   *What is a* *webhook?*: [https://www.redhat.com/en/topics/automation/what-is-a-webhook](https://www.redhat.com/en/topics/automation/what-is-a-webhook)\n\nYou can also refer to the FastAPI documentation for information on how to document webhook endpoints in the OpenAPI documentation:\n\n*   *OpenAPI* *Webhooks*: [https://fastapi.tiangolo.com/advanced/openapi-webhooks/](https://fastapi.tiangolo.com/advanced/openapi-webhooks/)\n\n```"]