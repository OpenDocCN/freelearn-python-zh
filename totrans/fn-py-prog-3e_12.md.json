["```py\n    @decorator \n    def base_function() -> None: \n        pass\n    ```", "```py\n    def base_function() -> None: \n        pass \n\n    base_function = decorator(base_function)\n    ```", "```py\nnew_function = decorator(base_function)\n```", "```py\nfrom collections.abc import Callable \nfrom functools import wraps \n\ndef nullable(function: Callable[[float], float]) -> Callable[[float | None], float | None]: \n    @wraps(function) \n    def null_wrapper(value: float | None) -> float | None: \n        return None if value is None else function(value) \n    return null_wrapper\n```", "```py\nimport math \n\n@nullable \ndef st_miles(nm: float) -> float: \n    return 1.15078 * nm\n```", "```py\n>>> some_data = [8.7, 86.9, None, 43.4, 60] \n>>> scaled = map(st_miles, some_data) \n>>> list(scaled) \n[10.011785999999999, 100.002782, None, 49.94385199999999, 69.04679999999999]\n```", "```py\n@nullable \ndef nround4(x: float) -> float: \n    return round(x, 4)\n```", "```py\n>>> some_data = [8.7, 86.9, None, 43.4, 60] \n>>> scaled = map(st_miles, some_data) \n>>> [nround4(v) for v in scaled] \n[10.0118, 100.0028, None, 49.9439, 69.0468]\n```", "```py\nst_miles_2: Callable[[float | None], float | None] = ( \n    nullable(lambda nm: nm * 1.15078) \n) \nnround4_2: Callable[[float | None], float | None] = ( \n    nullable(lambda x: round(x, 4)) \n)\n```", "```py\n(’__module__’, ’__name__’, ’__qualname__’, ’__doc__’, \n’__annotations__’)\n```", "```py\n@f_deco \ndef g(x): \n    something\n```", "```py\ndef stringify(argument_function: Callable[[int, int], int]) -> Callable[[str], str]: \n    @wraps(argument_function) \n    def two_part_wrapper(text: str) -> str: \n        # The \"before\" part \n        arg1, arg2 = map(int, text.split(\",\")) \n        int_result = argument_function(arg1, arg2) \n        # The \"after\" part \n        return str(int_result) \n    return two_part_wrapper\n```", "```py\n>>> @stringify \n... def the_model(m: int, s: int) -> int: \n...     return m * 45 + s * 3 \n... \n>>> the_model(\"5,6\") \n’243’\n```", "```py\nfrom collections.abc import Callable \nimport decimal \nfrom typing import Any, Union, TypeVar, TypeAlias \n\nNumber: TypeAlias = Union[decimal.Decimal, float] \nNumT = TypeVar(\"NumT\", bound=Number) \n\ndef bad_data( \n         function: Callable[[str], NumT] \n) -> Callable[[str], NumT]: \n    @wraps(function) \n    def wrap_bad_data(source: str, **kwargs: Any) -> NumT: \n        try: \n            return function(source, **kwargs) \n        except (ValueError, decimal.InvalidOperation): \n            cleaned = source.replace(\",\", \"\") \n            return function(cleaned, **kwargs) \n    return wrap_bad_data\n```", "```py\nfrom decimal import Decimal \n\nbd_int = bad_data(int) \nbd_float = bad_data(float) \nbd_decimal = bad_data(Decimal)\n```", "```py\n>>> bd_int(\"13\") \n13 \n>>> bd_int(\"1,371\") \n1371 \n>>> bd_int(\"1,371\", base=16) \n4977\n```", "```py\n@deco(arg) \ndef func(x): \n    base function processing...\n```", "```py\nconcrete_deco = deco(arg) \n\ndef func(x): \n    base function processing... \n\nfunc = concrete_deco(func)\n```", "```py\nfrom collections.abc import Callable \nimport decimal \nfrom typing import Any, TypeVar \n\nT = TypeVar(’T’) \n\ndef bad_char_remove( \n    *bad_chars: str \n) -> Callable[[Callable[[str], T]], Callable[[str], T]]: \n    def cr_decorator( \n            function: Callable[[str], T] \n    ) -> Callable[[str], T]: \n        def clean_list(text: str, *, to_replace: tuple[str, ...]) -> str: \n            if to_replace: \n                return clean_list( \n                    text.replace(to_replace[0], \"\"), \n                    to_replace=to_replace[1:] \n                ) \n            return text \n\n        @wraps(function) \n        def wrap_char_remove(text: str, **kwargs: Any) -> T: \n            try: \n                return function(text, **kwargs) \n            except (ValueError, decimal.InvalidOperation): \n                cleaned = clean_list(text, to_replace=bad_chars) \n                return function(cleaned, **kwargs) \n        return wrap_char_remove \n    return cr_decorator\n```", "```py\nfrom decimal import Decimal \nfrom typing import Any \n\n@bad_char_remove(\"$\", \",\") \ndef currency(text: str, **kw: Any) -> Decimal: \n    return Decimal(text, **kw)\n```", "```py\n>>> currency(\"13\") \nDecimal(’13’) \n>>> currency(\"$3.14\") \nDecimal(’3.14’) \n>>> currency(\"$1,701.00\") \nDecimal(’1701.00’)\n```", "```py\n@f_wrap \n@g_wrap \ndef h(x): \n    return something...\n```", "```py\n@cleanse_before(cleanser) \ndef convert(text: str) -> int: \n    # code to convert the text, trusting it was clean \n    return # an int value\n```", "```py\n@then_convert(converter) \ndef cleanse(text: str) -> str: \n    # code to clean the text \n    return # the str value for later conversion\n```", "```py\nfrom collections.abc import Callable \nfrom typing import Any, TypeVar \n\n# Defined Earlier: \n# T = TypeVar(’T’) \n\ndef cleanse_before( \n    cleanse_function: Callable[[str], Any] \n) -> Callable[[Callable[[str], T]], Callable[[str], T]]: \n    def concrete_decorator(converter: Callable[[str], T]) -> Callable[[str], T]: \n        @wraps(converter) \n        def cc_wrapper(text: str, **kwargs: Any) -> T: \n            try: \n                return converter(text, **kwargs) \n            except (ValueError, decimal.InvalidOperation): \n                cleaned = cleanse_function(text) \n                return converter(cleaned, **kwargs) \n        return cc_wrapper \n    return concrete_decorator\n```", "```py\ndef drop_punct2(text: str) -> str: \n    return text.replace(\",\", \"\").replace(\"$\", \"\") \n\n@cleanse_before(drop_punct2) \ndef to_int(text: str, base: int = 10) -> int: \n    return int(text, base)\n```", "```py\nto_int2 = cleanse_before(drop_punct2)(int)\n```", "```py\n>>> to_int(\"1,701\") \n1701 \n>>> to_int(\"42\") \n42\n```", "```py\ndef to_int_flat(text: str, base: int = 10) -> int: \n    try: \n        return int(text, base) \n    except (ValueError, decimal.InvalidOperation): \n        cleaned = drop_punct2(text) \n        return int(cleaned, base)\n```", "```py\n    def clean_list(text: str, *, to_replace: tuple[str, ...]) -> str: \n        ...\n```", "```py\n@none_tolerant \ndef x2(x: float) -> float: \n    return 2 * x \n\ndef test_x2() -> None: \n    assert x2(42.) == 84.0 \n    assert x2(None) == None \n    assert list(map(x2, [1, 2, None, 3])) == [2, 3, None, 6]\n```", "```py\nfrom dataclasses import dataclass \n@dataclass(frozen=True) \nclass Sample: \n    id: int \n    observation: float \n    date_time: datetime.datetime\n```"]