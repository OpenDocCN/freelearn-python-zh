["```py\n>>> def hiding_generator():\n...     print('a')\n...     yield 'first value'\n...     print('b')\n...     yield 'second value'\n...     print('c')\n\n>>> generator = hiding_generator()\n\n>>> next(generator)\na\n'first value'\n\n>>> next(generator)\nb\n'second value'\n\n>>> next(generator)\nTraceback (most recent call last):\n...\nStopIteration \n```", "```py\n>>> import os\n>>> import inspect\n>>> import linecache\n\n>>> def print_code():\n...     while True:\n...         info = inspect.stack()[1]\n...         lineno = info.lineno + 1\n...         function = info.function\n...         # Fetch the next line of code\n...         code = linecache.getline(info.filename, lineno)\n...         print(f'{lineno:03d} {function}: {code.strip()}')\n...         yield\n\n# Always prime the generator\n>>> print_code = print_code()\n\n>>> def some_test_function(a, b):\n...     next(print_code)\n...     c = a + b\n...     next(print_code)\n...     return c\n\n>>> some_test_function('a', 'b')\n003 some_test_function: c = a + b\n005 some_test_function: return c\n'ab' \n```", "```py\ndef some_test_function(a, b):\n    c = a + b\n    return c\n\nprint(some_test_function('a', 'b')) \n```", "```py\n$ python3 -m trace --trace --timing T_01_trace.py\n --- modulename: T_01_trace, funcname: <module>\n0.00 T_01_trace.py(1): def some_test_function(a, b):\n0.00 T_01_trace.py(6): print(some_test_function('a', 'b'))\n --- modulename: T_01_trace, funcname: some_test_function\n0.00 T_01_trace.py(2):     c = a + b\n0.00 T_01_trace.py(3):     return c\nab \n```", "```py\nimport sys\nimport trace as trace_module\nimport contextlib\n\n@contextlib.contextmanager\ndef trace(count=False, trace=True, timing=True):\n    tracer = trace_module.Trace(\n        count=count, trace=trace, timing=timing)\n    sys.settrace(tracer.globaltrace)\n    yield tracer\n    sys.settrace(None)\n\n    result = tracer.results()\n    result.write_results(show_missing=False, summary=True)\n\ndef some_test_function(a, b):\n    c = a + b\n    return c\n\nwith trace():\n    print(some_test_function('a', 'b')) \n```", "```py\n$ python3 T_02_selective_trace.py\n --- modulename: T_02_selective_trace, funcname: some_test_function\n0.00 T_02_selective_trace.py(19):     c = a + b\n0.00 T_02_selective_trace.py(20):     return c\nab\n --- modulename: contextlib, funcname: __exit__\n0.00 contextlib.py(122):         if type is None:\n0.00 contextlib.py(123):             try:\n0.00 contextlib.py(124):                 next(self.gen)\n --- modulename: T_02_selective_trace, funcname: trace\n0.00 T_02_selective_trace.py(12):     sys.settrace(None) \n```", "```py\n$ python3 -m trace --trace --timing T_02_selective_trace.py | wc\n    256    2940   39984 \n```", "```py\nimport sys\nimport trace as trace_module\nimport contextlib\n\n@contextlib.contextmanager\ndef trace(filename):\n    tracer = trace_module.Trace()\n\n    def custom_trace(frame, event, arg):\n        # Only trace for the given filename\n        if filename != frame.f_code.co_filename:\n            return custom_trace\n\n        # Let globaltrace handle the rest\n        return tracer.globaltrace(frame, event, arg)\n\n    sys.settrace(custom_trace)\n    yield tracer\n    sys.settrace(None)\n\n    result = tracer.results()\n    result.write_results(show_missing=False, summary=True)\n\ndef some_test_function(a, b):\n    c = a + b\n    return c\n\n# Pass our current filename as '__file__'\nwith trace(filename=__file__):\n    print(some_test_function('a', 'b')) \n```", "```py\n$ python3 T_03_filename_trace.py\n --- modulename: T_03_filename_trace, funcname: some_test_function\nT_03_filename_trace.py(27):     c = a + b\nT_03_filename_trace.py(28):     return c\nab\n --- modulename: T_03_filename_trace, funcname: trace\nT_03_filename_trace.py(20):     sys.settrace(None)\nlines   cov%   module   (path)\n    3   100%   T_03_filename_trace   (T_03_filename_trace.py) \n```", "```py\nimport pprint\nimport inspect\nimport logging\nimport functools\n\ndef debug(function):\n    @functools.wraps(function)\n    def _debug(*args, **kwargs):\n        # Make sure 'result' is always defined\n        result = None\n        try:\n            result = function(*args, **kwargs)\n            return result\n        finally:\n            # Extract the signature from the function\n            signature = inspect.signature(function)\n            # Fill the arguments\n            arguments = signature.bind(*args, **kwargs)\n            # NOTE: This only works for Python 3.5 and up!\n            arguments.apply_defaults()\n            logging.debug('%s(%s): %s' % (\n                function.__qualname__,\n                ', '.join('%s=%r' % (k, v) for k, v in\n                          arguments.arguments.items()),\n                pprint.pformat(result),\n            ))\n\n    return _debug\n\n@debug\ndef add(a, b=123):\n    return a + b\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.DEBUG)\n\n    add(1)\n    add(1, 456)\n    add(b=1, a=456) \n```", "```py\n$ python3 T_04_logging.py\nDEBUG:root:add(a=1, b=123): 124\nDEBUG:root:add(a=1, b=456): 457\nDEBUG:root:add(a=456, b=1): 457 \n```", "```py\nimport logging\n\nlog_format = (\n    '[%(relativeCreated)d %(levelname)s] '\n    '%(filename)s:%(lineno)d:%(funcName)s: %(message)s'\n)\nlogging.basicConfig(level=logging.DEBUG, format=log_format) \n```", "```py\n$ python3 T_05_logging_config.py\n[DEBUG] T_05_logging_config.py:20:_debug: add(a=1, b=123): 124\n[DEBUG] T_05_logging_config.py:20:_debug: add(a=1, b=456): 457\n[DEBUG] T_05_logging_config.py:20:_debug: add(a=456, b=1): 457 \n```", "```py\nimport sys\nimport traceback\n\nclass ShowMyStack:\n    def run(self, limit=None):\n        print('Before stack print')\n        traceback.print_stack(limit=limit)\n        print('After stack print')\n\nclass InheritShowMyStack(ShowMyStack):\n    pass\n\nif __name__ == '__main__':\n    show_stack = InheritShowMyStack()\n\n    print('Stack without limit')\n    show_stack.run()\n    print()\n\n    print('Stack with limit 1')\n    show_stack.run(1) \n```", "```py\n$ python3 T_06_stack.py\nStack without limit\nBefore stack print\n  File \"T_06_stack.py\", line 20, in <module>\n    show_stack.run()\n  File \"T_06_stack.py\", line 8, in run\n    traceback.print_stack(limit=limit)\nAfter stack print\n\nStack with limit 1\nBefore stack print\n  File \"T_06_stack.py\", line 8, in run\n    traceback.print_stack(limit=limit)\nAfter stack print \n```", "```py\nimport ctypes\n\n# Get memory address 0, your kernel shouldn't allow this:\nctypes.string_at(0) \n```", "```py\n$ python3 T_07_faulthandler.py\nzsh: segmentation fault  python3 T_07_faulthandler.py \n```", "```py\nimport ctypes\n\ntry:\n    # Get memory address 0, your kernel shouldn't allow this:\n    ctypes.string_at(0)\nexcept Exception as e:\n    print('Got exception:', e) \n```", "```py\nimport ctypes\nimport faulthandler\n\nfaulthandler.enable()\n\n# Get memory address 0, your kernel shouldn't allow this:\nctypes.string_at(0) \n```", "```py\n$ python3 T_09_faulthandler_enabled.py\nFatal Python error: Segmentation fault\n\nCurrent thread 0x0000000110382e00 (most recent call first):\n  File python3.9/ctypes/__init__.py\", line 517 in string_at\n  File T_09_faulthandler.py\", line 7 in <module>\nzsh: segmentation fault  python3 T_09_faulthandler_enabled.py \n```", "```py\nimport code\n\ndef start_console():\n    some_variable = 123\n    print(f'Launching console, some_variable: {some_variable}')\n    code.interact(banner='console:', local=locals())\n    print(f'Exited console, some_variable: {some_variable}')\n\nif __name__ == '__main__':\n    start_console() \n```", "```py\n$ python3 T_10_console.py\nLaunching console, some_variable: 123\nconsole:\n>>> some_variable = 456\n>>>\nnow exiting InteractiveConsole...\nExited console, some_variable: 123 \n```", "```py\nimport pdb\n\ndef go_to_debugger():\n    some_variable = 123\n    print('Starting pdb trace')\n    pdb.set_trace()\n    print(f'Finished pdb, some_variable: {some_variable}')\n\nif __name__ == '__main__':\n    go_to_debugger() \n```", "```py\n$ python3 T_11_pdb.py\nStarting pdb trace\n> T_11_pdb.py(8)go_to_debugger()\n-> print(f'Finished pdb, some_variable: {some_variable}')\n(Pdb) some_variable\n123\n(Pdb) some_variable = 456\n(Pdb) continue\nFinished pdb, some_variable: 456 \n```", "```py\nimport pdb\n\ndef print_value(value):\n    print('value:', value)\n\nif __name__ == '__main__':\n    pdb.set_trace()\n    for i in range(5):\n        print_value(i) \n```", "```py\n$ python3 T_12_pdb_loop.py\n> T_12_pdb_loop.py (10)<module>()\n-> for i in range(5):\n(Pdb) source print_value  # View the source of print_value\n  4     def print_value(value):\n  5         print('value:', value)\n(Pdb) b 5  # Add a breakpoint to line 5\nBreakpoint 1 at T_12_pdb_loop.py:5\n(Pdb) w  # Where shows the current line\n> T_12_pdb_loop.py (10)<module>()\n-> for i in range(5):\n(Pdb) c  # Continue (until the next breakpoint or exception)\n> T_12_pdb_loop.py(5)print_value()\n-> print('value:', value)\n(Pdb) w  # Where shows the current line and the calling functions\n  T_12_pdb_loop.py(11)<module>()\n-> print_value(i)\n> T_12_pdb_loop.py(5)print_value()\n-> print('value:', value)\n(Pdb) ll  # List the lines of the current function\n  4     def print_value(value):\n  5 B->     print('value:', value)\n(Pdb) b  # Show the breakpoints\nNum Type         Disp Enb   Where\n1   breakpoint   keep yes   at T_12_pdb_loop.py:5\n        breakpoint already hit 1 time\n(Pdb) cl 1  # Clear breakpoint 1\nDeleted breakpoint 1 at T_12_pdb_loop.py:5\n(Pdb) c  # Continue the application until the end\nvalue: 0\nvalue: 1\nvalue: 2\nvalue: 3\nvalue: 4 \n```", "```py\n$ python3 T_12_pdb_loop.py\n> T_12_pdb_loop.py(10)<module>()\n-> for i in range(5):\n# print the source to find the variable name and line number:\n(Pdb) source print_value\n  4     def print_value(value):\n  5         print('value:', value)\n(Pdb) b 5, value == 3  # add a breakpoint at line 5 when value=3\nBreakpoint 1 at T_12_pdb_loop.py:5\n(Pdb) c  # continue until breakpoint\nvalue: 0\nvalue: 1\nvalue: 2\n> T_12_pdb_loop.py(5)print_value()\n-> print('value:', value)\n(Pdb) a  # show the arguments for the function\nvalue = 3\n(Pdb) value = 123  # change the value before the print\n(Pdb) c  # continue, we see the new value now\nvalue: 123\nvalue: 4 \n```", "```py\nprint('This still works')\n1 / 0\nprint('We will never reach this') \n```", "```py\n$ python3 -m pdb T_13_pdb_catching_exceptions\n> T_13_pdb_catching_exceptions(1)<module>()\n-> print('This still works')\n(Pdb) w  # Where\n  bdb.py(431)run()\n-> exec(cmd, globals, locals)\n  <string>(1)<module>()\n> T_13_pdb_catching_exceptions(1)<module>()\n-> print('This still works')\n(Pdb) s  # Step into the next statement\nThis still works\n> T_13_pdb_catching_exceptions(2)<module>()\n-> 1/0\n(Pdb) c  # Continue\nTraceback (most recent call last):\n  File \"pdb.py\", line 1661, in main\n    pdb._runscript(mainpyfile)\n  File \"pdb.py\", line 1542, in _runscript\n    self.run(statement)\n  File \"bdb.py\", line 431, in run\n    exec(cmd, globals, locals)\n  File \"<string>\", line 1, in <module>\n  File \"T_13_pdb_catching_exceptions\", line 2, in <module>\n    1/0\nZeroDivisionError: division by zero\nUncaught exception. Entering post mortem debugging\nRunning 'cont' or 'step' will restart the program\n> T_13_pdb_catching_exceptions(2)<module>()\n-> 1/0 \n```", "```py\ndef do_nothing(i):\n    pass\n\nfor i in range(10):\n    do_nothing(i) \n```", "```py\n$ python3 -m pdb T_14_pdb_commands.py\n> T_14_pdb_commands.py(1)<module>()\n-> def do_nothing(i):\n(Pdb) b do_nothing  # Add a breakpoint to function do_nothing\nBreakpoint 1 at T_14_pdb_commands.py:1\n(Pdb) commands 1  # add command to breakpoint 1\n(com) print(f'The passed value: {i}')\n(com) end  # end command\n(Pdb) c  # continue\nThe passed value: 0\n> 16_pdb_commands.py(2)do_nothing()\n-> pass\n(Pdb) q  # quit \n```", "```py\n$ pip3 install ipython \n```", "```py\ndef print_value(value):\n    print('value:', value)\n\nif __name__ == '__main__':\n    for i in range(5):\n        print_value(i) \n```", "```py\n$ ipython\nPython 3.10.0\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.19.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: %run -d T_15_ipython.py\nBreakpoint 1 at T_15_ipython.py:1\nNOTE: Enter 'c' at the ipdb>  prompt to continue execution.\n> T_15_ipython.py(1)<module>()\n1---> 1 def print_value(value):\n      2     print('value:', value)\n      3\n      4\n      5 if __name__ == '__main__':\n\nipdb> b print_value, value == 3  # Add a breakpoint when value=3\nBreakpoint 2 at T_15_ipython.py:1\nipdb> c\nvalue: 0\nvalue: 1\nvalue: 2\n> T_15_ipython.py(2)print_value()\n2     1 def print_value(value):\n----> 2     print('value:', value)\n      3\n      4\n      5 if __name__ == '__main__':\nipdb> value\n3\nipdb> value = 123  # Change the value\nipdb> c  # Continue\nvalue: 123\nvalue: 4 \n```", "```py\n$ conda create -n jupyter-debugger -c conda-forge xeus-python=0.8.6 notebook=6 jupyterlab=2 ptvsd nodejs\n...\n## Package Plan ##\n\n  added / updated specs:\n    - jupyterlab=2\n    - nodejs\n    - notebook=6\n    - ptvsd\n    - xeus-python=0.8.6\n...\n$ conda activate jupyter-debugger\n\n(jupyter-debugger) $ jupyter labextension install @jupyterlab/debugger\n\nBuilding jupyterlab assets (build:prod:minimize) \n```", "```py\n(jupyter-debugger) $ jupyter lab\n[I LabApp] JupyterLab extension loaded from jupyterlab\n[I LabApp] Jupyter Notebook 6.1.4 is running at:\n[I LabApp] http://localhost:8888/?token=...\n[I LabApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). \n```"]