- en: Chapter 4. Playing with SMS and Voice Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud telephony is the technology that moves your phone system to the cloud.
    This has made sure that we can now explore the possibilities of automation with
    SMS and voice notifications. This chapter begins with an introduction to cloud
    telephony and covers automation of business use cases with text and voice messages
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering with a cloud telephony provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving SMS messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS workflows for Domino's
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending voice messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving voice calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own customer service software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous few chapters, we looked at working with plain text and **comma-separated
    value** (**CSV**) files, and then we extended our scope to learn about working
    with Excel worksheets, Word documents, and PDF files. Excel, Word, and PDF files
    are available in the binary format and support mathematical operations, tables,
    charting, and many other operations. We also looked at interesting business use
    cases that can be automated with Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we take a look at an interesting world of cloud telephony.
    With the advent of the Internet, businesses have moved their communication systems
    to the cloud as well. Internet-based hosted telephony has replaced the conventional
    telephone equipment, such as PBX. This has opened up a world of possibilities
    of using cloud telephony to solve business needs, and that too, in Python. Using
    cloud telephony for your business allows you to make and receive multiple calls
    and SMS simultaneously. Services like call transfers, recording, bulk SMS are
    some of the awesome features cloud telephony can be leveraged for. Cloud telephony
    ensures management of business needs without compromising on quality, cost, and
    without having to invest in any additional infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter will focus on the Python modules that help us in
    sending/receiving SMS messages and voice calls. We''ll learn how to register with
    a cloud telephony provider, use Python APIs, and automate interesting business
    flows. Specifically, we will work with the [Twilio](https://www.twilio.com/) telephony
    provider and use the following Python modules in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twilio` ([https://pypi.python.org/pypi/twilio](https://pypi.python.org/pypi/twilio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we'll learn about the Twilio cloud telephony provider, there are other
    providers as well. Each of these has a great API set and works with Python libraries.
    If you choose to implement your solution, you can have a look at a few of them
    at [http://www.capterra.com/telephony-software/](http://www.capterra.com/telephony-software/).
  prefs: []
  type: TYPE_NORMAL
- en: Registering with a cloud telephony provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with cloud-based telephony services, we need to register for an account
    with a telephony provider. There are a couple of popular cloud providers that
    you can find when you search on the Internet. For this chapter, we use Twilio
    ([https://www.twilio.com/](https://www.twilio.com/)). Let's see how to register
    for an account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use cloud telephony APIs, we need to register for an account with
    Twilio so that we can get the **AccountSID** and **AuthToken**. We'd also need
    to rent numbers for the recipes in the SMS and voice sections. Let's learn how
    to work with Twilio APIs in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On your computer, open your favorite browser and browse to [https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio):![How
    to do it...](img/image_05_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you create an account, log in to it and add a few funds from the **Billing**
    page that is available as a dropdown option on your account dashboard. You can
    also directly browse to the **Billing** page at [https://www.twilio.com/user/billing](https://www.twilio.com/user/billing)
    if you're already logged in:![How to do it...](img/image_05_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make Twilio API calls, we need **AccountSID** and **AuthToken**. We can get
    these details by clicking on the **Account** section from the dropdown or directly
    browsing to [https://www.twilio.com/user/account/settings](https://www.twilio.com/user/account/settings).
    On this page, you will get the API credentials as shown in the following screenshot.
    Don't worry about two-factor authentication for now, but make sure **SSL Certification
    Validation** is enabled for your account:![How to do it...](img/image_05_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, that's good. Now, let's rent a phone number by directly browsing to [https://www.twilio.com/user/account/phone-numbers/search](https://www.twilio.com/user/account/phone-numbers/search).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on **Buy a Number**, you'll see a page where you can rent a number
    based on the country and prefix or area code. Here, I have chosen country as **United
    States** and prefix as `510`. I'm also renting a number that is capable of handling
    both **SMS** messages and **Voice** calls:![How to do it...](img/image_05_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **Advanced Search** option at the bottom of this page to get
    all the options, as shown in the following screenshot. You can go ahead with the
    default settings **All** or choose to rent **Local** or **Toll-Free** numbers.
    Based on the local rules of a region or country, renting numbers requires you
    to provide your address proof, but you don't need all this and could select the
    **Any** option. **Beta Numbers** are newly added numbers to Twilio from specific
    countries, added to support a list of countries. We don't have to care about this
    option in this recipe, so we keep it blank:![How to do it...](img/image_05_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on **Search**, this page will take you to the results screen
    where you can choose to buy any of the available numbers. Make sure you buy a number
    that has both **Voice** and **SMS** enabled. Toll-free numbers are costly, and
    it's best to buy a **Local** number for this exercise:![How to do it...](img/image_05_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cool! If you're already through this, then congratulations! You're now all set
    to start learning about using SMS messages and voice calls with Python APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, to work with Twilio APIs, we need to register for an account.
    Twilio creates an account for us and provides us with a unique **AccountSID**
    and **AuthToken**, which will validate our requests and make sure that our account
    gets billed for the API calls we make.
  prefs: []
  type: TYPE_NORMAL
- en: Phone numbers in Twilio are used as caller IDs to send text messages or voice
    calls. Caller ID (also known as calling line identification) is a caller's number
    that is flashed on the called party's equipment (landline or mobile). In this
    case, the number we rented from Twilio will be used as the caller ID.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at how to create an account, get **AccountSID** and **AuthToken**,
    and generate a phone number with Twilio. Let's now make use of these in the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Sending text messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at our first recipe on working with text messages. In this recipe,
    we will send a message to the recipient via SMS. Please note that you may also
    now have to charge your account for performing the next set of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by sending SMS messages with the Twilio APIs. Let's look at how to
    do it in this section. Before doing that, let's create a Python virtual environment
    and install `flask` and `twilio` modules with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we will use `flask` to host a simple web service, which will be called
    by the telephony provider Twilio. The *flask* app will then perform the required
    business operation based on the callback from Twilio. We will know more about
    this when we look at the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up a virtual environment and installing modules needs to be done from
    the command line of your computer. We use Python `pip` to install the `flask`
    and `twilio` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install `twilio` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a configuration that has our Twilio **AccountSID** and
    **AuthToken**. We also add our rented number as caller ID to the configuration
    and also add the custom number to whom the message will be sent. You can add your
    own number in this field to see if it works for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our configuration file looks as follows, and we store it as `config.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s write our application that will actually send out this message.
    We store this as `send_sms.py` and import the configuration from `config.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We run this code by going to the Terminal or from your favorite editor. Check
    your mobile and you should have a message from your rented number saying, **Hey,
    this is cool!** Indeed, this is cool! Your message can take 2-3 minutes to arrive
    depending on your carrier and network congestion, so be patient. See the following
    screenshot for the received message:![How to do it...](img/image_05_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we created a configuration file and filled it with all the required fields.
    In the `send_sms.py` file, we imported this configuration file by importing `config.py`
    and also imported the required modules such as `flask` and the `twilio` Python
    module.
  prefs: []
  type: TYPE_NORMAL
- en: We then created the `twilio` object, `client`, by using the class, `TwilioRestClient`,
    which is imported from the `twilio.rest` module. An object is created with **AccountSID**
    and **AuthToken**.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `create()` method of the `client.messages` class and send a
    message. Here `to` is the number to which the message is sent, `from_` is the
    caller ID, and `body` is the text to be sent. Wondering why `from_` instead of
    `from`? Well, that's because `from` will conflict with Python's `from` keyword,
    which is used to import modules.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trivial, isn't it?! Sending a text message to our number was a breeze. Now,
    can you write your own application? Let's see what you can think of. Probably,
    send me a message to invite me to your birthday party!
  prefs: []
  type: TYPE_NORMAL
- en: But hey, what's the fun if we don't know how to receive an incoming message?
    Let's learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving SMS messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you were thinking of the various use cases of sending SMS messages, you
    must have felt that the capability of receiving a text message is equally important.
    So, let's look at it with an auto-response-messaging app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the **ngrok** software. The ngrok ([https://ngrok.com/](https://ngrok.com/))
    software helps you tunnel your local machine to the Internet. It means that you
    can expose your local server behind NAT or Firewall to the Internet. Really powerful
    utility! For the next recipe, download ngrok ([https://ngrok.com/download](https://ngrok.com/download))
    and run it on port 5000 using the command from your Terminal. If you''re connected
    to the Internet you should see an instance up and running for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how ngrok has made your app visible to the Internet
    and on the URL, `https://<uuid>.ngrok.io/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't start ngrok yet, we start ngrok during our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by writing our server to receive SMSes. We''ll call this `recv_sms.py`.
    The code for the server looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the server with Python from your Terminal with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start ngrok with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nice, we got our server running. Let's configure our Twilio number by adding
    a **Request URL**. For doing this, log in to Twilio, go to the **Phone Numbers**
    section, and click on your rented number. Here, go to the messaging section and
    enter your **Request URL** as shown in the following screenshot. Make sure that
    the URL points to the ngrok instance that was fired up in the previous step:![How
    to do it...](img/image_05_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And we're done! So, when someone sends a message to your rented number, they
    will receive an auto response saying **Thanks for your query. We will get back
    to you soon**.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! That's great, but hey, how did it work?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server that accepts the incoming message is written in `Flask` and runs
    on port 5000\. This makes the server run on a local machine. To make it available
    on the Internet, we fire `ngrok` and make it run on the same port as the Flask
    server, which is port 5000.
  prefs: []
  type: TYPE_NORMAL
- en: We configure the Twilio phone number to route the incoming messages to our Flask
    server. To achieve this, we add the request URL to Twilio. So, whenever a message
    is sent to the rented number, it gets routed to our Flask server via ngrok. In
    our app, we have routed it to `https://<ngrokId>.ngrok.io/insms`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our Flask server, we already a have a route configured with the
    URL, `/insms`. This route gets a `POST` call from the Twilio server (thanks to
    the **Request URL** setting), which then responds back with the message, **Thanks
    for your query. We will get back to you soon**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learnt about sending and receiving text messages using Twilio. I know you're
    already thinking about your use cases and how you can leverage text messages to
    resolve them. Let's look at an example from the food retail industry.
  prefs: []
  type: TYPE_NORMAL
- en: SMS workflows for Domino's
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: John, the owner of a Domino's Pizza outlet in the US, is looking for ways to
    improve his pizza sales. One way to improve the sales would be to focus on making
    the process of ordering pizzas easier. He also wants to automate the workflows
    so that he can keep his customers updated on the order and delivery status. He
    also feels that while the Internet is great, customers may also want to order
    pizzas when they are in areas where the network reception is weak. What do you
    think he must do?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s think about the use case and write down what all we''d need? Here are
    a few things I can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to receive incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain and query the status of order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send outgoing status message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the solution and then understand how it works for the Domino's
    shop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is divided into three main aspects: the ability
    to receive incoming messages with the `flask` route, maintaining the status of
    the order for customers who query their orders, and the ability to send outbound
    messages from the *Flask* app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have an app to receive the incoming messages. So, we use this app
    and extend it for our needs. Our rented number becomes a Domino''s number, which
    is flashed on their advertising boards:'
  prefs: []
  type: TYPE_NORMAL
- en: In our use case, we have decided to use two keywords, `ORDER` and `STATUS`,
    which Domino's customers can use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When customers send the message, `ORDER`, to Domino's, they can place an order
    for a pizza of their choice. The pizza shop positively responds to the order by
    saying they're already working on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the customers want to know the status of their order, they can check it
    with a text saying, `STATUS`. In our case, when the customer queries for his order,
    he gets a response from the pizza shop saying that his order is ready. Imagine
    the satisfaction the customer gets when he reads this response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers feel it's so easy to place an order and know its status. They'll certainly
    start ordering more! Well, at least I will.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John is so happy that he decides to give a pay rise to his IT manager, and incidentally,
    that happens to be you! Cool, isn't it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, if you note the messages sent by or to the pizza shop, they are sent to
    a rented number. How about sending the messages to a custom code like **DOMP**
    (abbreviation for Domino's Pizza)? Yes, you can achieve that using SMS Short codes;
    they're not free and you need to buy them at a hefty price.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have come to the end of all the recipes for SMS messages. Hope you learnt
    a few things and will implement a few of them for your benefit. Can you try sending
    MMS messages, such as an offer to your esteemed customers with the Domino's logo?
    That's something for you to explore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next recipe, we will start working on voice calls and appreciate what
    they can offer. Can we do some awesome stuff with voice messages? Let's look at
    them in the next set of recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending voice messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heard of VoIP? Yes, **Voice over Internet Protocol**. **VoIP** (an abbreviation)
    is a group of technologies used for the delivery of voice and multimedia over
    Internet Protocol networks, such as the Internet itself. VoIP has opened up a
    whole new world for communication on the Internet with products such as Skype
    and Google Talk offering communication solutions in the consumer and enterprise
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Telephony API providers such as Twilio also use the VoIP protocol to send voice
    messages. You will learn how to make or receive voice calls using the Twilio APIs
    in this section. So, let's jump in and start using the APIs!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the `twilio` and `flask` modules like we used in the
    previous recipe for SMS. So, no new installations are needed for this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating our configuration file. Sending a voice message is as
    trivial as sending a text message. We need the Twilio **AccountSID** and **AuthToken**
    here as well. We''d need the caller ID and the number to send the voice message
    to. Here''s how our configuration looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now go ahead and write the code for our Flask server. The following
    code helps us in making voice calls using the Twilio Python APIs. We save the
    file as `voice_outbound.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the Flask server with the following command. This will run our Flask server
    on the default port 5000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start ngrok with the following command on port 5000\. This will make sure that
    our server is available on the Internet with the tunneling facility provided by
    ngrok. Copy the URL on which ngrok is running. It will be in the format, `https://<ngrokid>.ngrok.io/`,
    like we saw in previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our server is now ready to make calls, so just go ahead and make a `POST` request
    to `https://<ngrokid>.ngrok.io/call`, and you should receive a call to your number
    as added in the configuration file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wow, that's cool! But what happens when you pick up the call? Your call gets
    disconnected. Why? That's because in Twilio, every voice call is accompanied with
    a callback URL, which will execute the next set of instructions once the call
    gets picked. This is not defined in our code, and hence, the call gets disconnected
    with an error. Let's fix this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, let''s add the answer callback URL and complete our server code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you look at the `url` parameter in the `outbound_call()` method, it points
    to `BASE_URL`. This is the same as the ngrok URL suffixed with `/answer_url`.
    Now, if you make a `POST` request to `https://<ngrokid>.ngrok.io/call`, your number
    will receive a call. Once you pick up the call, a callback `POST` request is made
    to `https://<ngrokid>.ngrok.io/answer_url` and you'll hear the message "*Hey!
    You are awesome. Thanks for answering*". Wow!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how the server logs would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, how does it work? After doing the SMS section, this should be pretty straightforward
    to understand. We will go through the code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a `twilio` object, `client`, with the `TwilioRestClient` class
    from the `twilio.rest` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a route in our Flask app, `/call`, which accepts the `POST` method
    calls. This route makes a voice call to our number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual call is made in the `outbound_call()` route method with the help
    of the `create()` method of the `client.calls` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `create()` call, we define the parameters, such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`to`: This is the mobile/landline number that is called'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_`: This is the rented number from Twilio'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`record`: This will decide if the call should be recorded'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: This is the callback answer `url` that gets called when the voice call
    is answered'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Flask app, we have also defined a new route, `/answer_url`, which gets
    called when the call is picked up. Now, this is interesting to understand. Twilio
    works on the philosophy of TwiML, also known as the Twilio markup language. If
    you look at the markup, it is pretty much an XML markup. TwiML is a set of instructions
    that can be used to tell Twilio what it needs to do with an incoming SMS or voice
    call. So, the `addSay()` method is the same as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we learnt how to send voice calls to a given number and how the answer callback
    URL gets called when the call is answered. Now, let's learn how to handle an incoming
    voice call.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving voice calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Receiving voice calls is an important facet to developing apps using cloud telephony.
    A lot of business cases (as you'd have imagined) are dependent on incoming voice
    calls. Let's look at handling incoming voice calls using the Twilio APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the `twilio` and `flask` modules like we used in the
    previous recipe for SMS. So, no new installations are needed for this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating our configuration file. We need the Twilio **AccountSID**
    and **AuthToken** here as well. We don't need any caller ID in this case as the
    rented number itself is the caller ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s look at our Flask server, the code for which is given in the following.
    We call this as `voice_inbound.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the Flask server with the following command. This will run our Flask server
    on the default port 5000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start ngrok with the following command on port 5000\. This will make sure that
    our server is available on the Internet with the tunneling facility provided by
    ngrok. Copy the URL on which ngrok is running. It will be in the format, `https://<ngrokid>.ngrok.io/`,
    like we saw in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, log in to Twilio and configure the rented number for incoming voice calls.
    We configure the **Request URL** to point to the ngrok URL. See the following
    screenshot to know how to add the **Request URL** to your rented number:![How
    to do it...](img/image_05_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the servers running and the settings configured on Twilio, make
    a call to your rented number through Skype or Google Talk. This will make a `POST`
    call to our Flask server, which in turn will respond with a TwiML response saying,
    *Thanks for calling our customer service. Please hold while we connect you to
    our advisors*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server that accepts the incoming message is written in Flask and runs on
    port 5000\. This is local to our machine, and to make it available on the Internet,
    we create a tunnel with ngrok.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the rented number is called by anyone, Twilio looks up for the **Request
    URL** and makes a request to this URL, suggesting that there is an incoming call
    to the rented number.
  prefs: []
  type: TYPE_NORMAL
- en: Our flask server defines a route, `/incall` (to match with the **Request URL**),
    which gets called when our rented number receives an incoming call. The `/incall`
    route, in turn, creates a TwiML response that adds `<Say>` to the `<Response>`
    markup, and the caller gets to the message added in the `<Say>` XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the TwiML response looks in Twilio. By the
    way, every call or SMS received or sent can be seen from the Twilio interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building your own customer service software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paul is responsible for customer service at his company. The company has a nice
    looking fancy website that has a facility to receive customer grievances or questions
    over chat. Paul often receives feedback from his customers that the chat system
    is not useful as they would like to get in touch with someone from the company
    when they hit product issues and would like to get these resolved quickly. Can
    you make Paul's life easier?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s think about the use case and write down what all we''d need? Here are
    a few things I can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to receive incoming calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the call to a customer support engineer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the solution and then understand how it would work for Paul.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code snippet, we will add the ability to receive incoming calls to
    the rented numbers and also add the functionality of call transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already created an app that receives incoming calls. We extend this
    app to our use case so that when a customer calls the rented number, a `POST`
    call is made to the `/call` route as defined by the `inbound_call()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Our `flask` route takes the incoming call and adds it to a conference with the
    help of the TwiML instruction set. Conference, as you know, is a group of calls
    bridged with each other in one conference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `response.dial().conference(conference_name)` method is the method that
    helps us in adding a call leg to the conference. This is how the TwiML looks;
    you can see the `<Response>` tag under which we have the `<Dial>` and `<Conference>`
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `flask` route makes sure it makes an outgoing call to the customer support
    engineer (identified by `MYNUMBER`). The outgoing call to the customer support
    engineer is configured with the `url` parameter (the answer URL like we saw in
    our outgoing voice call section). So, when the support engineer picks up the call,
    the callback answer URL gets called and the engineer call leg is also added to
    the same conference as the incoming call leg.
  prefs: []
  type: TYPE_NORMAL
- en: Both the call legs, the incoming call from the customer and the outgoing call
    made to the support engineer, are now in one conference and can have a conversation.
    The customer gets his questions resolved in a jiffy and Paul is happy. Cool!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learned how to build your own SMS and voice applications by using the cloud
    telephony APIs. However, if you're really interested in leveraging the already
    built solutions for your needs, you can look up to some standard software applications,
    such as CallHub ([https://callhub.io/](https://callhub.io/)), which will help
    you automate your use cases efficiently at reasonable costs. You can also build
    your own call center solution with their APIs. So, what are you building next?
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you enjoyed the chapter; let's have some more fun in the next chapter.
    Let's see what we have in store!
  prefs: []
  type: TYPE_NORMAL
