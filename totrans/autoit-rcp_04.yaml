- en: Chapter 4. Playing with SMS and Voice Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 玩转短信和语音通知
- en: Cloud telephony is the technology that moves your phone system to the cloud.
    This has made sure that we can now explore the possibilities of automation with
    SMS and voice notifications. This chapter begins with an introduction to cloud
    telephony and covers automation of business use cases with text and voice messages
    in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 云电话是将您的电话系统迁移到云的技术。这确保了我们现在可以探索使用短信和语音通知自动化的可能性。本章从云电话的介绍开始，并涵盖使用Python在文本和语音消息中自动化业务用例。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Registering with a cloud telephony provider
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云电话服务提供商处注册
- en: Sending text messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送短信
- en: Receiving SMS messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收短信消息
- en: SMS workflows for Domino's
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Domino's的短信工作流程
- en: Sending voice messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送语音消息
- en: Receiving voice calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收语音通话
- en: Building your own customer service software
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的客户服务软件
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous few chapters, we looked at working with plain text and **comma-separated
    value** (**CSV**) files, and then we extended our scope to learn about working
    with Excel worksheets, Word documents, and PDF files. Excel, Word, and PDF files
    are available in the binary format and support mathematical operations, tables,
    charting, and many other operations. We also looked at interesting business use
    cases that can be automated with Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了处理纯文本和**逗号分隔值**（**CSV**）文件的方法，然后我们扩展了我们的范围，学习如何处理Excel工作表、Word文档和PDF文件。Excel、Word和PDF文件以二进制格式提供，并支持数学运算、表格、图表和其他许多操作。我们还探讨了可以用Python自动化的有趣业务用例。
- en: In this chapter, we take a look at an interesting world of cloud telephony.
    With the advent of the Internet, businesses have moved their communication systems
    to the cloud as well. Internet-based hosted telephony has replaced the conventional
    telephone equipment, such as PBX. This has opened up a world of possibilities
    of using cloud telephony to solve business needs, and that too, in Python. Using
    cloud telephony for your business allows you to make and receive multiple calls
    and SMS simultaneously. Services like call transfers, recording, bulk SMS are
    some of the awesome features cloud telephony can be leveraged for. Cloud telephony
    ensures management of business needs without compromising on quality, cost, and
    without having to invest in any additional infrastructure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个有趣的云电话世界。随着互联网的出现，企业也将他们的通信系统迁移到了云端。基于互联网的托管电话已经取代了传统的电话设备，如PBX。这为使用云电话解决业务需求打开了可能性，而且还是在Python中。使用云电话为您的业务提供让您能够同时进行多个通话和短信的服务。呼叫转移、录音、批量短信是云电话可以利用的一些令人惊叹的功能。云电话确保在不影响质量、成本的情况下管理业务需求，而且无需投资任何额外的基础设施。
- en: 'The recipes in this chapter will focus on the Python modules that help us in
    sending/receiving SMS messages and voice calls. We''ll learn how to register with
    a cloud telephony provider, use Python APIs, and automate interesting business
    flows. Specifically, we will work with the [Twilio](https://www.twilio.com/) telephony
    provider and use the following Python modules in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱将专注于帮助我们发送/接收短信和语音通话的Python模块。我们将学习如何注册云电话服务提供商，使用Python API，并自动化有趣的业务流程。具体来说，我们将与[Twilio](https://www.twilio.com/)电话服务提供商合作，并在本章中使用以下Python模块：
- en: '`Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))'
- en: '`twilio` ([https://pypi.python.org/pypi/twilio](https://pypi.python.org/pypi/twilio))'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twilio` ([https://pypi.python.org/pypi/twilio](https://pypi.python.org/pypi/twilio))'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While we'll learn about the Twilio cloud telephony provider, there are other
    providers as well. Each of these has a great API set and works with Python libraries.
    If you choose to implement your solution, you can have a look at a few of them
    at [http://www.capterra.com/telephony-software/](http://www.capterra.com/telephony-software/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将学习Twilio云电话服务提供商，但还有其他提供商。每个提供商都有一套优秀的API，并且与Python库兼容。如果您选择实现自己的解决方案，您可以在[http://www.capterra.com/telephony-software/](http://www.capterra.com/telephony-software/)查看其中的一些。
- en: Registering with a cloud telephony provider
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云电话服务提供商处注册
- en: To work with cloud-based telephony services, we need to register for an account
    with a telephony provider. There are a couple of popular cloud providers that
    you can find when you search on the Internet. For this chapter, we use Twilio
    ([https://www.twilio.com/](https://www.twilio.com/)). Let's see how to register
    for an account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于云的电话服务，我们需要在电话服务提供商处注册一个账户。你可以在网上搜索时找到一些流行的云提供商。对于这一章，我们使用Twilio ([https://www.twilio.com/](https://www.twilio.com/))。让我们看看如何注册一个账户。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to use cloud telephony APIs, we need to register for an account with
    Twilio so that we can get the **AccountSID** and **AuthToken**. We'd also need
    to rent numbers for the recipes in the SMS and voice sections. Let's learn how
    to work with Twilio APIs in this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用云电话API，我们需要在Twilio注册一个账户，以便我们能够获取**AccountSID**和**AuthToken**。我们还需要为短信和语音部分的食谱租用号码。让我们在这个食谱中学习如何使用Twilio
    API。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: On your computer, open your favorite browser and browse to [https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio):![How
    to do it...](img/image_05_001.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上，打开你喜欢的浏览器并浏览到[https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio)：![如何操作...](img/image_05_001.jpg)
- en: Once you create an account, log in to it and add a few funds from the **Billing**
    page that is available as a dropdown option on your account dashboard. You can
    also directly browse to the **Billing** page at [https://www.twilio.com/user/billing](https://www.twilio.com/user/billing)
    if you're already logged in:![How to do it...](img/image_05_002.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了一个账户，登录并从你的账户仪表板上的下拉菜单中的**账单**页面添加一些资金。如果你已经登录，也可以直接浏览到[https://www.twilio.com/user/billing](https://www.twilio.com/user/billing)的**账单**页面：![如何操作...](img/image_05_002.jpg)
- en: To make Twilio API calls, we need **AccountSID** and **AuthToken**. We can get
    these details by clicking on the **Account** section from the dropdown or directly
    browsing to [https://www.twilio.com/user/account/settings](https://www.twilio.com/user/account/settings).
    On this page, you will get the API credentials as shown in the following screenshot.
    Don't worry about two-factor authentication for now, but make sure **SSL Certification
    Validation** is enabled for your account:![How to do it...](img/image_05_003.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行Twilio API调用，我们需要**AccountSID**和**AuthToken**。我们可以通过在下拉菜单中点击**账户**部分或直接浏览到[https://www.twilio.com/user/account/settings](https://www.twilio.com/user/account/settings)来获取这些详细信息。在这个页面上，你会看到以下截图所示的API凭证。现在不用担心双因素认证，但请确保你的账户启用了**SSL证书验证**：![如何操作...](img/image_05_003.jpg)
- en: Okay, that's good. Now, let's rent a phone number by directly browsing to [https://www.twilio.com/user/account/phone-numbers/search](https://www.twilio.com/user/account/phone-numbers/search).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，那很好。现在，让我们通过直接浏览到[https://www.twilio.com/user/account/phone-numbers/search](https://www.twilio.com/user/account/phone-numbers/search)来租用一个电话号码。
- en: Once you click on **Buy a Number**, you'll see a page where you can rent a number
    based on the country and prefix or area code. Here, I have chosen country as **United
    States** and prefix as `510`. I'm also renting a number that is capable of handling
    both **SMS** messages and **Voice** calls:![How to do it...](img/image_05_004.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你点击**购买号码**，你将看到一个页面，你可以根据国家、前缀或区号来租用一个号码。在这里，我选择了国家为**美国**，前缀为`510`。我还在租用一个能够处理**短信**和**语音**通话的号码：![如何操作...](img/image_05_004.jpg)
- en: Now, click on the **Advanced Search** option at the bottom of this page to get
    all the options, as shown in the following screenshot. You can go ahead with the
    default settings **All** or choose to rent **Local** or **Toll-Free** numbers.
    Based on the local rules of a region or country, renting numbers requires you
    to provide your address proof, but you don't need all this and could select the
    **Any** option. **Beta Numbers** are newly added numbers to Twilio from specific
    countries, added to support a list of countries. We don't have to care about this
    option in this recipe, so we keep it blank:![How to do it...](img/image_05_005.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击页面底部的**高级搜索**选项以获取所有选项，如下截图所示。你可以使用默认设置**全部**或选择租用**本地**或**免费电话**号码。根据地区或国家的当地规则，租用号码可能需要你提供地址证明，但你不一定需要所有这些，可以选择**任何**选项。**测试号码**是从特定国家新添加到Twilio的号码，用于支持一系列国家。在这个食谱中，我们不需要关心这个选项，所以保持空白：![如何操作...](img/image_05_005.jpg)
- en: When you click on **Search**, this page will take you to the results screen
    where you can choose to buy any of the available numbers. Make sure you buy a number
    that has both **Voice** and **SMS** enabled. Toll-free numbers are costly, and
    it's best to buy a **Local** number for this exercise:![How to do it...](img/image_05_006.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击 **搜索** 时，此页面将带您到结果屏幕，您可以选择购买任何可用的号码。请确保您购买了一个同时启用了 **语音** 和 **短信** 的号码。免费电话号码成本较高，因此最好为此练习购买一个
    **本地** 号码：![如何操作...](img/image_05_006.jpg)
- en: Cool! If you're already through this, then congratulations! You're now all set
    to start learning about using SMS messages and voice calls with Python APIs.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！如果您已经完成了这些，那么恭喜您！现在您已经准备好开始学习如何使用 Python API 来使用短信和语音通话了。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As stated earlier, to work with Twilio APIs, we need to register for an account.
    Twilio creates an account for us and provides us with a unique **AccountSID**
    and **AuthToken**, which will validate our requests and make sure that our account
    gets billed for the API calls we make.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要使用 Twilio API，我们需要注册一个账户。Twilio 会为我们创建一个账户，并为我们提供一个唯一的 **AccountSID**
    和 **AuthToken**，这些信息将验证我们的请求，并确保我们的账户为所进行的 API 调用付费。
- en: Phone numbers in Twilio are used as caller IDs to send text messages or voice
    calls. Caller ID (also known as calling line identification) is a caller's number
    that is flashed on the called party's equipment (landline or mobile). In this
    case, the number we rented from Twilio will be used as the caller ID.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Twilio 中的电话号码用作主叫 ID 来发送短信或语音通话。主叫 ID（也称为来电号码识别）是显示在被叫方设备（固定电话或手机）上的来电号码。在这种情况下，我们将使用我们从
    Twilio 租用的号码作为主叫 ID。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We looked at how to create an account, get **AccountSID** and **AuthToken**,
    and generate a phone number with Twilio. Let's now make use of these in the next
    recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何创建账户、获取 **AccountSID** 和 **AuthToken** 以及使用 Twilio 生成电话号码。现在，让我们在下一个菜谱中使用这些信息。
- en: Sending text messages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信
- en: Let's look at our first recipe on working with text messages. In this recipe,
    we will send a message to the recipient via SMS. Please note that you may also
    now have to charge your account for performing the next set of operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们关于处理短信的第一个菜谱。在这个菜谱中，我们将通过 SMS 向收件人发送消息。请注意，您可能现在还需要为执行下一组操作向您的账户收费。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We start by sending SMS messages with the Twilio APIs. Let's look at how to
    do it in this section. Before doing that, let's create a Python virtual environment
    and install `flask` and `twilio` modules with the following steps.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 Twilio API 发送短信。让我们在本节中看看如何操作。在这样做之前，让我们按照以下步骤创建一个 Python 虚拟环境，并使用 `pip`
    安装 `flask` 和 `twilio` 模块。
- en: Note that we will use `flask` to host a simple web service, which will be called
    by the telephony provider Twilio. The *flask* app will then perform the required
    business operation based on the callback from Twilio. We will know more about
    this when we look at the recipes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将使用 `flask` 来托管一个简单的 Web 服务，该服务将由电话服务提供商 Twilio 调用。然后，*flask* 应用程序将根据 Twilio
    的回调执行所需的企业操作。当我们查看菜谱时，我们将了解更多关于此的信息。
- en: 'Setting up a virtual environment and installing modules needs to be done from
    the command line of your computer. We use Python `pip` to install the `flask`
    and `twilio` modules:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置虚拟环境并安装模块需要在您的计算机命令行中完成。我们使用 Python `pip` 来安装 `flask` 和 `twilio` 模块：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, install `twilio` using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令安装 `twilio`：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's start by creating a configuration that has our Twilio **AccountSID** and
    **AuthToken**. We also add our rented number as caller ID to the configuration
    and also add the custom number to whom the message will be sent. You can add your
    own number in this field to see if it works for you.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个包含我们的 Twilio **AccountSID** 和 **AuthToken** 的配置文件开始。我们还将我们的租用号码作为主叫
    ID 添加到配置中，并添加要发送消息的定制号码。您可以在该字段中添加自己的号码以查看它是否适合您。
- en: 'Our configuration file looks as follows, and we store it as `config.py`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的配置文件如下所示，我们将其存储为 `config.py`：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s write our application that will actually send out this message.
    We store this as `send_sms.py` and import the configuration from `config.py`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的应用程序，它将实际发送这条消息。我们将它存储为 `send_sms.py` 并从 `config.py` 中导入配置：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We run this code by going to the Terminal or from your favorite editor. Check
    your mobile and you should have a message from your rented number saying, **Hey,
    this is cool!** Indeed, this is cool! Your message can take 2-3 minutes to arrive
    depending on your carrier and network congestion, so be patient. See the following
    screenshot for the received message:![How to do it...](img/image_05_007.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we created a configuration file and filled it with all the required fields.
    In the `send_sms.py` file, we imported this configuration file by importing `config.py`
    and also imported the required modules such as `flask` and the `twilio` Python
    module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We then created the `twilio` object, `client`, by using the class, `TwilioRestClient`,
    which is imported from the `twilio.rest` module. An object is created with **AccountSID**
    and **AuthToken**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `create()` method of the `client.messages` class and send a
    message. Here `to` is the number to which the message is sent, `from_` is the
    caller ID, and `body` is the text to be sent. Wondering why `from_` instead of
    `from`? Well, that's because `from` will conflict with Python's `from` keyword,
    which is used to import modules.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trivial, isn't it?! Sending a text message to our number was a breeze. Now,
    can you write your own application? Let's see what you can think of. Probably,
    send me a message to invite me to your birthday party!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: But hey, what's the fun if we don't know how to receive an incoming message?
    Let's learn how to do this in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Receiving SMS messages
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you were thinking of the various use cases of sending SMS messages, you
    must have felt that the capability of receiving a text message is equally important.
    So, let's look at it with an auto-response-messaging app.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the **ngrok** software. The ngrok ([https://ngrok.com/](https://ngrok.com/))
    software helps you tunnel your local machine to the Internet. It means that you
    can expose your local server behind NAT or Firewall to the Internet. Really powerful
    utility! For the next recipe, download ngrok ([https://ngrok.com/download](https://ngrok.com/download))
    and run it on port 5000 using the command from your Terminal. If you''re connected
    to the Internet you should see an instance up and running for you:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows how ngrok has made your app visible to the Internet
    and on the URL, `https://<uuid>.ngrok.io/`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image_05_008.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't start ngrok yet, we start ngrok during our recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by writing our server to receive SMSes. We''ll call this `recv_sms.py`.
    The code for the server looks as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the server with Python from your Terminal with the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Start ngrok with the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nice, we got our server running. Let's configure our Twilio number by adding
    a **Request URL**. For doing this, log in to Twilio, go to the **Phone Numbers**
    section, and click on your rented number. Here, go to the messaging section and
    enter your **Request URL** as shown in the following screenshot. Make sure that
    the URL points to the ngrok instance that was fired up in the previous step:![How
    to do it...](img/image_05_009.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And we're done! So, when someone sends a message to your rented number, they
    will receive an auto response saying **Thanks for your query. We will get back
    to you soon**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! That's great, but hey, how did it work?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server that accepts the incoming message is written in `Flask` and runs
    on port 5000\. This makes the server run on a local machine. To make it available
    on the Internet, we fire `ngrok` and make it run on the same port as the Flask
    server, which is port 5000.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We configure the Twilio phone number to route the incoming messages to our Flask
    server. To achieve this, we add the request URL to Twilio. So, whenever a message
    is sent to the rented number, it gets routed to our Flask server via ngrok. In
    our app, we have routed it to `https://<ngrokId>.ngrok.io/insms`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our Flask server, we already a have a route configured with the
    URL, `/insms`. This route gets a `POST` call from the Twilio server (thanks to
    the **Request URL** setting), which then responds back with the message, **Thanks
    for your query. We will get back to you soon**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learnt about sending and receiving text messages using Twilio. I know you're
    already thinking about your use cases and how you can leverage text messages to
    resolve them. Let's look at an example from the food retail industry.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: SMS workflows for Domino's
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: John, the owner of a Domino's Pizza outlet in the US, is looking for ways to
    improve his pizza sales. One way to improve the sales would be to focus on making
    the process of ordering pizzas easier. He also wants to automate the workflows
    so that he can keep his customers updated on the order and delivery status. He
    also feels that while the Internet is great, customers may also want to order
    pizzas when they are in areas where the network reception is weak. What do you
    think he must do?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s think about the use case and write down what all we''d need? Here are
    a few things I can think of:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Ability to receive incoming messages
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain and query the status of order
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send outgoing status message
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the solution and then understand how it works for the Domino's
    shop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is divided into three main aspects: the ability
    to receive incoming messages with the `flask` route, maintaining the status of
    the order for customers who query their orders, and the ability to send outbound
    messages from the *Flask* app:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have an app to receive the incoming messages. So, we use this app
    and extend it for our needs. Our rented number becomes a Domino''s number, which
    is flashed on their advertising boards:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了接收传入消息的应用程序。因此，我们使用这个应用程序并扩展它以满足我们的需求。我们租用的号码变成了多米诺比萨的号码，它被闪现在他们的广告牌上：
- en: In our use case, we have decided to use two keywords, `ORDER` and `STATUS`,
    which Domino's customers can use.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们决定使用两个关键词，`ORDER`和`STATUS`，多米诺比萨的客户可以使用。
- en: When customers send the message, `ORDER`, to Domino's, they can place an order
    for a pizza of their choice. The pizza shop positively responds to the order by
    saying they're already working on it.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户发送`ORDER`消息到多米诺比萨时，他们可以为他们的选择订购披萨。披萨店积极回应订单，表示他们已经在处理了。
- en: When the customers want to know the status of their order, they can check it
    with a text saying, `STATUS`. In our case, when the customer queries for his order,
    he gets a response from the pizza shop saying that his order is ready. Imagine
    the satisfaction the customer gets when he reads this response.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户想要了解他们订单的状态时，他们可以通过发送`STATUS`文本来检查。在我们的案例中，当客户查询他们的订单时，他们从披萨店得到一个回复，说他们的订单已经准备好了。想象一下客户在阅读这个回复时的满意度。
- en: Customers feel it's so easy to place an order and know its status. They'll certainly
    start ordering more! Well, at least I will.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户觉得下订单和了解其状态非常简单。他们肯定会开始订购更多！嗯，至少我会。
- en: John is so happy that he decides to give a pay rise to his IT manager, and incidentally,
    that happens to be you! Cool, isn't it?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰非常高兴，他决定给他的IT经理加薪，而巧合的是，那个人就是你！酷，不是吗？
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, if you note the messages sent by or to the pizza shop, they are sent to
    a rented number. How about sending the messages to a custom code like **DOMP**
    (abbreviation for Domino's Pizza)? Yes, you can achieve that using SMS Short codes;
    they're not free and you need to buy them at a hefty price.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你注意到的消息是由或发送到比萨店的，它们是发送到租用的号码。把消息发送到像**DOMP**（多米诺比萨的缩写）这样的自定义代码怎么样？是的，你可以使用短信短码来实现这一点；它们不是免费的，你需要以高昂的价格购买。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We have come to the end of all the recipes for SMS messages. Hope you learnt
    a few things and will implement a few of them for your benefit. Can you try sending
    MMS messages, such as an offer to your esteemed customers with the Domino's logo?
    That's something for you to explore.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经完成了所有短信消息的菜谱。希望您学到了一些东西，并将其中的一些应用到您的实际中。你能尝试发送MMS消息，比如带有多米诺比萨标志的优惠信息吗？这是你可以探索的事情。
- en: In the next recipe, we will start working on voice calls and appreciate what
    they can offer. Can we do some awesome stuff with voice messages? Let's look at
    them in the next set of recipes.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将开始处理语音通话，并欣赏它们能提供的内容。我们能用语音信息做一些酷炫的事情吗？让我们在下一组菜谱中看看。
- en: Sending voice messages
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送语音消息
- en: Heard of VoIP? Yes, **Voice over Internet Protocol**. **VoIP** (an abbreviation)
    is a group of technologies used for the delivery of voice and multimedia over
    Internet Protocol networks, such as the Internet itself. VoIP has opened up a
    whole new world for communication on the Internet with products such as Skype
    and Google Talk offering communication solutions in the consumer and enterprise
    domain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过VoIP吗？是的，**互联网协议语音**。**VoIP**（缩写）是一组用于在互联网协议网络上（如互联网本身）传输语音和多媒体的技术，例如Skype和Google
    Talk等提供消费者和企业领域的通信解决方案的产品。VoIP为互联网上的通信开辟了一个全新的世界。
- en: Telephony API providers such as Twilio also use the VoIP protocol to send voice
    messages. You will learn how to make or receive voice calls using the Twilio APIs
    in this section. So, let's jump in and start using the APIs!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 电信API提供商，如Twilio，也使用VoIP协议发送语音消息。在本节中，你将学习如何使用Twilio API进行或接收语音通话。所以，让我们跳进去，开始使用API吧！
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use the `twilio` and `flask` modules like we used in the
    previous recipe for SMS. So, no new installations are needed for this section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`twilio`和`flask`模块，就像我们在之前的短信菜谱中使用的那样。所以，本节不需要新的安装。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by creating our configuration file. Sending a voice message is as
    trivial as sending a text message. We need the Twilio **AccountSID** and **AuthToken**
    here as well. We''d need the caller ID and the number to send the voice message
    to. Here''s how our configuration looks:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建我们的配置文件。发送语音消息就像发送短信一样简单。我们在这里也需要Twilio的**AccountSID**和**AuthToken**。我们还需要呼叫ID和发送语音消息的号码。这是我们的配置看起来像：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now go ahead and write the code for our Flask server. The following
    code helps us in making voice calls using the Twilio Python APIs. We save the
    file as `voice_outbound.py`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在开始编写我们的Flask服务器代码。以下代码帮助我们使用Twilio Python API进行语音通话。我们将文件保存为`voice_outbound.py`：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the Flask server with the following command. This will run our Flask server
    on the default port 5000:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Flask服务器。这将使我们的Flask服务器在默认端口5000上运行：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Start ngrok with the following command on port 5000\. This will make sure that
    our server is available on the Internet with the tunneling facility provided by
    ngrok. Copy the URL on which ngrok is running. It will be in the format, `https://<ngrokid>.ngrok.io/`,
    like we saw in previous section:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在端口5000上启动ngrok。这将确保我们的服务器通过ngrok提供的隧道设施在互联网上可用。复制ngrok正在运行的URL。它将是以下格式，`https://<ngrokid>.ngrok.io/`，就像我们在前面的章节中看到的那样：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our server is now ready to make calls, so just go ahead and make a `POST` request
    to `https://<ngrokid>.ngrok.io/call`, and you should receive a call to your number
    as added in the configuration file.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的服务器现在已准备好拨打电话，所以请继续向`https://<ngrokid>.ngrok.io/call`发送`POST`请求，你应该会接到配置文件中添加的电话。
- en: Wow, that's cool! But what happens when you pick up the call? Your call gets
    disconnected. Why? That's because in Twilio, every voice call is accompanied with
    a callback URL, which will execute the next set of instructions once the call
    gets picked. This is not defined in our code, and hence, the call gets disconnected
    with an error. Let's fix this.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇，这太酷了！但是当你接起电话时会发生什么？你的电话会被断开。为什么？那是因为在Twilio中，每个语音电话都伴随着一个回调URL，一旦电话被接起，就会执行下一组指令。这在我们代码中没有定义，因此电话会因为错误而断开。让我们来修复这个问题。
- en: 'So, let''s add the answer callback URL and complete our server code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，让我们添加回答回调URL并完成我们的服务器代码：
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you look at the `url` parameter in the `outbound_call()` method, it points
    to `BASE_URL`. This is the same as the ngrok URL suffixed with `/answer_url`.
    Now, if you make a `POST` request to `https://<ngrokid>.ngrok.io/call`, your number
    will receive a call. Once you pick up the call, a callback `POST` request is made
    to `https://<ngrokid>.ngrok.io/answer_url` and you'll hear the message "*Hey!
    You are awesome. Thanks for answering*". Wow!
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看`outbound_call()`方法中的`url`参数，它指向`BASE_URL`。这与ngrok URL后缀为`/answer_url`的URL相同。现在，如果你向`https://<ngrokid>.ngrok.io/call`发送`POST`请求，你的号码将收到电话。一旦你接起电话，就会向`https://<ngrokid>.ngrok.io/answer_url`发送一个回调`POST`请求，你将听到消息“*嘿！你太棒了。感谢你接听*”。哇！
- en: 'Here''s how the server logs would be:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是服务器日志的示例：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'So, how does it work? After doing the SMS section, this should be pretty straightforward
    to understand. We will go through the code step by step:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的？在完成短信部分后，这部分应该很容易理解。我们将一步一步地通过代码来讲解：
- en: We first create a `twilio` object, `client`, with the `TwilioRestClient` class
    from the `twilio.rest` module.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`twilio.rest`模块中的`TwilioRestClient`类创建一个名为`client`的`twilio`对象。
- en: We define a route in our Flask app, `/call`, which accepts the `POST` method
    calls. This route makes a voice call to our number.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Flask应用中定义了一个路由，`/call`，它接受`POST`方法调用。这个路由会给我们自己的号码拨打电话。
- en: The actual call is made in the `outbound_call()` route method with the help
    of the `create()` method of the `client.calls` class.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的电话是通过`outbound_call()`路由方法，利用`client.calls`类的`create()`方法来拨打的。
- en: 'In the `create()` call, we define the parameters, such as:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create()`调用中，我们定义了参数，例如：
- en: '`to`: This is the mobile/landline number that is called'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：这是被拨打的手机/固定电话号码'
- en: '`from_`: This is the rented number from Twilio'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_`：这是从Twilio租用的号码'
- en: '`record`: This will decide if the call should be recorded'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record`：这将决定电话是否应该被录音'
- en: '`url`: This is the callback answer `url` that gets called when the voice call
    is answered'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是当语音电话被接听时被调用的回调`url`'
- en: 'In the Flask app, we have also defined a new route, `/answer_url`, which gets
    called when the call is picked up. Now, this is interesting to understand. Twilio
    works on the philosophy of TwiML, also known as the Twilio markup language. If
    you look at the markup, it is pretty much an XML markup. TwiML is a set of instructions
    that can be used to tell Twilio what it needs to do with an incoming SMS or voice
    call. So, the `addSay()` method is the same as:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Flask应用中，我们还定义了一个新的路由，`/answer_url`，当电话被接起时会被调用。现在，这很有趣，需要理解。Twilio基于TwiML（也称为Twilio标记语言）的哲学。如果你查看标记，它基本上是一个XML标记。TwiML是一组指令，可以用来告诉Twilio如何处理传入的短信或语音电话。所以，`addSay()`方法与以下相同：
- en: '[PRE15]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So, we learnt how to send voice calls to a given number and how the answer callback
    URL gets called when the call is answered. Now, let's learn how to handle an incoming
    voice call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们学习了如何向特定号码发送语音电话，以及当电话被接听时，答案回调 URL 如何被调用。现在，让我们学习如何处理来电。
- en: Receiving voice calls
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收语音电话
- en: Receiving voice calls is an important facet to developing apps using cloud telephony.
    A lot of business cases (as you'd have imagined) are dependent on incoming voice
    calls. Let's look at handling incoming voice calls using the Twilio APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接收语音电话是使用云电话开发应用程序的一个重要方面。许多业务案例（正如你所想象的）都依赖于来电。让我们看看如何使用 Twilio API 处理来电。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use the `twilio` and `flask` modules like we used in the
    previous recipe for SMS. So, no new installations are needed for this section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `twilio` 和 `flask` 模块，就像我们在之前的 SMS 菜谱中使用的那样。因此，本节不需要进行新的安装。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We start by creating our configuration file. We need the Twilio **AccountSID**
    and **AuthToken** here as well. We don't need any caller ID in this case as the
    rented number itself is the caller ID.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建配置文件。我们在这里也需要 Twilio 的 **AccountSID** 和 **AuthToken**。在这种情况下，我们不需要任何来电者
    ID，因为租用的号码本身就是来电者 ID。
- en: 'Now, let''s look at our Flask server, the code for which is given in the following.
    We call this as `voice_inbound.py`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 Flask 服务器，其代码如下所示。我们将其称为 `voice_inbound.py`：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the Flask server with the following command. This will run our Flask server
    on the default port 5000:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Flask 服务器。这将使我们的 Flask 服务器在默认端口 5000 上运行：
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start ngrok with the following command on port 5000\. This will make sure that
    our server is available on the Internet with the tunneling facility provided by
    ngrok. Copy the URL on which ngrok is running. It will be in the format, `https://<ngrokid>.ngrok.io/`,
    like we saw in the previous section:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在端口 5000 上启动 ngrok。这将确保我们的服务器通过 ngrok 提供的隧道设施在互联网上可用。复制 ngrok 运行的 URL。它将是
    `https://<ngrokid>.ngrok.io/` 的格式，就像我们在上一节中看到的那样：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, log in to Twilio and configure the rented number for incoming voice calls.
    We configure the **Request URL** to point to the ngrok URL. See the following
    screenshot to know how to add the **Request URL** to your rented number:![How
    to do it...](img/image_05_010.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，登录到 Twilio 并为来电配置租用的号码。我们将 **请求 URL** 配置为指向 ngrok URL。查看以下截图了解如何将 **请求 URL**
    添加到你的租用号码：![如何操作...](img/image_05_010.jpg)
- en: Once you have the servers running and the settings configured on Twilio, make
    a call to your rented number through Skype or Google Talk. This will make a `POST`
    call to our Flask server, which in turn will respond with a TwiML response saying,
    *Thanks for calling our customer service. Please hold while we connect you to
    our advisors*.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在 Twilio 上启动了服务器并配置了设置，就可以通过 Skype 或 Google Talk 向你租用的号码打电话。这将向我们的 Flask
    服务器发送一个 `POST` 请求，然后服务器会以 TwiML 响应回复，内容为：“感谢您拨打我们的客服电话。请稍候，我们将为您连接顾问。”
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The server that accepts the incoming message is written in Flask and runs on
    port 5000\. This is local to our machine, and to make it available on the Internet,
    we create a tunnel with ngrok.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接收传入消息的服务器是用 Flask 编写的，并在端口 5000 上运行。这是本地于我们的机器上，为了使其在互联网上可用，我们使用 ngrok 创建隧道。
- en: Now, when the rented number is called by anyone, Twilio looks up for the **Request
    URL** and makes a request to this URL, suggesting that there is an incoming call
    to the rented number.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当任何人拨打租用的号码时，Twilio 会查找 **请求 URL** 并向该 URL 发送请求，表明租用号码有来电。
- en: Our flask server defines a route, `/incall` (to match with the **Request URL**),
    which gets called when our rented number receives an incoming call. The `/incall`
    route, in turn, creates a TwiML response that adds `<Say>` to the `<Response>`
    markup, and the caller gets to the message added in the `<Say>` XML.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Flask 服务器定义了一个路由 `/incall`（用于匹配 **请求 URL**），当我们的租用号码收到来电时会被调用。`/incall`
    路由反过来创建一个 TwiML 响应，向 `<Response>` 标记添加 `<Say>`，通话者会听到 `<Say>` XML 中添加的消息。
- en: 'The following screenshot shows how the TwiML response looks in Twilio. By the
    way, every call or SMS received or sent can be seen from the Twilio interface:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Twilio 中的 TwiML 响应外观。顺便说一下，接收或发送的每个电话或短信都可以在 Twilio 界面中看到：
- en: '![How it works...](img/image_05_011.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_05_011.jpg)'
- en: Building your own customer service software
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的客户服务软件
- en: Paul is responsible for customer service at his company. The company has a nice
    looking fancy website that has a facility to receive customer grievances or questions
    over chat. Paul often receives feedback from his customers that the chat system
    is not useful as they would like to get in touch with someone from the company
    when they hit product issues and would like to get these resolved quickly. Can
    you make Paul's life easier?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s think about the use case and write down what all we''d need? Here are
    a few things I can think of:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Ability to receive incoming calls
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the call to a customer support engineer
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the solution and then understand how it would work for Paul.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code snippet, we will add the ability to receive incoming calls to
    the rented numbers and also add the functionality of call transfer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already created an app that receives incoming calls. We extend this
    app to our use case so that when a customer calls the rented number, a `POST`
    call is made to the `/call` route as defined by the `inbound_call()` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Our `flask` route takes the incoming call and adds it to a conference with the
    help of the TwiML instruction set. Conference, as you know, is a group of calls
    bridged with each other in one conference.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The `response.dial().conference(conference_name)` method is the method that
    helps us in adding a call leg to the conference. This is how the TwiML looks;
    you can see the `<Response>` tag under which we have the `<Dial>` and `<Conference>`
    tags:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_05_012.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: The `flask` route makes sure it makes an outgoing call to the customer support
    engineer (identified by `MYNUMBER`). The outgoing call to the customer support
    engineer is configured with the `url` parameter (the answer URL like we saw in
    our outgoing voice call section). So, when the support engineer picks up the call,
    the callback answer URL gets called and the engineer call leg is also added to
    the same conference as the incoming call leg.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Both the call legs, the incoming call from the customer and the outgoing call
    made to the support engineer, are now in one conference and can have a conversation.
    The customer gets his questions resolved in a jiffy and Paul is happy. Cool!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learned how to build your own SMS and voice applications by using the cloud
    telephony APIs. However, if you're really interested in leveraging the already
    built solutions for your needs, you can look up to some standard software applications,
    such as CallHub ([https://callhub.io/](https://callhub.io/)), which will help
    you automate your use cases efficiently at reasonable costs. You can also build
    your own call center solution with their APIs. So, what are you building next?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you enjoyed the chapter; let's have some more fun in the next chapter.
    Let's see what we have in store!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
