<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer164">
<h1 class="chapter-number" id="_idParaDest-125"><a id="_idTextAnchor125"/>8</h1>
<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Creating an IoT Alarm Dashboard</h1>
<p>In today’s digitalized age, IoT has revolutionized security, transforming basic alarm dashboards into comprehensive, real-time security monitors. In <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we started constructing an IoT alarm system by building an IoT alarm module that could detect motion and relay MQTT messages. <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, introduced two versions of the IoT button: the first uses the M5Stack ATOM Matrix with an LCD matrix screen, and the second incorporates an OLED screen, buzzer, arcade-style button for arming our IoT alarm module, and a toggle switch <span class="No-Break">for disarming:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 8.1 – IoT alarm system" height="1197" src="image/B21282_08_01.jpg" width="1109"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – IoT alarm system</p>
<p>In this chapter, we will use our Raspberry Pi 5 with a 7-inch touchscreen to serve as our IoT alarm dashboard (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em>). This dashboard will let us arm and disarm our IoT alarm module, review the latest MQTT notification, and observe a map pinpointing the location where our alarm was activated. It will subscribe and publish to the same MQTT topic, <strong class="source-inline">IoTAlarm</strong>, as the other IoT alarm system devices – that is, the IoT alarm module, the M5Stack ATOM Matrix IoT button, and the Raspberry Pi Pico W <span class="No-Break">IoT button.</span></p>
<p>The IoT alarm dashboard completes our advanced IoT alarm system. Our system utilizes IoT technology and the internet’s vast reach for global <span class="No-Break">application deployment.</span></p>
<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Exploring IoT <span class="No-Break">alarm dashboards</span></li>
<li>Creating a Raspberry Pi 5 IoT <span class="No-Break">alarm dashboard</span></li>
<li>Building the external alarm <span class="No-Break">buzzer stand</span></li>
<li>Running <span class="No-Break">our application</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>A late model Raspberry Pi, such as the Raspberry <span class="No-Break">Pi 5</span></li>
<li>A Raspberry Pi branded 7-inch touchscreen with a <span class="No-Break">compatible case</span></li>
<li>1x SFM-27 <span class="No-Break">active buzzer</span></li>
<li>2x M2 <span class="No-Break">5mm screws</span></li>
<li>2x M4 <span class="No-Break">20mm bolts</span></li>
<li>2x <span class="No-Break">M4 nuts</span></li>
<li>1x M5 <span class="No-Break">20mm bolt</span></li>
<li>1x <span class="No-Break">M5 nut</span></li>
<li>Composite (multi-wire) cable with USB plug (a discarded USB charging cable <span class="No-Break">works well)</span></li>
<li>Hot <span class="No-Break">glue gun</span></li>
<li>Access to a 3D printer or 3D printer service to print an <span class="No-Break">optional case</span></li>
</ul>
<p>The code for this chapter can be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8</span></a></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Exploring IoT alarm dashboards</h1>
<p>IoT’s true strength is its limitless capabilities, as seen in IoT alarm dashboards. Integrating devices such as the Raspberry Pi 5 with the expansive network of IoT opens up new possibilities, especially in <a id="_idIndexMarker627"/>security systems. Using the Raspberry Pi in alarm systems, whether for homes or businesses, offers immense innovation potential. This versatile device opens up possibilities for advanced security solutions beyond traditional <span class="No-Break">alarm systems.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Using IoT alarm dashboards for industrial processes</h2>
<p>In modern industrial settings, monitoring safety and efficiency is essential. The industrial IoT alarm dashboard, which is typically integrated into a control room, provides an overview of the facility’s operations. It shows <a id="_idIndexMarker628"/>real-time metrics and system statuses and sends alarms if equipment deviates from <span class="No-Break">standard parameters.</span></p>
<p>The dashboard’s strength lies in its ability to detect and communicate issues quickly via the Internet. For example, in a petrochemical plant, sensors on a tank send data to the dashboard, as illustrated in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em>. Here, sensors on the tank publish “temp” and “level” MQTT messages to indicate the temperature of the liquid in the tank and the level, respectively. The Raspberry Pi has been set up to subscribe to these messages and passes this information onto the web interface and analog meter. If the tank’s level drops or its temperature changes drastically, the system flags <span class="No-Break">this discrepancy:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 8.2 – Industrial IoT application" height="921" src="image/B21282_08_02.jpg" width="1501"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Industrial IoT application</p>
<p>Alarms alert the team, allowing for prompt action to be taken to ensure worker safety and prevent potential hazards. The<a id="_idIndexMarker629"/> dashboard can also initiate automated responses, such as shutting down <span class="No-Break">affected areas.</span></p>
<p>Beyond safety, the IoT dashboard enhances operational efficiency. Analyzing long-term data can help industries predict maintenance needs, reducing downtimes. The dashboard can also connect to supply systems, updating raw material levels and product counts. By using data from various sources, industries can improve safety <span class="No-Break">and efficiency.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Exploring the IoT security alarm dashboard</h2>
<p>For modern security, the integration of IoT has redefined the capabilities of alarm dashboards. These aren’t the<a id="_idIndexMarker630"/> traditional systems of the past; IoT-enhanced alarm dashboards are dynamic, offering remote access and responsive actions. For instance, with the rise of smart homes and businesses, a breach in security doesn’t just trigger a loud siren but can instantly notify homeowners through their mobile devices, initiate real-time video footage capture, and even communicate with local law enforcement, all powered by <span class="No-Break">IoT connectivity.</span></p>
<p>Armed with our Raspberry Pi 5 and its 7-inch touchscreen display, we will build an alarm dashboard (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>) for our IoT alarm system. With this dashboard, we can arm and disarm our IoT alarm module using a 4-digit pin. Our dashboard will display the latest <strong class="source-inline">IoTAlarm</strong> MQTT message and provide a map of the area where our alarm has <span class="No-Break">been triggered:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 8.3 – IoT alarm dashboard" height="486" src="image/B21282_08_03.jpg" width="1140"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – IoT alarm dashboard</p>
<p>Since our Raspberry Pi 5 doesn’t have a built-in buzzer, we will add an external one that we will connect via the GPIO port using a composite (multi-wire) cable. This external buzzer will sit in a custom-designed 3D-printed stand and play a melody whenever our armed IoT alarm module <span class="No-Break">is triggered.</span></p>
<p>We will start our development by upgrading the code for our IoT alarm module so that it works with the map feature of the IoT <span class="No-Break">alarm dashboard.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor131"/>Creating a Raspberry Pi 5 alarm dashboard</h1>
<p>Since its release in late 2023, the<a id="_idIndexMarker631"/> Raspberry Pi 5 has set a new standard for compact computing, enabling developers to build more efficient and powerful applications across <span class="No-Break">various domains.</span></p>
<p>The Raspberry Pi 5 boasts an advanced processor that enhances our IoT alarm dashboard’s data processing speed and multitasking capabilities. Its robust software support and extensive Python support offer unparalleled programming flexibility, tailored to the IoT alarm system’s needs. Paired with the 7-inch touchscreen, our Raspberry Pi 5 provides us with a user-friendly and efficient interface for <span class="No-Break">our system.</span></p>
<p>We will begin developing our IoT alarm dashboard by modifying the IoT alarm module code from <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> so that it publishes the <strong class="source-inline">location</strong> data on the <strong class="source-inline">IoTAlarm</strong> MQTT topic. This data will enable our dashboard to identify the geographic position of the IoT alarm module with precision once it’s armed <span class="No-Break">and activated.</span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>Modifying the IoT alarm module code</h2>
<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> shows a slightly modified <a id="_idIndexMarker632"/>version of our IoT alarm module with the addition of a <strong class="source-inline">location</strong> message that sends geolocation data to our IoT alarm dashboard. In this case, we could integrate a GPS module, like the shown one in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em>, into our IoT <span class="No-Break">alarm module:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 8.4 – The GPS module next to a Raspberry Pi Pico" height="223" src="image/B21282_08_04.jpg" width="998"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The GPS module next to a Raspberry Pi Pico</p>
<p class="callout-heading">GPS test code</p>
<p class="callout">This chapter’s GitHub repository contains test code for a BN-180 GPS module and a Raspberry <span class="No-Break">Pi Pico.</span></p>
<p>However, despite its compact size and ability to easily connect to the Raspberry Pi Pico W, its value is limited as our IoT alarm module is for indoor use, and the GPS would struggle to obtain a <span class="No-Break">strong signal:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<img alt="Figure 8.5 – Worldwide deployment of the IoT alarm module" height="624" src="image/B21282_08_05.jpg" width="1290"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Worldwide deployment of the IoT alarm module</p>
<p>Instead, we’ll embed the GPS coordinates directly into our IoT alarm module’s code, operating under the assumption that the module’s location will remain static post-deployment. As the code<a id="_idIndexMarker633"/> requires Wi-Fi configuration updates, it’s straightforward to adjust the GPS details when we deploy the IoT alarm module on-site. This geolocation data will be published within the <strong class="source-inline">location</strong> message as part of enhancing our module code. This approach allows us to deploy our IoT alarm modules globally, as illustrated in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p>
<p>To publish the geolocation information, we will modify the <strong class="source-inline">motion_handler()</strong> method from the <strong class="source-inline">main.py</strong> file, which is stored on our IoT <span class="No-Break">alarm module.</span></p>
<p class="callout-heading">The advantage of using MicroPython over C with microcontrollers</p>
<p class="callout">While MicroPython runs slower than C, its adaptability is evident when it comes to modifying the code for the IoT alarm module. With C, changes require recompilation and external code tracking. MicroPython, however, can be edited directly on the microcontroller, bypassing filesystem searches <span class="No-Break">during alterations.</span></p>
<p>To modify the code, we<a id="_idIndexMarker634"/> must do <span class="No-Break">the following:</span></p>
<ol>
<li>First, we connect our Raspberry Pi Pico W to a USB port on your computer and <span class="No-Break">launch Thonny.</span></li>
<li>Then, we activate the MicroPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer155">
<img alt="Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)" height="163" src="image/B21282_08_06.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)</p>
<ol>
<li value="3">Under the <strong class="bold">Raspberry Pi Pico</strong> tab on the left-hand side of the screen, we double-click on the <strong class="source-inline">main.py</strong> file to <span class="No-Break">open it:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer156">
<img alt="Figure 8.7 – Selecting the main.py file" height="147" src="image/B21282_08_07.jpg" width="722"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Selecting the main.py file</p>
<ol>
<li value="4">Then, we rewrite the <strong class="source-inline">motion_handler()</strong> method so that it reads <span class="No-Break">as follows:</span><pre class="source-code">
def motion_handler(pin):
    print('Motion detected!')
    if mqtt_client:
        if ARMED:
            activate_buzzer()
            mqtt_client.publish(b"IoTAlarm", b"buzzer")
            mqtt_client.publish(b"IoTAlarm",
                                b"location:43.6426,-79.3871")
        else:
            mqtt_client.publish(b"IoTAlarm", b"motion")
    else:
        print("MQTT client not connected.")</pre></li> <li>Our only change here is the addition of another publish method on the <strong class="source-inline">mqtt_client</strong> object. In<a id="_idIndexMarker635"/> the new <strong class="source-inline">publish()</strong> method, we create a message called <strong class="source-inline">location</strong> that provides the approximate GPS coordinates of the CN Tower in <span class="No-Break">Toronto, Canada.</span></li>
</ol>
<p class="callout-heading">IoT alarm module geolocation</p>
<p class="callout">We’ve designed our IoT alarm module to be permanently installed at an indoor location – that is, the hard-coded geolocation. We are<a id="_idIndexMarker636"/> using the CN Tower in Toronto, Canada as an example. You’re encouraged to provide your own unique <span class="No-Break">GPS coordinates.</span></p>
<ol>
<li value="6">We then save our changes to our Raspberry Pi <span class="No-Break">Pico W.</span></li>
</ol>
<p>We’ll see the impact of this adjustment when we set up and launch the IoT alarm dashboard on our Raspberry Pi 5 in the <span class="No-Break">upcoming section.</span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Writing the dashboard code</h2>
<p>For the IoT alarm dashboard, we’ll use the Raspberry Pi 5, the Raspberry Pi 7-inch touchscreen, and its compatible case. This <a id="_idIndexMarker637"/>configuration is like what we established in <a href="B21282_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, with the<a id="_idIndexMarker638"/> addition of an external buzzer exclusive to the IoT <span class="No-Break">alarm dashboard.</span></p>
<p>We’ll begin by setting up our development environment and installing the packages required for <span class="No-Break">our code.</span></p>
<h3>Setting up our development environment</h3>
<p>We will use a Python virtual <a id="_idIndexMarker639"/>environment for our development. As there are libraries that only work with the root installation of Python, we will use system packages in our Python virtual environment. To do so, we must do <span class="No-Break">the following:</span></p>
<ol>
<li>On our Raspberry Pi 5, we open a <span class="No-Break">Terminal application.</span></li>
<li>To store our project files, we create a new directory by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">mkdir dashboard</strong></pre></li> <li>Then, we navigate to the <span class="No-Break">new directory:</span><pre class="source-code">
<strong class="bold">cd dashboard</strong></pre></li> <li>Next, we create a new Python virtual environment for <span class="No-Break">our project:</span><pre class="source-code">
<strong class="bold">python -m venv dashboard-env --system-site-packages</strong></pre><p class="list-inset">With this command, we create a new Python virtual environment called <strong class="source-inline">dashboard-env</strong> and enable access to the <strong class="source-inline">--system-site-packages</strong>. This allows the virtual environment to inherit packages from the global Python environment without affecting the global <span class="No-Break">Python environment.</span></p></li> <li>With our new Python virtual environment created, we source into it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source dashboard-env/bin/activate</strong></pre></li> <li>Our Terminal application should now show that we are using the <strong class="source-inline">dashboard-env</strong> Python <span class="No-Break">virtual </span><span class="No-Break"><a id="_idIndexMarker640"/></span><span class="No-Break">environment:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer157">
<img alt="Figure 8.8 – Terminal showing the use of the dashboard-env environment" height="195" src="image/B21282_08_08.jpg" width="971"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Terminal showing the use of the dashboard-env environment</p>
<ol>
<li value="7">Next, we install the extra packages that are required for <span class="No-Break">our code:</span><pre class="source-code">
<strong class="bold">pip install kivy kivy-garden.mapview paho.mqtt==1.5.1</strong></pre><p class="list-inset">Kivy is an open source Python library for developing multitouch applications on various devices and platforms. The <strong class="source-inline">kivy-garden.mapview</strong> extension offers an interactive map widget, while <strong class="source-inline">paho.mqtt</strong> is a Python client library that enables MQTT communications; it’s popular in IoT due to its efficiency. We’re ensuring that we install the version of <strong class="source-inline">paho.mqtt</strong> that will work with our program by specifying that we <span class="No-Break">want </span><span class="No-Break"><strong class="source-inline">1.5.1</strong></span><span class="No-Break">.</span></p></li> <li>With the extra packages installed, we close <span class="No-Break">the Terminal:</span><pre class="source-code">
<strong class="bold">exit</strong></pre></li> <li>We are now ready to load up Thonny. To do so, we click on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigate to the <strong class="bold">Programming</strong> category, and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our project, we will use the Python virtual environment we just created. To start, we need to view the project files by clicking on <strong class="bold">View</strong> and selecting <strong class="bold">Files</strong> if it isn’t <span class="No-Break">already selected.</span></li>
<li>In the <strong class="source-inline">Files</strong> section, we locate and open the <span class="No-Break"><strong class="source-inline">dashboard-env</strong></span><span class="No-Break"> directory.</span></li>
<li>Then, right-click on the <strong class="source-inline">pyvenv.cfg</strong> file and <a id="_idIndexMarker641"/>select the <strong class="bold">Activate virtual </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> option:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer158">
<img alt="Figure 8.9 – Activating a Python virtual environment in Thonny" height="652" src="image/B21282_08_09.jpg" width="360"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Activating a Python virtual environment in Thonny</p>
<p class="callout-heading">Activating the Python virtual environment</p>
<p class="callout">In the steps above we activated the<a id="_idIndexMarker642"/> Python virtual environment by clicking on the <strong class="source-inline">pyvenv.cfg</strong> file. The step was outlined this way to show an alternative way to activate the Python virtual environment than the way shown in <span class="No-Break">previous chapters.</span></p>
<p>With our project folder created, our Python virtual environment set up, and the packages we need for our project installed, we can start writing the code for our IoT alarm dashboard. We will divide our code into two files – one for the GUI that creates the dashboard and the other<a id="_idIndexMarker643"/> to activate the buzzer. But before we do, we must wire up the buzzer to the GPIO port of our Raspberry <span class="No-Break">Pi 5.</span></p>
<h3>Wiring up the buzzer</h3>
<p>For our project, we will use an SFM-27 active buzzer. We wire the buzzer with the positive wire (red) connected to <a id="_idIndexMarker644"/>GPIO 4 and the negative wire (black) connected to GND on the Raspberry Pi 5. We have the option of installing the buzzer into a custom case, something we’ll cover later in this chapter. For our code development and testing purposes, it is enough to wire the SFM-127 active buzzer directly to the Raspberry <span class="No-Break">Pi 5:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<img alt="Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port" height="483" src="image/B21282_08_10.jpg" width="948"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port</p>
<p>With the buzzer connected to<a id="_idIndexMarker645"/> our Raspberry Pi 5, it is now time to write and test the buzzer code. We will use this code to activate the buzzer when our dashboard receives a <strong class="source-inline">buzzer</strong> message from the <span class="No-Break">MQTT server.</span></p>
<h3>Writing and testing the buzzer code</h3>
<p>We write our buzzer code using Thonny on our Raspberry Pi 5, which has a 7-inch screen. For more screen space to <a id="_idIndexMarker646"/>assist in coding, we can add another monitor through the Raspberry Pi 5’s mini-HDMI port, creating a <a id="_idIndexMarker647"/><span class="No-Break">dual-monitor setup.</span></p>
<p>To write and test our buzzer code, do <span class="No-Break">the following:</span></p>
<ol>
<li>We launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>We then activate the <strong class="source-inline">dashboard-env</strong> Python <span class="No-Break">virtual environment.</span></li>
<li>Once inside Thonny, we create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">your keyboard.</span></li>
<li>In our new file, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from gpiozero import TonalBuzzer
from gpiozero.tones import Tone
from time import sleep
class BuzzerMelody:
    def __init__(self, pin, notes=[('E4', 1),
                                   ('E4', 0.5),
                                   ('F4', 0.5),
                                   ('G4', 1.5)]):
        self.buzzer = TonalBuzzer(pin)
        self.melody = notes
    def play_melody(self):
        for note, duration in self.melody:
            self.buzzer.play(Tone(note))
            sleep(duration)
            self.buzzer.stop()
            sleep(0.1)  # pause between notes
if __name__ == "__main__":
    buzzer_melody = BuzzerMelody(4)
    buzzer_melody.play_melody()</pre></li> <li>We save the file<a id="_idIndexMarker648"/> as <strong class="source-inline">buzzer.py</strong> in the <strong class="source-inline">dashboard</strong> project folder on our Raspberry <span class="No-Break">Pi 5.</span><p class="list-inset">Before we test our <a id="_idIndexMarker649"/>code, let’s <span class="No-Break">examine it:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">TonalBuzzer</strong> class from the <span class="No-Break"><strong class="source-inline">gpiozero</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">Then, we import the <strong class="source-inline">Tone</strong> class <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">gpiozero.tones</strong></span><span class="No-Break">.</span></li><li class="upper-roman">We finish our imports by importing the <strong class="source-inline">sleep</strong> function from the <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">Next, we define a <strong class="source-inline">BuzzerMelody</strong> class: Initializer (<strong class="source-inline">__init__()</strong>) accepts a pin and a list of notes with their durations. The list has a default melody. Within the initializer, we do <span class="No-Break">the following:</span><ol><li class="lower-roman">Initialize a <strong class="source-inline">TonalBuzzer</strong> object with the <span class="No-Break">provided pin</span></li><li class="lower-roman">Set <span class="No-Break">the melody</span></li></ol></li><li class="upper-roman">Then, we define the <strong class="source-inline">play_melody()</strong> method. In this method, we do <span class="No-Break">the following:</span><ol><li class="lower-roman">Iterate through the <span class="No-Break">melody notes</span></li><li class="lower-roman">Play each note for its <span class="No-Break">specified duration</span></li><li class="lower-roman">Ensure the buzzer stops after the notes <span class="No-Break">are played</span></li><li class="lower-roman">Add a brief pause <span class="No-Break">between notes</span></li></ol></li><li class="upper-roman">If the script is <a id="_idIndexMarker650"/>executed as <a id="_idIndexMarker651"/>the main program, we do <span class="No-Break">the following:</span><ol><li class="lower-roman">Create an instance of the <strong class="source-inline">BuzzerMelody</strong> class with <span class="No-Break">pin 4</span></li><li class="lower-roman">Play the melody using the <span class="No-Break"><strong class="source-inline">play_melody()</strong></span><span class="No-Break"> method</span></li></ol></li></ol></li>
<li>We run the code in Thonny by clicking on the green run button, hitting <em class="italic">F5</em> on your keyboard, or clicking on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should hear a melody play from <span class="No-Break">our buzzer.</span></li>
</ol>
<p>With our buzzer code in place, it’s time to write our main dashboard code <span class="No-Break">using Kivy.</span></p>
<h3>Creating our Kivy dashboard</h3>
<p>As mentioned previously, we will be using the Raspberry Pi 5’s 7-inch touchscreen to display our dashboard. The<a id="_idIndexMarker652"/> use of this screen is optional as we may use a standard monitor with our <span class="No-Break">Raspberry Pi.</span></p>
<p>To write and test our Kivy dashboard code, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>We then activate the <strong class="source-inline">dashboard-env</strong> Python <span class="No-Break">virtual environment.</span></li>
<li>Once inside Thonny, create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">your keyboard.</span></li>
<li>We will start our code with the <span class="No-Break">necessary imports:</span><pre class="source-code">
from kivy.config import Config
Config.set('graphics', 'fullscreen', 'auto')
Config.set('graphics', 'borderless', '1')
from kivy.app import App
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.clock import Clock
from threading import Thread
import paho.mqtt.client as mqtt
from kivy_garden.mapview import MapView, MapMarkerPopup
from buzzer import BuzzerMelody</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ul><li><strong class="source-inline">kivy.config</strong>: Our code imports the configuration settings from Kivy to tailor the <span class="No-Break">application’s behavior.</span></li><li><strong class="source-inline">fullscreen</strong>: We configure the application to run in <span class="No-Break">fullscreen mode.</span></li><li><strong class="source-inline">borderless</strong>: Our settings <a id="_idIndexMarker653"/>eliminate the <span class="No-Break">window border.</span></li><li><strong class="source-inline">kivy.app</strong>: Our code accesses the primary application class from Kivy that’s used for initializing and operating <span class="No-Break">Kivy apps.</span></li><li><strong class="source-inline">kivy.uix.floatlayout</strong>: We import <strong class="source-inline">FloatLayout</strong>, a flexible layout mechanism that places widgets based on <span class="No-Break">relative coordinates.</span></li><li><strong class="source-inline">kivy.uix.label</strong>: Our code uses the <strong class="source-inline">Label</strong> widget, letting us display text within <span class="No-Break">the application.</span></li><li><strong class="source-inline">kivy.uix.button</strong>: We integrate the <strong class="source-inline">Button</strong> widget so that it can be used with <span class="No-Break">our keypad.</span></li><li><strong class="source-inline">kivy.clock</strong>: We utilize the <strong class="source-inline">Clock</strong> class to schedule specific functions to run at <span class="No-Break">timed intervals.</span></li><li><strong class="source-inline">Threading</strong>: To ensure smooth multitasking, our code uses threading for parallel operations. We use threading to run the <strong class="source-inline">start_mqtt()</strong> method in a <span class="No-Break">separate thread.</span></li><li><strong class="source-inline">paho.mqtt.client</strong>: We <a id="_idIndexMarker654"/>use the MQTT client library in our code to communicate with our <span class="No-Break">MQTT server.</span></li><li><strong class="source-inline">kivy_garden.mapview</strong>: Our code pulls in classes for presenting maps (<strong class="source-inline">MapView</strong>) and interactive map markers (<strong class="source-inline">MapMarkerPopup</strong>). We use these classes to visually represent the exact location on the map where the alarm has <span class="No-Break">been triggered.</span></li><li><strong class="source-inline">buzzer.BuzzerMelody</strong>: We import the <strong class="source-inline">BuzzerMelody</strong> class so that we can activate the <span class="No-Break">external buzzer.</span></li></ul></li> <li>Then, set the variable declarations for <span class="No-Break">our code:</span><pre class="source-code">
MQTT_SERVER = "codfish.rmq.cloudamqp.com"
MQTT_PORT = 1883
USERNAME = "&lt;&lt;MQTT server username&gt;&gt;"
MQTT_PASSWORD = "&lt;&lt;MQTT server password&gt;&gt;"
DEVICE_ID = "IoTAlarmDashboard"
TOPIC = "IoTAlarm"</pre></li> <li>From here, we must define the <strong class="source-inline">AlarmDashboard</strong> class, which inherits from the <strong class="source-inline">FloatLayout</strong> class, and define the <span class="No-Break">initialization method:</span><pre class="source-code">
class AlarmDashboard(FloatLayout):
    def __init__(self, **kwargs):
        super(AlarmDashboard, self).__init__(**kwargs)
        self.password_toggle = "1234"
        self.entered_password = ''
        self.system_armed = False
        self.lockout = False
        self.last_message = ''
        self.client = mqtt.Client(client_id=DEVICE_ID)
        self.client.username_pw_set(USERNAME, MQTT_PASSWORD)
        self.client.on_message = self.on_message
        Thread(target=self.start_mqtt).start()
        self.init_widgets()
        self.buzzer = BuzzerMelody(4)</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ol><li class="upper-roman">First, we initialize specific <a id="_idIndexMarker655"/>attributes, such as the default password (<strong class="source-inline">password_toggle</strong>), the currently entered password (<strong class="source-inline">entered_password</strong>), a system status flag (<strong class="source-inline">system_armed</strong>), a lockout status (<strong class="source-inline">lockout</strong>), and the last received <span class="No-Break">message (</span><span class="No-Break"><strong class="source-inline">last_message</strong></span><span class="No-Break">).</span></li><li class="upper-roman">Then, we set up an MQTT client with a unique <strong class="source-inline">client_id</strong> and provide it with the necessary authentication details using the <span class="No-Break"><strong class="source-inline">username_pw_set</strong></span><span class="No-Break"> method.</span></li><li class="upper-roman">The <strong class="source-inline">on_message</strong> attribute of the client is set to a method named <strong class="source-inline">on_message()</strong>, which our code will use to handle incoming <span class="No-Break">MQTT messages.</span></li><li class="upper-roman">We start the MQTT connection on a separate thread using the <strong class="source-inline">start_mqtt</strong> method to <a id="_idIndexMarker656"/>avoid blocking the <span class="No-Break">main application.</span></li><li class="upper-roman">The <strong class="source-inline">init_widgets</strong> method, which we’ll define later, is called to initialize and arrange the user <span class="No-Break">interface elements.</span></li><li class="upper-roman">Lastly, we initialize the <strong class="source-inline">buzzer</strong> attribute with an instance of the <strong class="source-inline">BuzzerMelody</strong> class, setting it up on GPIO <span class="No-Break">pin 4.</span></li></ol></li> <li>Now, use the <strong class="source-inline">on_message()</strong> method to handle messages coming from our <span class="No-Break">MQTT server:</span><pre class="source-code">
def on_message(self, client, userdata, msg):
    message = f"{str(msg.payload.decode('utf-8'))}"
    self.last_message = "Last message: " + message
    if message.startswith("location:"):
        parts = message.split(":")[1].split(",")
        lat = float(parts[0])
        lon = float(parts[1])
        Clock.schedule_once(
            lambda dt: self.update_map(lat, lon), 0
        )
    if message == "arm":
        Clock.schedule_once(
            lambda dt: self.update_system_status(True), 0
        )
    elif message == "disarm":
        Clock.schedule_once(
            lambda dt: self.update_system_status(False), 0
        )
    if message == "buzzer":
        self.buzzer.play_melody()
    Clock.schedule_once(
        lambda dt: self.update_message_display(), 0
    )</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ol><li class="upper-roman">Upon receiving a <a id="_idIndexMarker657"/>message, our code decodes the message payload from bytes to <span class="No-Break">a string</span></li><li class="upper-roman">The most recent message is stored with the <strong class="source-inline">Last </strong><span class="No-Break"><strong class="source-inline">message:</strong></span><span class="No-Break"> prefix</span></li><li class="upper-roman">If the received message starts with <strong class="source-inline">location:</strong>, it extracts latitude and <span class="No-Break">longitude values</span></li><li class="upper-roman">These values are then used to update the displayed map, scheduling the <span class="No-Break"><strong class="source-inline">update_map()</strong></span><span class="No-Break"> method</span></li><li class="upper-roman">If the message that’s received is <strong class="source-inline">arm</strong>, the system’s status is updated to <strong class="source-inline">armed</strong> via the <span class="No-Break"><strong class="source-inline">update_system_status()</strong></span><span class="No-Break"> method</span></li><li class="upper-roman">If the message that’s received is <strong class="source-inline">disarm</strong>, the system’s status is updated to <strong class="source-inline">disarmed</strong> via the <span class="No-Break"><strong class="source-inline">update_system_status()</strong></span><span class="No-Break"> method</span></li><li class="upper-roman">If the message that’s received is <strong class="source-inline">buzzer</strong>, a melody is played through the <strong class="source-inline">buzzer</strong> instance via <a id="_idIndexMarker658"/>the <span class="No-Break"><strong class="source-inline">play_melody()</strong></span><span class="No-Break"> method</span></li><li class="upper-roman">Regardless of the message’s content, the message that’s displayed is updated using the <span class="No-Break"><strong class="source-inline">update_message_display()</strong></span><span class="No-Break"> method</span></li></ol></li> </ol>
<p class="callout-heading">Using the lambda() function in our code</p>
<p class="callout">The <strong class="source-inline">lambda()</strong> function is used as an anonymous, inline function in Python. It’s typically used for brief operations that are expressed in a single statement. Specifically, in our code, the <strong class="source-inline">lambda()</strong> function pairs with Kivy’s <strong class="source-inline">Clock.schedule_once()</strong> method to delay certain method executions. By using the <strong class="source-inline">Clock.schedule_once()</strong> method, a function can be scheduled to run after a specified delay. When <strong class="source-inline">0</strong> is given as its second argument, it indicates the function should be called immediately on the <span class="No-Break">next frame.</span></p>
<p class="callout">Each instance of the <strong class="source-inline">lambda()</strong> function in our code follows the <strong class="source-inline">lambda dt: some_method(arguments)</strong> pattern. Here, <strong class="source-inline">dt</strong> represents the time that’s elapsed since the last frame. It’s an argument that <strong class="source-inline">Clock.schedule_once()</strong> automatically provides. For example, <strong class="source-inline">Clock.schedule_once(lambda dt: self.update_map(lat, lon), 0)</strong> schedules the <strong class="source-inline">self.update_map(lat, lon)</strong> method for execution on the upcoming frame, with the already parsed <strong class="source-inline">lat</strong> and <strong class="source-inline">lon</strong> values as its arguments. Essentially, these <strong class="source-inline">lambda()</strong> functions act as a conduit, passing arguments to methods and setting them up for execution on the next frame via Kivy’s scheduling mechanism. Utilizing the <strong class="source-inline">Clock()</strong> function ensures that our UI updates remain smooth and synchronized with the display’s refresh rate, and also prevents blocking of the main thread, thus enhancing the responsiveness of <span class="No-Break">the application.</span></p>
<ol>
<li value="8">Our code defines a method called <strong class="source-inline">update_map()</strong>, whose purpose is to update the displayed <a id="_idIndexMarker659"/>map in two <span class="No-Break">main ways:</span><pre class="source-code">
    def update_map(self, lat, lon):
        self.mapview.center_on(lat, lon)
        marker = MapMarkerPopup(lat=lat, lon=lon)
        self.mapview.add_widget(marker)</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ol><li class="upper-roman">Our code adjusts the center of the map to the new latitude and longitude coordinates, which are provided as arguments (<strong class="source-inline">lat</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">lon</strong></span><span class="No-Break">).</span></li><li class="upper-roman">Then, it places a marker (specifically an interactive marker that can show a popup) on the map at the specified coordinates. This marker indicates the exact location of the IoT alarm module that triggered <span class="No-Break">the alarm.</span></li></ol></li> <li>The <strong class="source-inline">update_system_status()</strong> method updates the status message on our dashboard based on the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">is_armed</strong></span><span class="No-Break">:</span><pre class="source-code">
    def update_system_status(self, is_armed):
        if is_armed:
            self.system_armed = True
            self.system_status.text = "System is ARMED"
            self.system_status.color = (0, 1, 0, 1)
        else:
            self.system_armed = False
            self.system_status.text = "System is DISARMED"
            self.system_status.color = (1, 0, 0, 1)</pre></li> <li>Then, our code defines a method named <strong class="source-inline">start_mqtt()</strong> that sets up and initiates the MQTT <a id="_idIndexMarker660"/>communication for <span class="No-Break">the application:</span><pre class="source-code">
    def start_mqtt(self):
        self.client.connect(MQTT_SERVER, MQTT_PORT)
        self.client.subscribe(TOPIC)
        self.client.loop_forever()</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ol><li class="upper-roman">The method connects the MQTT client to the specified MQTT server using the given server address (<strong class="source-inline">MQTT_SERVER</strong>) and port <span class="No-Break">number (</span><span class="No-Break"><strong class="source-inline">MQTT_PORT</strong></span><span class="No-Break">).</span></li><li class="upper-roman">Once connected, the client subscribes to a specific topic (<strong class="source-inline">TOPIC</strong>), meaning it will start listening for messages that are published on <span class="No-Break">that topic.</span></li><li class="upper-roman">Finally, the <strong class="source-inline">loop_forever()</strong> method of the client is called, which keeps the MQTT client continuously checking for incoming messages and handling them for as long as the <span class="No-Break">application runs.</span></li></ol></li> <li>Our code defines a method named <strong class="source-inline">init_widgets()</strong> for initializing and placing various user interface <a id="_idIndexMarker661"/>components on our dashboard. We will start with the <strong class="bold">keypad </strong><span class="No-Break"><strong class="bold">initialization</strong></span><span class="No-Break"> process:</span><pre class="source-code">
def init_widgets(self):
    # Keypad buttons
    positions = [
        (0.03, 0.75), (0.14, 0.75), (0.25, 0.75),
        (0.03, 0.55), (0.14, 0.55), (0.25, 0.55),
        (0.03, 0.35), (0.14, 0.35), (0.25, 0.35)
    ]
    for index, pos in enumerate(positions, 1):
        btn = Button(
            text=str(index), size_hint=(0.1, 0.1),
            pos_hint={'x': pos[0], 'y': pos[1]}
        )
        btn.bind(on_press=self.handle_key_press)
        self.add_widget(btn)</pre><p class="list-inset">Here, a keypad layout is set up with buttons arranged in a 3x3 grid. The positions of these buttons are specified using the <strong class="source-inline">positions</strong> list, where each tuple represents the relative <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> coordinates. As we loop through these positions, we create a <a id="_idIndexMarker662"/>button with a corresponding number and bind its <strong class="source-inline">on_press</strong> event to the <strong class="source-inline">handle_key_press()</strong> method, which will capture the button press actions. Each button, once initialized, is added to the dashboard using the <span class="No-Break"><strong class="source-inline">add_widget()</strong></span><span class="No-Break"> method.</span></p></li> <li>Now, write the code for the <strong class="bold">system </strong><span class="No-Break"><strong class="bold">status label</strong></span><span class="No-Break">:</span><pre class="source-code">
    # System status
    self.system_status = Label(
        text="System is DISARMED",
        size_hint=(1, 0.2),
        pos_hint={'x': -0.3, 'y': 0.1},
        font_size=30,
        color=(1, 0, 0, 1)
    )
    self.add_widget(self.system_status)</pre><p class="list-inset">This label displays the status of the system, indicating whether it is armed or disarmed. It’s styled with a <a id="_idIndexMarker663"/>specific text size, color, and positioning. Once initialized, the label is added to <span class="No-Break">the dashboard.</span></p></li> <li>Next, set up a label for the <strong class="bold">MQTT </strong><span class="No-Break"><strong class="bold">message display</strong></span><span class="No-Break">:</span><pre class="source-code">
    # MQTT Messages
    self.message_display = Label(
        text="Waiting for message...",
        size_hint=(0.77, 0.6),
        pos_hint={'x': 0.23, 'y': 0.62},
        font_size=25,
        color=(1, 1, 1, 1)
    )
    self.add_widget(self.message_display)</pre><p class="list-inset">Here, a label has been set up to display incoming MQTT messages. It has a default text of <strong class="source-inline">Waiting for message...</strong> and is styled similarly to the system status label. Once it’s been created, it’s added to <span class="No-Break">the dashboard.</span></p></li> <li>Finally, add a <span class="No-Break"><strong class="bold">MapView widget</strong></span><span class="No-Break">:</span><pre class="source-code">
    self.mapview = MapView(
        zoom=15, lat=52.379189, lon=4.899431,
        size_hint=(0.5, 0.7), pos_hint={'x': 0.45, 'y': 0.15}
    )
    self.add_widget(self.mapview)</pre><p class="list-inset">Here, we initialize a <strong class="source-inline">MapView</strong> widget to display geographical locations. It’s preset to a specific zoom level and initial latitude and longitude coordinates. This map view allows us to <a id="_idIndexMarker664"/>visualize locations on a map. Once initialized, it’s added to <span class="No-Break">our dashboard.</span></p></li> <li>The <strong class="source-inline">update_message_display()</strong> method is used to refresh or update the text that’s displayed in the <strong class="source-inline">message_display</strong> widget to show the latest message that’s been received by <span class="No-Break">the system:</span><pre class="source-code">
    def update_message_display(self):
        self.message_display.text = self.last_message</pre></li> <li>The <strong class="source-inline">handle_key_press()</strong> method manages the user’s interactions with the virtual keypad when inputting the alarm system’s passcode, determines the validity of the entered code, and adjusts the alarm system’s status based on the <span class="No-Break">passcode input:</span><pre class="source-code">
def handle_key_press(self, instance):
    if not self.lockout:
        self.entered_password += instance.text
        print("The key:" + instance.text + " was pressed")
        if len(self.entered_password) == 4:
            if self.entered_password == self.password_toggle:
                if self.system_armed:
                    self.system_armed = False
                    self.system_status.text = "System is\
    DISARMED"
                    self.system_status.color = (1, 0, 0, 1)
                    self.client.publish(TOPIC, "disarm")
                else:
                    self.system_armed = True
                    self.system_status.text = "System is ARMED"
                    self.system_status.color = (0, 1, 0, 1)
                    self.client.publish(TOPIC, "arm")
                self.entered_password = ''
            else:
                self.lockout = True
                Clock.schedule_once(self.end_lockout, 5)
                self.entered_password = ''</pre><p class="list-inset">Let’s examine <span class="No-Break">this code:</span></p><ul><li><strong class="bold">Lockout check</strong>: The method begins by determining if the system is currently in a <em class="italic">lockout</em> state, preventing<a id="_idIndexMarker665"/> any further input <span class="No-Break">if true.</span></li><li><strong class="bold">Accumulating key presses</strong>: Each button press on the keypad is appended to the <strong class="source-inline">self.entered_password</strong> string, representing the user’s current <span class="No-Break">passcode input.</span></li><li><strong class="bold">Logging the keypress</strong>: For debugging purposes, the specific key that was pressed is <span class="No-Break">printed out.</span></li><li><strong class="bold">Password verification</strong>: Once the user has entered a 4-digit code, the <strong class="source-inline">handle_key_press()</strong> method verifies if it matches the predefined alarm system code. If the code is correct, the <span class="No-Break">following occurs:</span><ol><li class="lower-roman">The alarm system’s status toggles between <strong class="source-inline">armed</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">disarmed</strong></span><span class="No-Break">.</span></li><li class="lower-roman">A corresponding message (<strong class="source-inline">arm</strong> or <strong class="source-inline">disarm</strong>) is sent to the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> topic.</span></li></ol></li><li><strong class="bold">Incorrect code handling</strong>: If the code that’s been entered is incorrect, the system is placed in <span class="No-Break"><strong class="source-inline">lockout</strong></span><span class="No-Break"> mode:</span><ol><li class="lower-roman" value="1">A timer is initiated to<a id="_idIndexMarker666"/> end the lockout state after a specified duration (5 seconds in <span class="No-Break">this case).</span></li><li class="lower-roman">The code that was entered is reset in anticipation of <span class="No-Break">another attempt.</span></li></ol></li></ul></li> </ol>
<ol>
<li value="17">The <strong class="source-inline">end_lockout()</strong> function is designed to terminate the lockout state of the system. Setting the <strong class="source-inline">lockout</strong> attribute to <strong class="source-inline">False</strong> ensures that subsequent operations or interactions that were restricted during the lockout are <span class="No-Break">now permitted:</span><pre class="source-code">
    def end_lockout(self, dt):
        self.lockout = False</pre></li> <li>At this point, our code introduces the main application class, <strong class="source-inline">MyApp</strong>, which is built upon Kivy’s App framework. Inside this class, the <strong class="source-inline">build()</strong> method constructs and returns an instance of <strong class="source-inline">AlarmDashboard</strong>. If we run this code directly (not imported into another script), the <strong class="source-inline">if __name__ == '__main__':</strong> check ensures that a new <strong class="source-inline">MyApp</strong> instance is created and launched, initiating the entire <span class="No-Break">alarm application:</span><pre class="source-code">
class MyApp(App):
    def build(self):
        return AlarmDashboard()
if __name__ == '__main__':
    MyApp().run()</pre></li> <li>Save our code as <strong class="source-inline">dashboard.py</strong> in the <span class="No-Break">project folder.</span></li>
</ol>
<p>With our dashboard code written and our buzzer tested, it is time to build the custom stand for our buzzer. As always, this is <a id="_idIndexMarker667"/>optional; we may run our application without encasing the buzzer into a stand. However, doing so makes our application more professional-looking, enhances user experience, and offers a more polished presentation, ensuring that the buzzer is positioned securely and easily accessible <span class="No-Break">when needed.</span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor134"/>Building the external alarm buzzer stand</h1>
<p>Encasing our buzzer in a custom <a id="_idIndexMarker668"/>stand enhances our IoT alarm dashboard. In this section, we will build the stand. We will start by identifying the parts that make up our custom buzzer stand before we <span class="No-Break">assemble it.</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>Identifying the parts</h2>
<p>The parts that make up the<a id="_idIndexMarker669"/> custom buzzer stand can be made with either a 3D printer or a 3D printing service such as <span class="No-Break">Shapeways (</span><a href="https://www.shapeways.com"><span class="No-Break">https://www.shapeways.com</span></a><span class="No-Break">).</span></p>
<p>These parts are shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
<ul>
<li><em class="italic">A</em>: This is a 3D-printed version of the <strong class="source-inline">Stand.stl</strong> file, which is located in the <strong class="source-inline">Build Files/Buzzer Stand</strong> folder of this chapter’s GitHub repository. This version of the file was 3D printed using a liquid resin 3D printer and was subsequently painted. For those of us who prefer to use an FDM printer, the split stand located under <strong class="source-inline">Build Files/Split Stand</strong> would be a <span class="No-Break">better option:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer160">
<img alt="Figure 8.11 – Parts of the custom buzzer stand" height="652" src="image/B21282_08_11.jpg" width="1488"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Parts of the custom buzzer stand</p>
<ul>
<li><em class="italic">B</em>: This is our standard hook. It’s a liquid resin 3D-printed version of the <strong class="source-inline">Hook.stl</strong> file, which is located in the <strong class="source-inline">Build Files</strong> folder of this chapter’s <span class="No-Break">GitHub repository.</span></li>
<li><em class="italic">C</em>: This is the standard<a id="_idIndexMarker670"/> SFM-127 active buzzer that this stand was designed <span class="No-Break">to hold.</span></li>
<li><em class="italic">D</em>: This is a painted FDM 3D-printed version of the <strong class="source-inline">Front.stl</strong> file, which is also located in the <strong class="source-inline">Build </strong><span class="No-Break"><strong class="source-inline">Files</strong></span><span class="No-Break"> folder.</span></li>
<li><em class="italic">E</em>: An FDM 3D printer was used to create a version of the <strong class="source-inline">Back.stl</strong> file. This part connects the front (<em class="italic">D</em>) to the stand (<em class="italic">A</em>) using the <span class="No-Break">hook (</span><span class="No-Break"><em class="italic">B</em></span><span class="No-Break">).</span></li>
<li>Not shown: A multi-conductor cable such as a discarded <span class="No-Break">USB cable.</span></li>
<li>Not shown: 2x M4 <span class="No-Break">20mm bolts.</span></li>
<li>Not shown: 2x M3 <span class="No-Break">10mm bolts.</span></li>
<li>Not shown: 2x M2 <span class="No-Break">5mm bolts.</span></li>
<li>Not shown: 1x M5 <span class="No-Break">20mm bolt.</span></li>
<li>Not shown: 1x <span class="No-Break">M5 nut.</span></li>
<li>Not shown: 2x female<a id="_idIndexMarker671"/> jumper terminals for connecting the buzzer to the <span class="No-Break">GPIO port.</span></li>
</ul>
<p class="callout-heading">Which type of 3D printer should be used to create the parts?</p>
<p class="callout">In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.9</em>, parts were created using both FDM and liquid resin 3D printers. The choice of printer depends on the user’s experience and the part’s design. Flat parts, such as <em class="italic">E</em> and <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.10</em>, are ideal for FDM printers. Ornamental designs, such as part <em class="italic">A</em>, benefit from liquid resin printers. While hook (<em class="italic">B</em>) can use either method, we chose a liquid resin printer with an engineering-grade resin (Siraya Tech Blu) for <span class="No-Break">added strength.</span></p>
<p>With our parts identified, it is time to build our custom <span class="No-Break">buzzer stand.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>Building the stand</h2>
<p>To build the custom buzzer stand, we must <a id="_idIndexMarker672"/>follow the steps shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<img alt="Figure 8.12 – Steps to build the custom buzzer stand" height="747" src="image/B21282_08_12.jpg" width="1445"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Steps to build the custom buzzer stand</p>
<p>Let’s take a <span class="No-Break">closer look:</span></p>
<ol>
<li>Using two M4 10mm bolts, secure the buzzer (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>) to the front casing (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>). The bolts should screw tightly into the buzzer. If they’re loose, we <a id="_idIndexMarker673"/>may tighten them with two <span class="No-Break">M4 nuts.</span></li>
<li>Using a multi-conductor cable, such as a discarded USB cable, solder two wires to the buzzer (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
<li>Thread the multi-conductor cable through the hole on the front casing (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>) and apply glue via a hot glue gun to secure the cable to <span class="No-Break">the casing.</span></li>
<li>Using the same two wires (red and black, in our example) of the multi-conductor cable, crimp two female jumper terminals to the ends of the wire. An option here is to solder pre-existing jumper cables to the end instead <span class="No-Break">of crimping.</span></li>
<li>Then, secure the hook (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>) to the back plate (see <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>) by either using two M2 5mm screws or <span class="No-Break">epoxy glue.</span></li>
<li>Using two M3 10mm bolts, secure the back plate (see <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em>) to the front casing (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
<li>Using an M5 20mm bolt and M5 nut, secure the assembled casing to the stand (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
</ol>
<p>With the custom stand built, we<a id="_idIndexMarker674"/> may re-connect our buzzer to the GPIO port of the Raspberry Pi 5 by following the wiring diagram shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">.</span></p>
<p>We are now ready to test <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/>Running our application</h1>
<p>It’s now time for the moment we have<a id="_idIndexMarker675"/> been building toward over the last few chapters: testing our entire IoT alarm system. With the IoT alarm dashboard built, our IoT alarm system <span class="No-Break">is complete:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<img alt="Figure 8.13 – Completed IoT alarm system" height="938" src="image/B21282_08_13.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Completed IoT alarm system</p>
<p>We started by building the IoT alarm module (see <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>) in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, before proceeding to build IoT buttons (see <em class="italic">A</em> and <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>) in <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. In this chapter, we used the Raspberry Pi 5 with an active buzzer (see <em class="italic">B</em> and <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>), a Raspberry Pi 7-inch <a id="_idIndexMarker676"/>screen and case (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>), a keyboard (see <em class="italic">F</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>), and a mouse (see <em class="italic">G</em> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>) to build the IoT <span class="No-Break">alarm dashboard.</span></p>
<p>To test the IoT alarm dashboard, we simply need to arm the IoT alarm module and activate it by moving an object in front of its PIR sensor. To do so, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>To arm the IoT alarm module, using our mouse, we type the four-digit PIN code (1234) into the keypad of the IoT <span class="No-Break">alarm dashboard.</span></li>
<li>We should observe that the IoT alarm module goes into armed mode by the long blinking of the LED. To activate the alarm, we wave our hands in front of the <span class="No-Break">PIR sensor.</span></li>
<li>After a few seconds, we should hear the buzzer on the IoT alarm module, followed by the buzzers on the IoT button (version 2) and the IoT <span class="No-Break">alarm dashboard.</span></li>
<li>We should also observer that a map of Toronto with a marker at the CN Tower should be displayed on <a id="_idIndexMarker677"/>the screen of the IoT <span class="No-Break">alarm dashboard:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer163">
<img alt="Figure 8.14 – IoT alarm dashboard showing the location where the alarm was activated" height="451" src="image/B21282_08_14.jpg" width="905"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – IoT alarm dashboard showing the location where the alarm was activated</p>
<p>Having successfully tested the IoT alarm system, we’ve concluded the second part of this book. Throughout this journey, we’ve explored internet-based device communication and harnessed the capabilities of the Raspberry Pi Pico W microcontroller and Raspberry Pi 5 computer. This foundation will be invaluable for the advanced projects in <span class="No-Break">this book.</span></p>
<p>If we really want a challenge, we could position each component of the IoT alarm system as far apart as possible, perhaps by giving a component to a friend in another city. Doing such an activity will help us appreciate not only IoT but our internet-connected world <span class="No-Break">in general.</span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/>Summary</h1>
<p>In this chapter, we completed our IoT alarm system by building an IoT alarm dashboard. We began by understanding IoT alarm dashboards and their usage by considering an example of the level and temperature of a tank. Throughout this chapter, we went through the step-by-step process of setting up, coding, and testing our IoT alarm dashboard, including adding a custom stand for an <span class="No-Break">external buzzer.</span></p>
<p>We constructed a dashboard for our IoT alarm system using Kivy on the Raspberry Pi 5. The dashboard integrated map functionality to pinpoint the location of any activated IoT <span class="No-Break">alarm module.</span></p>
<p>As we close this section on the IoT alarm system, we look forward to the next exciting challenge: building a remote monitoring station using LoRa. This next section will introduce us to long-range communication, broadening our understanding and capabilities in <span class="No-Break">IoT projects.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer165">
<h1 id="_idParaDest-139" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor139"/>Part 3: Creating a LoRa-Enabled IoT Monitoring Station</h1>
<p>In this part, we will create a remote environmental monitoring station, using LoRa to collect and transmit data on temperature and humidity and transmit it over the internet. We will use this data to control an analog <span class="No-Break">weather indicator.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21282_09.xhtml#_idTextAnchor140"><em class="italic">Chapter 9</em></a>, <em class="italic">Understanding LoRa</em></li>
<li><a href="B21282_10.xhtml#_idTextAnchor157"><em class="italic">Chapter 10</em></a>, <em class="italic">Integrating LoRa with the Internet</em></li>
</ul>
</div>
<div>
<div id="_idContainer166">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer167">
</div>
</div>
</div></body></html>