<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer110">
<h1 id="_idParaDest-122"><em class="italic"><a id="_idTextAnchor124"/>Chapter 9</em>: Understanding Code through Abstract Syntax Tree</h1>
<p>In this chapter, we will look at what abstract syntax trees are and how to understand the syntax tree of each unit of the Python code we write.</p>
<p>Any programming language is designed with its own syntax, which is used by developers while coding in the language following specific syntax. The interpreter or compiler of a programming language interprets the syntax of the language and compiles or interprets the code and executes it to achieve the desired result.</p>
<p>In Python, an <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) provides an abstract representation of the syntax of the code in the form of a tree. Python has a library named <strong class="source-inline">ast</strong> that can be used to understand the abstract syntax of the code that we develop. </p>
<p>Throughout this chapter, we will look at understanding the syntax tree of some of the important code snippets that we developed in previous chapters, and we will also look at modifying or adding more information to the code through a few examples. We will be making use of abstract syntax trees throughout this chapter to perform an analysis of the code.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Exploring the <strong class="source-inline">ast</strong> library</li>
<li>Inspecting Python code with abstract syntax trees</li>
<li>Understanding abstract syntax trees with applications</li>
</ul>
<p>By the end of this chapter, you should be able to understand the abstract syntax tree of Python code. You should also be able to inspect, parse, and modify the abstract syntax tree of source code through metaprogramming.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9</a>.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor126"/>Exploring the ast library</h1>
<p>In this section, we will explore the <strong class="source-inline">ast</strong> Python library, which can be imported from Python 3 to analyze the Python code written by developers. We can also use it to modify the code through its abstract syntax tree at a <a id="_idIndexMarker434"/>metaprogramming level rather than modifying the syntax of the code itself. This helps in understanding how the code is syntactically represented and how the syntax tree of the code can be used to modify its behavior without modifying the original source code. We will look at some of the important functions of the <strong class="source-inline">ast</strong> library, as those functions will be used throughout this chapter to understand the code from our core example.</p>
<p>Let’s start by importing the <strong class="source-inline">ast</strong> library:</p>
<pre class="source-code">import ast</pre>
<p>Once we import the library, we can look at analyzing a piece of code using this library. We will now create a variable named <strong class="source-inline">assignment</strong> and assign a string format of the code to it:</p>
<pre class="source-code">assignment = "product_name = 'Iphone X'"</pre>
<p>The output of the <strong class="source-inline">assignment</strong> variable appears as follows:</p>
<pre class="source-code">assignment</pre>
<p class="source-code"><strong class="bold">"product_name = 'Iphone X'"</strong></p>
<p>The preceding code can be parsed into its corresponding nodes using the <strong class="source-inline">parse</strong> method of the <strong class="source-inline">ast</strong> library. We will now create a variable named <strong class="source-inline">assign_tree</strong> and store the parsed node of the lines of code stored under <strong class="source-inline">assignment</strong>:</p>
<pre class="source-code">assign_tree = ast.parse(assignment)</pre>
<pre class="source-code">assign_tree</pre>
<p>The output of the parsed node looks as follows:</p>
<pre class="source-code">&lt;ast.Module at 0x1b92b3f6520&gt;</pre>
<p>Now, we can make use of another method called <strong class="source-inline">dump</strong> to print the tree structure of the node with each of its values and fields. This helps in debugging the code:</p>
<pre class="source-code">print(ast.dump(assign_tree,indent = 4))</pre>
<p>The output of the code<a id="_idIndexMarker435"/> is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 9.1 – Example of an abstract syntax tree " height="127" src="image/Figure_9.1_B13426.jpg" width="451"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Example of an abstract syntax tree</p>
<p>The <strong class="source-inline">"product_name = 'Iphone X'"</strong> code is broken down into multiple parts. The syntax of any code in Python is grammatically embedded into <strong class="source-inline">Module</strong> followed by <strong class="source-inline">body</strong>. We have assigned the <strong class="source-inline">Iphone X</strong> value to the <strong class="source-inline">product_name</strong> variable and so the code that performs a value assignment is identified by the <strong class="source-inline">Assign</strong> branch, which has attributes mapped with the corresponding ID, context, and value. This is an example of what a simple representation of a node would look like. For multiple lines of code with various other operations, the node will have multiple other branches in the tree.</p>
<p>Let’s start inspecting the Python code for a few examples of using abstract syntax trees in the following section.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/>Inspecting Python code with abstract syntax trees</h1>
<p>In this section, we will review<a id="_idIndexMarker436"/> and understand the code for a<a id="_idIndexMarker437"/> simple arithmetic addition example, and we will also further look into parsing the code and modifying it using abstract syntax trees.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>Reviewing simple code using ast</h2>
<p>In this section, let’s review simple <a id="_idIndexMarker438"/>code that adds two numbers, and let’s look at all the elements of the node, and also how the elements are organized in the tree. Let’s begin by writing code to assign two variables, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, with numerical values, and <strong class="source-inline">c</strong> as the sum of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. Finally, let’s print the <strong class="source-inline">c</strong> value. This is shown in the following code:</p>
<pre class="source-code">addfunc = """</pre>
<pre class="source-code">a = 1098</pre>
<pre class="source-code">b = 2032</pre>
<pre class="source-code">c = a + b</pre>
<pre class="source-code">print(c)</pre>
<pre class="source-code">"""</pre>
<p>We will now parse the preceding <strong class="source-inline">addfunc</strong> and store the node in another variable called <strong class="source-inline">add_tree</strong>:</p>
<pre class="source-code">add_tree = ast.parse(addfunc)</pre>
<pre class="source-code">add_tree</pre>
<p>The output of the parsed node is as follows:</p>
<p class="source-code">&lt;ast.Module at 0x19c9b2bf2e0&gt;</p>
<p>The base element of the node is <strong class="source-inline">Module</strong>, and all the other lines of code are split into semantics that are stored within the module of the node. </p>
<p>Let’s look at the detailed tree representation in the following code by calling the <strong class="source-inline">dump</strong> method on the tree:</p>
<pre class="source-code">print(ast.dump(add_tree, indent=4))</pre>
<p>The tree begins with <strong class="source-inline">Module</strong> as its base element, or the trunk followed by multiple branches. <strong class="source-inline">Module</strong> is followed by <strong class="source-inline">body</strong> as a list item that lists down all other elements of the code.</p>
<p>Within <strong class="source-inline">body</strong>, there will be four list items that describe the operations of <strong class="source-inline">addfunc</strong>. The first one, which is also the first line of <strong class="source-inline">addfunc</strong>, is to assign the <strong class="source-inline">Constant</strong> value <strong class="source-inline">1098</strong> to a variable with a name whose id is <strong class="source-inline">a</strong> and the context of the value is <strong class="source-inline">Store</strong> since we are storing the value in the variable. Here is how it appears:</p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 9.2 – Code snippet output " height="108" src="image/Figure_9.2_B13426.jpg" width="366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Code snippet output</p>
<p>Similarly, the second<a id="_idIndexMarker439"/> line of <strong class="source-inline">addfunc</strong> is to store the <strong class="source-inline">2032</strong> value in the <strong class="source-inline">b</strong> variable, which is represented grammatically in the following list item:</p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 9.3 – Code snippet output " height="74" src="image/Figure_9.3_B13426.jpg" width="302"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Code snippet output</p>
<p>The third line of code in <strong class="source-inline">addfunc</strong> has the arithmetic operation of adding the two values stored in <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 9.4 – Code snippet output " height="126" src="image/Figure_9.4_B13426.jpg" width="350"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Code snippet output</p>
<p>The preceding code has an additional element, <strong class="source-inline">BinOp</strong>, followed by <strong class="source-inline">left</strong>, <strong class="source-inline">op</strong>, and <strong class="source-inline">right</strong> variables to indicate the left numerical value, addition operation, and right numerical value, respectively.</p>
<p>The last line of the code in <strong class="source-inline">addfunc</strong> is the <strong class="source-inline">Expr</strong> expression element, which represents the printing of the <strong class="source-inline">c</strong> variable with a context value of <strong class="source-inline">Load</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 9.5 – Code snippet output " height="127" src="image/Figure_9.5_B13426.jpg" width="392"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Code snippet output</p>
<p>To execute <strong class="source-inline">addfunc</strong>, we need to first compile the parsed tree as follows:</p>
<pre class="source-code">add_code = compile(add_tree, 'add_tree', 'exec')</pre>
<p>Post-compilation, we <a id="_idIndexMarker440"/>should be able to execute the compiled tree, which results in the addition of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>:</p>
<pre class="source-code">exec(add_code)</pre>
<p>The following is the output of the code:</p>
<p class="source-code">3130</p>
<p>In this section, we reviewed the abstract syntax tree of the simple arithmetic <strong class="source-inline">add</strong> function. In the following section, let’s look at modifying the code of the <strong class="source-inline">add</strong> function using metaprogramming.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>Modifying simple code using ast</h2>
<p>In this section, let’s consider the <a id="_idIndexMarker441"/>example of <strong class="source-inline">addfunc</strong> from the preceding section and look at how to modify the code in the example through metaprogramming, without modifying the actual code. The operation performed by the code in <strong class="source-inline">addfunc</strong> is arithmetic addition. What if we want to perform arithmetic multiplication instead of addition and we don’t want the actual code to be modified? What if there are multiple locations where we want arithmetic addition to be replaced by arithmetic multiplication, and browsing through thousands of lines of code and modifying them is not a feasible option as it might impact or break something else in the code? In such scenarios, we <a id="_idIndexMarker442"/>can modify the node of the code using its syntax tree instead of modifying the actual code itself. To achieve this, let’s make use of the abstract syntax tree of the code. </p>
<p>Let’s reuse the <strong class="source-inline">add_tree</strong> parsed tree variable from the code in the preceding section:</p>
<pre class="source-code">add_tree</pre>
<pre class="source-code"><strong class="bold">&lt;ast.Module at 0x19c9b2bf2e0&gt;</strong></pre>
<p>To understand which fields to modify, let’s look at the following representation of the node and look at each section of the node marked by an identifier. The elements of interest for this example are represented inside a box in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 9.6 – Parsed node of addfunc " height="706" src="image/Figure_9.6_B13426.jpg" width="1041"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Parsed node of addfunc</p>
<p>To modify the add operation into a multiplication operation, the tree for this node traverses through <strong class="source-inline">body</strong> followed by its list item <strong class="source-inline">2</strong>, followed by the <strong class="source-inline">value</strong> field of the item, followed by the <strong class="source-inline">op</strong> field. The <strong class="source-inline">Add()</strong> operation of the <strong class="source-inline">op</strong> field will have to be modified into a multiplication<a id="_idIndexMarker443"/> operation to achieve our goal for this section. Here’s how:</p>
<pre class="source-code">add_tree.body[2].value.op=ast.Mult()</pre>
<p>Executing the preceding code results in a change of the tree:</p>
<pre class="source-code">print(ast.dump(add_tree, indent=4))</pre>
<p>The figure of the updated tree structure is represented as follows, with the <strong class="source-inline">Add()</strong> operation replaced by the <strong class="source-inline">Mult()</strong> operation:</p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 9.7 – Tree modified to perform multiplication " height="713" src="image/Figure_9.7_B13426.jpg" width="1098"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Tree modified to perform multiplication</p>
<p>To verify whether the preceding modification on the tree node works, let’s compile the tree and execute it to check the results:</p>
<pre class="source-code">add_code = compile(add_tree, 'add_tree', 'exec')</pre>
<pre class="source-code">exec(add_code)</pre>
<p>Executing the preceding code should have ideally provided an output of <strong class="source-inline">3130</strong>, which is the addition of two numbers, <strong class="source-inline">1098</strong> and <strong class="source-inline">2032</strong>. But we have modified <strong class="source-inline">ast</strong> to perform multiplication instead and so it would result in the value, which is a product of the two numbers:</p>
<pre class="source-code"><strong class="bold">2231136</strong></pre>
<p>Thus the tree is now<a id="_idIndexMarker444"/> modified and can be compiled to achieve the desired result without modifying the actual code.</p>
<p>With this understanding, let’s proceed further to look at how to parse and understand the classes in Python.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Understanding abstract syntax trees with applications</h1>
<p>In this section, we will look into applying the concept of abstract syntax trees to our core example of <em class="italic">ABC Megamart</em> and explore how <strong class="source-inline">ast</strong> is defined in the classes, such as the <strong class="source-inline">Branch</strong> class and the <strong class="source-inline">VegCounter</strong> class of <em class="italic">ABC Megamart</em>. We will also look at modifying the behavior<a id="_idIndexMarker445"/> of these classes using <strong class="source-inline">ast</strong> at a metaprogramming level instead of modifying the actual source code of the class.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Understanding the ast of a class</h2>
<p>In this section, we will look<a id="_idIndexMarker446"/> at understanding the abstract syntax tree of a class, which will help us in exploring how to <a id="_idIndexMarker447"/>modify the elements of a class through metaprogramming. We can try it as follows:</p>
<ol>
<li>Let’s begin by creating a class with empty definitions and look at its abstract syntax tree:<p class="source-code">branch_code = """</p><p class="source-code">class Branch:</p><p class="source-code">    '''attributes...'''</p><p class="source-code">    '''methods...'''</p><p class="source-code">""" </p></li>
<li>Next, let’s parse<a id="_idIndexMarker448"/> the code:<p class="source-code">branch_tree = ast.parse(branch_code)</p><p class="source-code">branch_tree</p><p class="source-code"><strong class="bold">&lt;ast.Module at 0x216ed8b5850&gt;</strong></p></li>
<li>Let’s further look at the<a id="_idIndexMarker449"/> elements of the node and understand how the class is grammatically defined:<p class="source-code">print(ast.dump(branch_tree, indent=4))</p></li>
</ol>
<p>The structure of the node is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 9.8 – Code snippet output  " height="242" src="image/Figure_9.8_B13426.jpg" width="502"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Code snippet output </p>
<p>In the preceding output, we have <strong class="source-inline">Module</strong> followed by <strong class="source-inline">body</strong>, with <strong class="source-inline">ClassDef</strong> within the <strong class="source-inline">body</strong> element. This <strong class="source-inline">ClassDef</strong> has a <strong class="source-inline">name</strong> element followed by two expressions.</p>
<ol>
<li value="4">Let’s redefine this empty class definition with an attribute and a method along with a decorator and recheck the structure of the node:<p class="source-code">branch_code = """class Branch:</p><p class="source-code">    branch_id = 1001</p><p class="source-code">    @staticmethod</p><p class="source-code">    def get_product(self):</p><p class="source-code">        return 'product'</p><p class="source-code">        """</p></li>
<li>We will now<a id="_idIndexMarker450"/> parse <strong class="source-inline">branch_code</strong> in the following step:<p class="source-code">branch_tree = ast.parse(branch_code)</p><p class="source-code">print(ast.dump(branch_tree, indent=4))</p></li>
</ol>
<p>The structure of the <strong class="source-inline">Branch</strong> class in the form of an abstract syntax tree is as follows. We can see that the node starts with the <strong class="source-inline">Module</strong> element followed by <strong class="source-inline">body</strong>.</p>
<p>Within <strong class="source-inline">body</strong>, we<a id="_idIndexMarker451"/> have a <strong class="source-inline">ClassDef</strong> element that contains the class name followed by its attributes, which include <strong class="source-inline">branch_id</strong> stored as a constant value followed by the <strong class="source-inline">get_product</strong> method with its arguments. Refer to the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 9.9 – Code snippet output" height="418" src="image/Figure_9.9_B13426.jpg" width="536"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Code snippet output </p>
<ol>
<li value="6">We also<a id="_idIndexMarker452"/> have a <strong class="source-inline">decorator</strong> method loaded under <strong class="source-inline">decorator_list</strong> as<a id="_idIndexMarker453"/> follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 9.10 – Code snippet output " height="78" src="image/Figure_9.10_B13426.jpg" width="508"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Code snippet output</p>
<ol>
<li value="7">If we create an object for the class, the code for the object can also be parsed similarly to the preceding class example:<p class="source-code">branch_code = """</p><p class="source-code">branch_albany = Branch()</p><p class="source-code">"""</p><p class="source-code">branch_tree = ast.parse(branch_code)</p><p class="source-code">print(ast.dump(branch_tree, indent=4))</p></li>
<li>The node of the object<a id="_idIndexMarker454"/> will have the following structure:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 9.11 Code snippet output " height="190" src="image/Figure_9.11_B13426.jpg" width="466"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 Code snippet output</p>
<p>In this section, we<a id="_idIndexMarker455"/> reviewed the abstract syntax tree of a class to understand the various elements of its syntax. With this understanding, let’s look further into modifying the abstract syntax tree of a class from our core example, <em class="italic">ABC Megamart</em>.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor132"/>Modifying the ast of a code block by parsing</h2>
<p>In this section, let’s look at how<a id="_idIndexMarker456"/> to modify the attributes in the <a id="_idIndexMarker457"/>code of a class by using its abstract syntax tree instead of modifying the actual class itself. </p>
<p>Let’s consider having developed a robust library with multiple classes and methods. A robust library definition may be too big to be disturbed or modified. Instead of modifying the source code, we can make changes to some specific attributes in the library without impacting the actual code, through metaprogramming. In such a scenario, modifying <strong class="source-inline">ast</strong> of the library would be a better way of making changes rather than impacting the source code of the library. </p>
<p>In this example, we will be following these steps:</p>
<ol>
<li value="9">We will be creating a <strong class="source-inline">vegCounter</strong> class and adding a <strong class="source-inline">return_cart</strong> method to return the items <a id="_idIndexMarker458"/>within the cart. We will also be creating an object for the class and <a id="_idIndexMarker459"/>calling the <strong class="source-inline">return_cart</strong> method on the object. Refer to the following code:<p class="source-code">vegctr = """</p><p class="source-code">class VegCounter():</p><p class="source-code">    def return_cart(self,*items):</p><p class="source-code">        cart_items = list(items)</p><p class="source-code">        return cart_items</p><p class="source-code">veg = VegCounter()</p><p class="source-code">print(veg.return_cart('onions','tomatoes','carrots','lettuce'))</p><p class="source-code">"""</p></li>
<li>Next, let’s parse the code for <strong class="source-inline">vegCounter</strong> and look at the structure of the node:<p class="source-code">vegctr_tree = ast.parse(vegctr)</p><p class="source-code">print(ast.dump(vegctr_tree, indent=4))</p></li>
</ol>
<p>The output of the node is as follows. There is a class definition followed by a function definition in <strong class="source-inline">ast</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 9.12 – Code snippet output" height="308" src="image/Figure_9.12_B13426.jpg" width="313"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Code snippet output</p>
<ol>
<li value="11">The following<a id="_idIndexMarker460"/> output has the elements for the list item and<a id="_idIndexMarker461"/> the logic that reads items to the list:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 9.13 – Code snippet output " height="414" src="image/Figure_9.13_B13426.jpg" width="482"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Code snippet output</p>
<ol>
<li value="12">The following output has the syntax for creating the object for the <strong class="source-inline">VegCounter</strong> class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer104">
<img alt="Figure 9.14 – Code snippet output " height="130" src="image/Figure_9.14_B13426.jpg" width="379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Code snippet output</p>
<ol>
<li value="13">The following output displays the<a id="_idIndexMarker462"/> elements that print<a id="_idIndexMarker463"/> the cart items by calling the <strong class="source-inline">return_cart</strong> method on a list of cart items:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer105">
<img alt="Figure 9.15 – Code snippet output " height="306" src="image/Figure_9.15_B13426.jpg" width="391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Code snippet output</p>
<ol>
<li value="14">Let’s now compile the abstract syntax tree and execute it to display the list of items added to the cart:<p class="source-code">vegctr_code = compile(vegctr_tree, 'vegctr_tree', 'exec')</p><p class="source-code">exec(vegctr_code)</p><p class="source-code"><strong class="bold">['onions', 'tomatoes', 'carrots', 'lettuce']</strong></p></li>
<li>Next, let’s navigate through<a id="_idIndexMarker464"/> the values in the cart items and look at the path of the second value in the <strong class="source-inline">return_cart</strong> method output:<p class="source-code">vegctr_tree.body[2].value.args[0].args[1].n</p><p class="source-code"><strong class="bold">'tomatoes'</strong></p></li>
<li>Let’s now change the second value of the cart item from <strong class="source-inline">tomatoes</strong> to <strong class="source-inline">potatoes</strong> by parsing<a id="_idIndexMarker465"/> through the node elements hierarchically:<p class="source-code">vegctr_tree.body[2].value.args[0].args[1].n = 'potatoes'</p><p class="source-code">print(ast.dump(vegctr_tree, indent=4))</p></li>
<li>In the following output, let’s look at the updated value for the second item in the cart, which is modified without changing the source code:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer106">
<img alt="Figure 9.16 – Modifying value within ast " height="587" src="image/Figure_9.16_B13426.jpg" width="909"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Modifying value within ast</p>
<ol>
<li value="18">We can now <a id="_idIndexMarker466"/>unparse the node using the <strong class="source-inline">unparse</strong> method in the <strong class="source-inline">ast</strong> library as follows:<p class="source-code">print(ast.unparse(vegctr_tree))</p></li>
<li>The modified source code now looks as follows:<p class="source-code">class VegCounter:</p><p class="source-code">    def return_cart(self, *items):</p><p class="source-code">        cart_items = list(items)</p><p class="source-code">        return cart_items</p><p class="source-code">veg = VegCounter()</p><p class="source-code">print(veg.return_cart('onions', 'potatoes', 'carrots', 'lettuce'))</p></li>
</ol>
<p>This is one approach to<a id="_idIndexMarker467"/> modifying the Python source code using an abstract syntax tree.</p>
<p>With this understanding, let’s proceed with the next approach, where we will be transforming the nodes of the abstract syntax tree.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor133"/>Modifying the ast of a code block by transforming nodes</h2>
<p>In this section, we will look<a id="_idIndexMarker468"/> at another approach to modifying the source code of a class by modifying the abstract syntax tree instead of <a id="_idIndexMarker469"/>changing the actual code: </p>
<ol>
<li value="1">Let’s now create the <strong class="source-inline">VegCounter</strong> class as follows:<p class="source-code">class VegCounter():</p><p class="source-code">    def return_cart(self,*items):</p><p class="source-code">        cart_items = []</p><p class="source-code">        for i in items:</p><p class="source-code">            cart_items.append(i)</p><p class="source-code">        return cart_items</p><p class="source-code">veg = VegCounter()</p></li>
<li>Next, let’s create a variable named <strong class="source-inline">cart</strong> and add the function call on the object as a string:<p class="source-code">cart = """veg.return_cart('onions','tomatoes','carrots','lettuce')"""</p><p class="source-code">cart_tree = ast.parse(cart)</p><p class="source-code">print(ast.dump(cart_tree, indent = 4))</p></li>
<li>Parsing the<a id="_idIndexMarker470"/> preceding code provides the following output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer107">
<img alt="Figure 9.17 – AST of the object variable " height="290" src="image/Figure_9.17_B13426.jpg" width="464"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – AST of the object variable</p>
<p>In this section, instead of traversing<a id="_idIndexMarker471"/> through the structure of the node, we will be using <strong class="source-inline">NodeTransformer</strong> from the <strong class="source-inline">ast</strong> library to perform code transformation:</p>
<p class="source-code">from ast import NodeTransformer</p>
<ol>
<li value="4">The attributes of <strong class="source-inline">NodeTransformer</strong> are as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer108">
<img alt="Figure 9.18 – Attributes of NodeTransformer " height="120" src="image/Figure_9.18_B13426.jpg" width="271"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Attributes of NodeTransformer</p>
<ol>
<li value="5">Next, let’s create a class named <strong class="source-inline">ModifyVegCounter</strong> inherited from the <strong class="source-inline">NodeTransfomer</strong> class. We will be redefining the <strong class="source-inline">visit_Constant</strong> method to modify the constant <a id="_idIndexMarker472"/>values of the cart items by adding a string prefix whenever the constant value occurs in the code:<p class="source-code">class ModifyVegCounter(NodeTransformer):</p><p class="source-code">    def visit_Constant(self, node):</p><p class="source-code">        modifiedValue = ast.Constant('item:' + str(node.value))</p><p class="source-code">        return modifiedValue</p></li>
<li>We can make use of the <strong class="source-inline">visit</strong> method to visit the node and use the <strong class="source-inline">dump</strong> method to print <a id="_idIndexMarker473"/>the tree:<p class="source-code">ModifyVegCounter().visit(cart_tree)</p><p class="source-code">print(ast.dump(cart_tree, indent = 4))</p></li>
</ol>
<p>The transformed node looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 9.19 – Source code transformed with NodeTransformer " height="620" src="image/Figure_9.19_B13426.jpg" width="869"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Source code transformed with NodeTransformer</p>
<ol>
<li value="7">We can further unparse the<a id="_idIndexMarker474"/> code using the <strong class="source-inline">ast</strong> library’s <strong class="source-inline">unparse</strong> method:<p class="source-code">print(ast.unparse(cart_tree))</p></li>
</ol>
<p>The output of the code is represented as follows:</p>
<p class="source-code"><strong class="bold">veg.return_cart('item:onions', 'item:tomatoes', 'item:carrots', 'item:lettuce')</strong></p>
<p>This is another example of how an abstract syntax tree can be used in metaprogramming.</p>
<p>In this section, we covered the<a id="_idIndexMarker475"/> approach of transforming the nodes of an abstract syntax tree using the <strong class="source-inline">NodeTransformer</strong> method of the <strong class="source-inline">ast</strong> library.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Summary</h1>
<p>In this chapter, we have learned about the concept of the abstract syntax tree by exploring the <strong class="source-inline">ast</strong> library in Python 3. We also inspected Python code using abstract syntax trees. We understood the applications of abstract syntax trees by modifying the code at the node level using source code from our core example.</p>
<p>Similar to other chapters in this book, this chapter covered the concept of abstract syntax trees in metaprogramming. This also helps in understanding how to modify the behavior of Python objects externally without modifying the source code. Modifying the abstract syntax tree instead of the actual methods and attributes in the code helps migrate source code from different versions of Python or the application development platform conveniently without impacting the actual logic of the code.</p>
<p>In the next chapter, we will be looking at the concept of <strong class="bold">method resolution order</strong> with some other interesting examples.</p>
</div>
<div>
<div id="_idContainer111">
</div>
</div>
</div></body></html>