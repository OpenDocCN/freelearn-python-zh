<html><head></head><body>
<div><div><h1 id="_idParaDest-122"><em class="italic"><a id="_idTextAnchor124"/>Chapter 9</em>: Understanding Code through Abstract Syntax Tree</h1>
<p>In this chapter, we will look at what abstract syntax trees are and how to understand the syntax tree of each unit of the Python code we write.</p>
<p>Any programming language is designed with its own syntax, which is used by developers while coding in the language following specific syntax. The interpreter or compiler of a programming language interprets the syntax of the language and compiles or interprets the code and executes it to achieve the desired result.</p>
<p>In Python, an <code>ast</code> that can be used to understand the abstract syntax of the code that we develop. </p>
<p>Throughout this chapter, we will look at understanding the syntax tree of some of the important code snippets that we developed in previous chapters, and we will also look at modifying or adding more information to the code through a few examples. We will be making use of abstract syntax trees throughout this chapter to perform an analysis of the code.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Exploring the <code>ast</code> library</li>
<li>Inspecting Python code with abstract syntax trees</li>
<li>Understanding abstract syntax trees with applications</li>
</ul>
<p>By the end of this chapter, you should be able to understand the abstract syntax tree of Python code. You should also be able to inspect, parse, and modify the abstract syntax tree of source code through metaprogramming.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9</a>.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor126"/>Exploring the ast library</h1>
<p>In this section, we will explore the <code>ast</code> Python library, which can be imported from Python 3 to analyze the Python code written by developers. We can also use it to modify the code through its abstract syntax tree at a <a id="_idIndexMarker434"/>metaprogramming level rather than modifying the syntax of the code itself. This helps in understanding how the code is syntactically represented and how the syntax tree of the code can be used to modify its behavior without modifying the original source code. We will look at some of the important functions of the <code>ast</code> library, as those functions will be used throughout this chapter to understand the code from our core example.</p>
<p>Let’s start by importing the <code>ast</code> library:</p>
<pre class="source-code">import ast</pre>
<p>Once we import the library, we can look at analyzing a piece of code using this library. We will now create a variable named <code>assignment</code> and assign a string format of the code to it:</p>
<pre class="source-code">assignment = "product_name = 'Iphone X'"</pre>
<p>The output of the <code>assignment</code> variable appears as follows:</p>
<pre class="source-code">assignment
<strong class="bold">"product_name = 'Iphone X'"</strong></pre>
<p>The preceding code can be parsed into its corresponding nodes using the <code>parse</code> method of the <code>ast</code> library. We will now create a variable named <code>assign_tree</code> and store the parsed node of the lines of code stored under <code>assignment</code>:</p>
<pre class="source-code">assign_tree = ast.parse(assignment)</pre>
<pre class="source-code">assign_tree</pre>
<p>The output of the parsed node looks as follows:</p>
<pre class="source-code">&lt;ast.Module at 0x1b92b3f6520&gt;</pre>
<p>Now, we can make use of another method called <code>dump</code> to print the tree structure of the node with each of its values and fields. This helps in debugging the code:</p>
<pre class="source-code">print(ast.dump(assign_tree,indent = 4))</pre>
<p>The output of the code<a id="_idIndexMarker435"/> is as follows:</p>
<div><div><img alt="Figure 9.1 – Example of an abstract syntax tree " height="127" src="img/Figure_9.1_B13426.jpg" width="451"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Example of an abstract syntax tree</p>
<p>The <code>"product_name = 'Iphone X'"</code> code is broken down into multiple parts. The syntax of any code in Python is grammatically embedded into <code>Module</code> followed by <code>body</code>. We have assigned the <code>Iphone X</code> value to the <code>product_name</code> variable and so the code that performs a value assignment is identified by the <code>Assign</code> branch, which has attributes mapped with the corresponding ID, context, and value. This is an example of what a simple representation of a node would look like. For multiple lines of code with various other operations, the node will have multiple other branches in the tree.</p>
<p>Let’s start inspecting the Python code for a few examples of using abstract syntax trees in the following section.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/>Inspecting Python code with abstract syntax trees</h1>
<p>In this section, we will review<a id="_idIndexMarker436"/> and understand the code for a<a id="_idIndexMarker437"/> simple arithmetic addition example, and we will also further look into parsing the code and modifying it using abstract syntax trees.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>Reviewing simple code using ast</h2>
<p>In this section, let’s review simple <a id="_idIndexMarker438"/>code that adds two numbers, and let’s look at all the elements of the node, and also how the elements are organized in the tree. Let’s begin by writing code to assign two variables, <code>a</code> and <code>b</code>, with numerical values, and <code>c</code> as the sum of <code>a</code> and <code>b</code>. Finally, let’s print the <code>c</code> value. This is shown in the following code:</p>
<pre class="source-code">addfunc = """</pre>
<pre class="source-code">a = 1098</pre>
<pre class="source-code">b = 2032</pre>
<pre class="source-code">c = a + b</pre>
<pre class="source-code">print(c)</pre>
<pre class="source-code">"""</pre>
<p>We will now parse the preceding <code>addfunc</code> and store the node in another variable called <code>add_tree</code>:</p>
<pre class="source-code">add_tree = ast.parse(addfunc)</pre>
<pre class="source-code">add_tree</pre>
<p>The output of the parsed node is as follows:</p>
<pre>&lt;ast.Module at 0x19c9b2bf2e0&gt;</pre>
<p>The base element of the node is <code>Module</code>, and all the other lines of code are split into semantics that are stored within the module of the node. </p>
<p>Let’s look at the detailed tree representation in the following code by calling the <code>dump</code> method on the tree:</p>
<pre class="source-code">print(ast.dump(add_tree, indent=4))</pre>
<p>The tree begins with <code>Module</code> as its base element, or the trunk followed by multiple branches. <code>Module</code> is followed by <code>body</code> as a list item that lists down all other elements of the code.</p>
<p>Within <code>body</code>, there will be four list items that describe the operations of <code>addfunc</code>. The first one, which is also the first line of <code>addfunc</code>, is to assign the <code>Constant</code> value <code>1098</code> to a variable with a name whose id is <code>a</code> and the context of the value is <code>Store</code> since we are storing the value in the variable. Here is how it appears:</p>
<div><div><img alt="Figure 9.2 – Code snippet output " height="108" src="img/Figure_9.2_B13426.jpg" width="366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Code snippet output</p>
<p>Similarly, the second<a id="_idIndexMarker439"/> line of <code>addfunc</code> is to store the <code>2032</code> value in the <code>b</code> variable, which is represented grammatically in the following list item:</p>
<div><div><img alt="Figure 9.3 – Code snippet output " height="74" src="img/Figure_9.3_B13426.jpg" width="302"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Code snippet output</p>
<p>The third line of code in <code>addfunc</code> has the arithmetic operation of adding the two values stored in <code>a</code> and <code>b</code>:</p>
<div><div><img alt="Figure 9.4 – Code snippet output " height="126" src="img/Figure_9.4_B13426.jpg" width="350"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Code snippet output</p>
<p>The preceding code has an additional element, <code>BinOp</code>, followed by <code>left</code>, <code>op</code>, and <code>right</code> variables to indicate the left numerical value, addition operation, and right numerical value, respectively.</p>
<p>The last line of the code in <code>addfunc</code> is the <code>Expr</code> expression element, which represents the printing of the <code>c</code> variable with a context value of <code>Load</code>:</p>
<div><div><img alt="Figure 9.5 – Code snippet output " height="127" src="img/Figure_9.5_B13426.jpg" width="392"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Code snippet output</p>
<p>To execute <code>addfunc</code>, we need to first compile the parsed tree as follows:</p>
<pre class="source-code">add_code = compile(add_tree, 'add_tree', 'exec')</pre>
<p>Post-compilation, we <a id="_idIndexMarker440"/>should be able to execute the compiled tree, which results in the addition of <code>a</code> and <code>b</code>:</p>
<pre class="source-code">exec(add_code)</pre>
<p>The following is the output of the code:</p>
<pre>3130</pre>
<p>In this section, we reviewed the abstract syntax tree of the simple arithmetic <code>add</code> function. In the following section, let’s look at modifying the code of the <code>add</code> function using metaprogramming.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>Modifying simple code using ast</h2>
<p>In this section, let’s consider the <a id="_idIndexMarker441"/>example of <code>addfunc</code> from the preceding section and look at how to modify the code in the example through metaprogramming, without modifying the actual code. The operation performed by the code in <code>addfunc</code> is arithmetic addition. What if we want to perform arithmetic multiplication instead of addition and we don’t want the actual code to be modified? What if there are multiple locations where we want arithmetic addition to be replaced by arithmetic multiplication, and browsing through thousands of lines of code and modifying them is not a feasible option as it might impact or break something else in the code? In such scenarios, we <a id="_idIndexMarker442"/>can modify the node of the code using its syntax tree instead of modifying the actual code itself. To achieve this, let’s make use of the abstract syntax tree of the code. </p>
<p>Let’s reuse the <code>add_tree</code> parsed tree variable from the code in the preceding section:</p>
<pre class="source-code">add_tree</pre>
<pre class="source-code"><strong class="bold">&lt;ast.Module at 0x19c9b2bf2e0&gt;</strong></pre>
<p>To understand which fields to modify, let’s look at the following representation of the node and look at each section of the node marked by an identifier. The elements of interest for this example are represented inside a box in the following figure:</p>
<div><div><img alt="Figure 9.6 – Parsed node of addfunc " height="706" src="img/Figure_9.6_B13426.jpg" width="1041"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Parsed node of addfunc</p>
<p>To modify the add operation into a multiplication operation, the tree for this node traverses through <code>body</code> followed by its list item <code>2</code>, followed by the <code>value</code> field of the item, followed by the <code>op</code> field. The <code>Add()</code> operation of the <code>op</code> field will have to be modified into a multiplication<a id="_idIndexMarker443"/> operation to achieve our goal for this section. Here’s how:</p>
<pre class="source-code">add_tree.body[2].value.op=ast.Mult()</pre>
<p>Executing the preceding code results in a change of the tree:</p>
<pre class="source-code">print(ast.dump(add_tree, indent=4))</pre>
<p>The figure of the updated tree structure is represented as follows, with the <code>Add()</code> operation replaced by the <code>Mult()</code> operation:</p>
<div><div><img alt="Figure 9.7 – Tree modified to perform multiplication " height="713" src="img/Figure_9.7_B13426.jpg" width="1098"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Tree modified to perform multiplication</p>
<p>To verify whether the preceding modification on the tree node works, let’s compile the tree and execute it to check the results:</p>
<pre class="source-code">add_code = compile(add_tree, 'add_tree', 'exec')</pre>
<pre class="source-code">exec(add_code)</pre>
<p>Executing the preceding code should have ideally provided an output of <code>3130</code>, which is the addition of two numbers, <code>1098</code> and <code>2032</code>. But we have modified <code>ast</code> to perform multiplication instead and so it would result in the value, which is a product of the two numbers:</p>
<pre class="source-code"><strong class="bold">2231136</strong></pre>
<p>Thus the tree is now<a id="_idIndexMarker444"/> modified and can be compiled to achieve the desired result without modifying the actual code.</p>
<p>With this understanding, let’s proceed further to look at how to parse and understand the classes in Python.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Understanding abstract syntax trees with applications</h1>
<p>In this section, we will look into applying the concept of abstract syntax trees to our core example of <em class="italic">ABC Megamart</em> and explore how <code>ast</code> is defined in the classes, such as the <code>Branch</code> class and the <code>VegCounter</code> class of <em class="italic">ABC Megamart</em>. We will also look at modifying the behavior<a id="_idIndexMarker445"/> of these classes using <code>ast</code> at a metaprogramming level instead of modifying the actual source code of the class.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Understanding the ast of a class</h2>
<p>In this section, we will look<a id="_idIndexMarker446"/> at understanding the abstract syntax tree of a class, which will help us in exploring how to <a id="_idIndexMarker447"/>modify the elements of a class through metaprogramming. We can try it as follows:</p>
<ol>
<li>Let’s begin by creating a class with empty definitions and look at its abstract syntax tree:<pre>branch_code = """
class Branch:
    '''attributes...'''
    '''methods...'''
""" </pre></li>
<li>Next, let’s parse<a id="_idIndexMarker448"/> the code:<pre>branch_tree = ast.parse(branch_code)
branch_tree
<strong class="bold">&lt;ast.Module at 0x216ed8b5850&gt;</strong></pre></li>
<li>Let’s further look at the<a id="_idIndexMarker449"/> elements of the node and understand how the class is grammatically defined:<pre>print(ast.dump(branch_tree, indent=4))</pre></li>
</ol>
<p>The structure of the node is as follows:</p>
<div><div><img alt="Figure 9.8 – Code snippet output  " height="242" src="img/Figure_9.8_B13426.jpg" width="502"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Code snippet output </p>
<p>In the preceding output, we have <code>Module</code> followed by <code>body</code>, with <code>ClassDef</code> within the <code>body</code> element. This <code>ClassDef</code> has a <code>name</code> element followed by two expressions.</p>
<ol>
<li value="4">Let’s redefine this empty class definition with an attribute and a method along with a decorator and recheck the structure of the node:<pre>branch_code = """class Branch:
    branch_id = 1001
    @staticmethod
    def get_product(self):
        return 'product'
        """</pre></li>
<li>We will now<a id="_idIndexMarker450"/> parse <code>branch_code</code> in the following step:<pre>branch_tree = ast.parse(branch_code)
print(ast.dump(branch_tree, indent=4))</pre></li>
</ol>
<p>The structure of the <code>Branch</code> class in the form of an abstract syntax tree is as follows. We can see that the node starts with the <code>Module</code> element followed by <code>body</code>.</p>
<p>Within <code>body</code>, we<a id="_idIndexMarker451"/> have a <code>ClassDef</code> element that contains the class name followed by its attributes, which include <code>branch_id</code> stored as a constant value followed by the <code>get_product</code> method with its arguments. Refer to the following output:</p>
<div><div><img alt="Figure 9.9 – Code snippet output" height="418" src="img/Figure_9.9_B13426.jpg" width="536"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Code snippet output </p>
<ol>
<li value="6">We also<a id="_idIndexMarker452"/> have a <code>decorator</code> method loaded under <code>decorator_list</code> as<a id="_idIndexMarker453"/> follows:</li>
</ol>
<div><div><img alt="Figure 9.10 – Code snippet output " height="78" src="img/Figure_9.10_B13426.jpg" width="508"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Code snippet output</p>
<ol>
<li value="7">If we create an object for the class, the code for the object can also be parsed similarly to the preceding class example:<pre>branch_code = """
branch_albany = Branch()
"""
branch_tree = ast.parse(branch_code)
print(ast.dump(branch_tree, indent=4))</pre></li>
<li>The node of the object<a id="_idIndexMarker454"/> will have the following structure:</li>
</ol>
<div><div><img alt="Figure 9.11 Code snippet output " height="190" src="img/Figure_9.11_B13426.jpg" width="466"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 Code snippet output</p>
<p>In this section, we<a id="_idIndexMarker455"/> reviewed the abstract syntax tree of a class to understand the various elements of its syntax. With this understanding, let’s look further into modifying the abstract syntax tree of a class from our core example, <em class="italic">ABC Megamart</em>.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor132"/>Modifying the ast of a code block by parsing</h2>
<p>In this section, let’s look at how<a id="_idIndexMarker456"/> to modify the attributes in the <a id="_idIndexMarker457"/>code of a class by using its abstract syntax tree instead of modifying the actual class itself. </p>
<p>Let’s consider having developed a robust library with multiple classes and methods. A robust library definition may be too big to be disturbed or modified. Instead of modifying the source code, we can make changes to some specific attributes in the library without impacting the actual code, through metaprogramming. In such a scenario, modifying <code>ast</code> of the library would be a better way of making changes rather than impacting the source code of the library. </p>
<p>In this example, we will be following these steps:</p>
<ol>
<li value="9">We will be creating a <code>vegCounter</code> class and adding a <code>return_cart</code> method to return the items <a id="_idIndexMarker458"/>within the cart. We will also be creating an object for the class and <a id="_idIndexMarker459"/>calling the <code>return_cart</code> method on the object. Refer to the following code:<pre>vegctr = """
class VegCounter():
    def return_cart(self,*items):
        cart_items = list(items)
        return cart_items
veg = VegCounter()
print(veg.return_cart('onions','tomatoes','carrots','lettuce'))
"""</pre></li>
<li>Next, let’s parse the code for <code>vegCounter</code> and look at the structure of the node:<pre>vegctr_tree = ast.parse(vegctr)
print(ast.dump(vegctr_tree, indent=4))</pre></li>
</ol>
<p>The output of the node is as follows. There is a class definition followed by a function definition in <code>ast</code>:</p>
<div><div><img alt="Figure 9.12 – Code snippet output" height="308" src="img/Figure_9.12_B13426.jpg" width="313"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Code snippet output</p>
<ol>
<li value="11">The following<a id="_idIndexMarker460"/> output has the elements for the list item and<a id="_idIndexMarker461"/> the logic that reads items to the list:</li>
</ol>
<div><div><img alt="Figure 9.13 – Code snippet output " height="414" src="img/Figure_9.13_B13426.jpg" width="482"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Code snippet output</p>
<ol>
<li value="12">The following output has the syntax for creating the object for the <code>VegCounter</code> class:</li>
</ol>
<div><div><img alt="Figure 9.14 – Code snippet output " height="130" src="img/Figure_9.14_B13426.jpg" width="379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Code snippet output</p>
<ol>
<li value="13">The following output displays the<a id="_idIndexMarker462"/> elements that print<a id="_idIndexMarker463"/> the cart items by calling the <code>return_cart</code> method on a list of cart items:</li>
</ol>
<div><div><img alt="Figure 9.15 – Code snippet output " height="306" src="img/Figure_9.15_B13426.jpg" width="391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Code snippet output</p>
<ol>
<li value="14">Let’s now compile the abstract syntax tree and execute it to display the list of items added to the cart:<pre>vegctr_code = compile(vegctr_tree, 'vegctr_tree', 'exec')
exec(vegctr_code)
<strong class="bold">['onions', 'tomatoes', 'carrots', 'lettuce']</strong></pre></li>
<li>Next, let’s navigate through<a id="_idIndexMarker464"/> the values in the cart items and look at the path of the second value in the <code>return_cart</code> method output:<pre>vegctr_tree.body[2].value.args[0].args[1].n
<strong class="bold">'tomatoes'</strong></pre></li>
<li>Let’s now change the second value of the cart item from <code>tomatoes</code> to <code>potatoes</code> by parsing<a id="_idIndexMarker465"/> through the node elements hierarchically:<pre>vegctr_tree.body[2].value.args[0].args[1].n = 'potatoes'
print(ast.dump(vegctr_tree, indent=4))</pre></li>
<li>In the following output, let’s look at the updated value for the second item in the cart, which is modified without changing the source code:</li>
</ol>
<div><div><img alt="Figure 9.16 – Modifying value within ast " height="587" src="img/Figure_9.16_B13426.jpg" width="909"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Modifying value within ast</p>
<ol>
<li value="18">We can now <a id="_idIndexMarker466"/>unparse the node using the <code>unparse</code> method in the <code>ast</code> library as follows:<pre>print(ast.unparse(vegctr_tree))</pre></li>
<li>The modified source code now looks as follows:<pre>class VegCounter:
    def return_cart(self, *items):
        cart_items = list(items)
        return cart_items
veg = VegCounter()
print(veg.return_cart('onions', 'potatoes', 'carrots', 'lettuce'))</pre></li>
</ol>
<p>This is one approach to<a id="_idIndexMarker467"/> modifying the Python source code using an abstract syntax tree.</p>
<p>With this understanding, let’s proceed with the next approach, where we will be transforming the nodes of the abstract syntax tree.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor133"/>Modifying the ast of a code block by transforming nodes</h2>
<p>In this section, we will look<a id="_idIndexMarker468"/> at another approach to modifying the source code of a class by modifying the abstract syntax tree instead of <a id="_idIndexMarker469"/>changing the actual code: </p>
<ol>
<li value="1">Let’s now create the <code>VegCounter</code> class as follows:<pre>class VegCounter():
    def return_cart(self,*items):
        cart_items = []
        for i in items:
            cart_items.append(i)
        return cart_items
veg = VegCounter()</pre></li>
<li>Next, let’s create a variable named <code>cart</code> and add the function call on the object as a string:<pre>cart = """veg.return_cart('onions','tomatoes','carrots','lettuce')"""
cart_tree = ast.parse(cart)
print(ast.dump(cart_tree, indent = 4))</pre></li>
<li>Parsing the<a id="_idIndexMarker470"/> preceding code provides the following output:</li>
</ol>
<div><div><img alt="Figure 9.17 – AST of the object variable " height="290" src="img/Figure_9.17_B13426.jpg" width="464"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – AST of the object variable</p>
<p>In this section, instead of traversing<a id="_idIndexMarker471"/> through the structure of the node, we will be using <code>NodeTransformer</code> from the <code>ast</code> library to perform code transformation:</p>
<pre>from ast import NodeTransformer</pre>
<ol>
<li value="4">The attributes of <code>NodeTransformer</code> are as follows:</li>
</ol>
<div><div><img alt="Figure 9.18 – Attributes of NodeTransformer " height="120" src="img/Figure_9.18_B13426.jpg" width="271"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Attributes of NodeTransformer</p>
<ol>
<li value="5">Next, let’s create a class named <code>ModifyVegCounter</code> inherited from the <code>NodeTransfomer</code> class. We will be redefining the <code>visit_Constant</code> method to modify the constant <a id="_idIndexMarker472"/>values of the cart items by adding a string prefix whenever the constant value occurs in the code:<pre>class ModifyVegCounter(NodeTransformer):
    def visit_Constant(self, node):
        modifiedValue = ast.Constant('item:' + str(node.value))
        return modifiedValue</pre></li>
<li>We can make use of the <code>visit</code> method to visit the node and use the <code>dump</code> method to print <a id="_idIndexMarker473"/>the tree:<pre>ModifyVegCounter().visit(cart_tree)
print(ast.dump(cart_tree, indent = 4))</pre></li>
</ol>
<p>The transformed node looks as follows:</p>
<div><div><img alt="Figure 9.19 – Source code transformed with NodeTransformer " height="620" src="img/Figure_9.19_B13426.jpg" width="869"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Source code transformed with NodeTransformer</p>
<ol>
<li value="7">We can further unparse the<a id="_idIndexMarker474"/> code using the <code>ast</code> library’s <code>unparse</code> method:<pre>print(ast.unparse(cart_tree))</pre></li>
</ol>
<p>The output of the code is represented as follows:</p>
<pre><strong class="bold">veg.return_cart('item:onions', 'item:tomatoes', 'item:carrots', 'item:lettuce')</strong></pre>
<p>This is another example of how an abstract syntax tree can be used in metaprogramming.</p>
<p>In this section, we covered the<a id="_idIndexMarker475"/> approach of transforming the nodes of an abstract syntax tree using the <code>NodeTransformer</code> method of the <code>ast</code> library.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor134"/>Summary</h1>
<p>In this chapter, we have learned about the concept of the abstract syntax tree by exploring the <code>ast</code> library in Python 3. We also inspected Python code using abstract syntax trees. We understood the applications of abstract syntax trees by modifying the code at the node level using source code from our core example.</p>
<p>Similar to other chapters in this book, this chapter covered the concept of abstract syntax trees in metaprogramming. This also helps in understanding how to modify the behavior of Python objects externally without modifying the source code. Modifying the abstract syntax tree instead of the actual methods and attributes in the code helps migrate source code from different versions of Python or the application development platform conveniently without impacting the actual logic of the code.</p>
<p>In the next chapter, we will be looking at the concept of <strong class="bold">method resolution order</strong> with some other interesting examples.</p>
</div>
<div><div></div>
</div>
</div></body></html>