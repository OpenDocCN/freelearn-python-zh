<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Connecting to the Cloud</h1></div></div></div><p class="calibre8">Cloud modules <a id="id241" class="calibre1"/>may seem like the most daunting type of Salt module, because of how many functions are required to present a cohesive tool for a cloud provider. Fortunately, connecting to most cloud providers is easy, once you know how. In this chapter, we'll discuss:</p><div><ul class="itemizedlist"><li class="listitem">Understanding how cloud components fit together</li><li class="listitem">Learning which functions are required, and how they are used</li><li class="listitem">Comparing Libcloud-based modules with direct REST modules</li><li class="listitem">Writing a generic cloud module</li><li class="listitem">Troubleshooting cloud modules</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec49" class="calibre1"/>Understanding cloud components</h1></div></div></div><p class="calibre8">The word <em class="calibre9">cloud</em> has suffered from an unfortunate bout of overuse and misuse in recent years, so <a id="id242" class="calibre1"/>before we talk about what the components look like, we need to define what we're actually talking about in the first place.</p><p class="calibre8">Salt Cloud is<a id="id243" class="calibre1"/> designed to operate with <em class="calibre9">compute cloud</em> providers. This means that they offer computing resources, often in the form of virtual machines. A number of cloud providers also offer other resources, such as storage space, DNS, and load balancing. While Salt Cloud isn't explicitly designed to manage these resources, it is possible to add support for them.</p><p class="calibre8">For our purposes, we will discuss creating cloud drivers with a focus on managing virtual machines. Some of the techniques can be used for adding other resources, so if you're planning on going in that direction, this chapter will still be useful to you.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec75" class="calibre1"/>Looking at the puzzle pieces</h2></div></div></div><p class="calibre8">The <a id="id244" class="calibre1"/>primary<a id="id245" class="calibre1"/> goal of Salt Cloud is to easily create virtual machines on a cloud provider, install a Salt Minion onto that machine, and then automatically accept that Minion's keys on the Master. When you dig down, you <a id="id246" class="calibre1"/>will<a id="id247" class="calibre1"/> find that a number of pieces fit together to achieve this goal.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec10" class="calibre1"/>Connection mechanism</h3></div></div></div><p class="calibre8">Most <a id="id248" class="calibre1"/>cloud providers offer an API to manage the resources in your account. This API comprises an authentication scheme, and a collection of URLs that are used in similar ways. Almost every cloud provider supports URLs based on both <code class="email">GET</code> and <code class="email">POST</code> methods, but some support other methods such as <code class="email">PATCH</code> and <code class="email">DELETE</code>.</p><p class="calibre8">Quite <a id="id249" class="calibre1"/>frequently, these URLs will include up to four components:</p><div><ul class="itemizedlist"><li class="listitem">A resource name</li><li class="listitem">The action to be performed on that resource</li><li class="listitem">The ID of the resource to be managed</li><li class="listitem">Arguments that define how the resource is managed</li></ul></div><p class="calibre8">These components can be combined with the authentication scheme to create a single tool that is used to perform all of the management features that are available.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec11" class="calibre1"/>Listing resources</h3></div></div></div><p class="calibre8">Most <a id="id250" class="calibre1"/>resources have a way to list them from the API. These include both options that are defined by the cloud provider and resources that belong to your account and can be managed by you. Some of the resources that can usually be listed from the API are:</p><div><ul class="itemizedlist"><li class="listitem">Operating system images</li><li class="listitem">Sizes of virtual machines that can be created</li><li class="listitem">Existing virtual machines in a user's account</li><li class="listitem">Details about specific virtual machines</li><li class="listitem">Non-compute resources that are managed by the account</li></ul></div><p class="calibre8">A Salt Cloud module should provide a few different ways to list resources, both for creating new virtual machines and for managing existing virtual machines.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec12" class="calibre1"/>Creating virtual machines</h3></div></div></div><p class="calibre8">The <a id="id251" class="calibre1"/>most complex component of most cloud modules is the <code class="email">create()</code> function, which orchestrates the tasks of requesting a virtual machine, waiting for it to become available, logging in to it and installing Salt, and accepting that virtual machine's Minion keys on the Master. Many of these tasks have been abstracted into helper functions that can be called from cloud modules, which greatly <a id="id252" class="calibre1"/>simplifies the development of the <code class="email">create()</code> function.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec13" class="calibre1"/>Managing other resources</h3></div></div></div><p class="calibre8">Once<a id="id253" class="calibre1"/> the preceding components have been put together, creating other functions to create, list, modify, and delete other resources will usually not take much effort.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec76" class="calibre1"/>Libcloud versus SDK versus direct REST API</h2></div></div></div><p class="calibre8">There <a id="id254" class="calibre1"/>are three types of cloud modules that ship with Salt. The first and original type of module uses a library <a id="id255" class="calibre1"/>called Libcloud to communicate with cloud providers. Using this<a id="id256" class="calibre1"/> kind of library has some distinct advantages:</p><div><ul class="itemizedlist"><li class="listitem">Libcloud supports a huge amount of cloud providers</li><li class="listitem">Libcloud provides a standard and reasonably consistent interface across providers</li><li class="listitem">Salt Cloud has a number of functions built in specifically for Libcloud</li><li class="listitem">Libcloud is actively developed, with frequent releases</li></ul></div><p class="calibre8">There<a id="id257" class="calibre1"/> are some disadvantages to using Libcloud:</p><div><ul class="itemizedlist"><li class="listitem">Not every feature in every cloud is supported by Libcloud</li><li class="listitem">New cloud providers may not yet be supported</li><li class="listitem">Old, obscure, and proprietary drivers may not ever be supported</li></ul></div><p class="calibre8">Some cloud <a id="id258" class="calibre1"/>providers also provide their own libraries for connecting to their infrastructure. This may prove the fastest, easiest, or most reliable way to connect to them. Some <a id="id259" class="calibre1"/>advantages to using a provider's own SDK are:</p><div><ul class="itemizedlist"><li class="listitem">The developers are likely to have the most complete knowledge of the API</li><li class="listitem">When new features are released, the SDK is often the first library to support them</li></ul></div><p class="calibre8">Some<a id="id260" class="calibre1"/> disadvantages are:</p><div><ul class="itemizedlist"><li class="listitem">Some SDKs still don't support all of the features for that cloud provider</li><li class="listitem">Some SDKs can be difficult to use</li></ul></div><p class="calibre8">Another <a id="id261" class="calibre1"/>option for communicating with a cloud provider is to communicate directly with their REST API. Some advantages to this are:</p><div><ul class="itemizedlist"><li class="listitem">You control how the module is maintained</li><li class="listitem">You <a id="id262" class="calibre1"/>can make your own additions without waiting for new versions of a library</li></ul></div><p class="calibre8">But there<a id="id263" class="calibre1"/> are some definite disadvantages to using a direct REST API:</p><div><ul class="itemizedlist"><li class="listitem">You have to maintain the module</li><li class="listitem">You have to add any new features yourself</li><li class="listitem">You aren't likely to have as many resources to use the driver as the cloud provider has</li></ul></div><p class="calibre8">You<a id="id264" class="calibre1"/> are going to need to decide which of these options is most appropriate for your situation. Fortunately, once you have set up a connection mechanism to use (whether you write it yourself or use somebody else's), there aren't really any differences between the functions that make use of those connections.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec50" class="calibre1"/>Writing a generic cloud module</h1></div></div></div><p class="calibre8">We're <a id="id265" class="calibre1"/>going to set up a very generic module that uses a direct REST API to communicate with a cloud provider. If you spend a lot of time with different APIs, you'll find the style used here to be very common.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec77" class="calibre1"/>Checking for required configuration</h2></div></div></div><p class="calibre8">In order <a id="id266" class="calibre1"/>to use a cloud provider, you will need a <code class="email">__virtual__()</code> function to check for required configuration, and if necessary, any dependencies. You will also need a function called <code class="email">get_configured_provider()</code>, which checks to make sure that the configuration that is required to connect to your cloud provider (usually authentication at the very least, and sometimes other connection parameters) have been specified. We will also need to define <code class="email">__virtualname__</code>, which contains the name of the driver as Salt Cloud will know it. Let's go ahead and start our cloud module with these:</p><div><pre class="programlisting">'''
Generic Salt Cloud module

This module is not designed for any specific cloud provider, but is generic
enough that only minimal changes may be required for some providers.

This file should be saved as salt/cloud/clouds/generic.py

Set up the cloud configuration at ``/etc/salt/cloud.providers`` or
``/etc/salt/cloud.providers.d/generic.conf``:

.. code-block:: yaml

    my-cloud-config:
      driver: generic
      # The login user
      user: larry
      # The user's password
      password: 123pass
      # The user's API key
      api_key: 0123456789abcdef
'''
__virtualname__ = 'generic'


def __virtual__():
    '''
    Check for cloud configs
    '''
    # No special libraries required

    if get_configured_provider() is False:
        return False

    return __virtualname__


def get_configured_provider():
    '''
    Make sure configuration is correct
    '''
    return config.is_provider_configured(
        __opts__,
        __active_provider_name__ or __virtualname__,
        ('user', 'password', 'apikey')
    )</pre></div><p class="calibre8">We've <a id="id267" class="calibre1"/>started out with a <code class="email">docstring</code> that contains information about the required configuration for our driver. We're going to stick with a simple authentication scheme, which uses an API key as part of the URL, and an HTTP username and password.</p><p class="calibre8">The <code class="email">__virtual__()</code> function should first make sure that any required libraries are installed. In our case, we don't need anything special, so we'll skip that part. We then call <code class="email">get_configured_provider()</code> to make sure that any required configurations are in place, and<a id="id268" class="calibre1"/> if all is good, we return <code class="email">__virtualname__</code>.</p><p class="calibre8">The <code class="email">get_configured_provider()</code> function will never change, outside of the list of parameters that are absolutely required in order for the module to work. If you are going to accept any optional parameters, do not include them in this function.</p><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">get_configured_provider()</code> function mentions another built-in variable called <code class="email">__active_provider_name__</code>. This contains a combination of the name that the user sets for this module in their provider config (such as <code class="email">my-cloud-config</code>) and the name of the actual driver itself (in our case, <code class="email">generic</code>), separated by a colon (<code class="email">:</code>). If you were to use the sample configuration in our docstring, then <code class="email">__active_provider_name__</code> would be set to <code class="email">my-cloud-config:generic</code>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec78" class="calibre1"/>Using http.query()</h2></div></div></div><p class="calibre8">Salt comes <a id="id269" class="calibre1"/>with its own library for communicating over HTTP. This library is not a connection library itself; rather, it allows you to use <code class="email">urllib2</code> (which ships with Python), Tornado (which is a dependency of Salt itself), or <code class="email">requests</code> (which is a very popular and powerful HTTP library for Python). Like Libcloud, Salt's HTTP library strives to provide a consistent interface across available libraries. You can specify which library is to be used, if you need to use specific features in that library, but by default Tornado is used.</p><p class="calibre8">This library lives in <code class="email">salt.utils</code> and contains a number of HTTP-related functions. The one that is most commonly used is called <code class="email">query()</code>. It not only supports all three backend libraries but also includes mechanisms to automatically translate return data from either JSON or XML into a Python dictionary.</p><p class="calibre8">A call to <code class="email">http.query()</code> usually looks something like this:</p><div><pre class="programlisting">import salt.utils.http
result = salt.utils.http.query(
    'https://api.example.com/v1/resource/action/id',
    'POST',
    data=post_data_dict,
    decode=True,
    decode_type='json',
    opts=__opts__
)
print(result['dict'])</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec79" class="calibre1"/>A common REST API</h2></div></div></div><p class="calibre8">Before <a id="id270" class="calibre1"/>we connect to a REST API, we need to <a id="id271" class="calibre1"/>know what it looks like. The structure of the URL often contains the following components:</p><div><pre class="programlisting">https://&lt;hostname&gt;/&lt;version&gt;/&lt;resource&gt;[/&lt;action&gt;[/&lt;id&gt;]]</pre></div><p class="calibre8">Technically, the URL scheme can be HTTP, but if that's your only option, I would recommend switching to another cloud provider.</p><p class="calibre8">The hostname usually contains some hint that it belongs to the API, such as <code class="email">api.example.com</code>. The documentation for your cloud provider will tell you which hostname to use here. The hostname may also include information about which data center you are communicating with, such as <code class="email">eu-north.api.example.com</code>.</p><p class="calibre8">Most providers also require you to specify which version of their API you are using. This may be in the URL, or in the <code class="email">POST</code> data, or even in the client request headers. You should always use the latest version unless you have a very good reason not to, but cloud providers will often support old versions as well, if only temporarily.</p><p class="calibre8">The resource refers to what you are actually monitoring. This may be something like <code class="email">instance</code> or <code class="email">nodes</code> for virtual machines, <code class="email">storage</code> or <code class="email">volumes</code> to refer to disks, or <code class="email">images</code> to refer to prebuilt operating system images or templates. I wish I could be more specific here, but this will depend on your cloud provider.</p><p class="calibre8">The action may or may not appear in the URL. Some cloud providers will include actions such as <code class="email">create</code>, <code class="email">list</code>, <code class="email">modify</code>, <code class="email">delete</code>, and so on, followed by the ID of the resource to be managed, where necessary.</p><p class="calibre8">However, it's becoming increasingly common for the action to be determined by the HTTP method that is used to make the call. The following methods are commonly used by REST APIs:</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec14" class="calibre1"/>GET</h3></div></div></div><p class="calibre8">This is <a id="id272" class="calibre1"/>used for calls that will only display, but never change resources. If an ID is not given, then a list of resources is usually given. If an ID is used, then the details about that specific resource will be returned.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec15" class="calibre1"/>POST</h3></div></div></div><p class="calibre8">This is <a id="id273" class="calibre1"/>often used for calls that create data, and frequently for those that modify data. If an ID is not declared, then a new resource will usually be created. If an ID is given, then an existing resource will be modified.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec16" class="calibre1"/>PATCH</h3></div></div></div><p class="calibre8">This method<a id="id274" class="calibre1"/> was recently added for modifying existing resources. If a cloud provider makes use of this method, then they are unlikely to allow <code class="email">POST</code> to modify existing data. Instead, <code class="email">POST</code> will only be used to apply new data, and <code class="email">PATCH</code> will be used to update existing data.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec17" class="calibre1"/>DELETE</h3></div></div></div><p class="calibre8">Calls<a id="id275" class="calibre1"/> using a <code class="email">DELETE</code> method will generally include both a resource type, and the ID of the resource to be removed. This method is never used to create or modify data; only remove it.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec80" class="calibre1"/>Setting up a _query() function</h2></div></div></div><p class="calibre8">Now<a id="id276" class="calibre1"/> that we know what the API will look like, let's create a function to communicate with it. We will make use of <code class="email">http.query()</code> to talk to it, but we also need to wrap a few other items in there as well. We'll start with a function declaration:</p><div><pre class="programlisting">def _query(
    resource=None,
    action=None,
    method='GET',
    location=None,
    data=None,
):</pre></div><p class="calibre8">Notice that we have made this function private. There is no reason to allow this function to be called directly from the command line, so we need to hide it. We have allowed any of the arguments to remain unspecified, because we won't always need all of them.</p><p class="calibre8">Let's go ahead and set our <code class="email">_query()</code> function, and then go over each of the components in it:</p><div><pre class="programlisting">import json
import salt.utils.http
import salt.config as config


def _query(
        resource=None,
        action=None,
        params=None,
        method='GET',
        data=None
    ):
    '''
    Make a web call to the cloud provider
    '''
    user = config.get_cloud_config_value(
        'user', get_configured_provider(), __opts__,
    )

    password = config.get_cloud_config_value(
        'password', get_configured_provider(), __opts__,
    )

    api_key = config.get_cloud_config_value(
        'api_key', get_configured_provider(), __opts__,
    )

    location = config.get_cloud_config_value(
        'location', get_configured_provider(), __opts__, default=None
    )

    if location is None:
        location = 'eu-north'

    url = 'https://{0}.api.example.com/v1'.format(location)

    if resource:
        url += '/{0}'.format(resource)

    if action:
        url += '/{0}'.format(action)

    if not isinstance(params, dict):
        params = {}

    params['api_key'] = api_key

    if data is not None:
        data = json.dumps(data)

    result = salt.utils.http.query(
        url,
        method,
        params=params,
        data=data,
        decode=True,
        decode_type='json',
        hide_fields=['api_key'],
        opts=__opts__,
    )

    return result['dict']</pre></div><p class="calibre8">We<a id="id277" class="calibre1"/> start off by collecting the connection parameters that are required for our cloud provider. The <code class="email">salt.config</code> library includes a function called <code class="email">get_cloud_config_value()</code> that searches through the cloud configuration for the requested value. It can search through the main cloud configuration (usually at <code class="email">/etc/salt/cloud</code>) as well as through any provider or profile configuration. In this case, all of the configuration should be found in the provider configuration, as specified in our docstring.</p><p class="calibre8">Once we have collected the <code class="email">user</code>, <code class="email">password</code>, and <code class="email">api_key</code>, we turn our attention to <code class="email">location</code>. You may recall that many cloud providers use the hostname to differentiate different data centers. Many also have a default data center. In the case of our generic driver, we'll assume that <code class="email">eu-north </code>is the default, and create a URL using that. Our URL also contains a version, as we mentioned before.</p><p class="calibre8">We then look at the resource that will be used, and any actions that will be performed on it. If found, these will be appended to the URL path. With those in place, we look at any parameters that will be added to the URL.</p><p class="calibre8">The <code class="email">params</code> variable refers to <code class="email">&lt;name&gt;=&lt;value&gt;</code> pairs that will be added to the URL. These will start with a question mark (<code class="email">?</code>) and then be separated with an ampersand (<code class="email">&amp;</code>), for instance:</p><div><pre class="programlisting">http://example.com/form.cgi?name1=value1&amp;name2=value2&amp;name3=value3</pre></div><p class="calibre8">Instead of appending these to the URL by ourselves, we'll let the <code class="email">http.query()</code> function take care of it for us. It will properly encode this data if specified and append it to the end of the URL for us.</p><p class="calibre8">If used, <code class="email">params</code> need to be specified as a dictionary. We know that <code class="email">api_key</code> will be one <code class="email">params</code>, so we add it after doing a type check.</p><p class="calibre8">Finally, we need to look at any data that is going to be <code class="email">POST</code>ed to the cloud provider. Many providers require <code class="email">POST</code> data to be sent as a JSON string, rather than as URL-encoded data, so if any data is given, we'll convert it to JSON before sending it over.</p><p class="calibre8">Once we have everything prepared, we use <code class="email">http.query()</code> (as <code class="email">salt.utils.http.query()</code>) to actually make the call. You can see <code class="email">url</code>, <code class="email">method</code> (as specified in the function declaration), <code class="email">params</code>, and <code class="email">data</code>. We've also set <code class="email">decode</code> to <code class="email">True</code> and <code class="email">decode_type</code> to <code class="email">json</code>, so that the return data from the cloud provider will automatically be converted to a dictionary for us.</p><p class="calibre8">We've also passed through a list of fields to hide from any logging that may occur inside the <code class="email">http.query()</code> function. This will keep data such as our <code class="email">api_key</code> private, in the event that any logs are generated. Rather than logging a URL such as:</p><div><pre class="programlisting">https://example.com/?api_key=0123456789abcdef</pre></div><p class="calibre8">A sanitized URL will be logged:</p><div><pre class="programlisting">https://example.com/?api_key=XXXXXXXXXX</pre></div><p class="calibre8">Finally, we<a id="id278" class="calibre1"/> pass through a copy of <code class="email">__opts__</code>, so that <code class="email">http.query()</code> has access to any variables that it needs from the <code class="email">master</code> or <code class="email">minion</code> configuration files.</p><p class="calibre8">The <code class="email">http.query()</code> function will return a dictionary, including an item called <code class="email">dict</code>, which contains the return data from the cloud provider, converted into a dictionary. This is what we will pass back to any functions calling our <code class="email">_query()</code> function.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec81" class="calibre1"/>Getting profile details</h2></div></div></div><p class="calibre8">Once<a id="id279" class="calibre1"/> we have the ability to connect <a id="id280" class="calibre1"/>to a cloud provider, we need to be able to collect information that can be used to create a VM on that provider. That almost always includes a list of VM images and VM sizes. If a cloud provider has multiple data centers (and most of them do), then you will also need a function that returns a list of them.</p><p class="calibre8">These three functions are called <code class="email">avail_images()</code>, <code class="email">avail_sizes()</code>, and <code class="email">avail_locations()</code>. They are accessed from the <code class="email">salt-cloud</code> command using the <code class="email">--list-images</code>, <code class="email">--list-sizes</code>, and <code class="email">--list-locations</code> options, respectively.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec18" class="calibre1"/>Listing images</h3></div></div></div><p class="calibre8">Images <a id="id281" class="calibre1"/>refer to a prebuilt root VM volume. With Windows images, this will be the <code class="email">C:\</code> disk volume. In other operating systems, it will be the <code class="email">/</code> volume. Very commonly, a cloud provider will give access to a number of different operating systems, and a number of different versions of each of those.</p><p class="calibre8">For instance, a cloud provider may offer a single image each for Ubuntu 14.04, Ubuntu 14.10, Ubuntu 15.04, and so on, or they may provide each of those bundled with WordPress, MediaWiki, MariaDB, or another popular software package.</p><p class="calibre8">In the case of our generic cloud provider, a list of images can be returned simply by requesting the <code class="email">images</code> resource:</p><div><pre class="programlisting">def avail_images():
    '''
    Get list of available VM images
    '''
    return _query(resource='images')</pre></div><p class="calibre8">In a profile configuration, an<a id="id282" class="calibre1"/> image is specified using the <code class="email">image</code> argument.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec19" class="calibre1"/>Listing sizes</h3></div></div></div><p class="calibre8">Sizes<a id="id283" class="calibre1"/> are a concept that is unique to cloud providers, and indeed not every cloud provider even supports them. Depending on the provider, size usually refers to a combination of the number of processors, processor speed, amount of RAM, disk space, type of disk (platter versus SSD), and so on.</p><p class="calibre8">Once again, our generic cloud provider will return a list of sizes under the <code class="email">sizes</code> resource:</p><div><pre class="programlisting">def avail_sizes():
    '''
    Get list of available VM sizes
    '''
    return _query(resource='sizes')</pre></div><p class="calibre8">In a profile configuration, a size is specified using the <code class="email">size</code> argument.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec20" class="calibre1"/>Listing locations</h3></div></div></div><p class="calibre8">Depending<a id="id284" class="calibre1"/> on the cloud provider, a location may refer to a specific data center, a region in some part of the world, or even a specific data center inside a region that contains multiple data centers.</p><p class="calibre8">As we said before, the location is often prepended to the URL used to talk to the API. In the case of our generic cloud provider, locations are queried using the <code class="email">regions</code> resource.</p><div><pre class="programlisting">def avail_locations():
    '''
    Get list of available locations
    '''
    return _query(resource='locations')</pre></div><p class="calibre8">In a profile configuration, a location is specified using the <code class="email">location</code> argument.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec82" class="calibre1"/>Listing nodes</h2></div></div></div><p class="calibre8">The next <a id="id285" class="calibre1"/>thing to do is display the nodes that currently <a id="id286" class="calibre1"/>exist inside the account for that cloud provider. There are three <code class="email">salt-cloud</code> arguments to display node data: <code class="email">-Q</code> or <code class="email">--query</code>, <code class="email">-F</code> or <code class="email">--full-query</code>, and <code class="email">-S</code> or <code class="email">--select-query</code>. Each of these options will query every configured cloud provider, and return all of the information at once.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec21" class="calibre1"/>Querying standard node data</h3></div></div></div><p class="calibre8">There <a id="id287" class="calibre1"/>are six pieces of information that should always be provided for each node. This data is displayed when the <code class="email">-Q</code> argument is used with <code class="email">salt-cloud</code>:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">id</code>: The ID of this VM, as used by the cloud provider.</li><li class="listitem"><code class="email">image</code>: The image used to create this VM. If this data is not available, it should be set to <code class="email">None</code>.</li><li class="listitem"><code class="email">size</code>: The size used to create this VM. If this data is not available, it should be set to <code class="email">None</code>.</li><li class="listitem"><code class="email">state</code>: The current running state of this VM. This is usually <code class="email">RUNNING</code>, <code class="email">STOPPED</code>, <code class="email">PENDING</code> (the VM is still booting), or <code class="email">TERMINATED</code> (the VM has been destroyed, but not yet cleaned up). If this data is not available, it should be set to None.</li><li class="listitem"><code class="email">private_ips</code>: Any private IP addresses that are used on a cloud provider's internal network. These should be returned as a list. If this data is not available, the list should be empty.</li><li class="listitem"><code class="email">public_ips</code>: Any public IP addresses that are available for this VM. Any IPv6 addresses should be included here. These IPs should be returned as a list. If this data is not available, the list should be empty.</li></ul></div><p class="calibre8">Users should have access to all of these variables, even if they are empty or set to None. This is also the only data that should be returned by the <code class="email">-Q</code> argument. To return this data, we use a function called <code class="email">list_nodes()</code>:</p><div><pre class="programlisting">def list_nodes():
    '''
    List of nodes, with standard query data
    '''
    ret = {}
    nodes = _query(resource='instances')
    for node in nodes:
        ret[node] = {
            'id': nodes[node]['id'],
            'image': nodes[node].get('image', None),
            'size': nodes[node].get('size', None),
            'state': nodes[node].get('state', None),
            'private_ips': nodes[node].get('private_ips', []),
            'public_ips': nodes[node].get('public_ips', []),
        }
    return ret</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec22" class="calibre1"/>Querying full node data</h3></div></div></div><p class="calibre8">VMs<a id="id288" class="calibre1"/> usually contain quite a bit more information than is returned with <code class="email">-Q</code>. If you want to view all of the information that a cloud provider is willing and able to display to you, you use the <code class="email">-F</code> flag. This corresponds to a function called <code class="email">list_nodes_full()</code>:</p><div><pre class="programlisting">def list_nodes_full():
    '''
    List of nodes, with full node data
    '''
    return _query(resource='instances')</pre></div><p class="calibre8">Sometimes, you are only interested in a very specific set of data. For instance, you may only want to display a VM's ID, public IPs, and state. The <code class="email">-S</code> option allows you to perform a query that returns only a selection of the fields that are available with a full query. The selection itself is defined as a list in the main cloud configuration file (usually <code class="email">/etc/salt/cloud</code>):</p><div><pre class="programlisting">query.selection:
  - id
  - public_ips
  - state</pre></div><p class="calibre8">The query itself is performed by a function called <code class="email">list_nodes_select()</code>. Some providers may require something special to be done to separate out this data, but most of the time you can just use the <code class="email">list_nodes_select()</code> function that ships with the <code class="email">salt.utils.cloud</code> library:</p><div><pre class="programlisting">import salt.utils.cloud


def list_nodes_select():
    '''
    Return a list of the VMs that are on the provider, with select fields
    '''
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full('function'), __opts__['query.selection'],
    )</pre></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch09lvl2sec83" class="calibre1"/>Creating a VM</h2></div></div></div><p class="calibre8">The<a id="id289" class="calibre1"/> most complex part of any cloud module has <a id="id290" class="calibre1"/>traditionally been the <code class="email">create()</code> function. That's because this function doesn't just spin up a VM. Its tasks can generally be split up into these components:</p><div><ul class="itemizedlist"><li class="listitem">Request that the cloud provider create a VM</li><li class="listitem">Wait for that VM to become available</li><li class="listitem">Log in to that VM and install Salt</li><li class="listitem">Accept that's VM's Minion keys on the Master</li></ul></div><p class="calibre8">Some more complex cloud providers may include additional steps, such as requesting different types of VMs based on the profile configuration, or attaching volumes to the VM. In addition, the <code class="email">create()</code> function should fire events along Salt's event bus, to let the Master know how far along it is with the creation process.</p><p class="calibre8">Before we get into the <code class="email">create()</code> function, we should put together another function called <code class="email">request_instance()</code>. This function will do two things for us:</p><div><ul class="itemizedlist"><li class="listitem">It can be called directly from <code class="email">create()</code>, which will simplify the <code class="email">create()</code> function</li><li class="listitem">It can be called outside of <code class="email">create()</code>, when a non-Salt VM is needed</li></ul></div><p class="calibre8">This function doesn't need to do much. As the name implies, it need only request that the cloud provider create a VM. But it will need to collect together some information to build the HTTP request:</p><div><pre class="programlisting">def request_instance(vm_):
    '''
    Request that a VM be created
    '''
    request_kwargs = {
        'name': vm_['name'],
        'image': vm_['image'],
        'size': vm_['size'],
        'location': vm_['location']
    }

    salt.utils.cloud.fire_event(
        'event',
        'requesting instance',
        'salt/cloud/{0}/requesting'.format(vm_['name']),
        {'kwargs': request_kwargs},
        transport=__opts__['transport']
    )

    return _query(
        resource='instances',
        method='POST',
        data=request_kwargs,
    )</pre></div><p class="calibre8">You've probably noticed the call to <code class="email">salt.utils.cloud.fire_event()</code> in this function. Every time you do something major in the <code class="email">create()</code> function (or in functions that are called by <code class="email">create()</code>), you should fire an event that gives some information about what you're about to do. Those events will be picked up by the event reactor, allowing the Master to<a id="id291" class="calibre1"/> keep track of progress and perform <a id="id292" class="calibre1"/>additional tasks if configured to do so, at the right time.</p><p class="calibre8">We're also going to create a function called <code class="email">query_instance()</code>. This function will watch a newly requested VM, and wait for an IP address to become available. This IP address will be used to log in to the VM and provision it.</p><div><pre class="programlisting">def query_instance(vm_):
    '''
    Query a VM upon creation
    '''
    salt.utils.cloud.fire_event(
        'event',
        'querying instance',
        'salt/cloud/{0}/querying'.format(vm_['name']),
        transport=__opts__['transport']
    )

    def _query_ip_address():
        nodes = list_nodes_full()
        data = nodes.get(vm_['name'], None)
        if not data:
            return False

        if 'public_ips' in data:
            return data['public_ips']
        return None

    data = salt.utils.cloud.wait_for_ip(
        _query_ip_address,
        timeout=config.get_cloud_config_value(
            'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),
        interval=config.get_cloud_config_value(
            'wait_for_ip_interval', vm_, __opts__, default=10),
        interval_multiplier=config.get_cloud_config_value(
            'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),
    )

    return data</pre></div><p class="calibre8">This function makes use of another function that ships with Salt called <code class="email">salt.utils.cloud.wait_for_ip()</code>. That function takes a callback, which we're defining as a nested function called <code class="email">_query_ip_address()</code>. That nested function checks to see if an IP address exists. If it does, then <code class="email">salt.utils.cloud.wait_for_ip()</code> will stop waiting and move on. If it does not yet exist, then it will keep waiting.</p><p class="calibre8">There are <a id="id293" class="calibre1"/>three more arguments that we're passing in <a id="id294" class="calibre1"/>as well. <code class="email">timeout</code> defines how long to wait for an IP address to show up at all (in our case, ten minutes); <code class="email">interval</code> tells Salt Cloud how long to wait between queries (our default is ten seconds).</p><p class="calibre8">You may be tempted to use a much shorter interval, but many cloud providers will throttle requests if an account seems to be abusing its privileges. On that note, <code class="email">interval_multiplier</code> will increase <code class="email">interval</code> after each request. For instance, if <code class="email">interval</code> was set to 1 and <code class="email">interval_multiplier</code> was set to 2, then requests would be spaced out at 1 second, then 2, 4, 8, 16, 32, and so on.</p><p class="calibre8">With those two functions in place, we can finally set up our <code class="email">create()</code> function. It requires one argument, which is a dictionary containing a combination of the profile, provider, and main cloud configuration data:</p><div><pre class="programlisting">def create(vm_):
    '''
    Create a single VM
    '''
    salt.utils.cloud.fire_event(
        'event',
        'starting create',
        'salt/cloud/{0}/creating'.format(vm_['name']),
        {
            'name': vm_['name'],
            'profile': vm_['profile'],
            'provider': vm_['driver'],
        },
        transport=__opts__['transport']
    )

    create_data = request_instance(vm_)
    query_data = query_instance(vm_)

    vm_['key_filename'] = config.get_cloud_config_value(
        'private_key', vm_, __opts__, search_global=False, default=None
    )
    vm_['ssh_host'] = query_data['public_ips'][0]

    salt.utils.cloud.bootstrap(vm_, __opts__)

    salt.utils.cloud.fire_event(
        'event',
        'created instance',
        'salt/cloud/{0}/created'.format(vm_['name']),
        {
            'name': vm_['name'],
            'profile': vm_['profile'],
            'provider': vm_['driver'],
        },
        transport=__opts__['transport']
    )

    return query_data</pre></div><p class="calibre8">We begin<a id="id295" class="calibre1"/> our function by firing an event stating that a<a id="id296" class="calibre1"/> creation process is being started. We then allow <code class="email">request_instance()</code> and <code class="email">query_instance()</code> to do their work, pull the name of an SSH key filename from the profile data, and then scrape an IP address to use to log in to the box from the VM data.</p><p class="calibre8">The next step involves waiting for the VM to become available, and then logging in and provisioning it. But since that part of the process is the same across cloud providers, it's all been rolled into another helper function inside <code class="email">salt.utils.cloud</code> called <code class="email">bootstrap()</code>. The <code class="email">bootstrap()</code> function will even fire additional events for us, keeping the event reactor apprised of its own status.</p><p class="calibre8">When all is said and done, we fire one last event stating the information about the VM, and return the VM's data to the user.</p><div><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">You may have noticed that the events that we fire all include a tag starting with <code class="email">salt/cloud/</code>, then the VM's name, then a short name for the step that we are currently performing. If you are working with a more complex cloud provider and wish to fire other events that are specific to them, keep the tag looking the same way, with as simple a descriptor as possible. This will help your users keep track of all of your cloud tags.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_8"><a id="ch09lvl2sec84" class="calibre1"/>Destroying VMs</h2></div></div></div><p class="calibre8">It's just<a id="id297" class="calibre1"/> as important<a id="id298" class="calibre1"/> to be able to destroy a VM as it is to be able to create one, but the process is thankfully much easier. Keep in mind that events should also be fired when destroying: once before it happens, and once after:</p><div><pre class="programlisting">def destroy(name):
    '''
    Destroy a machine by name
    '''
    salt.utils.cloud.fire_event(
        'event',
        'destroying instance',
        'salt/cloud/{0}/destroying'.format(name),
        {'name': name},
        transport=__opts__['transport']
    )

    nodes = list_nodes_full()
    ret = _query(
        resource='instances/{0}'.format(nodes[name]['id']),
        location=node['location'],
        method='DELETE'
    )

    salt.utils.cloud.fire_event(
        'event',
        'destroyed instance',
        'salt/cloud/{0}/destroyed'.format(name),
        {'name': name},
        transport=__opts__['transport']
    )

    if __opts__.get('update_cachedir', False) is True:
        salt.utils.cloud.delete_minion_cachedir(
            name, __active_provider_name__.split(':')[0], __opts__
        )

    return ret</pre></div><p class="calibre8">We've done one more important thing in this function. Salt Cloud has the ability to maintain a cache of information about VMs. We didn't see this before, because the <code class="email">bootstrap()</code> function handles populating the cache when a VM is created. However, since there<a id="id299" class="calibre1"/> is no generic method for destroying machines, we need to handle<a id="id300" class="calibre1"/> this manually.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_9"><a id="ch09lvl2sec85" class="calibre1"/>Using actions and functions</h2></div></div></div><p class="calibre8">So far, all <a id="id301" class="calibre1"/>of the functions that we've written are <a id="id302" class="calibre1"/>called directly using a special command-line argument (such as <code class="email">--query</code> or <code class="email">--provision</code>). However, there are other operations that cloud providers may be able to perform that are not necessarily as standard as the ones that we've seen so far.</p><p class="calibre8">For instance, most cloud providers have API methods for <code class="email">start</code>, <code class="email">stop</code>, and <code class="email">restart</code>. But some providers don't support all of those; <code class="email">start</code> and <code class="email">stop</code> may be available, but not <code class="email">restart</code>. Or <code class="email">start</code> and <code class="email">restart</code>, but not <code class="email">stop</code>. Other operations, such as listing SSH keys, may be available on one cloud provider, but not another.</p><p class="calibre8">When it comes down to it, there are two types of operations that can be performed against a cloud provider. Operations that are specific to a VM (<code class="email">stop</code>, <code class="email">start</code>, <code class="email">restart</code>, and so on) are known in <a id="id303" class="calibre1"/>Salt Cloud as <strong class="calibre2">actions</strong>. Operations that interact with a component <a id="id304" class="calibre1"/>of the cloud provider, that are not specific to a VM (listing SSH keys, modifying users, and so on), are known in Salt Cloud as <strong class="calibre2">functions</strong>.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec23" class="calibre1"/>Using actions</h3></div></div></div><p class="calibre8">Actions <a id="id305" class="calibre1"/>are called using the <code class="email">--action</code> argument with the <code class="email">salt-cloud</code> command. Because they operate on a specific VM, the first argument passed to them is a name. If other arguments are passed in from the command line, they will show up in a dictionary <a id="id306" class="calibre1"/>called <code class="email">kwargs</code>. There is one more argument, called <code class="email">call</code>, which tells a function whether it was called with <code class="email">--action</code> or <code class="email">--function</code>. You can use this to inform users when they have called an action or function incorrectly:</p><div><pre class="programlisting">def rename(name, kwargs, call=None):
    '''
    Properly rename a node. Pass in the new name as "newname".
    '''
    if call != 'action':
        raise SaltCloudSystemExit(
            'The rename action must be called with -a or --action.'
        )

    salt.utils.cloud.rename_key(
        __opts__['pki_dir'], name, kwargs['newname']
    )

    nodes = list_nodes_full()
    return _query(
        resource='instances/{0}'.format(nodes[name]['id']),
        action='rename',
        method='POST',
        data={'name': kwargs['newname']}
    )</pre></div><p class="calibre8">Even if you do not plan to issue a warning to users, you must accept the <code class="email">call</code> argument; it will be passed to it regardless, and an error will be raised if it isn't there.</p><p class="calibre8">Once<a id="id307" class="calibre1"/> again, I've sprung another surprise on you. Since this action will be renaming a VM, we need to notify Salt as well. If we don't, then the Master will be unable to contact the Minion. As usual, there is a helper function (<code class="email">salt.utils.cloud.rename_key()</code>) that does the work for us.</p></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec24" class="calibre1"/>Using functions</h3></div></div></div><p class="calibre8">Because<a id="id308" class="calibre1"/> functions do not operate on a specific VM, they do not require a name argument. However, they do require the <code class="email">kwargs</code> and <code class="email">call</code> arguments, even if you don't intend to use them for anything.</p><div><pre class="programlisting">def show_image(kwargs, call=None):
    '''
    Show the details for a VM image
    '''
    if call != 'function':
        raise SaltCloudSystemExit(
            'The show_image function must be called with -f or --function.'
        )

    return _query(resource='images/{0}'.format(kwargs['image']))</pre></div><p class="calibre8">If you add the call argument to various functions throughout your module, you will be able to call them directly using the <code class="email">--action</code> or <code class="email">--function</code> arguments. This can be very useful for, say, the <code class="email">list_nodes()</code> functions, when you want to look at VMs for only one cloud provider at a time, rather than all of them at once.</p><p class="calibre8">The only public function that cannot be called this way is the <code class="email">create()</code> function. <code class="email">destroy()</code> can be called using the <code class="email">--action</code> argument, and almost everything else that we've added so far can be called using the <code class="email">–-function</code> argument. We'll go ahead and add those in for our final cloud module.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec51" class="calibre1"/>The final cloud module</h1></div></div></div><p class="calibre8">When we <a id="id309" class="calibre1"/>have finished, the final cloud module will look like this:</p><div><pre class="programlisting">'''
Generic Salt Cloud module

This module is not designed for any specific cloud provider, but is generic
enough that only minimal changes may be required for some providers.

This file should be saved as salt/cloud/clouds/generic.py

Set up the cloud configuration at ``/etc/salt/cloud.providers`` or
``/etc/salt/cloud.providers.d/generic.conf``:

.. code-block:: yaml

    my-cloud-config:
      driver: generic
      # The login user
      user: larry
      # The user's password
      password: 123pass
'''
import json
import salt.utils.http
import salt.utils.cloud
import salt.config as config
from salt.exceptions import SaltCloudSystemExit

__virtualname__ = 'generic'


def __virtual__():
    '''
    Check for cloud configs
    '''
    if get_configured_provider() is False:
        return False

    return __virtualname__


def get_configured_provider():
    '''
    Make sure configuration is correct
    '''
    return config.is_provider_configured(
        __opts__,
        __active_provider_name__ or __virtualname__,
        ('user', 'password')
    )


def request_instance(vm_):
    '''
    Request that a VM be created
    '''
    request_kwargs = {
        'name': vm_['name'],
        'image': vm_['image'],
        'size': vm_['size'],
        'location': vm_['location']
    }

    salt.utils.cloud.fire_event(
        'event',
        'requesting instance',
        'salt/cloud/{0}/requesting'.format(vm_['name']),
        {'kwargs': request_kwargs},
        transport=__opts__['transport']
    )

    return _query(
        resource='instances',
        method='POST',
        data=request_kwargs,
    )


def query_instance(vm_):
    '''
    Query a VM upon creation
    '''
    salt.utils.cloud.fire_event(
        'event',
        'querying instance',
        'salt/cloud/{0}/querying'.format(vm_['name']),
        transport=__opts__['transport']
    )

    def _query_ip_address():
        nodes = list_nodes_full()
        data = nodes.get(vm_['name'], None)
        if not data:
            log.error('There was an empty response from the cloud provider')
            return False

        log.debug('Returned query data: {0}'.format(data))

        if 'public_ips' in data:
            return data['public_ips']
        return None

    data = salt.utils.cloud.wait_for_ip(
        _query_ip_address,
        timeout=config.get_cloud_config_value(
            'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),
        interval=config.get_cloud_config_value(
            'wait_for_ip_interval', vm_, __opts__, default=10),
        interval_multiplier=config.get_cloud_config_value(
            'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),
    )

    return data


def create(vm_):
    '''
    Create a single VM
    '''
    salt.utils.cloud.fire_event(
        'event',
        'starting create',
        'salt/cloud/{0}/creating'.format(vm_['name']),
        {
            'name': vm_['name'],
            'profile': vm_['profile'],
            'provider': vm_['driver'],
        },
        transport=__opts__['transport']
    )

    create_data = request_instance(vm_)
    query_data = query_instance(vm_)

    vm_['key_filename'] = config.get_cloud_config_value(
        'private_key', vm_, __opts__, search_global=False, default=None
    )
    vm_['ssh_host'] = query_data['public_ips'][0]

    salt.utils.cloud.bootstrap(vm_, __opts__)

    salt.utils.cloud.fire_event(
        'event',
        'created instance',
        'salt/cloud/{0}/created'.format(vm_['name']),
        {
            'name': vm_['name'],
            'profile': vm_['profile'],
            'provider': vm_['driver'],
        },
        transport=__opts__['transport']
    )

    return query_data


def destroy(name, call=None):
    '''
    Destroy a machine by name
    '''
    salt.utils.cloud.fire_event(
        'event',
        'destroying instance',
        'salt/cloud/{0}/destroying'.format(name),
        {'name': name},
        transport=__opts__['transport']
    )

    nodes = list_nodes_full()
    ret = _query(
        resource='instances/{0}'.format(nodes[name]['id']),
        location=node['location'],
        method='DELETE'
    )

    salt.utils.cloud.fire_event(
        'event',
        'destroyed instance',
        'salt/cloud/{0}/destroyed'.format(name),
        {'name': name},
        transport=__opts__['transport']
    )

    if __opts__.get('update_cachedir', False) is True:
        salt.utils.cloud.delete_minion_cachedir(
            name, __active_provider_name__.split(':')[0], __opts__
        )

    return ret


def rename(name, kwargs, call=None):
    '''
    Properly rename a node. Pass in the new name as "newname".
    '''
    if call != 'action':
        raise SaltCloudSystemExit(
            'The rename action must be called with -a or --action.'
        )

    salt.utils.cloud.rename_key(
        __opts__['pki_dir'], name, kwargs['newname']
    )

    nodes = list_nodes_full()
    return _query(
        resource='instances/{0}'.format(nodes[name]['id']),
        action='rename',
        method='POST',
        data={'name': kwargs['newname']}
    )


def show_image(kwargs, call=None):
    '''
    Show the details for a VM image
    '''
    if call != 'function':
        raise SaltCloudSystemExit(
            'The show_image function must be called with -f or --function.'
        )

    return _query(resource='images/{0}'.format(kwargs['image']))


def list_nodes(call=None):
    '''
    List of nodes, with standard query data
    '''
    ret = {}
    nodes = _query(resource='instances')
    for node in nodes:
        ret[node] = {
            'id': nodes[node]['id'],
            'image': nodes[node].get('image', None),
            'size': nodes[node].get('size', None),
            'state': nodes[node].get('state', None),
            'private_ips': nodes[node].get('private_ips', []),
            'public_ips': nodes[node].get('public_ips', []),
        }
    return ret


def list_nodes_full(call=None):
    '''
    List of nodes, with full node data
    '''
    return _query(resource='instances')


def list_nodes_select(call=None):
    '''
    Return a list of the VMs that are on the provider, with select fields
    '''
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full('function'), __opts__['query.selection'], call,
    )


def avail_images(call=None):
    '''
    Get list of available VM images
    '''
    return _query(resource='images')


def avail_sizes(call=None):
    '''
    Get list of available VM sizes
    '''
    return _query(resource='sizes')


def avail_locations(call=None):
    '''
    Get list of available locations
    '''
    return _query(resource='locations')


def _query(
        resource=None,
        action=None,
        params=None,
        method='GET',
        location=None,
        data=None
    ):
    '''
    Make a web call to the cloud provider
    '''
    user = config.get_cloud_config_value(
        'user', get_configured_provider(), __opts__, search_global=False
    )
    password = config.get_cloud_config_value(
        'password', get_configured_provider(), __opts__,
    )
    api_key = config.get_cloud_config_value(
        'api_key', get_configured_provider(), __opts__,
    )
    location = config.get_cloud_config_value(
        'location', get_configured_provider(), __opts__, default=None
    )

    if location is None:
        location = 'eu-north'

    url = 'https://{0}.api.example.com/v1'.format(location)

    if resource:
        url += '/{0}'.format(resource)

    if action:
        url += '/{0}'.format(action)

    if not isinstance(params, dict):
        params = {}

    params['api_key'] = api_key

    if data is not None:
        data = json.dumps(data)

    result = salt.utils.http.query(
        url,
        method,
        params=params,
        data=data,
        decode=True,
        decode_type='json',
        hide_fields=['api_key'],
        opts=__opts__,
    )

    return result['dict']</pre></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec52" class="calibre1"/>Troubleshooting cloud modules</h1></div></div></div><p class="calibre8">Cloud <a id="id310" class="calibre1"/>modules may seem daunting because there are so many components that are required to make a cohesive piece of code. But if you work on the module with bite-sized chunks, it will be a lot easier to handle.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec86" class="calibre1"/>Write avail_sizes() or avail_images() first</h2></div></div></div><p class="calibre8">Whenever I write a new cloud module, the first thing I do is get some sample code working that makes a small query. Because images and sizes are critical to the creation of a VM, and because those calls tend to be very simple, they are usually the easiest to get working.</p><p class="calibre8">Once you have one of those functions working, break it out into a <code class="email">_query()</code> function (if you didn't start that way) and a function that calls it. Then write another function that calls it. You may find yourself tweaking <code class="email">_query()</code> for each of the first few functions, but then it will stabilize and require few, if any, changes.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec87" class="calibre1"/>Use shortcuts</h2></div></div></div><p class="calibre8">I cannot tell you how many hours I have spent waiting for VMs to spin up, just to test one piece of code. If you break out the <code class="email">create()</code> function into a lot of smaller functions, then you can<a id="id311" class="calibre1"/> temporarily hardcode VM data as needed, and skip over operations that would otherwise waste too much time. Just be sure to take out the shortcuts when you finish!</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec53" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Salt Cloud is designed to handle compute resources, though additional cloud functionality can be added as needed. A cloud module can be written using Libcloud, an SDK, or the direct REST API; each method has its pros and cons. Modern REST APIs tend to be very similar and easy to work with. There are several functions that are required for a cohesive cloud module, but most are not complex. Actions are performed against individual VMs while functions are performed against cloud providers themselves.</p><p class="calibre8">Now that we've gone over cloud modules, it's time to start monitoring our resources. Next up: beacons.</p></div></body></html>