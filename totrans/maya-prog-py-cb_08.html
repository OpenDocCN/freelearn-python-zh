<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Working with File Input/Output</h1></div></div></div><p>In this chapter, we'll be looking at ways to get custom data in and out of Maya via scripting:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the fileDialog2 command to navigate the file system</li><li class="listitem" style="list-style-type: disc">Reading text files</li><li class="listitem" style="list-style-type: disc">Writing text files</li><li class="listitem" style="list-style-type: disc">Writing binary data</li><li class="listitem" style="list-style-type: disc">Reading binary data</li><li class="listitem" style="list-style-type: disc">Reading multiple types of files</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Introduction</h1></div></div></div><p>Although Maya is an incredibly powerful tool, it's almost always just one step in a larger toolchain. Whether you're using Maya to create prerendered animation for film and video or creating assets for use in real-time applications, you'll generally always need to interface Maya or the content you create within it, with other applications. Very often, this takes the form of either reading or writing data of a specific format.</p><p>In this chapter, we'll be looking at how to work with custom data formats, both text-based and binary, and to both read and write data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Using the fileDialog2 command to navigate the file system</h1></div></div></div><p>Loading <a id="id295" class="indexterm"/>and saving files will almost always require prompting the user for a file location. In this example, we'll look at how to do that. We'll also see how to work with directories, including creating new ones.</p><p>We'll create a script that will allow the user to browse the files in a <code class="literal">customData</code> folder within the current project directory. If that folder doesn't exist, it will be created the first time the script is run.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec157"/>How to do it...</h2></div></div></div><p>Create a <a id="id296" class="indexterm"/>new file and add the following:</p><div><pre class="programlisting">import os
import maya.cmds as cmds

def browseCustomData():

    projDir = cmds.internalVar(userWorkspaceDir=True)
    
    newDir = os.path.join(projDir, 'customData')

    if (not os.path.exists(newDir)):
        os.makedirs(newDir)

    cmds.fileDialog2(startingDirectory=newDir)


browseCustomData()</pre></div><p>You'll be presented with a file browser dialog. And, while the dialog won't actually do anything just yet, if you check your project directory, you'll find that it now contains a folder named <code class="literal">customData</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec158"/>How it works...</h2></div></div></div><p>The first thing to note about this script is that we add an additional import statement to the start of the script:</p><div><pre class="programlisting">import os</pre></div><p>The os library (short for "operating system") offers a variety of functionality related to the operating system of the host machine, including the ability to work with directories. We'll be using both to check to see whether a directory exists and to create it if it doesn't exist. More on this will be explained later.</p><p>For this script, we'll want to start by finding out what the current project directory is. For that, we can use the <code class="literal">internalVar</code> command. The <code class="literal">internalVar</code> command can be used to get access to various directories related to the current user's environment. It cannot be used to set any of those directories, only to query them. However, note that we don't actually use it in the query mode (Maya's commands aren't always the most consistent). Instead, we set the value of the flag we want the value of to true.</p><p>In this case, we're asking for the <code class="literal">userWorkspaceDir</code>, which will provide us with the current project directory:</p><div><pre class="programlisting">projDir = cmds.internalVar(userWorkspaceDir=True)</pre></div><p>Next, we <a id="id297" class="indexterm"/>want to test to see if there's the <code class="literal">customData</code> folder within the current workspace. To do this, we'll start by creating the full path to that directory (if it exists) by adding "customData" to the value that <code class="literal">internalVar</code> returned. We <em>could</em> do it with string manipulation, but that gets a bit tricky, since different platforms can use different characters to indicate separations between directories. Linux-based platforms (including Macintosh) use "/", whereas Windows machines use "\". A safer (and therefore better) way to go about it is to use Python's <code class="literal">os.path.join</code> method, which is guaranteed to be safe, as follows:</p><div><pre class="programlisting">newDir = os.path.join(projDir, 'customData')</pre></div><p>Now we have the full path to the <code class="literal">customData</code> folder, but it might not actually exist. We can use another function from <code class="literal">os.path</code>, <code class="literal">os.path.exists</code>, to check that, and to create it if it doesn't:</p><div><pre class="programlisting">if (not os.path.exists(newDir)):</pre></div><p>If we find that the path, in fact, does not exist, we use <code class="literal">os.makedirs</code> to create it:</p><div><pre class="programlisting">    os.makedirs(newDir)</pre></div><p>At this point, we can finally invoke the <code class="literal">fileDialog2</code> command to present the user with a file browser dialog. In order to make sure that it starts out in the <code class="literal">customData</code> directory, we set the <code class="literal">startingDirectory</code> flag to our <code class="literal">newDir</code> variable:</p><div><pre class="programlisting">cmds.fileDialog2(startingDirectory=newDir)</pre></div><p>Note that we use <code class="literal">fileDialog2</code>, which might look a bit odd. There is also a <code class="literal">fileDialog</code> command, but it's deprecated (along with the <code class="literal">fileBrowserDialog</code> command). As a result, we're left needing to use the somewhat awkwardly named <code class="literal">fileDialog2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec159"/>There's more...</h2></div></div></div><p>The <code class="literal">fileDialog2</code> command has a number of other options that we'll see in later examples. The <code class="literal">internalVar</code> command also has a number of additional locations that it can provide. One that is often useful is the <code class="literal">userScriptDir</code> option, which will provide the user's script directory.</p><p>If you wanted to get a list of all of the scripts currently in the user's script directory, for example, you could use the following snippet:</p><div><pre class="programlisting">def listScripts():
    scriptDir = cmds.internalVar(userScriptDir=True)
    print(os.listdir(scriptDir))</pre></div><p>The <code class="literal">os.listdir</code> command will provide an array of all the files in a given directory. In this case, we <a id="id298" class="indexterm"/>might want to create GUI with a button for each script, providing an easy way for users to select and run scripts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Reading text files</h1></div></div></div><p>In this example, we'll <a id="id299" class="indexterm"/>be reading a text file and using the contents to create some geometry in our scene.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec160"/>Getting ready</h2></div></div></div><p>In order to do any kind of file input/output, the first thing you'll need to do is to understand the file format that you're wanting to read (or create). In both this example and the one involving writing to text files, we'll be using an example file format—the "foo" file. "Foo" files are text-based files, and each line represents a geometric primitive of a given type, at a given location. The type of geometric primitive is represented by a three-letter string, with "spr" meaning a sphere and "cub" meaning a cube. The type string is then followed by three numbers representing the X, Y, and Z position of the item. So, an example <code class="literal">.foo</code> file might look something like the following:</p><div><pre class="programlisting">spr    0    0    0
cub    -2   0    -2</pre></div><p>Although this is certainly not a particularly useful format, it shares similarities with many common text-based formats. The OBJ format, for example, is a common standard for 3D models that uses a similar approach—each line consists of an identifier for the type of information it holds, followed by details on that entry. For example, a line indicating that there is a vertex located at 2, 3, and 4 would look like the following:</p><div><pre class="programlisting">v 2 3 4</pre></div><p>So, our "foo" files, while intentionally very simple, will be read and processed in much the same way as many <em>real</em> file formats.</p><p>Before you run the script for this example, make sure that you've created a <code class="literal">.foo</code> file. To do that, create a new text file and add some number of lines that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Begin with either "spr" (for sphere) or "cub" (for cube)</li><li class="listitem" style="list-style-type: disc">Are followed with three numbers (for X, Y, and Z positions), each separated by a space</li></ul></div><p>Be sure to save the file as a <code class="literal">.foo</code> file, rather than <code class="literal">.txt</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec161"/>How to do it...</h2></div></div></div><p>Create a <a id="id300" class="indexterm"/>new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def processFooLine(line):

    parts = line.split()

    if (len(parts) &lt; 4):
        cmds.error("BAD DATA " + line)

    x = float(parts[1])
    y = float(parts[2])
    z = float(parts[3])

    if (parts[0] == "spr"):
        cmds.sphere()
    elif (parts[0] == "cub"):
        cmds.polyCube()

    cmds.move(x, y, z)


def readFooFile():
    filePath = cmds.fileDialog2(fileMode=1, fileFilter="*.foo")

    fileRef = open(filePath[0], "r")

    line = fileRef.readline()
    while (line):
        processFooLine(line)
        line = fileRef.readline()

    fileRef.close()

readFooFile()</pre></div><p>Run the file, and you will be presented with a file dialog that will let you find a <code class="literal">.foo</code> file. Once you specify a file with valid FOO file data, you should see some number of spheres and cubes created.</p><div><img src="img/4657_08_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec162"/>How it works...</h2></div></div></div><p>The first thing <a id="id301" class="indexterm"/>we do in the script is to invoke the <code class="literal">fileDialog2</code> command in order to let the user specify a file. We set the <code class="literal">fileMode</code> flag to 1 to indicate that we want to read (rather than write) a file. We also make use of the <code class="literal">fileFilter</code> flag in order to point the user at our custom file format. This is totally optional, but it can be a nice way to prevent the user from giving you the wrong kind of data. To do that, we'll want to provide Maya with two things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A short description of the file type to show the user, and</li><li class="listitem" style="list-style-type: disc">One or more file extensions, with a wildcard character ("*")</li></ul></div><p>So in this case, we'll want to limit the user to "FOO files", and we'll identify those as anything that ends in either <code class="literal">.foo</code> or <code class="literal">.fo</code>. The final value of the string to pass in looks like:</p><div><pre class="programlisting">"FOO files (*.foo *.fo)"</pre></div><p>Note that we could also allow the user to open other kinds of files as well, by separating the strings for each with a double semicolon. Let's say that we wanted to allow the user to open text (<code class="literal">.txt</code>) files as well. For that, our call to <code class="literal">fileDialog2</code> would look like the following:</p><div><pre class="programlisting">cmds.fileDialog2(fileMode=1, fileFilter="FOO files (*.foo *.fo);;Text files (*.txt)")</pre></div><p>If you allow the user to open files of more than one type, each type will be available in the dropdown in the bottom of the file dialog. By selecting an option from the dropdown, the user can change which types of files the dialog will accept. Now that we've covered specifying the file type, let's go back to our regularly scheduled example.</p><p>We store the output of the <code class="literal">fileDialog</code> to a variable. We also check to make sure that the variable is not None before proceeding. This way, we'll ensure that we don't proceed with the script if the user has clicked on the "cancel" button:</p><div><pre class="programlisting">    filePath = cmds.fileDialog2(fileMode=1, fileFilter="FOO files (*.foo *.fo);;Text files (*.txt)")

    if (filePath == None):
        return</pre></div><p>Now we're <a id="id302" class="indexterm"/>ready to actually open the file. To do it, we use Python's <code class="literal">open</code> command, with the first argument being the full path to the file we want to open, and the second argument indicating the mode to open the file in, with <code class="literal">"r"</code> meaning "read":</p><div><pre class="programlisting">    fileRef = open(filePath[0], "r")</pre></div><p>Note that <code class="literal">filePath</code> is an array, so we'll need to feed in the first element into the open command. The return value of open, which we store in our <code class="literal">fileRef</code> variable, is a reference to the file that we can use to read in data.</p><p>For most types of text-based files (with FOO files being no exception), we'll want to read the file in line by line. We'll start by reading a single line from our file reference:</p><div><pre class="programlisting">    line = fileRef.readline()</pre></div><p>Once we've done that, we want to:</p><div><ol class="orderedlist arabic"><li class="listitem">Process the information in the line we just read</li><li class="listitem">Read the next line from the file</li><li class="listitem">Continue until we've read the entire file</li></ol></div><p>That's easily done with a while loop. The processing will be handled by a separate function, which we'll get to next:</p><div><pre class="programlisting">    while (line):
        processFooLine(line)
        line = fileRef.readline()</pre></div><p>Once we get to the end of the file, our line variable will be empty, and the while loop will terminate. The last thing we do is a bit of housekeeping, that is, we close the reference to the file:</p><div><pre class="programlisting">    fileRef.close()</pre></div><p>Now, let's take a closer look at how we process the data, in our <code class="literal">processFooLine</code> function. We start off by breaking the line up into parts, using Python's <code class="literal">split</code> function. That will take the input string and break it up into an array of strings, separated (by default) based on whitespaces:</p><div><pre class="programlisting">parts = line.split()

if (len(parts) &lt; 4):
    cmds.error("BAD DATA " + line)</pre></div><p>Because our <a id="id303" class="indexterm"/>FOO file specification states that each line should be a short string, followed by three numbers, we throw an error if our parts array has fewer than four entries. If it does have at least four, we convert the second, third, and fourth entries to floats and store them into variables for the <em>x</em>, <em>y</em>, and <em>z</em> position:</p><div><pre class="programlisting">x = float(parts[1])
y = float(parts[2])
z = float(parts[3])</pre></div><p>Now we create the object, either a sphere or a cube based on the first entry in the parts array:</p><div><pre class="programlisting">if (parts[0] == "spr"):
    cmds.sphere()
elif (parts[0] == "cub"):
    cmds.polyCube()</pre></div><p>Finally, we move the object we just created to the position indicated in our <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> variables:</p><div><pre class="programlisting">cmds.move(x, y, z)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec163"/>There's more...</h2></div></div></div><p>Although the FOO format specification is intentionally simplistic, we could easily extend it to store more information or possibly optional information. For example, we might also have an optional fifth entry to indicate the size of the object to be created (for example, face width for cubes and radius for spheres). If you would like to see what a format that is superficially similar to FOO files, but more useful, looks like, I encourage you to take a look at the OBJ file format. Not only is it widely used in 3D, but it's also a relatively simple format to understand and as such is a great introduction to file parsing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Writing text files</h1></div></div></div><p>In the<a id="id304" class="indexterm"/> previous example, we looked at how to read a custom data file format and use it to create geometry in a scene. In this example, we'll do the inverse, in that we'll examine our scene for polygonal cubes and NURBS spheres, and write the position of each one we find out to a new FOO file. In the process, we'll see how to write data to custom text-based formats.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec164"/>Getting ready</h2></div></div></div><p>Before running this example, make sure that you have a scene with some number of (NURBS) spheres and polygonal cubes in it. Make sure that you create the cubes and spheres with construction history enabled, otherwise our script won't be able to correctly identify the<a id="id305" class="indexterm"/> geometry.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec165"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def checkHistory(obj):
    history = cmds.listHistory(obj)

    geoType = ""

    for h in history:

        if (h.startswith("makeNurbSphere")):
            geoType = "spr"

        if (h.startswith("polyCube")):
            geoType = "cub"

    return geoType


def writeFOO():
    
    filePath = cmds.fileDialog2(fileMode=0, fileFilter="FOO files (*.foo)")

    if (filePath == None):
        return

    fileRef = open(filePath[0], "w")

    objects = cmds.ls(type="transform")

    for obj in objects:
        geoType = checkHistory(obj)

        if (geoType != ""):

            position = cmds.xform(obj, query=True, translation=True, worldSpace=True)
            positionString = " ".join(format(x, ".3f") for x in position)

            newLine = geoType + " " + positionString + "\n"
            fileRef.write(newLine)

    fileRef.close()


writeFOO()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec166"/>How it works...</h2></div></div></div><p>We start <a id="id306" class="indexterm"/>off by prompting the user to specify a file. As in the file reading example, we set the <code class="literal">fileFilter</code> flag so that the dialog is limited to .foo files. This time, though, we set the <code class="literal">fileMode</code> flag to 0 to indicate that we want to write a file (instead of a value of 1, indicating reading):</p><div><pre class="programlisting">filePath = cmds.fileDialog2(fileMode=0, fileFilter="FOO files (*.foo)")</pre></div><p>If the result of the <code class="literal">fileDialog2</code> command is empty (indicating that the user canceled), we stop. Otherwise, we continue with the script and open the specified file for writing. Again, note that the <code class="literal">fileDialog2</code> command returned an array, meaning that we need to pass in its first entry to the open command. We also set the second argument to <code class="literal">"w"</code>, indicating that we want to write to the file:</p><div><pre class="programlisting">if (filePath == None):
    return

fileRef = open(filePath[0], "w")</pre></div><p>Next, we need to find all of the cubes and spheres in our scene. To do that, we start off by getting all of the transform nodes in the scene.</p><div><pre class="programlisting">objects = cmds.ls(type="transform")</pre></div><p>For each object, we want to find out if it's a sphere or a cube. One way to do it is to examine the construction history of the object and see if there's a <code class="literal">makeNurbSphere</code> or <code class="literal">polyCube</code> node. To keep things nice and neat, we'll wrap that in a separate function, <code class="literal">checkHistory</code>.</p><p>To get the history for a given object, we can use the <code class="literal">listHistory</code> command, which will give us the construction history as an array:</p><div><pre class="programlisting">def checkHistory(obj):
    history = cmds.listHistory(obj)</pre></div><p>Once we've done that, we're ready to run through the history and see if we can find the geometry that we're looking for. But first, we set up a variable to hold the geometry type and initialize it to an empty string:</p><div><pre class="programlisting">geoType = ""</pre></div><p>If the object in<a id="id307" class="indexterm"/> question <em>is</em> one of the types we're looking for, it will have either the <code class="literal">makeNurbSphere</code> or <code class="literal">polyCube</code> node in its history. However, in either case, the node will have a number at the end of its name. So, we'll need to use Python's <code class="literal">startswith</code> command to perform the check, instead of just testing for direct equality.</p><p>If we find either of the geometry creation nodes we're looking for, we'll set our <code class="literal">geoType</code> string to the appropriate abbreviation (based on the FOO file format specification):</p><div><pre class="programlisting">for h in history:

    if (h.startswith("makeNurbSphere")):
        geoType = "spr"

    if (h.startswith("polyCube")):
        geoType = "cub"</pre></div><p>Finally, we return the <code class="literal">geoType</code> variable:</p><div><pre class="programlisting">return geoType</pre></div><p>The upshot of all that is that we'll have either "spr" or "cub" for the objects that we want to export, and an empty string for everything else. With this, we can turn our attention back to our main function.</p><p>Armed with out <code class="literal">checkHistory</code> function, we're now ready to loop through all of the objects in the scene, testing each one to see if it's the geometry we're interested in:</p><div><pre class="programlisting">for obj in objects:
    geoType = checkHistory(obj)

    if (geoType != ""):</pre></div><p>If the value returned from <code class="literal">checkHistory</code> is <em>not</em> an empty string, we know that we have something that we want to write out to our file. We already know the geometry type, but we still need to get the world-space position. For that, we use the <code class="literal">xform</code> command, in query mode.</p><div><pre class="programlisting">position = cmds.xform(obj, query=True, translation=True, worldSpace=True)</pre></div><p>Now we're finally ready to write our data out to our file. We'll want to build up a string with the following format:</p><div><pre class="programlisting">[geometry type ID] [x position] [y position] [z position]</pre></div><p>We'll start by creating a string from the position we received from <code class="literal">xform</code>. The position starts out as an array of floating-point numbers, which we'll want to convert into a single string. This means that we need to do two things:</p><div><ol class="orderedlist arabic"><li class="listitem">Convert the numbers to strings.</li><li class="listitem">Join the strings together into a single string.</li></ol></div><p>If we have<a id="id308" class="indexterm"/> an array of strings, we can join them together using Python's <code class="literal">join</code> command. The syntax for that is a bit odd, but it's easy enough to use; we start with a string that holds whatever it is that we would like to use as a separator. In this case (as in most cases), we'll want to use a space. We then call join on that string, passing in the list of elements that we want to join. So, if the position array contained strings, we could do the following:</p><div><pre class="programlisting">positionString = " ".join(position)</pre></div><p>However, it's not quite that easy because the position array contains floating-point values. So, before we can run join, we need to first convert the numerical values to strings. If that's all we want to do, we could do the following:</p><div><pre class="programlisting">positionString = " ".join(map(str, position))</pre></div><p>In the preceding code, we use Python's <code class="literal">map</code> function to apply the first argument (the <code class="literal">str</code> or string function) to each element of the second (the position array). That translates the position array into an array of strings, which can then be passed to the join function.</p><p>However, we may want more control over the formatting of our floats, which brings us to the line that we're actually using, namely:</p><div><pre class="programlisting">positionString = " ".join(format(x, ".3f") for x in position)</pre></div><p>This is a bit similar to the map-based example, in that we apply a function to the position array before passing the contents into the join function. However, in this case, we use the <code class="literal">format</code> function, which allows us more control over the specifics of how floats are formatted. In this case, we're limiting the precision of the values to three decimal places.</p><p>At this point, we have the full position of the object at hand as a string. To finish it off, we need to add the geometry type identifier (as specified in our FOO file format spec). We'll also want to add a newline (<code class="literal">\n</code>) character at the end, to ensure that each piece of geometry has a separate line for its data.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Note that if you open the created file in notepad on a Windows machine, you'll see that all of your data appear as a single line. That's because unix-like systems (including Mac) use <code class="literal">\n</code> as the newline character, whereas Windows uses <code class="literal">\r\n</code>. The <code class="literal">\r</code> is the carriage return character, whereas <code class="literal">\n</code> is the newline character. Using both is a byproduct of the old days when typewriters would perform two actions to move to the next line—move the paper all the way to the right (<code class="literal">\r</code>) and move it up (<code class="literal">\n</code>). If you're working on Windows, you might want to add <code class="literal">\r\n</code> instead of just <code class="literal">\n</code>.</p></div></div><p>This gives us the following:</p><div><pre class="programlisting">newLine = geoType + " " + positionString + "\n"</pre></div><p>Now we're finally<a id="id309" class="indexterm"/> ready to write the data to our file. That's easily done with a call to <code class="literal">write()</code> on our file:</p><div><pre class="programlisting">fileRef.write(newLine)</pre></div><p>Once we've finished our loop through all the objects and saved out all our data, we finish off by closing the file reference:</p><div><pre class="programlisting">fileRef.close()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec167"/>There's more...</h2></div></div></div><p>The example presented in this section may seem a bit artificial, but exporting positional data is a fairly common need. Very often, it can be easier for your art team to use Maya to position objects that are later used in some programmatic way, such as (in the case of games) spawn points or item pickup locations.</p><p>In this example, we identified the objects to export by examining their construction history. This can work, but it's easily broken if construction history is ever deleted. Because deleting history is a common thing to do, it's good to have alternative means to identify nodes for export.</p><p>One very reliable way to go about it is to add a custom attribute to nodes that should be exported and to use that when looping through objects. For example, we might be using polygonal cubes to indicate where certain types of item pickups are in a game level. To better prepare for exporting the data, we could add a <code class="literal">pickupType</code> attribute to each cube. </p><p>We could easily wrap that in a nice function to add the attribute and set its value, as in the following:</p><div><pre class="programlisting">def markAsPickup(obj, pickupType):
    customAtts = cmds.listAttr(obj, userDefined=True)

    if ("pickupType" not in customAtts):
        cmds.addAttr(obj, longName="pickupType", keyable=True)

    cmds.setAttr(obj + ".pickupType", pickupType)</pre></div><p>The preceding code would add a keyable <code class="literal">pickupType</code> attribute to a given object and set its value. Note that we check to see whether the <code class="literal">pickupType</code> attribute exists on the node before adding it because adding an attribute that already exists will generate an error. To check for the attribute, we first get a list of all the user-defined attributes, then test to see if <code class="literal">pickupType</code> exists in that array.</p><p>When we're ready to export our data, we can use the same trick to identify the objects for which we want to export data. If we wanted to write out data for every object that possesses the <code class="literal">pickupType</code> attribute, we could do the following:</p><div><pre class="programlisting">def listPickups():
    pickups = []
    objects = cmds.ls(type="transform")
    
    for obj in objects:
        customAtts = cmds.listAttr(obj, userDefined=True)
        if (customAtts != None):
            if ("pickupType" in customAtts):
                print(obj)
                pickups.append(obj)
    
return pickups</pre></div><p>We start by <a id="id310" class="indexterm"/>creating a new list to hold our pickups, then grabbing all of the transform nodes in the scene. For each transform, we grab all of the custom attributes added to it and check to see whether any of them are named <code class="literal">pickupType</code>. If that's the case, we add the object to our list. Once we've finished with the loop, we return the list, for use elsewhere (perhaps to write out their locations).</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec168"/>See also</h2></div></div></div><p>For a quick overview of the FOO file format, be sure to take a look at the previous example regarding reading text-based data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Writing binary data</h1></div></div></div><p>So far <a id="id311" class="indexterm"/>in this chapter, we've looked at reading and writing text-based data formats. This will allow you to work with many types of data (and to easily create your own formats), but it's only half of the picture. In this example, we'll look at the other half-binary formats.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec169"/>Getting ready</h2></div></div></div><p>In this example, we'll be writing out a binary version of our FOO file. We'll call such files FOB (foo, binary). As was the case with FOO files, FOB files are a scaled-down example of the types of things that are often encountered in real formats. FOB files will contain the same data we saw in FOO files, namely a list of object types and positions, but stored in a way common to binary formats.</p><p>Most binary<a id="id312" class="indexterm"/> files consist of two main parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A header, which is a fixed-size chunk that describes the nature of the rest of the document.</li><li class="listitem" style="list-style-type: disc">Entries that are read according to the data layout specified in the header.</li></ul></div><p>In the case of our FOB files, our header will contain the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An integer (1 byte) that specifies how many characters are used for the geometry type specification per entry (our "spr" or "cub").</li><li class="listitem" style="list-style-type: disc">An integer (1 byte) that specifies the maximum number of attributes per object (X, Y, and Z position at a minimum, possibly more data).</li><li class="listitem" style="list-style-type: disc">An integer (1 byte) that specifies the number of bytes per attribute.</li></ul></div><p>So, a specific FOB file might say that we're using three bytes for the geometry type, with a maximum number of four data values (X, Y, Z position and size), each of which uses four bytes. This would give us a header like the following:</p><div><pre class="programlisting">3 4 4</pre></div><p>After the header, there would be some number of entries, each of which would consist of 19 bytes (3 for the geometry type, plus 4 * 4, or 16 bytes for the data).</p><p>Before you run the example, make sure that you have one or more NURBS spheres and/or polygonal cubes in your scene and that they were created with construction history enabled (the default option).</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec170"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds
import struct


def checkHistory(obj):
    history = cmds.listHistory(obj)

    geoType = ""

    for h in history:

        if (h.startswith("makeNurbSphere")):
            geoType = "spr"

        if (h.startswith("polyCube")):
            geoType = "cub"

    return geoType


def writeFOBHeader(f):
    headerStr = 'iii'
    f.write(struct.pack(headerStr, 3, 3, 4))

def writeObjData(obj, geoType, f):

    position = cmds.xform(obj, query=True, translation=True, worldSpace=True)

    f.write(geoType)

    f.write(struct.pack('fff', position[0], position[1], position[2]))


def saveFOBFile():
    filePath = cmds.fileDialog2(fileMode=0, fileFilter="FOO Binary files (*.fob)")

    if (filePath == None):
        return

    fileRef = open(filePath[0], "wb")

    writeFOBHeader(fileRef)
    objects = cmds.ls(type="transform")

    for obj in objects:
        geoType = checkHistory(obj)

        if (geoType != ""):

            writeObjData(obj, geoType, fileRef)
            # positionString = " ".join(format(x, ".3f") for x in position)

    fileRef.close()


saveFOBFile()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec171"/>How it works...</h2></div></div></div><p>The first thing<a id="id313" class="indexterm"/> to note is that we have an additional import statement at the start of the script:</p><div><pre class="programlisting">import struct</pre></div><p>The <code class="literal">struct</code> library provides functions that we'll be using to properly format data to write to binary. More on that in a bit. Onto the script itself...</p><p>First off, we ask the user to specify a file, just as we've done in the previous examples. The only difference is that we change the <code class="literal">fileFilter</code> argument a bit to specify files of type "FOO Binary", with a <code class="literal">.fob</code> extension:</p><div><pre class="programlisting">filePath = cmds.fileDialog2(fileMode=0, fileFilter="FOO Binary files (*.fob)")</pre></div><p>We check to make sure that our <code class="literal">filePath</code> variable has an actual value (that the user didn't cancel out) and stop the script if it doesn't. We then open the file for writing:</p><div><pre class="programlisting">fileRef = open(filePath[0], "wb")</pre></div><p>Note that we're using <code class="literal">"wb"</code> instead of <code class="literal">"w"</code> as an argument to the open command; this tells Python that we want to open the file for writing (<code class="literal">"w"</code>) in binary mode (<code class="literal">"b"</code>).</p><p>Now we're ready to start writing to our file. Before we can write any data though, we'll need to write the header. In the case of FOB files, all that is three integers—one to hold the number of characters for the geometry identifier, one to hold the number of data points per object, and one to hold the number of bytes per data points.</p><p>To actually write the data, we'll use the pack function of the <code class="literal">struct</code> library. The pack function will create a sequence of bytes containing data of a given format, as specified in a format string. The format string is a sequence of characters, with each one representing the type of data that is to be written. The characters can be any of the following as well as many others:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>integer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>f</p>
</td><td style="text-align: left" valign="top">
<p>float</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>c</p>
</td><td style="text-align: left" valign="top">
<p>char</p>
</td></tr></tbody></table></div><p>For a full list, refer to Python's documentation.</p><p>In this case, we'll want to store three integers, so our format string will need to consist of three Is, as in:</p><div><pre class="programlisting">headerStr = 'iii'</pre></div><p>We pass the<a id="id314" class="indexterm"/> format string into the <code class="literal">struct.pack</code> function, followed by the values we want to encode (in this case, three integers). In this case, we'll want three characters for our geometry identifier length (to accommodate "spr" and "cub"), three points of data (the X, Y, and Z positions), and four bytes for each piece of data. Putting that all together gives us the following:</p><div><pre class="programlisting">struct.pack(headerStr, 3, 3, 4)</pre></div><p>Once we have the data packed up, we write it to our file with <code class="literal">write</code>. We wrap all of that in a nice function as follows:</p><div><pre class="programlisting">def writeFOBHeader(f):
    headerStr = 'iii'
    f.write(struct.pack(headerStr, 3, 3, 4))</pre></div><p>Now that we've written our header to the file, we're ready to write the data for our objects. We run through the scene and find all of the spheres and cubes in exactly the same way that we did in the example on saving text data. For each object we find, we write the data to our file.</p><div><pre class="programlisting">for obj in objects:
    geoType = checkHistory(obj)

    if (geoType != ""):
        writeObjData(obj, geoType, fileRef)</pre></div><p>Our <code class="literal">writeObjData</code> function takes the object itself, the object type string (as determined by our <code class="literal">checkHistory</code> function from the text output example and a reference to the file we're writing to.</p><p>Within the <code class="literal">writeObjData</code> function, we start out by grabbing the position of the object in world space using the <code class="literal">xform</code> command:</p><div><pre class="programlisting">position = cmds.xform(obj, query=True, translation=True, worldSpace=True)</pre></div><p>We then write the geometry type identifier (either "spr" or "cub") to the file. Writing text to binary files is easy—we just write the values directly. This will result in a single byte for each character being written to the file.</p><div><pre class="programlisting">f.write(geoType)</pre></div><p>Finally, we write the position data to the file, once again using the struct.pack function. This time, however, we want to write floating-point values, so we use three fs as the format string:</p><div><pre class="programlisting">f.write(struct.pack('fff', position[0], position[1], position[2]))</pre></div><p>Finally, and back in our main function, we close our file, which now contains both the header and all of our data.</p><div><pre class="programlisting">fileRef.close()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec172"/>There's more...</h2></div></div></div><p>We could easily<a id="id315" class="indexterm"/> write out more than just position data for each object. If we wanted to write out a radius value for each sphere, we would need to do a few things, namely:</p><div><ol class="orderedlist arabic"><li class="listitem">Change our header to specify four values per object, instead of just three.</li><li class="listitem">Change the format string passed in to pack to have four fs instead of three.</li></ol></div><p>Note that even though a radius value doesn't make sense in the case of a cube, we would still need to write <em>something</em> in that place in order to ensure that each entry occupies the same number of bytes. Since binary files are generally processed by reading in a set number of bytes at a time, having a byte width that changes from entry to entry would interfere with that.</p><p>If you think that it's a limitation, you're right. Binary formats tend to be much stricter than text-based formats, and they are generally only worth it if you really need to create very compact files. In general, if you're considering creating a custom format, text is almost always going to be a better choice. Reserve binary output for situations where you find yourself having to output data to an existing format that happens to be binary.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Reading binary data</h1></div></div></div><p>In this <a id="id316" class="indexterm"/>example, we'll look at how to read in binary data. We'll use our same example format, the "FOO binary" format, which consists of a header with three integers, followed by one or more entries, each of which has a string identifying a type of object and three or more numbers indicating its position (and possibly additional data).</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec173"/>Getting ready</h2></div></div></div><p>In order to run this example, you'll need to have a <code class="literal">.fob</code> file at the ready. Creating binary files manually is a bit of a hassle, so I recommend using the example explained earlier to generate one for you.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec174"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds
import struct

def makeObject(objType, pos):

    newObj = None

    if (objType == "spr"):
        newObj = cmds.sphere()
    elif (objType == "cub"):
        newObj = cmds.polyCube()

    if (newObj != None):
        cmds.move(pos[0], pos[1], pos[2])



def readFOBFile():
    filePath = cmds.fileDialog2(fileMode=1, fileFilter="FOO binary files (*.fob)")

    if (filePath == None):
        return

    f = open(filePath[0], "rb")

    data = f.read()

    headerLen = 12

    res = struct.unpack('iii', data[0:headerLen])

    geoTypeLen = res[0]
    numData = res[1]
    bytesPerData = res[2]

    objectLen = geoTypeLen + (numData * bytesPerData)
    
    numEntries = (len(data) - headerLen) / objectLen

    dataStr = 'f'*numData

    for i in range(0,numEntries):
        start = (i * objectLen) + headerLen 
        end = start + geoTypeLen

        geoType = data[start:end]

        start = end
        end = start + (numData * bytesPerData)

        pos = struct.unpack(dataStr, data[start:end])
        makeObject(geoType, pos)

    f.close()
    

readFOBFile()</pre></div><p>Run the script, point <a id="id317" class="indexterm"/>it at a valid .fob file, and you should see some number of spheres and/or cubes in your scene.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec175"/>How it works...</h2></div></div></div><p>In this example, we'll also be using the struct library (to unpack our data), so we need to make sure that we import it:</p><div><pre class="programlisting">import struct</pre></div><p>We start out by using the <code class="literal">fileDialog2</code> command to prompt the user to specify a .fob file and exiting the script if nothing was given:</p><div><pre class="programlisting">filePath = cmds.fileDialog2(fileMode=1, fileFilter="FOO binary files (*.fob)")

if (filePath == None):
    return</pre></div><p>If we have a file to open, we open it using the <code class="literal">open</code> command, passing in <code class="literal">"rb"</code> for the mode (<code class="literal">"r"</code> for reading and <code class="literal">"b"</code> for binary):</p><div><pre class="programlisting">f = open(filePath[0], "rb")</pre></div><p>Once we have the file open, we grab all of the data at once, using the <code class="literal">read</code> function:</p><div><pre class="programlisting">data = f.read()</pre></div><p>This will result in data holding an array of all of the bytes in the file. Once we've done that, we're ready to start parsing our content. For each bit of data we read, we'll be doing the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Reading some number of bytes from our data variable.</li><li class="listitem">Passing the bytes into <code class="literal">struct.unpack</code>, along with a format string indicating what type of data it should be interpreted as.</li></ol></div><p>The first thing we'll need to do is to read the file's header. In the case of .fob files, that's guaranteed to always be exactly 12 bytes—3 integers, at 4 bytes each. So, we start by reading the first 12 bytes in the data array and passing that to <code class="literal">struct.unpack</code>. The format string we use will be "iii", indicating that the bytes should be interpreted as three integers:</p><div><pre class="programlisting">    headerLen = 12
    res = struct.unpack('iii', data[0:headerLen])</pre></div><p>The output of <a id="id318" class="indexterm"/>the <code class="literal">unpack</code> function is an array containing the data. In this case, we have the number of bytes per geometric identifier, the number of data points per entry, and the number of bytes per data point. To make things easier on ourselves (and the code more readable), we store each element in its own, named variable:</p><div><pre class="programlisting">geoTypeLen = res[0]
numData = res[1]
bytesPerData = res[2]</pre></div><p>Once we've done that, we do one more thing for the sake of clarity in what comes next—we calculate the total number of bytes per entry as follows:</p><div><pre class="programlisting">objectLen = geoTypeLen + (numData * bytesPerData)</pre></div><p>Once we have that, we can determine the total number of entries in the file by dividing the total number of bytes (minus those consumed by the header) by the number of bytes per entry:</p><div><pre class="programlisting">numEntries = (len(data) - headerLen) / objectLen</pre></div><p>There's one more detail to take care of before we read the data; we'll want to create a format string for use with <code class="literal">struct.unpack</code>. In the case of <code class="literal">.fob</code> files, everything after the geometric identifier string will be a float, but we want to make sure that we take into account the number of entries, as specified in the header. So, if we have three entries per object, we'll want "fff", but if we have four, we would want "ffff". Python makes creating a string from a given number of repeated characters as easy as multiplying, which gives us the following:</p><div><pre class="programlisting">dataStr = 'f'*numData</pre></div><p>And with that, we're done with the prep work and we're ready to move on to actually reading our data. We start with a loop that runs for the number of entries that we found earlier:</p><div><pre class="programlisting">    for i in range(0,numEntries):</pre></div><p>The math to calculate the indices we'll need to read isn't particularly complicated, but it would get confusing, so we use a couple of variables to break it out onto separate lines.</p><p>The starting byte for each entry is simply the number of entries we've read so far multiplied by the total length per entry and offset by the length of the header. The end index is the start plus the length of the header:</p><div><pre class="programlisting">start = (i * objectLen) + headerLen 
end = start + geoTypeLen</pre></div><p>Reading the geometric identifier is easy, since it's just text, with each byte corresponding to a single letter:</p><div><pre class="programlisting">geoType = data[start:end]</pre></div><p>Now we set <a id="id319" class="indexterm"/>out start and end variables to new values to read the position (and possibly other) data. We set the start to the previous value of end. This works, because when reading a range of indices from a Python array, the values read start at the first number and read up to (but not including) the second.</p><p>The ending index for the data is the start plus the total number of bytes for the data (<code class="literal">numData * bytesPerData</code>):</p><div><pre class="programlisting">start = end
end = start + (numData * bytesPerData)</pre></div><p>And with this, we can finally read our object's data. We index into our data array and pass the result to <code class="literal">struct.unpack</code>, along with our previously created format string (<code class="literal">dataStr</code>):</p><div><pre class="programlisting">pos = struct.unpack(dataStr, data[start:end])</pre></div><p>Once we have both the geometry type (<code class="literal">geoType</code>) and the position (<code class="literal">pos</code>), we pass both into a function to actually create the geometry we want:</p><div><pre class="programlisting">makeObject(geoType, pos)</pre></div><p>The <code class="literal">makeObject</code> function is pretty straightforward—we use the <code class="literal">geoType</code> argument to create one of two possible objects and, if that worked, we move the created object to the position given in the <code class="literal">pos</code> array:</p><div><pre class="programlisting">def makeObject(objType, pos):

    newObj = None

    if (objType == "spr"):
        newObj = cmds.sphere()
    elif (objType == "cub"):
        newObj = cmds.polyCube()

    if (newObj != None):
        cmds.move(pos[0], pos[1], pos[2])</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec176"/>There's more...</h2></div></div></div><p>Till now, we've only read (or written) binary data of a single type, such as integers (for our header) and floats (for the data). The <code class="literal">struct.pack</code> and <code class="literal">struct.unpack</code> functions can also be used with mixed types, as long as you use the proper format string. For example, if we knew that our header contained three floats and one integer, we could use the following to read it in: </p><div><pre class="programlisting">struct.unpack('fffi', data[0:16])</pre></div><p>Note that the <a id="id320" class="indexterm"/>preceding code uses 0 and 16 as the start and end indices, which might seem like we're grabbing 17 bytes. However, Python interprets ranges as from the start up to (but not including) the second. So, what we're really saying is to use indices from 0 to (16-1), or 15.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Reading multiple types of files</h1></div></div></div><p>Sometimes, you<a id="id321" class="indexterm"/> might want to have a single script that is capable of reading in multiple file types. For example, if you were building a complex system to build character rigs, you might want to have one custom format that holds information about default bone layouts and another type that stores information about animation settings, allowing the user to mix and match any two files.</p><p>In such cases, you might want your script to handle files with multiple extensions—one for each type of data. In this example, we'll look at how to do that by creating a script that can be used to read either FOO (our example text-based format) or FOB (our example binary format).</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec177"/>Getting ready</h2></div></div></div><p>Make sure that you have at least one file of each type. For FOO files, you can just create them directly in a text editor. For FOB files, it's best to use the script in the writing binary files example.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec178"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds
import struct
import os

def readMultipleTypes():
    
    fileRes = cmds.fileDialog2(fileMode=1, fileFilter="FOO files(*.foo);;FOO binary files (*.fob)")

    if (fileRes == None):
        return

    filePath = fileRes[0]

    pathParts = os.path.splitext(filePath)
    extension = pathParts[1]

    if (extension == ".foo"):
        readFOOFile(filePath)
    elif (extension == ".fob"):
        readFOBFile(filePath)
    else:
        cmds.error("unrecognized file type")

readMultipleTypes()</pre></div><p>Note that the <a id="id322" class="indexterm"/>preceding code makes use of two functions that we haven't defined, namely <code class="literal">readFOOFile</code> and <code class="literal">readFOBFile</code>. I've left those out for the sake of brevity, but they both use the same code as we discussed in the previous examples on reading text and binary files, respectfully.</p><p>If you run the script, you'll be able to select FOO files or, by selecting "FOO binary files" from the drop-down list of file types, FOB files. Either way, you should see the corresponding collection of spheres and cubes added to the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec179"/>How it works...</h2></div></div></div><p>The first thing that we have to do in order to read multiple files is to add two or more types to the <code class="literal">fileFilter</code> argument, separating them with a double semicolon, as in:</p><div><pre class="programlisting">FOO files(*.foo);;FOO binary files (*.fob)</pre></div><p>Other than this, the <code class="literal">fileDialog2</code> command is used as we've used it in the past. Once we have the result from the command, we store the first entry (the path the used selected) into a <code class="literal">filePath</code> variable.</p><p>Once we've done that, we want to examine the file extension of the file chosen by the user. We could do that with string functions, but it's a bit safer to rely on Python's <code class="literal">os.path.splitext</code> function, which is specifically designed to separate extensions from paths, with the return being an array consisting of first the path (including filename) and then the extension:</p><div><pre class="programlisting">    filePath = fileRes[0]

    pathParts = os.path.splitext(filePath)
    extension = pathParts[1]</pre></div><p>Once we have the extension, we test it against all of the types we want to process, calling the appropriate function for each:</p><div><pre class="programlisting">if (extension == ".foo"):
    readFOOFile(filePath)
elif (extension == ".fob"):
    readFOBFile(filePath)
else:
    cmds.error("unrecognized file type")</pre></div><p>For each file type, we invoke a function to handle the actual processing, passing in the path to the file. We finish off by throwing an error, in the event that the user somehow managed to choose a file of a type that we don't handle.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec180"/>There's more...</h2></div></div></div><p>You can certainly<a id="id323" class="indexterm"/> extend this approach to handle a wide range of file types in a single script, though if you have a large number of types, selecting the proper one from the dropdown might prove tiring for the user.</p><p>In such cases, you might want to just leave out the <code class="literal">fileFilter</code> altogether, and just allow the script to accept all file types, relying on the extension-filtering logic to filter out any types that you didn't want to process.</p><p>In practice, however, if you're really dealing with a large number of different file types, it's likely that your script is trying to do too many things. Consider breaking it up into smaller components, with each one focused on a specific subset of the process you're building them for.</p></div></div></body></html>