- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Advanced Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设计模式
- en: 'In this chapter, we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍更多设计模式。我们将再次涵盖标准示例，以及任何在Python中常见的替代实现。我们将讨论以下内容：
- en: The Adapter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The Façade pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Lazy initialization and the Flyweight pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载和享元模式
- en: The Abstract Factory pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The Composite pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: The Template pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式
- en: The case study for this chapter will demonstrate how to apply a few of these
    patterns to the iris sample problem. In particular, we'll show how much of the
    design has been based – implicitly – on a number of these patterns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将展示如何将这些模式中的几个应用到鸢尾花样本问题中。特别是，我们将展示设计中有多少是基于这些模式——隐含地——构建的。
- en: 'Consistent with the practice in *Design Patterns: Elements of Reusable Object-Oriented
    Software*, we''ll capitalize the pattern names.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与《设计模式：可复用面向对象软件元素》中的实践一致，我们将首字母大写模式名称。
- en: We'll begin with the Adapter pattern. This is often used to provide a needed
    interface around an object with a design that doesn't – quite – fit our needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从适配器模式开始。这种模式通常用于在对象的设计不完全符合我们的需求时，提供一个所需的接口。
- en: The Adapter pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Unlike most of the patterns we reviewed in the previous chapter, the Adapter
    pattern is designed to interact with existing code. We would not design a brand
    new set of objects that implement the Adapter pattern. Adapters are used to allow
    two preexisting objects to work together, even if their interfaces are not compatible.
    Like the display adapters that allow you to plug your Micro USB charging cable
    into a USB-C phone, an adapter object sits between two different interfaces, translating
    between them on the fly. The adapter object's sole purpose is to perform this
    translation. Adapting may entail a variety of tasks, such as converting arguments
    to a different format, rearranging the order of arguments, calling a differently
    named method, or supplying default arguments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中回顾的大多数模式不同，适配器模式的设计目的是与现有代码进行交互。我们不会设计一套全新的对象来实现适配器模式。适配器用于允许两个预先存在的对象协同工作，即使它们的接口不兼容。就像允许您将Micro
    USB充电线插入USB-C手机的显示适配器一样，适配器对象位于两个不同接口之间，在运行时进行转换。适配器对象的唯一目的是执行这种转换。适配可能涉及各种任务，例如将参数转换为不同的格式、重新排列参数的顺序、调用不同名称的方法，或者提供默认参数。
- en: 'In structure, the Adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. This is depicted in UML form in the following
    diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构上，适配器模式类似于简化的装饰器模式。装饰器通常提供与它们所替代的相同接口，而适配器则在不同接口之间进行映射。这在上面的UML图中以图形形式表示：
- en: '![](img/B17070_12_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_01.png)'
- en: 'Figure 12.1: Adapter pattern'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：适配器模式
- en: Here, a client object, an instance of **Client**,needs to collaborate with another
    class to do something useful. In this example, we're using `load_data()` as a
    concrete example of a method that requires an adapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个客户端对象，即**Client**的一个实例，需要与其他类协作以完成一些有用的操作。在这个例子中，我们使用`load_data()`作为一个需要适配器的具体方法示例。
- en: 'We already have this perfect class, named **Implementation**, that does everything
    we want (and to avoid duplication, we don''t want to rewrite it!). This perfect
    class has one problem: it requires a complex sequence of operations using methods
    called `read_raw_data()`, `parse_raw_data()`, and `create_useful_object()`. The **Adapter** class
    implements an easy-to-use `load_data()` interface that hides the complexity of
    the existing interface provided by the **Implementation**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个完美的类，命名为**Implementation**，它能够完成我们想要的所有操作（为了避免重复，我们不想重新编写它！）。这个完美的类有一个问题：它需要使用名为`read_raw_data()`、`parse_raw_data()`和`create_useful_object()`的方法进行一系列复杂的操作。**Adapter**类实现了一个易于使用的`load_data()`接口，它隐藏了由**Implementation**提供的现有接口的复杂性。
- en: The advantage of this design is that the code that maps from the hoped-for interface
    to the actual interface is all in one place, the **Adapter** class. The alternative
    would require putting the code into the client, cluttering it up with possibly
    irrelevant implementation details. If we had multiple kinds of clients, we'd have
    to perform the complex `load_data()` processing in multiple places whenever any
    of those clients needed to access the `Implementation` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的优势在于，将希望接口映射到实际接口的代码都集中在一个地方，即**适配器**类。另一种选择则需要将代码放入客户端，可能会使客户端充斥着可能无关的实现细节。如果我们有多个客户端，那么每当这些客户端需要访问`Implementation`类时，我们都必须在多个地方执行复杂的`load_data()`处理。
- en: An Adapter example
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器示例
- en: 'Imagine we have the following pre-existing class, which takes string timestamps
    in the format `HHMMSS` and calculates useful floating-point intervals from those
    strings:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个以下预定义的类，它接受格式为`HHMMSS`的字符串时间戳，并从这些字符串中计算出有用的浮点时间间隔：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class handles string to time-interval conversion. Since we have this class
    in the application already, it has unit test cases and works nicely. If you forget
    the `from __future__ import annotations`, you'll get an error trying to use `tuple[float,
    float, float]` as a type hint. Be sure to include the `annotations` module as
    the first line of code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类处理字符串到时间间隔的转换。由于我们在应用程序中已经有了这个类，它有单元测试用例并且运行良好。如果你忘记了`from __future__ import
    annotations`，尝试使用`tuple[float, float, float]`作为类型提示时会出现错误。确保将`annotations`模块作为代码的第一行包含进来。
- en: 'Here''s an example showing how this class works:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了这个类是如何工作的：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with these unformatted times is a little awkward, but a number of **Internet
    of Things** (**IoT**) devices provide these kinds of time strings, separated from
    the rest of the date. For example, look at the NMEA 0183 format messages from
    a GPS device, where dates and times are unformatted strings of digits.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些未格式化的时间打交道有点尴尬，但许多**物联网**（**IoT**）设备提供这类时间字符串，与日期的其他部分分开。例如，看看来自GPS设备的NMEA
    0183格式消息，其中日期和时间是未格式化的数字字符串。
- en: We have an old log from one of these devices, apparently created years ago.
    We want to analyze this log for the sequence of messages that occur after each
    ERROR message. We'd like the exact times, relative to the ERROR, as part of our
    root cause problem analysis.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一份这些设备之一的旧日志，显然是几年前创建的。我们希望分析这份日志，找出每个ERROR消息之后发生的消息序列。我们希望得到相对于ERROR的精确时间，作为我们根本原因问题分析的一部分。
- en: 'Here''s some of the log data we''re using for testing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们用于测试的一些日志数据：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s difficult to compute the time interval between the ERROR and the WARNING
    message. It''s not impossible; many of us have enough fingers to do the computation.
    But it would be better to show the log with relative times instead of absolute
    times. Here''s an outline of the log formatter we''d like to use. This code, however,
    has a problem that we''ve marked with `???`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 计算ERROR信息和WARNING信息之间的时间间隔很困难。这并非不可能；我们大多数人都有足够的指头来进行计算。但最好是用相对时间而不是绝对时间来显示日志。以下是我们要使用的日志格式化程序的概要。然而，这段代码有一个问题，我们用`???`标记了它：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `LogProcessor` class seems like the right thing to do. It iterates through
    the log entries, resetting the `first_time` variable on each occurrence of an
    ERROR line. This makes sure that the log shows offsets from the error, saving
    us from having to do a lot of math to work out exactly what happened.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`LogProcessor`类看起来是正确的做法。它遍历日志条目，每次遇到ERROR行时都会重置`first_time`变量。这确保了日志显示从错误开始的偏移量，从而让我们免于进行大量的数学计算来确定确切发生了什么。
- en: 'But, we have a problem. We''d really like to reuse the `TimeSince` class. However,
    it doesn''t simply compute an interval between two values. We have several options
    to address this scenario:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们遇到了一个问题。我们非常希望重用`TimeSince`类。然而，它并不简单地计算两个值之间的间隔。我们有几种选择来应对这种情况：
- en: We could rewrite the `TimeSince` class to work with a pair of time strings.
    This runs a small risk of breaking something else in our application. We sometimes
    call this the **splash radius** of a change – how many other things get wet when
    we drop a boulder into the swimming pool? The Open/Closed design principle (one
    of the SOLID principles, which we discussed in the Chapter 4 case study; see [https://subscription.packtpub.com/book/application_development/9781788835831/4](https://subscription.packtpub.com/book/application_development/9781788835831/4)
    for more background) suggests a class should be open to extension but closed to
    this kind of modification. If this class was downloaded from PyPI, we may not
    want to change its internal structure because then we wouldn't be able to use
    any subsequent releases. We need an alternative to tinkering inside another class.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将`TimeSince`类重写为与一对时间字符串一起工作。这可能会使我们的应用中其他部分出现问题的风险增加。我们有时将这种变化称为**溅射半径**——当我们把一块大石头扔进游泳池时，会有多少其他东西被弄湿？开放/封闭设计原则（SOLID原则之一，我们在第4章案例研究中讨论过；更多背景信息请参阅[https://subscription.packtpub.com/book/application_development/9781788835831/4](https://subscription.packtpub.com/book/application_development/9781788835831/4)）建议一个类应该易于扩展但不易于这种修改。如果这个类是从PyPI下载的，我们可能不想改变其内部结构，因为那样我们就无法使用任何后续版本。我们需要一个替代方案来避免在另一个类内部进行篡改。
- en: We could use the class as it is, and whenever we want to calculate the intervals
    between an ERROR and subsequent log lines, we create a new `TimeSince` object.
    This is a lot of object creation. Imagine we have several log analysis applications,
    each looking at different aspects of the log messages. Making a change means having
    to go back and fix all of the places where these `TimeSince` objects were created.
    Cluttering up the `LogProcessor` class with details of how the `TimeSince` class
    works violates the Single Responsibility design principle. Another principle,
    **Don't Repeat Yourself** (**DRY**), seems to apply in this case, also.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用当前的类，并且每次我们需要计算一个错误和随后的日志行之间的间隔时，我们都会创建一个新的`TimeSince`对象。这会导致大量的对象创建。想象一下，如果我们有多个日志分析应用程序，每个应用程序都在查看日志消息的不同方面。进行更改意味着我们必须返回并修复所有创建这些`TimeSince`对象的地方。在`LogProcessor`类中添加`TimeSince`类工作细节会使类变得杂乱无章，这违反了单一职责设计原则。另一个原则，**不要重复自己**（**DRY**），在这个情况下似乎也适用。
- en: Instead, we can add an adapter that connects the needs of the `LogProcessor`
    class with the methods available from the `TimeSince` class.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，我们可以添加一个适配器，将`LogProcessor`类的需求与`TimeSince`类提供的方法相连接。
- en: 'The Adapter solution introduces a class that offers the interface required
    by the `LogProcessor` class. It consumes the interface offered by the `TimeSince`
    class. It allows for independent evolution of the two classes, leaving them closed
    to modification, but open to extension. It looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器解决方案引入了一个类，该类提供了`LogProcessor`类所需的接口。它消费了`TimeSince`类提供的接口。它允许两个类独立演化，使它们对修改封闭但对扩展开放。它看起来是这样的：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This adapter creates a `TimeSince` object when it's needed. If there is no `TimeSince`,
    it has to create one. If there is an existing `TimeSince` object, and it uses
    the already established start time, the `TimeSince` instance can be reused. If,
    however, the `LogProcessor` class has shifted the focus of the analysis to a new
    error message, then a new `TimeSince` needs to be created.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此适配器在需要时创建一个`TimeSince`对象。如果没有`TimeSince`，它必须创建一个。如果已经存在一个`TimeSince`对象，并且它使用已经建立的开端时间，那么`TimeSince`实例可以被重用。然而，如果`LogProcessor`类已经将分析的焦点转移到新的错误消息上，那么就需要创建一个新的`TimeSince`。
- en: 'Here''s the final design for the `LogProcessor` class, using the `IntervalAdapter`
    class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`LogProcessor`类的最终设计，使用了`IntervalAdapter`类：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We created an `IntervalAdapter()` instance during initialization. Then we used
    this object to compute each time offset. This lets us reuse the existing `TimeSince`
    class without any modification to the original class, and it leaves the `LogProcessor`
    uncluttered by details of how `TimeSince` works.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，我们创建了一个`IntervalAdapter()`实例。然后我们使用这个对象来计算每个时间偏移。这使得我们可以在不修改原始类的情况下重用现有的`TimeSince`类，并且它使`LogProcessor`不会因为`TimeSince`的工作细节而变得杂乱。
- en: We can also tackle this kind of design through inheritance. We could extend
    `TimeSince` to add the needed method to it. This inheritance alternative isn't
    a bad idea, and it illustrates the common situation where there's no single "right"
    answer. In some cases, we need to write out the inheritance solution and compare
    it with the adapter solution to see which one is easier to explain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过继承来处理这种设计。我们可以扩展`TimeSince`类来添加所需的方法。这种继承方案并不是一个坏主意，它说明了存在没有单一“正确”答案的常见情况。在某些情况下，我们需要编写出继承解决方案，并将其与适配器解决方案进行比较，以看哪一个更容易解释。
- en: Instead of inheritance, we can sometimes also use monkey patching to add a method
    to an existing class. Python lets us add a new method that provides the adapted
    interface that is required by calling code. This means, of course, the easy-to-find
    class definition inside the `class` statement isn't the whole class being used
    at runtime. We force other developers to search the code base to find out where
    the new feature was monkey patched into the class. Outside unit testing, monkey
    patching is not a good idea.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承不同，有时我们也可以使用猴子补丁（monkey patching）来向现有类中添加方法。Python 允许我们添加一个新方法，它提供了调用代码所需的适配接口。这意味着，当然，`class`
    语句内部的易于找到的类定义并不是运行时使用的整个类。我们迫使其他开发者搜索代码库以找出新特性被猴子补丁添加到类的位置。在单元测试之外，猴子补丁并不是一个好主意。
- en: 'It is often possible to use a function as an adapter. While this doesn''t obviously
    fit the traditional design of the Adapter class design pattern, it''s a distinction
    with little practical impact: a class with the `__call__()` method is a callable
    object, indistinguishable from a function. A function can be a perfectly good
    Adapter; Python doesn''t require everything be defined in classes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 经常可以将一个函数用作适配器。虽然这并不明显符合适配器类设计模式的传统设计，但这种区别对实际影响很小：具有`__call__()`方法的类是一个可调用对象，与函数无法区分。一个函数可以是一个完美的适配器；Python不要求所有内容都必须在类中定义。
- en: The distinction between Adapter and Decorator is small but important. An Adapter
    often extends, modifies, or combines more than one method from the class(es) being
    adapted. A Decorator, however, generally avoids profound changes, keeping a similar
    interface for a given method, adding features incrementally. As we saw in *Chapter
    11*, *Common Design Patterns*, a Decorator should be viewed as a specialized kind
    of Adapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器（Adapter）和装饰器（Decorator）之间的区别虽小但很重要。适配器通常扩展、修改或组合被适配的类（们）的多个方法。然而，装饰器一般避免进行深刻的变化，保持给定方法的相似接口，并逐步添加功能。正如我们在第11章“常见设计模式”中看到的，装饰器应被视为一种特殊的适配器。
- en: Using an Adapter class is a lot like using a Strategy class; the idea is that
    we might make changes, and need a different adapter someday. The principal difference
    is that Strategies are often chosen at runtime, where as an Adapter is a design-time
    choice and changes very slowly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器类与使用策略类非常相似；其理念是我们可能需要进行更改，并在某一天需要不同的适配器。主要区别在于策略通常在运行时选择，而适配器则是在设计时做出的选择，并且变化非常缓慢。
- en: The next pattern we'll look at is similar to an Adapter, as it also wraps functionality
    inside a new container. The difference is the complexity of what is being wrapped;
    a Façade often contains considerably more complex structures.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的下一个模式类似于适配器，因为它同样是在一个新容器中封装功能。区别在于被封装内容的复杂性；外观（Façade）通常包含更为复杂的结构。
- en: The Façade pattern
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: The Façade pattern is designed to provide a simple interface to a complex system
    of components. It allows us to define a new class that encapsulates a typical
    usage of the system, thereby avoiding a design that exposes the many implementation
    details hiding among multiple object interactions. Any time we want access to
    common or typical functionality, we can use a single object's simplified interface.
    If another part of the project needs access to more complete functionality, it
    is still able to interact with the components and individual methods directly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在为复杂组件系统提供一个简单的接口。它允许我们定义一个新的类，该类封装了系统的典型用法，从而避免暴露隐藏在多个对象交互中的许多实现细节的设计。任何我们需要访问常见或典型功能的时候，我们都可以使用单个对象的简化接口。如果项目的另一部分需要访问更完整的功能，它仍然可以直接与组件和单个方法进行交互。
- en: 'The UML diagram for the Façade pattern is really dependent on the subsystem,
    shown as a package, `Big System`, but in a cloudy way it looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Façade 模式的 UML 图实际上依赖于子系统，显示为一个包，`Big System`，但以模糊的方式看起来是这样的：
- en: '![](img/B17070_12_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_02.png)'
- en: 'Figure 12.2: The Façade pattern'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：外观模式
- en: The Façade pattern is, in many ways, like the Adapter pattern. The primary difference
    is that a Façade tries to abstract a simpler interface out of a complex one, while
    an Adapter only tries to map one existing interface to another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式在很多方面类似于适配器模式。主要区别在于外观模式试图从一个复杂的接口中抽象出一个更简单的接口，而适配器模式只尝试将一个现有的接口映射到另一个接口。
- en: A Façade example
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外墙示例
- en: The images for this book were made with PlantUML ([https://plantuml.com](https://plantuml.com)).
    Each diagram starts as a text file and needs to be converted to the PNG file that's
    part of the text. This is a two-step process and we use a Façade pattern to combine
    the two processes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的图像是用 PlantUML 制作的([https://plantuml.com](https://plantuml.com)). 每个图表最初都是一个文本文件，需要转换成作为文本一部分的
    PNG 文件。这是一个两步过程，我们使用外观模式（Façade pattern）来合并这两个过程。
- en: The first part is locating all of the UML files. This is a walk through the
    directory tree finding all files with names ending in `.uml`. We also look inside
    the file to see if there are multiple diagrams named inside the file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是定位所有的 UML 文件。这是通过遍历目录树来查找所有以 `.uml` 结尾的文件。我们还会查看文件内部，看看是否有多个在文件内部命名的图表。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `FindUML` class requires a base directory. The `uml_file_iter()` method
    walks the entire directory tree, using the `Path.glob()` method. It skips over
    any directories with names that start with `.`; these are often used by tools
    like **tox**, **mypy**, or **git**, and we don't want to look inside these directories.
    The remaining files will have `@startuml` lines in them. Some will have a line
    that names multiple output files. Most of the UML files don't create multiple
    files. The `self.start_pattern` regular expression will capture the name, if one
    is provided. The iterator yields tuples with two paths.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindUML` 类需要一个基本目录。`uml_file_iter()` 方法遍历整个目录树，使用 `Path.glob()` 方法。它会跳过任何以
    `.` 开头的目录；这些目录通常被像 **tox**、**mypy** 或 **git** 这样的工具使用，我们不希望查看这些目录内部。剩余的文件将包含 `@startuml`
    行。其中一些将包含指定多个输出文件的行。大多数 UML 文件不会创建多个文件。如果提供了名称，`self.start_pattern` 正则表达式将捕获该名称。迭代器产生包含两个路径的元组。'
- en: 'Separately, we have a class that runs the PlantUML application program as a
    subprocess. When Python is running, it''s an operating system process. We can,
    using the `subprocess` module, start child processes that run other binary applications
    or shell scripts. It looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分别地，我们有一个类，它作为子进程运行 PlantUML 应用程序。当 Python 运行时，它是一个操作系统进程。我们可以使用 `subprocess`
    模块启动子进程，运行其他二进制应用程序或 shell 脚本。它看起来是这样的：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `PlantUML` class depends on using **conda** to create a virtual environment
    named `CaseStudy`. If other virtual environment managers are used, a subclass
    can provide the needed path modifications. We'll need to install the Graphviz
    package into the named virtual environment; this renders the diagram as an image
    file. We also need to download the `plantuml.jar` file somewhere. We chose to
    put it into a `share` directory inside our virtual environment. The value of the
    `command` variable presumes the **Java Runtime Environment** (**JRE**) is properly
    installed and visible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PlantUML` 类依赖于使用 **conda** 创建一个名为 `CaseStudy` 的虚拟环境。如果使用其他虚拟环境管理器，子类可以提供所需的路径修改。我们需要将
    Graphviz 软件包安装到指定的虚拟环境中；这将把图表渲染为图像文件。我们还需要在某处下载 `plantuml.jar` 文件。我们选择将其放入虚拟环境内的
    `share` 目录中。`command` 变量的值假设 **Java 运行时环境**（**JRE**）已正确安装且可见。
- en: The `subprocess.run()` function accepts the command-line arguments and any special
    environment variables that need to be set. It will run the given command, with
    the given environment, and it will check the resulting return code to be sure
    the program ran properly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess.run()` 函数接受命令行参数以及需要设置的任何特殊环境变量。它将运行给定的命令，在给定的环境中执行，并且会检查返回的代码以确保程序正确运行。'
- en: Separately, we can use these steps to find all the UML files and create the
    diagrams. Because the interface is a bit awkward, a class that follows the Façade
    pattern helps create a useful command-line application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分别地，我们可以使用这些步骤来查找所有的 UML 文件并创建图表。因为界面有点不灵活，遵循外观模式的类有助于创建一个有用的命令行应用程序。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `GenerateImages` class is a handy façade that combines features of the `FindUML`
    and the `PlantUML` classes. It uses the `FindUML.uml_file_iter()` method to locate
    source files and output image files. It checks the modification times of these
    files to avoid processing them if the image is newer than the source. (The `stat().st_mtime`
    is pretty obscure; it turns out the `stat()` method of a `Path` provides a lot
    of file status information, and the modification time is only one of many things
    we can find about a file.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateImages` 类是一个方便的界面，它结合了 `FindUML` 和 `PlantUML` 类的功能。它使用 `FindUML.uml_file_iter()`
    方法定位源文件并输出图像文件。它会检查这些文件的修改时间，以避免在图像文件比源文件新时处理它们。（`stat().st_mtime` 非常晦涩；结果发现 `Path`
    的 `stat()` 方法提供了大量的文件状态信息，而修改时间只是我们能从文件中找到的许多信息之一。）'
- en: 'If the `.uml` file is newer, it means one of the authors changed it, and the
    images need to be regenerated. The main script to do this is now delightfully
    simple:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.uml`文件较新，这意味着作者之一对其进行了修改，因此需要重新生成图像。执行此操作的主要脚本现在变得非常简单：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example shows one of the important ways Python can be used to automate
    things. We broke the process into steps that we could implement in a few lines
    of code. Then we combined those steps, wrapping them in a Façade. Another, more
    complex application can use the Façade without worrying deeply about how it's
    implemented.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了Python可以用来自动化事物的一个重要方法。我们将这个过程分解成几个步骤，这些步骤可以用几行代码实现。然后我们把这些步骤组合起来，用门面模式（Façade）封装它们。另一个更复杂的应用可以使用门面模式，而不必深入关心其实现细节。
- en: Although it is rarely mentioned by name in the Python community, the Façade
    pattern is an integral part of the Python ecosystem. Because Python emphasizes
    language readability, both the language and its libraries tend to provide easy-to-comprehend
    interfaces for complicated tasks. For example, `for` loops, `list` comprehensions,
    and generators are all façades into a more complicated iterator protocol. The `defaultdict` implementation
    is a façade that abstracts away annoying edge cases when a key doesn't exist in
    a dictionary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Python 社区中很少被提及，但外观模式（Façade pattern）是 Python 生态系统的一个基本组成部分。因为 Python 强调语言的易读性，所以其语言及其库都倾向于为复杂任务提供易于理解的接口。例如，`for`
    循环、`list` 推导和生成器都是对更复杂的迭代协议的外观封装。`defaultdict` 的实现是一个外观封装，它抽象掉了当字典中不存在键时的烦人边缘情况。
- en: The third-party `requests` or `httpx` libraries are both powerful façades over
    less readable `urllib` libraries for HTTP processing. The `urllib` package itself
    is a façade over managing the text-based HTTP protocol using the underlying `socket`
    package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方`requests`或`httpx`库都是对HTTP处理中不太易读的`urllib`库的强大封装。`urllib`包本身是对使用底层`socket`包管理基于文本的HTTP协议的封装。
- en: A Façade conceals complexity. Sometimes, we want to avoid duplicating data.
    The next design pattern can help optimize storage when working with large volumes
    of data. It's particularly helpful on very small computers, typical for Internet
    of Things applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 外观隐藏了复杂性。有时，我们希望避免数据重复。下一个设计模式可以帮助在处理大量数据时优化存储。它在非常小的计算机上特别有用，这些计算机是物联网应用的典型代表。
- en: The Flyweight pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级模式
- en: The Flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of it. Relying on the built-in memory management is the best way to
    start. In some cases, for example, very large data science applications, memory
    constraints can become barriers, and more active measures need to be taken. In
    very small Internet of Things devices, memory management can also be helpful.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式是一种内存优化模式。新手 Python 程序员往往忽略内存优化，认为内置的垃圾回收器会处理它。依赖内置的内存管理是开始的最佳方式。在某些情况下，例如，非常大的数据科学应用，内存限制可能成为障碍，需要采取更积极的措施。在非常小的物联网设备中，内存管理也可能很有帮助。
- en: The Flyweight pattern ensures that objects that share a state can use the same
    memory for their shared state. It is normally implemented only after a program
    has demonstrated memory problems. It may make sense to design an optimal configuration
    from the beginning in some situations, but bear in mind that premature optimization
    is the most effective way to create a program that is too complicated to maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式确保共享相同状态的对象可以使用相同的内存来存储它们的共享状态。它通常只在程序已经显示出内存问题时才会被实现。在某些情况下，从一开始就设计一个最优配置可能是有意义的，但请记住，过早优化是创建一个过于复杂而难以维护的程序的最有效方式。
- en: In some languages, a Flyweight design requires careful sharing of object references,
    avoiding accidental object copying, and careful tracking of object ownership to
    ensure that objects aren't deleted prematurely. In Python, everything is an object,
    and all objects work through consistent references. A Flyweight design in Python
    is generally somewhat simpler than in other languages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，Flyweight设计需要仔细共享对象引用，避免意外复制对象，并仔细跟踪对象所有权以确保对象不会被提前删除。在Python中，一切皆对象，所有对象都通过一致的引用进行工作。Python中的Flyweight设计通常比其他语言要简单一些。
- en: 'Let''s have a look at the following UML diagram for the Flyweight pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下 Flyweight 模式的 UML 图：
- en: '![](img/B17070_12_03.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_03.png)'
- en: 'Figure 12.3: The Flyweight pattern'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：享元模式
- en: Each **Flyweight** object has no specific state of its own. Any time it needs
    to perform an operation on **SpecificState**, that state needs to be passed into
    the **Flyweight** by the calling code as an argument value. Traditionally, the
    factory that returns an instance of a `Flyweight` class is a separate object;
    its purpose is to return individual Flyweight objects, perhaps organized by a
    key or index of some kind. It works like the Singleton pattern we discussed in *Chapter
    11*, *Common Design Patterns*; if the Flyweight exists, we return it; otherwise,
    we create a new one. In many languages, the factory is implemented, not as a separate
    object, but as a static method on the `Flyweight` class itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **Flyweight** 对象都没有自己的特定状态。每次它需要在对 **SpecificState** 执行操作时，该状态都需要由调用代码作为参数值传递给 **Flyweight**。传统上，返回 `Flyweight` 类实例的工厂是一个单独的对象；其目的是返回单个Flyweight对象，可能通过某种键或索引进行组织。它的工作方式类似于我们在 *第11章*，*常见设计模式* 中讨论的单例模式；如果Flyweight存在，我们就返回它；否则，我们创建一个新的。在许多语言中，工厂不是作为一个单独的对象实现，而是作为 `Flyweight` 类本身的静态方法实现。
- en: We can liken this to the way the World Wide Web has replaced a computer loaded
    up with data. In the olden days, we would be forced to collect and index documents
    and files, filling up our local computer with copies of source material. This
    used to involve transfers of physical media like floppy disks and CDs. Now, we
    can – via a website – have a reference to the original data without making a bulky,
    space-consuming copy. Because we are working with a reference to the source data,
    we can read it easily on a mobile device. The Flyweight principle of working with
    a reference to data has been a profound change in our access to information.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这比作万维网取代了装满数据的计算机的方式。在古代，我们被迫收集和索引文档和文件，将我们的本地计算机填满源材料的副本。这曾经涉及到像软盘和CD这样的物理媒体的传输。现在，我们可以通过一个网站——来获取原始数据的引用，而不需要制作一个庞大、占用空间的副本。因为我们是在使用源数据的引用进行工作，所以我们可以在移动设备上轻松地阅读它。使用数据引用的Flyweight原则对我们获取信息的方式产生了深远的影响。
- en: Unlike the Singleton design pattern, which only needs to return one instance
    of a class, a Flyweight design may have multiple instances of the Flyweight classes.
    One approach is to store the items in a dictionary and provide values to Flyweight
    objects based on the dictionary key. Another common approach in some IoT applications
    is to leverage a buffer of items. On a large computer, allocating and deallocating
    objects is relatively low-cost. On a small IoT computer, we need to minimize object
    creation, which means leveraging Flyweight designs where a buffer is shared by
    objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅需要返回一个类实例的 Singleton 设计模式不同，Flyweight 设计模式可能包含多个 Flyweight 类的实例。一种方法是将项目存储在字典中，并根据字典键为
    Flyweight 对象提供值。在有些物联网应用中，另一种常见的方法是利用项目缓冲区。在大型计算机上，分配和释放对象相对成本较低。在小型物联网计算机上，我们需要最小化对象创建，这意味着利用共享缓冲区的
    Flyweight 设计。
- en: A Flyweight example in Python
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的轻量级示例
- en: 'We''ll start with some concrete classes for an IoT device that works with GPS
    messages. We don''t want to create a lot of individual `Message` objects with
    duplicate values taken from a source buffer; instead, we want Flyweight objects
    to help save memory. This leverages two important features:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个与GPS消息协同工作的物联网设备的具体类开始。我们不希望创建大量具有从源缓冲区复制值的单个`Message`对象；相反，我们希望使用Flyweight对象来帮助节省内存。这利用了两个重要的特性：
- en: The Flyweight objects reuse bytes in a single buffer. This avoids data duplication
    in a small computer.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级对象在单个缓冲区中复用字节。这避免了在小型计算机中的数据重复。
- en: The Flyweight classes can have unique processing for the various message types.
    In particular, the GPGGA, GPGLL, and GPRMC messages all have latitude and longitude
    information. Even though the details vary by message, we don't want to create
    distinct Python objects. It's a fair amount of overhead to handle the case when
    the only real processing distinction is the location of the relevant bytes within
    a buffer.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flyweight 类可以对各种消息类型进行独特的处理。特别是 GPGGA、GPGLL 和 GPRMC 消息都包含经纬度信息。尽管消息的细节各不相同，但我们不想创建不同的
    Python 对象。当唯一的实际处理区别是相关字节在缓冲区中的位置时，这会产生相当大的开销。
- en: 'Here''s the UML diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 UML 图：
- en: '![](img/B17070_12_04.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17070_12_04.png)'
- en: 'Figure 12.4: GPS messages UML diagram'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：GPS消息UML图
- en: Given a `Buffer` object with bytes read from the GPS, we can apply a `MessageFactory`
    to create Flyweight instances of the various `Message` subclasses. Each subclass
    has access to the shared `Buffer` object and can produce a `Point` object, but
    they have unique implementations reflecting the distinct structure of each message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个从GPS读取字节的`Buffer`对象，我们可以应用`MessageFactory`来创建各种`Message`子类的Flyweight实例。每个子类都可以访问共享的`Buffer`对象，并可以生成一个`Point`对象，但它们具有独特的实现，反映了每个消息的独特结构。
- en: There's an additional complication that is unique to Python. We can get into
    trouble when we have multiple references to an instance of the `Buffer` object.
    After working with a number of messages, we'll have local, temporary data in each
    of the `Message` subclasses, including a reference to the `Buffer` instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中存在一个独特的附加复杂性。当我们对 `Buffer` 对象的多个实例进行引用时，可能会遇到麻烦。在处理了若干条消息之后，我们会在每个 `Message`
    子类中拥有局部、临时数据，包括对 `Buffer` 实例的引用。
- en: 'The situation might look as shown in the following diagram, which has the concrete
    objects and their references:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 情况可能看起来如下所示，其中包含具体对象及其引用：
- en: '![](img/B17070_12_05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_05.png)'
- en: 'Figure 12.5: Reference diagram'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：参考图
- en: Some client application, shown as a `Client` object, has a reference to a `Buffer`
    instance. It read a bunch of GPS traffic into this buffer. Additionally, a specific
    `GPGGA` instance also has a reference to the `Buffer` object because offset 0
    in the buffer had a GPGGA message. Offsets 68 and 98 have other messages; these
    will also have references back to the `Buffer` instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些客户端应用程序，以`Client`对象的形式展示，拥有对`Buffer`实例的引用。它将大量GPS交通数据读入这个缓冲区。此外，一个特定的`GPGGA`实例也拥有对`Buffer`对象的引用，因为缓冲区中的偏移量0处有一个GPGGA消息。偏移量68和98处有其他消息；这些也将有对`Buffer`实例的引用。
- en: Because the `Buffer` has a reference to a GPGGA `Message` object, and the `Message`
    also has a reference back to the `Buffer`, we have a circular pair of references.
    When the client stops using a `Buffer`, the reference count goes from four references
    to three. We cannot easily remove the `Buffer` and its `Message` objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Buffer`对象有一个指向GPGGA `Message`对象的引用，而`Message`对象也回指`Buffer`对象，所以我们存在一对循环引用。当客户端停止使用`Buffer`时，引用计数从四个引用变为三个。我们无法轻易移除`Buffer`及其`Message`对象。
- en: We can solve this problem by taking advantage of Python's `weakref` module.
    Unlike ordinary ("strong") references, a weak reference isn't counted for the
    purposes of memory management. We can have lots of weak references to an object,
    but once the last ordinary reference is removed, the object can be removed from
    memory. This permits the client to start working with a new `Buffer` object without
    having to worry about the old `Buffer` cluttering up memory. The number of strong
    references goes from one to zero, allowing it to be removed. Similarly, each `Message`
    object could have one strong reference from the `Buffer`, so removing the `Buffer`
    will also remove each `Message`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用 Python 的 `weakref` 模块来解决此问题。与普通（"强"）引用不同，弱引用不计入内存管理的范畴。我们可以对一个对象拥有许多弱引用，但一旦最后一个普通引用被移除，该对象就可以从内存中移除。这允许客户端开始使用一个新的
    `Buffer` 对象，而无需担心旧的 `Buffer` 会占用内存。强引用的数量从一变为零，从而允许其被移除。同样，每个 `Message` 对象可能从
    `Buffer` 有一个强引用，因此移除 `Buffer` 也会移除每个 `Message`。
- en: Weak references are part of the foundation of the Python runtime. Consequently,
    they are an important optimization that surfaces in a few special cases. One of
    these optimizations is that we can't create a weak reference to a `bytes` object.
    The overhead would be painful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用是 Python 运行时基础的一部分。因此，它们是一些特殊情况下出现的重要优化。其中一种优化是我们不能创建对 `bytes` 对象的弱引用。这种开销会非常痛苦。
- en: In a few cases (like this) we need to create an Adapter for the underlying `bytes`
    object to transform it into an object that can have weak references.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下（如这种情况）我们需要为底层的 `bytes` 对象创建一个适配器，以便将其转换为一个可以拥有弱引用的对象。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This definition of a `Buffer` class doesn't really contain a great deal of new
    code. We provided three special methods, and all three delegated the work to the
    underlying `bytes` object. The `Sequence` abstract base type provides a few methods
    for us, like `index()` and `count()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Buffer`类的定义实际上并不包含很多新的代码。我们提供了三个特殊方法，而这三个方法都将工作委托给了底层的`bytes`对象。`Sequence`抽象基类为我们提供了一些方法，例如`index()`和`count()`。
- en: 'The three definitions of the overloaded `__getitem__()` method is how we tell
    **mypy** of the important distinction between an expression like `buffer[i]` and
    `buffer[start: end]`. The first expression gets a single `int` item from the buffer,
    the second uses a slice and returns a `bytes` object. The final non-overload definition
    of `__getitem__()` implements the two overloads by delegating the work to the
    `self.contents` object, which handles this nicely.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '重载的 `__getitem__()` 方法的三个定义是我们如何向 **mypy** 表明 `buffer[i]` 和 `buffer[start:
    end]` 这样的表达式之间的重要区别。第一个表达式从缓冲区获取单个 `int` 类型的项，第二个使用切片并返回一个 `bytes` 对象。`__getitem__()`
    的最终非重载定义通过将工作委托给 `self.contents` 对象来实现这两个重载，该对象很好地处理了这一点。'
- en: Back in *Chapter 11*, *Common Design Patterns*, we looked at using a state-based
    design to acquire and compute checksums. This chapter takes a different approach
    to working with a large volume of rapidly arriving GPS messages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*常见设计模式*中，我们探讨了使用基于状态的设计来获取和计算校验和。本章采用了一种不同的方法来处理大量快速到达的GPS消息。
- en: 'Here''s a typical GPS message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的GPS消息：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `$` starts the message. The `*` ends the message. The characters after
    the `*` are the checksum value. We''ll ignore the two checksum bytes in this example,
    trusting that it''s correct. Here''s the abstract `Message` class with some common
    methods to help parse these GPS messages:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`符号开始消息。`*`符号结束消息。`*`符号之后的字符是校验值。在这个例子中，我们将忽略两个校验字节，并相信它是正确的。以下是具有一些常用方法的`Message`抽象类，这些方法有助于解析这些GPS消息：'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `__init__()` method doesn't actually do anything. We've provided a list
    of instance variables with their types, but we don't actually set them here. This
    is a way to alert **mypy** to what instance variables are going to be set elsewhere
    in the class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法实际上并没有做任何事情。我们提供了一组实例变量及其类型列表，但在这里并没有实际设置它们。这是一种通知 **mypy**
    在类的其他地方将要设置哪些实例变量的方式。'
- en: In the `from_buffer()` method, we create a weak reference to a `Buffer` instance
    using the `weakref.ref()` function. As noted above, this special reference is
    not used to track how many places a `Buffer` object is used, allowing `Buffer`
    objects to be removed even if `Message` objects still have old, stale references
    to them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`from_buffer()`方法中，我们使用`weakref.ref()`函数创建对`Buffer`实例的弱引用。如上所述，这种特殊引用不用于跟踪`Buffer`对象被使用的位置数量，即使`Message`对象仍然持有对它们的旧、过时的引用，也允许移除`Buffer`对象。
- en: The `from_buffer()` method scans the buffer for "`,`" characters, making it
    easier to locate where each field is. This can save some time if we need several
    fields. If we only need one or two fields, this might be excessive overhead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_buffer()` 方法扫描缓冲区以查找 "`,`" 字符，这使得定位每个字段的位置变得更容易。如果我们需要多个字段，这可以节省一些时间。如果我们只需要一个或两个字段，这可能会造成过度的开销。'
- en: In the `__getitem__()` method, we de-reference the weak reference to track down
    the `Buffer` object. Normally, when processing a `Buffer`, it's in memory along
    with some `Message` objects. Evaluating `self.buffer()` – calling the reference
    like a function – retrieves the ordinary reference we can use in the body of the
    method. At the end of the `__getitem__()` method, the buffer variable is no longer
    used, and the temporary reference vanishes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__getitem__()` 方法中，我们取消对弱引用的引用以追踪 `Buffer` 对象。通常情况下，当处理 `Buffer` 时，它会在内存中与一些
    `Message` 对象一起存在。评估 `self.buffer()` – 就像调用函数一样调用引用 – 获取我们可以在方法主体中使用的普通引用。在 `__getitem__()`
    方法的末尾，缓冲区变量不再使用，临时引用也随之消失。
- en: 'A client application may have code like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序可能包含如下代码：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `buffer` variable has an ordinary reference to a `Buffer` object. Ideally,
    this is the only reference. Each time we execute this assignment statement, the
    old `Buffer` object will have zero references and can be removed from memory.
    After this assignment statement, and before we evaluate the `from_buffer()` method
    of a `Message`, an attempt to use the `__getitem__()` method of a `Message` object
    will raise a `RuntimeError` exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 变量对 `Buffer` 对象有一个普通引用。理想情况下，这应该是唯一的引用。每次我们执行这个赋值语句时，旧的 `Buffer` 对象将没有引用并且可以从内存中移除。在这条赋值语句之后，在我们评估
    `Message` 的 `from_buffer()` 方法之前，尝试使用 `Message` 对象的 `__getitem__()` 方法将引发 `RuntimeError`
    异常。'
- en: If our application attempts to use a `Message` object's `__getitem__()` method
    without having done `set_fields()` first, that's a serious, fatal bug. We've tried
    to make it obvious by crashing the application. When we get to *Chapter 13*, *Testing
    Object-Oriented Programs*, we can use unit tests to confirm that the methods are
    used in the proper order. Until then, we have to be sure we use `__getitem__()`
    correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序试图在没有先执行 `set_fields()` 的情况下使用 `Message` 对象的 `__getitem__()` 方法，那将是一个严重且致命的错误。我们通过使应用程序崩溃来试图让它变得明显。当我们到达第
    *13 章*，*面向对象程序的测试* 时，我们可以使用单元测试来确认方法是否按照正确的顺序使用。在此之前，我们必须确保我们正确地使用了 `__getitem__()`。
- en: 'Here''s the rest of the `Message` abstract base class, showing the methods
    required to extract a fix from a message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Message`抽象基类的其余部分，展示了从消息中提取修复所需的方法：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `get_fix()` method delegates the work to four separate methods, each of
    which extracts one of the many fields from the GPS message. We can provide subclasses
    like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_fix()` 方法将工作委托给四个独立的方法，每个方法从 GPS 消息中提取多个字段中的一个。我们可以提供如下子类：'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class will use the `get_field()` method, inherited from the `Message` class,
    to pick out the bytes for four specific fields in the overall sequence of bytes.
    Because the `get_field()` method uses a reference to a `Buffer` object, we don't
    need to duplicate the entire message's sequence of bytes. Instead, we reach back
    into the `Buffer` object to get the data, avoiding cluttering up memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课将使用从`Message`类继承而来的`get_field()`方法，从整个字节序列中挑选出四个特定字段的字节。因为`get_field()`方法使用了一个指向`Buffer`对象的引用，所以我们不需要复制整个消息的字节序列。相反，我们回溯到`Buffer`对象以获取数据，从而避免内存的杂乱。
- en: We haven't shown the `Point` object. It's left as part of the exercises. It
    needs to convert strings of bytes into useful floating-point numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有展示`Point`对象。它被留作练习的一部分。它需要将字节字符串转换为有用的浮点数。
- en: 'Here''s how we create a suitable Flyweight object, based on the message type
    in the buffer:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何根据缓冲区中的消息类型创建一个合适的享元对象：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we''re looking at a recognized message, we create an instance of one of
    our Flyweight classes. We left a comment suggesting another exercise: Use `functools.lru_cache`
    to avoid creating `Message` objects that are already available. Let''s look at
    how the `message_factory()` works in practice:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在查看一个已识别的消息，我们会创建我们Flyweight类中的一个实例。我们留下了一条注释建议另一个练习：使用`functools.lru_cache`来避免创建已经可用的`Message`对象。让我们看看`message_factory()`在实际中是如何工作的：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've loaded up a `Buffer` object with some bytes. The message name is a slice
    of bytes in positions 1 to 6 of the buffer. The slice operation will create a
    small `bytes` object here. The `message_factory()` function will locate one of
    our Flyweight class definitions, the `GPGLL` class. We can then use the `from_buffer()`
    method so the Flyweight can scan the `Buffer`, starting from offset zero, looking
    for "`,`" bytes to locate the starting point and ending point for the various
    fields.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一些字节加载到了一个`Buffer`对象中。消息名称是缓冲区中位置1到6的字节切片。切片操作将在这里创建一个小的`bytes`对象。`message_factory()`函数将定位我们Flyweight类定义中的一个，即`GPGLL`类。然后我们可以使用`from_buffer()`方法，这样Flyweight就可以从偏移量零开始扫描`Buffer`，寻找"`,`"字节以确定各个字段的起始点和结束点。
- en: When we evaluate `get_fix()`, the `GPGLL` flyweight will extract four fields,
    convert the values to useful degrees and return a `Point` object with two floating-point
    values. If we want to correlate this with other devices, we might want to show
    a value that has degrees and minutes separated from each other. It can be more
    helpful to see `37°51.6500S` than `37.86083333333333`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估 `get_fix()` 时，`GPGLL` 飞行轻量级将提取四个字段，将值转换为有用的度数，并返回一个包含两个浮点值的 `Point` 对象。如果我们想将其与其他设备关联起来，我们可能希望显示一个度数和分钟分开的值。看到
    `37°51.6500S` 比看到 `37.86083333333333` 更有帮助。
- en: Multiple messages in a buffer
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区中的多条消息
- en: Let's stretch this out a bit, to look at a buffer with a sequence of messages
    in it. We'll put two GPGLL messages into a sequence of bytes. We'll include explicit
    end-of-line whitespace characters that some GPS devices include in the data stream.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微展开一下，看看一个包含消息序列的缓冲区。我们将把两个GPGLL消息放入字节数列中。我们将包括一些GPS设备在数据流中包含的显式行尾空白字符。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've found the first GPGLL message, created a `GPGLL` object, and extracted
    the fix from the message. The next message begins where the previous message ends.
    This lets us start at a new offset in the buffer and examine a different region
    of bytes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了第一条GPGLL消息，创建了一个`GPGLL`对象，并从消息中提取了定位信息。下一条消息从上一条消息结束的地方开始。这使得我们可以在缓冲区的新偏移量处开始，检查不同的字节区域。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've used the `message_factory()` function to create a new GPGLL object. Since
    the data from the message isn't in the object, we can reuse the previous GPGLL
    object. We can take out the `flyweight =` line of code, and the results are the
    same. When we use the `from_buffer()` method, we'll locate a new batch of "`,`"
    characters. When we use the `get_fix()` method, we'll get values from a new place
    in the overall collection of bytes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`message_factory()`函数来创建一个新的GPGLL对象。由于消息中的数据不在对象中，我们可以重用之前的GPGLL对象。我们可以移除`flyweight
    =`这一行代码，结果仍然相同。当我们使用`from_buffer()`方法时，我们会定位到新的“`,`”字符批次。当我们使用`get_fix()`方法时，我们会从整体字节数据集合中的新位置获取值。
- en: This implementation creates a few short strings of bytes to create a cacheable
    object for use by `message_factory()`. It creates new float values when it creates
    a `Point`. It avoids slinging around large blocks of bytes, however, by making
    the message processing objects reuse a single `Buffer` instance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现创建了一些短的字节字符串来创建一个用于`message_factory()`的缓存对象。当它创建一个`Point`时，它会创建新的浮点值。然而，它通过使消息处理对象重用单个`Buffer`实例来避免传递大块字节。
- en: 'Generally, using the Flyweight pattern in Python is a matter of making sure
    we have references to the original data. Generally, Python avoids making implicit
    copies of objects; almost all object creation is obvious, using a class name or
    perhaps comprehension syntax. One case where object creation is not obvious is
    taking a slice from a sequence, like a buffer of bytes: when we use `bytes[start:
    end]`, this makes a copy of the bytes. Too many of these and our IoT device is
    out of usable memory. A Flyweight design avoids creating new objects, and – in
    particular – avoids slicing strings and bytes to create copies of the data.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，在Python中使用享元模式是一个确保我们有原始数据引用的问题。通常，Python避免对对象进行隐式复制；几乎所有的对象创建都是显而易见的，使用类名或者可能是理解语法。一个对象创建不明显的情况是从序列中取切片，比如字节数组缓冲区：当我们使用`bytes[start:
    end]`时，这会创建字节数组的副本。如果这些副本太多，我们的物联网设备就会耗尽可用内存。享元设计避免了创建新对象，并且特别避免通过切片字符串和字节来创建数据的副本。'
- en: Our example also introduced `weakref`. This isn't essential for a Flyweight
    design, but it can be helpful to identify objects that can be removed from memory.
    While the two are often seen together, they're not closely related.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子还介绍了`weakref`。这对于Flyweight设计来说不是必需的，但它可以帮助识别可以从内存中移除的对象。虽然这两个经常一起出现，但它们之间并没有紧密的联系。
- en: The Flyweight pattern can have an enormous impact on memory consumption. It
    is common for programming solutions that optimize CPU, memory, or disk space to
    result in more complicated code than their unoptimized brethren. It is therefore
    important to weigh up the trade-offs when deciding between code maintainability
    and optimization. When choosing optimization, try to use patterns such as Flyweight
    to ensure that the complexity introduced by optimization is confined to a single
    (well-documented) section of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式可以对内存消耗产生巨大的影响。对于优化 CPU、内存或磁盘空间的编程解决方案来说，它们通常会产生比未优化的版本更复杂的代码。因此，在决定代码的可维护性和优化之间权衡时，非常重要。在选择优化时，尽量使用如
    Flyweight 这样的模式，以确保优化引入的复杂性仅限于代码的一个（良好文档化的）部分。
- en: Before we look at the Abstract Factory pattern, we'll digress a bit, to look
    at another memory optimization technique, unique to Python. This is the `__slots__`
    magic attribute name.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨抽象工厂模式之前，我们将稍微偏离一下主题，来了解一下Python特有的另一种内存优化技术。这就是`__slots__`魔法属性名。
- en: Memory optimization via Python's __slots__
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Python 的 `__slots__` 进行内存优化
- en: If you have a lot of Python objects in one program, another way to save memory
    is through the use of `__slots__`. This is a sidebar, since it's not a common
    design pattern outside the Python language. It is a helpful Python design pattern
    because it can shave a few bytes off an object that's used widely. Instead of
    a Flyweight design – where storage is intentionally shared – a slots design creates
    objects with their own private data, but avoids Python's built-in dictionary.
    Instead, there is direct mapping from attribute name to a sequence of values,
    avoiding the rather large hash table that is a part of every Python `dict` object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个程序中有很多Python对象，另一种节省内存的方法是通过使用`__slots__`。这是一个旁注，因为它不是Python语言之外常见的模式。这是一个有用的Python设计模式，因为它可以从广泛使用的对象中节省几个字节。与共享存储的Flyweight设计不同——其中存储是故意共享的——slots设计创建了具有自己私有数据的对象，但避免了Python的内置字典。相反，存在从属性名到值序列的直接映射，避免了每个Python
    `dict`对象都包含的相当大的哈希表。
- en: 'Looking back at our previous example in this chapter, we avoided describing
    the `Point` object that was created as part of the `get_fix()` method of each
    subclass of `Message`. Here''s one possible definition of the `Point` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章之前的示例，我们避免了描述作为`Message`每个子类的`get_fix()`方法创建的`Point`对象。下面是`Point`类的一个可能定义：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each instance of a `Point` can have exactly two attributes with the names `latitude`
    and `longitude`. The `__init__()` method sets these values and provides useful
    type hints for tools like **mypy**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Point` 实例恰好可以有两个属性，名称分别为 `latitude` 和 `longitude`。`__init__()` 方法设置这些值，并为像
    **mypy** 这样的工具提供了有用的类型提示。
- en: 'In most other respects, this class is the same as a class without `__slots__`.
    The most notable difference is we cannot add attributes. Here''s an example, showing
    what exception is raised:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他方面，这个类与没有 `__slots__` 的类相同。最显著的区别是我们不能添加属性。以下是一个示例，展示了会抛出什么异常：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The extra housekeeping of defining the names of the slots can be helpful when
    our application creates vast numbers of these objects. In many cases, however,
    our application is built on one or a very small number of instances of a class,
    and the memory-saving from introducing `__slots__` is negligible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定义槽位名称的额外维护工作，在我们应用程序创建大量此类对象时可能有所帮助。然而，在许多情况下，我们的应用程序建立在类的一个或非常少数的实例之上，引入`__slots__`所带来的内存节省是微不足道的。
- en: In some cases, using a `NamedTuple` can be as effective at saving memory as
    using `__slots__`. We looked at these in *Chapter 7*, *Python Data Structures*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用`NamedTuple`可以像使用`__slots__`一样有效地节省内存。我们曾在*第7章*，*Python数据结构*中讨论过这些内容。
- en: We've seen how to manage complexity by wrapping objects in a Façade. We've seen
    how to manage memory use by using Flyweight objects that have little (or no) internal
    state. Next, we'll look at how we can create a variety of different kinds of objects
    using a *factory*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过封装对象在门面（Façade）中管理复杂性。我们也看到了如何通过使用具有少量（或没有）内部状态的享元（Flyweight）对象来管理内存使用。接下来，我们将探讨如何使用*工厂*创建各种不同类型的对象。
- en: The Abstract Factory pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The Abstract Factory pattern is appropriate when we have multiple possible implementations
    of a system that depend on some configuration or platform detail. The calling
    code requests an object from the Abstract Factory, not knowing exactly what class
    of object will be returned. The underlying implementation returned may depend
    on a variety of factors, such as the current locale, operating system, or local
    configuration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式适用于我们有一个或多个系统实现的可能，这些实现依赖于某些配置或平台细节。调用代码从抽象工厂请求一个对象，并不知道将返回哪种类的对象。底层返回的实现可能依赖于各种因素，例如当前区域设置、操作系统或本地配置。
- en: Common examples of the Abstract Factory pattern include code for operating-system-independent
    toolkits, database backends, and country-specific formatters or calculators. An
    operating-system-independent GUI toolkit might use an Abstract Factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object-relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an Abstract Factory
    can return a particular tax calculation object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的常见示例包括操作系统无关的工具包代码、数据库后端、以及特定国家的格式化器或计算器。一个操作系统无关的GUI工具包可能会使用抽象工厂模式，在Windows下返回一组WinForm小部件，在Mac下返回一组Cocoa小部件，在Gnome下返回一组GTK小部件，在KDE下返回一组QT小部件。Django提供了一个抽象工厂，根据当前站点的配置设置返回一组用于与特定数据库后端（MySQL、PostgreSQL、SQLite等）交互的对象关系类。如果应用程序需要部署在多个地方，每个地方只需更改一个配置变量就可以使用不同的数据库后端。不同的国家有不同的系统来计算零售商品的税费、小计和总计；抽象工厂可以返回特定的税费计算对象。
- en: 'There are two central features of an Abstract Factory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂有两个核心特性：
- en: We need to have multiple implementation choices. Each implementation has a factory
    class to create objects. A single Abstract Factory defines the interface to the
    implementation factories.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要有多重实现选择。每个实现都有一个工厂类来创建对象。一个单独的抽象工厂定义了实现工厂的接口。
- en: We have a number of closely related objects, and the relationships are implemented
    via multiple methods of each factory.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们拥有许多紧密相关的对象，并且这些关系是通过每个工厂的多种方法实现的。
- en: 'The following UML class diagram seems like a clutter of relationships:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 类图看起来像是一团关系的混乱：
- en: '![](img/B17070_12_06.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_06.png)'
- en: 'Figure 12.6: Abstract Factory pattern'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：抽象工厂模式
- en: There's an essential symmetry here that's very important. The client needs instances
    of class A and class B. To the client, these are abstract class definitions. The
    `Factory` class is an abstract base class that requires an implementation. Each
    of the implementation packages, `implementation_1` and `implementation_2`, provides
    concrete `Factory` subclasses that will build the necessary A and B instances
    for the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常重要的基本对称性。客户端需要A类和B类的实例。对于客户端来说，这些都是抽象类定义。`Factory`类是一个抽象基类，它需要一个实现。每个实现包，`implementation_1`和`implementation_2`，都提供了具体的`Factory`子类，这些子类将为客户端构建必要的A和B实例。
- en: An Abstract Factory example
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂示例
- en: 'The UML class diagram for the Abstract Factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. Let''s look at two card games, Poker and Cribbage. Don''t panic,
    you don''t need to know all the rules, only that they''re similar in a few fundamental
    ways but different in the details. This is depicted in the following diagram:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有具体示例，抽象工厂模式的 UML 类图很难理解，所以让我们先从创建一个具体示例开始。让我们看看两种纸牌游戏，扑克和克里比奇。别慌，你不需要知道所有规则，只需知道它们在几个基本方面相似但在细节上不同。这如下面的图中所示：
- en: '![](img/B17070_12_07.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_07.png)'
- en: 'Figure 12.7: Abstract Factory pattern for Cribbage and Poker'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：Cribbage和Poker的抽象工厂模式
- en: The `Game` class requires `Card` objects and `Hand` objects (among several others).
    We've shown that the abstract `Card` objects are contained within the abstract
    `Hand` collection. Each implementation provides some unique features. For the
    most part, the `PokerCard` matches the generic `Card` definition. The `PokerHand`
    class, however, extends the `Hand` abstract base class with all the unique rules
    for defining the rank of the hand. Poker players know that there are a very, very
    large number of Poker game variants. We've shown a hand containing five cards
    because this seems to be a common feature of many games.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类需要 `Card` 对象和 `Hand` 对象（以及其他几个对象）。我们已经展示了抽象的 `Card` 对象包含在抽象的 `Hand`
    集合中。每个实现都提供了一些独特的功能。大部分情况下，`PokerCard` 与通用的 `Card` 定义相匹配。然而，`PokerHand` 类却扩展了
    `Hand` 抽象基类，包含了定义手牌等级的所有独特规则。扑克玩家知道扑克游戏变体非常多。我们展示了包含五张牌的手牌，因为这似乎是许多游戏的一个共同特征。'
- en: The Cribbage implementation introduces a number of types of `CribbageCard` subclasses,
    each of which has an additional attribute, points. The `CribbageFace` cards are
    all worth 10 points, while for the other kinds of `CribbageCard` classes the number
    of points matches the rank. The `CribbageHand` class extends the abstract base
    class of `Hand` with the unique rules for finding all the scoring combinations
    in a hand. We can use an Abstract Factory to build `Card` and `Hand` objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Cribbage（克里比奇）的实现引入了多种`CribbageCard`子类，每个子类都有一个额外的属性，即点数。`CribbageFace`牌都值10点，而其他种类的`CribbageCard`类中点数与牌面等级相匹配。`CribbageHand`类通过具有在手中找到所有计分组合的独特规则的抽象基类`Hand`进行扩展。我们可以使用抽象工厂来构建`Card`和`Hand`对象。
- en: Here are the core definitions of `Hand` and `Card`. We didn't make these official
    abstract base classes. Python doesn't require this, and the extra complexity didn't
    seem helpful.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`手`和`牌`的核心定义。我们没有创建这些官方的抽象基类。Python 不需要这些，额外的复杂性看起来也没有什么帮助。
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These seem to capture the essence of "card" and "hand of cards." We''ll need
    to extend these with subclasses that pertain to each game. We''ll also need an
    Abstract Factory that creates cards and hands for us:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些似乎捕捉了“牌”和“牌手”的本质。我们需要通过子类扩展这些，以适应每个游戏。我们还需要一个抽象工厂来为我们创建牌和牌手：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've made the factory an actual abstract base class. Each individual game needs
    to provide extensions for the game's unique features of `Hand` and `Card`. The
    game will also provide an implementation of the `CardGameFactory` class that can
    build the expected classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将工厂类设计成了一个实际的抽象基类。每个单独的游戏都需要为游戏的独特特性“手牌”和“牌”提供扩展。游戏还将提供一个`CardGameFactory`类的实现，该实现可以构建预期的类。
- en: 'We can define the cards for cribbage like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义克里比奇牌戏的牌：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These extensions to the base `Card` class all have an additional points property.
    In Cribbage, one of the kinds of tricks is any combination of cards worth 15 points.
    Most cards have points equal to the rank, but the Jack, Queen, and King are all
    worth 10 points. This also means the Cribbage extension to `Hand` has a rather
    complex method for scoring, which we'll omit for now.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对基本 `Card` 类的扩展都包含一个额外的点数属性。在克里比奇牌戏中，一种技巧类型是任何点数为15的牌的组合。大多数牌的点数等于其花色等级，但杰克、王后和国王都值10点。这也意味着对
    `Hand` 的克里比奇扩展有一个相当复杂的计分方法，我们现在将省略。
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To provide some uniformity between the games, we've designated the scoring combinations
    in Cribbage and the rank of the hand in Poker as a subclass of "Trick." In Cribbage,
    there's a fairly large number of point-scoring tricks. In Poker, on the other
    hand, there's a single Trick that represents the hand as a whole. Tricks don't
    seem to be a place where an Abstract Factory is useful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏之间提供一些统一性，我们将Cribbage中的计分组合和Poker中的手牌等级定义为“回合”的子类。在Cribbage中，有相当多的计分回合。而在Poker中，则有一个代表整个手牌的单一回合。回合似乎不是一个抽象工厂能发挥作用的地方。
- en: The computation of the various scoring combinations in Cribbage is a rather
    sophisticated problem. It involves looking at all possible combinations of cards
    that total to 15 points, among other things. These details are unrelated to the
    Abstract Factory design pattern.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 克里比奇牌计算各种得分组合是一个相当复杂的问题。它涉及到查看所有可能的牌的组合，这些组合的总分为15点，以及其他方面。这些细节与抽象工厂设计模式无关。
- en: 'The Poker variant has its own unique complication: Aces are a higher rank than
    the King:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 德州扑克变体有其独特的复杂性：Aces（王牌）的等级高于King（国王）：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ranking the various hands in poker is also a rather sophisticated problem,
    but outside the Abstract Factory realm. Here''s the concrete factory that builds
    hands and cards for Poker:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对扑克牌的各种手牌进行排名也是一个相当复杂的问题，但这个问题并不属于抽象工厂的范畴。下面是具体工厂构建扑克牌手牌和牌的示例：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the way the `make_card()` method reflects the way Aces work in Poker. Having
    the Ace outrank the King reflects a common complication in a number of card games;
    we need to reflect the various ways Aces work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`make_card()`方法如何反映了扑克牌中A牌的工作方式。A牌高于K牌反映了众多纸牌游戏中常见的复杂情况；我们需要反映A牌的各种工作方式。
- en: 'Here''s a test case for how Cribbage works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于克里比奇游戏如何进行的测试案例：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ve created an instance of the `CribbageFactory` class, a concrete implementation
    of the abstract `CardGameFactory` class. We can use the factory to create some
    cards, and we can also use the factory to create a hand of cards. When playing
    Cribbage, an additional card is flipped, called the "starter." In this case, our
    hand is four cards in sequence, and the starter happens to fit with that sequence.
    We can score the hand and see that there are three scoring combinations: there
    are two ways to make 15 points, plus a run of five cards.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`CribbageFactory`类的实例，这是抽象类`CardGameFactory`的一个具体实现。我们可以使用这个工厂来创建一些牌，同时也可以用它来创建一副牌。在玩克里比奇牌戏时，会额外翻出一张牌，称为“起始牌”。在这种情况下，我们的手牌是按顺序的四张牌，而起始牌恰好与这个顺序相匹配。我们可以计算手牌的分数，并看到有三个得分组合：有两种方式可以凑出15分，再加上一个五张牌的顺子。
- en: This design provides some hints toward what needs to be done when we want to
    add support for more games. Introducing new rules means creating the new `Hand`
    and `Card` subclasses and extending the Abstract Factory class definition, also.
    Of course, inheritance leads to the opportunity for reuse, something we can capitalize
    on to create families of games with similar rules.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计提供了一些提示，关于当我们想要添加更多游戏支持时需要做什么。引入新规则意味着需要创建新的`Hand`和`Card`子类，同时也需要扩展抽象工厂类的定义。当然，继承带来了复用的机会，这是我们能够利用来创建具有相似规则的游戏家族的方法。
- en: Abstract Factories in Python
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的抽象工厂
- en: 'The previous example highlights an interesting consequence of the way Python''s
    duck typing works. Do we really need the abstract base class, `CardGameFactory?`
    It provides a framework used for type checking, but otherwise doesn''t have any
    useful features. Since we don''t really need it, we can think of this design as
    having three parallel modules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子突出了 Python 鸭式类型检查方式的一个有趣后果。我们真的需要这个抽象基类 `CardGameFactory` 吗？它提供了一个用于类型检查的框架，但除此之外并没有任何有用的功能。由于我们实际上并不需要它，我们可以将这种设计视为有三个并行模块：
- en: '![](img/B17070_12_08.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_08.png)'
- en: 'Figure 12.8: Abstract Factory without abstract base classes'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：无抽象基类的抽象工厂
- en: 'Both of the defined games implement a class, `CardGameFactory`, that defines
    the unique features of the game. Because these are in separate modules, we can
    use the same name for each class. This lets us write a Cribbage application that
    uses `from cribbage import CardGameFactory`. This skips past the overhead of a
    common abstract base class and lets us provide extensions as separate modules
    sharing some common base class definitions. Each alternative implementation also
    provides a common module-level interface: they expose a standard class name that
    handles the remaining details of creating unique objects.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 两个定义的游戏都实现了一个名为 `CardGameFactory` 的类，该类定义了游戏独特的功能。因为这些功能在独立的模块中，我们可以为每个类使用相同的名称。这使得我们能够编写一个使用
    `from cribbage import CardGameFactory` 的克瑞比奇应用程序。这跳过了公共抽象基类的开销，并允许我们通过共享一些公共基类定义的模块来提供扩展。每个替代实现还提供了一个公共模块级接口：它们公开了一个标准类名，用于处理创建独特对象的剩余细节。
- en: 'In this case, the Abstract Factory becomes a concept, and is not implemented
    as an actual abstract base class. We''ll need to provide adequate documentation
    in the docstrings for all classes that purport to be `CardGameFactory` implementations.
    We can clarify our intentions by defining a protocol using `typing.Protocol`.
    It could look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，抽象工厂只是一个概念，并不是作为一个实际的抽象基类来实现的。我们需要为所有声称是 `CardGameFactory` 实现的类提供充分的文档说明。我们可以通过定义一个使用
    `typing.Protocol` 的协议来明确我们的意图。它可能看起来像这样：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This definition allows **mypy** to confirm that a `Game` class can refer to
    either a `poker.CardGameFactory` or a `cribbage.CardGameFactory` because both
    implement the same protocol. Unlike the abstract base class definition, this is
    not a runtime check. A protocol definition is only used by **mypy** to confirm
    that the code is likely to pass its unit test suite.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义允许 **mypy** 确认 `Game` 类可以引用 `poker.CardGameFactory` 或 `cribbage.CardGameFactory`，因为两者都实现了相同的协议。与抽象基类定义不同，这并不是一个运行时检查。协议定义仅由
    **mypy** 用于确认代码可能通过其单元测试套件。
- en: The Abstract Factory pattern helps us define related families of objects, for
    instance, playing cards and hands. A single factory can produce two separate classes
    of objects that are closely related. In some cases, the relationships aren't a
    simple collection and item. Sometimes there are sub-collections in addition to
    items. These kinds of structures can be handled using the Composite design pattern.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式帮助我们定义相关对象家族，例如，扑克牌和手牌。单个工厂可以生产两个紧密相关的独立类对象。在某些情况下，这些关系不仅仅是集合和项目。有时除了项目外，还有子集合。这类结构可以使用组合设计模式来处理。
- en: The Composite pattern
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The Composite pattern allows complex tree structures to be built from simple
    components, often called **nodes**. A node with children will behave like a container;
    a node without children will behave like a single object. A composite object is
    – generally – a container object, where the content may be another composite object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许从简单的组件（通常称为**节点**）构建复杂的树结构。带有子节点的节点将表现得像一个容器；没有子节点的节点将表现得像一个单一的对象。组合对象通常是一个容器对象，其中内容可能又是另一个组合对象。
- en: 'Traditionally, each node in a composite object must be either a **leaf** node
    (that cannot contain other objects) or a **composite** node. The key is that both
    composite and leaf nodes can have the same interface. The following UML diagram shows
    this elegant parallelism as a `some_action()` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，复合对象中的每个节点必须是**叶节点**（不能包含其他对象）或**复合节点**。关键在于复合节点和叶节点可以拥有相同的接口。下面的UML图展示了这种优雅的并行性，通过`some_action()`方法表示：
- en: '![](img/B17070_12_09.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_09.png)'
- en: 'Figure 12.9: The Composite pattern'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：组合模式
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. The following diagram
    depicts a concrete instance of such a complicated arrangement:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个简单的模式使我们能够创建复杂元素排列，所有这些排列都满足组件对象接口。以下图表展示了一个此类复杂排列的具体实例：
- en: '![](img/B17070_12_10.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_10.png)'
- en: 'Figure 12.10: A large Composite pattern'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：一个大型组合模式
- en: The Composite pattern applies to language processing. Both natural languages
    and artificial languages (like Python) tend to follow rules that are hierarchical
    and fit nicely with the Composite design pattern. Markup languages, like HTML,
    XML, RST, and Markdown, tend to reflect some common composite concepts like lists
    of lists, and headers with sub-headings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式适用于语言处理。自然语言和人工语言（如Python）都倾向于遵循层次化的规则，并且很好地与组合设计模式相匹配。标记语言，如HTML、XML、RST和Markdown，往往反映了某些常见的组合概念，例如列表中的列表和带有子标题的标题。
- en: A programming language involves recursive tree structures. The Python standard
    library includes the `ast` module, which provides the classes that define the
    structure of Python code. We can use this module to examine Python code without
    resorting to regular expressions or other hard-to-get-correct text processing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言涉及递归树结构。Python标准库中包含了`ast`模块，该模块提供了定义Python代码结构的类。我们可以使用这个模块来检查Python代码，而无需求助于正则表达式或其他难以正确处理的文本处理方法。
- en: A Composite example
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个综合示例
- en: The Composite pattern needs to be applied to tree structures like the files
    and folders of a file system. Regardless of whether a node in the tree is an ordinary
    data file or a folder, it is still subject to operations such as moving, copying,
    or deleting the node. We can create a component interface that supports these
    operations, and then use a composite object to represent folders, and leaf nodes
    to represent data files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式需要应用于像文件系统中的文件和文件夹这样的树结构。无论树中的节点是普通数据文件还是文件夹，它都仍然要受到移动、复制或删除节点等操作的影响。我们可以创建一个支持这些操作的组件接口，然后使用组合对象来表示文件夹，以及使用叶节点来表示数据文件。
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们再次可以利用鸭子类型来隐式提供接口，因此我们只需要编写两个类。让我们首先在以下代码中定义这些接口：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For each `Folder`, a composite object, we maintain a dictionary of children.
    The children may be a mixture of `Folder` and `File` instances. For many composite
    implementations, a list is sufficient, but in this case, a dictionary will be
    useful for looking up children by name.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个复合对象`Folder`，我们维护一个子对象的字典。子对象可能包括`Folder`和`File`实例的混合。对于许多复合实现，列表就足够了，但在这个情况下，使用字典通过名称查找子对象将会很有用。
- en: 'Thinking about the methods involved, there are several patterns:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到涉及的方法，存在几种模式：
- en: For doing a move, relocating the `Folder` will carry along all the children.
    Relocating a `File` will turn out to be precisely the same code because we don't
    need to consider the children.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行移动操作时，移动`文件夹`会将其所有子项一同移动。移动`文件`的结果将与上述代码完全相同，因为我们不需要考虑子项。
- en: For doing a copy, we'll need to copy all of the children. Since there's no data
    outside the `File` nodes of the composite object, we don't need to do anything
    more.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行复制，我们需要复制所有的子节点。由于复合对象的外部没有`File`节点之外的数据，我们不需要做更多的事情。
- en: For a delete, we should follow the Linux pattern of clearing out the children
    before trying to remove a parent.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于删除操作，我们应该遵循Linux模式，在尝试移除父节点之前先清除子节点。
- en: This design lets us create subclasses with distinct operation implementations.
    Each subclass implementation could make external requests, or perhaps make OS
    requests on the local machine.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计使我们能够创建具有不同操作实现的子类。每个子类的实现可能进行外部请求，或者也许在本地机器上执行操作系统请求。
- en: 'To take advantage of the similar operations, we can extract the common methods
    into a parent class. Let''s refactor this to create a base class, `Node`, with
    the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用类似的操作，我们可以将公共方法提取到一个父类中。让我们重构一下，创建一个基类，`Node`，以下代码所示：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This abstract `Node` class defines that each node has a string with a reference
    to a parent. Keeping the parent information around lets us look "up" the tree
    toward the root node. This makes it possible to move and remove files by making
    a change to the parent's collection of children.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为 `Node` 的抽象类定义了每个节点都有一个字符串，用于引用其父节点。保留父节点信息使我们能够沿着树向上查看根节点。这使得通过更改父节点的子节点集合来移动和删除文件成为可能。
- en: We've created the `move()` method on the `Node` class. This works by reassigning
    a `Folder` or a `File` object to a new location. It follows up by removing the
    object from its previous location. For the `move()` method, the target should
    be an existing folder, or we'll get an error because a `File` instance doesn't
    have an `add_child()` method. As in many examples in technical books, error handling
    is woefully absent, to help focus on the principles under consideration. A common
    practice is to handle the `AttributeError` exception by raising a new `TypeError`
    exception. See *Chapter 4*, *Expecting the Unexpected*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Node`类中创建了`move()`方法。这个方法通过将`Folder`或`File`对象重新分配到新位置来实现。随后，它会从其原始位置删除该对象。对于`move()`方法，目标应该是一个已存在的文件夹，否则我们会得到一个错误，因为`File`实例没有`add_child()`方法。正如技术书籍中的许多例子一样，错误处理严重缺失，以帮助集中关注正在考虑的原则。一种常见的做法是通过引发一个新的`TypeError`异常来处理`AttributeError`异常。参见*第4章*，*预料之外*。
- en: 'We can then extend this class to provide the unique features of a `Folder`
    that has children, and a `File`, which is the leaf node of the tree and has no
    children:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个类扩展以提供具有子项的`文件夹`的独特特性和作为树中叶节点的`文件`，它没有子项：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we add a child to a `Folder`, we'll do two things. First, we tell the child
    who their new parent is. This makes sure that each `Node` (except the root `Folder`
    instance) has a parent. Second, we'll drop the new `Node` into the folder's collection
    of children, if it doesn't already exist.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个孩子添加到`文件夹`中时，我们会做两件事。首先，我们告诉孩子他们的新父母是谁。这确保了每个`节点`（除了根`文件夹`实例）都有一个父节点。其次，如果新的`节点`尚未存在于文件夹的子节点集合中，我们将将其放入文件夹的子节点集合中。
- en: When we copy `Folder` objects around, we need to make sure all the children
    are copied. Each child could, in turn, be another `Folder`, with children. This
    recursive walk involves delegating the `copy()` operation to each sub-`Folder`
    within a `Folder` instance. The implementation for a `File` object, on the other
    hand, is simpler.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在复制 `Folder` 对象时，需要确保所有子对象都被复制。每个子对象可能本身又是一个带有子对象的 `Folder`。这种递归遍历涉及到将 `copy()`
    操作委托给 `Folder` 实例内的每个子 `Folder`。另一方面，对于 `File` 对象的实现则更为简单。
- en: The recursive design for removal is similar to the recursive copy. A `Folder`
    instance must first remove all of the children; this may involve removing sub-`Folder`
    instances. A `File` object, on the other hand, can be directly removed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 删除的递归设计类似于递归复制。一个`Folder`实例必须首先删除所有子项；这可能包括删除子`Folder`实例。另一方面，`File`对象可以直接删除。
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working properly
    with the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单。让我们看看以下代码片段是否能够正确地工作我们的组合文件层次结构：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The value of `tree` can be a little difficult to visualize. Here's a variation
    on the display that can help.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`的值可能有点难以可视化。这里有一个显示方式的变体，可以帮助理解。'
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We didn''t cover the algorithm for producing this nested visualization. It''s
    not too difficult to add to the class definitions. We can see that the parent
    folder, `Tree`, has a sub-folder, `src`, with two files inside it. We can describe
    a filesystem operation like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖生成这种嵌套可视化的算法。将其添加到类定义中并不太难。我们可以看到父文件夹`Tree`下有一个子文件夹`src`，里面包含两个文件。我们可以这样描述文件系统操作：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ve created a new folder, `tests`, and moved the file. Here''s another view
    of the resulting composite objects:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的文件夹，`tests`，并将文件移动了。以下是结果组合对象的另一种视图：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. Sometimes, if only a shallow tree is being created, we can get away with
    a list of lists or a dictionary of dictionaries, and do not need to implement
    custom component, leaf, and composite classes. Indeed, JSON, YAML, and TOML documents
    often follow the dict-of-dict pattern. While we often use abstract base classes
    for this, it isn't required; Python's duck typing can make it easy to add other
    objects to a composite hierarchy, as long as they have the correct interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式对于各种树形结构极为有用，包括GUI小部件层次结构、文件层次结构、树集、图和HTML DOM。有时，如果只创建一个浅层树，我们可以用列表的列表或字典的字典来应付，而不需要实现自定义的组件、叶子和组合类。实际上，JSON、YAML和TOML文档通常遵循字典的字典模式。虽然我们通常使用抽象基类来处理这种情况，但这并不是必需的；Python的鸭子类型可以使得向组合层次结构添加其他对象变得容易，只要它们具有正确的接口。
- en: One of the important aspects of the Composite pattern is a common interface
    for the various subtypes of a node. We needed two implementation variants for
    `Folder` and `File` classes. In some cases, these operations are similar, and
    it can help to offer a template implementation of a complex method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式的其中一个重要方面是节点各种子类型的一个公共接口。我们需要为`Folder`和`File`类提供两种实现变体。在某些情况下，这些操作是相似的，提供一个复杂方法的模板实现可能会有所帮助。
- en: The Template pattern
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模式
- en: 'The Template pattern (sometimes called the Template method) is useful for removing
    duplicate code; it''s intended to support the **Don''t Repeat Yourself** principle
    we discussed in *Chapter 5*, *When to Use Object-Oriented Programming*. It is
    designed for situations where we have several different tasks to accomplish that
    have some, but not all, steps in common. The common steps are implemented in a
    base class, and the distinct steps are overridden in subclasses to provide custom
    behavior. In some ways, it''s like the Strategy pattern, except similar sections
    of the algorithms are shared using a base class. Here it is in the UML format:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式（有时称为模板方法）对于去除重复代码非常有用；它的目的是支持我们在第5章“何时使用面向对象编程”中讨论的**“不要重复自己”**原则。它适用于我们有许多不同的任务需要完成，这些任务有一些但不是所有步骤是共同的情况。共同的步骤在基类中实现，而不同的步骤在子类中被覆盖以提供自定义行为。在某种程度上，它类似于策略模式，除了算法的相似部分是通过基类共享的。以下是它的UML格式表示：
- en: '![](img/B17070_12_11.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_11.png)'
- en: 'Figure 12.11: The Template pattern'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：模板模式
- en: A Template example
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板示例
- en: Let's create a car sales reporter as an example. We can store records of sales
    in an SQLite database table. SQLite is the built-in database engine that allows
    us to store records using SQL syntax. Python includes SQLite in its standard library,
    so there are no extra modules to install.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个汽车销售报告员为例。我们可以在 SQLite 数据库表中存储销售记录。SQLite 是一个内置的数据库引擎，它允许我们使用 SQL 语法来存储记录。Python
    将 SQLite 包含在其标准库中，因此无需安装额外的模块。
- en: 'We have two common tasks we need to perform:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个常见的任务需要执行：
- en: Select all sales of new vehicles and output them to the screen in a comma-delimited
    format
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所有新车销售记录并以逗号分隔的格式输出到屏幕上
- en: Output a comma-delimited list of all salespeople with their gross sales and
    save it to a file that can be imported to a spreadsheet
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出所有销售人员的销售额列表，以逗号分隔，并将其保存到可以导入电子表格的文件中
- en: 'These seem like quite different tasks, but they have some common features.
    In both cases, we need to perform the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务看起来相当不同，但它们有一些共同特征。在两种情况下，我们需要执行以下步骤：
- en: Connect to the database
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Construct a query for new vehicles or gross sales
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建针对新车或总销售额的查询
- en: Issue the query
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出查询
- en: Format the results into a comma-delimited string
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果格式化为逗号分隔的字符串
- en: Output the data to a file or email
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据输出到文件或电子邮件
- en: The query construction and output steps are different for the two tasks, but
    the remaining steps are identical. We can use the Template pattern to put the
    common steps in a base class, and the varying steps in two subclasses.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 两个任务的查询构建和输出步骤不同，但剩余步骤是相同的。我们可以使用模板模式将公共步骤放在一个基类中，而将不同的步骤放在两个子类中。
- en: 'Before we start, let''s create a database and put some sample data in it, using
    a few lines of SQL:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们使用几行SQL语句创建一个数据库并将一些样本数据放入其中：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Hopefully, you can see what's going on here even if you don't know SQL; we've
    created a table named `Sales` to hold the data, and used six `insert` statements
    to add sales records. The data is stored in a file named `sales.db`. Now we have
    a sample database with a table we can work with in developing our Template pattern.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 希望即使你不了解 SQL，你也能看懂这里的情况；我们创建了一个名为 `Sales` 的表来存储数据，并使用了六个 `insert` 语句来添加销售记录。数据存储在一个名为
    `sales.db` 的文件中。现在我们有一个包含可以用于开发我们的模板模式的表的示例数据库。
- en: 'Since we''ve already outlined the steps that the template has to perform, we
    can start by defining the base class that contains the steps. Each step gets its
    own method (to make it easy to selectively override any one step), and we have
    one more managerial method that calls the steps in turn. Without any method content,
    here''s how the class might look as a first step toward completion:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经概述了模板必须执行的步骤，我们可以从定义包含这些步骤的基本类开始。每个步骤都拥有自己的方法（以便可以单独覆盖任何一步），我们还有一个管理方法，它会依次调用这些步骤。在没有方法内容的情况下，这个类在完成的第一步可能看起来是这样的：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `process_format()` method is the primary method to be called by an outside
    client. It ensures each step is executed in order, but it does not care whether
    that step is implemented in this class or in a subclass. For our examples, we
    expect the `construct_query()` and the `output_context()` methods are likely to
    change.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_format()` 方法是外部客户端需要调用的主要方法。它确保每个步骤按顺序执行，但它并不关心该步骤是在此类中实现还是在子类中实现。对于我们的示例，我们预计
    `construct_query()` 和 `output_context()` 方法可能会发生变化。'
- en: In Python, we can formalize our expectation by using an abstract base class.
    An alternative is to raise a `NotImplementedError` exception for the missing method
    in the template. This will provide a runtime check if we subclass the `QueryTemplate`
    and – perhaps – misspell the name of our attempted override of the `construct_query()`
    method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过使用抽象基类来形式化我们的期望。另一种选择是在模板中为缺失的方法抛出`NotImplementedError`异常。如果我们从`QueryTemplate`派生子类，并且——也许——拼写错误地尝试覆盖`construct_query()`方法，这将提供一个运行时检查。
- en: 'The remaining methods are going to be identical between our two classes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的方法将在我们两个班级之间保持一致：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is a kind of abstract class. It doesn''t use a formal abstract base class;
    instead, the two methods we expect to update show two distinct approaches to providing
    an abstract definition:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种抽象类。它不使用正式的抽象基类；相反，我们期望更新的两种方法展示了提供抽象定义的两种不同的方法：
- en: The `construct_query()` method must be overridden. The method definition base
    class raises the `NotImplementedError` exception. This is an alternative for creating
    an abstract interface in Python. Raising `NotImplementedError` helps the programmer
    understand that the class is meant to be subclassed and these methods overridden.
    It can be described as "smuggling in an abstract base class without being explicit"
    in the `class` definition and without using `@abc.abstracmethod` decorators.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`construct_query()` 方法必须被重写。基类中的方法定义会引发 `NotImplementedError` 异常。这在 Python
    中是创建抽象接口的一种替代方法。引发 `NotImplementedError` 有助于程序员理解该类旨在被继承并重写这些方法。这可以描述为在 `class`
    定义中“隐性地引入抽象基类”，而不使用 `@abc.abstractmethod` 装饰器。'
- en: The `output_context()` method may be overridden. There's a default implementation
    provided that sets the `self.target_file` instance variable and also returns a
    context value. The default uses `sys.stdout` as the output file and a null context
    manager.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output_context()` 方法可以被重写。提供了一个默认实现，该实现设置了 `self.target_file` 实例变量，并返回一个上下文值。默认情况下使用
    `sys.stdout` 作为输出文件，并使用一个空上下文管理器。'
- en: Now we have a template class that takes care of the boring details, but is flexible
    enough to allow the execution and formatting of a wide variety of queries. The
    best part is, if we ever want to change our database engine from SQLite to another
    database engine (such as `py-postgresql`), we only have to do it here, in this
    template class, and we don't have to touch the two (or two hundred) subclasses
    we might have written.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模板类，它负责处理那些繁琐的细节，同时足够灵活，允许执行和格式化各种查询。最好的部分是，如果我们将来想要将我们的数据库引擎从SQLite更改为其他数据库引擎（例如`py-postgresql`），我们只需在这里，在这个模板类中操作，而无需触及我们可能编写的两个（或两百个）子类。
- en: 'Let''s have a look at the concrete classes now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看具体的类：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These two classes are actually pretty short, considering what they''re doing:
    connecting to a database, executing a query, formatting the results, and outputting
    them. The superclass takes care of the repetitive work, but lets us easily specify
    those steps that vary between tasks. Further, we can also easily change steps
    that are provided in the base class. For example, if we wanted to output something
    other than a comma-delimited string (for example, an HTML report to be uploaded
    to a website), we can still override the `output_results()` method.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类实际上相当简短，考虑到它们所做的事情：连接数据库、执行查询、格式化结果以及输出它们。超类负责处理重复性工作，但允许我们轻松指定不同任务之间有所不同的步骤。此外，我们还可以轻松更改基类中提供的一些步骤。例如，如果我们想输出除了逗号分隔的字符串之外的内容（例如，要上传到网站的HTML报告），我们仍然可以覆盖`output_results()`方法。
- en: Case study
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: The previous chapters of the case study have contained a number of design patterns.
    We'll pick a variation on the model and walk through some of the patterns from
    this chapter and how they were applied.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究的前几章包含了许多设计模式。我们将选择模型的一个变体，并介绍本章中的一些模式及其应用方式。
- en: 'Here''s an overview of several parts of the application''s classes. This is
    from the case study in *Chapter 7*, *Python Data Structures*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用类几个部分的概述。这来自第七章的案例研究，*《Python 数据结构》*：
- en: '![](img/B17070_12_12.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_12_12.png)'
- en: 'Figure 12.12: The case study Logical view'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：案例研究逻辑视图
- en: This involves a number of patterns we've seen in this chapter. We'll start with
    the `Hyperparameter` class, which is a Façade that includes two separate complex
    components, the classifier algorithm and the training data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到本章中我们看到的许多模式。我们将从`Hyperparameter`类开始，它是一个包含两个独立复杂组件的Façade，即分类算法和训练数据。
- en: 'First, we''ll look at the classifier algorithm. In *Chapter 10*, *The Iterator
    Pattern*, we saw how the classifier is itself a complex structure. We looked at
    three alternatives: `k_nn_1()`, which had a naïve sort, `k_nn_b()`, which used
    bisection, and `k_nn_q()`, which used a heap queue. This exploration relied on
    several design patterns from this chapter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨分类器算法。在*第10章*，*迭代器模式*中，我们了解到分类器本身就是一个复杂的结构。我们考察了三种替代方案：`k_nn_1()`，它采用了简单的排序，`k_nn_b()`，它使用了二分查找，以及`k_nn_q()`，它使用了堆队列。这次探索依赖于本章中提到的几个设计模式：
- en: The classifier depends on the Strategy design pattern to incorporate one of
    the many distance computations. We defined a class, `Distance`, and made sure
    each distance computation was a subclass. The classifier algorithm was given the
    distance computation as a parameter.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类器依赖于策略设计模式来整合众多距离计算方法之一。我们定义了一个名为`Distance`的类，并确保每个距离计算都是一个子类。分类器算法被赋予了距离计算作为参数。
- en: The classifier is a Façade that provides a uniform interface for testing and
    evaluating a sample. Each variation on the classifier used a slightly different
    data structure for managing the collection of nearest neighbors. We don't want
    to sort a large training set; we only want to track the subset of nearest neighbors.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类器是一个门面，它提供了一个统一的接口用于测试和评估样本。分类器使用的每种变体都采用了稍微不同的数据结构来管理最近邻集合。我们不想对大量训练集进行排序；我们只想跟踪最近邻的子集。
- en: Throughout the previous chapters, we've made sure the training data leverages
    the Flyweight design pattern to avoid keeping multiple copies of the training
    data. The idea of wrapping each `Sample` object with a separate frozen dataclass
    to include known information about the sample is a kind of Flyweight design, also.
    More fundamentally, it is an example of the Composite pattern. The useable sample
    is a composite and avoids keeping multiple copies of the underlying `KnownSample`
    objects in memory.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们确保训练数据利用了享元设计模式来避免保留多个训练数据副本。将每个`Sample`对象包裹在一个单独的冻结数据类中，以包含有关样本的已知信息，这也是一种享元设计。更根本的是，它是一个组合模式的例子。可用的样本是一个组合对象，避免了在内存中保留多个底层的`KnownSample`对象副本。
- en: 'Looking at the `TrainingData` class, we can see how this design also follows
    the Façade design pattern. A number of distinct operations have a uniform interface.
    There are two important parts:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`TrainingData`类，我们可以看到这种设计也遵循了外观设计模式。许多不同的操作具有统一的接口。这里有两个重要的部分：
- en: Loading raw `Sample` instances to partition them into training and testing subsets.
    The various data formats described in *Chapter 9*, *Strings, Serialization, and
    File Paths*, can be seen as complex algorithms that are simplified by a uniform
    Façade. The choice of algorithm to partition the initial set of samples into a
    training set and a testing set is, similarly, an application of the Strategy design
    pattern. This lets us change the ratio of samples used for training and testing
    using a different implementation from a strategy class hierarchy.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始`Sample`实例加载以将它们划分为训练集和测试集。*第9章*中描述的各种数据格式，如字符串、序列化和文件路径，可以被视为通过统一的外观（Façade）简化的复杂算法。将初始样本集划分为训练集和测试集的算法选择，同样也是策略设计模式的应用。这使得我们可以通过从策略类层次结构的不同实现中更改用于训练和测试的样本比例。
- en: Keeping the testing and training sets to be used for hyperparameter tuning is
    done by partitioning the raw data into two disjoint lists.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用于超参数调整的测试集和训练集保持分离，是通过将原始数据划分为两个互斥的列表来实现的。
- en: The idea of creating `TrainingKnownSample` or `TestingKnownSample` instances
    is an example of the Abstract Factory pattern. The partitioning algorithm can
    be described by an Abstract Factory class definition. Each partitioning algorithm
    becomes a concrete factory that creates different mixtures of training and testing
    objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`TrainingKnownSample`或`TestingKnownSample`实例的想法是抽象工厂模式的一个例子。分区算法可以通过一个抽象工厂类的定义来描述。每个分区算法都成为一个具体的工厂，它创建不同的训练和测试对象的混合体。
- en: 'In *Chapter 11*, *Common Design Patterns*, we looked closely at the hyperparameter
    tuning process. The *k*-nearest neighbors algorithm depends on two parameters,
    called hyperparameters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*常见设计模式*中，我们详细探讨了超参数调整过程。*k*最近邻算法依赖于两个参数，称为超参数：
- en: The algorithm used to compute the distances between samples.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算样本之间距离的算法。
- en: The number of samples, *k*, used. The most common of the *k* nearest neighbors
    becomes the label assigned to the unknown sample. If the value for *k* is odd,
    we can avoid an even split between two choices, ensuring there's always a winner.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的样本数量，*k*。最常见的是将*k*个最近邻中的最接近的一个作为分配给未知样本的标签。如果*k*的值是奇数，我们可以避免两个选择之间的平分，确保总有一个赢家。
- en: 'In *Chapter 11*, the tuning algorithm shown is not particularly speedy but
    is patiently thorough: the grid search algorithm. In that chapter, we used the
    Command design pattern to enumerate various combinations of *k* and distance computations.
    Each combination was a command that – when executed – provided quality and timing
    information.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*中，展示的调谐算法并不特别快速，但非常耐心且全面：网格搜索算法。在第11章中，我们使用了命令设计模式来列举各种*k*和距离计算的组合。每个组合都是一个命令，当执行时，提供质量和时间信息。
- en: 'There were three major phases of work involved in the application, as a whole.
    These were presented in *Chapter 1*, *Object-Oriented Design*, as the various
    use cases:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用过程中涉及了三个主要工作阶段。这些阶段在*第一章*，*面向对象设计*中作为各种用例进行了阐述：
- en: A Botanist provides training data
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 植物学家提供训练数据
- en: A Botanist uses hyperparameter tuning to locate an optimal model
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 植物学家使用超参数调优来定位一个最优模型
- en: Users make use of this to classify their unknown samples
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户利用此方法对他们的未知样本进行分类
- en: 'This pattern of work suggests the Template design pattern may be required to
    ensure that classes like the `TrainingData` class and the overall application
    work consistently. Currently, it doesn''t seem like a carefully designed class
    hierarchy is needed. When we review *Chapter 1*, however, the initial intent was
    to use this example to learn more about classifiers, and eventually extend this
    from the simple example of classifying iris species to more complex real-world
    problems. This follows what''s called "the telescope rule":'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作模式表明，可能需要模板设计模式来确保像`TrainingData`类这样的类以及整个应用程序能够一致地工作。目前，似乎不需要精心设计的类层次结构。然而，当我们回顾*第一章*时，最初的意图是利用这个例子来了解更多关于分类器的知识，并最终将这个例子从简单的鸢尾花物种分类扩展到更复杂的现实世界问题。这遵循了所谓的“望远镜规则”：
- en: 'Thomson''s Rule for First-Time Telescope Makers: "It is faster to make a four-inch
    mirror then a six-inch mirror than to make a six-inch mirror."'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 汤姆森给初学望远镜制作者的规则：“制作一个四英寸的镜子比制作一个六英寸的镜子要快。”
- en: -- Programming Pearls, Communications of the ACM, September 1985
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- 编程珠玑，ACM通讯，1985年9月
- en: The intent behind the problem is to build something workable, using a variety
    of design patterns. The various components can then be replaced, revised, and
    expanded to tackle larger and more complex problems. The telescope maker will
    learn a lot about telescopes from making their first mirror, and those lessons
    can be applied to making their next, more useful telescope. A similar pattern
    of learning applies to software and object-oriented design. If the various components
    are designed well and follow established patterns, then the changes to improve
    and expand are not damaging or disruptive.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 题目背后的意图是构建一个可工作的系统，使用各种设计模式。然后，各种组件可以被替换、修订和扩展，以应对更大和更复杂的问题。望远镜制造商在制作他们的第一个镜片时，将从望远镜的制作中学到很多知识，而这些经验可以应用于制作下一个更有用的望远镜。类似的
    学习模式也适用于软件和面向对象的设计。如果各个组件设计良好并遵循既定模式，那么对改进和扩展所做的更改就不会造成损害或破坏。
- en: Recall
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Often, we''ll spot really good ideas that are repeated; the repetition can
    form a recognizable pattern. Exploiting a pattern-based approach to software design
    can save the developer from wasting time trying to reinvent something already
    well understood. In this chapter, we looked at a few more advanced design patterns:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会发现一些真正优秀的想法被反复提及；这种重复可以形成一种可识别的模式。利用基于模式的软件设计方法可以帮助开发者避免浪费时间尝试重新发明已经非常清楚的东西。在本章中，我们探讨了几个更高级的设计模式：
- en: An Adapter class is a way to insert an intermediary so a client can make use
    of an existing class even when the class is not a perfect match. The software
    adapter parallels the idea of USB hardware adapters between various kinds of devices
    with various USB interface connectors.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器类是一种插入中介的方式，使得客户端即使现有类不是完美匹配，也能使用该类。软件适配器与各种具有不同USB接口连接器的设备之间的USB硬件适配器的理念相类似。
- en: The Façade pattern is a way to create a unified interface over a number of objects.
    The idea parallels the façade of a building that unifies separate floors, rooms,
    and halls into a single space.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式是一种在多个对象上创建统一接口的方法。这种想法与建筑外观相似，它将独立的楼层、房间和走廊统一成一个单一的空间。
- en: We can leverage the Flyweight pattern to implement a kind of lazy initialization.
    Instead of copying objects, we can design Flyweight classes that share a common
    pool of data, minimizing or avoiding initialization entirely.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用享元模式来实现一种懒加载初始化。而不是复制对象，我们可以设计享元类来共享一个公共的数据池，从而最小化或避免完全初始化。
- en: When we have closely related classes of objects, the Abstract Factory pattern
    can be used to build a class that can emit instances that will work together.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们拥有紧密相关的对象类时，可以使用抽象工厂模式来构建一个能够发出可以协同工作的实例的类。
- en: The Composition pattern is widely used for complex document types. It covers
    programming languages, natural languages, and markup languages, including XML
    and HTML. Even something like the filesystem with a hierarchy of directories and
    files fits this design pattern.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式在复杂文档类型中被广泛使用。它涵盖了编程语言、自然语言和标记语言，包括XML和HTML。甚至像具有目录和文件层次结构的文件系统也符合这种设计模式。
- en: When we have a number of similar, complex classes, it seems appropriate to create
    a class following the Template pattern. We can leave gaps or openings in the template
    into which we can inject any unique features.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们拥有许多相似且复杂的类时，似乎创建一个遵循模板模式的类是合适的。我们可以在模板中留下空隙或开口，以便我们可以注入任何独特的特性。
- en: These patterns can help a designer focus on accepted, good design practices.
    Each problem is, of course, unique, so the patterns must be adapted. It's often
    better to make an adaptation to a known pattern and avoid trying to invent something
    completely new.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式可以帮助设计师专注于被接受的良好设计实践。当然，每个问题都是独特的，因此模式必须进行适应。通常，对已知模式进行改编比尝试发明完全新的东西要好。
- en: Exercises
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Before diving into exercises for each design pattern, take a moment to add the
    `os` and `pathlib` calls to implement the methods for the `File` and `Folder` objects
    in the section on *The Composite pattern*. The `copy()` method on `File` will
    need to read and write the bytes of a file. The `copy()` method on `Folder` is
    quite a bit more complicated, as you first have to duplicate the folder, and then
    recursively copy each of its children to the new location. The examples we provided
    update the internal data structure, but don't apply changes to the operating system.
    Be careful about testing this in isolated directories. You don't want to accidentally
    destroy important files.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now, as in the previous chapter, look at the patterns we've discussed and consider
    ideal places where you might implement them. You may want to apply the Adapter
    pattern to existing code, as it is usually applicable when interfacing with existing
    libraries, rather than new code. How can you use an Adapter to force two interfaces
    to interact with each other correctly?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像上一章一样，看看我们讨论过的模式，并考虑你可能实施它们的地方。你可能想要将适配器模式应用于现有代码，因为它通常适用于与现有库接口，而不是新代码。你如何使用适配器来强制两个接口正确地相互交互？
- en: Can you think of a system complex enough to justify using the Façade pattern?
    Consider how façades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the façade interface are other programmers, rather than people
    trained to use it. Are there complex systems in your latest project that could
    benefit from the Façade pattern?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否想到一个足够复杂的系统来证明使用外观模式（Façade pattern）的合理性？考虑一下外观在实际生活中的应用，例如汽车的驾驶员界面，或者工厂的控制面板。在软件中，情况类似，只不过外观接口的使用者是其他程序员，而不是受过培训来使用它的人。在你的最新项目中，是否有复杂系统可以从外观模式中受益？
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the Flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a Flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does adopting the Flyweight pattern make sense?
    When is it overkill?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你没有任何庞大的、消耗内存的代码能够从享元模式中受益，但你能否想到一些可能有用的情况？任何需要处理大量重叠数据的地方，享元模式都在等待被使用。在银行业务中会有用吗？在Web应用中呢？在什么情况下采用享元模式是有意义的？什么时候又会过度使用呢？
- en: The Abstract Factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式，或者我们讨论过的稍微更Pythonic的衍生模式，在创建一键可配置的系统时可以非常实用。你能想到哪些地方这样的系统是有用的吗？
- en: The Composite pattern applies in a number of places. There are tree-like structures
    all around us in programming. Some of them, like our file hierarchy example, are
    blatant; others are fairly subtle. What situations might arise where the Composite
    pattern would be useful? Can you think of places where you can use it in your
    own code? What if you adapted the pattern slightly; for example, to contain different
    types of leaf or composite nodes for different types of objects?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式适用于许多场景。在编程中，我们周围到处都是树状结构。其中一些，比如我们的文件层次结构示例，非常明显；而另一些则相当微妙。在什么情况下组合模式可能会很有用？你能想到在你的代码中可以应用它的地方吗？如果你稍微调整一下模式；例如，为不同类型的对象包含不同类型的叶节点或组合节点，会怎样呢？
- en: The `ast` module provides a composite tree structure for Python code. A particularly
    useful thing is to use the `ast` module to locate all of the import statements
    in some code. This can help confirm that a project's list of required modules,
    often in a `requirements.txt` file, is complete and consistent.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`ast` 模块为 Python 代码提供了复合树结构。特别有用的一点是，可以使用 `ast` 模块来定位某些代码中的所有导入语句。这有助于确认一个项目的所需模块列表，通常在
    `requirements.txt` 文件中，是否完整且一致。'
- en: 'A Template method is helpful when decomposing a complex operation so it is
    open to extension. It appears that the *k*-nearest neighbors algorithm might be
    a good candidate for a Template method. In *Chapter 10*, *The Iterator Pattern*,
    we rewrote the *k*-nearest neighbors algorithm as three completely separate functions.
    Was this necessary? Could we have rewritten it into a method that decomposes the
    problem into three steps: computing distances, finding the *k*-nearest, and then
    finding the mode? Compare this design with doing it as separate functions; which
    do you find more expressive?'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The Adapter pattern is useful for matching interfaces, while the Façade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. Abstract Factories allow the runtime
    separation of implementations depending on configuration or system information.
    The Composite pattern is used universally for tree-like structures. A Template
    method can be helpful for breaking complex operations into steps to avoid repeating
    the common features.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: This is the last of the truly object-oriented design chapters in this book.
    In the next two chapters, we'll discuss how important it is to test Python programs,
    and how to do it, focusing on object-oriented principles. Then we'll look at the
    concurrency features of Python and how to exploit them to get work done more quickly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
