- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Façade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization and the Flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case study for this chapter will demonstrate how to apply a few of these
    patterns to the iris sample problem. In particular, we'll show how much of the
    design has been based – implicitly – on a number of these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consistent with the practice in *Design Patterns: Elements of Reusable Object-Oriented
    Software*, we''ll capitalize the pattern names.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin with the Adapter pattern. This is often used to provide a needed
    interface around an object with a design that doesn't – quite – fit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike most of the patterns we reviewed in the previous chapter, the Adapter
    pattern is designed to interact with existing code. We would not design a brand
    new set of objects that implement the Adapter pattern. Adapters are used to allow
    two preexisting objects to work together, even if their interfaces are not compatible.
    Like the display adapters that allow you to plug your Micro USB charging cable
    into a USB-C phone, an adapter object sits between two different interfaces, translating
    between them on the fly. The adapter object's sole purpose is to perform this
    translation. Adapting may entail a variety of tasks, such as converting arguments
    to a different format, rearranging the order of arguments, calling a differently
    named method, or supplying default arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In structure, the Adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. This is depicted in UML form in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Adapter pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a client object, an instance of **Client**,needs to collaborate with another
    class to do something useful. In this example, we're using `load_data()` as a
    concrete example of a method that requires an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have this perfect class, named **Implementation**, that does everything
    we want (and to avoid duplication, we don''t want to rewrite it!). This perfect
    class has one problem: it requires a complex sequence of operations using methods
    called `read_raw_data()`, `parse_raw_data()`, and `create_useful_object()`. The **Adapter** class
    implements an easy-to-use `load_data()` interface that hides the complexity of
    the existing interface provided by the **Implementation**.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this design is that the code that maps from the hoped-for interface
    to the actual interface is all in one place, the **Adapter** class. The alternative
    would require putting the code into the client, cluttering it up with possibly
    irrelevant implementation details. If we had multiple kinds of clients, we'd have
    to perform the complex `load_data()` processing in multiple places whenever any
    of those clients needed to access the `Implementation` class.
  prefs: []
  type: TYPE_NORMAL
- en: An Adapter example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine we have the following pre-existing class, which takes string timestamps
    in the format `HHMMSS` and calculates useful floating-point intervals from those
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class handles string to time-interval conversion. Since we have this class
    in the application already, it has unit test cases and works nicely. If you forget
    the `from __future__ import annotations`, you'll get an error trying to use `tuple[float,
    float, float]` as a type hint. Be sure to include the `annotations` module as
    the first line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example showing how this class works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working with these unformatted times is a little awkward, but a number of **Internet
    of Things** (**IoT**) devices provide these kinds of time strings, separated from
    the rest of the date. For example, look at the NMEA 0183 format messages from
    a GPS device, where dates and times are unformatted strings of digits.
  prefs: []
  type: TYPE_NORMAL
- en: We have an old log from one of these devices, apparently created years ago.
    We want to analyze this log for the sequence of messages that occur after each
    ERROR message. We'd like the exact times, relative to the ERROR, as part of our
    root cause problem analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some of the log data we''re using for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s difficult to compute the time interval between the ERROR and the WARNING
    message. It''s not impossible; many of us have enough fingers to do the computation.
    But it would be better to show the log with relative times instead of absolute
    times. Here''s an outline of the log formatter we''d like to use. This code, however,
    has a problem that we''ve marked with `???`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This `LogProcessor` class seems like the right thing to do. It iterates through
    the log entries, resetting the `first_time` variable on each occurrence of an
    ERROR line. This makes sure that the log shows offsets from the error, saving
    us from having to do a lot of math to work out exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we have a problem. We''d really like to reuse the `TimeSince` class. However,
    it doesn''t simply compute an interval between two values. We have several options
    to address this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: We could rewrite the `TimeSince` class to work with a pair of time strings.
    This runs a small risk of breaking something else in our application. We sometimes
    call this the **splash radius** of a change – how many other things get wet when
    we drop a boulder into the swimming pool? The Open/Closed design principle (one
    of the SOLID principles, which we discussed in the Chapter 4 case study; see [https://subscription.packtpub.com/book/application_development/9781788835831/4](https://subscription.packtpub.com/book/application_development/9781788835831/4)
    for more background) suggests a class should be open to extension but closed to
    this kind of modification. If this class was downloaded from PyPI, we may not
    want to change its internal structure because then we wouldn't be able to use
    any subsequent releases. We need an alternative to tinkering inside another class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use the class as it is, and whenever we want to calculate the intervals
    between an ERROR and subsequent log lines, we create a new `TimeSince` object.
    This is a lot of object creation. Imagine we have several log analysis applications,
    each looking at different aspects of the log messages. Making a change means having
    to go back and fix all of the places where these `TimeSince` objects were created.
    Cluttering up the `LogProcessor` class with details of how the `TimeSince` class
    works violates the Single Responsibility design principle. Another principle,
    **Don't Repeat Yourself** (**DRY**), seems to apply in this case, also.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, we can add an adapter that connects the needs of the `LogProcessor`
    class with the methods available from the `TimeSince` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Adapter solution introduces a class that offers the interface required
    by the `LogProcessor` class. It consumes the interface offered by the `TimeSince`
    class. It allows for independent evolution of the two classes, leaving them closed
    to modification, but open to extension. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This adapter creates a `TimeSince` object when it's needed. If there is no `TimeSince`,
    it has to create one. If there is an existing `TimeSince` object, and it uses
    the already established start time, the `TimeSince` instance can be reused. If,
    however, the `LogProcessor` class has shifted the focus of the analysis to a new
    error message, then a new `TimeSince` needs to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final design for the `LogProcessor` class, using the `IntervalAdapter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We created an `IntervalAdapter()` instance during initialization. Then we used
    this object to compute each time offset. This lets us reuse the existing `TimeSince`
    class without any modification to the original class, and it leaves the `LogProcessor`
    uncluttered by details of how `TimeSince` works.
  prefs: []
  type: TYPE_NORMAL
- en: We can also tackle this kind of design through inheritance. We could extend
    `TimeSince` to add the needed method to it. This inheritance alternative isn't
    a bad idea, and it illustrates the common situation where there's no single "right"
    answer. In some cases, we need to write out the inheritance solution and compare
    it with the adapter solution to see which one is easier to explain.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inheritance, we can sometimes also use monkey patching to add a method
    to an existing class. Python lets us add a new method that provides the adapted
    interface that is required by calling code. This means, of course, the easy-to-find
    class definition inside the `class` statement isn't the whole class being used
    at runtime. We force other developers to search the code base to find out where
    the new feature was monkey patched into the class. Outside unit testing, monkey
    patching is not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is often possible to use a function as an adapter. While this doesn''t obviously
    fit the traditional design of the Adapter class design pattern, it''s a distinction
    with little practical impact: a class with the `__call__()` method is a callable
    object, indistinguishable from a function. A function can be a perfectly good
    Adapter; Python doesn''t require everything be defined in classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between Adapter and Decorator is small but important. An Adapter
    often extends, modifies, or combines more than one method from the class(es) being
    adapted. A Decorator, however, generally avoids profound changes, keeping a similar
    interface for a given method, adding features incrementally. As we saw in *Chapter
    11*, *Common Design Patterns*, a Decorator should be viewed as a specialized kind
    of Adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Adapter class is a lot like using a Strategy class; the idea is that
    we might make changes, and need a different adapter someday. The principal difference
    is that Strategies are often chosen at runtime, where as an Adapter is a design-time
    choice and changes very slowly.
  prefs: []
  type: TYPE_NORMAL
- en: The next pattern we'll look at is similar to an Adapter, as it also wraps functionality
    inside a new container. The difference is the complexity of what is being wrapped;
    a Façade often contains considerably more complex structures.
  prefs: []
  type: TYPE_NORMAL
- en: The Façade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Façade pattern is designed to provide a simple interface to a complex system
    of components. It allows us to define a new class that encapsulates a typical
    usage of the system, thereby avoiding a design that exposes the many implementation
    details hiding among multiple object interactions. Any time we want access to
    common or typical functionality, we can use a single object's simplified interface.
    If another part of the project needs access to more complete functionality, it
    is still able to interact with the components and individual methods directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML diagram for the Façade pattern is really dependent on the subsystem,
    shown as a package, `Big System`, but in a cloudy way it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The Façade pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The Façade pattern is, in many ways, like the Adapter pattern. The primary difference
    is that a Façade tries to abstract a simpler interface out of a complex one, while
    an Adapter only tries to map one existing interface to another.
  prefs: []
  type: TYPE_NORMAL
- en: A Façade example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The images for this book were made with PlantUML ([https://plantuml.com](https://plantuml.com)).
    Each diagram starts as a text file and needs to be converted to the PNG file that's
    part of the text. This is a two-step process and we use a Façade pattern to combine
    the two processes.
  prefs: []
  type: TYPE_NORMAL
- en: The first part is locating all of the UML files. This is a walk through the
    directory tree finding all files with names ending in `.uml`. We also look inside
    the file to see if there are multiple diagrams named inside the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `FindUML` class requires a base directory. The `uml_file_iter()` method
    walks the entire directory tree, using the `Path.glob()` method. It skips over
    any directories with names that start with `.`; these are often used by tools
    like **tox**, **mypy**, or **git**, and we don't want to look inside these directories.
    The remaining files will have `@startuml` lines in them. Some will have a line
    that names multiple output files. Most of the UML files don't create multiple
    files. The `self.start_pattern` regular expression will capture the name, if one
    is provided. The iterator yields tuples with two paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separately, we have a class that runs the PlantUML application program as a
    subprocess. When Python is running, it''s an operating system process. We can,
    using the `subprocess` module, start child processes that run other binary applications
    or shell scripts. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `PlantUML` class depends on using **conda** to create a virtual environment
    named `CaseStudy`. If other virtual environment managers are used, a subclass
    can provide the needed path modifications. We'll need to install the Graphviz
    package into the named virtual environment; this renders the diagram as an image
    file. We also need to download the `plantuml.jar` file somewhere. We chose to
    put it into a `share` directory inside our virtual environment. The value of the
    `command` variable presumes the **Java Runtime Environment** (**JRE**) is properly
    installed and visible.
  prefs: []
  type: TYPE_NORMAL
- en: The `subprocess.run()` function accepts the command-line arguments and any special
    environment variables that need to be set. It will run the given command, with
    the given environment, and it will check the resulting return code to be sure
    the program ran properly.
  prefs: []
  type: TYPE_NORMAL
- en: Separately, we can use these steps to find all the UML files and create the
    diagrams. Because the interface is a bit awkward, a class that follows the Façade
    pattern helps create a useful command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `GenerateImages` class is a handy façade that combines features of the `FindUML`
    and the `PlantUML` classes. It uses the `FindUML.uml_file_iter()` method to locate
    source files and output image files. It checks the modification times of these
    files to avoid processing them if the image is newer than the source. (The `stat().st_mtime`
    is pretty obscure; it turns out the `stat()` method of a `Path` provides a lot
    of file status information, and the modification time is only one of many things
    we can find about a file.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `.uml` file is newer, it means one of the authors changed it, and the
    images need to be regenerated. The main script to do this is now delightfully
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example shows one of the important ways Python can be used to automate
    things. We broke the process into steps that we could implement in a few lines
    of code. Then we combined those steps, wrapping them in a Façade. Another, more
    complex application can use the Façade without worrying deeply about how it's
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is rarely mentioned by name in the Python community, the Façade
    pattern is an integral part of the Python ecosystem. Because Python emphasizes
    language readability, both the language and its libraries tend to provide easy-to-comprehend
    interfaces for complicated tasks. For example, `for` loops, `list` comprehensions,
    and generators are all façades into a more complicated iterator protocol. The `defaultdict` implementation
    is a façade that abstracts away annoying edge cases when a key doesn't exist in
    a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The third-party `requests` or `httpx` libraries are both powerful façades over
    less readable `urllib` libraries for HTTP processing. The `urllib` package itself
    is a façade over managing the text-based HTTP protocol using the underlying `socket`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: A Façade conceals complexity. Sometimes, we want to avoid duplicating data.
    The next design pattern can help optimize storage when working with large volumes
    of data. It's particularly helpful on very small computers, typical for Internet
    of Things applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of it. Relying on the built-in memory management is the best way to
    start. In some cases, for example, very large data science applications, memory
    constraints can become barriers, and more active measures need to be taken. In
    very small Internet of Things devices, memory management can also be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight pattern ensures that objects that share a state can use the same
    memory for their shared state. It is normally implemented only after a program
    has demonstrated memory problems. It may make sense to design an optimal configuration
    from the beginning in some situations, but bear in mind that premature optimization
    is the most effective way to create a program that is too complicated to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, a Flyweight design requires careful sharing of object references,
    avoiding accidental object copying, and careful tracking of object ownership to
    ensure that objects aren't deleted prematurely. In Python, everything is an object,
    and all objects work through consistent references. A Flyweight design in Python
    is generally somewhat simpler than in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following UML diagram for the Flyweight pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The Flyweight pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Each **Flyweight** object has no specific state of its own. Any time it needs
    to perform an operation on **SpecificState**, that state needs to be passed into
    the **Flyweight** by the calling code as an argument value. Traditionally, the
    factory that returns an instance of a `Flyweight` class is a separate object;
    its purpose is to return individual Flyweight objects, perhaps organized by a
    key or index of some kind. It works like the Singleton pattern we discussed in *Chapter
    11*, *Common Design Patterns*; if the Flyweight exists, we return it; otherwise,
    we create a new one. In many languages, the factory is implemented, not as a separate
    object, but as a static method on the `Flyweight` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can liken this to the way the World Wide Web has replaced a computer loaded
    up with data. In the olden days, we would be forced to collect and index documents
    and files, filling up our local computer with copies of source material. This
    used to involve transfers of physical media like floppy disks and CDs. Now, we
    can – via a website – have a reference to the original data without making a bulky,
    space-consuming copy. Because we are working with a reference to the source data,
    we can read it easily on a mobile device. The Flyweight principle of working with
    a reference to data has been a profound change in our access to information.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Singleton design pattern, which only needs to return one instance
    of a class, a Flyweight design may have multiple instances of the Flyweight classes.
    One approach is to store the items in a dictionary and provide values to Flyweight
    objects based on the dictionary key. Another common approach in some IoT applications
    is to leverage a buffer of items. On a large computer, allocating and deallocating
    objects is relatively low-cost. On a small IoT computer, we need to minimize object
    creation, which means leveraging Flyweight designs where a buffer is shared by
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: A Flyweight example in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with some concrete classes for an IoT device that works with GPS
    messages. We don''t want to create a lot of individual `Message` objects with
    duplicate values taken from a source buffer; instead, we want Flyweight objects
    to help save memory. This leverages two important features:'
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight objects reuse bytes in a single buffer. This avoids data duplication
    in a small computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flyweight classes can have unique processing for the various message types.
    In particular, the GPGGA, GPGLL, and GPRMC messages all have latitude and longitude
    information. Even though the details vary by message, we don't want to create
    distinct Python objects. It's a fair amount of overhead to handle the case when
    the only real processing distinction is the location of the relevant bytes within
    a buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: GPS messages UML diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Given a `Buffer` object with bytes read from the GPS, we can apply a `MessageFactory`
    to create Flyweight instances of the various `Message` subclasses. Each subclass
    has access to the shared `Buffer` object and can produce a `Point` object, but
    they have unique implementations reflecting the distinct structure of each message.
  prefs: []
  type: TYPE_NORMAL
- en: There's an additional complication that is unique to Python. We can get into
    trouble when we have multiple references to an instance of the `Buffer` object.
    After working with a number of messages, we'll have local, temporary data in each
    of the `Message` subclasses, including a reference to the `Buffer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation might look as shown in the following diagram, which has the concrete
    objects and their references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Reference diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Some client application, shown as a `Client` object, has a reference to a `Buffer`
    instance. It read a bunch of GPS traffic into this buffer. Additionally, a specific
    `GPGGA` instance also has a reference to the `Buffer` object because offset 0
    in the buffer had a GPGGA message. Offsets 68 and 98 have other messages; these
    will also have references back to the `Buffer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Buffer` has a reference to a GPGGA `Message` object, and the `Message`
    also has a reference back to the `Buffer`, we have a circular pair of references.
    When the client stops using a `Buffer`, the reference count goes from four references
    to three. We cannot easily remove the `Buffer` and its `Message` objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this problem by taking advantage of Python's `weakref` module.
    Unlike ordinary ("strong") references, a weak reference isn't counted for the
    purposes of memory management. We can have lots of weak references to an object,
    but once the last ordinary reference is removed, the object can be removed from
    memory. This permits the client to start working with a new `Buffer` object without
    having to worry about the old `Buffer` cluttering up memory. The number of strong
    references goes from one to zero, allowing it to be removed. Similarly, each `Message`
    object could have one strong reference from the `Buffer`, so removing the `Buffer`
    will also remove each `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: Weak references are part of the foundation of the Python runtime. Consequently,
    they are an important optimization that surfaces in a few special cases. One of
    these optimizations is that we can't create a weak reference to a `bytes` object.
    The overhead would be painful.
  prefs: []
  type: TYPE_NORMAL
- en: In a few cases (like this) we need to create an Adapter for the underlying `bytes`
    object to transform it into an object that can have weak references.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This definition of a `Buffer` class doesn't really contain a great deal of new
    code. We provided three special methods, and all three delegated the work to the
    underlying `bytes` object. The `Sequence` abstract base type provides a few methods
    for us, like `index()` and `count()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three definitions of the overloaded `__getitem__()` method is how we tell
    **mypy** of the important distinction between an expression like `buffer[i]` and
    `buffer[start: end]`. The first expression gets a single `int` item from the buffer,
    the second uses a slice and returns a `bytes` object. The final non-overload definition
    of `__getitem__()` implements the two overloads by delegating the work to the
    `self.contents` object, which handles this nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in *Chapter 11*, *Common Design Patterns*, we looked at using a state-based
    design to acquire and compute checksums. This chapter takes a different approach
    to working with a large volume of rapidly arriving GPS messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical GPS message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$` starts the message. The `*` ends the message. The characters after
    the `*` are the checksum value. We''ll ignore the two checksum bytes in this example,
    trusting that it''s correct. Here''s the abstract `Message` class with some common
    methods to help parse these GPS messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method doesn't actually do anything. We've provided a list
    of instance variables with their types, but we don't actually set them here. This
    is a way to alert **mypy** to what instance variables are going to be set elsewhere
    in the class.
  prefs: []
  type: TYPE_NORMAL
- en: In the `from_buffer()` method, we create a weak reference to a `Buffer` instance
    using the `weakref.ref()` function. As noted above, this special reference is
    not used to track how many places a `Buffer` object is used, allowing `Buffer`
    objects to be removed even if `Message` objects still have old, stale references
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: The `from_buffer()` method scans the buffer for "`,`" characters, making it
    easier to locate where each field is. This can save some time if we need several
    fields. If we only need one or two fields, this might be excessive overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In the `__getitem__()` method, we de-reference the weak reference to track down
    the `Buffer` object. Normally, when processing a `Buffer`, it's in memory along
    with some `Message` objects. Evaluating `self.buffer()` – calling the reference
    like a function – retrieves the ordinary reference we can use in the body of the
    method. At the end of the `__getitem__()` method, the buffer variable is no longer
    used, and the temporary reference vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client application may have code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `buffer` variable has an ordinary reference to a `Buffer` object. Ideally,
    this is the only reference. Each time we execute this assignment statement, the
    old `Buffer` object will have zero references and can be removed from memory.
    After this assignment statement, and before we evaluate the `from_buffer()` method
    of a `Message`, an attempt to use the `__getitem__()` method of a `Message` object
    will raise a `RuntimeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: If our application attempts to use a `Message` object's `__getitem__()` method
    without having done `set_fields()` first, that's a serious, fatal bug. We've tried
    to make it obvious by crashing the application. When we get to *Chapter 13*, *Testing
    Object-Oriented Programs*, we can use unit tests to confirm that the methods are
    used in the proper order. Until then, we have to be sure we use `__getitem__()`
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the rest of the `Message` abstract base class, showing the methods
    required to extract a fix from a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_fix()` method delegates the work to four separate methods, each of
    which extracts one of the many fields from the GPS message. We can provide subclasses
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class will use the `get_field()` method, inherited from the `Message` class,
    to pick out the bytes for four specific fields in the overall sequence of bytes.
    Because the `get_field()` method uses a reference to a `Buffer` object, we don't
    need to duplicate the entire message's sequence of bytes. Instead, we reach back
    into the `Buffer` object to get the data, avoiding cluttering up memory.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't shown the `Point` object. It's left as part of the exercises. It
    needs to convert strings of bytes into useful floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we create a suitable Flyweight object, based on the message type
    in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''re looking at a recognized message, we create an instance of one of
    our Flyweight classes. We left a comment suggesting another exercise: Use `functools.lru_cache`
    to avoid creating `Message` objects that are already available. Let''s look at
    how the `message_factory()` works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've loaded up a `Buffer` object with some bytes. The message name is a slice
    of bytes in positions 1 to 6 of the buffer. The slice operation will create a
    small `bytes` object here. The `message_factory()` function will locate one of
    our Flyweight class definitions, the `GPGLL` class. We can then use the `from_buffer()`
    method so the Flyweight can scan the `Buffer`, starting from offset zero, looking
    for "`,`" bytes to locate the starting point and ending point for the various
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate `get_fix()`, the `GPGLL` flyweight will extract four fields,
    convert the values to useful degrees and return a `Point` object with two floating-point
    values. If we want to correlate this with other devices, we might want to show
    a value that has degrees and minutes separated from each other. It can be more
    helpful to see `37°51.6500S` than `37.86083333333333`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple messages in a buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's stretch this out a bit, to look at a buffer with a sequence of messages
    in it. We'll put two GPGLL messages into a sequence of bytes. We'll include explicit
    end-of-line whitespace characters that some GPS devices include in the data stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've found the first GPGLL message, created a `GPGLL` object, and extracted
    the fix from the message. The next message begins where the previous message ends.
    This lets us start at a new offset in the buffer and examine a different region
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `message_factory()` function to create a new GPGLL object. Since
    the data from the message isn't in the object, we can reuse the previous GPGLL
    object. We can take out the `flyweight =` line of code, and the results are the
    same. When we use the `from_buffer()` method, we'll locate a new batch of "`,`"
    characters. When we use the `get_fix()` method, we'll get values from a new place
    in the overall collection of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation creates a few short strings of bytes to create a cacheable
    object for use by `message_factory()`. It creates new float values when it creates
    a `Point`. It avoids slinging around large blocks of bytes, however, by making
    the message processing objects reuse a single `Buffer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, using the Flyweight pattern in Python is a matter of making sure
    we have references to the original data. Generally, Python avoids making implicit
    copies of objects; almost all object creation is obvious, using a class name or
    perhaps comprehension syntax. One case where object creation is not obvious is
    taking a slice from a sequence, like a buffer of bytes: when we use `bytes[start:
    end]`, this makes a copy of the bytes. Too many of these and our IoT device is
    out of usable memory. A Flyweight design avoids creating new objects, and – in
    particular – avoids slicing strings and bytes to create copies of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Our example also introduced `weakref`. This isn't essential for a Flyweight
    design, but it can be helpful to identify objects that can be removed from memory.
    While the two are often seen together, they're not closely related.
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight pattern can have an enormous impact on memory consumption. It
    is common for programming solutions that optimize CPU, memory, or disk space to
    result in more complicated code than their unoptimized brethren. It is therefore
    important to weigh up the trade-offs when deciding between code maintainability
    and optimization. When choosing optimization, try to use patterns such as Flyweight
    to ensure that the complexity introduced by optimization is confined to a single
    (well-documented) section of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the Abstract Factory pattern, we'll digress a bit, to look
    at another memory optimization technique, unique to Python. This is the `__slots__`
    magic attribute name.
  prefs: []
  type: TYPE_NORMAL
- en: Memory optimization via Python's __slots__
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a lot of Python objects in one program, another way to save memory
    is through the use of `__slots__`. This is a sidebar, since it's not a common
    design pattern outside the Python language. It is a helpful Python design pattern
    because it can shave a few bytes off an object that's used widely. Instead of
    a Flyweight design – where storage is intentionally shared – a slots design creates
    objects with their own private data, but avoids Python's built-in dictionary.
    Instead, there is direct mapping from attribute name to a sequence of values,
    avoiding the rather large hash table that is a part of every Python `dict` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at our previous example in this chapter, we avoided describing
    the `Point` object that was created as part of the `get_fix()` method of each
    subclass of `Message`. Here''s one possible definition of the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each instance of a `Point` can have exactly two attributes with the names `latitude`
    and `longitude`. The `__init__()` method sets these values and provides useful
    type hints for tools like **mypy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most other respects, this class is the same as a class without `__slots__`.
    The most notable difference is we cannot add attributes. Here''s an example, showing
    what exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The extra housekeeping of defining the names of the slots can be helpful when
    our application creates vast numbers of these objects. In many cases, however,
    our application is built on one or a very small number of instances of a class,
    and the memory-saving from introducing `__slots__` is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, using a `NamedTuple` can be as effective at saving memory as
    using `__slots__`. We looked at these in *Chapter 7*, *Python Data Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to manage complexity by wrapping objects in a Façade. We've seen
    how to manage memory use by using Flyweight objects that have little (or no) internal
    state. Next, we'll look at how we can create a variety of different kinds of objects
    using a *factory*.
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Abstract Factory pattern is appropriate when we have multiple possible implementations
    of a system that depend on some configuration or platform detail. The calling
    code requests an object from the Abstract Factory, not knowing exactly what class
    of object will be returned. The underlying implementation returned may depend
    on a variety of factors, such as the current locale, operating system, or local
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Common examples of the Abstract Factory pattern include code for operating-system-independent
    toolkits, database backends, and country-specific formatters or calculators. An
    operating-system-independent GUI toolkit might use an Abstract Factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object-relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an Abstract Factory
    can return a particular tax calculation object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two central features of an Abstract Factory:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to have multiple implementation choices. Each implementation has a factory
    class to create objects. A single Abstract Factory defines the interface to the
    implementation factories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a number of closely related objects, and the relationships are implemented
    via multiple methods of each factory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following UML class diagram seems like a clutter of relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Abstract Factory pattern'
  prefs: []
  type: TYPE_NORMAL
- en: There's an essential symmetry here that's very important. The client needs instances
    of class A and class B. To the client, these are abstract class definitions. The
    `Factory` class is an abstract base class that requires an implementation. Each
    of the implementation packages, `implementation_1` and `implementation_2`, provides
    concrete `Factory` subclasses that will build the necessary A and B instances
    for the client.
  prefs: []
  type: TYPE_NORMAL
- en: An Abstract Factory example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The UML class diagram for the Abstract Factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. Let''s look at two card games, Poker and Cribbage. Don''t panic,
    you don''t need to know all the rules, only that they''re similar in a few fundamental
    ways but different in the details. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Abstract Factory pattern for Cribbage and Poker'
  prefs: []
  type: TYPE_NORMAL
- en: The `Game` class requires `Card` objects and `Hand` objects (among several others).
    We've shown that the abstract `Card` objects are contained within the abstract
    `Hand` collection. Each implementation provides some unique features. For the
    most part, the `PokerCard` matches the generic `Card` definition. The `PokerHand`
    class, however, extends the `Hand` abstract base class with all the unique rules
    for defining the rank of the hand. Poker players know that there are a very, very
    large number of Poker game variants. We've shown a hand containing five cards
    because this seems to be a common feature of many games.
  prefs: []
  type: TYPE_NORMAL
- en: The Cribbage implementation introduces a number of types of `CribbageCard` subclasses,
    each of which has an additional attribute, points. The `CribbageFace` cards are
    all worth 10 points, while for the other kinds of `CribbageCard` classes the number
    of points matches the rank. The `CribbageHand` class extends the abstract base
    class of `Hand` with the unique rules for finding all the scoring combinations
    in a hand. We can use an Abstract Factory to build `Card` and `Hand` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the core definitions of `Hand` and `Card`. We didn't make these official
    abstract base classes. Python doesn't require this, and the extra complexity didn't
    seem helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These seem to capture the essence of "card" and "hand of cards." We''ll need
    to extend these with subclasses that pertain to each game. We''ll also need an
    Abstract Factory that creates cards and hands for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've made the factory an actual abstract base class. Each individual game needs
    to provide extensions for the game's unique features of `Hand` and `Card`. The
    game will also provide an implementation of the `CardGameFactory` class that can
    build the expected classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the cards for cribbage like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These extensions to the base `Card` class all have an additional points property.
    In Cribbage, one of the kinds of tricks is any combination of cards worth 15 points.
    Most cards have points equal to the rank, but the Jack, Queen, and King are all
    worth 10 points. This also means the Cribbage extension to `Hand` has a rather
    complex method for scoring, which we'll omit for now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To provide some uniformity between the games, we've designated the scoring combinations
    in Cribbage and the rank of the hand in Poker as a subclass of "Trick." In Cribbage,
    there's a fairly large number of point-scoring tricks. In Poker, on the other
    hand, there's a single Trick that represents the hand as a whole. Tricks don't
    seem to be a place where an Abstract Factory is useful.
  prefs: []
  type: TYPE_NORMAL
- en: The computation of the various scoring combinations in Cribbage is a rather
    sophisticated problem. It involves looking at all possible combinations of cards
    that total to 15 points, among other things. These details are unrelated to the
    Abstract Factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Poker variant has its own unique complication: Aces are a higher rank than
    the King:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranking the various hands in poker is also a rather sophisticated problem,
    but outside the Abstract Factory realm. Here''s the concrete factory that builds
    hands and cards for Poker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the way the `make_card()` method reflects the way Aces work in Poker. Having
    the Ace outrank the King reflects a common complication in a number of card games;
    we need to reflect the various ways Aces work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a test case for how Cribbage works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created an instance of the `CribbageFactory` class, a concrete implementation
    of the abstract `CardGameFactory` class. We can use the factory to create some
    cards, and we can also use the factory to create a hand of cards. When playing
    Cribbage, an additional card is flipped, called the "starter." In this case, our
    hand is four cards in sequence, and the starter happens to fit with that sequence.
    We can score the hand and see that there are three scoring combinations: there
    are two ways to make 15 points, plus a run of five cards.'
  prefs: []
  type: TYPE_NORMAL
- en: This design provides some hints toward what needs to be done when we want to
    add support for more games. Introducing new rules means creating the new `Hand`
    and `Card` subclasses and extending the Abstract Factory class definition, also.
    Of course, inheritance leads to the opportunity for reuse, something we can capitalize
    on to create families of games with similar rules.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factories in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example highlights an interesting consequence of the way Python''s
    duck typing works. Do we really need the abstract base class, `CardGameFactory?`
    It provides a framework used for type checking, but otherwise doesn''t have any
    useful features. Since we don''t really need it, we can think of this design as
    having three parallel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Abstract Factory without abstract base classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the defined games implement a class, `CardGameFactory`, that defines
    the unique features of the game. Because these are in separate modules, we can
    use the same name for each class. This lets us write a Cribbage application that
    uses `from cribbage import CardGameFactory`. This skips past the overhead of a
    common abstract base class and lets us provide extensions as separate modules
    sharing some common base class definitions. Each alternative implementation also
    provides a common module-level interface: they expose a standard class name that
    handles the remaining details of creating unique objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the Abstract Factory becomes a concept, and is not implemented
    as an actual abstract base class. We''ll need to provide adequate documentation
    in the docstrings for all classes that purport to be `CardGameFactory` implementations.
    We can clarify our intentions by defining a protocol using `typing.Protocol`.
    It could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This definition allows **mypy** to confirm that a `Game` class can refer to
    either a `poker.CardGameFactory` or a `cribbage.CardGameFactory` because both
    implement the same protocol. Unlike the abstract base class definition, this is
    not a runtime check. A protocol definition is only used by **mypy** to confirm
    that the code is likely to pass its unit test suite.
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern helps us define related families of objects, for
    instance, playing cards and hands. A single factory can produce two separate classes
    of objects that are closely related. In some cases, the relationships aren't a
    simple collection and item. Sometimes there are sub-collections in addition to
    items. These kinds of structures can be handled using the Composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Composite pattern allows complex tree structures to be built from simple
    components, often called **nodes**. A node with children will behave like a container;
    a node without children will behave like a single object. A composite object is
    – generally – a container object, where the content may be another composite object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, each node in a composite object must be either a **leaf** node
    (that cannot contain other objects) or a **composite** node. The key is that both
    composite and leaf nodes can have the same interface. The following UML diagram shows
    this elegant parallelism as a `some_action()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: The Composite pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. The following diagram
    depicts a concrete instance of such a complicated arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: A large Composite pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The Composite pattern applies to language processing. Both natural languages
    and artificial languages (like Python) tend to follow rules that are hierarchical
    and fit nicely with the Composite design pattern. Markup languages, like HTML,
    XML, RST, and Markdown, tend to reflect some common composite concepts like lists
    of lists, and headers with sub-headings.
  prefs: []
  type: TYPE_NORMAL
- en: A programming language involves recursive tree structures. The Python standard
    library includes the `ast` module, which provides the classes that define the
    structure of Python code. We can use this module to examine Python code without
    resorting to regular expressions or other hard-to-get-correct text processing.
  prefs: []
  type: TYPE_NORMAL
- en: A Composite example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composite pattern needs to be applied to tree structures like the files
    and folders of a file system. Regardless of whether a node in the tree is an ordinary
    data file or a folder, it is still subject to operations such as moving, copying,
    or deleting the node. We can create a component interface that supports these
    operations, and then use a composite object to represent folders, and leaf nodes
    to represent data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For each `Folder`, a composite object, we maintain a dictionary of children.
    The children may be a mixture of `Folder` and `File` instances. For many composite
    implementations, a list is sufficient, but in this case, a dictionary will be
    useful for looking up children by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about the methods involved, there are several patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: For doing a move, relocating the `Folder` will carry along all the children.
    Relocating a `File` will turn out to be precisely the same code because we don't
    need to consider the children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For doing a copy, we'll need to copy all of the children. Since there's no data
    outside the `File` nodes of the composite object, we don't need to do anything
    more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a delete, we should follow the Linux pattern of clearing out the children
    before trying to remove a parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This design lets us create subclasses with distinct operation implementations.
    Each subclass implementation could make external requests, or perhaps make OS
    requests on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of the similar operations, we can extract the common methods
    into a parent class. Let''s refactor this to create a base class, `Node`, with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This abstract `Node` class defines that each node has a string with a reference
    to a parent. Keeping the parent information around lets us look "up" the tree
    toward the root node. This makes it possible to move and remove files by making
    a change to the parent's collection of children.
  prefs: []
  type: TYPE_NORMAL
- en: We've created the `move()` method on the `Node` class. This works by reassigning
    a `Folder` or a `File` object to a new location. It follows up by removing the
    object from its previous location. For the `move()` method, the target should
    be an existing folder, or we'll get an error because a `File` instance doesn't
    have an `add_child()` method. As in many examples in technical books, error handling
    is woefully absent, to help focus on the principles under consideration. A common
    practice is to handle the `AttributeError` exception by raising a new `TypeError`
    exception. See *Chapter 4*, *Expecting the Unexpected*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then extend this class to provide the unique features of a `Folder`
    that has children, and a `File`, which is the leaf node of the tree and has no
    children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we add a child to a `Folder`, we'll do two things. First, we tell the child
    who their new parent is. This makes sure that each `Node` (except the root `Folder`
    instance) has a parent. Second, we'll drop the new `Node` into the folder's collection
    of children, if it doesn't already exist.
  prefs: []
  type: TYPE_NORMAL
- en: When we copy `Folder` objects around, we need to make sure all the children
    are copied. Each child could, in turn, be another `Folder`, with children. This
    recursive walk involves delegating the `copy()` operation to each sub-`Folder`
    within a `Folder` instance. The implementation for a `File` object, on the other
    hand, is simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive design for removal is similar to the recursive copy. A `Folder`
    instance must first remove all of the children; this may involve removing sub-`Folder`
    instances. A `File` object, on the other hand, can be directly removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working properly
    with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The value of `tree` can be a little difficult to visualize. Here's a variation
    on the display that can help.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t cover the algorithm for producing this nested visualization. It''s
    not too difficult to add to the class definitions. We can see that the parent
    folder, `Tree`, has a sub-folder, `src`, with two files inside it. We can describe
    a filesystem operation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a new folder, `tests`, and moved the file. Here''s another view
    of the resulting composite objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. Sometimes, if only a shallow tree is being created, we can get away with
    a list of lists or a dictionary of dictionaries, and do not need to implement
    custom component, leaf, and composite classes. Indeed, JSON, YAML, and TOML documents
    often follow the dict-of-dict pattern. While we often use abstract base classes
    for this, it isn't required; Python's duck typing can make it easy to add other
    objects to a composite hierarchy, as long as they have the correct interface.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important aspects of the Composite pattern is a common interface
    for the various subtypes of a node. We needed two implementation variants for
    `Folder` and `File` classes. In some cases, these operations are similar, and
    it can help to offer a template implementation of a complex method.
  prefs: []
  type: TYPE_NORMAL
- en: The Template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Template pattern (sometimes called the Template method) is useful for removing
    duplicate code; it''s intended to support the **Don''t Repeat Yourself** principle
    we discussed in *Chapter 5*, *When to Use Object-Oriented Programming*. It is
    designed for situations where we have several different tasks to accomplish that
    have some, but not all, steps in common. The common steps are implemented in a
    base class, and the distinct steps are overridden in subclasses to provide custom
    behavior. In some ways, it''s like the Strategy pattern, except similar sections
    of the algorithms are shared using a base class. Here it is in the UML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: The Template pattern'
  prefs: []
  type: TYPE_NORMAL
- en: A Template example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a car sales reporter as an example. We can store records of sales
    in an SQLite database table. SQLite is the built-in database engine that allows
    us to store records using SQL syntax. Python includes SQLite in its standard library,
    so there are no extra modules to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two common tasks we need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Select all sales of new vehicles and output them to the screen in a comma-delimited
    format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output a comma-delimited list of all salespeople with their gross sales and
    save it to a file that can be imported to a spreadsheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These seem like quite different tasks, but they have some common features.
    In both cases, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a query for new vehicles or gross sales
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue the query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Format the results into a comma-delimited string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the data to a file or email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The query construction and output steps are different for the two tasks, but
    the remaining steps are identical. We can use the Template pattern to put the
    common steps in a base class, and the varying steps in two subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let''s create a database and put some sample data in it, using
    a few lines of SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you can see what's going on here even if you don't know SQL; we've
    created a table named `Sales` to hold the data, and used six `insert` statements
    to add sales records. The data is stored in a file named `sales.db`. Now we have
    a sample database with a table we can work with in developing our Template pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve already outlined the steps that the template has to perform, we
    can start by defining the base class that contains the steps. Each step gets its
    own method (to make it easy to selectively override any one step), and we have
    one more managerial method that calls the steps in turn. Without any method content,
    here''s how the class might look as a first step toward completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `process_format()` method is the primary method to be called by an outside
    client. It ensures each step is executed in order, but it does not care whether
    that step is implemented in this class or in a subclass. For our examples, we
    expect the `construct_query()` and the `output_context()` methods are likely to
    change.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can formalize our expectation by using an abstract base class.
    An alternative is to raise a `NotImplementedError` exception for the missing method
    in the template. This will provide a runtime check if we subclass the `QueryTemplate`
    and – perhaps – misspell the name of our attempted override of the `construct_query()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining methods are going to be identical between our two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a kind of abstract class. It doesn''t use a formal abstract base class;
    instead, the two methods we expect to update show two distinct approaches to providing
    an abstract definition:'
  prefs: []
  type: TYPE_NORMAL
- en: The `construct_query()` method must be overridden. The method definition base
    class raises the `NotImplementedError` exception. This is an alternative for creating
    an abstract interface in Python. Raising `NotImplementedError` helps the programmer
    understand that the class is meant to be subclassed and these methods overridden.
    It can be described as "smuggling in an abstract base class without being explicit"
    in the `class` definition and without using `@abc.abstracmethod` decorators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output_context()` method may be overridden. There's a default implementation
    provided that sets the `self.target_file` instance variable and also returns a
    context value. The default uses `sys.stdout` as the output file and a null context
    manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have a template class that takes care of the boring details, but is flexible
    enough to allow the execution and formatting of a wide variety of queries. The
    best part is, if we ever want to change our database engine from SQLite to another
    database engine (such as `py-postgresql`), we only have to do it here, in this
    template class, and we don't have to touch the two (or two hundred) subclasses
    we might have written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the concrete classes now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These two classes are actually pretty short, considering what they''re doing:
    connecting to a database, executing a query, formatting the results, and outputting
    them. The superclass takes care of the repetitive work, but lets us easily specify
    those steps that vary between tasks. Further, we can also easily change steps
    that are provided in the base class. For example, if we wanted to output something
    other than a comma-delimited string (for example, an HTML report to be uploaded
    to a website), we can still override the `output_results()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters of the case study have contained a number of design patterns.
    We'll pick a variation on the model and walk through some of the patterns from
    this chapter and how they were applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overview of several parts of the application''s classes. This is
    from the case study in *Chapter 7*, *Python Data Structures*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_12_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: The case study Logical view'
  prefs: []
  type: TYPE_NORMAL
- en: This involves a number of patterns we've seen in this chapter. We'll start with
    the `Hyperparameter` class, which is a Façade that includes two separate complex
    components, the classifier algorithm and the training data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll look at the classifier algorithm. In *Chapter 10*, *The Iterator
    Pattern*, we saw how the classifier is itself a complex structure. We looked at
    three alternatives: `k_nn_1()`, which had a naïve sort, `k_nn_b()`, which used
    bisection, and `k_nn_q()`, which used a heap queue. This exploration relied on
    several design patterns from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The classifier depends on the Strategy design pattern to incorporate one of
    the many distance computations. We defined a class, `Distance`, and made sure
    each distance computation was a subclass. The classifier algorithm was given the
    distance computation as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classifier is a Façade that provides a uniform interface for testing and
    evaluating a sample. Each variation on the classifier used a slightly different
    data structure for managing the collection of nearest neighbors. We don't want
    to sort a large training set; we only want to track the subset of nearest neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we've made sure the training data leverages
    the Flyweight design pattern to avoid keeping multiple copies of the training
    data. The idea of wrapping each `Sample` object with a separate frozen dataclass
    to include known information about the sample is a kind of Flyweight design, also.
    More fundamentally, it is an example of the Composite pattern. The useable sample
    is a composite and avoids keeping multiple copies of the underlying `KnownSample`
    objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `TrainingData` class, we can see how this design also follows
    the Façade design pattern. A number of distinct operations have a uniform interface.
    There are two important parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading raw `Sample` instances to partition them into training and testing subsets.
    The various data formats described in *Chapter 9*, *Strings, Serialization, and
    File Paths*, can be seen as complex algorithms that are simplified by a uniform
    Façade. The choice of algorithm to partition the initial set of samples into a
    training set and a testing set is, similarly, an application of the Strategy design
    pattern. This lets us change the ratio of samples used for training and testing
    using a different implementation from a strategy class hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the testing and training sets to be used for hyperparameter tuning is
    done by partitioning the raw data into two disjoint lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of creating `TrainingKnownSample` or `TestingKnownSample` instances
    is an example of the Abstract Factory pattern. The partitioning algorithm can
    be described by an Abstract Factory class definition. Each partitioning algorithm
    becomes a concrete factory that creates different mixtures of training and testing
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 11*, *Common Design Patterns*, we looked closely at the hyperparameter
    tuning process. The *k*-nearest neighbors algorithm depends on two parameters,
    called hyperparameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used to compute the distances between samples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of samples, *k*, used. The most common of the *k* nearest neighbors
    becomes the label assigned to the unknown sample. If the value for *k* is odd,
    we can avoid an even split between two choices, ensuring there's always a winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Chapter 11*, the tuning algorithm shown is not particularly speedy but
    is patiently thorough: the grid search algorithm. In that chapter, we used the
    Command design pattern to enumerate various combinations of *k* and distance computations.
    Each combination was a command that – when executed – provided quality and timing
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There were three major phases of work involved in the application, as a whole.
    These were presented in *Chapter 1*, *Object-Oriented Design*, as the various
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A Botanist provides training data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Botanist uses hyperparameter tuning to locate an optimal model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Users make use of this to classify their unknown samples
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This pattern of work suggests the Template design pattern may be required to
    ensure that classes like the `TrainingData` class and the overall application
    work consistently. Currently, it doesn''t seem like a carefully designed class
    hierarchy is needed. When we review *Chapter 1*, however, the initial intent was
    to use this example to learn more about classifiers, and eventually extend this
    from the simple example of classifying iris species to more complex real-world
    problems. This follows what''s called "the telescope rule":'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thomson''s Rule for First-Time Telescope Makers: "It is faster to make a four-inch
    mirror then a six-inch mirror than to make a six-inch mirror."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- Programming Pearls, Communications of the ACM, September 1985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The intent behind the problem is to build something workable, using a variety
    of design patterns. The various components can then be replaced, revised, and
    expanded to tackle larger and more complex problems. The telescope maker will
    learn a lot about telescopes from making their first mirror, and those lessons
    can be applied to making their next, more useful telescope. A similar pattern
    of learning applies to software and object-oriented design. If the various components
    are designed well and follow established patterns, then the changes to improve
    and expand are not damaging or disruptive.
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we''ll spot really good ideas that are repeated; the repetition can
    form a recognizable pattern. Exploiting a pattern-based approach to software design
    can save the developer from wasting time trying to reinvent something already
    well understood. In this chapter, we looked at a few more advanced design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: An Adapter class is a way to insert an intermediary so a client can make use
    of an existing class even when the class is not a perfect match. The software
    adapter parallels the idea of USB hardware adapters between various kinds of devices
    with various USB interface connectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Façade pattern is a way to create a unified interface over a number of objects.
    The idea parallels the façade of a building that unifies separate floors, rooms,
    and halls into a single space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can leverage the Flyweight pattern to implement a kind of lazy initialization.
    Instead of copying objects, we can design Flyweight classes that share a common
    pool of data, minimizing or avoiding initialization entirely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have closely related classes of objects, the Abstract Factory pattern
    can be used to build a class that can emit instances that will work together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Composition pattern is widely used for complex document types. It covers
    programming languages, natural languages, and markup languages, including XML
    and HTML. Even something like the filesystem with a hierarchy of directories and
    files fits this design pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have a number of similar, complex classes, it seems appropriate to create
    a class following the Template pattern. We can leave gaps or openings in the template
    into which we can inject any unique features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These patterns can help a designer focus on accepted, good design practices.
    Each problem is, of course, unique, so the patterns must be adapted. It's often
    better to make an adaptation to a known pattern and avoid trying to invent something
    completely new.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into exercises for each design pattern, take a moment to add the
    `os` and `pathlib` calls to implement the methods for the `File` and `Folder` objects
    in the section on *The Composite pattern*. The `copy()` method on `File` will
    need to read and write the bytes of a file. The `copy()` method on `Folder` is
    quite a bit more complicated, as you first have to duplicate the folder, and then
    recursively copy each of its children to the new location. The examples we provided
    update the internal data structure, but don't apply changes to the operating system.
    Be careful about testing this in isolated directories. You don't want to accidentally
    destroy important files.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as in the previous chapter, look at the patterns we've discussed and consider
    ideal places where you might implement them. You may want to apply the Adapter
    pattern to existing code, as it is usually applicable when interfacing with existing
    libraries, rather than new code. How can you use an Adapter to force two interfaces
    to interact with each other correctly?
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a system complex enough to justify using the Façade pattern?
    Consider how façades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the façade interface are other programmers, rather than people
    trained to use it. Are there complex systems in your latest project that could
    benefit from the Façade pattern?
  prefs: []
  type: TYPE_NORMAL
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the Flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a Flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does adopting the Flyweight pattern make sense?
    When is it overkill?
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  prefs: []
  type: TYPE_NORMAL
- en: The Composite pattern applies in a number of places. There are tree-like structures
    all around us in programming. Some of them, like our file hierarchy example, are
    blatant; others are fairly subtle. What situations might arise where the Composite
    pattern would be useful? Can you think of places where you can use it in your
    own code? What if you adapted the pattern slightly; for example, to contain different
    types of leaf or composite nodes for different types of objects?
  prefs: []
  type: TYPE_NORMAL
- en: The `ast` module provides a composite tree structure for Python code. A particularly
    useful thing is to use the `ast` module to locate all of the import statements
    in some code. This can help confirm that a project's list of required modules,
    often in a `requirements.txt` file, is complete and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Template method is helpful when decomposing a complex operation so it is
    open to extension. It appears that the *k*-nearest neighbors algorithm might be
    a good candidate for a Template method. In *Chapter 10*, *The Iterator Pattern*,
    we rewrote the *k*-nearest neighbors algorithm as three completely separate functions.
    Was this necessary? Could we have rewritten it into a method that decomposes the
    problem into three steps: computing distances, finding the *k*-nearest, and then
    finding the mode? Compare this design with doing it as separate functions; which
    do you find more expressive?'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The Adapter pattern is useful for matching interfaces, while the Façade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. Abstract Factories allow the runtime
    separation of implementations depending on configuration or system information.
    The Composite pattern is used universally for tree-like structures. A Template
    method can be helpful for breaking complex operations into steps to avoid repeating
    the common features.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last of the truly object-oriented design chapters in this book.
    In the next two chapters, we'll discuss how important it is to test Python programs,
    and how to do it, focusing on object-oriented principles. Then we'll look at the
    concurrency features of Python and how to exploit them to get work done more quickly.
  prefs: []
  type: TYPE_NORMAL
