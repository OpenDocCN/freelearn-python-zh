<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Tasklist II: Databases and AJAX"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Tasklist II: Databases and AJAX</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>In this chapter, we will refactor our tasklist application. It will use a database engine on the server to store items and will use jQuery's AJAX functionality to dynamically update the contents of the web application. On the server side, we will learn how to use Python's bundled SQLite database engine. On the presentation side, we will encounter jQuery UI's event system and will learn how to react to mouse clicks.</p></blockquote></div><p>In this chapter, we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn some benefits of using a database engine</li><li class="listitem" style="list-style-type: disc">Get familiar with SQLite, a database engine distributed with Python</li><li class="listitem" style="list-style-type: disc">Implement a password database with SQLite</li><li class="listitem" style="list-style-type: disc">Learn how to design and develop a database-driven tasklist application</li><li class="listitem" style="list-style-type: disc">Implement a test framework</li><li class="listitem" style="list-style-type: disc">Learn how to make a web application more responsive using AJAX calls</li><li class="listitem" style="list-style-type: disc">See how to implement interactive applications without<code class="literal">&lt;form&gt;</code> elements</li></ul></div><p>So let's get on with it...</p><div class="section" title="The advantages of a database compared to a filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>The advantages of a database compared to a filesystem</h1></div></div></div><p>Storing records on a filesystem as separate files might be simple but does have several drawbacks:<a id="id164" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You have to define your own interface for accessing these files and parsing their contents. This is much more serious than it may sound because it compels you to develop and test a lot of specific functionality that you would otherwise get more or less for free from an existing library</li><li class="listitem" style="list-style-type: disc">Accessing single files is much slower than selecting records from a table in a database. That might be workable as long as you know which record you want (as is the case in our tasklist application) but it certainly isn't workable when you want to select records based on the value of some attribute. This would necessitate opening each and every file and checking whether some attribute matches your criteria. On a data collection of hundreds of items or more, this would be prohibitively slow</li><li class="listitem" style="list-style-type: disc">Also, it is difficult to implement transactions. If we want to guarantee that a set of actions will either be successful as a whole or will be rolled back if some part of it doesn't succeed, we will have to implement very sophisticated code ourselves if we want to use files on a filesystem<a id="id165" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">When using files on a filesystem, it is a nuisance to define and maintain relations between records, and although our tasklist application is about as simple as it gets, almost any other application has more than one logical object and relations between them, so this is a serious issue.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Choosing a database engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Choosing a database engine</h1></div></div></div><p>There are many database engines available that can be accessed from Python, both commercial and open source (http://wiki.python.org/moin/DatabaseInterfaces). Choosing the right database is not a trivial task as it might not only depend on functional requirements, but also on performance, the available budget, and hard to define requirements like easy maintenance.<a id="id166" class="indexterm"/>
</p><p>In the applications we develop in this book, we have chosen to use the SQLite database engine (<a class="ulink" href="http://http://www.sqlite.org">http://www.sqlite.org</a>) for a number of reasons. First, it is free and included in Python's standard distribution. This is important for people writing books because it means that everyone who is able to run Python has access to the SQLite database engine as well. However, this is not a toy database: as a matter of fact, SQLite is a database that is used in many smartphones and high-profile applications like Firefox to store things like configurations and bookmarks. Furthermore, it is reliable and robust and, on top of that, quite fast.<a id="id167" class="indexterm"/>
</p><p>It does have some drawbacks as well: first of all, it uses its own dialect of SQL (the language used to interact with the database) but to be fair, most database engines use their own dialect.<a id="id168" class="indexterm"/>
</p><p>More seriously, the focus of SQLite is on embedded systems, the most visible consequence of that is that it doesn't have facilities to limit user access to a subset of tables and columns. There is just a single file on the filesystem that holds the contents of the database and the access rights to the file are determined by the filesystem on which it resides.</p><p>The final issue is not so much a drawback as a point of serious attention: SQLite does not enforce types. In many databases, the type defined for column determines rigidly what you can store in that column. When a column is defined as an INTEGER, the database engine, in general, won't allow you to store a string or a boolean value, whereas, SQLite does. This isn't as strange as it sounds once you compare it with the way Python manages variables. In Python, it is perfectly valid to define a variable and assign an integer to it, and later assign a string to the same variable. A variable in Python is just like a column in SQLite; it is just a pointer to a value and that value is not simply the value itself but also has an explicitly associated type.<a id="id169" class="indexterm"/>
</p><p>The combination of availability, reliability, and a type system closely resembling Python's native way of dealing with values makes SQLite a very suitable database engine in many applications, although specific applications may have requirements that may be better served by other database engines, like PostgreSQL or MySQL. The latter might be an attractive alternative if your application will run on a web server that already provides MySQL.<a id="id170" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Database-driven authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Database-driven authentication</h1></div></div></div><p>Before we start designing a database-driven tasklist application, let's first familiarize ourselves with SQLite in the context of a seemingly much simpler set of requirements: storing username/password combinations in a database and refactoring the Logon class to interact with this database.<a id="id171" class="indexterm"/>
</p><p>The functional requirements are deceptively simple: to verify whether a username/password combination is valid, all we have to do is verify that the username/password combination given is present in the table of usernames and passwords. Such a table consists of two columns, one named<code class="literal"> username</code> and the other named<code class="literal"> password</code>. As it is never a good idea to store a collection of passwords in plaintext, we encrypt the passwords with a hash function so even if the password database is compromised, the bad guys will have a difficult time retrieving the passwords. This means, of course, that we have to hash a given password with the same hash function before comparing it to the stored password for the username but that doesn't add much complexity.</p><p>What does add complexity is the fact that CherryPy is multi-threaded, meaning that CherryPy consists of multiple lightweight processes accessing the same data. And although the developers of SQLite maintain the opinion that threads are evil (<a class="ulink" href="http://www.sqlite.org/faq.html#q6">http://www.sqlite.org/faq.html#q6</a>), threads make perfect sense in situations where a lot of time in the application is spent on waiting. This certainly is the case in web applications that spend a lot of time waiting for network traffic to complete, even in this time of broadband connections. The most effective way of using this waiting time is to enable a different thread to serve another connection so more users might enjoy a better interactive experience.<a id="id172" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"/>Note</h3><p>
<span class="strong"><strong>Hash functions</strong></span> (or Cryptographic hash functions to be more specific) convert any input string to an output string of limited length in such a way that it is very unlikely that two input strings that are different produce the same output. Also, conversion from input to output is a one way operation or at least it will cost a large amount of computing power to construct the input from the output. There are many useful hash functions known, the most popular ones are available in Python's<code class="literal"> hashlib</code> module. The specific hash function we use here is called<code class="literal"> SHA1</code>.</p><p>More about hashing can be found in the Python documentation at<a class="ulink" href="http://docs.python.org/py3k/library/hashlib.html"> http://docs.python.org/py3k/library/hashlib.html</a>, or on Wikipedia at<a class="ulink" href="http://en.wikipedia.org/wiki/Cryptographic_hash_function"> http://en.wikipedia.org/wiki/Cryptographic_hash_function</a>.</p></div><p>However, in SQLite, the connection object cannot be shared among threads. This doesn't mean that that we cannot use SQLite in a multi-threaded environment (despite the evilness of threads), but it does mean we have to make sure that if we want to access the same SQLite database from different threads, each thread must use a connection object that is exclusively created for that thread.<a id="id173" class="indexterm"/>
</p><p>Fortunately, it is quite easy to instruct CherryPy to call a function the moment it starts a new thread and let that function create a new connection to our database, as we will see in the next section. If we would employ many different threads, this might be wasteful because the connection objects use some memory, but with a few tens of threads this doesn't pose much of a problem (The default number of threads in CherryPy is 10 and can be configured with the<code class="literal"> server.thread_pool</code> configuration option). If the memory consumption is a problem, there are alternative solutions available, for example, in the form of a separate worker thread that handles all database interaction or a small pool of such threads. A starting point for this might be<a class="ulink" href="http://tools.cherrypy.org/wiki/Databases"> http://tools.cherrypy.org/wiki/Databases</a>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action authentication using a database"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Time for action authentication using a database</h1></div></div></div><p>To illustrate how to use database-driven user authentication, run<code class="literal"> logondbapp.py</code>. It will present you with a logon screen very similar to the one shown in the previous chapter. You may enter the built-in username/password combination of admin/admin, after which you will be presented with a welcoming page.<a id="id174" class="indexterm"/>
</p><p>In order to make this mini application work with the database-driven version of user authentication, all we have to do is replace the reference to an instance of the Logon class to one of the<code class="literal"> LogonDB</code> class, as highlighted in the following code (the full code is available as<code class="literal"> logondbapp.py):</code>
<a id="id175" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/logondbdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import cherrypy
import logondb
class Root(object):<span class="strong"><strong>
	logon = logondb.LogonDB(path="/logon", authenticated="/", not_
authenticated="/goaway", db="/tmp/pwd.db")</strong></span>
	@cherrypy.expose
	def index(self):
		username=Root.logon.checkauth('/logon')
		return '&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello user &lt;b&gt;%s&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;/
html&gt;'%username
	@cherrypy.expose
	def goaway(self):
		return '&lt;html&gt;&lt;body&gt;&lt;h1&gt;Not authenticated, please go away.&lt;/h1&gt;&lt;/
body&gt;&lt;/html&gt;'
	goaway._cp_config = {'tools.expires.on':True,'tools.expires.
secs':0,'tools.expires.force':True}
	@cherrypy.expose
	def somepage(self):
		username=Root.logon.checkauth('/logon',returntopage=True)
		return '&lt;html&gt;&lt;body&gt;&lt;h1&gt;This is some page.&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'
if __name__ == "__main__":
	import os.path
	current_dir = os.path.dirname(os.path.abspath(__file__))
	root = Root()<span class="strong"><strong>
	def connect(thread_index):</strong></span>
		root.logon.connect()
	cherrypy.engine.subscribe('start_thread', connect)
	cherrypy.quickstart(root,config={ ... } )
</pre></div><p>Another important difference with the previous implementation is the highlighted definition of a<code class="literal"> connect()</code> function that should be called for each new thread that is started by CherryPy. It calls the<code class="literal"> connect()</code> method of the<code class="literal"> LogonDB</code> instance to create a database connection object unique for a given thread. We register this function with the<code class="literal"> cherrypy.engine.subscribe()</code> function and make it call our<code class="literal"> connect()</code> function at the start of each new thread CherryPy starts.<a id="id176" class="indexterm"/>
</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>What just happened?</h2></div></div></div><p>The database-centered version of our<code class="literal"> Logon</code> class,<code class="literal"> LogonDB</code> inherits a lot from<code class="literal"> Logon</code>. Specifically, all HTML-related logic is reused.<code class="literal"> LogonDB</code> does override the<code class="literal"> __init__()</code> method to store a path to a database file and makes sure the database is initialized using the<code class="literal"> initdb()</code> method, if it does not yet exist (highlighted). It also overrides the<code class="literal"> checkpass()</code> method because this method must now verify the existence of a valid username/password pair against a database table.</p><p>
<span class="strong"><strong>Chapter4/logondb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import logon
import sqlite3
from hashlib import sha1 as hash
import threading
import cherrypy<span class="strong"><strong>
class LogonDB(logon.Logon):</strong></span>
	def __init__( self,path="/logon", authenticated="/", not_
authenticated="/", db="/tmp/pwd.db"):
		super().__init__(path,authenticated,not_authenticated)
		self.db=db
		self.initdb()
	@staticmethod
	def _dohash(s):
		h = hash()
		h.update(s.encode())
		return h.hexdigest()<span class="strong"><strong>
	def checkpass(self,username,password):</strong></span>
		password = LogonDB._dohash(password)
		c = self.data.conn.cursor()
		c.execute("SELECT count(*) FROM pwdb WHERE username = ? AND 
password = ?",(username,password))
		if c.fetchone()[0]==1 :return True
		return False
	def initdb(self):
		conn=sqlite3.connect(self.db)
		c = conn.cursor()<span class="strong"><strong>
		c.execute("CREATE TABLE IF NOT EXISTS pwdb(username unique not 
null,password not null);")</strong></span>
		c.execute('INSERT OR IGNORE INTO pwdb 
VALUES("admin",?)',(LogonDB._dohash("admin"),))
		conn.commit()
		conn.close()
		self.data=threading.local()
	def connect(self):
		'''call once for every thread as sqlite connection objects cannot 
be shared among threads.'''
		self.data.conn = sqlite3.connect(self.db)
</pre></div><p>The definition of the database consists of a single table<code class="literal"> pwdb</code> that is defined in the highlighted line (and only if that table does not yet exist). The<code class="literal"> pwdb</code> table consists of two columns, namely,<code class="literal"> username</code> and<code class="literal"> password</code>. By marking both columns as<code class="literal"> not null</code>, we ensure that we cannot enter empty values in any of them. The<code class="literal"> username</code> column is also marked as<code class="literal"> unique</code> because a username may only occur once. This database schema of a single table can be depicted in the following diagram where each column has a header with a name and several lines that list the attributes of a certain column (as our database design gets more elaborate, we will rely more on these diagrams and less on a detailed expose of the SQL code):<a id="id177" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col width="0.845902777777777" style="text-align: left"/><col width="0.931701388888889" style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pwdb</p>
</th><td class="auto-generated"> </td></tr><tr><th style="text-align: left" valign="bottom">
<p>Username</p>
</th><th style="text-align: left" valign="bottom">
<p>password</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>not null</p>
<p>unique</p>
</td><td style="text-align: left" valign="top">
<p>not null</p>
</td></tr></tbody></table></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"/>Note</h3><p>Anyone familiar with other dialects of SQL might have noticed that the column definitions lack any kind of type. This is deliberate: SQLite allows us to store any kind of value in a column, just as Python allows us to store any kind of value in a variable. The type of the value is directly associated with the value, not with the column or variable. SQLite does support the notion of affinity or preferred type and we will encounter that in other tables we will create in this book.</p></div><p>Besides creating a table, if needed (in the<code class="literal"> initdb()</code> method, highlighted), we also initialize it with a username/password combination of admin/admin if the admin username is not yet there. If it is, we leave it as it is because we do not want to reset an altered password, but we do want to make sure that there is an admin username present. This is accomplished by the<code class="literal"> insert or ignore</code> statement because the<code class="literal"> insert</code> of an<code class="literal"> admin</code> username into a table that already contains one would fail because of the unique constraint. Adding the non standard or<code class="literal"> ignore</code> clause will ignore such an occurrence, in other words, it will not insert a new record with a username of admin if it is already there.<a id="id178" class="indexterm"/>
</p><p>The<code class="literal"> insert</code> statement also illustrates that we store passwords not as plaintext, but as hashed values (that are extremely hard to convert back to plaintext again). The hash method we use here is SHA1 and is imported as<code class="literal"> hash()</code> from Python's<code class="literal"> hashlib</code> module. The conversion from plaintext is handled by the<code class="literal"> _dohash()</code> static method (marked as private by leading underscore in its name but note that in Python, this is a convention only, as there really aren't any private methods).<a id="id179" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"/>Note</h3><p>The way we store passwords in this example is still not safe enough for production environments, but implementing a more secure solution is out of scope for this book. I strongly suggest reading<a class="ulink" href="http://www.aspheute.com/english/20040105.asp"> http://www.aspheute.com/english/20040105.asp</a> for more on this subject.</p></div><p>The<code class="literal"> initdb()</code> method also takes care of creating an object that can be used to store data that is local to a thread with the<code class="literal"> threading.local()</code> function. Because, normally, all data in threads is shared, we have to use this function to create a place to store a database connection object that is different for each thread. If we were to store such a connection object in a global variable, each thread would have access to the same database connection and this is not allowed in SQLite.</p><p>The fact that we store passwords as hashed values implies that checking username/password combinations necessarily involves converting a plaintext password as well before it can be checked for existence. This is implemented in the<code class="literal"> checkpass()</code> method (highlighted). The password argument is converted with the<code class="literal"> _dohash()</code> method before being passed to the<code class="literal"> execute()</code> method.</p><p>The SQL statement itself then counts the number of rows in the<code class="literal"> pwdb</code> table that contain the given username and (hashed) password and retrieves the result. The result is a single row containing a single value, the number of matching rows. If this is one, we have a valid username/password combination, otherwise we don't. We do not discriminate between the cases where the username is unknown or whether there is more than a single row containing the same username. This is because the latter situation is unlikely to happen because of the<code class="literal"> unique</code> constraint on the username column.<a id="id180" class="indexterm"/>
</p></div><div class="section" title="Have a go hero adding new username/passwords"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Have a go hero adding new username/passwords</h2></div></div></div><p>Our<code class="literal"> LogonDB</code> class does not yet have a method to add a new username/password combination to the database. How would you implement one?</p><p>Hint: You need to provide both an exposed method that offers a page with a form where one can enter a new username and password and a method that may act as an action attribute in a<code class="literal">&lt;form&gt;</code> element and that is passed the username and password as parameters.</p><p>Note that this method has to check not only that the user is authenticated but also that the user that adds the new username/password is the admin, otherwise everyone could add new accounts! A sample implementation is already provided in<code class="literal"> logondb.py</code>.</p></div><div class="section" title="Tasklist II storing tasks in a database"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>Tasklist II storing tasks in a database</h2></div></div></div><p>Now that we have seen how we may use a database engine to store persistent data and how to access this data from a CherryPy application, let's apply this new knowledge to the tasklist application we designed in the previous chapter. Of course, there is more to an application than storing data and we will also revamp the user interface in order to make it more responsive and slightly simpler to maintain.<a id="id181" class="indexterm"/>
</p><div class="section" title="Improving interactivity with AJAX"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Improving interactivity with AJAX</h3></div></div></div><p>When you look at the difference between applications that are standalone on a PC versus a web application, you might notice few differences at a first glance. However, if you look more closely, there is a major difference: In the standalone application when something changes in the display, only those onscreen elements are redrawn that are actually modified.<a id="id182" class="indexterm"/>
</p><p>In traditional web pages, this is completely different. Clicking a button that changes the sort order of a list, for example, might not only retrieve and redraw that list again, but would retrieve a complete page, including all side bars, navigation headers, advertisements, and what not.</p><p>If that unmodified content is slow to retrieve over the internet, the whole web page might feel sluggish, even more so if the whole webpage is waiting for the arrival of the last piece of information to display itself in its full glory. When web pages evolved to mimic applications, this difference in the interactive experience quickly became a nuisance and people started thinking about solutions.</p><p>One of the most prominent of those solutions is AJAX. It's an abbreviation for asynchronous JavaScript and XML, that is, a method to retrieve data by using the browser's built-in JavaScript capabilities. Nowadays, every browser supports AJAX and the jQuery library smoothes out most browser inconsistencies. The XML part in the name is no longer relevant as the data that might be retrieved with an AJAX call might be just about anything: besides XML and its close cousin HTML,<span class="strong"><strong> JavaScript Object Notation</strong></span> (JSON) is a popular format to transmit data that might be processed even more simply than XML by the JavaScript interpreter in the browser.<a id="id183" class="indexterm"/>
</p><p>The asynchronous bit in the AJAX name is still relevant, however: most AJAX calls that retrieve data return immediately without waiting for the result. However, they do call a function when the data retrieval is complete. This ensures that other parts of the application are not stalled and that the overall interactive experience of the web application can be improved.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action getting the time with AJAX"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Time for action getting the time with AJAX</h1></div></div></div><p>Enter the following code and run it. If you point your web browser to the familiar<a class="ulink" href="http://localhost:8080"> http://localhost:8080</a> address, you will see something similar to the picture below with the time changing every five seconds or so. (The code is also available as<code class="literal"> timer.py)</code>
</p><div class="mediaobject"><img src="images/3746_4_1.jpg" height="52" alt="Time for action getting the time with AJAX"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>What just happened?</h2></div></div></div><p>Our small CherryPy application offers just two methods (both highlighted in the code). The<code class="literal"> index()</code> method returns a minimalistic HTML page with some static text and a small piece of JavaScript that takes care of retrieving the current time from the server. It also features a<code class="literal"> time()</code> method that simply returns the current time as plain text.<a id="id184" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/timer.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import cherrypy
import os.path
from time import asctime
current_dir = os.path.dirname(os.path.abspath(__file__))
class Root(object):
	@cherrypy.expose<span class="strong"><strong>
	def index(self):</strong></span>
		return '''&lt;html&gt;
		&lt;head&gt;&lt;script type="text/javascript" src="/jquery.js" &gt;&lt;/script&gt;&lt;/
head&gt;
		&lt;body&gt;&lt;h1&gt;The current time is ...&lt;/h1&gt;&lt;div id="time"&gt;&lt;/div&gt;
		&lt;script type="text/javascript"&gt;<span class="strong"><strong>
		window.setInterval(function(){$.ajax({url:"time",cache:false,success:
function(data,status,request){
			$("#time").html(data);</strong></span>
		}});},5000);
		&lt;/script&gt;
		&lt;/body&gt;
		&lt;/html&gt;'''
	@cherrypy.expose<span class="strong"><strong>
	def time(self,_=None):</strong></span>
		return asctime()
cherrypy.quickstart(Root(),config={
	'/jquery.js':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_
dir,"static","jquery","jquery-1.4.2.js")
	}
})
</pre></div><p>The magic is in that small piece of JavaScript (highlighted). This script is executed once the static page is loaded and it calls the<code class="literal"> setInterval()</code> method of the<code class="literal"> window</code> object. The arguments to the<code class="literal"> setInterval()</code> method are an anonymous function and a time interval in milliseconds. We set the time interval to five seconds. The function passed to<code class="literal"> setInterval()</code> is called at the end of each interval.<a id="id185" class="indexterm"/>
</p><p>In this example, we pass an anonymous function to<code class="literal"> setInterval()</code> that relies on jQuery's<code class="literal"> ajax()</code> function to retrieve the time. The<code class="literal"> ajax()</code> function's only argument is an object that may contain numerous options. The<code class="literal"> url</code> option tells which URL to use to retrieve the data from, in this case, the relative URL<code class="literal"> time</code> (relative to the page that serves the content the script is embedded in,<code class="literal"> /</code>, so it actually refers to<code class="literal"> http://localhost:8080/time)</code>.</p><p>The<code class="literal"> cache</code> option is set to<code class="literal"> false</code> to prevent the browser from using a cached result when instructed to get the time URL it has seen already. This is ensured by the underlying JavaScript library by appending an extra<code class="literal"> _</code> parameter (that is the name of this parameter which consists of a single underscore) to the URL. This extra parameter contains a random number, so the browser will regard each call as a call to a new URL. The<code class="literal"> time()</code> method is defined to accept this parameter because otherwise CherryPy would raise an exception, but the contents of the parameter are ignored.</p><p>The<code class="literal"> success</code> option is set to a function that will be called when the data is successfully received. This function will receive three arguments when called: the data that was retrieved by the<code class="literal"> ajax()</code> function, the status, and the original request object. We will only use the data here.</p><p>We select the<code class="literal">&lt;div&gt;</code> element with the<code class="literal"> time</code> ID and replace its contents by passing the data to its<code class="literal"> html()</code> method. Note that even though the<code class="literal"> time()</code> method just produces text, it could just as easily have returned text containing some markup this way.</p><p>We explicitly instructed the<code class="literal"> ajax()</code> function not to cache the result of the query, but instead we could also decorate our<code class="literal"> time()</code> method with CherryPy's<code class="literal"> expires</code> tool. This would instruct the<code class="literal"> time()</code> method to insert the correct http headers in response to instruct the browser not to cache the results. This is illustrated in the following code (available in<code class="literal"> timer2.py):</code>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.tools.expires(secs=0,force=True)
	@cherrypy.expose
	def time(self,_=None):
		return asctime()
</pre></div><p>Using the<code class="literal"> @cherrypy.tools.expires</code> decorator means we do not have to instruct the<code class="literal"> ajax()</code> method not to cache the result, which gives us the option to use a shortcut method. The JavaScript code may then be rewritten to use jQuery's<code class="literal"> load()</code> method, shown as follows:</p><div class="informalexample"><pre class="programlisting">
&lt;script type="text/javascript"&gt;
window.setInterval(function(){$("#time").load("time");},5000);
&lt;/script&gt;
</pre></div><p>The<code class="literal"> load()</code> method is passed the URL where it will retrieve the data and, upon success, will replace the contents of the selected<code class="literal"> DOMelement</code> with the data it received.<a id="id186" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"/>Note</h3><p>jQuery provides many AJAX shortcut methods and all these methods share a common set of defaults that may be set using the<code class="literal"> ajaxSetup()</code> function. For example, to make sure all AJAX methods will not cache any returned result, we could call it like this:<code class="literal"> $.ajaxSetup({cache:false})</code>;</p></div></div><div class="section" title="Redesigning the Tasklist application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Redesigning the Tasklist application</h2></div></div></div><p>The tasklist application will consist of two parts: an authentication part for which we will reuse the<code class="literal"> LogonDB</code> class and new<code class="literal"> TaskApp</code> class. The<code class="literal"> TaskApp</code> class will implement the methods necessary to deliver the page with an overview of all tasks for the authenticated user plus additional methods to respond to AJAX requests.<a id="id187" class="indexterm"/>
</p><p>Instead of a filesystem, SQLite will be used to store the tasks for all users. Note that this is a separate database from the one used to store usernames and passwords. Such a setup allows us to keep the authentication functionality separate from other concerns, allowing for easier reuse. Once the user is authenticated, we do, of course, use his/her username to identify the tasks belonging to him/her.</p><p>Access to the task database will be encapsulated in a<code class="literal"> tasklistdb</code> module. It provides classes and methods to retrieve, add, and modify tasks for a given user. It is not concerned with checking access permission, as this is the responsibility of the<code class="literal"> TaskApp</code> class. You can picture this separation as a two layer model, the top layer checking user credentials and serving content, and the bottom layer actually interfacing with a database.<a id="id188" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746OS_04_02.jpg" width="134" alt="Redesigning the Tasklist application"/></div></div><div class="section" title="Database design"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Database design</h2></div></div></div><p>The design of our task database (the database<span class="emphasis"><em> schema)</em></span> is very straightforward. It consists of a single table, which contains columns to define a task.<a id="id189" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col width="1.03055555555556" style="text-align: left"/><col width="1.00277777777778" style="text-align: left"/><col width="1.00277777777778" style="text-align: left"/><col width="1.00277777777778" style="text-align: left"/><col width="1.00277777777778" style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Task</p>
</th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th style="text-align: left" valign="bottom">
<p>task_id</p>
</th><th style="text-align: left" valign="bottom">
<p>description</p>
</th><th style="text-align: left" valign="bottom">
<p>duedate</p>
</th><th style="text-align: left" valign="bottom">
<p>completed</p>
</th><th style="text-align: left" valign="bottom">
<p>user_id</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>integer</p>
<p>primary key</p>
<p>autoincrement</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>Most columns do not have a specific type defined, as SQLite will let us store anything in a column. Furthermore, most columns do not have special constraints except for the<code class="literal"> task_id</code> column that we designate to be the primary key. We do explicitly type the<code class="literal"> task_id</code> column as an integer and designate it as<code class="literal"> autoincrement</code>. This way, we do not have to set the value of this column explicitly, but a new unique integer will be inserted for us every time we add a new task to the table.<a id="id190" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action creating the task database"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Time for action creating the task database</h1></div></div></div><p>First, let us take some time to familiarize with the steps necessary to create a new database from Python.<a id="id191" class="indexterm"/>
</p><p>Enter the following code and run it (It is also available as<code class="literal"> taskdb1.py)</code>.</p><p>
<span class="strong"><strong>Chapter4/taskdb1.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import sqlite3
database=':memory:'
connection = sqlite3.connect(database)<span class="strong"><strong>
cursor=connection.executescript('''</strong></span>
create table if not exists task (
	task_id integer primary key autoincrement,
	description,
	duedate,
	completed,
	user_id
);
''')
connection.commit()<span class="strong"><strong>
sql = '''insert into task (description,duedate,completed,user_id) values(?,?,?,?)'''</strong></span>
cursor.execute(sql,('work' 			,'2010-01-01',None,'alice'))
cursor.execute(sql,('more work' 	,'2010-02-01',None,'alice'))
cursor.execute(sql,('work' 			,'2010-03-01',None,'john'))
cursor.execute(sql,('even more work','2010-04-01',None,'john'))
connection.commit()
connection.close()
</pre></div><p>It will create a temporary database in memory and defines a task table. It also populates this table with a number of tasks using INSERT statements.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>What just happened?</h2></div></div></div><p>After establishing a connection to the database, the first task is to create the<code class="literal"> task</code> table (highlighted). Here we use the<code class="literal"> executescript()</code> method of the<code class="literal"> connection</code> object, because this method allows us to pass more than one SQL statement in one go. Here our database schema consists of a single<code class="literal"> create</code> statement so the<code class="literal"> execute()</code> method would do just as well, but normally when creating a database, we create a number of tables and then passing all necessary SQL statements together is very convenient.<a id="id192" class="indexterm"/>
</p><p>When you look at the<code class="literal"> create</code> statement, you may notice it features a<code class="literal"> if not exists</code> clause. This is completely redundant in this example because a freshly opened in-memory database is always empty, but should our database reside on disk, it might contain all the tables we want already. Once we have created the table, we commit our changes to the database with the<code class="literal"> commit()</code> method.</p><p>The second highlighted line shows how we may create an insert statement that will insert new records in the task table. The values we will insert are placeholders, each represented by a question mark. In the next four lines, we execute this insert statement and supply a tuple of values that will be inserted in place of those placeholders.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action retrieving information with select statements"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Time for action retrieving information with select statements</h1></div></div></div><p>In SQL, the<code class="literal"> select</code> statement can be used to retrieve records from a database. How would you express a query to retrieve all tasks belonging to the user john?<a id="id193" class="indexterm"/>
</p><p>Answer:<code class="literal"> select * from task where user_id = 'john'</code>
</p><p>We may implement this in Python as follows (only relevant lines shown, complete implementation is available as<code class="literal"> taskdb2.py):</code>
</p><p>
<span class="strong"><strong>Chapter4/tasktdb2.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
connection.row_factory = sqlite3.Row
sql = """select * from task where user_id = 'john'"""<span class="strong"><strong>
cursor.execute(sql)</strong></span>
tasks = cursor.fetchall()
for t in tasks:
	print(t['duedate'],t['description'])
</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>What just happened?</h2></div></div></div><p>The first line in the code is normally placed just after establishing a connection to the database and ensures that any row returned from a<code class="literal"> fetchone()</code> or<code class="literal"> fetchall()</code> method are not plain tuples, but<code class="literal"> sqlite3.Row</code> objects. These objects behave just like tuples, but their fields can be indexed by the name of the column they represent as well.<a id="id194" class="indexterm"/>
</p><p>The query is executed by passing it to the<code class="literal"> execute()</code> method of the cursor attribute (highlighted) and the results are then retrieved with the<code class="literal"> fetchall()</code> method that will return a list of tuples, each tuple representing a matching record, its elements equal to the columns. We print some of those elements by indexing the tuples with the column names we are interested in.</p><p>When<code class="literal"> taskdb2.py</code> is run, the output will show a list of task records, each with a date and a description:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>
C:\Tasklist II&gt;python taskdb2.py
2010-03-01 work
2010-04-01 even more work</strong></span>
</pre></div></div><div class="section" title="Pop quiz using variable selection criteria"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Pop quiz using variable selection criteria</h2></div></div></div><p>Most of the time we would like to pass the<code class="literal"> user_id</code> to match as a variable. As we saw in the insert statements used in<code class="literal"> taskdb1.py</code>, it is possible to construct a query using<code class="literal"> ?</code> as placeholders. This way, we could pass a variable containing a<code class="literal"> user_id</code> to the execute method. How would you refactor the code to select all records for a user whose<code class="literal"> user_id</code> is contained in the variable<code class="literal"> username?</code>
</p></div><div class="section" title="TaskDB interfacing with the database"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>TaskDB interfacing with the database</h2></div></div></div><p>Now we are ready to take on the real implementation of the database interface needed for the tasklist application.<a id="id195" class="indexterm"/>
</p><p>The database interface layer will have to provide functionality to initialize a database and to provide thread-safe ways to create, retrieve, update, and delete tasks (collectively, often called<span class="strong"><strong> CRUD)</strong></span> as well as list all tasks for a given user. The code to do this is contained in two classes,<code class="literal"> Task</code> and<code class="literal"> TaskDB</code> (both available in<code class="literal"> tasklistdb.py). TaskDB</code> encapsulates the connection to the database and contains code to initialize the database as well as methods to retrieve a selection of tasks and to create new tasks. These tasks are implemented as instances of the<code class="literal"> Task</code> class and a<code class="literal"> Task</code> instance may be updated or deleted.<a id="id196" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action connecting to the database"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Time for action connecting to the database</h1></div></div></div><p>Let's first have a look at the<code class="literal"> TaskDB</code> class. It consists of a constructor<code class="literal"> __init__()</code> that takes the filename where the database will reside as a parameter. It calls a private method to initialize this database, and like the<code class="literal"> LogonDB</code> class, creates some storage to hold connection objects for each thread (highlighted). It also defines a<code class="literal"> connect()</code> method that should be called once for each thread and stores a thread-specific connection object. It also sets the<code class="literal"> row_factory</code> attribute of the connection to<code class="literal"> sqlite3.Row</code>. This causes the tuples returned by, for example,<code class="literal"> fetchall()</code> to 	have their fields named after the columns they represent. This makes sense as<code class="literal"> t['user_id']</code> is a lot more self documenting than<code class="literal"> t[1]</code>, for example.<a id="id197" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
class TaskDB:
	def __init__(self,db):<span class="strong"><strong>
		self.data = threading.local()</strong></span>
		self.db = db
		self._initdb()
	def connect(self):
		'''call once for every thread'''
		self.data.conn = sqlite3.connect(self.db)
		self.data.conn.row_factory = sqlite3.Row
</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>What just happened?</h2></div></div></div><p>The code for the<code class="literal"> __init__()</code> method did not initialize any table in the database itself, but delegated this to the<code class="literal"> _initdb()</code> method. This method starts with an underscore so it is private by convention (but by convention only). It is meant to be called just from<code class="literal"> __init__()</code> and initializes the database, if necessary. It opens a connection to the database and executes a multiline statement (highlighted). Here we use<code class="literal"> create if not exists</code> to create the<code class="literal"> task</code> table, but only if it is not already present. So if we start the application for the first time, the database will be completely empty and this statement will create a new table named task. If we start the application again later, this statement will not do anything. Before closing the connection, we commit our changes.</p><p>
<span class="strong"><strong>Chapter4/tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def _initdb(self):
	'''call once to initialize the metabase tables'''
	conn = sqlite3.connect(self.db)<span class="strong"><strong>
	conn.cursor().executescript('''</strong></span>
	create table if not exists task (
		task_id integer primary key autoincrement,
		description,
		duedate,
		completed,
		user_id
	);
	'''
	)
	conn.commit()
	conn.close()
<a id="id198" class="indexterm"/>
</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action storing and retrieving information"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Time for action storing and retrieving information</h1></div></div></div><p>The final part of the<code class="literal"> TaskDB</code> class defines three methods,<code class="literal"> create()</code> that will create a completely new<code class="literal"> Task</code> instance,<code class="literal"> retrieve()</code> that will fetch a task from the<code class="literal"> task</code> table given a<code class="literal"> task_id</code> and return it as a<code class="literal"> Task</code> instance, and<code class="literal"> list()</code> that will return a list of<code class="literal"> task_ids</code> for a given user.<a id="id199" class="indexterm"/>
</p><p>We separated<code class="literal"> retrieve()</code> and<code class="literal"> list()</code> because retrieving an object complete with all its attributes might be quite expensive and not always needed. For example, if we were to select a list with thousands of tasks, we would likely display them as a page of about twenty tasks each. If we were to retrieve complete information for all those tasks, we might have to wait a while, so we might choose to instantiate only a first page-full of them and fetch the rest on an as-needed basis as the users step through the pages. We will encounter this pattern a few more times in this book.</p><p>The<code class="literal"> create()</code> method itself simply passes on all parameters to the<code class="literal"> Task</code> constructor together with the thread local storage that holds the database connection. It returns the resulting<code class="literal"> Task</code> instance.</p><p>The<code class="literal"> retrieve()</code> method takes the username and the ID of the task to retrieve. The username is taken as a sanity check, but not strictly necessary. If a record is found that matches both the<code class="literal"> task_id</code> and the<code class="literal"> username</code>, a<code class="literal"> Task</code> instance is created and returned (highlighted). If no such record could be found, a<code class="literal"> KeyError</code> exception is raised.</p><p>The<code class="literal"> list()</code> method returns a list of<code class="literal"> task_ids</code> for a given user. It constructs this list from the list of tuples returned by taking the first (and only) item from each tuple (highlighted).<a id="id200" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
	def create (self, user=None, id=None, description='', duedate=None, 
completed=None):
		return Task(self.data, user=user, id=id, description=description, 
duedate=duedate, completed=completed)
	def retrieve(self, user,id):
		sql = """select * from task where task_id = ? and user_id = ?"""
		cursor = self.data.conn.cursor()
		cursor.execute(sql,(id,user))
		tasks = cursor.fetchall()
		if len(tasks):<span class="strong"><strong>
			return self.create(user, tasks[0]['task_id'], tasks[0]
['description'], tasks[0]['duedate'], tasks[0]['completed'])
</strong></span>
		raise KeyError('no such task')
	def list(self,user):
		sql = '''select task_id from task where user_id = ?'''
		cursor = self.data.conn.cursor()
		cursor.execute(sql,(user,))<span class="strong"><strong>
		return [row[0] for row in cursor.fetchall()]</strong></span>
</pre></div><p>The constructor for<code class="literal"> Task</code> takes a number of optional parameters together with a mandatory username and a<code class="literal"> taskdb</code> parameter that point to the thread local data that holds the database connections. If the<code class="literal"> duedate</code> parameter is not given, it assigns it the date of today (highlighted).</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>What just happened?</h2></div></div></div><p>The construction of Task instances in the previous code deserves a closer look. Based on the value of the<code class="literal"> id</code> parameter, the constructor can do two things.</p><p>If the<code class="literal"> id</code> is known, this<code class="literal"> Task</code> instance is constructed based on data just retrieved from a database query so there is nothing more to be done as all parameters are already stored as instance variables.</p><p>However, if<code class="literal"> id</code> is not given (or<code class="literal"> None)</code>, we apparently are creating a completely new<code class="literal"> Task</code> that is not already present in the database. Therefore, we have to insert it into the task table using an<code class="literal"> insert</code> statement (highlighted).</p><p>We do not pass a new<code class="literal"> task_id</code> as a value to this<code class="literal"> insert</code> statement, but one will be created for us because we defined the<code class="literal"> task_id</code> column as<code class="literal"> integer primary key autoincrement</code>. This generated number is available from the cursor's<code class="literal"> lastrowid</code> attribute and we store that for later reuse. All this is quite SQLite-specific, for more information, refer to the information box.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"/>Note</h3><p>Only an<code class="literal"> integer primary key</code> column can be defined as<code class="literal"> autoincrement</code> and only an<code class="literal"> integer primary key autoincrement</code> column will mapped to the internal<code class="literal"> rowid</code> column (and that is not even a real column). All this is very useful, but also quite SQLite-specific. More information on this subject can be found on the SQLite FAQ at<a class="ulink" href="http://www.sqlite.org/faq.html"> http://www.sqlite.org/faq.html</a> and in the section on rowid in the SQL reference at<a class="ulink" href="http://www.sqlite.org/lang_createtable.html#rowid"> http://www.sqlite.org/lang_createtable.html#rowid</a>.</p></div><p>
<span class="strong"><strong>Chapter4/tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
class Task:
	def __init__(self,taskdb,user,id=None,description='',duedate=None,
completed=None):
	self.taskdb=taskdb
	self.user=user
	self.id=id
	self.description=description
	self.completed=completed<span class="strong"><strong>
	self.duedate=duedate if duedate != None else date.today().
isoformat()</strong></span>
	if id == None:
		cursor = self.taskdb.conn.cursor()<span class="strong"><strong>
		sql = '''insert into task (description,duedate,completed,user_
id) values(?,?,?,?)'''</strong></span>
		cursor.execute(sql,(self.description,self.duedate,self.
completed,self.user))
		self.id = cursor.lastrowid
		self.taskdb.conn.commit()
</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action updating and deleting information"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Time for action updating and deleting information</h1></div></div></div><p>Updating the record for a<code class="literal"> Task</code> is all about constructing the correct<code class="literal"> update</code> query.<code class="literal"> update</code> will alter any records that match the conditions in the<code class="literal"> where</code> clause. It will change only those columns mentioned in its<code class="literal"> set</code> clause so we start by constructing this<code class="literal"> set</code> clause (highlighted).<a id="id201" class="indexterm"/>
</p><p>Joining a list of parameters and interpolating it into an SQL query might be a bit overdone but if we later want to add an extra attribute, this would be very simple (and our SQL query string now fits on a single line, making it a lot easier to read and typeset).</p><p>Once we have executed the insert, we check the number of rows affected. This value is available as the<code class="literal"> rowcount</code> attribute of the<code class="literal"> cursor</code> object and should be<code class="literal"> 1</code> as we used the unique<code class="literal"> task_id</code> to select the records. If it isn't<code class="literal"> 1</code>, something strange has happened and we roll back the insert and raise an exception. If it went well, we commit our changes.<a id="id202" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def update(self,user):
	params= []
	params.append('description = ?')
	params.append('duedate = ?')
	params.append('completed = ?')
	sql = '''update task set %s where task_id = ? and user_id = ?'''<span class="strong"><strong>
	sql = sql%(",".join(params))</strong></span>
	conn = self.taskdb.conn
	cursor = conn.cursor()
	cursor.execute(sql, (self.description,self.duedate,self.
completed,self.id,user))
	if cursor.rowcount != 1 :
		debug('updated',cursor.rowcount)
		debug(sql)
		conn.rollback()
		raise DatabaseError('update failed')
	conn.commit()
</pre></div><p>To delete a task with a given task ID, all we have to do is execute a<code class="literal"> delete query</code> on the<code class="literal"> task</code> table with an expression in the<code class="literal"> where</code> clause that matches our<code class="literal"> task_id</code>, just like we did for an update. We do check that our delete query affects a single record only (highlighted) and roll back otherwise. This shouldn't happen, but it is better to be safe than sorry.</p><div class="informalexample"><pre class="programlisting">
def delete(self,user):
	sql = '''delete from task where task_id = ? and user_id = ?'''
	conn = self.taskdb.conn
	cursor = conn.cursor()
	cursor.execute(sql,(self.id,user))<span class="strong"><strong>
	if cursor.rowcount != 1:</strong></span>
		conn.rollback()
		raise DatabaseError('no such task')
	conn.commit()
</pre></div><div class="section" title="Testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Testing</h2></div></div></div><p>Developing software without testing it is a little bit like driving a car with your eyes closed: if the road is straight you might get surprisingly far, but chances are you will crash within a few seconds. Testing, in other words, is good.<a id="id203" class="indexterm"/>
</p><p>It does take time, however, to test an application thoroughly, so it makes sense to automate the testing process as much as possible. If tests can be executed easily, it encourages developers to run these tests often. This is desirable when the implementation changes. It can also act as a sanity check just before a new release. So although writing serious tests may sometimes take about as long as writing the code itself, this is a solid investment, as it might prevent many unwelcome surprises if the code is changed or the environment in which the code is deployed is altered.</p><p>There are many aspects of an application that you might like to test, but not all lend themselves to automatic testing, like user interaction (although tools like Selenium can get you quite far. More information on this tool is available at<a class="ulink" href="http://seleniumhq.org/)"> http://seleniumhq.org/)</a>. However, other parts are quite simple to automate.</p><p>Python comes with a<code class="literal"> unittest</code> module that simplifies the task of repeatedly testing small functional units of code. The idea of unit testing is to isolate small chunks of code and define its expected behavior by asserting any number of expectations. If one of those assertions fails, the test fails. (There is much more to unit testing than can be fully covered in this book. Here we cover just the bare minimum to get a taste of the possibilities and we cover a few examples that are intended to give you enough information to understand the test suites supplied with the example code for this book. If you would like to read more on unit testing in Python, a good starting point would be<span class="emphasis"><em> Python Testing</em></span> by<span class="emphasis"><em> Daniel Arbuckle, Packt Publishing</em></span>, 978-1-847198-84-6).</p><p>Python's<code class="literal"> unittest</code> module contains a number of classes and functions that enable us to write and run groups of tests and their associated assertions. For example, say we have a module called<code class="literal"> factorial</code> that defines a function<code class="literal"> fac()</code> to calculate a factorial.</p><p>A factorial of a number n is the product of all numbers from 1 to n inclusive. For example,<code class="literal"> fac(4) = 4 * 3 * 2 * 1 = 24</code>. Zero is an exceptional case as the factorial of 0 = 1. Factorials are only defined for integers &gt;= 0, so we design our code to raise<code class="literal"> ValueError</code> exceptions if the argument<code class="literal"> n</code> is not an<code class="literal"> int</code> or is negative (highlighted). The factorial itself is calculated recursively. If<code class="literal"> n</code> is either zero or one, we return one, otherwise we return the factorial of<code class="literal"> n</code> minus one times<code class="literal"> n:</code>
</p><p>
<span class="strong"><strong>Chapter4/factorial.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def fac(n):<span class="strong"><strong>
	if n &lt; 0 : raise ValueError("argument is negative")
	if type(n) != int : raise ValueError("argument is not an integer")</strong></span>
	if n == 0 : return 1
	if n == 1 : return 1
	return n*fac(n-1)
</pre></div><p>The code is available as<code class="literal"> factorial.py</code>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action testing factorial.py"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Time for action testing factorial.py</h1></div></div></div><p>The test suite to accompany<code class="literal"> factorial.py</code> is called<code class="literal"> test_factorial.py</code>. Run it and you should see output similar to this:<a id="id204" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>
python test_factorial.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s
OK</strong></span>
</pre></div><p>Three tests were executed and apparently everything went ok.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>What just happened?</h2></div></div></div><p>The code in<code class="literal"> test_factorial.py</code> starts by importing both the module we want to test (factorial) and the<code class="literal"> unittest</code> module. Then we define a single class named<code class="literal"> Test</code> (highlighted) derived from<code class="literal"> unittest.TestCase</code>. By deriving from this class, our class will be distinguishable as a test case to the test runner and will provide us with a number of<span class="strong"><strong> assertion</strong></span> methods.</p><p>Our<code class="literal"> Test</code> class may consist of any number of methods. The ones with names starting with<code class="literal"> test_</code> will be recognized as tests by the test runner. Because the names of failing tests will be printed, it is useful to give these tests sensible names reflecting their purpose. Here we define three such methods:<code class="literal"> test_number(), test_zero()</code>, and<code class="literal"> test_illegal()</code>.</p><p>
<span class="strong"><strong>Chapter4/test_factorial.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import unittest
from factorial import fac<span class="strong"><strong>
class Test(unittest.TestCase):</strong></span>
	def test_number(self):
		self.assertEqual(24,fac(4))
		self.assertEqual(120,fac(5))
		self.assertEqual(720,fac(6))
	def test_zero(self):
		self.assertEqual(1,fac(0))
	def test_illegal(self):
		with self.assertRaises(ValueError):
			fac(-4)
		with self.assertRaises(ValueError):
			fac(3.1415)
if __name__ == '__main__':
	unittest.main()
</pre></div><p>
<code class="literal">test_number()</code> tests a number of regular cases to see if our function returns something reasonable. In this case, we check three different numbers and use the<code class="literal"> assertEquals()</code> method inherited from the<code class="literal"> TestCase</code> class to check that the value calculated (passed as the second argument) equals the expected value (the first argument).<a id="id205" class="indexterm"/>
</p><p>
<code class="literal">test_zero()</code> asserts that the special case of zero indeed returns 1. It again uses the<code class="literal"> assertEqual()</code> method to check whether the expected value (1) matches the value returned.</p><p>
<code class="literal">test_illegal()</code> finally asserts that only positive arguments are accepted (or rather it asserts that negative values correctly raise a<code class="literal"> ValueError</code> exception) and that arguments to<code class="literal"> fac()</code> should be<code class="literal"> int</code> or raise a<code class="literal"> ValueError</code> as well.</p><p>It utilizes the method<code class="literal"> assertRaises()</code> provided by<code class="literal"> TestCase. assertRaises()</code> will return an object that can be used as a context manager in a with statement. Effectively, it will catch any exception and check whether it is an expected one. If not, it will flag the test as failed.</p><p>These methods show a familiar pattern in unit testing: a fairly small number of tests check whether the unit behaves correctly in normal cases, while the bulk of the tests are often devoted to special cases (often referred to as edge cases). And, just as important, serious effort is spent on testing that illegal cases are correctly flagged as such.</p><p>The last thing we find in<code class="literal"> test_factorial.py</code> is a call to<code class="literal"> unittest.main()</code>, the test runner. It will look for any defined classes deriving from<code class="literal"> TestCase</code> and run any method that starts with<code class="literal"> test_</code>, tallying the results.</p></div><div class="section" title="Now what have we gained?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Now what have we gained?</h2></div></div></div><p>If we would change, for example, the implementation of<code class="literal"> fac()</code> to something that does not use recursion like the following code, we could rapidly check that it behaves as expected by running<code class="literal"> test_factorial.py</code> again.<a id="id206" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">
from functools import reduce
def fac(n):
	if n &lt; 0 : raise ValueError("factorial of a negative number is not 
defined")
	if type(n) != int : raise ValueError("argument is not an integer")
	if n == 0 : return 1
	if n == 1 : return 1<span class="strong"><strong>
	return reduce(lambda x,y:x*y,range(3,n+1))</strong></span>
</pre></div><p>The special case handling remains the same, but the highlighted line shows that we now calculate the factorial with Python's<code class="literal"> reduce()</code> function from the<code class="literal"> functools</code> module. The<code class="literal"> reduce()</code> function will apply a function to the first pair of items in a list and then again to the result of this and each remaining item. The product of all numbers in a list can be calculated by passing<code class="literal"> reduce()</code> a function that will return the product of two arguments, in this case, our lambda function.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"/>Note</h3><p>More on the<code class="literal"> reduce()</code> function can be found in the documentation of the<code class="literal"> functools</code> module, Python's powerful functional programming library:<a class="ulink" href="http://docs.python.org/py3k/library/functools.html"> http://docs.python.org/py3k/library/functools.html</a>.</p></div></div><div class="section" title="Pop quiz spotting the error"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Pop quiz spotting the error</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Can you anticipate any errors in the previous code? Which test method will fail?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_number()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">test_zero()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">test_illegal()</code></li></ul></div></li></ol></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action writing unit tests for tasklistdb.py"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Time for action writing unit tests for tasklistdb.py</h1></div></div></div><p>Run<code class="literal"> test_tasklistdb.py</code> (provided in the code distribution for this chapter). The output should be a list of test results:<a id="id207" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>
python test_tasklistdb.py
......
----------------------------------------------------------------------
Ran 6 tests in 1.312s
OK</strong></span>
</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>What just happened?</h2></div></div></div><p>Let us look at one of the classes defined in<code class="literal"> test_tasklistdb.py, DBentityTest. DBentityTest</code> contains a number of methods starting with<code class="literal"> test_</code>. These are the actual tests and they verify whether some common operations like retrieving or deleting tasks behave as expected.<a id="id208" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter4/test_tasklistdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
from tasklistdb import TaskDB, Task, AuthenticationError, 
DatabaseError
import unittest
from os import unlink,close
from tempfile import mkstemp
(fileno,database) = mkstemp()
close(fileno)
class DBentityTest(unittest.TestCase):<span class="strong"><strong>
	def setUp(self):</strong></span>
		try:
			unlink(database)
		except:
			pass
		self.t=TaskDB(database)
		self.t.connect()
		self.description='testtask'
		self.task = self.t.create(user='testuser',description=self.
description)
	def tearDown(self):
		self.t.close()
		try:
			unlink(database)
		except:
			pass
	def test_retrieve(self):
		task = self.t.retrieve('testuser',self.task.id)
		self.assertEqual(task.id,self.task.id)
		self.assertEqual(task.description,self.task.description)
		self.assertEqual(task.user,self.task.user)
	def test_list(self):
		ids = self.t.list('testuser')
		self.assertListEqual(ids,[self.task.id])
	def test_update(self):
		newdescription='updated description' self.task.
description=newdescription
		self.task.update('testuser')
		task = self.t.retrieve('testuser',self.task.id)
		self.assertEqual(task.id,self.task.id)
		self.assertEqual(task.duedate,self.task.duedate)
		self.assertEqual(task.completed,self.task.completed)
		self.assertEqual(task.description,newdescription)
	def test_delete(self):
		task = self.t.create('testuser',description='second task')
		ids = self.t.list('testuser')
		self.assertListEqual(sorted(ids),sorted([self.task.id,task.id]))
		task.delete('testuser')
		ids = self.t.list('testuser')
		self.assertListEqual(sorted(ids),sorted([self.task.id]))
		with self.assertRaises(DatabaseError):
			task = self.t.create('testuser',id='short')
			task.delete('testuser')
if __name__ == '__main__':
	unittest.main(exit=False)
</pre></div><p>All these<code class="literal"> test_</code> methods depend on an initialized database containing at least one task and an open connection to this database. Instead of repeating this setup for each test,<code class="literal"> DBentityTest</code> contains the special method<code class="literal"> setUp()</code> (highlighted) that removes any test database lingering around from a previous test and then instantiates a<code class="literal"> TestDB</code> object. This will initialize the database with proper table definitions. Then it connects to this new database and creates a single task object. All tests now can rely upon their initial environment to be the same. The corresponding<code class="literal"> tearDown()</code> method is provided to close the database connection and remove the database file.<a id="id209" class="indexterm"/>
</p><p>The file that is used to store the temporary database is created with the<code class="literal"> mkstemp()</code> function from Python's<code class="literal"> tempfile</code> module and stored in the global variable database. (mkstemp() returns the number of the file handle of the opened as well, which is immediately used to close the file as we are only interested in the name of the file.)</p><p>The<code class="literal"> test_list()</code> and<code class="literal"> test_delete()</code> methods feature a new assertion:<code class="literal"> assertListEqual()</code>. This assertion checks whether two lists have the same items (and in the same order, hence the<code class="literal"> sorted()</code> calls). The<code class="literal"> unittest</code> module contains a whole host of specialized assertions that can be applied for specific comparisons. Check Python's online documentation for the<code class="literal"> unittest</code> module for more details (http://docs.python.org/py3k/library/unittest.html).<a id="id210" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"/>Note</h3><p>Many of the modules we develop in this book come bundled with a suite of unit tests. We will not examine those tests in any detail, but it might be educational to check some of them. You should certainly use them if you experiment with the code as that is exactly what they are for.</p></div></div><div class="section" title="Designing for AJAX"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Designing for AJAX</h2></div></div></div><p>Using AJAX to retrieve data not only has the potential to make the tasklist application more responsive, but it will also make it simpler. This is achieved because the HTML will be simpler as there will be no need for the many<code class="literal">&lt;form&gt;</code> elements we created to accommodate the various delete and done buttons. Instead, we will simply act on click events bound to buttons and call small methods in our CherryPy application. All these functions have to do is perform the action and return ok, whereas in the previous version of our application, we would have to return a completely new page.<a id="id211" class="indexterm"/>
</p><p>In fact, apart from a number of<code class="literal">&lt;script&gt;</code> elements in the<code class="literal">&lt;head&gt;</code>, the core HTML in the body is rather short (the<code class="literal">&lt;header&gt;</code> element and the extra elements in the<code class="literal">&lt;div&gt;</code> element with a<code class="literal"> taskheader</code> class are omitted for brevity):</p><div class="informalexample"><pre class="programlisting">
&lt;body id="itemlist"&gt;
	&lt;div id="content"&gt;
		&lt;div class="header"&gt;&lt;/div&gt;
		&lt;div class="taskheader"&gt;&lt;/div&gt;
		&lt;div id="items"&gt;&lt;/div&gt;
		&lt;div class="item newitem"&gt;
			&lt;input type="text" class="duedate left editable-date tooltip"
				name="duedate" title="click for a date" /&gt;
			&lt;input type="text" class="description middle tooltip"
				title="click to enter a description" name="description"/&gt;
			&lt;button type="submit" class="add-button"
				name="add" value="Add" &gt;Add&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/body&gt;
</pre></div><p>The<code class="literal">&lt;div&gt;</code> element containing the input fields and a submit button takes up most of the space. It structures the elements that make up the line that allows the user to add new tasks. The<code class="literal">&lt;div&gt;</code> element with the ID<code class="literal"> items</code> will hold a list of tasks and will be initialized and managed by the JavaScript code using AJAX calls.</p><p>The JavaScript code in<code class="literal"> tasklistajax.js</code> serves a number of goals:<a id="id212" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initializing the list of items</li><li class="listitem" style="list-style-type: disc">Styling and enhancing UI elements with interactive widgets (like a<code class="literal"> datepicker)</code></li><li class="listitem" style="list-style-type: disc">Maintaining and refreshing the list of tasks based on button clicks</li></ul></div><p>Let's have a look at<code class="literal"> tasklistajax.js</code>.</p><p>
<span class="strong"><strong>Chapter4/static/js/tasklistajax.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
$.ajaxSetup({cache:false});$.ajaxSetup({cache:false});
function itemmakeup(data,status,req){
	$(".done-button").button( {icons: {primary: 'ui-icon-check' 
}, text:false});
	$(".del-button").button( {icons: {primary: 'ui-icon-trash' }, 
text:false});<span class="strong"><strong>
	$("#items input.duedate").sort(</strong></span>
		function(a,b){return $(a).val() &gt; $(b).val() ? 1 : -1;},
		function(){ return this.parentNode; }).addClass("just-sorted");
		// disable input fields and done button on items that are already 
marked as completed
	$(".done .done-button").button( "option", "disabled", true );
	$(".done input").attr("disabled","disabled");
	$( "#items .editable-date" ).datepicker({
		dateFormat: $.datepicker.ISO_8601,
		onClose: function(dateText,datePicker){ if(dateText != '')
{$(this).removeClass("inline-label");}}
	});
};
$(document).ready(function(){
	$(".header").addClass("ui-widget ui-widget-header");<span class="strong"><strong>
	$(".add-button").button( {icons: {primary: 'ui-icon-plusthick' }, 
text:false}).click(function(){</strong></span>
		$(".inline-label").each(function() {
	if($(this).val() === $(this).attr('title')) {
		$(this).val('');
	};
		})
	var dd=$(this).siblings(".duedate").val();
	var ds=$(this).siblings(".description").val();
	$.get("add",{description:ds, duedate:dd},function(data,status,req)
{
		$("#items").load("list",itemmakeup);
	});
		return false; // prevent the normal action of the button click
	});
	$(".logoff-button").button({icons: {primary: 'ui-icon-
closethick'}, text:false}).click(function(){
	location.href = $(this).val();
	return false;
	});
	$(".login-button").button( {icons: {primary: 'ui-icon-play' }, 
text:false});
	$(":text").addClass("textinput");
	$(":password").addClass("textinput");
	$( ".editable-date" ).datepicker({
		dateFormat: $.datepicker.ISO_8601,
		onClose: function(dateText,datePicker){ if(dateText != '')
{$(this).removeClass("inline-label");}}
	});
	// give username field focus (only if it's there)
	$("#username").focus();
	$(".newitem input").addClass("ui-state-highlight");<span class="strong"><strong>
	$(".done-button").live("click",function(){</strong></span>
		var item=$(this).siblings("[name='id']").val();
		var done=$(this).siblings(".completed").val();
		$.get("done",{id:item, completed:done},function(data,status,req)
{
			$("#items").load("list",itemmakeup);
		});
		return false;
	});<span class="strong"><strong>
	$(".del-button").live("click",function(){</strong></span>
		var item=$(this).siblings("[name='id']").val();
		$.get("delete",{id:item},function(data,status,req){
			$("#items").load("list",itemmakeup);
		});
		return false;
	});<span class="strong"><strong>
	$("#items").load("list",itemmakeup); // get the individual task 
items</strong></span>
});
</pre></div><p>The first line establishes the defaults for all AJAX calls that we will use. It makes sure that the browser will not cache any results.<a id="id213" class="indexterm"/>
</p><p>Initializing the list of items once the page is loaded is done in the final highlighted line of code. It calls the<code class="literal"> load()</code> method with a URL that will be handled by our application and will return a list of tasks. If the call to<code class="literal"> load()</code> is successful, it will not only insert this data in the selected<code class="literal">&lt;div&gt;</code> element, but also call the function<code class="literal"> itemmakeup()</code> passed to it as a second argument. That function,<code class="literal"> itemmakeup()</code>, is defined in the beginning of the file. It will style any<code class="literal">&lt;button&gt;</code> element with a<code class="literal"> done-button</code> or<code class="literal"> del-button</code> class with a suitable icon. We do not add any event handlers to those buttons here, which is done elsewhere as we will see shortly.</p><p>Next, we use the<code class="literal"> sort</code> plugin to sort the items (highlighted), that is, we select any input field with the<code class="literal"> duedate</code> class that are children of the<code class="literal">&lt;div&gt;</code> element with the ID<code class="literal"> items</code> (we do not want to consider input fields that are part of the new item div for example).</p><p>The sort plugin is available as sort.js and is based on code by James Padolsey:<a class="ulink" href="http://james.padolsey.com/javascript/sorting-elements-with-jquery/"> http://james.padolsey.com/javascript/sorting-elements-with-jquery/</a>. The plugin will sort any list of HTML elements and takes two arguments. The first argument is a comparison function that will return either 1 or -1 and the second argument is a function that when given an element will return the element that should actually be moved around. This allows us to compare the values of child elements while swapping the parent elements they are contained in.</p><p>For example, here we compare the due dates. That is, the content of the selected<code class="literal">&lt;input&gt;</code> elements, as retrieved by their<code class="literal"> val()</code> method, but we sort not the actual input fields but their parents, the<code class="literal">&lt;div&gt;</code> elements containing all elements that make up a task.</p><p>Finally,<code class="literal"> itemmakeup()</code> makes sure any button marked with a<code class="literal"> done</code> class is disabled as is any input element with that class to prevent completed tasks from being altered and changes any input element with an<code class="literal"> editable-date</code> class into a datapicker widget to allow the user to choose a completion date before marking a task as done.</p><div class="section" title="Click handlers"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Click handlers</h3></div></div></div><p>Besides styling elements, the<code class="literal"> $(document).ready()</code> function adds click handlers to the add, done, and delete buttons (highlighted).</p><p>Only one add button is created when the page is created, so we can add a click handler with the<code class="literal"> click()</code> method. However, new done and delete buttons may appear each time the list of items is refreshed. To ensure that freshly appearing buttons that match the same selection criteria receive the same event handler as the ones present now, we call the<code class="literal"> live()</code> method.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"/>Note</h3><p>jQuery's<code class="literal"> live()</code> method will make sure any event handler is attached to any element that matches some criterion, now or in the future. More on jQuery's event methods can be found at<a class="ulink" href="http://api.jquery.com/category/events/"> http://api.jquery.com/category/events/</a>.</p></div><p>Apart from the way we bind an event handler to a button, the actions associated with a click are similar for all buttons. We retrieve the data we want to pass to the server by selecting the appropriate input elements from among the button's siblings with the<code class="literal"> siblings()</code> method. As each task is represented by its own<code class="literal">&lt;div&gt;</code> element in the list and the<code class="literal">&lt;button&gt;</code> and<code class="literal">&lt;input&gt;</code> elements are all children of that<code class="literal">&lt;div&gt;</code> element, so selecting sibling input elements only ensures that we refer to elements of a single task only.</p><p>To get a better understanding of what we are selecting with the<code class="literal"> siblings()</code> method, take a look at some of the (simplified) HTML that is generated for the list of items:</p><div class="informalexample"><pre class="programlisting">
&lt;div id="items"&gt;
	&lt;div class="item"&gt;&lt;input name=""/&gt; … &lt;button name="done"&gt;&lt;/div
	&lt;div class="item"&gt;&lt;input name=""/&gt; … &lt;button name="done"&gt;&lt;/div
	…
&lt;/div&gt;
</pre></div><p>So each<code class="literal">&lt;div&gt;</code> that represents a task contains a number of<code class="literal">&lt;input&gt;</code> elements and some<code class="literal">&lt;button&gt;</code> elements. The siblings of any<code class="literal">&lt;button&gt;</code> element are the elements within the same<code class="literal">&lt;div&gt;</code> (without the button itself).</p><p>When we have gathered the relevant data from the input elements, this data is then passed to a<code class="literal"> get()</code> call. The<code class="literal"> get()</code> function is another AJAX shortcut that will make an HTTP GET request to the URL given as its first argument (a different URL for each button type). The data passed to the<code class="literal"> get()</code> function is appended to the GET request as parameters. Upon success, the function passed as the third argument to<code class="literal"> get()</code> is called. This is the same<code class="literal"> itemmakeup()</code> function that refreshes the list of items that was used when the page was first loaded.</p></div></div><div class="section" title="The application"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>The application</h2></div></div></div><p>With the JavaScript to implement the interactivity and the means to access the database in place, we still have to define a class that can act as a CherryPy application. It is available as<code class="literal"> taskapp.py</code> and here we show the relevant bits only (Its<code class="literal"> index()</code> method is omitted because it simply delivers the HTML shown earlier).</p><p>
<span class="strong"><strong>Chapter4/taskapp.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
class TaskApp(object):
	def __init__(self,dbpath,logon,logoffpath):
		self.logon=logon
		self.logoffpath=logoffpath<span class="strong"><strong>
		self.taskdb=TaskDB(dbpath)</strong></span>
	def connect(self):
		self.taskdb.connect()
</pre></div><p>The constructor for<code class="literal"> TaskApp</code> stores a reference to a<code class="literal"> LogonDB</code> instance in order to be able to call its<code class="literal"> checkauth()</code> method in exposed methods to authenticate a user. It also stores the<code class="literal"> logoffpath</code>, a URL to a page that will end the user's session. The<code class="literal"> dbpath</code> argument is the filename of the file that holds the tasklist database. It is used to create an instance of<code class="literal"> TaskDB</code>, used in subsequent methods to access the data (highlighted).</p><p>The<code class="literal"> connect()</code> method should be called for each new CherryPy thread and simply calls the corresponding method on the<code class="literal"> TaskDB</code> instance.</p><p>To service the AJAX calls of the application,<code class="literal"> TaskApp</code> exposes four short methods:<code class="literal"> list()</code> to generate a list of tasks,<code class="literal"> add()</code> to add a new task, and<code class="literal"> done()</code> and<code class="literal"> delete()</code> to mark a task as done or to remove a task respectively. All take a dummy argument named<code class="literal"> _</code> (a single underscore) that is ignored. It is added by the AJAX call in the browser to prevent caching of the results.</p><p>
<code class="literal">list()</code> is the longer one and starts out with authenticating the user making the request (highlighted). If the user is logged in, this will yield the username. This username is then passed as an argument to the<code class="literal"> taskdb.list()</code> method to retrieve a list of task IDs belonging to this user.</p><p>With each ID, a<code class="literal"> Task</code> instance is created that holds all information for that task (highlighted). This information is used to construct the HTML that makes up the task as visualized on screen. Finally, all HTML of the individual tasks is joined and returned to the browser.</p><p>
<span class="strong"><strong>Chapter4/taskapp.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def list(self,_=None):<span class="strong"><strong>
	username = self.logon.checkauth()</strong></span>
	tasks = []
	for t in self.taskdb.list(username):<span class="strong"><strong>
		task=self.taskdb.retrieve(username,t)</strong></span>
		tasks.append('''&lt;div class="item %s"&gt;
		&lt;input type="text" class="duedate left" name="duedate" 
value="%s" readonly="readonly" /&gt;
		&lt;input type="text" class="description middle" name="description" 
value="%s" readonly="readonly" /&gt;
		&lt;input type="text" class="completed right editable-date tooltip" 
title="click to select a date, then click done" name="completed" 
value="%s" /&gt;
		&lt;input type="hidden" name="id" value="%s" /&gt;
		&lt;button type="submit" class="done-button" name="done" 
value="Done" &gt;Done&lt;/button&gt;
		&lt;button type="submit" class="del-button" name="delete" 
value="Del" &gt;Del&lt;/button&gt;
		&lt;/div&gt;'''%('notdone' if task.completed==None else 'done',task.
duedate,task.description,task.completed,task.id))
	return '\n'.join(tasks)
</pre></div><p>The other methods are quite similar to each other.<code class="literal"> add()</code> takes<code class="literal"> description</code> and<code class="literal"> duedate</code> as arguments and passes them together with the username it got after authentication of the user to the<code class="literal"> create()</code> method of the<code class="literal"> TaskDB</code> instance. It returns 'ok' to indicate success. (Note that an empty string would do just as well: it's the return code that matters, but this makes it more obvious to anyone reading the code).</p><p>The<code class="literal"> delete()</code> method (highlighted) has one relevant argument,<code class="literal"> id</code>. This ID is used together with the username to retrieve a<code class="literal"> Task</code> instance. This instance's<code class="literal"> delete()</code> method is then called to remove this task from the database.</p><p>The<code class="literal"> done()</code> method (highlighted) also takes an<code class="literal"> id</code> argument together with<code class="literal"> completed</code>. The latter either holds a date or is empty, in which case it is set to today's date. A<code class="literal"> Task</code> instance is retrieved in the same manner as for the<code class="literal"> delete()</code> method, but now its<code class="literal"> completed</code> attribute is set with the contents of the argument of the same name and its<code class="literal"> update()</code> method is called to synchronize this update with the database.</p><p>
<span class="strong"><strong>Chapter4/taskapp.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose<span class="strong"><strong>
def add(self,description,duedate,_=None):</strong></span>
	username = self.logon.checkauth()
	task=self.taskdb.create(user=username, description=description, 
duedate=duedate)
	return 'ok'
@cherrypy.expose<span class="strong"><strong>
def delete(self,id,_=None):</strong></span>
	username = self.logon.checkauth()
	task=self.taskdb.retrieve(username,id)
	task.delete(username)
	return 'ok'
@cherrypy.expose<span class="strong"><strong>
def done(self,id,completed,_=None):</strong></span>
	username = self.logon.checkauth()
	task=self.taskdb.retrieve(username,id)
	if completed == "" or completed == "None":
		completed = date.today().isoformat()
	task.completed=completed
	task.update(username)
	return 'ok'
</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Time for action putting it all together</h1></div></div></div><p>Now that we have all the requisite components in place (that is,<code class="literal"> tasklistdb.py, taskapp.py</code>, and<code class="literal"> tasklistajax.js)</code>, it is straightforward to put them together. If you run the code below (available as<code class="literal"> tasklist.py)</code> and point your browser at<a class="ulink" href="http://localhost:8080/"> http://localhost:8080/</a>, you will get a familiar looking login screen and after entering some credentials (username admin and password admin are configured by default) the resulting screen will look almost the same as the application we developed in the previous chapter, as illustrated in the following screenshot:</p><div class="mediaobject"><img src="images/3746_4_3.jpg" height="59" alt="Time for action putting it all together"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>What just happened?</h2></div></div></div><p>For the CherryPy application, we need a root class that can act as the root of the tree of pages we serve the user. Again, we call this class simply<code class="literal"> Root</code> and assign an instance of our<code class="literal"> TaskApp</code> application to the task variable and an instance of the<code class="literal"> LogonDB</code> application to the logon variable (highlighted in the code below). Together with the<code class="literal"> index()</code> method, this will create a tree of pages looking like this:</p><div class="informalexample"><pre class="programlisting">
/
/logon
/task
</pre></div><p>If the user starts on the top-level page or on the logon page, he/she will be redirected to the<code class="literal"> /task</code> page after successful authentication. Below the<code class="literal"> /task</code> page are, of course, the other pages that implement the server side of the AJAX communications like, for example,<code class="literal"> /task/add</code>.</p><p>
<span class="strong"><strong>Chapter4/tasklist.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import cherrypy
from taskapp import TaskApp
from logondb import LogonDB
import os.path
current_dir = os.path.dirname(os.path.abspath(__file__))
theme = "smoothness"
class Root(object):<span class="strong"><strong>
	logon = LogonDB()
	task = TaskApp(dbpath='/tmp/taskdb.db', logon=logon, logoffpath="/
logon/logoff")</strong></span>
	@cherrypy.expose
	def index(self):
		return Root.logon.index(returnpage='/task')
if __name__ == "__main__":
	Root.logon.initdb()<span class="strong"><strong>
	def connect(thread_index):</strong></span>
		Root.task.connect()
		Root.logon.connect()
	# Tell CherryPy to call "connect" for each thread, when it starts up
	cherrypy.engine.subscribe('start_thread', connect)
	cherrypy.quickstart(Root(),config={
	'/':
	{ 'log.access_file' : os.path.join(current_dir,"access.log"),
	'log.screen': False,
	'tools.sessions.on': True
	},
	'/static':
	{ 'tools.staticdir.on':True,
	'tools.staticdir.dir':os.path.join(current_dir,"static")
	},
	'/jquery.js':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_
dir,"static","jquery","jquery-1.4.2.js")
	},
	'/jquery-ui.js':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_
dir,"static","jquery","jquery-ui-1.8.1.custom.min.js")
	},
	'/jquerytheme.css':
	{ 'tools.staticfile.on':True,
	'tools.staticfile.filename':os.path.join(current_dir,"static",
"jquery","css",theme,"jquery-ui-1.8.4.custom.css")
	},
	'/images':
	{ 'tools.staticdir.on':True,
	'tools.staticdir.dir':os.path.join(current_dir,"static","jquery",
"css",theme,"images")
	}
})
</pre></div><p>Before the CherryPy application is started in the usual way by calling the<code class="literal"> quickstart()</code> function, we first initialize the authentication database and create a function<code class="literal"> connect()</code> (highlighted). This is the function we will register with CherryPy to execute each time CherryPy starts a new thread. The function will create a connection to the SQLite databases containing the authentication and tasklist data.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Have a go hero refreshing the itemlist on a regular basis"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec14"/>Have a go hero refreshing the itemlist on a regular basis</h1></div></div></div><p>If you were to access your tasklist from home and keep the application open and later access it from, for example, your work, any changes made to the list from work wouldn't be visible at home unless you refreshed the page manually. This is because there is nothing implemented to refresh the list of tasks regularly; it is refreshed only after some action is initiated by clicking a button.<a id="id214" class="indexterm"/>
</p><p>How could you implement a regular refresh? Hint: in the first AJAX example, we encountered JavaScript's<code class="literal"> setInterval()</code> method. Can you devise a way to let it replace the contents of the<code class="literal">&lt;div&gt;</code> element containing the list of tasks using the<code class="literal"> load()</code> method?</p><p>An example implementation is available in<code class="literal"> tasklistajax2.js</code>. You can either rename it to<code class="literal"> tasklistajax.js</code> and run<code class="literal"> tasklist.py</code> or run<code class="literal"> tasklist2.py</code>.<a id="id215" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about using a database to store persistent data.</p><p>Specifically, we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The benefits of using a database engine</li><li class="listitem" style="list-style-type: disc">How to use SQLite, a database engine distributed with Python</li><li class="listitem" style="list-style-type: disc">How to implement a password database</li><li class="listitem" style="list-style-type: disc">How to design and develop a database-driven tasklist application</li><li class="listitem" style="list-style-type: disc">How to implement unit tests with Python's<code class="literal"> unittest</code> module</li><li class="listitem" style="list-style-type: disc">How to make a web application more responsive using AJAX calls</li></ul></div><p>We also discussed how to make a web application respond to mouse clicks and request new data from the server without using<code class="literal">&lt;form&gt;</code> elements but using jQuery's<code class="literal"> click()</code> and<code class="literal"> live()</code> methods.</p><p>Now that we've made the first step in using a database, we're ready to create more elaborate databases designs, consisting of more than a single table, and look at the methods to define relations between these tables which is the topic of the next chapter.</p></div></div>
</body></html>