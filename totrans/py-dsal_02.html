<html><head></head><body>
        

            
                <h1 class="header-title">Python Data Types and Structures</h1>
            

            
                
<p>In this chapter, we are going to examine the Python data types in detail. We have already been introduced to two data types, the string, <kbd>str()</kbd>, and <kbd>list()</kbd>. It is often the case where we want more specialized objects to represent our data. In addition to the built-in types, there are several internal modules that allow us to address common issues when working with data structures. First, we are going to review some operations and expressions that are common to all data types.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Operations and expressions</h1>
            

            
                
<p>There are a number of operations that are common to all data types. For example, all data types, and generally all objects, can be tested for a truth value in some way. The following are values that Python considers <kbd>False</kbd>:</p>
<ul>
<li>The <kbd>None</kbd> type</li>
<li><kbd>False</kbd></li>
<li>An integer, float, or complex zero</li>
<li>An empty sequence or mapping</li>
<li>An instance of a user-defined class that defines a <kbd>__len__()</kbd> or <kbd>__bool__()</kbd> method that returns zero or <kbd>False</kbd></li>
</ul>
<p>All other values are considered <kbd>True</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Boolean operations</h1>
            

            
                
<p>A Boolean operation returns a value of eighter <kbd>True</kbd> or <kbd>False</kbd>. Boolean operations are ordered in priority, so if more than one Boolean operation occurs in an expression, the operation with the highest priority will occur first. The following table outlines the three Boolean operators in descending order of priority:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p>not <kbd>x</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if <kbd>x</kbd> is <kbd>False</kbd>; returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>x</kbd> and <kbd>y</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if both <kbd>x</kbd> and <kbd>y</kbd> are <kbd>True</kbd>; returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>x</kbd> or <kbd>y</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if either <kbd>x</kbd> or <kbd>y</kbd> is <kbd>True</kbd>; returns <kbd>False</kbd> otherwise.</p>
</td>
</tr>
</tbody>
</table>
<p>Both the <kbd>and</kbd> operator and the <kbd>or</kbd> operator use "short-circuiting" when evaluating an expression. This means Python will only evaluate an operator if it needs to. For example, if <kbd>x</kbd> is <kbd>True</kbd> then in an expression <kbd>x</kbd> or <kbd>y</kbd>, the <kbd>y</kbd> does not get evaluated since the expression is obviously <kbd>True</kbd>. In a similar way, in an expression <kbd>x</kbd> and <kbd>y</kbd> where <kbd>x</kbd> is <kbd>False</kbd>, the interpreter will simply evaluate <kbd>x</kbd> and return <kbd>False</kbd>, without evaluating <kbd>y</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Comparison and Arithmetic operators</h1>
            

            
                
<p>The standard arithmetic operators (<kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, <kbd>/</kbd>) work with all Python numeric types. The <kbd>//</kbd> operator gives an integer quotient, (for example, <kbd>3 // 2</kbd> returns <kbd>1</kbd>), the exponent operator is <kbd>x ** y</kbd>, and the modulus operator, given by <kbd>a % b</kbd>, returns the remainder of the division <kbd>a/b</kbd>. The comparison operators (<kbd>&lt;</kbd>, <kbd>&lt;=</kbd>, <kbd>&gt;</kbd>, <kbd>&gt;=</kbd>, <kbd>==</kbd>, and <kbd>!=</kbd>) work with numbers, strings, lists, and other collection objects and return <kbd>True</kbd> if the condition holds. For collection objects, these operators compare the number of elements and the equivalence operator <kbd>== b</kbd> returns <kbd>True</kbd> if each collection object is structurally equivalent, and the value of each element is identical.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Membership, identity, and logical operations</h1>
            

            
                
<p>Membership operators (<kbd>in</kbd>, <kbd>not in</kbd>) test for variables in sequences, such as lists or strings do what you would expect, <kbd>x in y</kbd> returns <kbd>True</kbd> if a variable <kbd>x</kbd> is found in <kbd>y</kbd>. The <kbd>is</kbd> operator compares object identity. For example, the following snippet shows contrast equivalence with object identity:</p>
<div><img class=" image-border" height="163" src="img/image_02_001.png" width="235"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Built-in data types</h1>
            

            
                
<p>Python data types can be divided into three categories: numeric, sequence, and mapping. There is also the <kbd>None</kbd> object that represents a <kbd>Null</kbd>, or absence of a value. It should not be forgotten either that other objects such as classes, files, and exceptions can also properly be considered <em>types</em>; however, they will not be considered here.</p>
<p>Every value in Python has a data type. Unlike many programming languages, in Python you do not need to explicitly declare the type of a variable. Python keeps track of object types internally.</p>
<p>Python built-in data types are outlined in the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Category</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>None</p>
</td>
<td>
<p><kbd>None</kbd></p>
</td>
<td>
<p>The null object.</p>
</td>
</tr>
<tr>
<td>
<p>Numeric</p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>Integer.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>float</kbd></p>
</td>
<td>
<p>Floating point number.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>complex</kbd></p>
</td>
<td>
<p>Complex number.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p>Boolean (True, False).</p>
</td>
</tr>
<tr>
<td>
<p>Sequences</p>
</td>
<td>
<p><kbd>str</kbd></p>
</td>
<td>
<p>String of characters.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>list</kbd></p>
</td>
<td>
<p>List of arbitrary objects.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>Tuple</kbd></p>
</td>
<td>
<p>Group of arbitrary items.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>range</kbd></p>
</td>
<td>
<p>Creates a range of integers.</p>
</td>
</tr>
<tr>
<td>
<p>Mapping</p>
</td>
<td>
<p><kbd>dict</kbd></p>
</td>
<td>
<p>Dictionary of key-value pairs.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>set</kbd></p>
</td>
<td>
<p>Mutable, unordered collection of unique items.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p><kbd>frozenset</kbd></p>
</td>
<td>
<p>Immutable set.</p>
</td>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">None type</h1>
            

            
                
<p>The None type is immutable and has one value, <kbd>None</kbd>. It is used to represent the absence of a value. It is returned by objects that do not explicitly return a value and evaluates to <kbd>False</kbd> in Boolean expressions. It is often used as the default value in optional arguments to allow the function to detect whether the caller has passed a value.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Numeric Types</h1>
            

            
                
<p>All numeric types, apart from <kbd>bool</kbd>, are signed and they are all immutable. Booleans have two possible values, <kbd>True</kbd> and <kbd>False</kbd>. These values are mapped to 1 and 0, respectively. The integer type, <kbd>int</kbd>, represents whole numbers of unlimited range. Floating point numbers are represented by the native double precision floating point representation of the machine. Complex numbers are represented by two floating point numbers. They are assigned using the <kbd>j</kbd> operator to signify the imaginary part of the complex number, for example:</p>
<pre>
a = 2+3j
</pre>
<p>We can access the real and imaginary parts with <kbd>a.real</kbd> and <kbd>a.imag</kbd>, respectively.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Representation error</h1>
            

            
                
<p>It should be noted that the native double precision representation of floating point numbers leads to some unexpected results. For example, consider the following:</p>
<div><img class=" image-border" height="65" src="img/image_02_002.png" width="196"/></div>
<p>This is a result of the fact that most decimal fractions are not exactly representable as a binary fraction, which is how most underlying hardware represents floating point numbers. For algorithms or applications where this may be an issue, Python provides a <kbd>decimal</kbd> module. This module allows for the exact representation of decimal numbers and facilitates greater control properties such as rounding behavior, number of significant digits, and precision. It defines two objects, a <kbd>Decimal</kbd> type, representing decimal numbers, and a <kbd>Context</kbd> type, representing various computational parameters such as precision, rounding, and error handling. An example of its usage can be seen in the following snippet:</p>
<div><img class=" image-border" height="132" src="img/image_02_003.png" width="373"/></div>
<p>Here we have created a global context and set the precision to <kbd>4</kbd>. The <kbd>Decimal</kbd> object can be treated pretty much as you would treat an <kbd>int</kbd> or a <kbd>float</kbd>. They are subject to all the same mathematical operations and can be used as dictionary keys, placed in sets, and so on. In addition, <kbd>Decimal</kbd> objects also have several methods for mathematical operations, such as natural exponents, <kbd>x.exp()</kbd>, natural logarithms, <kbd>x.ln()</kbd>, and base 10 logarithms, <kbd>x.log10()</kbd>.</p>
<p>Python also has a <kbd>fractions</kbd> module that implements a rational number type. The following example shows several ways to create fractions:</p>
<div><img class=" image-border" height="120" src="img/image_02_004.png" width="441"/></div>
<p>It is also worth mentioning here the <kbd>NumPy</kbd> extension. This has types for mathematical objects such as arrays, vectors, and matrixes, and capabilities for linear algebra, calculation of Fourier transforms, eigenvectors, logical operations, and much more.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Sequences</h1>
            

            
                
<p>Sequences are ordered sets of objects indexed by non-negative integers. Lists and tuples are sequences of arbitrary objects, strings are sequences of characters. String, tuple, and range objects are immutable. All sequence types have a number of operations in common. For all sequences, the indexing and slicing operators apply as described in the previous chapter. Note that for the immutable types, any operation will only return a value rather than actually change the value.</p>
<p>All sequences have the following methods:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>len(s)</kbd></p>
</td>
<td>
<p>Number of elements in <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>min(s, [,default=obj, key=func])</kbd></p>
</td>
<td>
<p>The minimum value in <kbd>s</kbd> (alphabetically for strings)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>max(s, [,default=obj, key=func])</kbd></p>
</td>
<td>
<p>Maximum value in <kbd>s</kbd> (alphabetically for strings)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sum(s,[,start=0])</kbd></p>
</td>
<td>
<p>The sum of the elements (returns <kbd>TypeError</kbd> if <kbd>s</kbd> is not numeric)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>all(s)</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if all elements in <kbd>s</kbd> are True (that is, not <kbd>0</kbd>, <kbd>False</kbd>, or  <kbd>Null</kbd>)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>any(s)</kbd></p>
</td>
<td>
<p>Checks whether any item in <kbd>s</kbd> is <kbd>True</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>In addition, all sequences support the following operations:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s + r</kbd></p>
</td>
<td>
<p>Concatenates two sequences of the same type</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s * n</kbd></p>
</td>
<td>
<p>Make <kbd>n</kbd> copies of <kbd>s</kbd>, where <kbd>n</kbd> is an integer</p>
</td>
</tr>
<tr>
<td>
<p><kbd>v1, v2 ..., vn = s</kbd></p>
</td>
<td>
<p>Unpacks n variables from <kbd>s</kbd> to <kbd>v1</kbd>, <kbd>v2</kbd>, and so on</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s[i]</kbd></p>
</td>
<td>
<p>Indexing-returns element <kbd>i</kbd> of <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s[i:j:stride]</kbd></p>
</td>
<td>
<p>Slicing returns elements between <kbd>i</kbd> and <kbd>j</kbd> with optional stride</p>
</td>
</tr>
<tr>
<td>
<p><kbd>x in s</kbd></p>
</td>
<td>
<p>Returns <kbd>True</kbd> if element <kbd>x</kbd> is in <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>x not in s</kbd></p>
</td>
<td>
<p>Returns true if element <kbd>x</kbd> is not in <kbd>s</kbd></p>
</td>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Tuples</h1>
            

            
                
<p>Tuples are immutable sequences of arbitrary objects. They are indexed by integers greater than zero. Tuples are <strong>hashable</strong>, which means we can sort lists of them and they can be used as keys to dictionaries. Syntactically, tuples are just a comma-separated sequence of values; however, it is common practice to enclose them in parentheses:</p>
<pre>
tpl= ('a', 'b', 'c') 
</pre>
<p>It is important to remember to use a trailing comma when creating a tuple with one element, for example:</p>
<pre>
t = ('a',) 
</pre>
<p>Without the trailing comma, this would be interpreted as a string.</p>
<p>We can also create a tuple using the built-in function <kbd>tuple()</kbd>. With no argument, this creates an empty tuple. If the argument to <kbd>tuple()</kbd> is a sequence then this creates a tuple of elements of that sequence, for example:</p>
<div><img class=" image-border" height="35" src="img/image_02_005.png" width="354"/></div>
<p>Most operators, such as those for slicing and indexing, work as they do on lists. However, because tuples are immutable, trying to modify an element of a tuple will give you a <kbd>TypeError.</kbd> We can compare tuples in the same way that we compare other sequences, using the <kbd>==</kbd>, <kbd>&gt;</kbd> and <kbd>&lt;</kbd> operators.</p>
<p>An important use of tuples is to allow us to assign more than one variable at a time by placing a tuple on the left-hand side of an assignment, for example:</p>
<div><img class=" image-border" height="57" src="img/image_02_006.png" width="451"/></div>
<p>We can actually use this multiple assignment to swap values in a tuple, for example:</p>
<div><img class=" image-border" src="img/image_02_007.png"/></div>
<p>A <kbd>ValueError</kbd> will be thrown if the number of values on each side of the assignment are not the same.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Dictionaries</h1>
            

            
                
<p>Dictionaries are arbitrary collections of objects indexed by numbers, strings, or other immutable objects. Dictionaries themselves are mutable; however, their index keys must be immutable. The following table contains all the dictionary methods and their descriptions:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>len(d)</kbd></p>
</td>
<td>
<p>Number of items in <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.clear()</kbd></p>
</td>
<td>
<p>Removes all items from <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.copy()</kbd></p>
</td>
<td>
<p>Makes a shallow copy of <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.fromkeys(s [,value])</kbd></p>
</td>
<td>
<p>Returns a new dictionary with keys from sequence <kbd>s</kbd> and values set to <kbd>value</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.get(k [,v])</kbd></p>
</td>
<td>
<p>Returns <kbd>d[k]</kbd> if found, or else returns <kbd>v</kbd>, or None if <kbd>v</kbd> is not given.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.items()</kbd></p>
</td>
<td>
<p>Returns a sequence of <kbd>key:value</kbd> pairs in <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.keys()</kbd></p>
</td>
<td>
<p>Returns a sequence of keys in <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.pop(k [,default])</kbd></p>
</td>
<td>
<p>Returns <kbd>d[k]</kbd> and removes it from <kbd>d</kbd>. If <kbd>d[k]</kbd> is not found, it returns default or raises <kbd>KeyError</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.popitem()</kbd></p>
</td>
<td>
<p>Removes a random <kbd>key:value</kbd> pair from <kbd>d</kbd> and returns it as a tuple.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.setdefault(k [,v])</kbd></p>
</td>
<td>
<p>Returns <kbd>d[k]</kbd>. If <kbd>d[k]</kbd> is not found, it returns <kbd>v</kbd> and sets <kbd>d[k]</kbd> to <kbd>v</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.update(b)</kbd></p>
</td>
<td>
<p>Adds all objects from <kbd>b</kbd> to <kbd>d</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>d.values()</kbd></p>
</td>
<td>
<p>Returns a sequence of values in <kbd>d</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p>Python dictionaries are the only built-in mapping type and they are similar to hash tables or associative arrays found in other languages. They can be thought of as a mapping from a set of keys to a set of values. They are created using the syntax <kbd>{key:value}</kbd>. For example, the following creates a dictionary mapping words to numerals:</p>
<pre>
d ={'one': 1 , 'two': 2, 'three': 3 } # creates a dictionary 
</pre>
<p>We can add keys and values as follows:</p>
<pre>
d['four']=4 #add an item 
</pre>
<p>Or update multiple values using the following:</p>
<pre>
d.update({'five': 5, 'six': 6}) #add multiple items 
</pre>
<p>When we inspect <kbd>d</kbd>, we get the following:</p>
<div><img class=" image-border" height="39" src="img/image_02_008.png" width="517"/></div>
<p>We can test for the occurrence of a value using the <kbd>in</kbd> operator, for example:</p>
<div><img class=" image-border" height="32" src="img/image_02_009.png" width="163"/></div>
<p>It should be noted that the <kbd>in</kbd> operator, when applied to dictionaries, works in a slightly different way to when it is applied to a list. When we use the <kbd>in</kbd> operator on a list, the relationship between the time it takes to find an element and the size of the list is considered linear. That is, as the size of the list gets bigger, the corresponding time it takes to find an element grows, at most, linearly. The relationship between the time an algorithm takes to run compared to the size of its input is often referred to as its time complexity. We will talk more about this important topic in the next (and subsequent) chapters.</p>
<p>In contrast to the <kbd>list</kbd> object, when the <kbd>in</kbd> operator is applied to dictionaries, it uses a hashing algorithm and this has the effect of the increase in time for each lookup almost independent of the size of the dictionary. This makes dictionaries extremely useful as a way to work with large amounts of indexed data. We will talk more about this important topic of rates of growth hashing in <a href="fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml">Chapter 4</a>, <em>Lists and pointer structures</em>, and <a href="48e9b010-a4c9-4cc3-9ae0-de772639da37.xhtml">Chapter 13</a>, <em>Implementations, applications and tools</em>.</p>
<p>Notice when we print out the <kbd>key:value</kbd> pairs of the dictionary it does so in no particular order. This is not a problem since we use specified keys to look up each dictionary value rather than an ordered sequence of integers as is the case for strings and lists.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Sorting dictionaries</h1>
            

            
                
<p>If we want to do a simple sort on either the keys or values of a dictionary, we can do the following:</p>
<div><img class=" image-border" height="68" src="img/image_02_010.png" width="359"/></div>
<p>Note that the first line in the preceding code sorts the keys according to alphabetical order, and the second line sorts the values in order of integer value.</p>
<p>The <kbd>sorted()</kbd> method has two optional arguments that are of interest: <kbd>key</kbd> and <kbd>reverse</kbd>. The key argument has nothing to do with the dictionary keys, but rather is a way of passing a function to the sort algorithm to determine the sort order. For example, in the following code, we use the <kbd>__getitem__</kbd> special method to sort the dictionary keys according to the dictionary values:</p>
<div><img class=" image-border" height="35" src="img/image_02_011.png" width="352"/></div>
<p>Essentially, what the preceding code is doing is for every <kbd>key</kbd> in <kbd>d</kbd> to use the corresponding value to sort. We can also sort the values according to the sorted order of the dictionary keys. However, since dictionaries do not have a method to return a <kbd>key</kbd> by using its value, the equivalent of the <kbd>list.index</kbd> method for lists, using the optional <kbd>key</kbd> argument to do this is a little tricky. An alternative approach is to use a list comprehension, as the following example demonstrates:</p>
<div><img class=" image-border" height="31" src="img/image_02_012.png" width="382"/></div>
<p>The <kbd>sorted()</kbd> method also has an optional reverse argument, and unsurprisingly, this does exactly what it says, reverses the order of the sorted list, for example:</p>
<div><img class=" image-border" height="37" src="img/image_02_013.png" width="443"/></div>
<p>Now, let's say we are given the following dictionary, English words as keys and French words as values. Our task is to place these string values in correct numerical order:</p>
<pre>
d2 ={'one':'uno' , 'two':'deux', 'three':'trois', 'four': 'quatre', 'five': 'cinq', 'six':'six'}
</pre>
<p>Of course, when we print this dictionary out, it will be unlikely to print in the correct order. Because all keys and values are strings, we have no context for numerical ordering. To place these items in correct order, we need to use the first dictionary we created, mapping words to numerals as a way to order our English to French dictionary:</p>
<div><img class=" image-border" height="35" src="img/image_02_014.png" width="401"/></div>
<p>Notice we are using the values of the first dictionary, <kbd>d</kbd>, to sort the keys of the second dictionary, <kbd>d2</kbd>. Since our keys in both dictionaries are the same, we can use a list comprehension to sort the values of the French to English dictionary:</p>
<div><img class=" image-border" height="36" src="img/image_02_015.png" width="415"/></div>
<p>We can, of course, define our own custom method that we can use as the <kbd>key</kbd> argument to the <kbd>sorted</kbd> method. For example, here we define a function that simply returns the last letter of a string:</p>
<pre>
def corder(string): <br/><br/>   return(string[len(string)-1]) 
</pre>
<p>We can then use this as the <kbd>key</kbd> to our <kbd>sorted</kbd> function to sort each element by its last letter:</p>
<div><img class=" image-border" height="39" src="img/image_02_016.png" width="369"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Dictionaries for text analysis</h1>
            

            
                
<p>A common use of dictionaries is to count the occurrences of like items in a sequence; a typical example is counting the occurrences of words in a body of text. The following code creates a dictionary where each word in the text is used as a key and the number of occurrences as its value. This uses a very common idiom of nested loops. Here we are using it to traverse the lines in a file in an outer loop and the keys of a dictionary on the inner loop:</p>
<pre>
def wordcount(fname): <br/>    try: <br/>        fhand=open(fname) <br/>    except: <br/>        print('File cannot be opened') <br/>        exit() <br/><br/>    count= dict() <br/>    for line in fhand: <br/>        words = line.split() <br/>        for word in words: <br/>            if word not in count: <br/>                count[word] = 1 <br/>            else: <br/>                count[word] += 1 <br/>    return(count) 
</pre>
<p>This will return a dictionary with an element for each unique word in the text file. A common task is to filter items such as these into subsets we are interested in. You will need a text file saved in the same directory as you run the code. Here we have used <kbd>alice.txt</kbd>, a short excerpt from <em>Alice in Wonderland</em>. To obtain the same results, you can download <kbd>alice.txt</kbd> from <a href="http://davejulian.net/bo5630">davejulian.net/bo5630</a>, or use a text file of your own. In the following code, we create another dictionary, <kbd>filtered</kbd>, containing a subset of items from <kbd>count</kbd>:</p>
<pre>
count=wordcount('alice.txt') <br/>filtered = { key:value for key, value in count.items() if value  &lt; 20 and value &gt; 15 } 
</pre>
<p>When we print the filtered dictionary, we get the following:</p>
<div><img class=" image-border" height="39" src="img/image_02_017.png" width="527"/></div>
<p>Note the use of the <strong>dictionary comprehension</strong> used to construct the filtered dictionary. Dictionary comprehensions work in an identical way to the list comprehensions we looked at in <a href="bed519dd-40d8-4bfd-a721-184d8ea37555.xhtml">Chapter 1</a>, <em>Python Objects, Types, and Expressions</em>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Sets</h1>
            

            
                
<p>Sets are unordered collections of unique items. Sets are themselves mutable, we can add and remove items from them; however, the items themselves must be immutable. An important distinction with sets is that they cannot contain duplicate items. Sets are typically used to perform mathematical operations such as intersection, union, difference, and complement.</p>
<p>Unlike sequence types, set types do not provide any indexing or slicing operations. There are also no keys associated with values, as is the case with dictionaries. There are two types of set objects in Python, the mutable <kbd>set</kbd> object and the immutable <kbd>frozenset</kbd> object. Sets are created using comma-separated values within curly braces. By the way, we cannot create an empty set using <kbd>a={}</kbd>, because this will create a dictionary. To create an empty set, we write either <kbd>a=set()</kbd> or <kbd>a=frozenset()</kbd>.</p>
<p>Methods and operations of sets are described in the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Operators</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>len(s)</kbd></p>
</td>
<td/>
<td>
<p>Returns the number of elements in <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.copy()</kbd></p>
</td>
<td/>
<td>
<p>Returns a shallow copy of <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.difference(t)</kbd></p>
</td>
<td>
<p><kbd>s - t- t2 - ...</kbd></p>
</td>
<td>
<p>Returns a set of all items in <kbd>s</kbd> but not in <kbd>t</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.intersection(t)</kbd></p>
</td>
<td/>
<td>
<p>Returns a set of all items in both <kbd>t</kbd> and <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.isdisjoint(t)</kbd></p>
</td>
<td/>
<td>
<p>Returns True if <kbd>s</kbd> and <kbd>t</kbd> have no items in common</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.issubset(t)</kbd></p>
</td>
<td>
<p><kbd>s &lt;= t</kbd></p>
<p><kbd>s &lt; t (s != t)</kbd></p>
</td>
<td>
<p>Returns True if all items in <kbd>s</kbd> are also in <kbd>t</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.issuperset(t)</kbd></p>
</td>
<td>
<p><kbd>s &gt;= t</kbd></p>
<p><kbd>s &gt; t (s != t)</kbd></p>
</td>
<td>
<p>Returns True if all items in <kbd>t</kbd> are also in <kbd>s</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.symmetric_difference(t)</kbd></p>
</td>
<td>
<p><kbd>s ^ t</kbd></p>
</td>
<td>
<p>Returns a set of all items that are in <kbd>s</kbd> or <kbd>t</kbd>, but not both</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.union(t)</kbd></p>
</td>
<td>
<p><kbd>s | t1 | t2 |...</kbd></p>
</td>
<td>
<p>Returns a set of all items in <kbd>s</kbd> or <kbd>t</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>In the preceding table, the parameter <kbd>t</kbd> can be any Python object that supports iteration and all methods are available to both <kbd>set</kbd> and <kbd>frozenset</kbd> objects. It is important to be aware that the operator versions of these methods require their arguments to be sets, whereas the methods themselves can accept any iterable type. For example, <kbd>s - [1,2,3]</kbd>, for any set <kbd>s</kbd>, will generate an unsupported operand type. Using the equivalent <kbd>s.difference([1,2,3])</kbd> will return a result.</p>
<p>Mutable set objects have additional methods, described in the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.add(item)</kbd></p>
</td>
<td>
<p>Adds item to <kbd>s</kbd>. Has no effect if <kbd>item</kbd> is already present.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.clear()</kbd></p>
</td>
<td>
<p>Removes all items from <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.difference_update(t)</kbd></p>
</td>
<td>
<p>Removes all items in <kbd>s</kbd> that are also in <kbd>t</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.discard(item)</kbd></p>
</td>
<td>
<p>Removes <kbd>item</kbd> from <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.intersection_update(t)</kbd></p>
</td>
<td>
<p>Removes all items from <kbd>s</kbd> that are not in the intersection of <kbd>s</kbd> and <kbd>t</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.pop()</kbd></p>
</td>
<td>
<p>Returns and removes an arbitrary item from <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.remove(item)</kbd></p>
</td>
<td>
<p>Removes item from <kbd>s</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.symetric_difference_update(t)</kbd></p>
</td>
<td>
<p>Removes all items from <kbd>s</kbd> that are not in the symmetric difference of <kbd>s</kbd> and <kbd>t</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>s.update(t)</kbd></p>
</td>
<td>
<p>Adds all the items in an iterable object <kbd>t</kbd> to <kbd>s</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates some simple set operations and their results:</p>
<div><img class=" image-border" height="156" src="img/image_02_018.png" width="275"/></div>
<p>Notice that the set object does not care that its members are not all of the same type, as long as they are all immutable. If you try to use a mutable object such as a list or dictionaries in a set, you will receive an unhashable type error. Hashable types all have a hash value that does not change throughout the lifetime of the instance. All built-in immutable types are hashable. All built-in mutable types are not hashable, so they cannot be used as elements of sets or keys to dictionaries.</p>
<p>Notice also in the preceding code that when we print out the union of <kbd>s1</kbd> and <kbd>s2,</kbd> there is only one element with the value <kbd>'ab'</kbd>. This is a natural property of sets in that they do not include duplicates.</p>
<p>In addition to these built-in methods there are a number of other operations that we can perform on sets. For example, to test for membership of a set, use the following:</p>
<div><img class=" image-border" height="72" src="img/image_02_019.png" width="155"/></div>
<p>We can loop through elements in a set using the following:</p>
<div><img class=" image-border" height="69" src="img/image_02_020.png" width="277"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Immutable sets</h1>
            

            
                
<p>Python has an immutable set type called <kbd>frozenset</kbd>. It works pretty much exactly like <kbd>set</kbd> apart from not allowing methods or operations that change values such as the <kbd>add()</kbd> or <kbd>clear()</kbd> methods. There are several ways that this immutability can be useful. For example, since normal sets are mutable and therefore not hashable, they cannot be used as members of other sets. The <kbd>frozenset</kbd>, on the other hand, is immutable and therefore able to be used as a member of a set:</p>
<div><img class=" image-border" height="158" src="img/image_02_021.png" width="400"/></div>
<p>Also the immutable property of <kbd>frozenset</kbd> means we can use it for a <kbd>key</kbd> to a dictionary, for example:</p>
<p><img class=" image-border" height="82" src="img/image_02_022.png" width="564"/></p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Modules for data structures and algorithms</h1>
            

            
                
<p>In addition to the built-in types, there are several Python modules that we can use to extend these built-in types and functions. In many cases, these Python modules may offer efficiency and programming advantages that allow us to simplify our code.</p>
<p>So far, we have looked at the built-in datatypes of strings, lists, sets, and dictionaries as well as the <kbd>decimal</kbd> and <kbd>fractions</kbd> modules. They are often described by the term <strong>abstract data types</strong> (<strong>ADTs</strong>). ADTs can be considered as mathematical specifications for the set of operations that can be performed on data. They are defined by their behavior rather than their implementation. In addition to the ADTs that we have looked at, there are several Python libraries that provide extensions to the built-in datatypes. These will be discussed in the following section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Collections</h1>
            

            
                
<p>The <kbd>collections</kbd> module provides more specialized, high, performance alternatives for the built-in data types as well as a utility function to create named tuples. The following table lists the datatypes and operations of the collections module and their descriptions:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Datatype or operation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>namedtuple()</kbd></p>
</td>
<td>
<p>Creates tuple subclasses with named fields.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>deque</kbd></p>
</td>
<td>
<p>Lists with fast appends and pops either end.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ChainMap</kbd></p>
</td>
<td>
<p>Dictionary like class to create a single view of multiple mappings.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Counter</kbd></p>
</td>
<td>
<p>Dictionary subclass for counting hashable objects.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>OrderedDict</kbd></p>
</td>
<td>
<p>Dictionary subclass that remembers the entry order.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>defaultdict</kbd></p>
</td>
<td>
<p>Dictionary subclass that calls a function to supply missing values.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>UserDict</kbd></p>
<p><kbd>UserList</kbd></p>
<p><kbd>UserString</kbd></p>
</td>
<td>
<p>These three data types are simply wrappers for their underlying base classes. Their use has largely been supplanted by the ability to subclasas their respective base classes directly. Can be used to access the underlying object as an attribute.</p>
</td>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Deques</h1>
            

            
                
<p>Double-ended queues, or deques (usually pronounced <em>decks</em>), are list-like objects that support thread-safe, memory-efficient appends. Deques are mutable and support some of the operations of lists, such as indexing. Deques can be assigned by index, for example, <kbd>dq[1] = z</kbd>; however, we cannot directly slice deques. For example, <kbd>dq[1:2]</kbd> results in a <kbd>TypeError</kbd> (we will look at a way to return a slice from a <kbd>deque</kbd> as a list shortly).</p>
<p>The major advantage of deques over lists is that inserting items at the beginning of a deque is much faster than inserting items at the beginning of a list, although inserting items at the end of a <kbd>deque</kbd> is very slightly slower than the equivalent operation on a list. Deques are thread, safe and can be serialized using the <kbd>pickle</kbd> module.</p>
<p>A useful way of thinking about deques is in terms of populating and consuming items. Items in deques are usually populated and consumed sequentially from either end:</p>
<div><img class=" image-border" height="171" src="img/image_02_023.png" width="453"/></div>
<p>We can use the <kbd>pop()</kbd> and <kbd>popleft()</kbd> methods for consuming items in the <kbd>deque</kbd>, for example:</p>
<div><img class=" image-border" height="109" src="img/image_02_024.png" width="442"/></div>
<p>We can also use the <kbd>rotate(n)</kbd> method to move and rotate all items of <em>n</em> steps to the right for positive values of the integer <em>n</em>, or left for negative values of n the left, using positive integers as the argument, for example:</p>
<div><img class=" image-border" height="118" src="img/image_02_025.png" width="405"/></div>
<p>Note that we can use the <kbd>rotate</kbd> and <kbd>pop</kbd> methods to delete selected elements. Also worth knowing is a simple way to return a slice of a deque, as a list, which can be done as follows:</p>
<div><img class=" image-border" height="71" src="img/image_02_026.png" width="400"/></div>
<p>The <kbd>itertools.islice</kbd> method works in the same way that slice works on a list, except rather than taking a list for an argument, it takes an iterable and returns selected values, by start and stop indices, as a list.</p>
<p>A useful feature of deques is that they support a <kbd>maxlen</kbd> optional parameter that restricts the size of the <kbd>deque</kbd>. This makes it ideally suited to a data structure known as a <strong>circular buffer</strong>. This is a fixed-size structure that is effectively connected end to end and they are typically used for buffering data streams. The following is a basic example:</p>
<pre>
dq2=deque([],maxlen=3) <br/>for i in range(6): <br/>    dq2.append(i) <br/>    print(dq2) 
</pre>
<p>This prints out the following:</p>
<div><img class=" image-border" height="80" src="img/image_02_027.png" width="182"/></div>
<p>In this example, we are populating from the right and consuming from the left. Notice that once the buffer is full, the oldest values are consumed first, and values are replaced from the right. We will look at circular buffers again in <a href="fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml">Chapter 4</a>, <em>Lists and Pointer Structures</em>, by implementing circular lists.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">ChainMaps</h1>
            

            
                
<p>The <kbd>collections.chainmap</kbd> class was added in Python 3.2 and it provides a way to link a number of dictionaries, or other mappings, so that they can be treated as one object. In addition, there is a <kbd>maps</kbd> attribute, a <kbd>new_child()</kbd> method, and a <kbd>parents</kbd> property. The underlying mappings for <kbd>ChainMap</kbd> objects are stored in a list and are accessible using the <kbd>maps[<em>i</em>]</kbd> attribute to retrieve the <kbd>ith</kbd> dictionary. Note that even though dictionaries themselves are unordered, ChainMaps are an ordered list of dictionaries. <kbd>ChainMap</kbd> is useful in applications where we are using a number of dictionaries containing related data. The consuming application expects data in terms of a priority, where the same key in two dictionaries is given priority if it occurs at the beginning of the underlying list. <kbd>ChainMap</kbd> is typically used to simulate nested contexts such as when we have multiple overriding configuration settings. The following example demonstrates a possible use case for <kbd>ChainMap</kbd>:</p>
<div><img class=" image-border" height="176" src="img/image_02_028.png" width="618"/></div>
<p>The advantage of using ChainMaps, rather than just a dictionary, is that we retain previously set values. Adding a child context overrides values for the same key, but it does not remove it from the data structure. This can be useful for when we may need to keep a record of changes so that we can easily roll back to a previous setting.</p>
<p>We can retrieve and change any value in any of the dictionaries by providing the <kbd>map()</kbd> method with an appropriate index. This index represents a dictionary in the ChainMap. Also, we can retrieve the parent setting, that is, the default settings, by using the <kbd>parents()</kbd> method:</p>
<div><img class=" image-border" height="234" src="img/image_02_029.png" width="630"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Counter objects</h1>
            

            
                
<p>Counter is a subclass of a dictionary where each dictionary <kbd>key</kbd> is a hashable object and the associated value is an integer count of that object. There are three ways to initialize a counter. We can pass it any sequence object, a dictionary of <kbd>key:value</kbd> pairs, or a tuple of the format <kbd>(object = value, ...)</kbd>, for example:</p>
<div><img class=" image-border" height="90" src="img/image_02_030.png" width="641"/></div>
<p>We can also create an empty counter object and populate it by passing its <kbd>update</kbd> method an iterable or a dictionary, for example:</p>
<div><img class=" image-border" height="33" src="img/image_02_031.png" width="594"/></div>
<p>Notice how the <kbd>update</kbd> method adds the counts rather than replacing them with new values. Once the counter is populated, we can access stored values in the same way we would for dictionaries, for example:</p>
<div><img class=" image-border" height="118" src="img/image_02_032.png" width="488"/></div>
<p>The most notable difference between counter objects and dictionaries is that counter objects return a zero count for missing items rather than raising a <kbd>key</kbd> error, for example:</p>
<div><img class=" image-border" height="156" src="img/image_02_033.png" width="335"/></div>
<p>We can create an iterator out of a <kbd>Counter</kbd> object by using its <kbd>elements()</kbd> method. This returns an iterator where counts below one are not included and the order is not guaranteed. In the following code, we perform some updates, create an iterator from <kbd>Counter</kbd> elements, and use <kbd>sorted()</kbd> to sort the keys alphabetically:</p>
<div><img class=" image-border" height="82" src="img/image_02_034.png" width="331"/></div>
<p>Two other Counter methods worth mentioning are <kbd>most_common()</kbd> and <kbd>subtract()</kbd>. The most common method takes a positive integer argument that determines the number of most common elements to return. Elements are returned as a list of <kbd>(key ,value)</kbd> tuples. The <kbd>subtract</kbd> method works exactly like update except instead of adding values, it subtracts them, for example:</p>
<div><img class=" image-border" height="30" src="img/image_02_035.png" width="123"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Ordered dictionaries</h1>
            

            
                
<p>The important thing about ordered dictionaries is that they remember the insertion order, so when we iterate over them, they return values in the order they were inserted. This is in contrast to a normal dictionary, where the order is arbitrary. When we test to see whether two dictionaries are equal, this equality is only based on their keys and values; however, with an <kbd>OrderedDict</kbd>, the insertion order is also considered An equality test between two OrderedDicts with the same keys and values but a different insertion order will return <kbd>False</kbd>:</p>
<div><img class=" image-border" height="54" src="img/image_02_036.png" width="472"/></div>
<p>Similarly, when we add values from a list using <kbd>update</kbd>, the <kbd>OrderedDict</kbd> will retain the same order as the list. This is the order that is returned when we iterate the values, for example:</p>
<div><img class=" image-border" height="93" src="img/image_02_037.png" width="398"/></div>
<p>The <kbd>OrderedDict</kbd> is often used in conjunction with the sorted method to create a sorted dictionary. For example, in the following example we use a <kbd>lambda</kbd> function to sort on the values, here we use a numerical expression to sort the integer values:</p>
<div><img class=" image-border" height="170" src="img/image_02_038.png" width="206"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">defaultdict</h1>
            

            
                
<p>The <kbd>defaultdict</kbd> object is a subclass of <kbd>dict</kbd> and therefore they share methods and operations. It acts as a convenient way to initialize dictionaries. With a <kbd>dict</kbd>, Python will throw a <kbd>KeyError</kbd> when attempting to access a key that is not already in the dictionary. The <kbd>defaultdict</kbd> overrides one method, <kbd>__missing__(key)</kbd>, and creates a new instance variable, <kbd>default_factory</kbd>. With <kbd>defaultdict</kbd>, rather than throw an error, it will run the function, supplied as the <kbd>default_factory</kbd> argument, which will generate a value. A simple use of <kbd>defaultdict</kbd> is to set <kbd>default_factory</kbd> to <kbd>int</kbd> and use it to quickly tally the counts of items in the dictionary, for example:</p>
<div><img class=" image-border" height="138" src="img/image_02_039.png" width="426"/></div>
<p>You will notice that if we tried to do this with an ordinary dictionary, we would get a key error when we tried to add the first key. The <kbd>int</kbd> we supplied as an argument to default <kbd>dict</kbd> is really the function <kbd>int()</kbd> that simply returns a zero. We can, of course, create a function that will determine the dictionary's values. For example, the following function returns <kbd>True</kbd> if the supplied argument is a primary color, that is red, green, or blue, or returns <kbd>False</kbd> otherwise:</p>
<pre>
def isprimary(c):  <br/>    if (c == 'red') or (c == 'blue') or (c == 'green'):  <br/>        return True  <br/>    else: <br/>        return False 
</pre>
<p>We can now create a new <kbd>defaultdict</kbd> object and use the <kbd>isprimary</kbd> function to populate it:</p>
<div><img class=" image-border" height="53" src="img/image_02_040.png" width="572"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Named Tuples</h1>
            

            
                
<p>The <kbd>namedtuple</kbd> method returns a tuple-like object that has fields accessible with named indexes as well as the integer indexes of normal tuples. This allows for code that is, to a certain extent, self-documenting and more readable. It can be especially useful in an application where there is a large number of tuples and we need to easily keep track of what each tuple represents. The <kbd>namedtuple</kbd> inherits methods from <kbd>tuple</kbd> and it is backward-compatible with <kbd>tuple</kbd>.</p>
<p>The field names are passed to the <kbd>namedtuple</kbd> method as comma and/or whitespace separated values. They can also be passed as a sequence of strings. Field names are single strings and they can be any legal Python identifier that does not begin with a digit or an underscore. A typical example is shown here:</p>
<div><img class=" image-border" height="118" src="img/image_02_041.png" width="476"/></div>
<p>The <kbd>namedtuple</kbd> method take two optional Boolean arguments, <kbd>verbose</kbd> and <kbd>rename</kbd>. When <kbd>verbose</kbd> is set to <kbd>True</kbd> then the class definition is printed when it is built. This argument is depreciated in favor of using the <kbd>__source</kbd> attribute. When the <kbd>rename</kbd> argument is set to <kbd>True</kbd> then any invalid field names will be automatically replaced with positional arguments. As an example, we attempt to use <kbd>def</kbd> as a field name. This would normally generate an error, but since we have assigned <kbd>rename</kbd> to <kbd>True</kbd>, the Python interpreter allows this. However, when we attempt to look up the <kbd>def</kbd> value, we get a syntax error, since <kbd>def</kbd> is a reserved keyword. The illegal field name has been replaced by a field name created by adding an underscore to the positional value:</p>
<div><img class=" image-border" height="78" src="img/image_02_042.png" width="561"/></div>
<p>In addition to the inherited tuple methods, the named tuple also defines three methods of its own, <kbd>_make()</kbd> , <kbd>asdict()</kbd>, and <kbd>_replace</kbd>. These methods begin with an underscore to prevent potential conflicts with field names. The <kbd>_make()</kbd> method takes an iterable as an argument and turns it into a named tuple object, for example:</p>
<div><img class=" image-border" height="103" src="img/image_02_043.png" width="536"/></div>
<p>The <kbd>_asdict</kbd> method returns an <kbd>OrderedDict</kbd> with the field names mapped to index keys and the values mapped to the dictionary values, for example:</p>
<div><img class=" image-border" height="167" src="img/image_02_044.png" width="449"/></div>
<p>The <kbd>_replace</kbd> method returns a new instance of the tuple, replacing the specified values, for example:</p>
<div><img class=" image-border" height="59" src="img/image_02_045.png" width="212"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Arrays</h1>
            

            
                
<p>The array module defines a datatype <kbd>array</kbd> that is similar to the <kbd>list</kbd> datatype except for the constraint that their contents must be of a single type of the underlying representation, as is determined by the machine architecture or underlying C implementation.</p>
<p>The type of an array is determined at creation time and it is indicated by one of the following type codes:</p>
<table class="table">
<tbody>
<tr>
<td>
<p>Code</p>
</td>
<td>
<p>C type</p>
</td>
<td>
<p>Python type</p>
</td>
<td>
<p>Minimum bytes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'b'</kbd></p>
</td>
<td>
<p><kbd>signed char</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'B'</kbd></p>
</td>
<td>
<p><kbd>unsigned char</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'u'</kbd></p>
</td>
<td>
<p><kbd>Py_UNICODE</kbd></p>
</td>
<td>
<p><kbd>Unicode character</kbd></p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'h'</kbd></p>
</td>
<td>
<p><kbd>signed short</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'H'</kbd></p>
</td>
<td>
<p><kbd>unsigned short</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'i'</kbd></p>
</td>
<td>
<p><kbd>signed int</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'I'</kbd></p>
</td>
<td>
<p><kbd>unsigned int</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'l'</kbd></p>
</td>
<td>
<p><kbd>signed long</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'L'</kbd></p>
</td>
<td>
<p><kbd>unsigned long</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>8</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'q'</kbd></p>
</td>
<td>
<p><kbd>signed long long</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>8</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'Q'</kbd></p>
</td>
<td>
<p><kbd>unsigned lon long</kbd></p>
</td>
<td>
<p><kbd>int</kbd></p>
</td>
<td>
<p>8</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'f'</kbd></p>
</td>
<td>
<p><kbd>float</kbd></p>
</td>
<td>
<p><kbd>float</kbd></p>
</td>
<td>
<p>4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'d'</kbd></p>
</td>
<td>
<p><kbd>double</kbd></p>
</td>
<td>
<p><kbd>float</kbd></p>
</td>
<td>
<p>8</p>
</td>
</tr>
</tbody>
</table>
<p>The array objects support the following attributes and methods:</p>
<table class="table">
<tbody>
<tr>
<td>
<p>Attribute or method</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.typecode</kbd></p>
</td>
<td>
<p>The typecode character used to create the array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.itemsize</kbd></p>
</td>
<td>
<p>Size, in bytes, of items stored in the array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.append(x)</kbd></p>
</td>
<td>
<p>Appends item <kbd>x</kbd> to the end of the array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.buffer_info()</kbd></p>
</td>
<td>
<p>Returns the memory location and length of the buffer used to store the array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.byteswap()</kbd></p>
</td>
<td>
<p>Swaps the byte order of each item. Used for writing to a machine or file with a different byte order.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.count(x)</kbd></p>
</td>
<td>
<p>Returns the number of occurrences of <kbd>x</kbd> in <kbd>a</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.extend(b)</kbd></p>
</td>
<td>
<p>Appends any iterable, <kbd>b</kbd>, to the end of array <kbd>a</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.frombytes(s)</kbd></p>
</td>
<td>
<p>Appends items from a string, <kbd>s</kbd>, as an array of machine values.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.fromfile(f, n)</kbd></p>
</td>
<td>
<p>Reads <kbd>n</kbd> items, as machine values, from a file object, <kbd>f</kbd>, and appends them to <kbd>a</kbd>. Raises an <kbd>EOFError</kbd> if there are fewer than <kbd>n</kbd> items in <kbd>n</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.fromlist(l)</kbd></p>
</td>
<td>
<p>Appends items from list <kbd>l</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.fromunicode(s)</kbd></p>
</td>
<td>
<p>Extends <kbd>a</kbd> with unicode string <kbd>s</kbd>. Array <kbd>a</kbd> must be of type <kbd>u</kbd> or else <kbd>ValueError</kbd> is raised.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>index(x)</kbd></p>
</td>
<td>
<p>Returns the first (smallest) index of item <kbd>x.</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.insert(i, x)</kbd></p>
</td>
<td>
<p>Inserts item <kbd>x</kbd> before index <kbd>i.</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.pop([i])</kbd></p>
</td>
<td>
<p>Removes and returns items with index <kbd>i</kbd>. Defaults to the last item <kbd>(i = -1)</kbd> if not specified.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.remove(x)</kbd></p>
</td>
<td>
<p>Removes the first occurrence of item <kbd>x</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.reverse()</kbd></p>
</td>
<td>
<p>Reverses the order of items.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.tobytes()</kbd></p>
</td>
<td>
<p>Convert the array to machine values and returns the bytes representation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.tofile(f)</kbd></p>
</td>
<td>
<p>Writes all items, as machine values, to file object <kbd>f</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.tolist()</kbd></p>
</td>
<td>
<p>Converts the array to a list.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>a.tounicode()</kbd></p>
</td>
<td>
<p>Convert an array to <kbd>unicode</kbd> string. The array type must be <kbd>'u'</kbd> or else a <kbd>ValueError</kbd> is raised.</p>
</td>
</tr>
</tbody>
</table>
<p>Array objects support all the normal sequence operations such as indexing, slicing, concatenation, and multiplication.</p>
<p>Using arrays, as opposed to lists, is a much more efficient way of storing data that is all of the same type. In the following example, we have created an integer array of the digits from 0 to 1 million minus 1, and an identical list. Storing 1 million integers in an integer array requires around 45% of the memory of an equivalent list:</p>
<div><img class=" image-border" height="65" src="img/image_02_046.png" width="319"/></div>
<p>Because we are interested in saving space, that is, we are dealing with large datasets and limited memory size, we usually perform in-place operations on arrays, and only create copies when we need to. Typically, enumerate is used to perform an operation on each element. In the following snippet, we perform the simple operation of adding one to each item in the array:</p>
<div><img class=" image-border" height="31" src="img/image_02_047.png" width="211"/></div>
<p>It should be noted that when performing operations on arrays that create lists, such as list comprehensions, the memory efficiency gains of using an array in the first place will be negated. When we need to create a new data object, a solution is to use a generator expression to perform the operation, for example:</p>
<div><img class=" image-border" height="118" src="img/image_02_048.png" width="317"/></div>
<p>Arrays created with this module are unsuitable for work that requires a matrix of vector operations. In the next chapter, we will build our own abstract data type to deal with these operations. Also important for numerical work is the <kbd>NumPy</kbd> extension, available at <a href="http://www.numpy.org">www.numpy.org</a> .</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In the last two chapters, we have examined the language features and data types of Python. We have looked at the built-in data types and some internal Python modules, most notably the collections module. There are also several other Python modules that are relevant to the topic of this book, but rather than examining them separately, their use and functionality should become self-evident as we begin using them. There are also a number of external libraries such as the SciPy stack, and, likewise, I will attempt to explain their basic functionality as we begin to apply them.</p>
<p>In the next chapter, we will introduce the basic theory and techniques of algorithm design.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>