<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-134"><a id="_idTextAnchor313"/>7. Working with Images</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Build a user avatar function</li>
				<li class="bullets">Develop an image uploading API using Flask-Uploads</li>
				<li class="bullets">Resize images using an API</li>
				<li class="bullets">Compress images using Pillow to enhance API performance<a id="_idTextAnchor314"/></li>
			</ul>
			<p><a id="_idTextAnchor315"/>In this chapter, we will learn how to perform image uploads so that we can let users post a profile picture and recipe cover image to our Smilecook application.</p>
		</div>
		<div><h2 id="_idParaDest-135"><a id="_idTextAnchor316"/>Introduction</h2>
			<p>In the previous chapter, we completed the account opening workflow by activating the user accounts via email. In this chapter, we will develop a function so that we can upload pictures. These pictures are the user's profile picture and the recipe cover images. Aside from uploading images, we will also discuss image compression. Pillow is an image processing package that we are going to use to compress images up to 90%. This can greatly enhance the performance of our API without compromising on the image's quality.</p>
			<p>Technically speaking, we will introduce two Python packages, Flask-Uploads and Pillow, in this chapter. Flask-Uploads allows us to quickly develop image uploading functions. For image compression, we will be using Pillow. It can generate images in our specified format and compress them accordingly.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor317"/>Building the User Avatar Function</h2>
			<p>In our Smilecook application, there are user profile pages that list user information. While this is useful enough, it would be much better if we could allow users to upload a profile picture (avatar) to their profile page. This would make the application more sociable.</p>
			<p>To store the user avatar, we will create a new attribute (<code>avatar_image</code>) in the user model. We are not going to store the image directly in this attribute. Instead, we are going to store the image on the server, and the new attribute will have the filename of the image. Later, when our API gets a client request asking for the image, we will find the filename in this attribute and generate the URL to point to the image location and then return it to the frontend client-side. The frontend client will then base on the image URL and fetch it from the server:</p>
			<div><div><img src="img/C15309_07_01.jpg" alt="Figure 7.1: Building a user model avatar diagram&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 7.1: Building a user model avatar diagram</h6>
			<p>We are going to create a new endpoint, <code>http://localhost:5000/users/avatar</code>, that will take <code>PUT</code> requests. The reason we have designed it to accept <code>PUT</code> requests is that there should be only one avatar picture for each user. So, every time there is a client request, it should be either replacing an empty image with the new image for the first time, or it will be replacing the old image with a new one. This is a replacement action. In this case, we should use the HTTP verb, PUT.</p>
			<p>Now, let's add the <code>avatar_image</code> attribute in our model. We will have to use Flask-Migrate to update the underlying database table.</p>
			<h3 id="_idParaDest-137">E<a id="_idTextAnchor318"/>xercise 45: Adding the avatar_image Attribute to the User Model</h3>
			<p>In this exercise, we will work on changing the user model. First, we will create an additional attribute (<code>avatar_image</code>) in the user model. Then, we will reflect it in the database schema and use the Flask-Migrate Python package to create the corresponding field in the database table. Finally, we will confirm the change is successful by using pgAdmin. Let's get started:</p>
			<ol>
				<li>Add the <code>avatar_image</code> attribute to the user model. The code file is <code>models/user .py</code>:<pre>avatar_image = db.Column(db.String(100), default=None)</pre><p>The <code>avatar_image</code> attribute is designed to store the filename of the uploaded image. Due to this, it is a string with a length of <code>100</code>. The default is <code>None</code>.</p></li>
				<li>Run the following command to generate the database migration script:<pre>flask db migrate</pre><p>You will see that a new column called <code>user.avatar_image</code> has been detected:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'user.avatar_image'
  Generating /TrainingByPackt/Python-API-Development-Fundamentals/Lesson07/smilecook/migrations/versions/7aafe51af016_.py ... done</pre></li>
				<li>Check the content in <code>/migrations/versions/7aafe51af016_.py</code>, which is the database migration script that we generated in the previous step:<pre>"""empty message
Revision ID: 7aafe51af016
Revises: 983adee75c9a
Create Date: 2019-09-18 20:54:51.823725
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = '7aafe51af016'
down_revision = '983adee75c9a'
branch_labels = None
depends_on = None
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('user', sa.Column('avatar_image', sa.String(length=100), nullable=True))
    # ### end Alembic commands ###
def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('user', 'avatar_image')
    # ### end Alembic commands ###</pre><p>From its content, we can see that two functions have been generated in the script: <code>upgrade</code> and <code>downgrade</code>. The <code>upgrade</code> function is used to add the new <code>avatar_image</code> column to the database table, while the <code>downgrade</code> function is used to remove the <code>avatar_image</code> column so that it can go back to its original state. </p></li>
				<li>Run the following <code>flask db upgrade</code> command to update the database schema:<pre>flask db upgrade</pre><p>You will see the following output:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 983adee75c9a -&gt; 7aafe51af016, empty message</pre></li>
				<li>Check the schema <code>change</code> in pgAdmin. <em class="italics">Right-click</em> on the <code>user</code> table and choose <code>Properties</code>. A new window will appear. Then, click the <code>Columns</code> tab to check the columns:<div><img src="img/C15309_07_02.jpg" alt="Figure 7.2: Checking all the columns in the Columns tab&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 7.2: Checking all the columns in the Columns tab</h6>
			<p>Here, we can see the new <code>avatar_image</code> column being added to the <code>user</code> table. Now, our Smilecook application is ready to take in the image path of the user avatar.</p>
			<h2 id="_idParaDest-138">Fl<a id="_idTextAnchor319"/>ask-Uploads</h2>
			<p>We<a id="_idTextAnchor320"/> will be using the Flask-Uploads package to complete our image upload function. This is a very powerful package that simplifies most of the tedious coding for us. By simply calling a few methods provided by the package, it allows us to efficiently and flexibly develop the file upload function. Flask-Uploads can handle various common file types out of the box. What we need to define is the Set that classifies the types of uploaded files, such as <code>IMAGES</code>, <code>DOCUMENT</code>, <code>AUDIO</code>, and so on. Then, we simply need to set the destination of the uploaded files. </p>
			<p>Let's look at a few basic concepts and functions in Flask-Uploads before we implement them.</p>
			<h3 id="_idParaDest-139"><a id="_idTextAnchor321"/>Upload Sets</h3>
			<p>Before we upload any files, we need to define the <code>UploadSet</code>. An upload set is a singl<a id="_idTextAnchor322"/>e collection of files. Take <code>images</code> as an example; we can define the image upload set as follows, where <code>'images'</code> is the name of the upload set:</p>
			<pre>image_set = UploadSet('images', IMAGES)</pre>
			<p>Once you have the <code>image_set</code>, you can use the <code>save</code> method to save the uploaded image from the incoming HTTP request, like so:</p>
			<pre>    image_set.save(image, folder=folder, name=filename)</pre>
			<p>An upload set's configuration also needs to be stored on an app. We can use the <code>configure_uploads</code> function from Flask-Uploads to do that:</p>
			<pre>configure_uploads(app, image_set)</pre>
			<p>In addition, you can also use <code>patch_request_class</code> to restrict the maximum upload size of the uploaded file. In the next exercise, we will work on the image upload function together. The image user is going to upload their avatar picture. We will define the destination as <code>static/images/avatars</code>.</p>
			<h3 id="_idParaDest-140">Ex<a id="_idTextAnchor323"/>ercise 46: Implementing the User Avatar Upload Function</h3>
			<p>In this exercise, we will start by installing the Flask-Uploads package to our virtual environment. Then, we will do some simple configurations and get to work on the image upload function development. By completing this exercise, we will see an image URL being returned to the client. Let's get started:</p>
			<ol>
				<li value="1">Ad<a id="_idTextAnchor324"/>d the following line in <code>requirements.txt</code>:<pre>Flask-Uploads==0.2.1</pre></li>
				<li>R<a id="_idTextAnchor325"/>u<a id="_idTextAnchor326"/>n the following command to install the Flask-Uploads package in the PyCharm console:<pre>pip install -r requirements.txt</pre><p>You will see the following installation result:</p><pre>Installing collected packages: Flask-Uploads
Running setup.py install for Flask-Uploads ... done
Successfully installed Flask-Uploads-0.2.1</pre></li>
				<li>Im<a id="_idTextAnchor327"/>port <code>UploadSet</code> and <code>IMAGES</code> into <code>extensions.py</code>:<pre>from flask_uploads import UploadSet, IMAGES</pre></li>
				<li>In the same <code>extensions.py</code> file, define a set called <code>'images'</code> and an extension called <code>IMAGES</code>. This will cover the common image file extensions (<code>.jpg</code>, <code>.jpeg</code>, <code>.png</code>, and so on):<pre>image_set = UploadSet('images', IMAGES)</pre></li>
				<li>Se<a id="_idTextAnchor328"/>t the image destination in <code>Config.py</code>:<pre>UPLOADED_IMAGES_DEST = 'static/images'</pre><h4>Note</h4><p class="callout">The <code>UPLOADED_IMAGES_DEST</code> attribute name is decided by the name of the upload set. Since we set the upload set name to be  <code>'images'</code>, the attribute name here must be <code>UPLOADED_IMAGES_DEST</code>.</p></li>
				<li>Im<a id="_idTextAnchor329"/>port <code>configure_uploads</code>, <code>patch_request_class</code>, and <code>image_set</code> into <code>app.py</code>:<pre>from flask_uploads import configure_uploads, patch_request_class
from extensions import db, jwt, image_set</pre></li>
				<li>Us<a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>ing the <code>configure_uploads</code> function that we have just imported, pass in the <code>image_set</code> that we want to upload:<pre>configure_uploads(app, image_set)</pre></li>
				<li>Se<a id="_idTextAnchor332"/>t the maximum file size allowed for uploads as 10 MB using <code>patch_request_class</code>. This step is important because, by default, there is no upload size limit:<pre>patch_request_class(app, 10 * 1024 * 1024)</pre></li>
				<li>Im<a id="_idTextAnchor333"/>port the <code>url_for</code> function in <code>schemas/user.py</code> and add the <code>avatar_url</code> attribute and <code>dump_avatar_url</code> method under the <code>UserSchema</code> class:<pre>from flask import url_for
class UserSchema(Schema):
    avatar_url = fields.Method(serialize='dump_avatar_url')
    def dump_avatar_url(self, user):
        if user.avatar_image:
            return url_for('static', filename='images/avatars/{}'.format(user.avatar_image), _external=True)
        else:
            return url_for('static', filename='images/assets/default-avatar.jpg', _external=True)</pre><p>The <code>url_for</code> function is used to help generate the URL of the image file. The <code>dump_avatar_url</code> method is used to return the URL of the user avatar after serialization. If no image is being uploaded, we will simply return the URL of the default avatar.</p></li>
				<li>Cr<a id="_idTextAnchor334"/>eate a folder called <code>assets</code> under <code>static/images</code> and place the <code>default-avatar.jpg</code> image inside it. This image is going to be our default user avatar:<div><img src="img/C15309_07_03.jpg" alt="Figure 7.3: Folder structure after adding the image&#13; &#10;"/></div><h6>Figure 7.3: Folder structure after adding the image</h6><h4>Note</h4><p class="callout">You can put any image you like in here. We have also provided a default avatar image in our sample code folder. </p></li>
				<li>Imp<a id="_idTextAnchor335"/>ort the <code>uuid</code> extension, and <code>image_set</code> into <code>utils.py</code>. You will see how these modules/methods are used next:<pre>import uuid
from flask_uploads import extension
from extensions import image_set</pre></li>
				<li>Add<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/> the <code>save_image</code> function to <code>utils.py</code>:<pre>def save_image(image, folder):
    filename = '{}.{}'.format(uuid.uuid4(), extension(image.filename))
    image_set.save(image, folder=folder, name=filename)
    return filename</pre><p>In <a id="_idTextAnchor338"/>the <code>save_image</code> method, we used the <code>uuid</code> function to generate the filename for the uploaded image. We got the file extension from the uploaded image using the extension function from Flask-Uploads. Then, we saved the image using the <code>image_set.save</code> function; the saving destination is <code>static/images</code>. If we pass in <code>folder='avatar'</code> as the parameter, the destination will be <code>static/images/avatar</code>.</p></li>
				<li>Import the <code>image_set</code> and <code>save_image</code> functions from <code>utils</code> into <code>resources/user.py</code>:<pre>from extensions import image_set
from utils import generate_token, verify_token, save_image</pre></li>
				<li>Add<a id="_idTextAnchor339"/> <code>user_avatar_schema</code> to <code>resources/user.py</code>. This schema is just to show the <code>avatar_url</code>:<pre>user_avatar_schema = UserSchema(only=('avatar_url', ))</pre></li>
				<li>Cre<a id="_idTextAnchor340"/>ate the <code>UserAvatarUploadResource</code> class, in <code>resources/user.py</code>, and define the <code>put</code> method inside it:<pre>class UserAvatarUploadResource(Resource):
    @jwt_required
    def put(self):
        file = request.files.get('avatar')
        if not file:
            return {'message': 'Not a valid image'}, HTTPStatus.BAD_REQUEST
        if not image_set.file_allowed(file, file.filename):
            return {'message': 'File type not allowed'}, HTTPStatus.BAD_REQUEST
        user = User.get_by_id(id=get_jwt_identity())
        if user.avatar_image:
            avatar_path = image_set.path(folder='avatars', filename=user.avatar_image)
            if os.path.exists(avatar_path):
                os.remove(avatar_path)</pre><p>The <code>@jwt_required</code> decorator before the <code>put</code> method means that login is required before this method is triggered. In the <code>put</code> method, we got the avatar image file from <code>request.files</code>. Then, we validated whether the image file exists and whether the file extension is permitted. If everything is okay, we will get back the user object and check whether an avatar already exists. If so, that will be removed before we replace it with our uploaded image.</p></li>
				<li>Then, we used <code>save_image</code> to save the uploaded image. Once the image is saved, we will get the filename of the image and save it to <code>user.avatar_image</code>. Then, we used <code>user.save()</code> to save the update to the database:<pre>        filename = save_image(image=file, folder='avatars')
        user.avatar_image = filename
        user.save()</pre></li>
				<li>Use <code>user_avatar_schema.dump(user).data</code> to return the image URL and the HTTP status code, <strong class="bold">200 OK</strong>:<pre>        return user_avatar_schema.dump(user).data, HTTPStatus.OK</pre></li>
				<li>Import the <code>UserAvatarUploadResource</code> class into <code>app.py</code>:<pre>from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource, UserActivateResource, UserAvatarUploadResource</pre></li>
				<li>Lin<a id="_idTextAnchor341"/>k the resource to the route, that is <code>/users/avatar in app.py</code>:<pre>api.add_resource(UserAvatarUploadResource, '/users/avatar')</pre></li>
			</ol>
			<p>We have successfully created the user avatar image upload function in our Smilecook application. Now, we can upload an image to the user profile page. In the next exercise, we will test that using Postman.</p>
			<h3 id="_idParaDest-141">Exe<a id="_idTextAnchor342"/>rcise 47: Testing the User Avatar Upload Function Using Postman</h3>
			<p>In the previous exercise, we finished developing the avatar uploading function. To make sure things are working as expected, we need to test the function from the client-side. We will be using Postman to send the client request, which will have the user avatar image in it. Let's get started:</p>
			<ol>
				<li value="1">First, log in to a user account. Now, click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST Token</strong> request. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_04.jpg" alt="Figure 7.4: Sending the POST Token request&#13; &#10;"/></div><h6>Figure 7.4: Sending the POST Token request</h6></li>
				<li>Next, we are going to use the <code>PUT</code> method to upload an avatar. Send an HTTP <code>PUT</code> request to the following URL: <code>http://localhost:5000/users/avatar</code>. Click on the <code>User</code> folder, and then create a new request.</li>
				<li>Set the <code>UserAvatarUpload</code> and save it in the <strong class="bold">User</strong> folder.</li>
				<li>Select <code>PUT</code> as the HTTP method and type in <code>http://locaohost:5000/users/avatar</code> as the request URL.</li>
				<li>Now, select the <code>Authorization</code> into the <code>Bearer {token}</code> into the <strong class="bold">VALUE</strong> field, where the token is the access token we got in the previous step.</li>
				<li>Select the <strong class="bold">Body</strong> tab. Then, select the <strong class="bold">form-data</strong> radio button and put "avatar" as the <strong class="bold">KEY</strong>.</li>
				<li>Select <strong class="bold">File</strong> in the drop-down menu next to <strong class="bold">Key</strong> and select the image file to upload.</li>
				<li>Now, click the <code>avatar_url</code> in the response, meaning that our image upload request was successful.</p></li>
				<li>Clicking on <code>avatar_url</code> should bring you to the uploaded image. Check the path, <code>static/images/avatars</code>, in PyCharm. You should see the uploaded image there:<div><img src="img/C15309_07_06.jpg" alt="Figure 7.6: Checking the uploaded image&#13;&#10;"/></div><h6>Figure 7.6: Checking the uploaded image</h6></li>
				<li>Send a request to get a user back by their <code>username</code>. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET User</strong> request.</li>
				<li>Type <code>http://localhost:5000/users/john</code> into the URL field. You can replace the username, that is, <strong class="bold">John</strong>, with any username that is appropriate and then click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:</li>
			</ol>
			<div><div><img src="img/C15309_07_07.jpg" alt="Figure 7.7: Checking the user avatar URL&#13; &#10;"/>
				</div>
			</div>
			<h6>Figure 7.7: Checking the user avatar URL</h6>
			<p>Here, we can see the new avatar URL attribute in the user.</p>
			<p>This testing exercise proves that the image upload function is working as expected. We can also look up the user by placing the username in the endpoint URL.</p>
			<h4>Note</h4>
			<p class="callout">You can test two more aspects of the <code>avatar image upload</code> functions. The first one is to upload an image that's greater than 10 MB in size. The second is to test whether the default avatar image (that is, <code>default-avatar.jpg</code>) will be used for a user account that has no uploaded avatar.</p>
			<h2 id="_idParaDest-142">Image R<a id="_idTextAnchor343"/>esizing and Compression</h2>
			<p>The size of the image will affect the speed of the website. Imagine looking at a picture that's 10 MB in size. If there are 10 pictures on one page, this website will be 100 MB in size, and so it will take a lot of time to get a page. Due to this, a good practice to reduce the size of the image and compress it so that it's around 500 KB in size instead.</p>
			<p>In addition, we will also convert the image into JPEG (it has the <code>.JPG</code> file extension). JPEG is an image compression technology that can remove unnoticeable, insignificant details in an image, thus achieving a smaller file size. Besides, it is often regarded as acceptable to have a lower image quality for web use.</p>
			<p>In our Smilecook application, we will convert all our uploaded images into JPG format and compress them. We will do this through the Pillow package.</p>
			<h4>Note</h4>
			<p class="callout">We cannot have a transparent image in JPEG format. If we save an image with the background removed as a JPEG, the background will become white, instead of transparent. The other two commonly used image formats, PNG and GIF. These two image formats will support transparency in images.</p>
			<p class="callout">In our Smilecook application, however, we won't be displaying a transparent image, so using JPG images will be good enough here.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor344"/>Introduction to Pillow</h2>
			<p>Pillow, previously known as the <code>Image</code>. We can use <code>Image.open</code> to create an object from an <code>image</code> file. We can then get the image dimension in pixels by using the attribute <code>size</code>. We can also find out the color mode of the image by using the attribute mode.</p>
			<p>Some common color modes you should expect to see include <code>L</code> for black and white, <code>RGB</code> for red-green-blue, and <code>CMYK</code> for cyan-magenta-yellow-black:</p>
			<pre>&gt;&gt;&gt;image = Image.open('default-avatar.jpg')
&gt;&gt;&gt;image.size
(1600, 1066)
&gt;&gt;&gt;image.mode
'RGB'</pre>
			<p>If we want to change the color mode of the picture to RGB, use the <code>convert</code> function. We usually change the color mode to ensure the color accuracy of our images. RGB is the most commonly used color mode for computer monitors:</p>
			<pre>&gt;&gt;&gt;image = image.convert("RGB")</pre>
			<p>If we want to resize an image so that it has smaller dimensions, we should use the <code>thumbnail</code> method. This method can maintain the aspect ratio of the image, and at the same time make sure that each side of the image is less than our defined limit.</p>
			<p>As an example, the resultant image's sides will be less than <code>1600</code> px, while keeping the aspect ratio intact:</p>
			<pre>&gt;&gt;&gt;maxsize = (1600, 1600)
&gt;&gt;&gt;image.thumbnail(maxsize)</pre>
			<p>When we save our changes using the Pillow package, we can pass in a <code>quality</code> parameter. This is done to specify how much JPEG compression we want. The quality can range from 1 to 100, with 1 being the worst and 95 being the best. We should avoid putting in a value higher than 95 because that means almost no compression. The default quality value is 75:</p>
			<pre>&gt;&gt;&gt;image.save('compressed_image.jpg', optimize=True, quality=85)</pre>
			<p>Let's c<a id="_idTextAnchor345"/>omplete an exercise in order to implement image compression.</p>
			<h3 id="_idParaDest-144"><a id="_idTextAnchor346"/>Exercise 48: Implementing Image Compression in Our Smilecook Application</h3>
			<p>Now that we've learned about the theory and the tools we can use to perform image compression, let's apply that to our Smilecook application. We would like to compress the user's avatar. We will be using the Pillow package to do this. Let's get started:</p>
			<ol>
				<li value="1">Add the <code>Pillow</code> package to <code>requirements.txt</code>:<pre>Pillow==6.2.1</pre></li>
				<li>Instal<a id="_idTextAnchor347"/>l the <code>Pillow</code> package by running the <code>pip install</code> command, as follows:<pre>pip install -r requirements.txt</pre><p>You should see the following installation result after running the preceding command:</p><pre>Installing collected packages: Pillow
Successfully installed Pillow-6.2.1</pre></li>
				<li>Import the necessary package and module into <code>utils.py</code>:<pre>import os
from PIL import Image</pre></li>
				<li>In <code>utils.py</code>, define the <code>compress_image</code> function, which takes the filename and <code>folder</code> as parameters.<p>First, we will use <code>image_set.path(filename=filename, folder=folder)</code> to get the actual image file's location. Then, by using <code>Image.open(file_path)</code>, we will create the <code>image</code> object from the image file:</p><pre>def compress_image(filename, folder):
    file_path = image_set.path(filename=filename, folder=folder)
    image = Image.open(file_path)</pre></li>
				<li>Change the color mode to <code>RGB</code> and resize it so that each side is no bigger than <code>1600</code> px:<pre>    if image.mode != "RGB":
        image = image.convert("RGB")
    if max(image.width, image.height) &gt; 1600:
        maxsize = (1600, 1600)
        image.thumbnail(maxsize, Image.ANTIALIAS)</pre></li>
				<li>Generate the new filename and path for our compressed image:<pre>    compressed_filename = '{}.jpg'.format(uuid.uuid4())
    compressed_file_path = image_set.path(filename=compressed_filename, folder=folder)</pre></li>
				<li>Save the compressed image with <code>quality = 85</code>:<pre>    image.save(compressed_file_path, optimize=True, quality=85)</pre></li>
				<li>Use <code>os.stat(file_path)</code> to get the size in bytes. By doing this, we will have the original size for a before and after comparison in our testing:<pre>    original_size = os.stat(file_path).st_size
  compressed_size = os.stat(compressed_file_path).st_size
    percentage = round((original_size - compressed_size) / original_size * 100)
    print("The file size is reduced by {}%, from {} to {}.".format(percentage, original_size, compressed_size))</pre><h4>Note</h4><p class="callout">The <code>os.stat </code>method is a Python method that returns basic folder/file information (for example, owner ID, group owner ID, and file size).</p></li>
				<li>Remove the original image and then return the compressed image filename by using the following code:<pre>    os.remove(file_path)
    return compressed_filename</pre></li>
				<li>Finally, in the <code>save_image</code> function, under <code>utils.py</code>, call the <code>compress_image</code> function right after the image is saved:<pre>def save_image(image, folder):
    filename = '{}.{}'.format(uuid.uuid4(), extension(image.filename))
    image_set.save(image, folder=folder, name=filename)
    filename = compress_image(filename=filename, folder=folder)
    return filename</pre></li>
			</ol>
			<p>Here, we have created our compress_image function. The function just needs to know where the image file is, and it will compress the image for us.</p>
			<p>In the next exercise, we will test the image compression function.</p>
			<h3 id="_idParaDest-145">Exercis<a id="_idTextAnchor348"/>e 49: Testing the Image Compression Function</h3>
			<p>So far, we have developed an image compression function that can compress the avatar that was uploaded by the user. In this exercise, we will test and see how the image compression function does. Let's <a id="_idTextAnchor349"/>get started:</p>
			<ol>
				<li value="1">First, we are going to use the <code>PUT</code> method to upload an avatar. We will send an HTTP <code>http://localhost:5000/users/avatar</code>. Click on <strong class="bold">PUT UserAvatarUpload</strong> and select the <strong class="bold">Body</strong> tab.</li>
				<li>Select a large image file to upload and click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_08.jpg" alt="Figure 7.8: Uploading an avatar using the PUT method&#13;&#10;"/></div><h6>Figure<a id="_idTextAnchor350"/> 7.8: Uploading an avatar using the PUT method</h6></li>
				<li>From the application log in PyCharm, we can see that the original size of the uploaded image was 7.6 MB; it is reduced to 618 KB after compression:</li>
			</ol>
			<div><div><img src="img/C15309_07_09.jpg" alt="Figure 7.9: Image size after compression&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 7.9: Image size after compression</h6>
			<p>By doing this, we can see that the image compression function that we implemented previously works. Now, the image size has been significantly reduced. In the next activity, we will implement the recipe cover image upload function.</p>
			<h3 id="_idParaDest-146">Activity <a id="_idTextAnchor351"/>11: Implementing the Recipe Cover Image Upload Function</h3>
			<p>So far, we have learned how to develop the image upload and compression function. In this activity, we are going to work on the recipe cover image upload function for the Smilecook application. We want to make our recipe more attractive by providing a cover image for it. Similar to the user avatar, only one cover image is allowed per recipe. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add the <code>cover_image</code> attribute to the user model in <code>models/recipe.py</code>.</li>
				<li>Update the corresponding DB schema using the <code>flask db migrate</code> command.</li>
				<li>Create the <code>recipe_cover_schema</code> to show the <code>cover_url</code> in the HTTP response.</li>
				<li>Create the <code>RecipeCoverUploadResource</code> for the recipe cover image upload function.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 323.</p></li>
			</ol>
			<h3 id="_idParaDest-147">Activity <a id="_idTextAnchor352"/><a id="_idTextAnchor353"/>12: Testing the Image Upload Function</h3>
			<p>In this activity, we are going to test the recipe cover image uploading function. First, we will create a new recipe, upload a recipe cover image, and verify whether it has been uploaded by fetching the recipe back. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Log in to the Smilecook user account using Postman.</li>
				<li>Send a client request to our API to create a recipe.</li>
				<li>Upload the recipe images.</li>
				<li>Check whether the image is compressed in PyCharm.</li>
				<li>Check the uploaded image in <code>static/images/recipes</code>.</li>
				<li>Get the recipe back and confirm that the <code>cover_url</code> attribute is populated.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 328.</p></li>
			</ol>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor354"/>Summary</h2>
			<p>In this chapter, we have learned how to use Flask-Uploads to upload images for our user avatar and recipe cover. Since our maximum uploaded image size is 10 MB, this allows users to upload huge images, thereby slowing down the performance of the website. To address this performance issue, we introduced the concept of image resizing and compression. From here, we worked on developing the function using the Pillow package.</p>
			<p>Apart from learning about new techniques regarding image manipulation, we also revisited things we learned in the previous chapters, such as updating the database schema using Flask-Migrate and displaying the URL of the uploaded image during deserialization using marshmallow's schema.</p>
			<p>We have completed most of the key functionality of our Smilecook recipe sharing platform. In the next chapter, we will develop the recipe searching and pagination functions.</p>
		</div>
	</body></html>