<html><head></head><body>
		<div>
			<div id="_idContainer120" class="Content">
			</div>
		</div>
		<div id="_idContainer121" class="Content">
			<h1 id="_idParaDest-134"><a id="_idTextAnchor313"/>7. Working with Images</h1>
		</div>
		<div id="_idContainer122" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Build a user avatar function</li>
				<li class="bullets">Develop an image uploading API using Flask-Uploads</li>
				<li class="bullets">Resize images using an API</li>
				<li class="bullets">Compress images using Pillow to enhance API performance<a id="_idTextAnchor314"/></li>
			</ul>
			<p><a id="_idTextAnchor315"/>In this chapter, we will learn how to perform image uploads so that we can let users post a profile picture and recipe cover image to our Smilecook application.</p>
		</div>
		<div id="_idContainer132" class="Content">
			<h2 id="_idParaDest-135"><a id="_idTextAnchor316"/>Introduction</h2>
			<p>In the previous chapter, we completed the account opening workflow by activating the user accounts via email. In this chapter, we will develop a function so that we can upload pictures. These pictures are the user's profile picture and the recipe cover images. Aside from uploading images, we will also discuss image compression. Pillow is an image processing package that we are going to use to compress images up to 90%. This can greatly enhance the performance of our API without compromising on the image's quality.</p>
			<p>Technically speaking, we will introduce two Python packages, <span class="None">Flask-Uploads </span>and Pillow, in this chapter. <span class="None">Flask-Uploads</span> allows us to quickly develop image uploading functions. For image compression, we will be using Pillow. It can generate images in our specified format and compress them accordingly.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor317"/>Building the User Avatar Function</h2>
			<p>In our Smilecook application, there are user profile pages that list user information. While this is useful enough, it would be much better if we could allow users to upload a profile picture (avatar) to their profile page. This would make the application more sociable.</p>
			<p>To store the user avatar, we will create a new attribute (<strong class="inline">avatar_image</strong>) in the user model. We are not going to store the image directly in this attribute. Instead, we are going to store the image on the server, and the new attribute will have the filename of the image. Later, when our API gets a client request asking for the image, we will find the filename in this attribute and generate the URL to point to the image location and then return it to the frontend client-side. The frontend client will then base on the image URL and fetch it from the server:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/C15309_07_01.jpg" alt="Figure 7.1: Building a user model avatar diagram&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 7.1: Building a user model avatar diagram</h6>
			<p>We are going to create a new endpoint, <strong class="inline">http://localhost:5000/users/avatar</strong><span class="None">, that will take </span><strong class="inline">PUT</strong><span class="None"> requests. The reason we have designed it to accept </span><strong class="inline">PUT</strong><span class="None"> requests is that there should be only one avatar picture for each user. So, every time there is a client request, it should be either replacing an empty image with the new image for the first time, or it will be replacing the old image with a new one. This is a replacement action. In this case, we should use the HTTP verb, PUT.</span></p>
			<p><span class="None">Now, let's add the </span><strong class="inline">avatar_image</strong><span class="None"> attribute in our model. We will have to use Flask-Migrate to update the underlying database table.</span></p>
			<h3 id="_idParaDest-137">E<a id="_idTextAnchor318"/>xercise 45: Adding<span class="None"> the avatar_image Attribute to the User Model</span></h3>
			<p><span class="None">In this exercise, we will work on changing the user model. First, we will create an additional attribute </span><span class="Annotation-reference">(</span><strong class="inline">avatar_image</strong><span class="Annotation-reference">) </span><span class="None">in the user model. Then, we will reflect it in the database schema and use the Flask-Migrate Python package to create the corresponding field in the database table. Finally, we will confirm the change is successful by using pgAdmin. Let's get started:</span></p>
			<ol>
				<li>Add the <strong class="inline">avatar_image</strong> attribute to the user model. The code file is <strong class="inline">models/user .py</strong>:<p class="snippet"><span class="None">avatar_image = db.Column(db.String(100), default=None)</span></p><p><span class="None">The </span><strong class="inline">avatar_image</strong><span class="None"> attribute is designed to store the filename of the uploaded image. Due to this, it is a string with a length of </span><strong class="inline">100</strong><span class="None">. The default is </span><strong class="inline">None</strong><span class="None">.</span></p></li>
				<li><span class="None">Run the following command to generate the database migration script:</span><p class="snippet"><span class="None">flask db migrate</span></p><p><span class="None">You will see that a new column called </span><strong class="inline">user.avatar_image</strong><span class="None"> has been detected:</span></p><p class="snippet"><span class="None">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</span></p><p class="snippet"><span class="None">INFO  [alembic.runtime.migration] Will assume transactional DDL.</span></p><p class="snippet"><span class="None">INFO  [alembic.autogenerate.compare] Detected added column 'user.avatar_image'</span></p><p class="snippet"><span class="None">  Generating /TrainingByPackt/Python-API-Development-Fundamentals/Lesson07/smilecook/migrations/versions/7aafe51af016_.py ... done</span></p></li>
				<li><span class="None">Check </span><span class="None">the content in </span><strong class="inline">/migrations/versions/7aafe51af016_.py</strong><span class="None">, which is the database migration script that we generated in the previous step:</span><p class="snippet"><span class="None">"""empty message</span></p><p class="snippet"><span class="None">Revision ID: 7aafe51af016</span></p><p class="snippet"><span class="None">Revises: 983adee75c9a</span></p><p class="snippet"><span class="None">Create Date: 2019-09-18 20:54:51.823725</span></p><p class="snippet"><span class="None">"""</span></p><p class="snippet"><span class="None">from alembic import op</span></p><p class="snippet"><span class="None">import sqlalchemy as sa</span></p><p class="snippet"><span class="None"># revision identifiers, used by Alembic.</span></p><p class="snippet"><span class="None">revision = '7aafe51af016'</span></p><p class="snippet"><span class="None">down_revision = '983adee75c9a'</span></p><p class="snippet"><span class="None">branch_labels = None</span></p><p class="snippet"><span class="None">depends_on = None</span></p><p class="snippet"><span class="None">def upgrade():</span></p><p class="snippet"><span class="None">    # ### commands auto generated by Alembic - please adjust! ###</span></p><p class="snippet"><span class="None">    op.add_column('user', sa.Column('avatar_image', sa.String(length=100), nullable=True))</span></p><p class="snippet"><span class="None">    # ### end Alembic commands ###</span></p><p class="snippet"><span class="None">def downgrade():</span></p><p class="snippet"><span class="None">    # ### commands auto generated by Alembic - please adjust! ###</span></p><p class="snippet"><span class="None">    op.drop_column('user', 'avatar_image')</span></p><p class="snippet"><span class="None">    # ### end Alembic commands ###</span></p><p><span class="None">From its content, we can see that two functions have been generated in the script: </span><strong class="inline">upgrade</strong><span class="None"> and </span><strong class="inline">downgrade</strong><span class="None">. The </span><strong class="inline">upgrade</strong><span class="None"> function is used to add the new </span><strong class="inline">avatar_image</strong><span class="None"> column to the database table, while the </span><strong class="inline">downgrade</strong><span class="None"> function is used to remove the </span><strong class="inline">avatar_image</strong><span class="None"> column so that it can go back to its original state. </span></p></li>
				<li>Run the<span class="None"> following </span><strong class="inline">flask db upgrade</strong><span class="None"> command to update the database </span>schema:<p class="snippet"><span class="None">flask db upgrade</span></p><p><span class="None">You will see the following output:</span></p><p class="snippet"><span class="None">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</span></p><p class="snippet"><span class="None">INFO  [alembic.runtime.migration] Will assume transactional DDL.</span></p><p class="snippet"><span class="None">INFO  [alembic.runtime.migration] Running upgrade 983adee75c9a -&gt; 7aafe51af016, empty message</span></p></li>
				<li><span class="None">Check the schema </span><strong class="inline">change</strong><span class="None"> in pgAdmin. </span><em class="italics">Right-click</em><span class="None"> on the </span><strong class="inline">user</strong><span class="None"> table and choose </span><strong class="inline">Properties</strong><span class="None">. A new window will appear. Then, click the </span><strong class="inline">Columns</strong><span class="None"> tab to check the </span>columns:<div id="_idContainer124" class="IMG---Figure"><img src="image/C15309_07_02.jpg" alt="Figure 7.2: Checking all the columns in the Columns tab&#13;&#10;"/></div></li>
			</ol>
			<h6><span class="None">Figure 7.2: Checking all the columns in the Columns tab</span></h6>
			<p><span class="None">Here, we can see the new </span><strong class="inline">avatar_image</strong><span class="None"> column being added to the </span><strong class="inline">user</strong> table. Now, our Smilecook application is ready to take in the image path of the user avatar.</p>
			<h2 id="_idParaDest-138"><span class="None">Fl<a id="_idTextAnchor319"/>ask-Uploads</span></h2>
			<p><span class="None">We<a id="_idTextAnchor320"/> will be using the Flask-Uploads</span><span class="Annotation-reference"> </span><span class="None">package to complete our image upload function. This is a very powerful package that simplifies most of the tedious coding for us. By simply calling a few methods provided by the package, it allows us to efficiently and flexibly develop the file upload function. Flask-Uploads can handle various common file types out of the box. What we need to define is the Set that classifies the types of uploaded files, such as </span><strong class="inline">IMAGES</strong><span class="None">, </span><strong class="inline">DOCUMENT</strong><span class="None">, </span><strong class="inline">AUDIO</strong><span class="None">, and so on. Then, we simply need to set the destination of the uploaded files. </span></p>
			<p>Let's look at a few basic concepts and functions in <span class="None">Flask-Uploads</span> before we implement them.</p>
			<h3 id="_idParaDest-139"><a id="_idTextAnchor321"/>Upload Sets</h3>
			<p>Before we upload any files, we need to define the <strong class="inline">UploadSet</strong>. An upload set is a singl<a id="_idTextAnchor322"/>e collection of files. Take <strong class="inline">images</strong> as an example; we can define the image upload set as follows, where <strong class="inline">'images'</strong> is the name of the upload set:</p>
			<p class="snippet"><span class="None">image_set = UploadSet('images', IMAGES)</span></p>
			<p>Once you have the <strong class="inline">image_set</strong>, you can use the <strong class="inline">save</strong> method to save the uploaded image from the incoming HTTP request, like so:</p>
			<p class="snippet"><span class="None">    image_set.save(image, folder=folder, name=filename)</span></p>
			<p>An upload set's configuration also needs to be stored on an app. We can use the <strong class="inline">configure_uploads</strong> function from <span class="None">Flask-Uploads</span> to do that:</p>
			<p class="snippet">configure_uploads(app, image_set)</p>
			<p>In addition, you can also use <strong class="inline">patch_request_class</strong> to restrict the maximum upload size of the uploaded file. <span class="None">In the next exercise, we will work on the image upload function together. The image user is going to upload their avatar picture. We will define the destination as </span><strong class="inline">static/images/avatars</strong><span class="None">.</span></p>
			<h3 id="_idParaDest-140"><span class="None">Ex<a id="_idTextAnchor323"/>ercise 46: Implementing the User Avatar Upload Function</span></h3>
			<p><span class="None">In this exercise, we will start by installing the Flask-Uploads package to our virtual environment. Then, we will do some simple configurations and get to work on the image upload function development. By completing this exercise, we will see an image URL being returned to the client. Let's get started:</span></p>
			<ol>
				<li value="1"><span class="None">Ad<a id="_idTextAnchor324"/>d the </span>following<span class="None"> line in </span><strong class="inline">requirements.txt</strong><span class="None">:</span><p class="snippet">Flask-Uploads==0.2.1</p></li>
				<li><span class="None">R<a id="_idTextAnchor325"/>u<a id="_idTextAnchor326"/>n the following command to install the Flask-Uploads package in the PyCharm console:</span><p class="snippet">pip install -r requirements.txt</p><p>You will see the following installation result:</p><p class="snippet">Installing collected packages: Flask-Uploads</p><p class="snippet">Running setup.py install for Flask-Uploads ... done</p><p class="snippet">Successfully installed Flask-Uploads-0.2.1</p></li>
				<li>Im<a id="_idTextAnchor327"/>port<span class="None"> </span><strong class="inline">UploadSet</strong><span class="None"> and </span><strong class="inline">IMAGES</strong><span class="None"> into </span><strong class="inline">extensions.py</strong><span class="None">:</span><p class="snippet">from flask_uploads import UploadSet, IMAGES</p></li>
				<li><span class="None">In </span>the<span class="None"> same </span><strong class="inline">extensions.py</strong><span class="None"> file, define a set called </span><strong class="inline">'images'</strong><span class="None"> and an extension called </span><strong class="inline">IMAGES</strong><span class="None">. This will cover the common image file extensions (</span><strong class="inline">.jpg</strong><span class="None">, </span><strong class="inline">.jpeg</strong><span class="None">, </span><strong class="inline">.png</strong><span class="None">, and so on):</span><p class="snippet"><span class="None">image_set = UploadSet('images', IMAGES)</span></p></li>
				<li><span class="None">Se<a id="_idTextAnchor328"/>t the image destination in </span><strong class="inline">Config.py</strong>:<p class="snippet"><span class="None">UPLOADED_IMAGES_DEST = 'static/images'</span></p><h4><span class="None">Note</span></h4><p class="callout"><span class="None">The </span><strong class="inline">UPLOADED_IMAGES_DEST</strong><span class="None"> attribute name is decided by the name of the upload set. Since we set the upload set name to be  </span><strong class="inline">'images'</strong><span class="None">, the attribute name here must be </span><strong class="inline">UPLOADED_IMAGES_DEST</strong><span class="None">.</span></p></li>
				<li>Im<a id="_idTextAnchor329"/>port<span class="None"> </span><strong class="inline">configure_uploads</strong><span class="None">, </span><strong class="inline">patch_request_class</strong><span class="None">, and </span><strong class="inline">image_set</strong><span class="None"> into </span><strong class="inline">app.py</strong>:<p class="snippet"><span class="None">from flask_uploads import configure_uploads, patch_request_class</span></p><p class="snippet"><span class="None">from extensions import db, jwt, image_set</span></p></li>
				<li>Us<a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>ing<span class="None"> the </span><strong class="inline">configure_uploads</strong><span class="None"> function that we have just imported, pass in the </span><strong class="inline">image_set</strong><span class="None"> that we want to upload:</span><p class="snippet"><span class="None">configure_uploads(app, image_set)</span></p></li>
				<li><span class="None">Se<a id="_idTextAnchor332"/>t the maximum file size allowed for uploads as 10 MB using </span><strong class="inline">patch_request_class</strong><span class="None">. This step is important because, by default, there is no upload size limit:</span><p class="snippet"><span class="None">patch_request_class(app, 10 * 1024 * 1024)</span></p></li>
				<li>Im<a id="_idTextAnchor333"/>port<span class="None"> the </span><strong class="inline">url_for</strong><span class="None"> function in </span><strong class="inline">schemas/user.py</strong><span class="None"> and add the </span><strong class="inline">avatar_url</strong><span class="None"> attribute and </span><strong class="inline">dump_avatar_url</strong><span class="None"> method under the </span><strong class="inline">UserSchema</strong><span class="None"> class:</span><p class="snippet"><span class="None">from flask import url_for</span></p><p class="snippet"><span class="None">class UserSchema(Schema):</span></p><p class="snippet"><span class="None">    avatar_url = fields.Method(serialize='dump_avatar_url')</span></p><p class="snippet"><span class="None">    def dump_avatar_url(self, user):</span></p><p class="snippet"><span class="None">        if user.avatar_image:</span></p><p class="snippet"><span class="None">            return url_for('static', filename='images/avatars/{}'.format(user.avatar_image), _external=True)</span></p><p class="snippet"><span class="None">        else:</span></p><p class="snippet"><span class="None">            return url_for('static', filename='images/assets/default-avatar.jpg', _external=True)</span></p><p><span class="None">The </span><strong class="inline">url_for</strong><span class="None"> function is used to help generate the URL of the image file. The </span><strong class="inline">dump_avatar_url</strong><span class="None"> method is used to return the URL of the user avatar after serialization. If no image is being uploaded, we will simply return the URL of the default avatar.</span></p></li>
				<li>Cr<a id="_idTextAnchor334"/>eate<span class="None"> a folder called </span><strong class="inline">assets</strong><span class="None"> under </span><strong class="inline">static/images</strong><span class="None"> and place the </span><strong class="inline">default-avatar.jpg</strong><span class="None"> image inside it. This image is going to be our default user avatar:</span><div id="_idContainer125" class="IMG---Figure"><img src="image/C15309_07_03.jpg" alt="Figure 7.3: Folder structure after adding the image&#13; &#10;"/></div><h6>Figure 7.3: Folder structure after adding the image</h6><h4><span class="None">Note</span></h4><p class="callout"><span class="None">You can put any image you like in here. We have also provided a default avatar image in our sample code folder. </span></p></li>
				<li>Imp<a id="_idTextAnchor335"/>ort<span class="None"> the </span><strong class="inline">uuid</strong><span class="None"> extension, and </span><strong class="inline">image_set</strong><span class="None"> into </span><strong class="inline">utils.py</strong><span class="None">. You will see how these modules/methods are used next:</span><p class="snippet"><span class="None">import uuid</span></p><p class="snippet"><span class="None">from flask_uploads import extension</span></p><p class="snippet"><span class="None">from extensions import image_set</span></p></li>
				<li><span class="None">Add<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/> the </span><strong class="inline">save_image</strong><span class="None"> function to </span><strong class="inline">utils.py</strong>:<p class="snippet"><span class="None">def save_image(image, folder):</span></p><p class="snippet"><span class="None">    filename = '{}.{}'.format(uuid.uuid4(), extension(image.filename))</span></p><p class="snippet"><span class="None">    image_set.save(image, folder=folder, name=filename)</span></p><p class="snippet"><span class="None">    return filename</span></p><p><span class="None">In <a id="_idTextAnchor338"/>the </span><strong class="inline">save_image</strong><span class="None"> method, we used the </span><strong class="inline">uuid</strong><span class="None"> function to generate the filename for the uploaded image. We got the file extension from the uploaded image using the extension function from Flask-Uploads. Then, we saved the image using the </span><strong class="inline">image_set.save</strong><span class="None"> function; the saving destination is </span><strong class="inline">static/images</strong><span class="None">. If we pass in </span><strong class="inline">folder='avatar'</strong><span class="None"> as the parameter, the destination will be </span><strong class="inline">static/images/avatar</strong><span class="None">.</span></p></li>
				<li>Import<span class="None"> the </span><strong class="inline">image_set</strong><span class="None"> and </span><strong class="inline">save_image</strong><span class="None"> functions from </span><strong class="inline">utils</strong><span class="None"> into </span><strong class="inline">resources/user.py</strong><span class="None">:</span><p class="snippet"><span class="None">from extensions import image_set</span></p><p class="snippet"><span class="None">from utils import generate_token, verify_token, save_image</span></p></li>
				<li>Add<a id="_idTextAnchor339"/><span class="None"> </span><strong class="inline">user_avatar_schema</strong><span class="None"> to </span><strong class="inline">resources/user.py</strong><span class="None">. This schema is just to show the </span><strong class="inline">avatar_url</strong>:<p class="snippet"><span class="None">user_avatar_schema = UserSchema(only=('avatar_url', ))</span></p></li>
				<li><span class="None">Cre<a id="_idTextAnchor340"/>ate the </span><strong class="inline">UserAvatarUploadResource</strong><span class="None"> class, </span>in <strong class="inline">resources/user.py</strong><span class="None">, and define the </span><strong class="inline">put</strong><span class="None"> </span>method<span class="None"> inside it:</span><p class="snippet"><span class="None">class UserAvatarUploadResource(Resource):</span></p><p class="snippet"><span class="None">    @jwt_required</span></p><p class="snippet"><span class="None">    def put(self):</span></p><p class="snippet"><span class="None">        file = request.files.get('avatar')</span></p><p class="snippet"><span class="None">        if not file:</span></p><p class="snippet"><span class="None">            return {'message': 'Not a valid image'}, HTTPStatus.BAD_REQUEST</span></p><p class="snippet"><span class="None">        </span><span class="None">if not image_set.file_allowed(file, file.filename):</span></p><p class="snippet"><span class="None">            return {'message': 'File type not allowed'}, HTTPStatus.BAD_REQUEST</span></p><p class="snippet"><span class="None">        user = User.get_by_id(id=get_jwt_identity())</span></p><p class="snippet"><span class="None">        if user.avatar_image:</span></p><p class="snippet"><span class="None">            avatar_path = image_set.path(folder='avatars', filename=user.avatar_image)</span></p><p class="snippet"><span class="None">            if os.path.exists(avatar_path):</span></p><p class="snippet"><span class="None">                os.remove(avatar_path)</span></p><p><span class="None">The </span><strong class="inline">@jwt_required</strong><span class="None"> decorator before the </span><strong class="inline">put</strong><span class="None"> method means that login is required before this method is triggered. In the </span><strong class="inline">put</strong><span class="None"> method, we got the avatar image file from </span><strong class="inline">request.files</strong><span class="None">. Then, we validated whether the image file exists and whether the file extension is permitted. If everything is okay, we will get back the user object and check whether an avatar already exists. If so, that will be removed before we replace it with our uploaded image.</span></p></li>
				<li><span class="None">Then, we used </span><strong class="inline">save_image</strong><span class="None"> to save the uploaded image. Once the image is saved, we will get the filename of the image and save it to </span><strong class="inline">user.avatar_image</strong><span class="None">. Then, we used </span><strong class="inline">user.save()</strong><span class="None"> to save the update to the database:</span><p class="snippet"><span class="None">        filename = save_image(image=file, folder='avatars')</span></p><p class="snippet"><span class="None">        user.avatar_image = filename</span></p><p class="snippet"><span class="None">        user.save()</span></p></li>
				<li>Use<span class="None"> </span><strong class="inline">user_avatar_schema.dump(user).data</strong><span class="None"> to return the image URL and the HTTP status code, </span><strong class="bold">200 OK</strong><span class="None">:</span><p class="snippet"><span class="None">        return user_avatar_schema.dump(user).data, HTTPStatus.OK</span></p></li>
				<li>Import<span class="None"> the </span><strong class="inline">UserAvatarUploadResource</strong><span class="None"> class into </span><strong class="inline">app.py</strong>:<p class="snippet"><span class="None">from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource, UserActivateResource, UserAvatarUploadResource</span></p></li>
				<li><span class="None">Lin<a id="_idTextAnchor341"/>k the resource to the route, that is </span><strong class="inline">/users/avatar in app.py</strong>:<p class="snippet"><span class="None">api.add_resource(UserAvatarUploadResource, '/users/avatar')</span></p></li>
			</ol>
			<p><span class="None">We have successfully created the user avatar image upload function in our Smilecook application. Now, we can upload an image to the user profile page. In the next exercise, we will test that using Postman.</span></p>
			<h3 id="_idParaDest-141"><span class="None">Exe<a id="_idTextAnchor342"/>rcise 47: Testing the User Avatar Upload Function Using Postman</span></h3>
			<p><span class="None">In the previous exercise, we finished developing the avatar uploading function. To make sure things are working as expected, we need to test the function from the client-side. We will be using Postman to send the client request, which will have the user avatar image in it. Let's get started:</span></p>
			<ol>
				<li value="1"><span class="None">First, log in to a user account. </span>Now, click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST Token</strong> request. Then, click the <strong class="bold">Send</strong> button. <span class="None">The result can be seen in the following screenshot:</span><div id="_idContainer126" class="IMG---Figure"><img src="image/C15309_07_04.jpg" alt="Figure 7.4: Sending the POST Token request&#13; &#10;"/></div><h6>Figure 7.4: Sending the POST Token request</h6></li>
				<li><span class="None">Next, we are going to use the </span><strong class="inline">PUT</strong><span class="None"> method to upload an avatar. Send an HTTP </span><strong class="inline">PUT</strong><span class="None"> request to the following </span>URL<span class="None">: </span><strong class="inline">http://localhost:5000/users/avatar</strong><span class="None">. Click on the </span><strong class="bold">Collections</strong><span class="None"> tab. </span><em class="italics">Right-click</em><span class="None"> on </span><strong class="bold">…</strong><span class="None"> next to the </span><strong class="inline">User</strong><span class="None"> folder, and then create a new request.</span></li>
				<li><span class="None">Set the </span><strong class="bold">Request Name</strong> to <strong class="inline">UserAvatarUpload</strong><span class="None"> and save it in the </span><strong class="bold">User</strong><span class="None"> folder.</span></li>
				<li><span class="None">Select </span><strong class="inline">PUT</strong><span class="None"> as the HTTP </span>method<span class="None"> and type in </span><strong class="inline">http://locaohost:5000/users/avatar</strong><span class="None"> as the request URL.</span></li>
				<li><span class="None">Now, select the </span><strong class="bold">Headers</strong><span class="None"> tab and put </span><strong class="inline">Authorization</strong><span class="None"> into the </span><strong class="bold">KEY</strong><span class="None"> field and </span><strong class="inline">Bearer {token}</strong><span class="None"> into the </span><strong class="bold">VALUE</strong><span class="None"> field, where the </span>token<span class="None"> is the access token we got in the previous step.</span></li>
				<li><span class="None">Select the </span><strong class="bold">Body</strong> tab. Then, select<span class="None"> the </span><strong class="bold">form-data</strong><span class="None"> radio button and put "avatar" as the </span><strong class="bold">KEY</strong><span class="None">.</span></li>
				<li><span class="None">Select </span><strong class="bold">File</strong><span class="None"> in the drop-down menu next to </span><strong class="bold">Key</strong><span class="None"> and select the image file to upload.</span></li>
				<li><span class="None">Now, click the</span><span class="None"> </span><strong class="bold">Save</strong><span class="None"> button and then the </span><strong class="bold">Send</strong><span class="None"> button. </span>The result can be seen in the following screenshot:<div id="_idContainer127" class="IMG---Figure"><img src="image/C15309_07_05.jpg" alt="Figure 7.5: Sending a request to upload an avatar&#13;&#10;"/></div><h6>Figure 7.5: Sending a request to upload an avatar</h6><p><span class="None">We can see </span><strong class="inline">avatar_url</strong><span class="None"> in the response, meaning that our image upload request was successful.</span></p></li>
				<li><span class="None">Clicking on </span><strong class="inline">avatar_url</strong><span class="None"> should bring you to the uploaded image. Check the path, </span><strong class="inline">static/images/avatars</strong><span class="None">, in </span>PyCharm<span class="None">. You should see the uploaded image there:</span><div id="_idContainer128" class="IMG---Figure"><img src="image/C15309_07_06.jpg" alt="Figure 7.6: Checking the uploaded image&#13;&#10;"/></div><h6>Figure 7.6: Checking the uploaded image</h6></li>
				<li><span class="None">Send a request to get a user back by their </span><strong class="inline">username</strong>. Click<span class="None"> on the </span><strong class="bold">Collections</strong><span class="None"> tab and select the </span><strong class="bold">GET User</strong><span class="None"> request.</span></li>
				<li><span class="None">Type </span><strong class="inline">http://localhost:5000/users/john</strong><span class="None"> into the URL field. You can replace the username, that is, </span><strong class="bold">John</strong><span class="None">, with </span>any<span class="None"> username that is appropriate and then click the </span><strong class="bold">Send</strong><span class="None"> button. The result can be seen in the following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/C15309_07_07.jpg" alt="Figure 7.7: Checking the user avatar URL&#13; &#10;"/>
				</div>
			</div>
			<h6>Figure 7.7: Checking the user avatar URL</h6>
			<p><span class="None">Here, we can see the new avatar URL attribute in the user.</span></p>
			<p><span class="None">This testing exercise proves that the image upload function is working as expected. We can also look up the user by placing the username in the endpoint URL.</span></p>
			<h4><span class="None">Note</span></h4>
			<p class="callout"><span class="None">You can test two more aspects of the </span><strong class="inline">avatar image upload</strong><span class="None"> functions. The first one is to upload an image that's greater than 10 MB in size. The second is to test whether the default avatar image (that is, </span><strong class="inline">default-avatar.jpg</strong><span class="None">) will be used for a user account that has no uploaded avatar.</span></p>
			<h2 id="_idParaDest-142"><span class="None">Image R<a id="_idTextAnchor343"/>esizing and Compression</span></h2>
			<p><span class="None">The size of the image will affect the speed of the website. Imagine looking at a picture that's 10 MB in size. If there are 10 pictures on one page, this website will be 100 MB in size, and so it will take a lot of time to get a page. Due to this, a good practice to reduce the size of the image and compress it so that it's around 500 KB in size instead.</span></p>
			<p><span class="None">In addition, we will also convert the image into JPEG (it has the </span><strong class="inline">.JPG</strong> file extension<span class="None">). JPEG is an image compression technology that can remove unnoticeable, insignificant details in an image, thus achieving a smaller file size. Besides, it is often regarded as acceptable to have a lower image quality for web use.</span></p>
			<p><span class="None">In our Smilecook application, we will convert all our uploaded images into JPG format and compress them. We will do this through the Pillow package.</span></p>
			<h4><span class="None">Note</span></h4>
			<p class="callout"><span class="None">We cannot have a transparent image in JPEG format. If we save an image with the background removed as a JPEG, the background will become white, instead of transparent. The other two commonly used image formats, PNG and GIF. These two image formats will support transparency in images.</span></p>
			<p class="callout"><span class="None">In our Smilecook application, however, we won't be displaying a transparent image, so using JPG images will be good enough here.</span></p>
			<h2 id="_idParaDest-143"><span class="None"><a id="_idTextAnchor344"/>Introduction to Pillow</span></h2>
			<p><span class="None">Pillow, previously known as the </span><strong class="keyword">Python Imaging Library</strong><span class="None"> (</span><strong class="keyword">PIL</strong><span class="None">), is an image processing package in Python</span>. <span class="None">The most important class in this package is </span><strong class="inline">Image</strong><span class="None">. We can use </span><strong class="inline">Image.open</strong><span class="None"> to create an object from an </span><strong class="inline">image</strong><span class="None"> file. We can then get the </span>image dimension in pixels by using the attribute <strong class="inline">size</strong>. We can also find out the color mode of the image by using the attribute mode.</p>
			<p><span class="None">Some common color modes you should expect to see include </span><strong class="inline">L</strong><span class="None"> for black and white, </span><strong class="inline">RGB</strong><span class="None"> for red-green-blue, and </span><strong class="inline">CMYK</strong><span class="None"> for cyan-magenta-yellow-black:</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image = Image.open('default-avatar.jpg')</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image.size</span></p>
			<p class="snippet"><span class="None">(1600, 1066)</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image.mode</span></p>
			<p class="snippet"><span class="None">'RGB'</span></p>
			<p><span class="None">If we want to change the color mode of the picture to RGB, use the </span><strong class="inline">convert</strong><span class="None"> function. We usually change the color mode to ensure the color accuracy of our images. RGB is the most commonly used color mode for computer monitors:</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image = image.convert("RGB")</span></p>
			<p><span class="None">If we want to resize an image so that it has smaller dimensions, we should use the </span><strong class="inline">thumbnail</strong><span class="None"> method. This method can maintain the aspect ratio of the image, and at the same time make sure that each side of the image is less than our defined limit.</span></p>
			<p><span class="None">As an example, the resultant image's sides will be less than </span><strong class="inline">1600</strong><span class="None"> px, while keeping the aspect ratio intact:</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;maxsize = (1600, 1600)</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image.thumbnail(maxsize)</span></p>
			<p><span class="None">When we save our changes using the Pillow package, we can pass in a </span><strong class="inline">quality</strong><span class="None"> parameter. This is done to specify how much JPEG compression we want. The quality can range from 1 to 100, with 1 being the worst and 95 being the best. We should avoid putting in a value higher than 95 because that means almost no compression. The default quality value is 75:</span></p>
			<p class="snippet"><span class="None">&gt;&gt;&gt;image.save('compressed_image.jpg', optimize=True, quality=85)</span></p>
			<p><span class="None">Let's c<a id="_idTextAnchor345"/>omplete an exercise in order to implement image compression.</span></p>
			<h3 id="_idParaDest-144"><span class="None"><a id="_idTextAnchor346"/>Exercise 48: Implementing Image Compression in Our Smilecook Application</span></h3>
			<p><span class="None">Now that we've learned about the theory and the tools we can use to perform image compression, let's apply that to our Smilecook application. We would like to compress the user's avatar. We will be using the Pillow package to do this. Let's get started:</span></p>
			<ol>
				<li value="1">Add the <strong class="inline">Pillow</strong> package to <strong class="inline">requirements.txt</strong>:<p class="snippet"><span class="None">Pillow==6.2.1</span></p></li>
				<li><span class="None">Instal<a id="_idTextAnchor347"/>l the </span><strong class="inline">Pillow</strong><span class="None"> </span>package<span class="None"> by running the </span><strong class="inline">pip install</strong><span class="None"> command, as follows:</span><p class="snippet"><span class="None">pip install -r requirements.txt</span></p><p><span class="None">You should see the following installation result after running the preceding command:</span></p><p class="snippet"><span class="None">Installing collected packages: Pillow</span></p><p class="snippet"><span class="None">Successfully installed Pillow-6.2.1</span></p></li>
				<li><span class="None">Import the necessary </span>package<span class="None"> and module into </span><strong class="inline">utils.py</strong><span class="None">:</span><p class="snippet"><span class="None">import os</span></p><p class="snippet"><span class="None">from PIL import Image</span></p></li>
				<li><span class="None">In </span><strong class="inline">utils.py</strong><span class="None">, define </span>the<span class="None"> </span><strong class="inline">compress_image</strong><span class="None"> function, which takes the filename and </span><strong class="inline">folder</strong><span class="None"> as parameters.</span><p><span class="None">First, we will use </span><strong class="inline">image_set.path(filename=filename, folder=folder)</strong> to get the actual image file's location. Then, by using <strong class="inline">Image.open(file_path)</strong>, we will create the <strong class="inline">image</strong> object from the image file:</p><p class="snippet"><span class="None">def compress_image(filename, folder):</span></p><p class="snippet"><span class="None">    file_path = image_set.path(filename=filename, folder=folder)</span></p><p class="snippet"><span class="None">    image = Image.open(file_path)</span></p></li>
				<li><span class="None">Change </span>the<span class="None"> color mode to </span><strong class="inline">RGB</strong><span class="None"> and resize it so that each side is no bigger than </span><strong class="inline">1600</strong><span class="None"> px:</span><p class="snippet"><span class="None">    if image.mode != "RGB":</span></p><p class="snippet"><span class="None">        image = image.convert("RGB")</span></p><p class="snippet"><span class="None">    if max(image.width, image.height) &gt; 1600:</span></p><p class="snippet"><span class="None">        maxsize = (1600, 1600)</span></p><p class="snippet"><span class="None">        image.thumbnail(maxsize, Image.ANTIALIAS)</span></p></li>
				<li>Generate<span class="None"> the new filename and path for our compressed image:</span><p class="snippet"><span class="None">    compressed_filename = '{}.jpg'.format(uuid.uuid4())</span></p><p class="snippet"><span class="None">    compressed_file_path = image_set.path(filename=compressed_filename, folder=folder)</span></p></li>
				<li><span class="None">Save the </span>compressed<span class="None"> image with </span><strong class="inline">quality = 85</strong><span class="None">:</span><p class="snippet"><span class="None">    image.save(compressed_file_path, optimize=True, quality=85)</span></p></li>
				<li><span class="None">Use </span><strong class="inline">os.stat(file_path)</strong><span class="None"> to get the size in bytes. By doing this, we will have the original size for a before and after comparison in our testing:</span><p class="snippet"><span class="None">    original_size = os.stat(file_path).st_size</span></p><p class="snippet"><span class="None">  compressed_size = os.stat(compressed_file_path).st_size</span></p><p class="snippet"><span class="None">    percentage = round((original_size - compressed_size) / original_size * 100)</span></p><p class="snippet"><span class="None">    print("The file size is reduced by {}%, from {} to {}.".format(percentage, original_size, compressed_size))</span></p><h4><span class="None">Note</span></h4><p class="callout"><span class="None">The </span><strong class="inline">os.stat </strong><span class="None">method is a Python method that returns basic folder/file information (for example, owner ID, group owner ID, and file size).</span></p></li>
				<li>Remove<span class="None"> the original image and then return the compressed image filename by using the following code:</span><p class="snippet"><span class="None">    os.remove(file_path)</span></p><p class="snippet"><span class="None">    return compressed_filename</span></p></li>
				<li>Finally<span class="None">, in the </span><strong class="inline">save_image</strong><span class="None"> function, under </span><strong class="inline">utils.py</strong><span class="None">, call the </span><strong class="inline">compress_image</strong><span class="None"> function right after the image is saved:</span><p class="snippet"><span class="None">def save_image(image, folder):</span></p><p class="snippet"><span class="None">    filename = '{}.{}'.format(uuid.uuid4(), extension(image.filename))</span></p><p class="snippet"><span class="None">    image_set.save(image, folder=folder, name=filename)</span></p><p class="snippet"><span class="None">    filename = compress_image(filename=filename, folder=folder)</span></p><p class="snippet"><span class="None">    return filename</span></p></li>
			</ol>
			<p>Here, we have created our compress_image function. The function just needs to know where the image file is, and it will compress the image for us.</p>
			<p><span class="None">In the next exercise, we will test the image compression function.</span></p>
			<h3 id="_idParaDest-145"><span class="None">Exercis<a id="_idTextAnchor348"/>e 49: Testing the Image Compression Function</span></h3>
			<p><span class="None">So far, we have developed an image compression function that can compress the avatar that was uploaded by the user. In this exercise, we will test and see how the image compression function does. Let's <a id="_idTextAnchor349"/>get started:</span></p>
			<ol>
				<li value="1"><span class="None">First, we are going to use the </span><strong class="inline">PUT</strong><span class="None"> method to upload an avatar. We will send an HTTP </span><strong class="bold">PUT</strong><span class="None"> request to the following URL: </span><strong class="inline">http://localhost:5000/users/avatar</strong><span class="None">. Click on </span><strong class="bold">PUT UserAvatarUpload</strong> and s<span class="None">elect the </span><strong class="bold">Body</strong> tab.</li>
				<li><span class="None">Select a large image file to upload and click the </span><strong class="bold">Send</strong><span class="None"> button. The result can be seen in the following screenshot:</span><div id="_idContainer130" class="IMG---Figure"><img src="image/C15309_07_08.jpg" alt="Figure 7.8: Uploading an avatar using the PUT method&#13;&#10;"/></div><h6>Figure<a id="_idTextAnchor350"/> 7.8: Uploading an avatar using the PUT method</h6></li>
				<li><span class="None">From the application log in PyCharm, we can see that the original size of the uploaded image was 7.6 MB; it is reduced to 618 KB after compression:</span></li>
			</ol>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/C15309_07_09.jpg" alt="Figure 7.9: Image size after compression&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 7.9: Image size after compression</h6>
			<p><span class="None">By doing this, we can see that the image compression function that we implemented previously works. Now, the image size has been significantly reduced. In the next activity, we will implement the</span> recipe cover image upload <span class="None">function.</span></p>
			<h3 id="_idParaDest-146"><span class="None">Activity <a id="_idTextAnchor351"/>11: Implementing the Recipe Cover Image Upload Function</span></h3>
			<p><span class="None">So far, we have learned how to develop the image upload and compression function. In this activity, we are going to work on the recipe cover image upload function for the Smilecook application. We want to make our recipe more attractive by providing a cover image for it. Similar to the user avatar, only one cover image is allowed per recipe. Follow these steps to complete this activity:</span></p>
			<ol>
				<li value="1"><span class="None">Add the </span><strong class="inline">cover_image</strong><span class="None"> attribute to the user model in </span><strong class="inline">models/recipe.py</strong>.</li>
				<li><span class="None">Update the corresponding DB schema using the </span><strong class="inline">flask db migrate</strong><span class="None"> command.</span></li>
				<li>Create the <strong class="inline">recipe_cover_schema</strong> to show the <strong class="inline">cover_url</strong> in the HTTP response.</li>
				<li>Create the <strong class="inline">RecipeCoverUploadResource</strong> for the recipe cover image upload function.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 323.</p></li>
			</ol>
			<h3 id="_idParaDest-147"><span class="None">Activity <a id="_idTextAnchor352"/><a id="_idTextAnchor353"/>12: Testing the Image Upload Function</span></h3>
			<p>In this activity, we are going to test the recipe cover image uploading function. First, we will create a new recipe, upload a recipe cover image, and verify whether it has been uploaded by fetching the recipe back. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1"><span class="None">Log in to the Smilecook user account using Postman.</span></li>
				<li><span class="None">Send a client request to our API to create a recipe.</span></li>
				<li><span class="None">Upload the recipe images.</span></li>
				<li><span class="None">Check whether the image is compressed in PyCharm.</span></li>
				<li><span class="None">Check the uploaded image in </span><strong class="inline">static/images/recipes</strong>.</li>
				<li><span class="None">Get the recipe back and confirm that the </span><strong class="inline">cover_url</strong><span class="None"> attribute is populated.</span><h4>Note</h4><p class="callout">The solution to this activity can be found on page 328.</p></li>
			</ol>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor354"/>Summary</h2>
			<p>In this chapter, we have learned how to use Flask-Uploads to upload images for our user avatar and recipe cover. Since our maximum uploaded image size is 10 MB, this allows users to upload huge images, thereby slowing down the performance of the website. To address this performance issue, we introduced the concept of image resizing and compression. From here, we worked on developing the function using the Pillow package.</p>
			<p>Apart from learning about new techniques regarding image manipulation, we also revisited things we learned in the previous chapters, such as updating the database schema using Flask-Migrate and displaying the URL of the uploaded image during deserialization using marshmallow's schema.</p>
			<p>We have completed most of the key functionality of our Smilecook recipe sharing platform. In the next chapter, we will develop the recipe searching and pagination functions.</p>
		</div>
	</body></html>