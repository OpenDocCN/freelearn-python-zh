["```py\nprint(\n    f\"INSERT INTO SSAMPLES(SERIES, SEQUENCE, X, Y)\"\n    f\"VALUES({series}, {sequence}, ’{x}’, ’{y}’)\"\n)\n```", "```py\nCREATE TABLE IF NOT EXISTS series(\n  series_id INTEGER,\n  name TEXT,\n\n  PRIMARY KEY (series_id)\n);\n\nCREATE TABLE IF NOT EXISTS series_sample(\n  series_id INTEGER,\n  sequence INTEGER,\n  x TEXT,\n  y TEXT,\n\n  PRIMARY KEY (series_id, sequence),\n  FOREIGN KEY (series_id) REFERENCES series(series_id)\n);\n```", "```py\nINSERT INTO series(series_id, name) VALUES(:series_id, :name)\n\nINSERT INTO series_sample(series_id, sequence, x, y)\n  VALUES(:series_id, :sequence, :x, :y)\n```", "```py\nCREATE_SERIES = \"\"\"\nCREATE TABLE IF NOT EXISTS series(\n-- rest of the SQL shown above...\n\"\"\"\n\nCREATE_VALUES = \"\"\"\nCREATE TABLE IF NOT EXISTS series_sample(\n-- rest of the SQL shown above...\n\"\"\"\n\nCREATE_SCHEMA = [\n    CREATE_SERIES,\n    CREATE_VALUES\n]\n\ndef execute_statements(\n        connection: sqlite3.Connection,\n        statements: list[str]\n) -> None:\n    for statement in statements:\n        connection.execute(statement)\n    connection.commit()\n```", "```py\nwith sqlite3.connect(\"file:example.db\", uri=True) as connection:\n    schema_build_load(connection, config, data_path)\n```", "```py\nINSERT_SERIES = \"\"\"\n    INSERT INTO series(series_id, name)\n        VALUES(:series_id, :name)\n\"\"\"\n\nSERIES_ROWS = [\n    {\"series_id\": 1, \"name\": \"Series I\"},\n    {\"series_id\": 2, \"name\": \"Series II\"},\n    {\"series_id\": 3, \"name\": \"Series III\"},\n    {\"series_id\": 4, \"name\": \"Series IV\"},\n]\n\ndef load_series(connection: sqlite3.Connection) -> None:\n    for series in SERIES_ROWS:\n        connection.execute(INSERT_SERIES, series)\n    connection.commit()\n```", "```py\nfor sequence, row in enumerate(reader):\n    for series_id, extractor in SERIES_BUILDERS:\n        param_values = (\n            asdict(extractor(row)) |\n            {\"series_id\": series_id, \"sequence\": sequence}\n        )\n        connection.execute(insert_values_SQL, param_values)\n```", "```py\n    SERIES_BUILDERS = [\n    (1, series_1),\n    (2, series_2),\n    (3, series_3),\n    (4, series_4)\n]\n```", "```py\nSELECT s.name, COUNT(*)\n  FROM series s JOIN series_sample sv\n    ON s.series_id = sv.series_id\n  GROUP BY s.series_id\n```", "```py\n% python src/acquire.py -o quartet --schema extract.toml \\\n  --db_uri file:example.db -u username\n\nEnter your password:\n```", "```py\nfrom dataclasses import dataclass\n\n@dataclass\nclass SeriesSample:\n    x: str\n    y: str\n\n@dataclass\nclass Series:\n    name: str\n    samples: list[SeriesSample]\n```", "```py\nSELECT s.name, sv.x, sv.y\n  FROM series s JOIN series_sample sv ON s.series_id = sv.series_id\n```", "```py\nSELECT s.name, s.series_id\n  FROM series s\n```", "```py\nSELECT sv.x, sv.y\n  FROM series_sample sv\n  WHERE sv.series_id = :series_id\n  ORDER BY sv.sequence\n```", "```py\nimport model\nimport sqlite3\nfrom typing import Any\nfrom collections.abc import Iterator\n\nclass Extract:\n    def build_samples(\n            self,\n            connection: sqlite3.Connection,\n            config: dict[str, Any],\n            name: str\n    ) -> model.Series:\n        ...\n\n    def series_iter(\n            self,\n            connection: sqlite3.Connection,\n            config: dict[str, Any]\n    ) -> Iterator[model.Series]:\n        ...\n```", "```py\ndef build_samples(\n        self,\n        connection: sqlite3.Connection,\n        config: dict[str, Any],\n        name: str\n) -> list[model.SeriesSample]:\n    samples_cursor = connection.execute(\n        config[’query’][’samples’],\n        {\"name\": name}\n    )\n    samples = [\n        model.SeriesSample(\n            x=row[0],\n            y=row[1])\n        for row in samples_cursor\n    ]\n    return samples\n```", "```py\ndef series_iter(\n        self,\n        connection: sqlite3.Connection,\n        config: dict[str, Any]\n) -> Iterator[model.Series]:\n    print(config[’query’][’names’])\n    names_cursor = connection.execute(config[’query’][’names’])\n    for row in names_cursor:\n        name=row[0]\n        yield model.Series(\n            name=name,\n            samples=self.build_samples(connection, config, name)\n        )\n```", "```py\n[query]\nsummary =  \"\"\"\nSELECT s.name, COUNT(*)\n  FROM series s JOIN series_sample sv ON s.series_id = sv.series_id\n  GROUP BY s.series_id\n\"\"\"\n\ndetail =  \"\"\"\nSELECT s.name, s.series_id, sv.sequence, sv.x, sv.y\n  FROM series s JOIN series_value sv ON s.series_id = sv.series_id\n\"\"\"\n\nnames = \"\"\"\nSELECT s.name FROM series s\n\"\"\"\n\nsamples = \"\"\"\nSELECT sv.x, sv.y\n  FROM series_sample sv JOIN series s ON s.series_id = sv.series_id\n  WHERE s.name = :name\n  ORDER BY sv.sequence\n\"\"\"\n```", "```py\nimport sqlite3\nfrom typing import Any, cast\nfrom unittest.mock import Mock, call, sentinel\nfrom pytest import fixture\nimport db_extract\nimport model\n\ndef test_build_sample(\n        mock_connection: sqlite3.Connection,\n        mock_config: dict[str, Any]\n):\n    extract = db_extract.Extract()\n    results = list(\n        extract.series_iter(mock_connection, mock_config)\n    )\n```", "```py\n    assert results == [\n        model.Series(\n            name=sentinel.Name,\n            samples=[\n               model.SeriesSample(sentinel.X, sentinel.Y)\n            ]\n        )\n    ]\n    assert cast(Mock, mock_connection).execute.mock_calls == [\n        call(sentinel.Names_Query),\n        call(sentinel.Samples_Query, {’name’: sentinel.Name})\n    ]\n```", "```py\n@fixture\ndef mock_connection() -> sqlite3.Connection:\n    names_cursor: list[tuple[Any, ...]] = [\n        (sentinel.Name,)\n    ]\n    samples_cursor: list[tuple[Any, ...]]  = [\n        (sentinel.X, sentinel.Y)\n    ]\n    query_to_cursor: dict[sentinel, list[tuple[Any, ...]]] = {\n        sentinel.Names_Query: names_cursor,\n        sentinel.Samples_Query: samples_cursor\n    }\n\n    connection = Mock(\n        execute=Mock(\n            side_effect=lambda query, param=None: query_to_cursor[query]\n        )\n    )\n    return cast(sqlite3.Connection, connection)\n```", "```py\n@fixture.sqlite\nScenario: Extract data from the enterprise database\n\n  Given a series named \"test1\"\n  And sample values \"[(11, 13), (17, 19)]\"\n  When we run the database extract command with the test fixture database\n  Then log has INFO line with \"series: test1\"\n  And log has INFO line with \"count: 2\"\n  And output directory has file named \"quartet/test1.csv\"\n```", "```py\nfrom behave import fixture, use_fixture\nfrom behave.runner import Context\n\ndef before_tag(context: Context, tag: str) -> None:\n    if tag == \"fixture.sqlite\":\n        use_fixture(sqlite_database, context)\n```", "```py\nfrom collections.abc import Iterator\nfrom pathlib import Path\nimport shutil\nimport sqlite3\nfrom tempfile import mkdtemp\nimport tomllib\n\nfrom behave import fixture, use_fixture\nfrom behave.runner import Context\n\n@fixture\ndef sqlite_database(context: Context) -> Iterator[str]:\n    # Setup: Build the database files (shown later).\n\n    yield context.db_uri\n\n    # Teardown: Delete the database files (shown later).\n```", "```py\n    # Get Config with SQL to build schema.\n    config_path = Path.cwd() / \"schema.toml\"\n    with config_path.open() as config_file:\n        config = tomllib.load(config_file)\n        create_sql = config[’definition’][’create’]\n        context.manipulation_sql = config[’manipulation’]\n    # Build database file.\n    context.working_path = Path(mkdtemp())\n    context.db_path =  context.working_path / \"test_example.db\"\n    context.db_uri = f\"file:{context.db_path}\"\n    context.connection = sqlite3.connect(context.db_uri, uri=True)\n    for stmt in create_sql:\n        context.connection.execute(stmt)\n    context.connection.commit()\n```", "```py\n    context.connection.close()\n    shutil.rmtree(context.working_path)\n```", "```py\n@given(u’a series named \"{name}\"’)\ndef step_impl(context, name):\n    insert_series = context.manipulation_sql[’insert_series’]\n    cursor = context.connection.execute(\n        insert_series,\n        {’series_id’: 99, ’name’: name}\n    )\n    context.connection.commit()\n```", "```py\n@given(u’sample values \"{list_of_pairs}\"’)\ndef step_impl(context, list_of_pairs):\n    pairs = literal_eval(list_of_pairs)\n    insert_values = context.manipulation_sql[’insert_values’]\n    for seq, row in enumerate(pairs):\n        cursor = context.connection.execute(\n            insert_values,\n            {’series_id’: 99, ’sequence’: seq, ’x’: row[0], ’y’: row[1]}\n        )\n    context.connection.commit()\n```"]