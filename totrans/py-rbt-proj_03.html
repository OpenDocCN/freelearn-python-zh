<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making a Gardener Robot</h1>
                </header>
            
            <article>
                
<p><span>All right my friends, you have understood some of the basics of input and output; now it's the time to make something to which we can hand over some of our daily responsibilities. This robot might not really look like a robot, but trust me, it will make your life easier. Most of all the plants in your garden will be blessing you for making it. </span></p>
<p>We will be covering the following topics:</p>
<ul>
<li>Working with solenoids</li>
<li>Making the robot</li>
<li>Making it more intelligent</li>
<li>Making it truly intelligent</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with solenoids</h1>
                </header>
            
            <article>
                
<p>What we are going to make is an automation system that will water your plants whenever they need it. So technically, once it is set up, you don't really have to worry ever about watering your green creatures. Whether you are at your home, at the office, or on a vacation, this will keep doing its job no matter what. </p>
<p>Now, you must be wondering how it will water the plants, so let me tell you, for every problem in this world, there exists a solution. In our case, that solution is called a solenoid valve. What it essentially does is switch the flow of liquids. There are various solenoid valves available in the market; some of the identifying features are as follows:</p>
<ul>
<li><strong>Size</strong>: They come in various sizes such as half an inch, three quarters of an inch, 1 inch, and so on. This basically will determine the flow rate of the solenoid valve.</li>
<li><strong>Medium</strong>: Whether it is meant for fluid, gas, vapor, and so on.</li>
<li><strong>Normal condition</strong>:
<ul>
<li><strong>Normally opened</strong>: This valve will allow the flow of liquids in the off state—when no power is supplied to the valve</li>
<li><strong>Normally closed</strong>: This valve will stop the flow of liquids in the off state—when no power is supplied to the valve</li>
</ul>
</li>
<li><strong>Number of ways</strong>: A simple valve will have an inlet and an outlet. So, when it is open, it will allow the liquid to flow from the inlet to the outlet. However, there can be other types of valve such as a three-way valve which might have two outlets and one inlet. It would regulate where the flow of the liquid would happen. </li>
</ul>
<p>There can be some more specifics in terms of the valves as well, but for now that's all we need to know. One thing to notice about the solenoid valve is that these valves can either be opened or closed. Achieving any state in between or controlling flow via these valves is not possible. For this we can use a servo valve or motor valve. But as of now, we don't need it. </p>
<p>What we will be using in this chapter is a half inch valve for water/fluid, which is normally closed. When you look closely at this valve you will see that it operates at 12 volts and the current consumption is close to 1 amp. This is a lot of current for Raspberry Pi. The upper limit of current that Raspberry Pi can provide per pin is about 50 milliamp. So if we connect this valve to Raspberry Pi then it's surely not going to work. </p>
<p>What do we do now? The answer to this question is a relay. The basic job of a relay is to re-lay the circuits. Basically, it's an electronically controlled switch. The basic job of a relay is to switch devices that have a higher current/voltage consumption than what can be given by a controlling unit <span>on and off</span>. This is a fairly simple device, as you can see in the diagram. There are two circuits. One is depicted in blue, which is a low voltage and low current circuit. This circuit is powering up a coil. The other circuit is depicted in red and black. This circuit is a high voltage, high current circuit. </p>
<p>In the initial stages, as you can see, the high voltage high current circuit is not complete and the oven will not work:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1e6f2d09-44b6-4c2e-ac23-dbb12b07c4be.png" style="width:39.67em;height:21.50em;"/></div>
<p>Now, in this second diagram, you can see that the blue circuit is connected to the 5V power source and that the coil is energized. Whenever a coil gets energized, it forms an electromagnet and attracts the metal leaf of the high power circuit to make the circuit complete, hence powering up the oven:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/77a0901e-d747-48fc-8c17-66fae48d452d.png" style="width:38.83em;height:21.08em;"/></div>
<p>This is how a solenoid works. The consumption of the coil is hardly a few milliamps, hence it is very easy to actuate a coil via a micro-controller. This in turn makes a contact between the final circuit. </p>
<p>There are various kinds of relays available on the market; <span>some of the identifying features are as follows:</span></p>
<ul>
<li><strong>Max output voltage</strong>: The maximum voltage that it can handle</li>
<li><strong>Maximum output current</strong>: The maximum current that it can bear for any output device connected to it</li>
<li><strong>Signal voltage</strong>: The voltage that it requires switch the components on or off</li>
<li><strong>Normal condition</strong>: 
<ul>
<li><strong>Normal off</strong>: This will not allow any current to flow until the time the signal is not received</li>
<li><strong>Normal on</strong>: It will allow the current to flow until the time the signal is not received</li>
</ul>
</li>
</ul>
<p>Now, coming back to our gardening robot, the solenoid attached to it will be working on 1 amp and 12V, so any relay which can supply equal to or more than 1 amp and 12V would work. </p>
<p>Commonly, the relays available on the market are 120V and 12 amp DC. One important thing to remember is that there will be two separate ratings for AC and DC voltage and current. As our solenoid will be working at 12V, we will only be considering the DC upper limit.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making the robot</h1>
                </header>
            
            <article>
                
<p>Now, let's get down to making the robot. Firstly, you need to make the water connection from the tap to the solenoid and from the solenoid to the sprinkler. You also have to make the connection, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/74d7c234-cb59-4298-8f3c-c83a270ebc2f.png"/></div>
<p>Now let's start programming. We will be interfacing a soil moisture sensor in this robot. The job of this sensor is to determine the amount of water in the soil. By determining this, we can understand if the garden needs water or not. This soil moisture sensor is an analogue sensor, hence we will be using an ADC to convert the analogue reading to Pi-understandable digital values. So let's get going:</p>
<pre>import time<br/>import RPi.GPIO as GPIO<br/>import Adafruit_ADS1x15<br/>water_valve_pin = 23<br/>moisture_percentage = 20<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>GPIO.setup(water_valve_pin, GPIO.OUT)<br/>adc = Adafruit_ADS1x15.ADS1115()<br/>channel = 0<br/>GAIN = 1<br/>while True:<br/> adc.start_adc(channel, gain=GAIN)<br/> moisture_value = adc.get_last_result()<br/> moisture_value= int(moisture_value/327)<br/> print moisture_value<br/> if moisture_value &lt; moisture_percentage:<br/> GPIO.output(water_valve_pin, GPIO.HIGH)<br/> time.sleep(5)<br/> else:<br/> GPIO.output(water_valve_pin, GPIO.LOW)</pre>
<p>Before you run this code, let's understand what it is actually doing:</p>
<pre><span>moisture_percentage = 20</span></pre>
<p><kbd>moisture_percentage = 20</kbd> is the percentage that will act as a threshold; if the moisture level in the soil becomes less than 20% then your garden needs water. It is this condition that your robot will keep looking for; once this condition is met then appropriate action can be taken. This percentage can also be changed to <kbd>30</kbd>, <kbd>40</kbd>, or any other value as per your garden's needs:</p>
<pre>moisture_value = int(moisture_value/327)</pre>
<p>The ADC is a 16-bit device—there are 16 binary digits that can represent a value. Hence, the value can be between <kbd>0</kbd> and <kbd>2<sup>15</sup></kbd> or, in other words, between <kbd>0</kbd> and <kbd>32768</kbd>. Now, it is simple math that for every percentage of moisture the ADC will give the following reading: <kbd>32768/100</kbd>, or <kbd>327.68</kbd>. Hence, to find out the percentage of moisture in the soil, we would have to divide the actual value given by the ADC by <kbd>327.68</kbd>.</p>
<p>The rest of the code is fairly simple and, once you go through it, it won't be very hard for you to understand. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making it more intelligent</h1>
                </header>
            
            <article>
                
<p>Congratulations on making your first robot! But did you notice one problem? The robot we made was continuously looking for a moisture value and, as soon as it noticed that the moisture value was low, it suddenly pumped water and made sure that the humidity of the soil was always more than 20%. However, this is not required. In general, we water the garden once or twice a day. If we water it more then it might not be good for the plants.</p>
<p>So, let's go ahead and make it slightly more intelligent and make it water the plants only when the moisture level is low at a certain time. This time, we won't need to make any changes to the hardware; we simply need to tweak the code. </p>
<p>Let's go ahead and upload the following code, and then see what exactly happens:</p>
<pre>from time import sleep<br/>from datetime import datetime<br/>import RPi.GPIO as GPIO<br/>import Adafruit_ADS1x15<br/>water_valve_pin = 23<br/>moisture_percentage = 20<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>GPIO.setup(water_valve_pin, GPIO.OUT)<br/>adc = Adafruit_ADS1x15.ADS1115()<br/>GAIN = 1<br/>def check_moisture():<br/> adc.start_adc(0,gain= GAIN)<br/> moisture_value = adc.get_last_result()<br/> moisture_value = int(moisture_value/327)<br/> if moisture_value &lt; moisture_level:<br/> GPIO.output(water_valve_pin, GPIO.HIGH)<br/> sleep(5)<br/> GPIO.output(water_valve_pin, GPIO.LOW)<br/> else:<br/> GPIO.output(water_valve_pin, GPIO.LOW)<br/>while True:<br/> H = datetime.now().strftime('%H')<br/> M = datetime.now().strftime('%M')<br/> if H == ‘07’ and M &lt;= ‘10’:<br/> check_moisture()<br/> if H == ‘17’ and M &lt;= ‘01’:<br/> check_moisture()</pre>
<p>This code might look a little alien to you, but trust me, it is as simple as it can get. Let's see what's happening step by step:</p>
<pre>from datetime import datetime</pre>
<p>This line of code is importing daytime instances from the date time library. This is a library which is by default in Python. All we need to do is to call it. Now, what it does is that without any hustle and bustle, it helps us determine the time within our code:</p>
<pre>def check_moisture():</pre>
<p>There are several times when we have to do something over and over again. These sets of code can be a few repetitive lines or multiple pages of code. Hence, rewriting that code doesn't make sense at all. We can create a function. In this function, we can define what will happen whenever it is called. Here in this line, we have created a function by the name of <kbd>check_moisture()</kbd>; now, whenever this function is called within a program, there will be a set of activities that will be performed. The set of activities that will be performed is defined by the user. So, whenever we write <kbd>def</kbd>, then it means that we are defining a function; thereafter, we write the name of the function that needs to be defined. </p>
<p>Once done, then whatever we write in the indentation following it will be done once the function is called. Do remember that whenever we call or define a function, it is denoted by an open and a closed <kbd>()</kbd> bracket at the end of the name of the function:</p>
<pre> moisture_value = adc.get_last_result()</pre>
<p><kbd>adc.get_last_result()</kbd> is a function of <kbd>adc</kbd>. The activity it does is to simply take the result from the pin defined earlier (pin number <kbd>0</kbd>) and fetch the reading to a variable <kbd>moisture_value</kbd>. So, after the line <kbd>moisture_value</kbd> will be the reading of the pin number <kbd>0</kbd> of the ADC or, in other words, the reading of the moisture sensor:</p>
<pre>H = datetime.now().strftime('%H')</pre>
<p>The code <kbd>datetime</kbd> is an instance and a method of <kbd>.now()</kbd>. What this function does is that it updates the time. Now, the <kbd>date time.now()</kbd> has updated all the parameters of date and time which includes the hours, minutes, seconds, and even the date. It is up to us whether we want all of it or any specific part of the date and time. At present, we want to put the value of hours in the variable <kbd>H</kbd>, hence we are using a <kbd>.strftime('%H')</kbd> method. <kbd>strftime</kbd> stands for string format of time. So whatever value it outputs is in string format. <kbd>('%H') </kbd> means that it will give us the value of the hours only. Similarly, we can also get the time in minutes by using <kbd>('%M')</kbd> and <kbd>('%S)</kbd>. We can also get the value of the date, month, and year with the following syntax:</p>
<ul>
<li>For getting the date:  <kbd>('%d')</kbd></li>
<li>For getting the month: <kbd><span>('%m')</span></kbd></li>
<li><span>For getting the year:  </span><kbd><span>('%Y')</span></kbd></li>
</ul>
<pre>if H == ‘07’ and M &lt;= ‘10’:</pre>
<p>In the preceding condition, we are checking if the time is 7 o'clock or not; further, we are also checking if the time is less than or equal to 10 minutes or not. So this piece of code will only run the statement in the <kbd>if</kbd> statement when the time is <kbd>7</kbd> hours and between <kbd>0</kbd> and <kbd>10</kbd> minutes. </p>
<p>One thing to particularly note is that we have used an <kbd>and</kbd> between both the conditions, hence it will only run the code inside it once both the statements are absolutely true. There are some other statements we can use inside it, as well, such as <kbd>or</kbd>, in which case it will run the code if either of the statements is true. </p>
<p>If we replace <kbd>and</kbd> with <kbd>or</kbd> in this <kbd>if</kbd> statement, then it will run the code for every 0 to 10 minutes of every hour and will run the code continuously for the entire time between 7:00 a.m. and 7:59 a.m.:</p>
<pre>check_moisture()</pre>
<p class="mce-root">As you may remember, previously we defined a function by the name of <kbd>check_moisture()</kbd>. While defining that function, we had also defined the set of activities that would happen every time this function is called.</p>
<p class="mce-root">Now is the time to call that function. As soon as the program reaches this end of the code, it will execute the set of activities that was earlier defined in the function. </p>
<p>So there we have it. Now, as soon as you run this code, it will wait for the time defined by you in the program. Once the specific time has been reached, then it will check for the moisture. If the moisture is less than the set value then it will start to water the plants until the time the moisture reaches above that threshold. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making it truly intelligent</h1>
                </header>
            
            <article>
                
<p>Amazing work! We have started building things that are smarter than us by ourselves. But now we want to take it a step further and make it even smarter than us—that's what robots are here for. Not only to do what we do but to do all that in a better way. </p>
<p>So, what can we improve? Well, we do not require a lot of water on a chilly winter day, but when it's summertime we need way more than what we drink in winter. The same thing happens with plants as well. </p>
<p>In winter, the amount of water they need is way less. Furthermore, even the rate of evaporation of water in the soil is slower. Hence, in both the conditions, we need to supply varying amounts of water to the garden. The question is, how do we do that?</p>
<p>Well, firstly, to know if it's hot or cold outside we require a sensor. We will be using a sensor named DHT11. It is a cheap yet robust sensor that gives us the readings of both the temperature and humidity. The best part is, it is super cheap at a rate of around $2. </p>
<p>It has four pins. But if you presume that it will work to I2C protocols, then you would be wrong. It has its own data transfer methodology. It is good to have one single protocol for all the sensors, but often you will also find that there are various sensors or devices which work on a different or an altogether new protocol. DHT11 is one such sensor. In this case, we have the choice of either understanding the entire methodology of communication or to simply get the library from the manufacturer and use it at our disposal. At present we will be opting for the latter. </p>
<p>Now let's see what the pins of the DHT11 look like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6042d3ce-84a3-453b-8933-b8acf88a677b.png" style="width:38.17em;height:20.50em;"/></div>
<p>What you can see here is that there is only one signal pin which will do all the communication digitally. There are two pins for power and one of the pin is not in use. I.e. there is no significant purpose of the pin. It might be there just for soldering or for future use. This sensor works on a 5V supply and only needs a few milliamps, hence we can simply power it up by using Raspberry Pi. Now, for the data communication, we will connect the signal pin to GPIO pin number <kbd>4</kbd>.</p>
<p>Before we start writing the code, let's first install the libraries for the communication between DHT11 and Raspberry Pi. We have done this before with the library of ADS1115, but in this one there are a few little tricks that we need to take care of. So let's get started.</p>
<p>Firstly, we need to make sure that the operating system of your Raspberry Pi is up to date. So connect Raspberry Pi to the internet, open the command prompt in Raspberry Pi, and type the following command:</p>
<pre><strong>sudo apt-get update</strong></pre>
<p>This command will update the raspbian OS of your Raspberry Pi automatically. Then go ahead and type in this:</p>
<pre><strong>sudo apt-get install build-essential python-dev python-openssl</strong></pre>
<p>In this command, we are installing the following packages:</p>
<ul>
<li><kbd>build-essential</kbd></li>
<li><kbd>python-dev</kbd></li>
<li><kbd>python-openssl</kbd></li>
</ul>
<p>You must be wondering why we are installing all of these. Well, to cut a long story short, these are the dependencies for the library that we are about to install for the communication of DHT11. We will not be able to use the library if these packages are not installed on Raspberry Pi.</p>
<p>Finally, we have to install the library; this is a generic library in which the function of communicating with the DHT11 sensor is also available. This should suffice for our needs of easy communication. Here is the command to install it:</p>
<pre><strong>sudo python setup.py install</strong></pre>
<p>All right then, we are good to go. Our system is ready to talk to DHT11. Let's first just see if what we have done up until now works the way we want. To do that, connect the DHT11 as follows; you can leave the rest of the components such as the solenoid and the soil humidity sensor connected as they are. They should not interfere. Now upload the the following code in Pi:</p>
<pre><span>from time import sleep<br/>from datetime import datetime<br/>import RPi.GPIO as GPIO<br/>import Adafruit_DHT<br/>sensor = 11<br/>pin = 4<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>while True:<br/> humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/> print("Temperature: " +temperature+ "C")<br/> print("Humidity: " +humidity+ "%")<br/> time.sleep(2)</span></pre>
<p>Once you upload this code, you will see readings of the sensor on your screen. This code is simply providing you with the raw readings of the sensor. This code is super simple and everything written here will be well understood by you, except for a few lines of the code, which are:</p>
<pre>import Adafruit_DHT</pre>
<p>In this line of the code, we are importing the <kbd>Adafruit_DHT</kbd> library in our code. This is the same library that will be used to communicate with the DHT11 sensor:</p>
<pre>sensor = 11 </pre>
<p>There are different versions of DHT available, such as DHT11, DHT22, and so on. We need to tell the program which sensor we are using. Hence, we have allotted a value to the variable sensor. Later, you will see how we will be using it:</p>
<pre>pin = 4  </pre>
<p>In this line, we are assigning the value <kbd>4</kbd> to a variable called <kbd>pin</kbd>. This variable will be used to tell the program on which pin of the Raspberry Pi we have connected the DHT11:</p>
<pre>humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)</pre>
<p>In this line, we are using a method of the <kbd>Adafruit</kbd> library named <kbd>Adafruit_DHT.read_retry()</kbd>. Now, what this does is that it reads the DHT sensor and gives the reading of the sensor to the variables <kbd>humidity</kbd> and <kbd>temperature</kbd>. One thing to note is that the DHT11 gives a reading which is updated every 2 seconds. Hence, the readings that you will be receiving will be refresh after every 2 seconds. </p>
<p>Once this code is through, then we can be sure that the sensor is working the way we want. Finally, the time has come to integrate all of the sensors together and make an entirely intelligent robot. As the solenoid, humidity sensor, and temperature sensors are already connected, all we need to do is to upload the code over to Pi and see the magic:</p>
<pre>from time import sleep<br/>from datetime import datetime<br/>import RPi.GPIO as GPIO<br/>import Adafruit_ADS1x15<br/>import Adafruit_DHT<br/>water_valve_pin = 23<br/>sensor = 11<br/>pin = 4<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>GPIO.setup(water_valve_pin, GPIO.OUT)<br/>Channel =0<br/>GAIN = 1<br/>adc = Adafruit_ADS1x15.ADS1115()<br/>def check_moisture(m):<br/> adc.start_adc(channel, gain=GAIN)<br/> moisture_value = adc.get_last_result()<br/> moisture_value = int(moisture_value/327)<br/> print moisture_value<br/> if moisture_value &lt; m:<br/> GPIO.output(water_valve_pin, GPIO.HIGH)<br/> sleep(5)<br/> GPIO.output(water_valve_pin, GPIO.LOW)<br/> else:<br/> GPIO.output(water_valve_pin, GPIO.LOW)<br/>while True:<br/> humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/> H = datetime.now().strftime(‘%H’)<br/> M = datetime.now().strftime(‘%M’)<br/> if H == ‘07’ and M &lt;= ‘10’:<br/> if temperature &lt; 15:<br/> check_moisture(20)<br/> elif temperature &gt;= 15 and temperature &lt; 28:<br/> check_moisture(30)<br/> elif temperature &gt;= 28:<br/> check_moisture(40)<br/> if H == ‘17’ and M &lt;= ‘10’:<br/> if temperature &lt; 15:<br/><br/> check_moisture(20)<br/> elif temperature &gt;= 15 and temperature &lt; 28:<br/> check_moisture(30)<br/> elif temperature &gt;= 28:<br/> check_moisture(40)</pre>
<p>Pretty long code, right? It might look so, but once you write it line by line, you will certainly understand that it might be longer than all the code we have written so far, but it's anything but complex. You might have understood most of the program, however let me explain a few new things that we have used here:</p>
<pre>def check_moisture(m):<br/>  adc.start_adc(channel, gain = GAIN)<br/><br/>moisture_value = adc.get_last_result()<br/>moisture_value = int(moisture_value / 327)<br/>print moisture_value<br/><br/>if moisture_value &lt; m:<br/>  GPIO.output(water_valve_pin, GPIO.HIGH)<br/>  sleep(5)<br/>  GPIO.output(water_valve_pin, GPIO.LOW)<br/>else :<br/>  GPIO.output(water_valve_pin, GPIO.LOW)</pre>
<p>In this line, we are defining a function named <kbd>check_moisture()</kbd>. Previously, if you remember, while we were making the function <kbd>check_moisture</kbd>, we were basically checking if the moisture value was either more or less than 20%. What if we have to check the moisture for 30%, 40%, and 50%? Would we make a separate function for that?</p>
<p>Obviously not! What we do is we pass an argument to the function,  an argument is basically a variable placed within the brackets of the function. Now we can assign values to this variable for, for example, <kbd>check_moisture(30)</kbd>—now the value of the <kbd>m</kbd> will be <kbd>30</kbd> during the time that function is executing. Then again, if you call it as <kbd>check_moisture(40)</kbd> then the value of that <kbd>m</kbd> would be <kbd>40</kbd>. </p>
<p>Now, as you can see, we are comparing values of <kbd>m</kbd> throughout the function:</p>
<pre>   if moisture_value &lt; m:</pre>
<p>The <kbd>if</kbd> statement will be checking the value of the <kbd>m</kbd> which is assigned while calling the function. This makes our job very easy and simple. </p>
<p>Let's see what the rest of the program is doing:</p>
<pre>            if temperature &lt; 15:<br/>                check_moisture(20)</pre>
<p>Every time the desired time is reached it will go ahead and check for the temperature. If the temperature is less than <kbd>15</kbd> it will call the function <kbd>check_moisture </kbd> with the value of the argument as <kbd>20</kbd>. Hence, if the moisture is less than 20%, then the water will be fed to the garden:</p>
<pre> elif temperature &gt;= 15 and temperature &lt; 28:<br/>                check_moisture(30)</pre>
<p>The <kbd>elif</kbd> or the <kbd>else if</kbd> statement is used after an <kbd>if</kbd> statement. This in common words means that if the previous <kbd>if</kbd> statement is not true, then it will check for this <kbd>if</kbd> statement. So, in the preceding line it will check if the temperature is between <kbd>15</kbd> and <kbd>28</kbd> degrees Celsius. If that is true, then it will check the moisture of the soil. The argument to the function is <kbd>30</kbd> in this line. Hence, it will check if the moisture is less than <kbd>30</kbd>. If so, then it will supply the water to the garden:</p>
<pre> elif temperature &gt;= 28:<br/>                check_moisture(40)</pre>
<p>Similarly, in this line of code we are checking the temperature, and if it is equal to or more than <kbd>28</kbd> degrees Celsius then it will pass the value <kbd>40</kbd> as an argument to the function <kbd>check_moisture</kbd>. Hence this time it will check for moisture if it is <kbd>28</kbd> or more than that.</p>
<p>As you can see, now the system will be checking the ambient temperature and, based on that, the amount of water to the plants is regulated. The best part is that it is consistent and will provide the right amount of water needed by the plants. </p>
<div class="packt_infobox">The values mentioned in this entire chapter are simply assumed values. I would strongly recommend to tweak it based on where you live and what kind of plants you have in your garden to get the best out of the system.</div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered certain topics such as solenoid integration and soil humidity sensors to build a robot that waters your backyard garden automatically. Next up, we will cover the basics of motors.</p>


            </article>

            
        </section>
    </div></body></html>