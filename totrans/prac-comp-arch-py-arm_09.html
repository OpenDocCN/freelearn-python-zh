<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-132" class="chapter-number" lang="en-GB"><a id="_idTextAnchor135"/>8</h1>&#13;
			<h1 id="_idParaDest-133" lang="en-GB"><a id="_idTextAnchor136"/>Simulators for Other Architectures</h1>&#13;
			<p lang="en-GB">In this chapter, you will learn how to create simulators for different instruction set architectures, for example, the stack-based computer and the classic CISC.</p>&#13;
			<p lang="en-GB">After describing a simple stack-based calculator, TC0, we will introduce a simulator for a one-address format. Most operations take place between an accumulator (i.e., register) and the contents of a memory location; for example, <code>ADD Y</code> means <em class="italic">add the contents of memory location Y to the accumulator</em>. The term <em class="italic">accumulator</em> indicates the location where the result of an addition is <em class="italic">accumulated</em>. Early microprocessors lacked room on the silicon chip for multiple registers, and all data had to pass through one or two accumulators.</p>&#13;
			<p lang="en-GB">After that, we will simulate a CISC architecture, which is an extension of the accumulator-based machine, where you can perform an operation on the contents of memory and on-chip registers.</p>&#13;
			<p lang="en-GB">Finally, we will present the code of TC4. This is a simulator for a non-von Neumann machine with separate address and data memories and where the address and data word lengths differ.</p>&#13;
			<p lang="en-GB">We will cover the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">TC0: A Stack-Based Calculator</li>&#13;
				<li lang="en-GB">TC2: A One-Address Accumulator Machine</li>&#13;
				<li lang="en-GB">TC3: A CISC Machine with a Register-to-Memory Architecture</li>&#13;
				<li lang="en-GB">The Complete TC3 Code</li>&#13;
				<li lang="en-GB">Arithmetic and Logic Unit (ALU)</li>&#13;
				<li lang="en-GB">A Final Example: TC4</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-134" lang="en-GB"><a id="_idTextAnchor137"/>Technical requirements</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08</a>.</p>&#13;
			<h1 id="_idParaDest-135" lang="en-GB"><a id="_idTextAnchor138"/>TC0: A stack-based calculator</h1>&#13;
			<p lang="en-GB">We’ll begin with a very simple s<em class="italic">tack-based calculator</em>. Here, we’ll introduce a zero-address machine that avoids explicit operand addresses by storing data on a stack. We have included the notion of a stack-based computer for two reasons. First, it forms the basis of many classic calculators, a programming language (FORTH) and the design of a classic computer (Burroughs B5000). Second, constructing a stack-based computer is very easy and you can experiment with this class of computer. Indeed, elements of a stack-based processor can easily be incorporated into any computer. In a conventional computer, two elements are added with an operation such as <code>ADD A,B,C</code>. In a stack-based computer, two elements are added with <code>ADD</code>. There is no need for operand addresses because the elements to be added are the top two in a stack.</p>&#13;
			<p lang="en-GB">The computer we describe here is called TC0 to indicate that it is a proto-simulator, rather than a full simulator (it cannot execute conditional operations).</p>&#13;
			<p lang="en-GB">The stack is a data structure in the form of a queue. Items enter the queue at the top and leave the queue in the reverse order to that in which they entered. It’s called a <em class="italic">stack</em> because it behaves exactly like a stack of papers.</p>&#13;
			<p lang="en-GB">A stack provides two operations: <em class="italic">push</em>, in which an item is added to the stack, and <em class="italic">pull</em> (or <em class="italic">pop</em>), in which an item is removed from the stack.</p>&#13;
			<p lang="en-GB">An operation on a single element (e.g., negate) is applied to the <em class="italic">top</em> element of the stack. An operation with two operands is applied to the two elements at the <strong class="bold">Top of the Stack (TOS)</strong>; for example, an addition is performed by pulling two operands off the stack, performing the addition, and then pushing the result back on the stack. <em class="italic">Figure 8</em><em class="italic">.1</em> demonstrates the behavior of the stack as we evaluate P = (A + B)×(C – B – D).</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_8.1_B19624.jpg" alt="Figure 8.1 – The sequence of actions taking place during the evaluation of (A + B)×(C – B – D)" width="1751" height="716"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 8.1 – The sequence of actions taking place during the evaluation of (A + B)×(C – B – D)</p>&#13;
			<p lang="en-GB"><em class="italic">Table 8.1</em> shows how we perform the P = (A + B)×(C – B – D) calculation using the <code>PUSH</code>, <code>PULL</code>, <code>ADD</code>, <code>SUB</code>, and <code>MUL</code> stack operations. As well as arithmetic operations, two other common stack operations are <code>DUP</code> (duplicate) and <code>SWAP</code>. The <code>DUP</code> operation makes <a id="_idIndexMarker500"/>a copy of the item at the TOS and pushes it on the stack (i.e., the top of the stack is duplicated). The <code>SWAP</code> operation exchanges the TOS and <strong class="bold">Next on Stack (</strong><strong class="bold">NOS)</strong> values.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">Operation        The stack as a Python list (bold is top of stack)</strong>&#13;
PUSH A           stack = [x,x,x,x,x,x,x,<strong class="bold">A</strong>]&#13;
PUSH B           stack = [x,x,x,x,x,x,<strong class="bold">B</strong>,A]&#13;
ADD              stack = [x,x,x,x,x,x,x,<strong class="bold">A+B</strong>]&#13;
PUSH C           stack = [x,x,x,x,x,x,<strong class="bold">C</strong>,A+B]&#13;
PUSH B           stack = [x,x,x,x,x,<strong class="bold">B</strong>,C,A+B]&#13;
SUBTRACT         stack = [x,x,x,x,x,x,<strong class="bold">C-B</strong>,A+B]&#13;
PUSH D           stack = [x,x,x,x,x,<strong class="bold">D</strong>,C-B,A+B]&#13;
SUBTRACT         stack = [x,x,x,x,x,x,<strong class="bold">D-C-B</strong>,A+B]&#13;
MULTIPLY         stack = [x,x,x,x,x,x,x,(<strong class="bold">D-C-B)(A+B)</strong>]&#13;
PULL result      stack = [x,x,x,x,x,x,x,x]</pre>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – The code to evaluate (A + B)×(C – B – D)</p>&#13;
			<p lang="en-GB">To simplify the simulator, each instruction is stored in a Python list consisting of the operation and <a id="_idIndexMarker501"/>memory address (for <code>PUSH</code> and <code>PULL</code>). This is not intended to be a practical simulator; it’s a demonstration of the use of the stack to handle arithmetic operations and an introduction to the stack for later chapters.</p>&#13;
			<p lang="en-GB">A register called a <code>1231,</code> pushing an element on the stack stores it at address <code>1230</code>, since the stack grows toward low addresses.</p>&#13;
			<p lang="en-GB">In some implementations, the stack pointer points at the <em class="italic">next free location</em> above the top of the stack. We will represent the stack in Python by the list <code>stack[]</code>. The stack pointer is sp and the operation to push item A on the stack is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sp = sp – 1       # Decrement the stack pointer. Point to the next free location above TOS&#13;
stack[sp] = A     # Load the new value, A, on the stack in this location</pre>&#13;
			<p lang="en-GB">Remember that the <a id="_idIndexMarker503"/>stack pointer is decremented because the stack grows toward lower addresses. If an item is popped off the stack, the inverse operation is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
A = stack[sp]     # Retrieve the item at the top of the stack</pre>&#13;
			<pre class="source-code">sp = sp + 1       # Move the stack pointer down</pre>&#13;
			<p lang="en-GB">These are complementary operations. A pull operation cancels a push. Consider evaluating an expression. <em class="italic">Figure 8</em><em class="italic">.2</em> shows the state of the stack during the evaluation of <code>X = (A + B)×(C – </code><code>D)</code>.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_8.2_B19624.jpg" alt="Figure 8.2 – The sequence of actions taking place during the evaluation of X = (A + B)×(C – D)" width="1471" height="888"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The sequence of actions taking place during the evaluation of X = (A + B)×(C – D)</p>&#13;
			<p lang="en-GB">The next step is <a id="_idIndexMarker504"/>to demonstrate how we can implement a simple calculator, TC0, based on a stack.</p>&#13;
			<h2 id="_idParaDest-136" lang="en-GB"><a id="_idTextAnchor139"/>TC0: A python stack machine</h2>&#13;
			<p lang="en-GB">We can <a id="_idIndexMarker505"/>represent the addition <code>y3 = y1 + y2</code> on a stack machine in Python as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
y1 = stack[sp]        # Retrieve the item at the top of the stack (y1 and y2 are on the stack)&#13;
sp = sp + 1           # Move the stack pointer down&#13;
y2 = stack[sp]        # Retrieve the item at the top of the stack&#13;
y3 = y1 + y2          # Add the two values&#13;
stack[sp] = y3        # Store the result on the stack</pre>&#13;
			<p lang="en-GB">We’ve taken a shortcut. We could have pulled two elements off the stack, added them, and pushed the result. Instead, we put the result back where the second operand was and saved two stack pointer movements. The following Python code illustrates a very simple stack machine interpreter. It does not implement branch operations, so it is not a realistic computation machine. Because a stack machine often operates on the top of the stack and the element below it, the second element is frequently called NOS. Note that the program <a id="_idIndexMarker506"/>is stored as a list of lists, with each instruction consisting of either a two-element list (e<a id="_idTextAnchor140"/>.g., <code>['push', '2'])</code> or a single-element list (e.g., <code>['</code><code>mu<a id="_idTextAnchor141"/>l']</code>):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                       # Stack machine simulator&#13;
prog = [['push',0],['push',1],['add'],   ['push',2],['push',1],           \&#13;
        ['sub'],   ['push',3],['sub'],   ['mul'],   ['push',4],           \&#13;
        ['swap'],  ['dup'],['pull',4],   ['stop']]&#13;
stack = [0] * 8                        # 8-location stack. Stack grows to lower addresses&#13;
mem   = [3,2,7,4,6,0]                  # Data memory (first locations are preloaded 3, 2,7, 4, 6)&#13;
run = True                             # Execution continues while run is true&#13;
pc = 0                                 # Program counter - initialize&#13;
sp = 8                                 # Initialize stack pointer to 1 past end of stack&#13;
while run:                             # Execute MAIN LOOP until run is false (STOP command)&#13;
    inst = prog[pc]                    # Read the next instruction&#13;
    pc = pc + 1                        # Increment program counter&#13;
    if   inst[0] == 'push':            # Test for push operation&#13;
         sp = sp - 1                   # Pre-decrement stack pointer&#13;
         address = int(inst[1])        # Get data from memory&#13;
         stack[sp] = mem[address]      # Store it on the stack&#13;
    elif inst[0] == 'pull':            # Test for a pull instruction&#13;
         address = int(inst[1])        # Get destination address&#13;
         mem[address] = stack[sp]      # Store the item in memory&#13;
         sp = sp + 1                   # Increment stack pointer&#13;
    elif inst[0] == 'add':             # If operation add TOS to NOS and push result&#13;
         p = stack[sp]&#13;
         sp = sp + 1&#13;
         q = stack[sp]&#13;
         stack[sp] = p + q&#13;
    elif inst[0] == 'sub':             # sub&#13;
         p = stack[sp]&#13;
         sp = sp + 1&#13;
         q = stack[sp]&#13;
         stack[sp] = q - p&#13;
    elif inst[0] == 'mul':             # mul&#13;
         p = stack[sp]&#13;
         sp = sp + 1&#13;
         q = stack[sp]&#13;
         stack[sp] = p * q&#13;
    elif inst[0] == 'div':             # div (note floor division with integer result)&#13;
         p = stack[sp]&#13;
         sp = sp + 1&#13;
         q = stack[sp]&#13;
         stack[sp] = p//q&#13;
    elif inst[0] == 'dup':             # dup (duplicate top item on stack)&#13;
         p = stack[sp]                 # get current TOS&#13;
         sp = sp - 1                   # and push it on the stack to duplicate&#13;
         stack[sp] = p&#13;
    elif inst[0] == 'swap':            # swap (exchange top of stack and next on stack)&#13;
         p = stack[sp]&#13;
         q = stack[sp+1]&#13;
         stack[sp] = q&#13;
         stack[sp+1]=p&#13;
    elif inst[0] == 'stop':            # stop&#13;
         run = False&#13;
    if sp == 8: TOS = 'empty'          # Stack elements 0 to 7. Element 8 is before the TOS&#13;
    else: TOS = stack[sp]&#13;
    print('pc =', pc-1,'sp =',sp,'TOS =',TOS,'Stack',stack,'Mem',mem,'op',inst)</pre>&#13;
			<p lang="en-GB">The following is <a id="_idIndexMarker507"/>the output from this program, which shows the program counter, the top of the stack, NOS, the stack itself, the data, and the opcode being executed. Values that change between cycles are in bold:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc=0 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">3</strong> Stack [0,0,0,0,0,0,0,<strong class="bold">3</strong>] Mem [<strong class="bold">3</strong>,2,7,4,6,0] op ['push',0]&#13;
pc=1 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">2</strong> Stack [0,0,0,0,0,0,<strong class="bold">2</strong>,3] Mem [3,<strong class="bold">2</strong>,7,4,6,0] op ['push',1]&#13;
pc=2 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,0,2,<strong class="bold">5</strong>] Mem [3,2,7,4,6,0] op ['add']&#13;
pc=3 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">7</strong> Stack [0,0,0,0,0,0,<strong class="bold">7</strong>,5] Mem [3,2,<strong class="bold">7</strong>,4,6,0] op ['push',2]&#13;
pc=4 sp=<strong class="bold">5</strong>  TOS=<strong class="bold">2</strong> Stack [0,0,0,0,0,<strong class="bold">2</strong>,7,5] Mem [3,<strong class="bold">2</strong>,7,4,6,0] op ['push',1]&#13;
pc=5 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,2,<strong class="bold">5</strong>,5] Mem [3,2,7,4,6,0] op ['sub']&#13;
pc=6 sp=<strong class="bold">5</strong>  TOS=<strong class="bold">4</strong> Stack [0,0,0,0,0,<strong class="bold">4</strong>,5,5] Mem [3,2,7,<strong class="bold">4</strong>,6,0] op ['push',3]&#13;
pc=7 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">1</strong> Stack [0,0,0,0,0,4,<strong class="bold">1</strong>,5] Mem [3,2,7,4,6,0] op ['sub']&#13;
pc=8 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,4,1,<strong class="bold">5</strong>] Mem [3,2,7,4,6,0] op ['mul']&#13;
pc=9 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">6</strong> Stack [0,0,0,0,0,4,<strong class="bold">6</strong>,5] Mem [3,2,7,4,<strong class="bold">6</strong>,0] op ['push',4]&#13;
pc=10 sp=6 TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,4,<strong class="bold">5</strong>,6] Mem [3,2,7,4,6,0] op ['swap']&#13;
pc=11 sp=5 TOS=5 Stack [0,0,0,0,0,<strong class="bold">5</strong>,5,6] Mem [3,2,7,4,6,0] op ['dup']&#13;
pc=12 sp=6 TOS=5 Stack [0,0,0,0,0,5,<strong class="bold">5</strong>,6] Mem [3,2,7,4,6,<strong class="bold">5</strong>] op ['pull',5]</pre>&#13;
			<pre class="source-code">pc=13 sp=6 TOS=5 Stack [0,0,0,0,0,5,5,6] Mem [3,2,7,4,6,5] op ['stop']</pre>&#13;
			<p lang="en-GB">In the next section, we will look at a more realistic machine that implements a simple accumulator <a id="_idIndexMarker508"/>machine of the early 8-bit microprocessor era.</p>&#13;
			<h1 id="_idParaDest-137" lang="en-GB"><a id="_idTextAnchor142"/>TC2: A one-address accumulator machine</h1>&#13;
			<p lang="en-GB">In this section, you will learn about a computer that implements a memory-to-register architecture. This is a very simple machine that implements a one-address instruction format (like an 8-bit CISC microprocessor from the 1970s).</p>&#13;
			<p lang="en-GB">The TC2 model <a id="_idIndexMarker509"/>can be used to simulate classic 8-bit microprocessors that are found in low-cost computer systems (e.g., controllers in mechanical devices). It also teaches you about the trade-off between simplicity (of the computer) and complexity (of the software that is constrained by the primitive architecture).</p>&#13;
			<p lang="en-GB">Unlike modern RISC architectures with data-processing operations between two registers, this computer implements a dyadic operation between one operand in the accumulator and the other operand, which is either a literal or the contents of memory; for example, <code>ADD M</code> adds the contents of memory location <code>M</code> to the accumulator, and <code>ADD #5</code> adds a literal to the contents of the accumulator. This computer does not have a large set of general-purpose registers.</p>&#13;
			<p lang="en-GB">The one-address machine permits operations between data in the accumulator and in memory. This contrasts with RISC architectures that permit data-processing operations only between registers. Load and store are the only memory operations permitted by a RISC architecture. This computer, TC2, implements a minimal instruction set that demonstrates its operation. Table 8.2 describes the instruction set:</p>&#13;
			<table id="table001-6" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Mnemonic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Action</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Memory form</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Literal form</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Opcode</p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDA</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load accumulator</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>[</code><code>M]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STA</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Store accumulator</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[M]</code> ← <code>[</code><code>A]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[M]</code> ← <code>L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ADD</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add to accumulator</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>[A] + [</code><code>M]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>[A] + L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>1</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>SUB</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Subtract from accumulator</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>[A] - [</code><code>M]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>[A] – L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>CLR</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load accumulator/memory with zero</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[A]</code> ← <code>0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[M]</code> ← <code>0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BRA</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch unconditionally to L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[PC]</code> ← <code>L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>4</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BEQ</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch on zero to L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>if Z = 1 then[PC]</code> ← <code>L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>5</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BNE</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch on not zero to L</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>if Z = 0 then[PC]</code> ← <code>L</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>6</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STOP</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Stop</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>7</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – Typical operations of a register-to-memory computer</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Here, <code>[A]</code> is the contents of the accumulator, <code>[M]</code> is the contents of memory location <em class="italic">M</em>, <em class="italic">L</em> is a literal, and the Z-bit is set if the result of a subtraction is zero. <em class="italic">M</em> and <em class="italic">L</em> represent the <a id="_idIndexMarker510"/>literal field of an instruction and are mutually exclusive. You can’t have an instruction with both an <em class="italic">M</em> and <em class="italic">L</em> operand.</p>&#13;
			<p lang="en-GB">Simulating a computer teaches us a lot about partitioning an instruction into various fields and how to implement instructions. In this example, we use a 3-bit opcode, a 1-bit <em class="italic">direction</em> flag (for <code>LDA</code> and <code>STA</code>) that defines the direction of data movement (to or from memory), and a 1-bit <em class="italic">mode</em> flag that selects either a literal or a direct memory access. A 5-bit numeric field provides an integer in the range 0 to 31, or a memory address. The instruction size is 10 bits with the format <code>CCC D M LLLLL</code>, where <em class="italic">CCC</em> is the opcode field, <em class="italic">D</em> is the direction bit, <em class="italic">M</em> is the mode bit, and <em class="italic">LLLLL</em> is the literal or memory address (<em class="italic">Figure 8</em><em class="italic">.3</em>). The extreme simplicity of this makes it easy to write a tiny simulator and leaves the user with a lot of opportunities to expand the code into a more realistic machine.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_8.3_B19624.jpg" alt="Figure 8.3 – TC2 instruction format" width="1167" height="693"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – TC2 instruction format</p>&#13;
			<p lang="en-GB">TC2 simulates a <a id="_idIndexMarker511"/>stored program computer with a single memory that holds both the program and data. The 32-bit location memory is initialized by memory = <code>[</code><code>0]*32</code>.</p>&#13;
			<p lang="en-GB">The TC2 code has a setup section and a <code>while</code> loop that includes a fetch instruction and an execute instruction part. The structure of the <code>while</code> loop part of the code (instruction fetch/execute cycle) consists of the following:</p>&#13;
			<pre>while run == True:&#13;
   operation         # Body of while loop operation&#13;
   .&#13;
   .&#13;
statement            # Next operation after the while loop</pre>&#13;
			<p lang="en-GB">Within the while loop, we have a <code>fetch</code> phase followed by an execution phase. The <code>fetch</code> phase is identical to the CPUs we have already described. Instruction decoding is included in this phase. Instruction decoding separates OpCode, Dir (i.e., direction to or from memory), Mode, and Literal by using shifting and bit-masking operations:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    MAR = PC                     # PC to Memory Address Register&#13;
    PC = PC + 1                  # Increment PC&#13;
    MBR = Memory[MAR]            # Read instruction, copy to Memory Buffer register&#13;
    IR = MBR                     # Copy instruction to Instruction Register&#13;
    OpCode = IR &gt;&gt; 7             # Extract Op-Code frominstruction (bits 7 to 10)&#13;
    Dir  = (IR &gt;&gt; 6) &amp; 1         # Extract data direction from instruction (0 = read, 1 = write)&#13;
    Mode = (IR &gt;&gt; 5) &amp; 1         # Extract address mode from instruction (0 = literal, 1 = memory)&#13;
    Lit = IR &amp; 0x1F              # Extract the literal/address field from the instruction</pre>&#13;
			<p lang="en-GB">Right shifts and <a id="_idIndexMarker512"/>ANDs extract fields from the instruction; for example, the 3-bit opcode is extracted from the 10-bit <code>CCCDMLLLLL</code> instruction by shifting seven places left to get <code>0000000CCC</code>. The direction bit, Dir, is extracted by performing six left shifts to get <code>000000CCCD</code> and then ANDing the result with 1 to get <code>000000000D</code>. These two operations can be combined and written as follows:</p>&#13;
			<p lang="en-GB"><code>(IR &gt;&gt; 6) &amp; 1</code>      # 6-bit shift right with &gt;&gt; and AND with 1 using the AND operator, &amp;</p>&#13;
			<p lang="en-GB">Similarly, we extract the mode bit by performing <code>Mode = (IR &gt;&gt; 5) &amp; 1</code>. Finally, the literal is in place, so all we have to do is to clear the other bits by ANDing it with <code>0b0000011111</code>, that is, <code>IR &amp; </code><code>0x1F</code>.</p>&#13;
			<p lang="en-GB">In the <code>execute</code> phase, the three op-code bits, <code>OpCode</code>, select one of the eight possible instructions. Of course, the use of <code>if … elif</code> would have been more appropriate:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if   OpCode == 0:&#13;
     Code for case 0&#13;
elif OpCode == 1:&#13;
     Code for case 1&#13;
.&#13;
.&#13;
elif OpCode == 7:&#13;
     Code for case 7</pre>&#13;
			<p lang="en-GB">Each op-code is guarded <a id="_idIndexMarker513"/>by an <code>if</code> statement. Here’s the code for the load and store accumulator instruction. We treat this as one operation and use the direction flag, <code>Dir</code>, to select between <code>LDA</code> (direction memory to accumulator) and <code>STA</code> (direction accumulator to memory):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if OpCode == 0:              # Test for Load A or Store A instruction&#13;
      if Dir  == 0:              # If direction bit is 0, then it's a load accumulator&#13;
         if Mode == 0:           # Test for literal or direct memory operand&#13;
            Acc  = Lit           # If mode is 0, then it's a literal operand&#13;
         else:                   #If mode is 1, then it's a memory access&#13;
            MAR = Lit            #Copy field (address) to MAR&#13;
            MBR = Memory[MAR]    #Do a read to get the operand in MBR&#13;
            Acc  = MBR           #and send it to the accumulator&#13;
      else:&#13;
          MAR = Lit              # If direction is 1 then it's a store accumulator&#13;
          MBR = Acc              # Copy accumulator to MBR&#13;
          Memory[MAR] = MBR      # and write MBR to memory</pre>&#13;
			<p lang="en-GB">To make it easier <a id="_idIndexMarker514"/>to read the code, we’ve divided it into two blocks (one shaded in dark gray and one in light gray) guarded by the if <code>Dir == 0</code> statement. When the direction flag is 0, the instruction is <em class="italic">load accumulator</em> and the address is copied to the <code>MAR</code>, a read is performed, and the data is copied to the <code>MBR</code> and then the accumulator. If the direction flag is 1, the instruction is a <em class="italic">store accumulator</em> and the accumulator is copied to the <code>MBR</code> and a write operation is carried out.</p>&#13;
			<p lang="en-GB">Note the use of the <code>Mode</code> flag. When loading the accumulator from memory, <code>LDA</code>, the mode flag is used to load the accumulator with either a literal or the contents of memory. When executing a <code>STA</code>, which refers to the store accumulator, the mode flag is ignored because only a memory store is possible.</p>&#13;
			<p lang="en-GB">We don’t need to describe the <code>ADD</code> and <code>SUB</code> operations because they are simply extensions of the load and store operations. We’ve included a clear operation, <code>CLR</code>, which sets either the accumulator to 0 or the contents of memory to 0 depending only on the <code>Mode</code> flag.</p>&#13;
			<p lang="en-GB">We’ll now present the full simulator code. The <code>Memory[MAR]</code> notation means the contents of memory whose address is in the <code>MAR</code> and is conveniently identical to the RTL we’ve been using. In the execute instruction block, alternate opcodes are shaded gray and blue to facilitate reading.</p>&#13;
			<p lang="en-GB">We’ve included a small program in memory, complete with data that tests several of the instructions, including load and store, add, subtract, and branch.</p>&#13;
			<p lang="en-GB">TC2 has a clear operation, <code>CLR</code>, that sets either the accumulator or the contents of memory to 0 depending on the Mode flag. This simplified computer has only a Z-bit (no N and C bits).</p>&#13;
			<p lang="en-GB">The branch group of instructions (<code>BRA</code>, <code>BEQ</code>, and <code>BNE</code>) load the program counter with a literal to force a jump. <code>BRA</code> performs an unconditional branch, and <code>BEQ</code>/<code>BNE</code> depending on the state of the Z-bit, which is set/cleared by add and subtract operations. The branch target address is an absolute address provided by the literal field.</p>&#13;
			<p lang="en-GB">We have reserved <a id="_idIndexMarker515"/>the last instruction opcode, <code>111</code>, as a stop (halt) instruction that breaks out of the <code>while</code> loop and terminates execution. In general, a real CPU does not need a halt instruction, although a halt instruction can be used to force it into a power-down mode until it is awakened by an external event, such as a keyboard/mouse input or a sc<a id="_idTextAnchor143"/>reen touch:</p>&#13;
			<pre>                                # The TC2: A primitive accumulator machine&#13;
mnemonics = {0:'LDA/STR', 1:'ADD', 2:'SUB', 3:'CLR', 4:'BRA', 5: \&#13;
               'BEQ', 6:'BNE', 7:'STOP'}&#13;
def progSet():&#13;
    global mem&#13;
    mem = [0] * 32              # The memory holds both instructions and data&#13;
  # Format  CCCDMLLLLL          # 000 LDA/STR, 001 ADD, 010 SUB, 011 CLR, 100 BRA, \&#13;
                                  101 BEQ, 110 BNE, 111 STOP&#13;
    mem[0]  =  0b0000110000     # LDA 16  [A]   = M[16]&#13;
    mem[1]  =  0b0010110001     # ADD 17  [A]   = [A] + M[17] &#13;
    mem[2]  =  0b0001110010     # STA 18  M[18] = [A]&#13;
    mem[3]  =  0b0100000011     # SUB #3  [A]   = [A] - 3&#13;
    mem[4]  =  0b1010001000     # BEQ 8&#13;
    mem[5]  =  0b0000010010     # LDA #18 [A]   = 18&#13;
    mem[6]  =  0b0001110010     # STA 18  M[18] = [A]&#13;
    mem[7]  =  0b0110000000     # CLR     [A]   = 0  &#13;
    mem[8]  =  0b0000000010     # LDA #2  [A]   = 2  &#13;
    mem[9]  =  0b0100000010     # SUB #2  [A]   = [A] - 3&#13;
    mem[10] =  0b1010001101     # BEQ 12&#13;
    mem[11] =  0b0000001111     # LDA #15 LDA #18 [A] = 18 Dummy not executed  &#13;
    mem[12] =  0b1110000000     # STOP&#13;
    mem[16] =  0b0000000100     # 4 Data for test&#13;
    mem[17] =  0b0000000101     # 5 Data for test  &#13;
    mem[31] =  0b1110000000     # Ensure STOP operation&#13;
    return(mem)&#13;
run = True                  # run is True for code execution. Setting run to False stops the computer&#13;
PC  = 0                     # The program counter points to the next instruction to execute. Initially 0&#13;
z = 0                       # Initialize z-bit (note no n and c bits implemented)&#13;
mem = progSet()</pre>&#13;
			<p lang="en-GB">Now that we’ve <a id="_idIndexMarker516"/>loaded memory with the program and set up some variables, we can enter the <code>fetch </code><code>execute</code> loop:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                 # MAIN LOOP – FETCH/EXECUTE&#13;
while run:                   # This is the fetch/execute cycle loop that continues until run is False&#13;
    MAR    = PC                  # FETCH PC to mem Address Register&#13;
    pcOld  = PC                  # Keep a copy of the PC for display&#13;
    PC     = PC + 1              # Increment PC&#13;
    MBR    = mem[MAR]            # Read the instruction, copy it to the mem Buffer Register&#13;
    IR     = MBR                 # Copy instruction to Instruction Register – prior to decoding it&#13;
    OpCode = (IR &gt;&gt; 7) &amp; 0x7     # Extract Op-Code from instruction bits 7 to 10 by shifting masking&#13;
    Dir    = (IR &gt;&gt; 6) &amp; 1       # Extract data direction from instruction (0 = read, 1 = write)&#13;
    Mode   = (IR &gt;&gt; 5) &amp; 1       # Extract address mode from instruction (0 = literal, 1 = mem)&#13;
    Lit     = IR &amp; 0x1F          # Extract literal/address field (0 = address, 1= literal)&#13;
                             # EXECUTE The EXECUTE block is an if statement, one for each opcode&#13;
    if OpCode == 0:          # Test for LDA and STA (Dir is 0 for load acc and 1 for store in mem)&#13;
        if Dir == 0:             # If Direction is 0, then it's a load accumulator, LDA&#13;
            if Mode == 0:        # Test for Mode bit to select literal or direct mem operand&#13;
                Acc = Lit        # If mode is 0, then the accumulator is loaded with L&#13;
            else:                # If mode is 1, then read mem to get operand&#13;
                MAR = Lit        # Literal (address) to MAR&#13;
                MBR = mem[MAR]   # Do a read to get operand in MBR&#13;
                Acc = MBR        # and send it to the accumulator&#13;
        else:&#13;
            MAR = Lit            # If Direction is 1, then it's a store accumulator&#13;
            MBR = Acc            # Copy accumulator to MBR&#13;
            mem[MAR] = MBR       # and write MBR to mem&#13;
    elif OpCode == 1:              # Test for ADD to accumulator&#13;
        if Mode == 0:              # Test for literal or direct mem operand&#13;
            total = Acc + Lit      # If mode is 0, then it's a literal operand&#13;
            if total == 0: z = 1   # Deal with z flag&#13;
            else: z = 0&#13;
        else:                      # If mode is 1, then it's a direct mem access&#13;
            MAR = Lit              # Literal (address) to MAR&#13;
            MBR = mem[MAR]         # Do a read to get operand in MBR&#13;
            total = MBR + Acc      # And send it to the accumulator&#13;
        if Dir == 0: Acc = total   # Test for destination (accumulator)&#13;
        else: mem[MAR] = total     # Or mem&#13;
    elif OpCode == 2:              # Test for SUB from accumulator&#13;
        if Mode == 0:              # Test for literal or direct mem operand&#13;
            total = Acc – Lit      # If mode is 0 then it's a literal operand&#13;
        else:                      # If mode is 1 then it's a direct mem access&#13;
            MAR = Lit              # Literal (address) to MAR&#13;
            MBR = mem[MAR]         # Do a read to get operand in MBR&#13;
            total = Lit – MBR      # and send it to the accumulator&#13;
        if total == 0: z = 1       # Now update z bit (in all cases)&#13;
        if Dir == 0: Acc = total   # Test for destination (accumulator)&#13;
        else: mem[MAR] = total     # Or mem</pre>&#13;
			<p lang="en-GB">The following block (dark shading) implements a clear operation. This instruction is not strictly necessary, because you can always load a zero or subtract x from X. For this reason, some computers do not incorporate a clear instruction. Some computers allow you to write <code>CLR</code> <a id="_idIndexMarker517"/>and then substitute an operation such as <code>SUB X,X</code>:</p>&#13;
			<pre>    elif OpCode == 3:              # Test for CLR (clear Accumulator or clear mem location)&#13;
        if Mode == 0:              # If Mode = 0 Then clear accumulator&#13;
            Acc = 0&#13;
        else:&#13;
            MAR = Lit              # If Mode = 1&#13;
            mem[MAR] = 0           # Then clear mem location mem[Literal]&#13;
    elif OpCode == 4:              # Test for BRA Branch unconditionally&#13;
        PC = Lit - 1          # Calculate new branch target address (-1 because PC auto increment)&#13;
    elif OpCode == 5:              # Test for BEQ Branch on zero&#13;
        if z == 1: PC = Lit - 1    # If z bit = 1 then calculate new branch target address&#13;
    elif OpCode == 6:              # Test for BNE Branch on not zero&#13;
        if z == 0: PC = Lit - 1    # If z bit = 0 calculate new branch target address&#13;
    elif OpCode == 7:               # Test for STOP&#13;
        run = False                 # If STOP then clear run flag to exit while loop and stop</pre>&#13;
			<p lang="en-GB">You could argue <a id="_idIndexMarker518"/>that we should have inserted a break or exit here because if we haven’t encountered a valid op-code by the end of the <code>execute</code> loop, the source code must be invalid:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# End of main fetch-execute loop&#13;
    mnemon = mnemonics.get(OpCode)  # Get the mnemonic for printing&#13;
    print('PC',pcOld, 'Op ',OpCode, 'Mode = ', Mode, 'Dir = ',Dir, \&#13;
          'mem', mem[16:19], 'z',z, 'Acc', Acc, mnemon)</pre>&#13;
			<p lang="en-GB">We now run this program. The output when running this program is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
PC 0  OpCode  0 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 4  LDA/STR&#13;
PC 1  OpCode  1 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 9  ADD&#13;
PC 2  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 9]  z 0 Acc 9  LDA/STR&#13;
PC 3  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  SUB&#13;
PC 4  OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  BEQ&#13;
PC 5  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 18 LDA/STR&#13;
PC 6  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 18] z 0 Acc 18 LDA/STR&#13;
PC 7  OpCode  3 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 0  CLR&#13;
PC 8  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 2  LDA/STR&#13;
PC 9  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  SUB&#13;
PC 10 OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  BEQ&#13;
PC 12 OpCode  7 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  STOP</pre>&#13;
			<h2 id="_idParaDest-138" lang="en-GB"><a id="_idTextAnchor144"/>Enhancing the TC2 Simulator</h2>&#13;
			<p lang="en-GB">The simple example of an accumulator-based machine illustrates several aspects of the implementation of instructions, the design of the instruction set, and the allocation of bits. The TC2 has <a id="_idIndexMarker519"/>a 3-bit opcode giving us eight operations. Or does it?</p>&#13;
			<p lang="en-GB">The direction bit, Dir, is employed only by the <code>LDA</code>/<code>STA</code> instruction. If we removed this bit from the opcode field, we would have a 4-bit opcode giving 16 instructions. Since <code>LDA</code> and <code>STA</code> would now be separate instructions, our eight-instruction computer would have nine instructions, leaving 16 – 9 = 7 new (i.e., unallocated) opcodes. We could have also used the direction flag with <code>ADD</code> and <code>SUB</code> instructions allowing the destination to be either the accumulator or memory. Consider the following example. The current TC2 simulator can increment variables <em class="italic">x</em> and <em class="italic">y</em> using the following code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      LDA  x&#13;
      ADD  #1&#13;
      STA  x&#13;
      LDA  y&#13;
      ADD  #1&#13;
      STA  y</pre>&#13;
			<p lang="en-GB">By extending the addition operation (<code>ADDA </code>to add to the accumulator and <code>ADDM</code> to add to memory), we can now write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      LDAA #1   ; Load accumulator with 1&#13;
      ADDM x    ; Add accumulator to memory location x&#13;
      ADDM y    ; Add accumulator to memory location y</pre>&#13;
			<p lang="en-GB">This enhancement <a id="_idIndexMarker520"/>halves the number of instructions, because we load the accumulator with the literal once and then add it to two different memory locations. The new code for the <code>ADD</code> operation is as follows:</p>&#13;
			<pre> if OpCode == 1:                 # Test for ADDA or ADDM instruction&#13;
    if Dir == 0:                 # Test for add to accumulator (Dir=0) or add to memory (Dir =1)&#13;
       if Mode == 0:             # Test for ADDA literal or direct memory operand&#13;
          Acc = Acc + Lit        # If mode is 0, then it's a literal operand&#13;
       else:                     # If mode is 1, then it's a direct memory access&#13;
          MAR = Lit              # Literal (address) to MAR&#13;
          MBR = Memory[MAR]      # Do a read to get operand in MBR&#13;
          Acc = MBR + Acc        # and send it to the accumulator&#13;
    if Dir == 1:                 # ADDM: add to memory version of ADD&#13;
       MAR = Lit                 # Set up the memory address&#13;
       MBR = Memory[MAR]         # Read memory contents&#13;
       MBR = MBR + Acc           # Add accumulator to memory&#13;
       Memory[MAR] = MBR         # And write back the result</pre>&#13;
			<p lang="en-GB">What else can we do to extend the instruction set? We allocated <em class="italic">three</em> opcodes to the branch group. That was <a id="_idIndexMarker521"/>very wasteful. Since each of these branch instructions has a direction and a mode bit that is unused, we can press these bits into service (i.e., redefine their meaning). Consider the arrangement of <em class="italic">Table 8.3</em>:</p>&#13;
			<table id="table002-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Operation</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Direction</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Mode</p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>BRA</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Undefined</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>BEQ</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>BNE</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption">Table 8.3 – Re-purposing the direction and mode bits</p>&#13;
			<p lang="en-GB">We have used the <code>Dir</code> and <code>Mode</code> instruction bits to select the branch type. As a bonus, we have a spare operation that is marked <em class="italic">undefined</em>. The code for the branch group is as follows. We’ve used shading to help identify the blocks. Note that in this example, we demonstrate how branches can be made program counter relative:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if OpCode == 3:                                # Test for the branch group&#13;
   if Dir == 0:                                # Direction 0 for unconditional&#13;
      if Mode == 0: PC = PC + Lit - 1          # If Mode is zero then unconditional branch&#13;
      else: run = 0                            # If Mode is 1 then this is undefined so stop&#13;
   else:&#13;
      if Dir == 1:                             # If direction is 1, it's a conditional branch&#13;
         if Mode == 0:                         # If mode is 0 then we have a BNE&#13;
            if Z == 0: PC = PC + Lit - 1       # Branch on Z = 0 (not zero)&#13;
         else:                                 # If Mode is 1 we have a BEQ&#13;
            if Z == 1: PC = PC + Lit - 1       # Branch on Z = 1 (zero)</pre>&#13;
			<p lang="en-GB">This code looks <a id="_idIndexMarker522"/>a little more complex than it is, because we have <code>if</code> statements nested four deep when we test for op-code, direction, mode, and then Z-bit. However, this example demonstrates how instruction bits can be reused to increase the number of instructions at the cost of decoding complexity.</p>&#13;
			<p lang="en-GB">There’s still room to maneuver and squeeze more functionality out of the instruction set. Look at the <code>CLR</code> instruction. We use the mode bit to clear memory or the accumulator. How about being a little creative and using the <em class="italic">direction</em> bit to provide another operation? Incrementing a register or memory is a common operation, so let’s provide that. We can use <code>Dir == 0</code> for <code>CLR</code> and <code>Dir == 1</code> for <code>INC</code> Memory/accumulator. The block shaded in gray is the original clear and the block shaded in blue is the new increment operation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if OpCode == 6:                    # Test for clear mem/Acc or increment mem/Acc&#13;
    if Dir == 0:                   # Direction = 0 for clear operation&#13;
        if Mode == 0:              # If Mode = 0&#13;
           Acc = 0                 # Then clear accumulator&#13;
        else:&#13;
           MAR = Lit               # If Mode = 1&#13;
           Memory[MAR] = 0         # Then clear memory location&#13;
    else:                          # Direction = 1 for increment&#13;
        if Mode == 0:              # If Mode = 0&#13;
           Acc = Acc + 1           # Then increment accumulator&#13;
        else:&#13;
           MAR = Lit               # If Mode = 1&#13;
           MBR = Memory[MAR]       # Then increment memory location&#13;
           MBR = MBR + 1           # Increment memory in MBR&#13;
           Memory[MAR] = MBR       # Write back incremented memory value</pre>&#13;
			<p lang="en-GB">Finally, consider <a id="_idIndexMarker523"/>the <code>STOP</code> (halt) instruction with the <code>111DMLLLLL</code> opcode. Here, we have 7 bits doing nothing. That is 27 = 128 combinations. If we were to reserve one code for halt, say, <code>1110000000</code>, we could allocate codes 1110000001 to <code>1111111111</code> to new instructions. The next section extends this architecture to create a more realistic simulator.</p>&#13;
			<h1 id="_idParaDest-139" lang="en-GB"><a id="_idTextAnchor145"/>TC3: A CISC machine with a register-to-memory architecture</h1>&#13;
			<p lang="en-GB">In this <a id="_idIndexMarker524"/>section, you will learn about the design of a simulator that implements a CISC-style instruction set architecture, providing both register-to-register and register-to-memory operations. TC3 is a more sophisticated version of TC2 with a more practical architecture.</p>&#13;
			<p lang="en-GB">TC3 supports register direct, register indirect, memory direct, and literal addressing modes. For example, <code>AND [R2], #129</code> performs a logical <code>AND</code> between the contents of the memory location pointed at by register <code>R2</code> and the binary value <code>10000001</code>.</p>&#13;
			<p lang="en-GB">We have included memory direct operations. These are intended to illustrate the features of a computer, rather than being practical. Early 8-bit microprocessors like the Motorola 6800 let you operate on memory directly. Most modern processors don’t. TC3 can access, say, memory at location 12 with <code>MOV</code> R2,<code>M:12</code>. This instruction loads register 2 with the contents of memory location 12. Note the syntax. A TC3 instruction provides a <a id="_idIndexMarker525"/>single literal field that can serve as a literal or a memory address, but not both at the same time. I’ve used <code>#</code> to indicate a literal and <code>M:</code> to indicate a memory address; consider <code>MOV </code>R2,<code>M:12</code> and <code>MOV </code>R2,<code>#12</code>. The former loads register <code>R2</code> with the contents of memory location <code>12</code>, and the latter loads <code>R2</code> with the integer <code>12</code>. With a single literal field in the instruction, TC3 can’t support an instruction like <code>MOV M:12,#127.</code></p>&#13;
			<h2 id="_idParaDest-140" lang="en-GB"><a id="_idTextAnchor146"/>The TC3 instruction set architecture</h2>&#13;
			<p lang="en-GB">The TC3 simulator is a one-and-a-half address CISC processor with a 24-bit instruction and an 8-bit data word length. This makes it a Harvard machine, because it has separate data and <a id="_idIndexMarker526"/>program memory. We have taken this approach for two reasons. First, an 8-bit data word is easy to work with from an educational point of view. Second, a 24-bit instruction provides functionality, without either using a large 32-bit word or employing variable-length instructions like some CISC processors.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 8</em><em class="italic">.4</em> describes the TC3’s instruction format, which has an instruction class and an op-code field, an addressing mode field, two register fields, and a literal field. The format is the same for all instructions.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_8.4_B19624.jpg" alt="Figure 8.4 – Instruction format of the TC3" width="1282" height="282"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 8.4 – Instruction format of the TC3</p>&#13;
			<p lang="en-GB">We use 8-bit registers, an 8-bit address, and an 8-bit literal to simplify the design. The data space is restricted to 28 = 256 locations, since the literal can access only 256 locations. Changing the instruction width to 32 bits and expanding the literal to 16 bits would provide a data space of 65,536 locations.</p>&#13;
			<p lang="en-GB">The TC3 has eight general-purpose registers, <code>R0</code> to <code>R7</code>. It requires 6 bits to provide source and destination register fields The instruction field is 6 bits wide and is divided into a 2-bit instruction-class field and a 4-bit op-code field. This allows up to 64 instructions with a maximum of 16 in each class. We took this approach (instruction class and op-code) to simplify the design. This is a rather inefficient approach in terms of instruction-space usage, because most instructions fall within one class and other classes are nearly empty.</p>&#13;
			<p lang="en-GB">The 4-bit mode field defines an instruction’s attributes (e.g., addressing modes). The TC3 supports the <a id="_idIndexMarker527"/>addressing modes defined by <em class="italic">Table 8.4</em>, that is, no-operand instructions, one-register instructions, instructions with a literal, and two-operand instructions. Although the TC3 supports only two operands (register + register and register + literal), there are three fields in the instruction. Consequently, the computer could be easily modified to provide three-operand instructions. We chose this approach to simplify instruction encoding and decoding. An alternative approach would be to provide two operand fields – a register field and a register or literal field:</p>&#13;
			<table id="table003-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Mode</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Address</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Example</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">RTL</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Class</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">No operand</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>STOP</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Single register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>INC R1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[R1]</code> ← <code>[R1] + 1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>1</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Literal offset</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>BEQ 123</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[pc]</code> ← <code>123</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Reserved</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Literal to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV R1,#M</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[R1]</code> ← <code>M</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV R1,R2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[R1]</code> ← <code>[</code><code>R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV R1,[R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[R1]</code> ← <code>[[</code><code>R2]]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">7</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register to register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV [R1],R2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[[R1]]</code> ← <code>[</code><code>R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">8</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect to register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV [R1],[R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[[R1]]</code> ← <code>[[</code><code>R2]]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">9</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register to memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV M:123,R2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>M[123] ← [</code><code>R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">10</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect to memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-2" lang="en-GB"><code>MOV M:123,[R2]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>M[123]</code> ← <code>[[</code><code>R2]]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">11</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Memory to register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>MOV R1,M:123</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[R1]</code> ← <code>M[123]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">12</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Memory to register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-2" lang="en-GB"><code>MOV [R1],M:123</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><code>[[R1]]</code> ← <code>M[123] </code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">13-15</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Reserved</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption">Table 8.4 – TC3 processor addressing modes</p>&#13;
			<p lang="en-GB">Consider the following assembly language program that runs on this computer. We wish to add together two vectors plus an integer, that is, <em class="italic">z</em>i = xi + yi + 5 for <em class="italic">i</em> = 0 to 3. The following code <a id="_idIndexMarker528"/>should be largely self-explanatory. Literals are prefixed with #, and a label in an instruction is terminated with a colon. The first part of the code uses the <code>RND R5</code> instruction to fill vectors <code>X</code> and <code>Y</code> with random numbers to aid testing.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      Code          @ Comment                        Instruction encoding&#13;
      MOV  R0,#     @ Point to memory location 8&#13;
Next: RND  R5       @ REPEAT: generate random value in r5&#13;
      MOV  [R0],R5  @ store r5 at location pointed at by r0&#13;
      DEC  R0       @ decrement r0 pointer&#13;
      BNE  Next     @ UNTIL zero&#13;
      EQU  X,#1     @ Vector X memory 1 to 4&#13;
      EQU  Y,#5     @ Vector Y memory 5 to 8&#13;
      EQU  Z,#9     @ Vector Z memory 9 to 12&#13;
      MOV  R0,#X    @ r0 points to array X                    00 0000 0010 000 000 00000001&#13;
      MOV  R1,#Y    @ r1 points to array Y                   00 0000 0010 001 000 00000101&#13;
      MOV  R2,#Z    @ r2 points to array Z                      00 0000 0010 010 000 00001001&#13;
      MOV  R3,#4    @ r3 number of elements to add in r3        00 0000 0010 011 000 00000100&#13;
Loop: MOV  R4,[R0]  @ Get xi                            00 0000 0000 100 000 00000000&#13;
      ADD  R4,#5    @ Add 5 to xi                         00 0001 0010 100 000 00000101&#13;
      ADD  R4,[R1]  @ Add xi + 5 to yi Memory to reg operation    00 0001 0001 100 001 00000000&#13;
      MOV  [R2],R4  @ Store result in array Z                 00 0000 0100 010 100 00000000&#13;
      INC  R0       @ Increment pointer to array X             00 1100 0000 000 000 00000000&#13;
      INC  R1       @ Increment pointer to array Y               00 1100 0000 001 000 00000000&#13;
      INC  R2       @ Increment pointer to array Z             00 1100 0000 010 000 00000000&#13;
      DEC  R3       @ Decrement loop counter                00 1101 0000 011 000 00000000&#13;
      BNE  Loop     @ Continue until counter 0              01 0011 0000 000 000 00000100</pre>&#13;
			<p lang="en-GB">This example <a id="_idIndexMarker529"/>uses literal, register direct, and register indirect (pointer-based) addressing. We have provided the binary code of each instruction with the class, op-code, addressing mode, registers, and literal fields.</p>&#13;
			<p lang="en-GB">Initially, we didn’t construct an assembler for this simulator. However, it was such a pain to hand-code the instructions that an assembler was incorporated. The key to both the assembler and simulator is the <code>mode</code> field of the instruction, which indicates the addressing mode.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When an instruction in mnemonic form is read, it is examined, and its addressing modes and operands are used to determine the four mode bits required by the instruction. The reverse action is carried out when the instruction is executed, and the mode bits are used to implement the appropriate addressing modes. For example, if the instruction is <code>LDR </code><code>R6,#5</code>, the mode is <code>4</code> and the assembler stores <code>6</code> in the first register field and <code>5</code> in the literal field. When the instruction is executed, the simulator uses the mode bits, <code>0100</code>, to determine that the destination register is <code>110</code> and the literal is <code>00000101</code>.</p>&#13;
			<p lang="en-GB">The first part of the TC3 simulator is given as follows. We create two lists: one for the program memory and one for the data memory (pMem and dMem). The instructions in program memory are imported from a file. The data memory is set up as 16 locations that are initialized to 0. The text file containing the source program is src and is processed to reformat instructions and remove assembler directives.</p>&#13;
			<p lang="en-GB">The shaded <a id="_idIndexMarker530"/>section of the code was added to detect the <code>'END'</code> directive in the source code, which terminates the assembly processing and acts as a <code>STOP</code> when the code is executed. I added it for convenience. I sometimes want to test one or two instructions but don’t want to write a new source code program. I can put the code under test at the top of an existing program, followed by <code>END</code>. All code after <code>END</code> is ignored. Later, I can delete the new code and <code>END</code>.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sTab = {}                             # Symbol table for equates and labels name:integerValue&#13;
pMem = []                             # Program memory (initially empty)&#13;
dMem = [0]*16                         # Data memory. Initialized and 16 locations&#13;
reg  = [0]*8                          # Register set&#13;
z,c,n = 0,0,0                         # Define and status flags: zero, carry, negative&#13;
testCode = "E:\\AwPW\\TC3_NEW_1.txt"  # Source filename on my computer&#13;
with open(testCode) as src:           # Open the source file containing the assembly program&#13;
    lines = src.readlines()           # Read the program into lines&#13;
src = [i[0:-1].lstrip() for i in lines ]&#13;
                                      # Remove the /n newline from each line of the source code&#13;
src = [i.split("@")[0] for i in src]           # Remove comments in the code&#13;
src = [i for i in src if i != '']     # Remove empty lines&#13;
for i in range(0,len(src)):           # Scan source code line-by-line&#13;
    src[i] = src[i].replace(',',' ')  # Replace commas by a space&#13;
    src[i] = src[i].upper()           # Convert to upper-case&#13;
    src[i] = src[i].split()           # Split into tokens (label, mnemonic, operands)&#13;
src1 = []                             # Set up dummy source file, initially empty&#13;
for i in range (0,len(src)):          # Read source and stop on first END instruction&#13;
    src1.append(src[i])               # Append each line to dummy source file&#13;
    if src[i][0] == 'END': break      # Stop on 'END' token&#13;
src = src1                            # Copy dummy file to source (having stopped on 'END')&#13;
for i in range (0,len(src)):          # Deal with equates of the form EQU PQR 25&#13;
    if src[i][0] == 'EQU':            # If the line is 3 or more tokens and first token is EQU&#13;
        sTab[src[i][1]] = getL(src[i][2])      # Put token in symbol table as integer&#13;
src = [i for i in src if i.count('EQU') == 0]  # Remove lines with "EQU" from source code</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The following code takes an instruction in assembly language form, tokenizes it, and converts it into the bit pattern of an instruction. In the following code, we use ic as the instruction counter, which steps through the source program line by line.</p>&#13;
			<p lang="en-GB">One issue we <a id="_idIndexMarker531"/>must deal with is the label. Some instructions have one and some don’t. That means that the mnemonic is token <code>0</code> for an instruction without a label, and token <code>1</code> if there is a label. The Python code checks for a label (which ends in a colon). If a label is found, <code>j</code> is set to <code>1</code>, and, if not found,<code> j</code> is set to <code>0</code>. We then use <code>j</code> to calculate the location of tokens in the instruction. The tLen variable is the number of tokens in an instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for ic in range(0,len(src)):           # ASSEMBLY LOOP (ic = instruction counter)&#13;
    t0,t1,t2 = '', '', ''              # Prepare to assign tokens. Initialize to null string&#13;
    if src[ic][0][-1] != ':':          # If the first token doesn't end in colon, it's an instruction&#13;
        j = 0                          # j = 0 forline starting with mnemonic&#13;
    else:                              # If the first token ends in a colon it's a label&#13;
        j = 1                          # j = 1 if mnemonic is second token&#13;
    t0 = src[ic][j]                    # Set t0 to mnemonic j selects first or second token&#13;
    if len(src[ic]) &gt; 1+j: t1 = src[ic][j+1]  # Set t1 to ingle operand&#13;
    if len(src[ic]) &gt; 2+j: t2 = src[ic][j+2]  # Set t2 to second operand&#13;
    tLen = len(src[ic]) - j - 1         # tLen is the number of tokens (adjusted for any label)</pre>&#13;
			<p lang="en-GB">The next section <a id="_idIndexMarker532"/>of the assembler does all the work. Here, we generate the binary code. Unlike other simulators we’ve developed, we use directories and lists to detect registers, as the following (partial) code shows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rName   = {'R0':0,'R1':1,'R2':2,'R3':3}  # Relate register name to numeric value (lookup table)&#13;
rNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3}&#13;
                                         # Look for register indirect addressing (lookup table)&#13;
iClass0 = ['STOP', 'NOP', 'END']         # Instruction class 00 mnemonic with no operands&#13;
iClass1 = ['BRA',  'BEQ', 'BNE','CZN' ]  # Instruction class 01 mnemonic with literal operand</pre>&#13;
			<p lang="en-GB">Now, we can take a token and ask whether it’s in <code>rName</code> to detect <code>R0 </code>to <code>R7</code>, or whether it’s in <code>rNamInd</code> to detect whether it’s <code>[R0]</code> to <code>[R7]</code>. Moreover, we can use the mnemonic from an instruction and ask whether it’s in each class in turn in order to determine the two class bits of the instruction; for example, if <code>t0</code> is the first token (corresponding to the mnemonic), we can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if t0 in iClass0: mode = 0.</pre>&#13;
			<p lang="en-GB">Similarly, we can use if t1 in <code>rNamInd</code> to determine whether the second token is a register used as a pointer (e.g., <code>[R4]</code>).</p>&#13;
			<p lang="en-GB">The most complex <a id="_idIndexMarker533"/>class of instructions is <code>iClass3</code>, which deals with two-operand instructions, such as <code>ADD [R3],R4</code>. In this case, token <code>t0</code> would be <code>'ADD'</code>, token <code>t1</code> would be <code>'</code><code>[r3]'</code>, and token <code>t2</code> would be <code>'R4'</code>. To identify the class of this instruction, we look for a first operand, which is an indirect register, and a second operand, which is a register, as follows:</p>&#13;
			<pre class="source-code"> if (t1 in rNamInd) and (t2 in rName): mode = 7</pre>&#13;
			<p lang="en-GB">The code that determines the mode of an instruction is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binC = 0                                  # Initialize binary code for this instruction to all zeros&#13;
opCode = mnemon[t0]                       # Look up op-code in table mnemon using token t0&#13;
iClass = opCode &gt;&gt; 4                      # Get two most significant bits of op-code (i.e., class)&#13;
if   t0 in iClass0:                       # If in iClass0 it's a single instruction, no operands&#13;
    mode = 0                              # The mode is 0 for everything in this class&#13;
    binC = (mnemon[t0] &lt;&lt; 18)             # All fields zero except op_code&#13;
elif t0 in iClass1:                       # If in iClass1 it's an 0p-code plus offset (e.g., branch)&#13;
    mode = 1                              # All class 1 instruction are mode 1 (op-code plus literal)&#13;
    binC = (mnemon[t0] &lt;&lt; 18)+(mode &lt;&lt; 14)+getL(t1)&#13;
                                          # Create binary code for Class1 instruction&#13;
elif t0 in iClass2:                       # If in iClass2 it's an op-code plus register number&#13;
    mode = 2                              # All iClass2 instructions are mode 2&#13;
    binC = (mnemon[t0] &lt;&lt; 18)+(mode &lt;&lt; 14)+(rName[t1] &lt;&lt; 11&#13;
                                          # Construct binary code of instruction&#13;
elif t0 in iClass3:                       # All data-processing and movement ops in iClass3&#13;
    if   (t1 in rName) and (t2[0] == '#'): # Look for register name and literal for mode 4&#13;
        mode = 4&#13;
    elif (t1 in rName) and (t2 in rName): # Look for register name and register name for mode 5&#13;
        mode = 5&#13;
    elif (t1 in rName) and (t2 in rNamInd):   # Look for R0,[R2]) format&#13;
        mode = 6&#13;
    elif (t1 in rNamInd) and (t2 in rName):   # Look for instruction format [R1],R2&#13;
        mode = 7&#13;
    elif (t1 in rNamInd) and (t2 in rNamInd): # Look for two register indirect names [R1],[R2]&#13;
        mode = 8&#13;
    elif (t1[0:2] == 'M:') and (t2 in rName):&#13;
                                      # Look for memory address M: and reg name M:12,r4&#13;
        mode = 9&#13;
    elif (t1[0:2] == 'M:') and (t2 in rNamInd): # Look for M:12,[R4] format&#13;
        mode = 10&#13;
    elif (t1 in rName) and (t2[0:2] == 'M:'): # Look for register name and literal prefixed by M:&#13;
        mode = 11&#13;
    elif (t1 in rNamInd) and (t2[0:2] == 'M:'):&#13;
                                      # Look for register indirect name and literal prefixed by M:&#13;
        mode = 12</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">After extracting the instruction class, op-code, and mode, the final step is to get the actual register numbers and any literals. In the following fragment of code, we define the two register <a id="_idIndexMarker534"/>fields and the literal field, respectively. These are <code>rField1</code>, <code>rField2</code>, and <code>lField</code> and are all initialized to <code>0</code>, because instructions without three fields have the corresponding bits set to <code>0</code>.</p>&#13;
			<p lang="en-GB">Here, we use the list as a very convenient method for extracting fields rather than combined if and or operators. For example, register field <code>1</code> is used by modes <code>4</code>, <code>5</code>, <code>6</code>, and <code>11</code>. We could write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 if (mode == 4) or (mode == 5) or (mode == 6) or (mode == 11):</pre>&#13;
			<p lang="en-GB">However, we can write instead, which is far easier to read:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 if mode in [4,5,6,11]:</pre>&#13;
			<p lang="en-GB">The following code shows how the three register/literal fields are evaluated:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  # Insert op_Code and mode fields in instruction&#13;
rField1, rField2, lField = 0, 0, 0        # Calculate register and literal fields. Initialize to zero&#13;
if mode in [4,5,6,11]: rField1 = rName[t1] # Convert register names into register numbers&#13;
if mode in [7,8,12]:   rField1 = rNamInd[t1]&#13;
if mode in [5,7,9]:    rField2 = rName[t2] # rField2 is second register field&#13;
if mode in [6,8,10]:   rField2 = rNamInd[t2]&#13;
if mode in [4,11,12]:  lField  = getL(t2)&#13;
                                  # if (mode==4) or (mode==11) or (mode==12): lField = getL(t2)&#13;
if mode in [9,10]:     lField  = getL(t1)&#13;
                                  # if (mode == 9) or (mode == 10): lField = getL(t1) Literal field</pre>&#13;
			<p lang="en-GB">The following two <a id="_idIndexMarker535"/>lines of the code-generation logic insert the register/literal fields by shifting and executing OR on bits and append the current binary instruction, binC, to the program memory, pMem:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binC = binC + (rField1 &lt;&lt; 11) + rField2 &lt;&lt; 8) + lField&#13;
                                  # Binary code with register and literal fields&#13;
pMem.append(binC)                 # Append instruction to program memory</pre>&#13;
			<h2 id="_idParaDest-141" lang="en-GB"><a id="_idTextAnchor147"/>Features of the simulator</h2>&#13;
			<p lang="en-GB">The simulator <a id="_idIndexMarker536"/>part of TC3 is relatively straightforward. Here, I’ll simply provide a few comments on some of its features to aid in understanding the code.</p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">1.	</strong><strong class="bold">Printing data</strong></p>&#13;
			<p lang="en-GB">The number of items to be displayed increased during the simulator’s development. So, we created a list of strings, one for each item to be printed, and then concatenated the items. For example, this is the print mechanism I used to display data during assembly:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
### Display assembly details of each instruction for diagnostics&#13;
pcF  = "{0:&lt;20}".format(" ".join(src[ic]))    # 1. instruction&#13;
icF  = 'pc = ' + "{:&lt;3}".format(ic)           # 2. pc&#13;
binF = format(binC, "024b")                   # 3. Binary encoding&#13;
iClF = 'Class = '+ str(iClass)                # 4. instruction class&#13;
modF = 'mode = ' + str(mode)                  # 5. instruction mode. Convert mode to string&#13;
t0F  = "{:&lt;5}".format(t0)                     # 6. token 0 (mnemonic)&#13;
t1F  = "{:&lt;5}".format(t1)                     # 7. token 1 (register field 1)&#13;
t2F  = "{:&lt;10}".format(t2)                    # 8. token 2 (register field 2 or literal)&#13;
print(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F)   # Print these fields</pre>&#13;
			<p lang="en-GB">The <code>displayLevel</code> parameter <a id="_idIndexMarker537"/>is included to determine what information was printed during the assembly process. For example, we could write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if displayLevel &gt; 4: print('Binary code =', xyz)</pre>&#13;
			<p lang="en-GB">This would print binary code only when debugging is required by setting the variable to <code>5</code> or greater.</p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">2.	Implementing add </strong><strong class="bold">with carry</strong></p>&#13;
			<p lang="en-GB">When I implemented the ALU with its numbered functions, I initially forgot to include <code>ADC</code>, add with carry. Rather than renumbering the functions, I converted the <code>ADD</code> into a dual <code>ADD</code>/<code>ADC</code> operation by first performing an addition. Then, if the op-code was an <code>ADC</code>, add the carry bit:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
elif fun == 1:                             # ADD:&#13;
        res = (op1 + op2)                  # Perform addition of operands&#13;
        if thisOp == 'ADC': res = res + c  # If operation ADC then add carry bit</pre>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">3.	Dealing with simple </strong><strong class="bold">instruction classes</strong></p>&#13;
			<p lang="en-GB">Here is the code <a id="_idIndexMarker538"/>used to deal with class 1 instructions. We do not have to worry about decoding the mode as there is only one mode for this class. Of course, the class could be extended (in the future) by the addition of other modes.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
elif opClass == 1:                         # Class 1 operation instructions with literal operand&#13;
    if    thisOp == 'BRA': pc = lit        # BRA Branch unconditionally PC = L&#13;
    elif (thisOp == 'BEQ') and (z == 1): pc = lit    # BEQ Branch on zero&#13;
    elif (thisOp == 'BNE') and (z == 0): pc = lit    # BNE Branch on not zero&#13;
    elif  thisOp == 'CZN':                 # Set/clear c, z, and n flags&#13;
        c = (lit &amp; 0b100) &gt;&gt; 2             # Bit 2 of literal is c&#13;
        z = (lit &amp; 0b010) &gt;&gt; 1             # Bit 1 of literal is z&#13;
        n = (lit &amp; 0b001)                  # Bit 0 of literal is n</pre>&#13;
			<p lang="en-GB">Class 1 instructions have an op-code and literal and are generally used to implement branch operations. Notice that we compare the current instruction with a name (e.g., <code>'BRA'</code>) rather than an op-code, as we did in other simulators. The use of a table of reverse op-code-to-mnemonic translations makes life much easier.</p>&#13;
			<p lang="en-GB">We have added a <code>CZN</code> (carry zero negative) instruction, which allows us to preset condition codes; for example, <code>CZN #%101</code> sets <code>c</code> and <code>n</code> to <code>1</code>, and <code>z</code> to <code>0</code>. Computers often have an operation that allows you to test condition codes, clear them, set them, and toggle (flip) them.</p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">4.	</strong><strong class="bold">Handling literals</strong></p>&#13;
			<p lang="en-GB">TC3’s numeric values <a id="_idIndexMarker539"/>can be expressed in several formats, for example, binary, where we represent <code>8</code> by <code>%1000</code>. Literal processing in TC3 must also deal with special formats, such as M:12, which indicates a memory address. The following function performs all the literal processing and handles several formats. It can also deal with literals that are symbolic names that must be looked up in the symbol table:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def getL(lit8):                               # Convert string to integer&#13;
    lit8v = 9999                              # Dummy default&#13;
    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  # Strip M: prefix from memory literal addresses&#13;
    if lit8[0:1]   == '#':  lit8  = lit8[1:]  # Strip # prefix from literal addresses&#13;
    if   type(lit8) == int: lit8v = lit8      # If integer, return it&#13;
    elif lit8.isnumeric():  lit8v = int(lit8) # If decimal in text form convert to integer&#13;
    elif lit8 in sTab:      lit8v = sTab[lit8]       # If in symbol table, retrieve it&#13;
    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  # If binary string convert to int&#13;
    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) # If hex string convert it to int&#13;
    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) &amp; 0xFF&#13;
                                               # If decimal negative convert to signed int&#13;
    return(lit8v)                              # Return integer corresponding to text string</pre>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">5.	</strong><strong class="bold">Result Writeback</strong></p>&#13;
			<p lang="en-GB">After performing an ALU operation or a data movement, the resulting operand must be written back into the computer. However, because we have specified a two-operand CISC-style format, the result of a calculation can be written to a register (like any RISC operation), it can be <a id="_idIndexMarker540"/>written to a memory location pointed at by a register, or it can be written to a memory operation specified by its address. The following fragment of code demonstrates TC3’s writeback:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
op3 = alu(fun,op1,op2)                          # Call ALU to perform the function&#13;
if mode in [4,5,6,11]: reg[reg1] = op3          # Writeback ALU result in op3 to a register&#13;
elif mode in [7,8,12]: dMem[reg[reg1]] = op3    # Writeback result to mem pointed at by reg&#13;
elif mode in [9,10]:   dMem[lit]       = op3    # Writeback result to memory</pre>&#13;
			<h3 lang="en-GB">Sample output</h3>&#13;
			<p lang="en-GB">The following is a <a id="_idIndexMarker541"/>sample of the output from the simulator that demonstrates integer handling. We have written a program with six different ways of inputting a literal. In each case, we load the literal into register <code>r0</code>. The source program is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 EQU www,#42&#13;
 MOV r0,#12&#13;
 MOV r0,#%11010&#13;
 MOV r0,#0xAF&#13;
 MOV r0,#-5&#13;
 MOV r0,M:7&#13;
 MOV r0,#www&#13;
 NOP&#13;
 STOP&#13;
 END</pre>&#13;
			<p lang="en-GB">In the following code block, we have the output of TC3. This output has been designed for the purpose <a id="_idIndexMarker542"/>of developing and testing the simulator (for example, following the assembly process):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Source code                     This is the tokenized source code&#13;
['MOV', 'R0', '#12']&#13;
['MOV', 'R0', '#%11010']&#13;
['MOV', 'R0', '#0XAF']&#13;
['MOV', 'R0', '#-5']&#13;
['MOV', 'R0', 'M:7']&#13;
['MOV', 'R0', '#WWW']&#13;
['NOP']&#13;
['STOP']&#13;
['END']&#13;
Equate and branch table          This is the symbol table. Only one entry&#13;
WWW      42</pre>&#13;
			<p lang="en-GB">The following is <a id="_idIndexMarker543"/>the output during the assembly and analysis phase:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Assembly loop&#13;
MOV R0 #12     pc=0 110000010000000000001100 Class=3 mode=4 MOV   t1=R0 #12&#13;
MOV R0 #%11010   pc=1 1110000010000000000011010   Class=3  mode=4   MOV   t1=R0 #%11010&#13;
MOV R0 #0XAF   pc=2 110000010000000010101111 Class=3 mode=4  MOV  t1=R0 #0XAF&#13;
MOV R0 #-5     pc=3 110000010000000011111011 Class=3 mode=4  MOV  t1=R0 #-5&#13;
MOV R0 M:7     pc=4 110000101100000000000111 Class=3 mode=11 MOV  t1=R0 M:7&#13;
MOV R0 #WWW    pc=5 110000010000000000101010 Class=3 mode=4  MOV  t1=R0 #WWW&#13;
NOP            pc=6 000000000000000000000000 Class=0 mode=0  NOP  t1 =&#13;
STOP           pc=7 001110000000000000000000 Class=0 mode=0  STOP t1 =&#13;
END            pc=8 001111000000000000000000 Class=0 mode=0  END  t1 =&#13;
110000010000000000001100      This is the program in binary form&#13;
110000010000000000011010&#13;
110000010000000010101111&#13;
110000010000000011111011&#13;
110000101100000000000111&#13;
110000010000000000101010&#13;
000000000000000000000000&#13;
001110000000000000000000</pre>&#13;
			<pre class="source-code">001111000000000000000000</pre>&#13;
			<p lang="en-GB">In the following code block, we have the single-step execution output. It’s been edited to help fit it <a id="_idIndexMarker544"/>on the page. We printed only two memory locations for each line. The literal in the instruction and its value in <code>r0</code> are printed in bold:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
EXECUTE&#13;
MOV R0 <strong class="bold">#12</strong>     pc=0  110000010000000000001100 Class=3 mode=4  &#13;
Reg=<strong class="bold">0c</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0&#13;
MOV R0 <strong class="bold">#%11010</strong> pc=1  110000010000000000011010 Class=3 mode=4  &#13;
Reg=<strong class="bold">1a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0&#13;
MOV R0 <strong class="bold">#0XAF</strong>   pc=2  110000010000000010101111 Class=3 mode=4  &#13;
Reg=<strong class="bold">af</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1&#13;
MOV R0 <strong class="bold">#-5</strong>     pc=3  110000010000000011111011 Class=3 mode=4  &#13;
Reg=<strong class="bold">fb</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1&#13;
MOV R0 <strong class="bold">M:7</strong>     pc=4  110000101100000000000111 Class=3 mode=11 &#13;
Reg=<strong class="bold">07</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0&#13;
MOV R0 <strong class="bold">#WWW</strong>    pc=5  110000010000000000101010 Class=3 mode=4  &#13;
Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0&#13;
NOP            pc=6  000000000000000000000000 Class=0 mode=0  &#13;
Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0&#13;
STOP           pc=7  001110000000000000000000 Class=0 mode=0  &#13;
Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</pre>&#13;
			<h1 id="_idParaDest-142" lang="en-GB"><a id="_idTextAnchor148"/>The complete TC3 code</h1>&#13;
			<p lang="en-GB">We have discussed the design of TC3. Here, we present the code of a complete simulator. There are some slight differences between the descriptive fragments of code we described in the <a id="_idIndexMarker545"/>previous section and this more complete simulator. This is followed by a sample run of the simulator. The first part of the code defines the instruction modes and provides a simple source program that will be executed:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
### TC3 CISC machine&#13;
### Demonstration register-to-memory architecture Designed 22 January 2022.&#13;
### Instruction formats and addressing modes&#13;
### Mode 0:  NOP, STOP        No operand length 1&#13;
### Mode 1:  INC R1           Single register operand&#13;
### Mode 2:  BEQ XXX          Literal operand&#13;
### Mode 3:  Reserved&#13;
### Mode 4:  MOV r1,literal   Two-operand, register and literal&#13;
### Mode 5:  MOV r1,r2        Two-operand, register to register&#13;
### Mode 6:  MOV r1,[r2]      Two-operand, register indirect to register&#13;
### Mode 7:  MOV [r1],r2      Two-operand, register to register indirect&#13;
### Mode 8:  MOV [r1],[r2]    Two-operand, register indirect to register indirect&#13;
### Mode 9:  MOV M,r2         Two-operand, register to memory address&#13;
### Mode 10: MOV M,[r2]       Two-operand, register indirect to memory address&#13;
### Mode 11: MOV r1,M         Two-operand, memory address to register&#13;
### Mode 12: MOV [r1],M       Two-operand, memory address to register indirect&#13;
### The sample test code&#13;
###       MOV  r0,#8      @ Memory locations 1 to 8 with random numbers&#13;
### Next: RND  r5&#13;
###       MOV  [r0],r5&#13;
###       DEC  r0&#13;
###       BNE  Next&#13;
###       EQU   X,#1      @ Vector 1&#13;
###       EQU   Y,#5      @ Vector 5&#13;
###       EQU   Z,#9      @ Vector 9&#13;
###       MOV   r1,#X     @ r0 points to array X              11 0000 0100 000 000 00000001&#13;
###       MOV   r2,#Y     @ r1 points to array Y              11 0000 0100 001 000 00000101&#13;
###       MOV   r3,#Z     @ r2 points to array Z               11 0000 0100 010 000 00001001&#13;
###       MOV   r4,#6     @ r4 number of elements to add      11 0000 0100 011 000 00000100&#13;
### Loop: MOV   r5,[r1]   @ REPEAT: Get xi                 11 0000 0110 100 000 00000000&#13;
###       ADD   r5,#6     @ Add 6 to xi                   11 0001 0100 100 000 00000101&#13;
###       ADD   r5,[r2]   @ Add xi + 5 to yi                 11 0001 0110 100 001 00000000&#13;
###       MOV   [r3],r5   @ Store result in array Z            11 0000 0111 010 100 00000000&#13;
###       INC   r1        @ Increment pointer to array X        10 0000 0010 000 000 00000000&#13;
###       INC   r2        @ Increment pointer to array Y        10 0000 0010 001 000 00000000&#13;
###       INC   r3        @ Increment pointer to array Z          10 0000 0010 010 000 00000000&#13;
###       DEC   r4        @ Decrement loop counter           10 0001 0010 011 000 00000000&#13;
###       BNE   Loop      @ Continue until counter zero         01 0010 0001 000 000 00000100&#13;
###       STOP                                        00 1111 0000 000 000 00000000</pre>&#13;
			<p lang="en-GB">The following block contains the dictionaries for instruction decoding and register lookup. We’ve provided <a id="_idIndexMarker546"/>reverse lookup so that you can look up a mnemonic to get its code or look up the code to get the mnemonic. Similarly, we’ve provided lookup for registers, such as <code>R0</code> and <code>R2</code>, and indirect registers, such as <code>[R0]</code> and <code>[R1]:</code></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
import random                                 # Get library of random number operations&#13;
### Dictionaries and variables&#13;
mnemon  = {'MOV':48,'MOVE':48,'ADD':49,'SUB':50,'CMP':51,'NOT':52,'AND':53, \&#13;
           'OR':54,'EOR':55,'ONES':56, 'MRG':57,'FFO':58,'LSL':59,'LSR':60, \&#13;
           'ADC':61,'INC':32,'DEC':33,'RND':34,'CZN':19,'TST':36,'NOP':0,   \&#13;
           'BRA':16,'BEQ':17,'BNE':18,'STOP':14,'END':15}&#13;
mnemonR = {48:'MOV',49:'ADD',50:'SUB',51:'CMP',52:'NOT',53:'AND',54:'OR',   \&#13;
           55:'EOR',56:'ONES',57:'MRG',58:'FFO',59:'LSL',60:'LSR',61:'ADC', \&#13;
           32:'INC',33:'DEC', 34:'RND',19:'CZN',36:'TST',0:'NOP',16:'BRA',  \&#13;
           17:'BEQ',18:'BNE',14:'STOP',15:'END'}&#13;
rName   = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} # Register tab&#13;
rNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3,'[R4]':4,' \&#13;
           '[R5]':5,'[R6]':6,'[R7]':7}                       # Indirect registers&#13;
iClass0 = ['STOP', 'NOP','END']         # class 00 mnemonic with no operands&#13;
iClass1 = ['BRA','BEQ','BNE','CZN']     # class 01 mnemonic with literal operand&#13;
iClass2 = ['INC','DEC','RND','TST']     # class 10 mnemonic with register operand&#13;
iClass3 = ['MOV','MOVE','ADD','ADC','SUB','CMP', 'NOT','AND','OR', \&#13;
           'EOR','ONES','MRG','FFO','LSL','LSR']   # class 11 mnemonic two operands&#13;
sTab = {}                              # Symbol table for equates and labels name:integerValue&#13;
pMem = []                              # Program memory (initially empty)&#13;
dMem = [0]*16                          # Data memory&#13;
reg  = [0]*8                           # Register set&#13;
z,c,n = 0,0,0                          # Define and clear flags zero, carry, negative</pre>&#13;
			<p lang="en-GB">The following two functions provide the ability to read integer operands in various formats, and an ALU that <a id="_idIndexMarker547"/>performs arithmetic and logic operations. Both of these functions can be expanded to provide additional capabilities:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def getL(lit8):                                # Convert string to integer&#13;
    lit8v = 9999                               # Dummy default&#13;
    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  # Strip M: prefix from memory literal addresses&#13;
    if lit8[0:1]   == '#':  lit8  = lit8[1:]   # Strip # prefix from literal addresses&#13;
    if   type(lit8) == int: lit8v = lit8       # If integer, return it&#13;
    elif lit8.isnumeric():  lit8v = int(lit8)  # If decimal in text from convert to integer&#13;
    elif lit8 in sTab:      lit8v = sTab[lit8] # If in symbol table, retrieve it&#13;
    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  # If binary string convert to int&#13;
    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) # If hex string convert to int&#13;
    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) &amp; 0xFF&#13;
                                               # If decimal negative convert to signed int&#13;
    return(lit8v)                              # Return integer corresponding to text string&#13;
def alu(fun,op1,op2):             # Perform arithmetic and logical operations on operands 1 and 2&#13;
    global z,n,c                               # Make flags global&#13;
    z,n,c = 0,0,0                              # Clear status flags initially&#13;
    if   fun == 0: res = op2             # MOV: Perform data copy from source to destination&#13;
    elif fun == 1:                       # ADD: Perform addition - and ensure 8 bits plus carry&#13;
        res = (op1 + op2)                      # Do addition of operands&#13;
        if thisOp == 'ADC': res = res + c      # If operation ADC then add carry bit&#13;
    elif fun == 2: res = (op1 - op2)           # <code>SUB</code>: Perform subtraction&#13;
    elif fun == 3: res = op1 - op2        # <code>CMP</code>: Same as subtract without writeback&#13;
    elif fun == 4: res = op1 &amp; op2        # <code>AND</code>: Perform bitwise AND&#13;
    elif fun == 5: res = op1 | op2        # <code>OR</code>&#13;
    elif fun == 6: res = ~op2             # <code>NOT</code>&#13;
    elif fun == 7: res = op1 ^ op2        # <code>XOR</code>&#13;
    elif fun == 8:&#13;
        res = op2 &lt;&lt; 1                    # <code>LSL</code>: Perform single logical shift left&#13;
    elif fun == 9:&#13;
        res = op2 &gt;&gt; 1                    # <code>LSR</code>: Perform single logical shift right&#13;
    elif fun == 10:                       # <code>ONES</code> (Count number of 1s in register)&#13;
       onesCount = 0                      # Clear the 1s counter&#13;
       for i in range (0,8):        # For i = 0 to 7 (test each bit) AND with 10000000 to get msb&#13;
           if op2 &amp; 0x80 == 0x80:         # If msb is set&#13;
               onesCount = onesCount + 1  # increment the 1s counter&#13;
           op2 = op2 &lt;&lt; 1                 # shift the operand one place left&#13;
       res = onesCount                    # Destination operand is 1s count&#13;
    elif fun == 11:                       # <code>MRG</code> (merge alternate bits of two registers)&#13;
         t1 = op1 &amp; 0b10101010            # Get even source operand bits&#13;
         t2 = op2 &amp; 0b01010101            # Get odd destination operand bits&#13;
         res = t1 | t2                    # Merge them using an OR&#13;
    elif fun == 12:                       # <code>FFO</code> (Find position of leading 1)&#13;
        res = 8                           # Set default position 8 (i.e., leading 1 not found)&#13;
        for i  in range (0,8):            # Examine the bits one by one&#13;
          temp = op2 &amp; 0x80               # AND with 10000000 to get leading bit and save&#13;
          op2 = op2 &lt;&lt; 1                  # Shift operand left&#13;
          res = res - 1                   # Decrement place counter&#13;
          if temp == 128: break           # If the last tested bit was 1 then jump out of loop&#13;
    if res &amp; 0xFF == 0:        z = 1      # TEST FLAGS z = 1 if bits 0 to 7 all 0&#13;
    if res &amp; 0x80 == 0x80:     n = 1      # If bit 7 is one, set the carry bit&#13;
    if res &amp; 0x100 == 0x100:   c = 1      # carry bit set if bit 8 set&#13;
    if (thisOp == 'LSR') and (op2 &amp; 1 == 1): c = 1&#13;
                                          # Deal with special case of shift right (carry out is lsb)&#13;
    return(res &amp; 0xFF)                    # Return and ensure value eight bits</pre>&#13;
			<p lang="en-GB">The <code>trace()</code> function prints the <a id="_idIndexMarker548"/>state of the processor as a program is executed. This can be modified to change the amount, layout, and format of the data:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def trace():                                          # Function to print execution data&#13;
    cF   = "{0:&lt;20}".format(" ".join(src[pcOld]))     # 1. instruction&#13;
    icF  = 'pc = ' + "{:&lt;3}".format(pcOld)            # 2. pc&#13;
    binF = format(inst, "024b")                       # 3. binary code&#13;
    iClF = 'Class = '+ str(iClass)                    # 4. instruction class&#13;
    modF = 'mode = ' + str(mode)   # 5. instruction mode NOTE we have to convert mode to string&#13;
    t0F  = "{:&lt;5}".format(t0)                        # 6. token 0 (mnemonic)&#13;
    t1F  = "{:&lt;5}".format(t1)                        # 7. token 1 (register field 1)&#13;
    t2F  = "{:&lt;10}".format(t2)                       # 8. token 2 (register field 2 or literal)&#13;
    rF   = 'Reg = '+ ' '.join('%02x' % b for b in reg)  # 9. Registers in hex format&#13;
    m    = dMem[0:11]                                # 10. First 10 memory locations&#13;
    mF   = 'Mem = '+ " ".join("%02x" % b for b in m) # 11. Hex-formatted memory values&#13;
    ccrF = 'C = '+ str(c) + ' Z = ' + str(z) +' N = ' + str(n) # 12. Condition codes&#13;
    x = input('&gt;&gt;&gt; ')                               # 13. Wait for keyboard input (return)&#13;
    print(cF,icF,binF,iClF, modF, rF, mF,ccrF)      # 14. Print the computer status data&#13;
    return()&#13;
testCode = "E:\\AwPW\\TC3_NEW_1.txt"  # Source filename on my computer&#13;
with open(testCode) as src:           # Open source file with assembly language program&#13;
    lines = src.readlines()           # Read the program into lines&#13;
src.close()                           # Close the source file&#13;
src = [i[0:-1].lstrip()  for i in lines ]&#13;
                                      # Remove the /n newline from each line of the source code&#13;
src = [i.split("@")[0] for i in src]  # Remove comments in the code&#13;
src = [i for i in src if i != '']     # Remove empty lines&#13;
for i in range(0,len(src)):           # Scan source code line by line&#13;
    src[i] = src[i].replace(',',' ')  # Replace commas by a space&#13;
    src[i] = src[i].upper()           # Convert to upper-case&#13;
    src[i] = src[i].split()           # Split into tokens (label, mnemonic, operands)&#13;
src1 = []                             # Set up dummy source file, initially empty&#13;
for i in range (0,len(src)):          # Read source and stop on first END operation&#13;
    src1.append(src[i])               # Append line to dummy source file&#13;
    if src[i][0] == 'END': break      # Stop on 'END' token&#13;
src = src1                            # Copy dummy file to source (having stopped on 'END')&#13;
for i in range (0,len(src)):          # Deal with equates of the form EQU PQR 25&#13;
    if src[i][0] == 'EQU':            # If the line is 3 or more tokens and first token is EQU&#13;
        sTab[src[i][1]] = getL(src[i][2])&#13;
                                      # Put token in symbol table as integer&#13;
src = [i for i in src if i.count("EQU") == 0]&#13;
                            # Remove lines with 'EQU' from source code (these are not instructions)&#13;
for i in range(0,len(src)):           # Add label addresses to symbol table&#13;
    if src[i][0][-1] == ':':          # If first token is a label with : terminator&#13;
        sTab.update({src[i][0][0:-1]:i}) # add it to the symbol table.&#13;
xLm = 0                               # Length of maximum instruction (for printing)&#13;
for i in range (0,len(src)):          # Step through source array&#13;
    xL = len(' '.join(src[i]))       # Get the length of each line after joining tokens&#13;
    if xL &gt; xLm: xLm = xL            # If xL &gt; xLm  NOTE: This facility is not used in this version&#13;
print('Source code')                 # Display tokenized source code&#13;
for i in range(0,len(src)): print(src[i])&#13;
print("\nEquate and branch table\n") # Display the symbol table&#13;
for x,y in sTab.items():             # Step through the symbol table dictionary structure&#13;
    print("{:&lt;8}".format(x),y)       # Display each line as label and value&#13;
print('\nAssembly loop \n')&#13;
for ic in range(0,len(src)):         # ASSEMBLY LOOP (ic = instruction counter)&#13;
    t0,t1,t2 = '','',''              # Prepare to assign tokens. Initialize to null string&#13;
    if src[ic][0][-1] != ':':        # If the first token doesn't end in colon, its an instruction&#13;
        j = 0                        # j = 0 for line starting with mnemonic&#13;
    else:                            # If the first token ends in a colon it's a label&#13;
        j = 1                        # j = 1 if mnemonic is second token&#13;
    t0 = src[ic][j]                  # Set t0 to mnemonic&#13;
    if len(src[ic]) &gt; 1+j: t1 = src[ic][j+1]   # Set t1 to single operand&#13;
    if len(src[ic]) &gt; 2+j: t2 = src[ic][j+2]   # Set t2 to second operand&#13;
    tLen = len(src[ic]) - j - 1      # tLen is the number of tokens (adjusted for any label)&#13;
    binC = 0                         # Initialize binary code for this instruction to all zeros&#13;
    opCode = mnemon[t0]              # Look up op-code in table mnemon using token t0&#13;
    iClass = opCode &gt;&gt; 4             # Get two most significant bits of op-code (i.e., class)&#13;
    if   t0 in iClass0:              # If in iClass0 it's a single instruction, no operands&#13;
        mode = 0                     # The mode is 0 for everything in this class&#13;
        binC = (mnemon[t0] &lt;&lt; 18)    # All fields zero except op_code&#13;
    elif t0 in iClass1:              # If in iClass1 it's an op-code plus offset (e.g., branch)&#13;
        mode = 1                     # All class 1 instruction are mode 1 (op-code plus literal)&#13;
        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  + getL(t1)&#13;
                                     # Create binary code with operation plus address (literal)&#13;
    elif t0 in iClass2:              # If in iClass2 it's an op-code plus register number&#13;
        mode = 2                     # All instruction are mode 2&#13;
        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  + (rName[t1] &lt;&lt; 11)&#13;
                                     # Create binary code&#13;
    elif t0 in iClass3:        # Two-operand inst. All data-processing and movement ops in iClass3&#13;
        if   (t1 in rName) and (t2[0] == '#'):&#13;
                               # Look for register name and literal for mode 4&#13;
            mode = 4&#13;
        elif (t1 in rName) and (t2 in rName):&#13;
                               # Look for register name and register name for mode 5&#13;
            mode = 5&#13;
        elif (t1 in rName) and (t2 in rNamInd):&#13;
                               # Look for register name and register indirect name (r1,[r2])&#13;
            mode = 6&#13;
        elif (t1 in rNamInd) and (t2 in rName):&#13;
                                     # Look for register indirect name and register ([r1],r2)&#13;
            mode = 7&#13;
        elif (t1 in rNamInd) and (t2 in rNamInd):&#13;
                                     # Look for two register indirect names ([r1],[r2])&#13;
            mode = 8&#13;
        elif (t1[0:2] == 'M:') and (t2 in rName):&#13;
                                     # Look for literal prefixed by M: and register name (M:12,r4)&#13;
            mode = 9&#13;
        elif (t1[0:2] == 'M:') and (t2 in rNamInd):&#13;
                               # Look for literal prefixed by M: and register indirect name (M:12,[r4])&#13;
            mode = 10&#13;
        elif (t1 in rName) and (t2[0:2] == 'M:'):&#13;
                                     # Look for register name and literal prefixed by M:&#13;
            mode = 11&#13;
        elif (t1 in rNamInd) and (t2[0:2] == 'M:'):&#13;
                                     # Look for register indirect name and literal prefixed by M:&#13;
            mode = 12&#13;
        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)&#13;
                                     # Insert op_Code and mode fields in the instruction&#13;
        rField1, rField2, lField = 0, 0, 0  # Calculate register and literal fields. Initialize to zero&#13;
        if mode in [4,5,6,11]: rField1 = rName[t1]&#13;
                               # Convert register names into register numbers rField1is first register&#13;
        if mode in [7,8,12]:   rField1 = rNamInd[t1]&#13;
        if mode in [5,7,9]:    rField2 = rName[t2]   # rField2 is second register field&#13;
        if mode in [6,8,10]:   rField2 = rNamInd[t2]&#13;
        if mode in [4,11,12]:  lField  = getL(t2)&#13;
                                  # if (mode == 4) or (mode == 11) or (mode == 12): Get literal&#13;
        if mode in [9,10]:     lField  = getL(t1)&#13;
                                  # if (mode == 9) or (mode == 10):  lField = getL(t1) Literal field&#13;
        binC = binC+(rField1 &lt;&lt; 11)+(rField2 &lt;&lt; 8)+lField&#13;
                                     # Binary code with register and literal fields added&#13;
    pMem.append(binC)                # Append instruction to program memory in pMem&#13;
### Display the assembly details of each instruction (this is for diagnostics)&#13;
    pcF  = '{0:&lt;20}'.format(' '.join(src[ic])) # 1. instruction&#13;
    icF  = 'pc = ' + '{:&lt;3}'.format(ic)        # 2. pc&#13;
    binF = format(binC, '024b')                # 3. binary code&#13;
    iClF = 'Class = '+ str(iClass)             # 4. instruction class&#13;
    modF = 'mode = ' + str(mode)           # 5. instruction mode NOTE convert mode to string&#13;
    t0F  = '{:&lt;5}'.format(t0)              # 6. token 0 (mnemonic)&#13;
    t1F  = '{:&lt;5}'.format(t1)              # 7. token 1 (register field 1)&#13;
    t2F  = '{:&lt;10}'.format(t2)             # 8. token 2 (register field 2 or literal)&#13;
    print(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F) # Print these fields&#13;
print('\nEXECUTE \n')&#13;
### EXECUTE LOOP   # reverse assemble the binary instruction to recover the fields and execute the instruction&#13;
pc = 0                                     # Reset the program counter to 0&#13;
run = True                         # run flag: True to execute, False to stop (stop on END or STOP)&#13;
while run == True:                         # MAIN LOOP&#13;
    op1, op2, op3 = 0,0,0                  # Initialize data operands&#13;
    inst = pMem[pc]        # Fetch current instruction. inst is the binary op-code executed in this cycle&#13;
    pcOld = pc                             # Remember current pc for printing/display&#13;
    pc = pc + 1                            # Increment program counter for next cycle&#13;
    iClass = inst &gt;&gt; 22                    # Extract operation class 0 to 3 (top two bits)&#13;
    opCode = (inst &gt;&gt; 18)   &amp; 0b111111     # Extract the current op-code&#13;
    mode   = (inst &gt;&gt; 14)   &amp; 0b1111       # Extract the addressing mode&#13;
    reg1   = (inst &gt;&gt; 11)   &amp; 0b0111       # Extract register 1 number&#13;
    reg2   = (inst &gt;&gt;  8)   &amp; 0b0111       # Extract register 2 number&#13;
    lit    = inst           &amp; 0b11111111   # Extract the 8-bit literal in the least significant bits</pre>&#13;
			<p lang="en-GB">The following is the <a id="_idIndexMarker549"/>instruction execution part of the program. Note that instructions are executed in the order of their class:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
### EXECUTE THE CODE&#13;
    thisOp = mnemonR[opCode]               # Reverse assemble. Get mnemonic from op-code&#13;
    if iClass == 0:                        # Class 0 no-operand instructions&#13;
        if thisOp == 'END' or thisOp == 'STOP': run = False&#13;
                                           # If END or STOP clear run flag to stop execution&#13;
        if opCode == 'NOP': pass           # If NOP then do nothing and "pass"&#13;
    elif iClass == 1:                      # Class 1 operation &#13;
                                           # Class 1 branch and instr with literal operands&#13;
        if    thisOp == 'BRA': pc = lit    # BRA Branch unconditionally PC = L&#13;
        elif (thisOp == 'BEQ') and (z == 1): pc = lit  # BEQ Branch on zero&#13;
        elif (thisOp == 'BNE') and (z == 0): pc = lit  # BNE Branch on not zero&#13;
        elif thisOp == 'CZN':                          # Set/clear c, z, and n flags&#13;
            c = (lit &amp; 0b100) &gt;&gt; 2                     # Bit 2 of literal is c&#13;
            z = (lit &amp; 0b010) &gt;&gt; 1                     # Bit 1 of literal is z&#13;
            n = (lit &amp; 0b001)              # Bit 0 of literal is c&#13;
    elif iClass == 2:                      # Class 0 single-register operand&#13;
        if   thisOp == 'INC': reg[reg1] = alu(1,reg[reg1],1)&#13;
                                           # Call ALU with second operand 1 to do increment&#13;
        elif thisOp == 'DEC': reg[reg1] = alu(2,reg[reg1],1)   # Decrement register&#13;
        elif thisOp == 'RND': reg[reg1] = random.randint(0,0xFF)&#13;
                                           # Generate random number in range 0 to 0xFF&#13;
        elif thisOp == 'TST':              # Test a register: return z and n flags. Set c to 0&#13;
            z, n, c = 0, 0, 0                      # Set all flags to 0&#13;
            if reg[reg1] == 0:           z = 1     # If operand 0 set z flag&#13;
            if reg[reg1] &amp; 0x80 == 0x80: n = 1     # If operand ms bit 1 set n bit&#13;
    elif iClass == 3:                      # Class 3 operation: Two operands.&#13;
        if   mode in [4,5,6,11]: op1 = reg[reg1]&#13;
                                           # Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2&#13;
        elif mode in [7,8,12]:   op1 = dMem[reg[reg1]]&#13;
                                           # Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2&#13;
        elif mode in [9,10]:     op1 = lit # MOV M:12,r3 moves register to memory&#13;
        if   mode in [4,11,12]:  op2 = lit # Mode second operand literal&#13;
        elif mode in [5,7,9]:    op2 = reg[reg2]&#13;
                                           # Modes with second operand contents of register&#13;
        elif mode in [6,8,10]:   op2 = dMem[reg[reg2]]&#13;
                                           # Second operand pointed at by register&#13;
        if thisOp == 'MOV' : fun = 0       # Use mnemonic to get function required by ALU&#13;
        if thisOp == 'ADD' : fun = 1       # ADD and ADC use same function&#13;
        if thisOp == 'ADC' : fun = 1&#13;
        if thisOp == 'SUB' : fun = 2&#13;
        if thisOp == 'AND' : fun = 4&#13;
        if thisOp == 'OR'  : fun = 5&#13;
        if thisOp == 'NOT' : fun = 6&#13;
        if thisOp == 'EOR' : fun = 7&#13;
        if thisOp == 'LSL' : fun = 8&#13;
        if thisOp == 'LSR' : fun = 9&#13;
        if thisOp == 'ONES': fun = 10&#13;
        if thisOp == 'MRG' : fun = 11&#13;
        if thisOp == 'FFO' : fun = 12&#13;
        op3 = alu(fun,op1,op2)             # Call ALU to perform the function&#13;
        if   mode in [4,5,6,11]: reg[reg1]       = op3&#13;
                                           # Writeback ALU result in op3 result to a register&#13;
        elif mode in [7,8,12]:   dMem[reg[reg1]] = op3&#13;
                                            # Writeback result to mem pointed at by reg&#13;
        elif mode in [9,10]:     dMem[lit]       = op3&#13;
                                            # Writeback the result to memory&#13;
    trace()                                 # Display the results line by line</pre>&#13;
			<h2 id="_idParaDest-143" lang="en-GB"><a id="_idTextAnchor149"/>A sample run of TC3</h2>&#13;
			<p lang="en-GB">Here is the output <a id="_idIndexMarker550"/>from a sample run of TC3. We have provided the source code that is executed, the equate and branch table, the assembled code, and then the output of a run:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">Source code</li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
['MOV', 'R0', '#8']&#13;
['NEXT:', 'RND', 'R5']&#13;
['MOV', '[R0]', 'R5']&#13;
['DEC', 'R0']&#13;
['BNE', 'NEXT']&#13;
['MOV', 'R1', '#X']&#13;
['MOV', 'R2', '#Y']&#13;
['MOV', 'R3', '#Z']&#13;
['MOV', 'R4', '#6']&#13;
['LOOP:', 'MOV', 'R5', '[R1]']&#13;
['ADD', 'R5', '#6']&#13;
['ADD', 'R5', '[R2]']&#13;
['MOV', '[R3]', 'R5']&#13;
['INC', 'R1']&#13;
['INC', 'R2']&#13;
['INC', 'R3']&#13;
['DEC', 'R4']&#13;
['BNE', 'LOOP']&#13;
['STOP', '00', '1111', '0']</pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">Equate and <a id="_idIndexMarker551"/>branch table</li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
X        1&#13;
Y        5&#13;
Z        9&#13;
NEXT     1</pre>&#13;
			<pre class="source-code">LOOP     9</pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3">Assembly <a id="_idIndexMarker552"/>loop</li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
MOV R0 #8    pc=0   110000010000000000001000 Class=3 mode=4 MOV t1=R0 #8&#13;
NEXT: RND R5 pc=1   100010001010100000000000 Class=2 mode=2 RND   t1=R5&#13;
MOV [R0] R5  pc=2   110000011100010100000000 Class=3 mode=7 MOV   t1=[R0]  R5&#13;
DEC R0       pc=3   100001001000000000000000 Class=2 mode=2 DEC   t1=R0&#13;
BNE NEXT     pc=4   010010000100000000000001 Class=1 mode=1 BNE   t1=NEXT&#13;
MOV R1 #X    pc=5   110000010000100000000001 Class=3 mode=4 MOV   t1=R1    #X&#13;
MOV R2 #Y    pc=6   110000010001000000000101 Class=3 mode=4 MOV   t1=R2    #Y&#13;
MOV R3 #Z    pc=7   110000010001100000001001 Class=3 mode=4 MOV   t1=R3    #Z&#13;
MOV R4 #6    pc=8   110000010010000000000110 Class=3 mode=4 MOV   t1=R4   #6&#13;
LOOP: MOV R5 [R1]  pc=9   110000011010100100000000 Class=3 mode=6 MOV   t1=R5    [R1]&#13;
ADD R5 #6    pc=10  110001010010100000000110 Class=3 mode=4 ADD   t1=R5   #6&#13;
ADD R5 [R2]  pc=11  110001011010101000000000 Class=3 mode=6 ADD   t1=R5   R2]&#13;
MOV [R3] R5  pc=12  110000011101110100000000 Class=3 mode=7 MOV   t1=[R3]  R5&#13;
INC R1       pc=13  100000001000100000000000 Class=2 mode=2 INC   t1=R1&#13;
INC R2       pc=14  100000001001000000000000 Class=2 mode=2 INC   t1=R2&#13;
INC R3       pc=15  100000001001100000000000 Class=2 mode=2 INC   t1=R3&#13;
DEC R4       pc=16  100001001010000000000000 Class=2 mode=2 DEC   t1=R4&#13;
BNE LOOP     pc=17  010010000100000000001001 Class=1 mode=1 BNE   t1=LOOP&#13;
STOP 00 1111 0  pc=18  001110000000000000000000 Class=0 mode=0 STOP  t1=00    1111</pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="4">EXECUTE</li>&#13;
			</ol>&#13;
			<p lang="en-GB">We have provided only a few lines of the traced output and reformatted them to fit on the page. </p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; &#13;
MOV R0 #8            pc = 0   110000010000000000001000 &#13;
Class = 3 mode = 4 &#13;
Reg = 08 00 00 00 00 00 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 00 00 00 &#13;
C = 0 Z = 0 N = 0&#13;
NEXT: RND R5         pc = 1   100010001010100000000000 &#13;
Class = 2 mode = 2 &#13;
Reg = 08 00 00 00 00 8f 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 00 00 00 &#13;
C = 0 Z = 0 N = 0&#13;
MOV [R0] R5         pc = 2   110000011100010100000000 &#13;
Class = 3 mode = 7 &#13;
Reg = 08 00 00 00 00 8f 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 8f 00 00 &#13;
C = 0 Z = 0 N = 1&#13;
DEC R0             pc = 3   100001001000000000000000 &#13;
Class = 2 mode = 2 &#13;
Reg = 07 00 00 00 00 8f 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 8f 00 00 &#13;
C = 0 Z = 0 N = 0&#13;
BNE NEXT             pc = 4   010010000100000000000001 &#13;
Class = 1 mode = 1 &#13;
Reg = 07 00 00 00 00 8f 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 8f 00 00 &#13;
C = 0 Z = 0 N = 0&#13;
NEXT: RND R5         pc = 1   100010001010100000000000 &#13;
Class = 2 mode = 2 &#13;
Reg = 07 00 00 00 00 35 00 00 &#13;
Mem = 00 00 00 00 00 00 00 00 8f 00 00 &#13;
C = 0 Z = 0 N = 0</pre>&#13;
			<p class="callout-heading" lang="en-GB">Note</p>&#13;
			<p class="callout" lang="en-GB">Output not displayed to save space</p>&#13;
			<p lang="en-GB">In the next section, we’ll look at <a id="_idIndexMarker553"/>one component of simulators in greater detail, the ALU.</p>&#13;
			<h1 id="_idParaDest-144" lang="en-GB"><a id="_idTextAnchor150"/>Arithmetic and Logic Unit (ALU)</h1>&#13;
			<p lang="en-GB">And now for something different. We have used an ALU in all the simulators. Here, you will learn about <a id="_idIndexMarker554"/>the ALU in greater detail and about its testing.</p>&#13;
			<p lang="en-GB">The following Python code demonstrates the implementation of an 8-bit, 16-function ALU. We have added several <em class="italic">contemporary operations</em> that some computers provide, such as modulus, minimum, and maximum. The alu function is called with the <code>op</code>, <code>a</code>, <code>b</code>, <code>cIn</code>, and <code>display</code> parameters. The <code>op</code> parameter is in the range 0 to 15 and defines the function. The <code>a</code> and <code>b</code> parameters are two 8-bit integers in the range 0 to 255, <code>cin</code> is a carry in, and <code>display</code> is a flag. When display is <code>0</code>, no data is printed. When <code>display</code> is <code>1</code>, the inputs and results are printed by the function. This feature is for debugging.</p>&#13;
			<p lang="en-GB">This code demonstrates the use of Python’s if...elif construct to decode the arithmetic operation. We have also included a <em class="italic">dictionary structure</em> that enables us to print out the operation code by name. In this case, the dictionary is <code>allOps</code> and is written as follows:</p>&#13;
			<pre class="source-code">AllOps = {0:'clr', 1:'add',2:'sub',3:'mul'}    # just four entries to make easy reading.</pre>&#13;
			<p lang="en-GB">Another feature is that we can easily print data in binary form. The <code>print(bin(c))</code> operation prints <code>c</code> in binary form. However, because we are using 8-bit arithmetic and wish to see leading zeros, we can force an 8-bit output by using the zfill; that is <code>print(bin(c).zfill(8))</code> method.</p>&#13;
			<p lang="en-GB">Alternatively, we can use <code>print('Result', format(c,'08b'))</code> to print the <code>c</code> variable as an 8-bit binary string.</p>&#13;
			<p lang="en-GB">A Python function can return multiple values as a <em class="italic">tuple</em>. A tuple is a Python list of immutable values that cannot be changed; for example, if you write return (<code>c</code>, <code>z</code>, <code>n</code>, <code>v</code> <code>cOut</code>), you are returning a tuple that consists of the function we calculated and the <code>z</code>, <code>n</code>, <code>v</code>, and <code>cOut</code> flags. These can’t be changed, but they can be assigned to variables in the calling program; take the following example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
result,Zero,Neg,oVerflow,carry = alu(0,A,B,0,1)</pre>&#13;
			<p lang="en-GB">Note the calculation of overflow. The <code>v-bit</code> is set if the sign bits of the two operands are the same and the <a id="_idIndexMarker555"/>sign bit of the result is different. Overflow is valid only for addition and subtraction. The modulus function returns a positive value if the input parameter is negative in two’s complement terms. We do this by inverting the bits and adding 1.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# This function simulates an 8-bit ALU and provides 16 operations&#13;
# It is called by alu(op,a,b,cIn,display). Op defines the ALU function&#13;
# a,b and cIn are the two inputs and the carry in&#13;
# If display is 1, the function prints all input and output on the terminal&#13;
# Return values: q, z, n, v, cOut) q is the result&#13;
def alu(op,a,b,cIn,display):&#13;
    allOps = {0:'clr', 1:'add',2:'sub',3:'mul',4:'div',5:'and',6:'or', \&#13;
              7:'not', 8:'eor', 9:'lsl',10:'lsr', 11:'adc',12:'sbc',   \&#13;
              13:'min',14:'max',15:'mod'}&#13;
    a, b = a &amp; 0xFF, b &amp; 0xFF             # Ensure the input is 8 bits&#13;
    cOut,z,n,v = 0,0,0,0                  # Clear all status flags&#13;
    if   op == 0:   q = 0                 # Code 0000 clear&#13;
    elif op == 1:   q = a + b             # Code 0001 add&#13;
    elif op == 2:   q = a - b             # Code 0010 subtract&#13;
    elif op == 3:   q = a * b             # Code 0011 multiply&#13;
    elif op == 4:   q = a // b            # Code 0100 divide&#13;
    elif op == 5:   q = a &amp; b             # Code 0100 bitwise AND&#13;
    elif op == 6:   q = a | b             # Code 0100bitwise OR&#13;
    elif op == 7:   q = ~a                # Code 0111 bitwise negate (logical complement)&#13;
    elif op == 8:   q = a ^ b             # Code 0100 bitwise EOR&#13;
    elif op == 9:   q = a &lt;&lt; b            # Code 0100 bitwise logical shift left b places&#13;
    elif op == 10:  q = a &gt;&gt; b            # Code 0100 bitwise logical shift right b places&#13;
    elif op == 11:  q = a + b + cIn       # Code 0100 add with carry in&#13;
    elif op == 12:  q = a - b - cIn       # Code 0100 subtract with borrow in&#13;
    elif op == 13:                        # Code 1101 q = minimum(a,b)&#13;
       if a &gt; b: q = b&#13;
       else:     q = a&#13;
    elif op == 14:                        # Code 1110 q = maximum(a,b)&#13;
       if a &gt; b: q = a                    # Note: in unsigned terms&#13;
       else:     q = b&#13;
    elif op == 15:                        # Code 1111 q = mod(a)&#13;
       if a &gt; 0b01111111: q = (~a+1)&amp;0xFF # if a is negative q = -a (2s comp)&#13;
       else:     q = a                    # if a is positive q =  a&#13;
<strong class="bold"># Prepare to exit: Setup flags</strong>&#13;
    cOut = (q&amp;0x100)&gt;&gt;8                   # Carry out is bit 8&#13;
    q    =  q &amp; 0xFF                      # Constrain result to 8 bits&#13;
    n    = (q &amp; 0x80)&gt;&gt;7                  # AND q with 10000000 and shift right 7 times&#13;
    if q == 0: z = 1                      # Set z bit if result zero&#13;
    p1 = ( (a&amp;0x80)&gt;&gt;7)&amp; ((b&amp;0x80)&gt;&gt;7)&amp;~((q&amp;0x80)&gt;&gt;7)&#13;
    p2 = (~(a&amp;0x80)&gt;&gt;7)&amp;~((b&amp;0x80)&gt;&gt;7)&amp; ((q&amp;0x80)&gt;&gt;7)&#13;
    if p1 | p2 == True: v = 1             # Calculate v-bit (overflow)&#13;
    if display == 1:                      # Display parameters and results&#13;
       a,b = a&amp;0xFF, b&amp;0xFF               # Force both inputs to 8 bits&#13;
       print('Op =',allOps[op],'Decimals: a =',a,' b =',b, \&#13;
             'cIn =',cIn,'Result =',q)&#13;
       print('Flags: Z =',z, 'N =',n, 'V =',v, 'C =',cOut)&#13;
       print('Binaries A =',format(a,'08b'), 'B =',format(b,'08b'), \&#13;
             'Carry in =',format(cIn,'01b'), 'Result =',format(q,'08b'))&#13;
       print ()&#13;
    return (q, z, n, v, cOut)             # Return c (result), and flags as a tuple</pre>&#13;
			<h2 id="_idParaDest-145" lang="en-GB"><a id="_idTextAnchor151"/>Testing the ALU</h2>&#13;
			<p lang="en-GB">We will now demonstrate testing the ALU. A <code>while</code> loop is created and two integers are inputted using <a id="_idIndexMarker556"/>Python’s keyboard input function and the <code>.split()</code> method to divide the input string into substrings. For example, you can enter add 3 5 to perform the addition of 3 and 5. A null input (i.e., a return) ends the sequence.</p>&#13;
			<p lang="en-GB">I have arranged the code so that you can see only the parameters entered as needed for the operation, for example, add 3,7, mod 5, or sbc 3 4 1. To make it easier to test logic functions, you can enter parameters in binary <code>(%10110</code>) or hexadecimal <code>($</code><code>3B</code>) format.</p>&#13;
			<p lang="en-GB">A feature of the <a id="_idIndexMarker557"/>test code is that I use a reverse dictionary. This allows you to enter a function by its name, rather than number.</p>&#13;
			<p lang="en-GB">The following is the code I used to test the ALU:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
#### MAIN BODY&#13;
def literal(lit):&#13;
    if   lit.isnumeric(): lit =  int(lit)        # If decimal convert to integer&#13;
    elif lit[0]  == '%': lit =  int(lit[1:],2)   # If binary string convert to int&#13;
    elif lit[0:1]== '$': lit =  int(lit[1:],16)  # If hex string convert to int&#13;
    elif lit[0]  == '-': lit = -int(lit[1:])&amp;0xFF # If negative convert to signed int&#13;
    return(lit)&#13;
opsRev = {'clr':0,'add':1,'sub':2,'mul':3,'div':4,'and':5,'or':6,     \&#13;
          'not':7,'eor':8,'lsl':9,'lsr':10,'adc':11,'sbc':12,         \&#13;
          'min':13,'max':14,'mod':15}&#13;
x,y,op1,op2,cIn = 0,0,0,0,0                      # Dummy value prior to test in while loop&#13;
while True:&#13;
    x = input('Enter operation and values ')&#13;
    if x == '': break                            # Exit on return&#13;
    y = x.split()                                # Divide into tokens&#13;
    print (y)                                    # Show the input&#13;
    fun = opsRev[y[0]]                           # Convert function name into number&#13;
    if len(y) &gt; 1: op1 = literal(y[1])           # One parameter&#13;
    if len(y) &gt; 2: op2 = literal(y[2])           # Two parameters&#13;
    if len(y) &gt; 3: cIn = literal(y[3])           # Three parameters&#13;
    q, z, n, v, cOut  = alu(fun,op1,op2,cIn,1)   # Call the ALU function&#13;
                                                 # Repeat until return entered</pre>&#13;
			<p lang="en-GB">Here’s some <a id="_idIndexMarker558"/>sample output from a test run:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Enter operation and values add 25 $1F&#13;
['add', '25', '$1F']&#13;
Operation =  add Decimals: a = 25  b = 31 cIn = 0 Result = 56&#13;
Flags: Z = 0 N = 0 V = 0 C = 0&#13;
Binaries A = 00011001 B = 00011111 Carry in = 0 Result = 00111000&#13;
Enter operation and values add %11111111 1&#13;
['add', '%11111111', '1']&#13;
Operation =  add Decimals: a = 255  b = 1 cIn = 0 Result = 0&#13;
Flags: Z = 1 N = 0 V = 0 C = 1&#13;
Binaries A = 11111111 B = 00000001 Carry in = 0 Result = 00000000&#13;
Enter operation and values add 126 2&#13;
['add', '126', '2']&#13;
Operation =  add Decimals: a = 126  b = 2 cIn = 0 Result = 128&#13;
Flags: Z = 0 N = 1 V = 1 C = 0&#13;
Binaries A = 01111110 B = 00000010 Carry in = 0 Result = 10000000&#13;
Enter operation and values add 7 -2&#13;
['add', '7', '-2']&#13;
Operation =  add Decimals: a = 7  b = 254 cIn = 0 Result = 5&#13;
Flags: Z = 0 N = 0 V = 0 C = 1&#13;
Binaries A = 00000111 B = 11111110 Carry in = 0 Result = 00000101&#13;
Enter operation and values add 128 -2&#13;
['add', '128', '-2']&#13;
Operation =  add Decimals: a = 128  b = 254 cIn = 0 Result = 126&#13;
Flags: Z = 0 N = 0 V = 1 C = 1&#13;
Binaries A = 10000000 B = 11111110 Carry in = 0 Result = 01111110&#13;
Enter operation and values and $A7 %11110001&#13;
['and', '$A7', '%11110001']&#13;
Operation =  and Decimals: a = 167  b = 241 cIn = 0 Result = 161&#13;
Flags: Z = 0 N = 1 V = 0 C = 0&#13;
Binaries A = 10100111 B = 11110001 Carry in = 0 Result = 10100001&#13;
Enter operation and values lsl %11100011 2&#13;
['lsl', '%11100011', '2']&#13;
Operation =  lsl Decimals: a = 227  b = 2 cIn = 0 Result = 140&#13;
Flags: Z = 0 N = 1 V = 0 C = 1&#13;
Binaries A = 11100011 B = 00000010 Carry in = 0 Result = 10001100&#13;
Enter operation and values</pre>&#13;
			<h1 id="_idParaDest-146" lang="en-GB"><a id="_idTextAnchor152"/>A final example: TC4</h1>&#13;
			<p lang="en-GB">In this example, we provide <a id="_idIndexMarker559"/>a new simulator that introduces you to some new elements of Python, such as the ability to include the date and time. This final example of a computer simulator brings some of the things we have discussed together and creates a simulator with a 32-bit instruction memory and a 16-bit data memory. Consequently, this is not a von Neumann machine because it has different program and data memories. TC4 incorporates several modifications to demonstrate both simplifications and additions.</p>&#13;
			<p lang="en-GB">We’ll present the code <a id="_idIndexMarker560"/>first and then add some comments via the labels that indicate points of interest. Shaded parts of the code have comments following the code:</p>&#13;
			<pre>import re                          # Library for regular expressions for removing spaces  (See 1)&#13;
from random import  *              # Random nu<a id="_idTextAnchor153"/>mber library&#13;
import sys                         # Operating system call library&#13;
from datetime import date          # Import date function                      (See 2)&#13;
bPt = []                           # Breakpoint table (labels and PC values)&#13;
bActive = 0&#13;
today = date.today()               # Get today's date                         (See 2)&#13;
print('Simulator', today, '\n')&#13;
deBug, trace, bActive  = 0, 0, 0   # Turn off debug, trace and breakpoint modes       (See 3)&#13;
x1 = input('D for debug &gt;&gt;&gt; ')     # Get command input&#13;
if x1.upper() == 'D': deBug = 1    # Turn on debug mode if 'D' or 'd' entered&#13;
x2 = input('T or B')               # Get command input&#13;
x2 = x2.upper()                    # Convert to upper-case&#13;
if x2 == 'T': trace = 1            # Turn on trace mode if 'T' or 't' entered&#13;
elif x2 == 'B':                    # If 'B' or 'b' get breakpoints until 'Q' input          (See 4)&#13;
    next = True&#13;
    bActive = 1                    # Set breakpoint active mode&#13;
    while next == True:            # Get breakpoint as either label or PC value&#13;
        y = input('Breakpoint ')&#13;
        y = y.upper()&#13;
        bPt.append(y)              # Put breakpoint (upper-case) in table&#13;
        if y == 'Q': next = False&#13;
    if deBug == 1:                 # Display breakpoint table if in debug mode&#13;
        print ('\nBreakpoint table')&#13;
        for i in range (0,len(bPt)): print(bPt[i])&#13;
        print()&#13;
print()</pre>&#13;
			<p lang="en-GB">The <code>memProc()</code> function deals with <a id="_idIndexMarker561"/>the data memory and allows you to store <a id="_idIndexMarker562"/>data in memory and even ASCII code. This function processes assembler directives:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def memProc(src):                                # Memory processing   &#13;
    global memPoint, memD                        # Deal with directives&#13;
    for i in range(len(src)):                    # and remove directives from source code&#13;
        if src[i][0] == '.WORD':                 # Test for .word directive&#13;
            lit = get_lit(src[i],2)              # Get the literal value&#13;
            sTab.update({src[i][1]:memPoint})    # Bind literal name to the memory address&#13;
            memD[memPoint] = lit                 # Store the literal in memory&#13;
            memPoint = memPoint + 1              # Move the memory pointer on one word&#13;
        if src[i][0] == '.ASCII':                # .ASCII: test for an ASCII character&#13;
            sTab.update({src[i][1]:memPoint})    # Bind name to memory address&#13;
            character = ord(src[i][2])           # Convert character to numeric form&#13;
            memD[memPoint] = character        # Store the character in memory as ASCII code&#13;
            memPoint = memPoint + 1           # Move the memory pointer on&#13;
        if src[i][0] == '.DSW':               # Test for .DSW to reserve locations in memory&#13;
            sTab.update({src[i][1]:memPoint}) # Save name in table and bind to memory address&#13;
            memPoint = memPoint + int(src[i][2]) # Move memory pointer by space required&#13;
    src = [i  for i in src if i[0] != '.WORD']   # Remove .word from source&#13;
    src = [i  for i in src if i[0] != '.ASCII']  # Remove .ASCII from source&#13;
    src = [i  for i in src if i[0] != '.DSW']    # Remove .DSW from source&#13;
    memD[memPoint] = 'END'                    # Add terminator to data memory (for display)</pre>&#13;
			<pre class="source-code">    return(src)</pre>&#13;
			<p lang="en-GB">The <code>get_reg()</code> function determines <a id="_idIndexMarker563"/>the number of a register. It first looks in the symbol table to determine whether the name is symbolic. Otherwise, it extracts the register number from the predicate:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def get_reg(pred,p):                     # Extract a register number from predicate&#13;
    reg = pred[p]                        # Read token p is the predicate&#13;
    if reg in sTab:                      # Check if this is a symbolic name&#13;
        reg = sTab.get(reg)              # If symbolic name read it from symbol table&#13;
        reg = int(reg[1:])               # Convert register name into number&#13;
    else: reg = int(reg[1:])             # If not symbolic name convert name into number&#13;
    return(reg)                          # Otherwise return the register number</pre>&#13;
			<p lang="en-GB">The <code>get_lit()</code> function extracts <a id="_idIndexMarker564"/>a literal from the predicate. As in the case of register names, it is able to deal with <a id="_idIndexMarker565"/>symbolic values by first looking for the name in the symbol table. If there is no symbolic name, the text is converted into the appropriate integer by observing and dealing with any prefixes:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def get_lit(pred,p):                              # Extract literal from place p in predicate&#13;
    global sTab                                   # We need the symbol table&#13;
    lit = pred[p]                                 # Read the literal from the predicate&#13;
    if lit in sTab:                               # If literal is in symbol table, look it up&#13;
        lit = int(sTab.get(lit))&#13;
    else:                                         # Convert literal format to an integer&#13;
        if   lit[0]   == "%": lit = int(pred[-1][1:],2)   # If prefix % then binary&#13;
        elif lit[0:2] == "0X": lit = int(pred[-1][2:],16)&#13;
                                                     # If prefix 0X then hexadecimal&#13;
        elif lit[0].isnumeric(): lit = int(pred[-1]) # If numeric get it&#13;
        elif lit[0].isalpha(): lit = ord(lit)        # Convert ASCII character to integer&#13;
        elif lit[0:2] == "0X": lit = int(pred[-1][2:],16)&#13;
                                                     # If prefix 0X then hexadecimal&#13;
        else:  lit = 0                               # Default (error) value 0&#13;
    return(lit)</pre>&#13;
			<p lang="en-GB">The <code>display()</code> function takes care <a id="_idIndexMarker566"/>of displaying data after each instruction has <a id="_idIndexMarker567"/>been executed. In this case, the data values are converted into hexadecimal format and turned into strings:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def display():                                # Print the state after each instruction&#13;
    thisOp = ' '.join(src[pcOld])             # Join this op-code's tokens into a string&#13;
    a =[format(x,'04x') for x in r]           # Format registers into hex strings&#13;
    b = (' ').join(a)                         # Join the hex strings with a space&#13;
    f1 = f'{pcOld:&lt;4}'                        # Format the PC as a string&#13;
    f2 = f'{thisOp:&lt;18}'                      # Format the instruction to fixed width&#13;
    print('PC =',f1,'Reg =',b,'Z =',z,'N =',n,'C =',c,f2)       # Print the data</pre>&#13;
			<pre class="source-code">    return()</pre>&#13;
			<p lang="en-GB">The <code>alu()</code> function performs <a id="_idIndexMarker568"/>arithmetic operations. This example is very rudimentary and provides only basic operations. Since we have covered ALU elsewhere, it’s not necessary to be comprehensive. You can easily add new functions yourself:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def alu(a,b,f):    # ALU for addition/subtraction and flag calculation                    (See 6)&#13;
# a and b are the numbers to add/subtract and f the function&#13;
    global z,c,n                      # Make flags global&#13;
    z,c,n = 0,0,0                     # Clear flags initially&#13;
    if f == 1: s = a + b              # f = 1 for add&#13;
    if f == 2: s = a - b              # f = 2 for subtract&#13;
    s = s &amp; 0x1FFFF                   # Constrain result to 17 bits&#13;
    if s &gt; 0xFFFF: c = 1              # Carry set if 17th bit 1&#13;
    if 0x8000 &amp; s == 0x8000 : n = 1   # Bit 15 set to 1 for negative&#13;
    if s &amp; 0xFFFF == 0: z = 1         # Zero flag set to 1 if bits 0-15 all 0&#13;
    s = 0xFFFF &amp; s                    # Ensure 16-bit result&#13;
    return(s)&#13;
codes = {"STOP":(0,0),"NOP":(0,1),"RND":(1,4),"BRA":(2,5),"BEQ":(2,6),      \&#13;
         "BNE":(2,7),"MOV":(3,8),"LDRM":(4,9),"LDRL":(4,10),"LDRI":(7,11),  \&#13;
         "LDRI+":(7,12),"STRM":(4,13),"STRI":(7,14),"STRI+":(7,15),         \&#13;
         "ADD":(5,16),"ADDL":(6,17),"SUB":(5,18),"SUBL":(6,19),             \&#13;
         "AND":(5,20),"ANDL":(6,21),"OR":(5,22),"ORL":(6,23), "EOR":(5,24), \&#13;
         "EORL":(6,25),"CMP":(3,26),"CMPL":(4,27),"LSL":(3,28),             \&#13;
         "LSR":(3,29),"ROL":(3,30),"ROR": (3,31), "BSR":(2,32),             \&#13;
         "RTS":(0,33),"PUSH":(1,34),"POP":(1,35),"BL":(2,36),"RL":(0,37),   \&#13;
         "INC":(1,48), "DEC":(1,49), "PRT":(1,3), "BHS": (2,71)}&#13;
# Style Code Format (a,b) where a is the <a id="_idIndexMarker569"/>instruction style and b is the actual op-code&#13;
# 0     Zero operand               STOP&#13;
# 1     Destination register operand    INC  R0&#13;
# 2     Literal operand              BEQ  5&#13;
# 3     Two registers: Rd, Rs1          MOV  R2,R4&#13;
# 4     Register and literal Rd L         LDR  R6,23&#13;
# 5     Three registers: Rd, Rs1, Rs2       ADD  R1,R2,R3&#13;
# 6     Two registers, literal Rs, Rd1, L    ADDL R1,R2,9&#13;
# 7     Indexed, Rd, Rs, L            LDRI R4,(R6,8)&#13;
# 8     UNDEFINED&#13;
testFile = 'E:/ArchitectureWithPython/TC4_test.txt'  # Source filename on my computer&#13;
with open(testFile) as myFile:        # Open source file with assembly language program&#13;
    lines = myFile.readlines()        # Read the program into lines&#13;
myFile.close()                        # Close the source file (not actually needed)&#13;
lines = [i[0:-1]  for i in lines ]    # Remove the /n newline from each line of the source code&#13;
src = lines                        # Copy lines to variable scr (i.e., source code)&#13;
if deBug == 1:                     # If in debug mode print the source file           (See 3)&#13;
    print('Debug mode: original source file')&#13;
    for i in range(0,len(src)): print(i, src[i])    # Listing file</pre>&#13;
			<p lang="en-GB">Here, we carry out the usual cleaning up of the source text in the assembly language file and prepare the text <a id="_idIndexMarker570"/>for later parsing and analysis. Note that we use a regular expression to remove multiple spaces. This is a feature we do not use in this book, but it is worthwhile investigating if you are doing extensive text processing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for i in range(0,len(src)):              # Remove comments from source&#13;
   src[i] = src[i].split('@',1)[0]       # Split line on first occurrence of @ and keep first item&#13;
src = [i.strip(' ') for i in src ]          # Remove leading and trailing spaces&#13;
src = [i for i in src if i != '']           # Remove blank lines&#13;
src = [i.upper() for i in src]              # Convert lower- to upper-case&#13;
src = [re.sub('+', ' ',i) for i in src ]    # Remove multiple spaces     1&#13;
src = [i.replace(', ',' ') for i in src]    # Replace commas space by single space&#13;
src = [i.replace('[','') for i in src]      # Remove [ in register indirect mode&#13;
src = [i.replace(']','') for i in src]      # Remove [&#13;
src = [i.replace(',',' ') for i in src]     # Replace commas by spaces&#13;
src = [i for i in src if i[0] != '@']       # Remove lines with just a comment&#13;
src = [i.split(' ')  for i in src]          # Tokenize&#13;
if deBug == 1:                              # If in debug mode print the source file&#13;
    print('\nProcessed source file\n')&#13;
    [print(i) for i in src]&#13;
# Initialize key variables&#13;
# memP program memory, memD data memory&#13;
sTab = {}                                   # Set up symbol table for labels and equates&#13;
memP = [0] * 64                             # Define program memory&#13;
memD = [0] * 64                             # Define data memory&#13;
memPoint = 0                                # memPoint points to next free  location&#13;
[sTab.update({i[1]:i[2]}) for i in src if i[0] == '.EQU']&#13;
                                            # Scan source file and deal with equates&#13;
src = [i  for i in src if i[0] != '.EQU']   # Remove equates from source&#13;
src = memProc(src)                          # Deal with memory-related directives&#13;
for i in range (0,len(src)):                # Insert labels in symbol table&#13;
    if src[i][0][-1]== ':': sTab.update({src[i][0][0:-1]:i})&#13;
                                            # Remove the colon from labels&#13;
print('\nSymbol table\n')&#13;
for x,y in sTab.items(): print("{:&lt;8}".format(x),y)    # Display symbol table&#13;
if deBug == 1:&#13;
    print("\nListing with assembly directives removed\n")&#13;
    for i in range(0,len(src)):             # Step through each line of code&#13;
        z = ''                              # Create empty string for non-labels&#13;
        if src[i][0][-1] != ':': z = '        '&#13;
                                            # Create 8-char empty first spaced&#13;
        for j in range(0,len(src[i])):      # Scan all tokens of instruction&#13;
            y = src[i][j]                   # Get a token&#13;
            y = y.ljust(8)                  # Pad it with spaces with a width of 8 characters&#13;
            z = z + y                       # Add it to the line&#13;
        print(str(i).ljust(3),z)            # Print line number and instruction&#13;
if deBug == 1:                              # Display data memory for debugging&#13;
    print("\nData memory")&#13;
    [print(memD[i]) for i in range(0,memPoint+1)]  # print pre-loaded data in memory&#13;
    print()&#13;
#### MAIN ASSEMBLY LOOP&#13;
if deBug == 1: print('Assembled instruction\n')    # If in debug mode print heading 4</pre>&#13;
			<p lang="en-GB">Now, we execute the code. The program counter is first initialized to 0. Of course, we could have started at <a id="_idIndexMarker571"/>any arbitrary point or even provided assembly language directives to preset the pc. After setting the pc, we read an instruction and parse it.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc = 0&#13;
for pc in range(0,len(src)):&#13;
    rD,rS1,rS2,lit = 0,0,0,0                      # Initialize operand fields&#13;
    if src[pc][0][-1] != ':':                     # Extract mnemonic and predicate&#13;
        mnem  = src[pc][0]&#13;
        if len(src[pc]) &gt; 1: pred = src[pc][1:]   # Check for single mnemonic only&#13;
        else: pred = '[]'                         # If only mnemonic with no predicate&#13;
    else:&#13;
        mnem  = src[pc][1]                        # For lines with a label&#13;
        if len(src[pc]) &gt; 2: pred = src[pc][2:]   # Get predicate if one exists&#13;
        else: pred = '[]'                         # If only mnemonic, no pred&#13;
    if mnem in codes:&#13;
       opFormat = codes.get(mnem)                 # Read of op-code format of mnemonic</pre>&#13;
			<pre class="source-code">    else: print('Illegal opcode ERROR, mnem')     # Display error message</pre>&#13;
			<p lang="en-GB">Now, we can use <code>opFormat</code> to extract the required parameters from the predicate:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# OP-CODE FORMATS&#13;
    if opFormat[0] == 1:            # Type 1 single register rD: inc r0&#13;
        rD = get_reg(pred,0)&#13;
    if opFormat[0] == 2:            # Type 2 literal operand: BEQ 24&#13;
        lit = get_lit(pred,-1)&#13;
    if opFormat[0] == 3:            # Type 3 two registers dD, rS1: MOV r3,R0&#13;
        rD  = get_reg(pred,0)&#13;
        rS1 = get_reg(pred,1)&#13;
    if opFormat[0] == 4:            # Type 4 register and literal Rd, lit: LDRL R1,34&#13;
        rD  = get_reg(pred,0)&#13;
        lit = get_lit(pred,-1)&#13;
    if opFormat[0] == 5:            # Type 5 three registers Rd, Rs1 Rs2: ADD  R1,R2,R3&#13;
        rD  = get_reg(pred,0)&#13;
        rS1 = get_reg(pred,1)&#13;
        rS2 = get_reg(pred,2)&#13;
    if opFormat[0] == 6:            # Type 6 two registers and lit Rd, Rs1 lit: ADD  R1,R2,lit&#13;
        rD  = get_reg(pred,0)&#13;
        rS1 = get_reg(pred,1)&#13;
        lit = get_lit(pred,-1)&#13;
    if opFormat[0] == 7:            # Type 7 two registers and lit Rd, Rs1 lit: LDR  R1,(R2,lit)&#13;
        rD  = get_reg(pred,0)&#13;
        pred[1] = pred[1].replace('(','')    # Remove brackets&#13;
        pred[2] = pred[2].replace(')','')&#13;
        rS1 = get_reg(pred,1)&#13;
        lit = get_lit(pred,-1)&#13;
    if opFormat[0] == 8:                     # Type 8 UNDEFINED&#13;
        pass</pre>&#13;
			<p lang="en-GB">In this example of a simulator, we create the binary code to be executed. The various parameters extracted <a id="_idIndexMarker572"/>from the predicate have to be moved into the appropriate place to create the final binary code, <code>binCode</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    opCd     = opFormat[1] &lt;&lt; 25    # Move op-code to left-most 7 bits&#13;
    rDs      = rD          &lt;&lt; 22    # Move destination reg into place&#13;
    rS1s     = rS1         &lt;&lt; 19    # Move source reg 1 in place&#13;
    rS2s     = rS2         &lt;&lt; 16    # Move source reg 2 in place&#13;
    binCode=opCd|rDs|rS1s|rS2s|lit  # Assemble the instruction by combining fields&#13;
    memP[pc] = binCode              # Store 32-bit binary code in program memory&#13;
    if deBug == 1:                  # If in debug mode show the binary output of the assembler&#13;
        a1 = f'{pc:&lt;4}'             # Format for the PC (4 chars wide)&#13;
        a2 = format(binCode,'032b') # Create 32-bit binary string for op-code&#13;
        a3 = f'{mnem:&lt;5}'           # Format the mnemonic to 5 places&#13;
        a4 = f'{rD:&lt;4}'             # Format source register to 4 places&#13;
        a5 = f'{rS1:&lt;4}'&#13;
        a6 = f'{rS2:&lt;4}'&#13;
        a7 = f'{lit:&lt;6}'&#13;
        print('PC =',a1,a2,a3,a4,a5,a6,a7,src[pc]) # Assemble items and print them&#13;
# CODE EXECUTE LOOP&#13;
print('\nExecute code\n')</pre>&#13;
			<p lang="en-GB">This block initializes variables, registers, memory, and the stack pointer before we enter the code execution loop. Note that we create a stack with 16 entries. The stack pointer is set to <code>16</code>, which is one <a id="_idIndexMarker573"/>below the bottom of the stack. When the first item is pushed, the stack pointer is pre-decremented to <code>15</code>, the bottom of the available stack area:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
r = [<a id="_idTextAnchor154"/>0] * 8                                   # Register set&#13;
stack = [0] * 16                              # stack with 16 locations           See 7&#13;
sp = 16                                       # stack pointer initialize to bottom of stack + 1&#13;
lr = 0                                        # link register initialize to 0&#13;
run = 1                                       # run = 1 to execute code&#13;
pc = 0                                        # Initialize program counter&#13;
z,c,n = 0,0,0                                 # Clear flag bits. Only z-bit is used&#13;
while run == 1:                               # Main loop&#13;
    instN = memP[pc]                          # Read instruction&#13;
    pcOld = pc                                # Remember the pc (for printing)&#13;
    pc = pc + 1                               # Point to the next instruction&#13;
    op  = (instN &gt;&gt; 25) &amp; 0b1111111           # Extract the op-code (7 most-significant bits)&#13;
    rD  = (instN &gt;&gt; 22) &amp; 0b111               # Extract the destination register&#13;
    rS1 = (instN &gt;&gt; 19) &amp; 0b111               # Extract source register 1&#13;
    rS2 = (instN &gt;&gt; 16) &amp; 0b111               # Extract source register 2&#13;
    lit = (instN      ) &amp; 0xFFFF              # Extract literal in least-significant 16 bits&#13;
    rDc = r[rD]                               # Read destination register contents)&#13;
    rS1c = r[rS1]                             # Read source register 1 contents&#13;
    rS2c = r[rS2]                             # Read source register 2 contents</pre>&#13;
			<p lang="en-GB">Here, the instructions <a id="_idIndexMarker574"/>are executed. Note we used an <code>if</code> statement for each instruction. This was used during the initial development phase. In practice, an if...elif structure would be more suitable:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Instruction execution&#13;
    if op == 0b0000001:           # NOP   Nothing to see here ... it's NOP so just drop out&#13;
        pass&#13;
    if op == 0b0000100:           # RND     # RND r0 generates random number in r0&#13;
       r[rD] = randint(0,0xFFFF)&#13;
    if op == 0b0000101:           # BRA     # Branch to the label or literal. Absolute address&#13;
        pc = lit&#13;
    if op == 0b0000110:           # BEQ     # Branch on zero flag&#13;
        if z == 1: pc = lit&#13;
    if op == 0b0000111:           # BNE     # Branch on not zero&#13;
        if z != 1: pc = lit<a id="_idTextAnchor155"/>&#13;
    if op == 0b1000111:           # BHS    # Branch on unsigned higher or same     (See 8)&#13;
        if c == 0 : pc = lit&#13;
    if op == 0b0001000:           # MOV    # Copy one register to another&#13;
        r[rD] = rS1c&#13;
    if op == 0b0001001:           # LDRM    # Load register from address in memory&#13;
        r[rD] = memD[lit]&#13;
    if op == 0b0001010:           # LDRL    # Load register with a literal&#13;
        r[rD] = lit&#13;
    if op == 0b0001011:           # LDRI    # Load register indirect with offset; LDRI r1,[r2,4]&#13;
        r[rD] = memD[rS1c + lit]&#13;
    if op == 0b0001100:           # LDRI+   # Auto-indexed. Increment pointer after use (See 9)&#13;
        r[rD] = memD[rS1c + lit]&#13;
        r[rS1] = rS1c + 1&#13;
    if op == 0b0001101:           # STRM    #&#13;
        memD[lit] = rDc&#13;
    if op == 0b0001110:           # STRI     # Store register indexed&#13;
        memD[rS1c + lit] = rDc&#13;
    if op == 0b0001111:           # STRI+    # Auto indexed&#13;
        memD[rS1c + lit] = rDc&#13;
        r[rS1] = rS1c + 1&#13;
    if op == 0b0010000:           # ADD     # r1 = r2 + r3&#13;
        r[rD] = alu(rS1c,rS2c,1)&#13;
    if op == 0b0010001:           # ADDL    # r1 = r2 + literal&#13;
        r[rD] = alu(rS1c,lit,1)&#13;
    if op == 0b0010010:                    # SUB&#13;
        r[rD] = alu(rS1c,rS2c,2)&#13;
    if op == 0b0010011:                    # SUBL&#13;
        r[rD] = alu(rS1c,lit,2)&#13;
    if op == 0b0010100:                    # AND&#13;
        r[rD] = (rS1c &amp; rS2c) &amp; 0xFFFF&#13;
    if op == 0b0010101:                    # ANDL&#13;
        r[rD] = (rS1c &amp; lit) &amp; 0xFFFF&#13;
    if op == 0b0010110:                    # OR&#13;
        r[rD] = (rS1c | rS2c) &amp; 0xFFFF&#13;
    if op == 0b0010111:                    # ORL&#13;
        r[rD] = (rS1c | lit) &amp; 0xFFFF&#13;
    if op == 0b0011000:                    # EOR (XOR)&#13;
        r[rD] = (rS1c ^ rS2c) &amp; 0xFFFF&#13;
    if op == 0b0011001:                    # EORL (XORL)&#13;
        r[rD] = (rS1c ^ lit) &amp; 0xFFFF&#13;
    if op == 0b0011010:                    # CMP&#13;
        diff = alu(rDc,rS1c,2)&#13;
    if op == 0b0011011:                    # CMPL&#13;
        diff = alu(rDc,lit,2)&#13;
    if op == 0b0011100:                    # LSL&#13;
        r[rD] = (rS1c &lt;&lt; 1) &amp; 0xFFFF&#13;
    if op == 0b0011101:                    # LSR&#13;
        r[rD] = (rS1c &gt;&gt; 1) &amp; 0xFFFF&#13;
    if op == 0b0011110:                    # ROL&#13;
        bitLost = (rS1c &amp; 0x8000) &gt;&gt; 16&#13;
        rS1c = (rS1c &lt;&lt; 1) &amp; 0xFFFF&#13;
        r[rD] = rS1c | bitLost&#13;
    if op == 0b0011111:                    # ROR&#13;
        bitLost = (rS1c &amp; 0x0001)&#13;
        rS1c = (rS1c &gt;&gt; 1) &amp; 0xFFFF&#13;
        r[rD] = rS1c | (bitLost &lt;&lt; 16)</pre>&#13;
			<p lang="en-GB">In the following <a id="_idIndexMarker575"/>code we’ve included stack-based operations for the sake of demonstrating stack usage and for versatility:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if op == 0b0100000:    # BSR&#13;
        sp = sp - 1&#13;
        stack[sp] = pc&#13;
        pc = lit&#13;
    if op == 0b0100001:                    # RTS&#13;
        pc = stack[sp]&#13;
        sp = sp + 1&#13;
    if op == 0b0100010:                    # PUSH                       (See 7)&#13;
        sp = sp - 1&#13;
        stack[sp] = rDc&#13;
    if op == 0b0100011:                    # POP                        (See 7)&#13;
        r[rD] = stack[sp]&#13;
        sp = sp + 1&#13;
    if op == 0b0100100:                    # BL branch with link               (See 10)&#13;
        lr = pc&#13;
        pc = lit&#13;
    if op == 0b0100101:                    # RL return from link&#13;
        pc = lr&#13;
    if op == 0b0110000:                    # INC&#13;
        r[rD] = alu(rDc,1,1)&#13;
    if op == 0b0110001:                    # DEC&#13;
        r[rD] = alu(rDc,1,2)&#13;
    if op == 0b0000011:    # PRT r0 displays the ASCII character in register r0             See 11&#13;
        character = chr(r[rD])&#13;
        print(character)&#13;
    if op == 0b0000000:                    # STOP&#13;
        run = 0&#13;
# END OF CODE EXECUTION <a id="_idIndexMarker576"/>Deal with display&#13;
    if bActive ==1:                        # Are breakpoints active?&#13;
        if src[pcOld][0] in bPt:           # If the current label or mnemonic is in the table&#13;
            display()                      # display the data&#13;
        if str(pcOld) in bPt:              # If the current PC (i.e., pcOld) is in the table display&#13;
            display()&#13;
    if trace == 1:                         # If in trace mode, display registers&#13;
        x = input('&lt;&lt; ')                   # Wait for keyboard entry (any key will do)&#13;
        display()                          # then display current operation&#13;
    elif bActive != 1: display()           # If not trace and not breakpoints, display registers&#13;
    if run == 0:                           # Test for end of program             See 12&#13;
        print('End of program')            # If end, say 'Goodbye'&#13;
        sys.exit()                         # and return</pre>&#13;
			<h2 id="_idParaDest-147" lang="en-GB"><a id="_idTextAnchor156"/>Comments on TC4</h2>&#13;
			<p lang="en-GB">We have not <a id="_idIndexMarker577"/>provided a detailed discussion of this program because it follows the same pattern as earlier simulators. However, we have highlighted some of its principal features. The following numbers correspond to the numbers (at the end of the comment field) in the shaded lines of the code:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">Call regular expressions library. This is a library that handles regular expressions that offer a very powerful means of processing text. In this example, we use only one simple example of regular text processing.</li>&#13;
				<li lang="en-GB">The <code>src = [re.sub(' +', ' ',i) for i in src ]</code> Python expression uses a regular expression to remove multiple spaces from a text string. We have included this to point you in the direction of regular expressions for more sophisticated text manipulation.</li>&#13;
				<li lang="en-GB">The <code>from datetime import date</code> operation imports a method date from datetime that can be used to display the date and time. This is useful for labeling your output during a run.</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">TC4 has an optional debugging facility. We can select three options. Entering ‘D’ provides a debugging facility by printing the source program as it is processed. We can see the original source code, the source code without comments and assembly directives, and the processed version, which includes the binary output after assembly. The ‘T’ option provides a line-by-line trace function that executes a line <a id="_idIndexMarker578"/>of code each time the <em class="italic">Enter</em> key is pressed. The ‘B’ option supports breakpoints where the output is printed only at a breakpoint. The breakpoint may be a label, a mnemonic, or the PC value. Note that in breakpoint mode, only breakpoint lines are displayed.</li>&#13;
				<li lang="en-GB">Entering <code>T</code> or <code>B</code> at the prompt can be used to set up a trace mode or enter instructions or PC values into the breakpoint table. Unusually, this is performed once at the beginning of the program and not during the execution phase.</li>&#13;
				<li lang="en-GB">The function processes the source code and deals with assembly directives related to setting up the data memory, for example, loading data values with the <code>.WORD</code> directive. It also supports storing an ASCII character in memory and reserving a named memory location for data.</li>&#13;
				<li lang="en-GB">The most important directive is <code>.WORD</code>, which stores a numeric value in memory and gives that address a symbolic value. For example, if the next free data memory location were <code>20</code>, then the<code>.WORD TIME 100</code> expression would store the number <code>100 </code>at memory location <code>20</code> and bind the name <code>time</code> to <code>100</code>. The<code>.DSW</code> (define storage word) directive simply reserves memory locations for future data access and names the address of the first location; for example, if the current memory location is <code>10</code>, then <code>.DSW XYZ 5</code> frees five memory locations (<code>10</code>, <code>11</code>, <code>12</code>, <code>13</code>, and <code>14</code>) and binds the names <code>XYZ</code> to <code>10</code>. The memory pointer is moved to <code>15</code>, the next free location. The <code>memPoint</code> variable is the memory pointer that keeps track of where data is to be stored in data memory during the assembly phase. The <code>.ASCII</code> directive is there for demonstration purposes. The <code>.ASCII PQR</code> directive would store the ASCII code for the character <code>'T'</code> in memory.</li>&#13;
				<li lang="en-GB">These directives are removed from the source code after they have done their job.</li>&#13;
				<li lang="en-GB">We have created <a id="_idIndexMarker579"/>a very simple ALU that implements only add and subtract. This was done to keep the program small and concentrate on more interesting instructions in this final example. Simple logic operations are directly implemented in the code execution of the program, in the style </li>&#13;
			</ol>&#13;
			<p lang="en-GB"><code>if thisOpcode == 'AND': result = a &amp; b</code>.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="10">TC4 provides several stack operations (push and pull). We initially create a separate stack. TC4’s stack does not use the data memory. This feature is for demonstration and can be expanded.</li>&#13;
				<li lang="en-GB">Real computers normally contain a far wider range of conditional branches than we have in this book. Here, we demonstrate one such branch operation, <code>BHS</code>, which means branch if higher or same. This operation forces a branch if two values are compared and <code>x</code> &gt; <code>y</code> or <code>x</code> = <code>y</code>. Note that this applies to unsigned numbers (i.e., not two’s complement). This condition is met if the carry bit, <code>c</code>, is <code>0</code> after a comparison. <code>BHS</code> and <code>BCC</code> (branch on carry 0) are synonyms. For example, if <code>x = 1000</code> and <code>y = 0100</code>, <code>x</code> &gt; <code>y</code> if the numbers are unsigned (4 &gt; -8) and y &gt; <code>x</code> (8 &gt; 4) if the numbers are signed.</li>&#13;
				<li lang="en-GB">The <code>LDRI+</code> operation performs a pointer-based load register operation and then increments the pointer register.</li>&#13;
				<li lang="en-GB">We have provided an interesting branch and return operation like that of the ARM’s branch with link. The <code>BL</code> operation jumps to a target address and saves the return address in a special register called the link register, <code>rl</code>. At the end of the subroutine, the <code>RL</code> (return from link) instruction returns to the instruction after the call. This mechanism allows only one call, because a second call would overwrite the <a id="_idIndexMarker580"/>return address in the link register.</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">To demonstrate direct printing, the <code>PRT</code> operation displays the character corresponding to the ASCII code in the register; for example, if R1 contains 0x42, the <code>PRT R2</code> operation would display <code>B</code> on the console.</li>&#13;
				<li lang="en-GB">When the program has been executed, the <code>sys.exit()</code> library function exits the program.</li>&#13;
				<li lang="en-GB">Here’s an example of code that can be executed by TC4. It’s been badly set out in order to test TC4’s ability to process text:&#13;
<pre class="source-code">&#13;
@ TC4_test&#13;
@ 31 Oct 2021&#13;
      .equ abc 4&#13;
.word aaa abc&#13;
.word bbb 5&#13;
.dsw   dataA 6             @ data area to store numbers&#13;
.word  end 0xFFFF&#13;
 ldrl r0,0xF&#13;
 addl r1,r7,2&#13;
 bl lk&#13;
back: rnd r0&#13;
       ldrl r3,dataA       @ r3 points at data area&#13;
       ldrm r4,bbb         @ r4 contains value to store&#13;
 ldrl r5,4                 @number of words to store&#13;
loop: nop                  @&#13;
      bsr sub1&#13;
      dec r5&#13;
 bne loop&#13;
 stop&#13;
sub1: stri r4,[r3,0]&#13;
   inc r3&#13;
   addl r4,r4,2&#13;
   cmpl r4,9&#13;
   bne skip&#13;
   addl r4,r4,6&#13;
skip:  rts&#13;
lk: ldrl r6,%11100101&#13;
        andl r7,r6,0xF0&#13;
 rl</pre></li>&#13;
			</ol>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This example ends <a id="_idIndexMarker581"/>the section of this book on designing simulators in Python. In the next part, we’ll look at a real computer.</p>&#13;
			<h1 id="_idParaDest-148" lang="en-GB"><a id="_idTextAnchor157"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we have extended our overview of simulator design. We started with one of the simplest simulators of them all, the <em class="italic">zero-address machine</em>; that is, the <em class="italic">stack computer</em>, TC0. This simulator is not a true computer, because it does not include conditional and branch operations. However, it demonstrates the use of the stack as a means of performing chained calculations.</p>&#13;
			<p lang="en-GB">We then looked at the instruction set architecture (IAS) of a classic 8-bit computer, with its simple one-address instruction format, where all operations are applied to a single accumulator (i.e., register) and the contents of a memory location or a literal.</p>&#13;
			<p lang="en-GB">The one-address machine is followed by the simulation of a multi-register CISC ISA that allows operations between two registers or between a register and the contents of a memory location. The simulator we developed had a 22-bit address just to demonstrate that you can have instructions of any width.</p>&#13;
			<p lang="en-GB">We also looked at the simulator of an ALU to further demonstrate the way in which arithmetic operations can be simulated.</p>&#13;
			<p lang="en-GB">Finally, we presented a register-to-register machine with separate data and instruction memories.</p>&#13;
			<p lang="en-GB">In the next chapter, we’ll change course and introduce the ARM-based Raspberry Pi microprocessor, which can be used to write programs in Python, and learn how to program a real 32-bit ARM microprocessor in assembly language.</p>&#13;
		</div>&#13;
	</div></body></html>