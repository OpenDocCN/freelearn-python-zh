<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer052" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-132" class="chapter-number" lang="en-GB"><a id="_idTextAnchor135"/>8</h1>&#13;
			<h1 id="_idParaDest-133" lang="en-GB"><a id="_idTextAnchor136"/>Simulators for Other Architectures</h1>&#13;
			<p lang="en-GB">In this chapter, you will learn how to create simulators for different instruction set architectures, for example, the stack-based computer and the <span class="No-Break">classic CISC.</span></p>&#13;
			<p lang="en-GB">After describing a simple stack-based calculator, TC0, we will introduce a simulator for a one-address format. Most operations take place between an accumulator (i.e., register) and the contents of a memory location; for example, <strong class="source-inline">ADD Y</strong> means <em class="italic">add the contents of memory location Y to the accumulator</em>. The term <em class="italic">accumulator</em> indicates the location where the result of an addition is <em class="italic">accumulated</em>. Early microprocessors lacked room on the silicon chip for multiple registers, and all data had to pass through one or <span class="No-Break">two accumulators.</span></p>&#13;
			<p lang="en-GB">After that, we will simulate a CISC architecture, which is an extension of the accumulator-based machine, where you can perform an operation on the contents of memory and <span class="No-Break">on-chip registers.</span></p>&#13;
			<p lang="en-GB">Finally, we will present the code of TC4. This is a simulator for a non-von Neumann machine with separate address and data memories and where the address and data word <span class="No-Break">lengths differ.</span></p>&#13;
			<p lang="en-GB">We will cover the following topics in <span class="No-Break">this chapter:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">TC0: A <span class="No-Break">Stack-Based Calculator</span></li>&#13;
				<li lang="en-GB">TC2: A One-Address <span class="No-Break">Accumulator Machine</span></li>&#13;
				<li lang="en-GB">TC3: A CISC Machine with a <span class="No-Break">Register-to-Memory Architecture</span></li>&#13;
				<li lang="en-GB">The Complete <span class="No-Break">TC3 Code</span></li>&#13;
				<li lang="en-GB">Arithmetic and Logic <span class="No-Break">Unit (ALU)</span></li>&#13;
				<li lang="en-GB">A Final <span class="No-Break">Example: TC4</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-134" lang="en-GB"><a id="_idTextAnchor137"/>Technical requirements</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can find the programs used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-135" lang="en-GB"><a id="_idTextAnchor138"/>TC0: A stack-based calculator</h1>&#13;
			<p lang="en-GB">We’ll begin with a very simple s<em class="italic">tack-based calculator</em>. Here, we’ll introduce a zero-address machine that avoids explicit operand addresses by storing data on a stack. We have included the notion of a stack-based computer for two reasons. First, it forms the basis of many classic calculators, a programming language (FORTH) and the design of a classic computer (Burroughs B5000). Second, constructing a stack-based computer is very easy and you can experiment with this class of computer. Indeed, elements of a stack-based processor can easily be incorporated into any computer. In a conventional computer, two elements are added with an operation such as <strong class="source-inline">ADD A,B,C</strong>. In a stack-based computer, two elements are added with <strong class="source-inline">ADD</strong>. There is no need for operand addresses because the elements to be added are the top two in <span class="No-Break">a stack.</span></p>&#13;
			<p lang="en-GB">The computer we describe here is called TC0 to indicate that it is a proto-simulator, rather than a full simulator (it cannot execute <span class="No-Break">conditional operations).</span></p>&#13;
			<p lang="en-GB">The stack is a data structure in the form of a queue. Items enter the queue at the top and leave the queue in the reverse order to that in which they entered. It’s called a <em class="italic">stack</em> because it behaves exactly like a stack <span class="No-Break">of papers.</span></p>&#13;
			<p lang="en-GB">A stack provides two operations: <em class="italic">push</em>, in which an item is added to the stack, and <em class="italic">pull</em> (or <em class="italic">pop</em>), in which an item is removed from <span class="No-Break">the stack.</span></p>&#13;
			<p lang="en-GB">An operation on a single element (e.g., negate) is applied to the <em class="italic">top</em> element of the stack. An operation with two operands is applied to the two elements at the <strong class="bold">Top of the Stack (TOS)</strong>; for example, an addition is performed by pulling two operands off the stack, performing the addition, and then pushing the result back on the stack. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> demonstrates the behavior of the stack as we evaluate P = (A + B)×(C – B – <span class="No-Break">D).</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer048" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_8.1_B19624.jpg" alt="Figure 8.1 – The sequence of actions taking place during the evaluation of (A + B)×(C – B – D)" width="1751" height="716"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 8.1 – The sequence of actions taking place during the evaluation of (A + B)×(C – B – D)</p>&#13;
			<p lang="en-GB"><em class="italic">Table 8.1</em> shows how we perform the P = (A + B)×(C – B – D) calculation using the <strong class="source-inline">PUSH</strong>, <strong class="source-inline">PULL</strong>, <strong class="source-inline">ADD</strong>, <strong class="source-inline">SUB</strong>, and <strong class="source-inline">MUL</strong> stack operations. As well as arithmetic operations, two other common stack operations are <strong class="source-inline">DUP</strong> (duplicate) and <strong class="source-inline">SWAP</strong>. The <strong class="source-inline">DUP</strong> operation makes <a id="_idIndexMarker500"/>a copy of the item at the TOS and pushes it on the stack (i.e., the top of the stack is duplicated). The <strong class="source-inline">SWAP</strong> operation exchanges the TOS and <strong class="bold">Next on Stack (</strong><span class="No-Break"><strong class="bold">NOS)</strong></span><span class="No-Break"> values.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">Operation        The stack as a Python list (bold is top of stack)</strong></span>&#13;
<span>PUSH A           stack = [x,x,x,x,x,x,x,<strong class="bold">A</strong>]</span>&#13;
<span>PUSH B           stack = [x,x,x,x,x,x,<strong class="bold">B</strong>,A]</span>&#13;
<span>ADD              stack = [x,x,x,x,x,x,x,<strong class="bold">A+B</strong>]</span>&#13;
<span>PUSH C           stack = [x,x,x,x,x,x,<strong class="bold">C</strong>,A+B]</span>&#13;
<span>PUSH B           stack = [x,x,x,x,x,<strong class="bold">B</strong>,C,A+B]</span>&#13;
<span>SUBTRACT         stack = [x,x,x,x,x,x,<strong class="bold">C-B</strong>,A+B]</span>&#13;
<span>PUSH D           stack = [x,x,x,x,x,<strong class="bold">D</strong>,C-B,A+B]</span>&#13;
<span>SUBTRACT         stack = [x,x,x,x,x,x,<strong class="bold">D-C-B</strong>,A+B]</span>&#13;
<span>MULTIPLY         stack = [x,x,x,x,x,x,x,(<strong class="bold">D-C-B)(A+B)</strong>]</span>&#13;
<span>PULL result      stack = [x,x,x,x,x,x,x,x]</span></pre>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – The code to evaluate (A + B)×(C – B – D)</p>&#13;
			<p lang="en-GB">To simplify the simulator, each instruction is stored in a Python list consisting of the operation and <a id="_idIndexMarker501"/>memory address (for <strong class="source-inline">PUSH</strong> and <strong class="source-inline">PULL</strong>). This is not intended to be a practical simulator; it’s a demonstration of the use of the stack to handle arithmetic operations and an introduction to the stack for <span class="No-Break">later chapters.</span></p>&#13;
			<p lang="en-GB">A register called a <strong class="bold">Stack Pointer (SP)</strong> points to the TOS. That is, the stack pointer contains the address <a id="_idIndexMarker502"/>of the item at the top of the stack. By convention, the stack pointer grows <em class="italic">upward</em> as items are added and shrinks downward as items are removed. Since we draw memory diagrams with low addresses at the top of the page, the stack grows up toward low addresses. In other words, if the top of a stack is at the location <strong class="source-inline">1231,</strong> pushing an element on the stack stores it at address <strong class="source-inline">1230</strong>, since the stack grows toward <span class="No-Break">low addresses.</span></p>&#13;
			<p lang="en-GB">In some implementations, the stack pointer points at the <em class="italic">next free location</em> above the top of the stack. We will represent the stack in Python by the list <strong class="source-inline">stack[]</strong>. The stack pointer is sp and the operation to push item A on the stack is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sp = sp – 1       <span class="sc-comment"># Decrement the stack pointer. Point to the next free location above TOS</span></span>&#13;
<span>stack[sp] = A     <span class="sc-comment"># Load the new value, A, on the stack </span><span class="sc-comment">in this location</span></span></pre>&#13;
			<p lang="en-GB">Remember that the <a id="_idIndexMarker503"/>stack pointer is decremented because the stack grows toward lower addresses. If an item is popped off the stack, the inverse operation is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>A = stack[sp]     <span class="sc-comment"># Retrieve the item at the top of the stack</span></span></pre>&#13;
			<pre class="source-code">sp = sp + 1       <span class="sc-comment"># Move the stack pointer down</span></pre>&#13;
			<p lang="en-GB">These are complementary operations. A pull operation cancels a push. Consider evaluating an expression. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em> shows the state of the stack during the evaluation of <strong class="source-inline">X = (A + B)×(C – </strong><span class="No-Break"><strong class="source-inline">D)</strong></span><span class="No-Break">.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer049" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_8.2_B19624.jpg" alt="Figure 8.2 – The sequence of actions taking place during the evaluation of X = (A + B)×(C – D)" width="1471" height="888"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The sequence of actions taking place during the evaluation of X = (A + B)×(C – D)</p>&#13;
			<p lang="en-GB">The next step is <a id="_idIndexMarker504"/>to demonstrate how we can implement a simple calculator, TC0, based on <span class="No-Break">a stack.</span></p>&#13;
			<h2 id="_idParaDest-136" lang="en-GB"><a id="_idTextAnchor139"/>TC0: A python stack machine</h2>&#13;
			<p lang="en-GB">We can <a id="_idIndexMarker505"/>represent the addition <strong class="source-inline">y3 = y1 + y2</strong> on a stack machine in Python <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>y1 = stack[sp]        <span class="sc-comment"># Retrieve the item at the top of the stack (y1 and y2 are on the stack)</span></span>&#13;
<span>sp = sp + 1           <span class="sc-comment"># Move the stack pointer down</span></span>&#13;
<span>y2 = stack[sp]        <span class="sc-comment"># Retrieve the item at the top of the stack</span></span>&#13;
<span>y3 = y1 + y2          <span class="sc-comment"># Add the two values</span></span>&#13;
<span>stack[sp] = y3        <span class="sc-comment"># Store the result on the stack</span></span></pre>&#13;
			<p lang="en-GB">We’ve taken a shortcut. We could have pulled two elements off the stack, added them, and pushed the result. Instead, we put the result back where the second operand was and saved two stack pointer movements. The following Python code illustrates a very simple stack machine interpreter. It does not implement branch operations, so it is not a realistic computation machine. Because a stack machine often operates on the top of the stack and the element below it, the second element is frequently called NOS. Note that the program <a id="_idIndexMarker506"/>is stored as a list of lists, with each instruction consisting of either a two-element list (e<a id="_idTextAnchor140"/>.g., <strong class="source-inline">['push', '2'])</strong> or a single-element list (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">['</strong></span><span class="No-Break"><strong class="source-inline">mu<a id="_idTextAnchor141"/>l']</strong></span><span class="No-Break">):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                       <span class="sc-comment"># Stack machine simulator</span></span>&#13;
<span>prog = [['push',0],['push',1],['add'],   ['push',2],['push',1],           \</span>&#13;
<span>        ['sub'],   ['push',3],['sub'],   ['mul'],   ['push',4],           \</span>&#13;
<span>        ['swap'],  ['dup'],['pull',4],   ['stop']]</span>&#13;
<span>stack = [0] * 8                        <span class="sc-comment"># 8-location stack. Stack grows to lower addresses</span></span>&#13;
<span>mem   = [3,2,7,4,6,0]                  <span class="sc-comment"># Data memory </span><span class="sc-comment">(first locations </span><span class="sc-comment">are preloaded 3, 2,</span><span class="sc-comment">7, 4, 6)</span></span>&#13;
<span>run = True                             <span class="sc-comment"># Execution </span><span class="sc-comment">continues while run </span><span class="sc-comment">is true</span></span>&#13;
<span>pc = 0                                 <span class="sc-comment"># Program counter </span><span class="sc-comment">- initialize</span></span>&#13;
<span>sp = 8                                 <span class="sc-comment"># Initialize stack </span><span class="sc-comment">pointer to 1 past </span><span class="sc-comment">end of stack</span></span>&#13;
<span>while run:                             <span class="sc-comment"># Execute MAIN LOOP </span><span class="sc-comment">until run is false </span><span class="sc-comment">(STOP command)</span></span>&#13;
<span>    inst = prog[pc]                    <span class="sc-comment"># Read the next </span><span class="sc-comment">instruction</span></span>&#13;
<span>    pc = pc + 1                        <span class="sc-comment"># Increment program </span><span class="sc-comment">counter</span></span>&#13;
<span>    if   inst[0] == 'push':            <span class="sc-comment"># Test for push </span><span class="sc-comment">operation</span></span>&#13;
<span>         sp = sp - 1                   <span class="sc-comment"># Pre-decrement </span><span class="sc-comment">stack pointer</span></span>&#13;
<span>         address = int(inst[1])        <span class="sc-comment"># Get data from </span><span class="sc-comment">memory</span></span>&#13;
<span>         stack[sp] = mem[address]      <span class="sc-comment"># Store it on the </span><span class="sc-comment">stack</span></span>&#13;
<span>    elif inst[0] == 'pull':            <span class="sc-comment"># Test for a pull </span><span class="sc-comment">instruction</span></span>&#13;
<span>         address = int(inst[1])        <span class="sc-comment"># Get destination </span><span class="sc-comment">address</span></span>&#13;
<span>         mem[address] = stack[sp]      <span class="sc-comment"># Store the item </span><span class="sc-comment">in memory</span></span>&#13;
<span>         sp = sp + 1                   <span class="sc-comment"># Increment stack </span><span class="sc-comment">pointer</span></span>&#13;
<span>    elif inst[0] == 'add':             <span class="sc-comment"># If operation add </span><span class="sc-comment">TOS to NOS and push </span><span class="sc-comment">result</span></span>&#13;
<span>         p = stack[sp]</span>&#13;
<span>         sp = sp + 1</span>&#13;
<span>         q = stack[sp]</span>&#13;
<span>         stack[sp] = p + q</span>&#13;
<span>    elif inst[0] == 'sub':             <span class="sc-comment"># sub</span></span>&#13;
<span>         p = stack[sp]</span>&#13;
<span>         sp = sp + 1</span>&#13;
<span>         q = stack[sp]</span>&#13;
<span>         stack[sp] = q - p</span>&#13;
<span>    elif inst[0] == 'mul':             <span class="sc-comment"># mul</span></span>&#13;
<span>         p = stack[sp]</span>&#13;
<span>         sp = sp + 1</span>&#13;
<span>         q = stack[sp]</span>&#13;
<span>         stack[sp] = p * q</span>&#13;
<span>    elif inst[0] == 'div':             <span class="sc-comment"># div (note floor </span><span class="sc-comment">division with </span><span class="sc-comment">integer result)</span></span>&#13;
<span>         p = stack[sp]</span>&#13;
<span>         sp = sp + 1</span>&#13;
<span>         q = stack[sp]</span>&#13;
<span>         stack[sp] = p//q</span>&#13;
<span>    elif inst[0] == 'dup':             <span class="sc-comment"># dup (duplicate </span><span class="sc-comment">top item on stack)</span></span>&#13;
<span>         p = stack[sp]                 <span class="sc-comment"># get current TOS</span></span>&#13;
<span>         sp = sp - 1                   <span class="sc-comment"># and push it on </span><span class="sc-comment">the stack to </span><span class="sc-comment">duplicate</span></span>&#13;
<span>         stack[sp] = p</span>&#13;
<span>    elif inst[0] == 'swap':            <span class="sc-comment"># swap (exchange </span><span class="sc-comment">top of stack and </span><span class="sc-comment">next on stack)</span></span>&#13;
<span>         p = stack[sp]</span>&#13;
<span>         q = stack[sp+1]</span>&#13;
<span>         stack[sp] = q</span>&#13;
<span>         stack[sp+1]=p</span>&#13;
<span>    elif inst[0] == 'stop':            <span class="sc-comment"># stop</span></span>&#13;
<span>         run = False</span>&#13;
<span>    if sp == 8: TOS = 'empty'          <span class="sc-comment"># Stack elements 0 </span><span class="sc-comment">to 7. Element 8 </span><span class="sc-comment">is before the TOS</span></span>&#13;
<span>    else: TOS = stack[sp]</span>&#13;
<span>    print('pc =', pc-1,'sp =',sp,'TOS =',TOS,'Stack',stack,'Mem',mem,'op',inst)</span></pre>&#13;
			<p lang="en-GB">The following is <a id="_idIndexMarker507"/>the output from this program, which shows the program counter, the top of the stack, NOS, the stack itself, the data, and the opcode being executed. Values that change between cycles are <span class="No-Break">in bold:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc=0 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">3</strong> Stack [0,0,0,0,0,0,0,<strong class="bold">3</strong>] Mem [<strong class="bold">3</strong>,2,7,4,6,0] op ['push',0]</span>&#13;
<span>pc=1 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">2</strong> Stack [0,0,0,0,0,0,<strong class="bold">2</strong>,3] Mem [3,<strong class="bold">2</strong>,7,4,6,0] op ['push',1]</span>&#13;
<span>pc=2 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,0,2,<strong class="bold">5</strong>] Mem [3,2,7,4,6,0] op ['add']</span>&#13;
<span>pc=3 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">7</strong> Stack [0,0,0,0,0,0,<strong class="bold">7</strong>,5] Mem [3,2,<strong class="bold">7</strong>,4,6,0] op ['push',2]</span>&#13;
<span>pc=4 sp=<strong class="bold">5</strong>  TOS=<strong class="bold">2</strong> Stack [0,0,0,0,0,<strong class="bold">2</strong>,7,5] Mem [3,<strong class="bold">2</strong>,7,4,6,0] op ['push',1]</span>&#13;
<span>pc=5 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,2,<strong class="bold">5</strong>,5] Mem [3,2,7,4,6,0] op ['sub']</span>&#13;
<span>pc=6 sp=<strong class="bold">5</strong>  TOS=<strong class="bold">4</strong> Stack [0,0,0,0,0,<strong class="bold">4</strong>,5,5] Mem [3,2,7,<strong class="bold">4</strong>,6,0] op ['push',3]</span>&#13;
<span>pc=7 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">1</strong> Stack [0,0,0,0,0,4,<strong class="bold">1</strong>,5] Mem [3,2,7,4,6,0] op ['sub']</span>&#13;
<span>pc=8 sp=<strong class="bold">7</strong>  TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,4,1,<strong class="bold">5</strong>] Mem [3,2,7,4,6,0] op ['mul']</span>&#13;
<span>pc=9 sp=<strong class="bold">6</strong>  TOS=<strong class="bold">6</strong> Stack [0,0,0,0,0,4,<strong class="bold">6</strong>,5] Mem [3,2,7,4,<strong class="bold">6</strong>,0] op ['push',4]</span>&#13;
<span>pc=10 sp=6 TOS=<strong class="bold">5</strong> Stack [0,0,0,0,0,4,<strong class="bold">5</strong>,6] Mem [3,2,7,4,6,0] op ['swap']</span>&#13;
<span>pc=11 sp=5 TOS=5 Stack [0,0,0,0,0,<strong class="bold">5</strong>,5,6] Mem [3,2,7,4,6,0] op ['dup']</span>&#13;
<span>pc=12 sp=6 TOS=5 Stack [0,0,0,0,0,5,<strong class="bold">5</strong>,6] Mem [3,2,7,4,6,<strong class="bold">5</strong>] op ['pull',5]</span></pre>&#13;
			<pre class="source-code">pc=13 sp=6 TOS=5 Stack [0,0,0,0,0,5,5,6] Mem [3,2,7,4,6,5] op ['stop']</pre>&#13;
			<p lang="en-GB">In the next section, we will look at a more realistic machine that implements a simple accumulator <a id="_idIndexMarker508"/>machine of the early 8-bit <span class="No-Break">microprocessor era.</span></p>&#13;
			<h1 id="_idParaDest-137" lang="en-GB"><a id="_idTextAnchor142"/>TC2: A one-address accumulator machine</h1>&#13;
			<p lang="en-GB">In this section, you will learn about a computer that implements a memory-to-register architecture. This is a very simple machine that implements a one-address instruction format (like an 8-bit CISC microprocessor from <span class="No-Break">the 1970s).</span></p>&#13;
			<p lang="en-GB">The TC2 model <a id="_idIndexMarker509"/>can be used to simulate classic 8-bit microprocessors that are found in low-cost computer systems (e.g., controllers in mechanical devices). It also teaches you about the trade-off between simplicity (of the computer) and complexity (of the software that is constrained by the <span class="No-Break">primitive architecture).</span></p>&#13;
			<p lang="en-GB">Unlike modern RISC architectures with data-processing operations between two registers, this computer implements a dyadic operation between one operand in the accumulator and the other operand, which is either a literal or the contents of memory; for example, <strong class="source-inline">ADD M</strong> adds the contents of memory location <strong class="source-inline">M</strong> to the accumulator, and <strong class="source-inline">ADD #5</strong> adds a literal to the contents of the accumulator. This computer does not have a large set of <span class="No-Break">general-purpose registers.</span></p>&#13;
			<p lang="en-GB">The one-address machine permits operations between data in the accumulator and in memory. This contrasts with RISC architectures that permit data-processing operations only between registers. Load and store are the only memory operations permitted by a RISC architecture. This computer, TC2, implements a minimal instruction set that demonstrates its operation. Table 8.2 describes the <span class="No-Break">instruction set:</span></p>&#13;
			<table id="table001-6" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Mnemonic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Action</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Memory form</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Literal form</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Opcode</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDA</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Load accumulator</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">M]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STA</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Store accumulator</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[M]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">A]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[M]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">ADD</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add <span class="No-Break">to accumulator</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[A] + [</strong><span class="No-Break"><strong class="source-inline">M]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[A] + L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">1</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">SUB</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Subtract <span class="No-Break">from accumulator</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[A] - [</strong><span class="No-Break"><strong class="source-inline">M]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[A] – L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">2</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">CLR</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load accumulator/memory <span class="No-Break">with zero</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[A]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[M]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BRA</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch unconditionally <span class="No-Break">to L</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[PC]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">4</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BEQ</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch on zero <span class="No-Break">to L</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">if Z = 1 then[PC]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">5</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BNE</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch on not zero <span class="No-Break">to L</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">if Z = 0 then[PC]</strong><span class="CharOverride-3"> </span><span class="CharOverride-4">←</span><span class="CharOverride-3"> </span><strong class="source-inline">L</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">6</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STOP</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Stop</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">7</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – Typical operations of a register-to-memory computer</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Here, <strong class="source-inline">[A]</strong> is the contents of the accumulator, <strong class="source-inline">[M]</strong> is the contents of memory location <em class="italic">M</em>, <em class="italic">L</em> is a literal, and the Z-bit is set if the result of a subtraction is zero. <em class="italic">M</em> and <em class="italic">L</em> represent the <a id="_idIndexMarker510"/>literal field of an instruction and are mutually exclusive. You can’t have an instruction with both an <em class="italic">M</em> and <span class="No-Break"><em class="italic">L</em></span><span class="No-Break"> operand.</span></p>&#13;
			<p lang="en-GB">Simulating a computer teaches us a lot about partitioning an instruction into various fields and how to implement instructions. In this example, we use a 3-bit opcode, a 1-bit <em class="italic">direction</em> flag (for <strong class="source-inline">LDA</strong> and <strong class="source-inline">STA</strong>) that defines the direction of data movement (to or from memory), and a 1-bit <em class="italic">mode</em> flag that selects either a literal or a direct memory access. A 5-bit numeric field provides an integer in the range 0 to 31, or a memory address. The instruction size is 10 bits with the format <strong class="source-inline">CCC D M LLLLL</strong>, where <em class="italic">CCC</em> is the opcode field, <em class="italic">D</em> is the direction bit, <em class="italic">M</em> is the mode bit, and <em class="italic">LLLLL</em> is the literal or memory address (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>). The extreme simplicity of this makes it easy to write a tiny simulator and leaves the user with a lot of opportunities to expand the code into a more <span class="No-Break">realistic machine.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer050" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_8.3_B19624.jpg" alt="Figure 8.3 – TC2 instruction format" width="1167" height="693"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – TC2 instruction format</p>&#13;
			<p lang="en-GB">TC2 simulates a <a id="_idIndexMarker511"/>stored program computer with a single memory that holds both the program and data. The 32-bit location memory is initialized by memory = <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">0]*32</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The TC2 code has a setup section and a <strong class="source-inline">while</strong> loop that includes a fetch instruction and an execute instruction part. The structure of the <strong class="source-inline">while</strong> loop part of the code (instruction fetch/execute cycle) consists of <span class="No-Break">the following:</span></p>&#13;
			<pre><span class="sc-top" lang="en-GB">while run == True:</span>&#13;
<span class="sc-bottom" lang="en-GB">   operation         <span class="sc-comment"># Body of while loop operation</span></span>&#13;
<span class="sc-bottom" lang="en-GB">   .</span>&#13;
<span class="sc-bottom" lang="en-GB">   .</span>&#13;
<span class="sc-grey" lang="en-GB">statement            <span class="sc-comment"># Next operation after the while loop</span></span></pre>&#13;
			<p lang="en-GB">Within the while loop, we have a <strong class="source-inline">fetch</strong> phase followed by an execution phase. The <strong class="source-inline">fetch</strong> phase is identical to the CPUs we have already described. Instruction decoding is included in this phase. Instruction decoding separates OpCode, Dir (i.e., direction to or from memory), Mode, and Literal by using shifting and <span class="No-Break">bit-masking operations:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    MAR = PC                     <span class="sc-comment"># PC to Memory Address Register</span></span>&#13;
<span>    PC = PC + 1                  <span class="sc-comment"># Increment PC</span></span>&#13;
<span>    MBR = Memory[MAR]            <span class="sc-comment"># Read instruction, copy to Memory Buffer register</span></span>&#13;
<span>    IR = MBR                     <span class="sc-comment"># Copy instruction to Instruction Register</span></span>&#13;
<span>    OpCode = IR &gt;&gt; 7             <span class="sc-comment"># Extract Op-Code frominstruction (bits 7 to 10)</span></span>&#13;
<span>    Dir  = (IR &gt;&gt; 6) &amp; 1         <span class="sc-comment"># Extract data direction from instruction (0 = read, 1 = write)</span></span>&#13;
<span>    Mode = (IR &gt;&gt; 5) &amp; 1         <span class="sc-comment"># Extract address mode from instruction (0 = literal, 1 = memory)</span></span>&#13;
<span>    Lit = IR &amp; 0x1F              <span class="sc-comment"># Extract the literal/address field from the instruction</span></span></pre>&#13;
			<p lang="en-GB">Right shifts and <a id="_idIndexMarker512"/>ANDs extract fields from the instruction; for example, the 3-bit opcode is extracted from the 10-bit <strong class="source-inline">CCCDMLLLLL</strong> instruction by shifting seven places left to get <strong class="source-inline">0000000CCC</strong>. The direction bit, Dir, is extracted by performing six left shifts to get <strong class="source-inline">000000CCCD</strong> and then ANDing the result with 1 to get <strong class="source-inline">000000000D</strong>. These two operations can be combined and written <span class="No-Break">as follows:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">(IR &gt;&gt; 6) &amp; 1</strong><span class="CharOverride-5">     </span><span class="sc-comment"> # 6-bit shift right with &gt;&gt; and AND with 1 using the AND </span><span class="No-Break"><span class="sc-comment">operator, &amp;</span></span></p>&#13;
			<p lang="en-GB">Similarly, we extract the mode bit by performing <strong class="source-inline">Mode = (IR &gt;&gt; 5) &amp; 1</strong>. Finally, the literal is in place, so all we have to do is to clear the other bits by ANDing it with <strong class="source-inline">0b0000011111</strong>, that is, <strong class="source-inline">IR &amp; </strong><span class="No-Break"><strong class="source-inline">0x1F</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">In the <strong class="source-inline">execute</strong> phase, the three op-code bits, <strong class="source-inline">OpCode</strong>, select one of the eight possible instructions. Of course, the use of <strong class="source-inline">if … elif</strong> would have been <span class="No-Break">more appropriate:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if   OpCode == 0:</span>&#13;
<span>     Code for case 0</span>&#13;
<span class="sc-grey" lang="en-GB">elif OpCode == 1:</span>&#13;
<span class="sc-grey" lang="en-GB">     Code for case 1</span>&#13;
<span class="sc-bottom" lang="en-GB">.</span>&#13;
<span class="sc-bottom" lang="en-GB">.</span>&#13;
<span class="sc-grey" lang="en-GB">elif OpCode == 7:</span>&#13;
<span class="sc-grey" lang="en-GB">     Code for case 7</span></pre>&#13;
			<p lang="en-GB">Each op-code is guarded <a id="_idIndexMarker513"/>by an <strong class="source-inline">if</strong> statement. Here’s the code for the load and store accumulator instruction. We treat this as one operation and use the direction flag, <strong class="source-inline">Dir</strong>, to select between <strong class="source-inline">LDA</strong> (direction memory to accumulator) and <strong class="source-inline">STA</strong> (direction accumulator <span class="No-Break">to memory):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if OpCode == 0:              <span class="sc-comment"># Test for Load </span><span class="sc-comment">A or Store A instruction</span></span>&#13;
<span class="sc-grey" lang="en-GB">      if Dir  == 0:              <span class="sc-comment"># If direction </span><span class="sc-comment">bit is 0, then it's a load accumulator</span></span>&#13;
<span class="sc-grey" lang="en-GB">         if Mode == 0:           <span class="sc-comment"># Test for </span><span class="sc-comment">literal or direct memory operand</span></span>&#13;
<span class="sc-grey" lang="en-GB">            Acc  = Lit           <span class="sc-comment"># If mode is 0, </span><span class="sc-comment">then it's a literal operand</span></span>&#13;
<span class="sc-grey" lang="en-GB">         else:                   <span class="sc-comment">#If mode is 1, </span><span class="sc-comment">then it's a memory access</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            MAR = Lit            <span class="sc-comment">#Copy field </span><span class="sc-comment">(address) to MAR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            MBR = Memory[MAR]    <span class="sc-comment">#Do a read to </span><span class="sc-comment">get the operand in MBR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            Acc  = MBR           <span class="sc-comment">#and send it to </span><span class="sc-comment">the accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">      else:</span>&#13;
<span class="sc-bottom" lang="en-GB">          MAR = Lit              <span class="sc-comment"># If direction </span><span class="sc-comment">is 1 then it's a store accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">          MBR = Acc              <span class="sc-comment"># Copy </span><span class="sc-comment">accumulator to MBR</span></span>&#13;
<span class="sc-bottom">          Memory[MAR] = MBR      <span class="sc-comment"># and write MBR </span><span class="sc-comment">to memory</span></span></pre>&#13;
			<p lang="en-GB">To make it easier <a id="_idIndexMarker514"/>to read the code, we’ve divided it into two blocks (one shaded in dark gray and one in light gray) guarded by the if <strong class="source-inline">Dir == 0</strong> statement. When the direction flag is 0, the instruction is <em class="italic">load accumulator</em> and the address is copied to the <strong class="source-inline">MAR</strong>, a read is performed, and the data is copied to the <strong class="source-inline">MBR</strong> and then the accumulator. If the direction flag is 1, the instruction is a <em class="italic">store accumulator</em> and the accumulator is copied to the <strong class="source-inline">MBR</strong> and a write operation is <span class="No-Break">carried out.</span></p>&#13;
			<p lang="en-GB">Note the use of the <strong class="source-inline">Mode</strong> flag. When loading the accumulator from memory, <strong class="source-inline">LDA</strong>, the mode flag is used to load the accumulator with either a literal or the contents of memory. When executing a <strong class="source-inline">STA</strong>, which refers to the store accumulator, the mode flag is ignored because only a memory store <span class="No-Break">is possible.</span></p>&#13;
			<p lang="en-GB">We don’t need to describe the <strong class="source-inline">ADD</strong> and <strong class="source-inline">SUB</strong> operations because they are simply extensions of the load and store operations. We’ve included a clear operation, <strong class="source-inline">CLR</strong>, which sets either the accumulator to 0 or the contents of memory to 0 depending only on the <span class="No-Break"><strong class="source-inline">Mode</strong></span><span class="No-Break"> flag.</span></p>&#13;
			<p lang="en-GB">We’ll now present the full simulator code. The <strong class="source-inline">Memory[MAR]</strong> notation means the contents of memory whose address is in the <strong class="source-inline">MAR</strong> and is conveniently identical to the RTL we’ve been using. In the execute instruction block, alternate opcodes are shaded gray and blue to <span class="No-Break">facilitate reading.</span></p>&#13;
			<p lang="en-GB">We’ve included a small program in memory, complete with data that tests several of the instructions, including load and store, add, subtract, <span class="No-Break">and branch.</span></p>&#13;
			<p lang="en-GB">TC2 has a clear operation, <strong class="source-inline">CLR</strong>, that sets either the accumulator or the contents of memory to 0 depending on the Mode flag. This simplified computer has only a Z-bit (no N and <span class="No-Break">C bits).</span></p>&#13;
			<p lang="en-GB">The branch group of instructions (<strong class="source-inline">BRA</strong>, <strong class="source-inline">BEQ</strong>, and <strong class="source-inline">BNE</strong>) load the program counter with a literal to force a jump. <strong class="source-inline">BRA</strong> performs an unconditional branch, and <strong class="source-inline">BEQ</strong>/<strong class="source-inline">BNE</strong> depending on the state of the Z-bit, which is set/cleared by add and subtract operations. The branch target address is an absolute address provided by the <span class="No-Break">literal field.</span></p>&#13;
			<p lang="en-GB">We have reserved <a id="_idIndexMarker515"/>the last instruction opcode, <strong class="source-inline">111</strong>, as a stop (halt) instruction that breaks out of the <strong class="source-inline">while</strong> loop and terminates execution. In general, a real CPU does not need a halt instruction, although a halt instruction can be used to force it into a power-down mode until it is awakened by an external event, such as a keyboard/mouse input or a <span class="No-Break">sc<a id="_idTextAnchor143"/>reen touch:</span></p>&#13;
			<pre><span class="sc-grey" lang="en-GB">                                <span class="sc-comment"># The TC2: A primitive accumulator machine</span></span>&#13;
<span class="sc-grey" lang="en-GB">mnemonics = {0:'LDA/STR', 1:'ADD', 2:'SUB', 3:'CLR', 4:'BRA', 5: \</span>&#13;
<span class="sc-grey" lang="en-GB">               'BEQ', 6:'BNE', 7:'STOP'}</span>&#13;
<span class="sc-grey" lang="en-GB">def progSet():</span>&#13;
<span class="sc-grey" lang="en-GB">    global mem</span>&#13;
<span class="sc-grey" lang="en-GB">    mem = [0] * 32              <span class="sc-comment"># The memory holds both instructions and data</span></span>&#13;
<span class="sc-grey" lang="en-GB">  # Format  CCCDMLLLLL          <span class="sc-comment"># 000 LDA/STR, 001 ADD, 010 SUB, 011 CLR, 100 BRA, \</span></span>&#13;
<span class="sc-grey" lang="en-GB">                                  <span class="sc-comment">101 BEQ, 110 BNE, 111 STOP</span></span>&#13;
<span class="sc-grey" lang="en-GB">    mem[0]  =  0b0000110000     # LDA 16  [A]   = M[16]</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[1]  =  0b0010110001     # ADD 17  [A]   = [A] + M[17] </span>&#13;
<span class="sc-grey" lang="en-GB">    mem[2]  =  0b0001110010     # STA 18  M[18] = [A]</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[3]  =  0b0100000011     # SUB #3  [A]   = [A] - 3</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[4]  =  0b1010001000     # BEQ 8</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[5]  =  0b0000010010     # LDA #18 [A]   = 18</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[6]  =  0b0001110010     # STA 18  M[18] = [A]</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[7]  =  0b0110000000     # CLR     [A]   = 0  </span>&#13;
<span class="sc-grey" lang="en-GB">    mem[8]  =  0b0000000010     # LDA #2  [A]   = 2  </span>&#13;
<span class="sc-grey" lang="en-GB">    mem[9]  =  0b0100000010     # SUB #2  [A]   = [A] - 3</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[10] =  0b1010001101     # BEQ 12</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[11] =  0b0000001111     # LDA #15 LDA #18 [A] = 18 Dummy not executed  </span>&#13;
<span class="sc-grey" lang="en-GB">    mem[12] =  0b1110000000     # STOP</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[16] =  0b0000000100     # 4 Data for test</span>&#13;
<span class="sc-grey" lang="en-GB">    mem[17] =  0b0000000101     # 5 Data for test  </span>&#13;
<span class="sc-grey" lang="en-GB">    mem[31] =  0b1110000000     # Ensure STOP operation</span>&#13;
<span class="sc-grey" lang="en-GB">    return(mem)</span>&#13;
<span class="sc-bottom" lang="en-GB">run = True                  <span class="sc-comment"># run is True for code execution. Setting run to False stops the computer</span></span>&#13;
<span class="sc-bottom" lang="en-GB">PC  = 0                     <span class="sc-comment"># The program counter points to the next instruction to execute. Initially 0</span></span>&#13;
<span class="sc-bottom" lang="en-GB">z = 0                       <span class="sc-comment"># Initialize z-bit (note no n and c bits implemented)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">mem = progSet()</span></pre>&#13;
			<p lang="en-GB">Now that we’ve <a id="_idIndexMarker516"/>loaded memory with the program and set up some variables, we can enter the <strong class="source-inline">fetch </strong><span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break"> loop:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                 <span class="sc-comment"># MAIN LOOP – FETCH/EXECUTE</span></span>&#13;
<span>while run:                   <span class="sc-comment"># This is the fetch/execute cycle loop that continues until run is False</span></span>&#13;
<span>    MAR    = PC                  <span class="sc-comment"># FETCH PC to mem Address Register</span></span>&#13;
<span>    pcOld  = PC                  <span class="sc-comment"># Keep a copy of the PC for display</span></span>&#13;
<span>    PC     = PC + 1              <span class="sc-comment"># Increment PC</span></span>&#13;
<span>    MBR    = mem[MAR]            <span class="sc-comment"># Read the instruction, copy it </span><span class="sc-comment">to the mem Buffer Register</span></span>&#13;
<span>    IR     = MBR                 <span class="sc-comment"># Copy instruction to Instruction Register – prior to decoding it</span></span>&#13;
<span>    OpCode = (IR &gt;&gt; 7) &amp; 0x7     <span class="sc-comment"># Extract Op-Code from </span><span class="sc-comment">instruction bits 7 to 10 by shifting masking</span></span>&#13;
<span>    Dir    = (IR &gt;&gt; 6) &amp; 1       <span class="sc-comment"># Extract data direction </span><span class="sc-comment">from instruction (0 = read, 1 = write)</span></span>&#13;
<span>    Mode   = (IR &gt;&gt; 5) &amp; 1       <span class="sc-comment"># Extract address mode from </span><span class="sc-comment">instruction (0 = literal, 1 = mem)</span></span>&#13;
<span>    Lit     = IR &amp; 0x1F          <span class="sc-comment"># Extract literal/address </span><span class="sc-comment">field (0 = address, 1= literal)</span></span>&#13;
<span class="sc-grey" lang="en-GB">                             <span class="sc-comment"># EXECUTE The EXECUTE block is an if statement, one for each opcode</span></span>&#13;
<span class="sc-grey" lang="en-GB">    if OpCode == 0:          <span class="sc-comment"># Test for LDA and STA (Dir is 0 </span><span class="sc-comment">for load acc and 1 for store in mem)</span></span>&#13;
<span class="sc-grey" lang="en-GB">        if Dir == 0:             <span class="sc-comment"># If Direction is 0, then it's </span><span class="sc-comment">a load accumulator, LDA</span></span>&#13;
<span class="sc-grey" lang="en-GB">            if Mode == 0:        <span class="sc-comment">#</span> <span class="sc-comment">Test for Mode bit to </span><span class="sc-comment">select literal or direct mem operand</span></span>&#13;
<span class="sc-grey" lang="en-GB">                Acc = Lit        <span class="sc-comment">#</span> <span class="sc-comment">If mode is 0, then the </span><span class="sc-comment">accumulator is loaded with L</span></span>&#13;
<span class="sc-grey" lang="en-GB">            else:                <span class="sc-comment"># If mode is 1, then read mem to get </span><span class="sc-comment">operand</span></span>&#13;
<span class="sc-grey" lang="en-GB">                MAR = Lit        <span class="sc-comment"># Literal (address) to MAR</span></span>&#13;
<span class="sc-grey" lang="en-GB">                MBR = mem[MAR]   <span class="sc-comment"># Do a read to get </span><span class="sc-comment">operand in MBR</span></span>&#13;
<span class="sc-grey" lang="en-GB">                Acc = MBR        <span class="sc-comment"># and send it to the </span><span class="sc-comment">accumulator</span></span>&#13;
<span class="sc-grey" lang="en-GB">        else:</span>&#13;
<span class="sc-grey" lang="en-GB">            MAR = Lit            <span class="sc-comment"># If Direction is 1, then </span><span class="sc-comment">it's a store accumulator</span></span>&#13;
<span class="sc-grey" lang="en-GB">            MBR = Acc            <span class="sc-comment"># Copy accumulator to MBR</span></span>&#13;
<span class="sc-grey" lang="en-GB">            mem[MAR] = MBR       <span class="sc-comment"># and write MBR to mem</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif OpCode == 1:              <span class="sc-comment"># Test for ADD to accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if Mode == 0:              <span class="sc-comment"># Test for literal or direct </span><span class="sc-comment">mem operand</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            total = Acc + Lit      <span class="sc-comment"># If mode is 0, then </span><span class="sc-comment">it's a literal operand</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            if total == 0: z = 1   <span class="sc-comment"># Deal with z flag</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            <span class="sc-comment">else: z = 0</span></span>&#13;
<span class="sc-grey" lang="en-GB">        else:                      <span class="sc-comment"># If mode is 1, then it's a direct mem access</span></span>&#13;
<span class="sc-grey" lang="en-GB">            MAR = Lit              <span class="sc-comment"># Literal (address) to MAR</span></span>&#13;
<span class="sc-grey" lang="en-GB">            MBR = mem[MAR]         <span class="sc-comment"># Do a read to get operand </span><span class="sc-comment">in MBR</span></span>&#13;
<span class="sc-grey" lang="en-GB">            total = MBR + Acc      <span class="sc-comment"># And send it to the </span><span class="sc-comment">accumulator</span></span>&#13;
<span class="sc-grey" lang="en-GB">        if Dir == 0: Acc = total   <span class="sc-comment"># Test for destination </span><span class="sc-comment">(accumulator)</span></span>&#13;
<span class="sc-grey" lang="en-GB">        else: mem[MAR] = total     <span class="sc-comment"># Or mem</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif OpCode == 2:              <span class="sc-comment"># Test for SUB from accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if Mode == 0:              <span class="sc-comment"># Test for literal or direct mem operand</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            total = Acc – Lit      <span class="sc-comment"># If mode is 0 then it's </span><span class="sc-comment">a literal operand</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        else:                      <span class="sc-comment"># If mode is 1 then it's a direct mem access</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            MAR = Lit              <span class="sc-comment">#</span> <span class="sc-comment">Literal (address) to MAR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            MBR = mem[MAR]         <span class="sc-comment"># Do a read to get operand </span><span class="sc-comment">in MBR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">            total = Lit – MBR      <span class="sc-comment"># and send it to the </span><span class="sc-comment">accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if total == 0: z = 1       <span class="sc-comment"># Now update z bit (in </span><span class="sc-comment">all cases)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if Dir == 0: Acc = total   <span class="sc-comment"># Test for destination </span><span class="sc-comment">(accumulator)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        else: mem[MAR] = total     <span class="sc-comment"># Or mem</span></span></pre>&#13;
			<p lang="en-GB">The following block (dark shading) implements a clear operation. This instruction is not strictly necessary, because you can always load a zero or subtract x from X. For this reason, some computers do not incorporate a clear instruction. Some computers allow you to write <strong class="source-inline">CLR</strong> <a id="_idIndexMarker517"/>and then substitute an operation such as <span class="No-Break"><strong class="source-inline">SUB X,X</strong></span><span class="No-Break">:</span></p>&#13;
			<pre><span class="sc-top" lang="en-GB">    elif OpCode == 3:              <span class="sc-comment"># Test for CLR (clear Accumulator </span><span class="sc-comment">or clear mem location)</span></span>&#13;
<span class="sc-top" lang="en-GB">        if Mode == 0:              <span class="sc-comment"># If Mode = 0 Then clear </span><span class="sc-comment">accumulator</span></span>&#13;
<span class="sc-top" lang="en-GB">            Acc = 0</span>&#13;
<span class="sc-top" lang="en-GB">        else:</span>&#13;
<span class="sc-top" lang="en-GB">            MAR = Lit              <span class="sc-comment"># If Mode = 1</span></span>&#13;
<span class="sc-top" lang="en-GB">            mem[MAR] = 0           <span class="sc-comment"># Then clear mem location </span><span class="sc-comment">mem[Literal]</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif OpCode == 4:              <span class="sc-comment"># Test for BRA Branch </span><span class="sc-comment">unconditionally</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        PC = Lit - 1          <span class="sc-comment"># Calculate new branch target </span><span class="sc-comment">address (-1 because PC auto increment)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif OpCode == 5:              <span class="sc-comment"># Test for BEQ Branch on zero</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if z == 1: PC = Lit - 1    <span class="sc-comment"># If z bit = 1 then </span><span class="sc-comment">calculate new branch target address</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif OpCode == 6:              <span class="sc-comment"># Test for BNE Branch on not zero</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        if z == 0: PC = Lit - 1    <span class="sc-comment"># If z bit = 0 </span><span class="sc-comment">calculate new branch target address</span></span>&#13;
<span class="sc-grey" lang="en-GB">    elif OpCode == 7:               <span class="sc-comment"># Test for STOP</span></span>&#13;
<span class="sc-grey" lang="en-GB">        run = False                 <span class="sc-comment"># If STOP then clear run flag to </span><span class="sc-comment">exit while loop and stop</span></span></pre>&#13;
			<p lang="en-GB">You could argue <a id="_idIndexMarker518"/>that we should have inserted a break or exit here because if we haven’t encountered a valid op-code by the end of the <strong class="source-inline">execute</strong> loop, the source code must <span class="No-Break">be invalid:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># End of main fetch-execute loop</span></span>&#13;
<span>    mnemon = mnemonics.get(OpCode)  <span class="sc-comment"># Get the mnemonic for </span><span class="sc-comment">printing</span></span>&#13;
<span>    print('PC',pcOld, 'Op ',OpCode, 'Mode = ', Mode, 'Dir = ',Dir, \</span>&#13;
<span>          'mem', mem[16:19], 'z',z, 'Acc', Acc, mnemon)</span></pre>&#13;
			<p lang="en-GB">We now run this program. The output when running this program is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>PC 0  OpCode  0 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 4  LDA/STR</span>&#13;
<span>PC 1  OpCode  1 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 9  ADD</span>&#13;
<span>PC 2  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 9]  z 0 Acc 9  LDA/STR</span>&#13;
<span>PC 3  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  SUB</span>&#13;
<span>PC 4  OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  BEQ</span>&#13;
<span>PC 5  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 18 LDA/STR</span>&#13;
<span>PC 6  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 18] z 0 Acc 18 LDA/STR</span>&#13;
<span>PC 7  OpCode  3 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 0  CLR</span>&#13;
<span>PC 8  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 2  LDA/STR</span>&#13;
<span>PC 9  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  SUB</span>&#13;
<span>PC 10 OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  BEQ</span>&#13;
<span>PC 12 OpCode  7 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  STOP</span></pre>&#13;
			<h2 id="_idParaDest-138" lang="en-GB"><a id="_idTextAnchor144"/>Enhancing the TC2 Simulator</h2>&#13;
			<p lang="en-GB">The simple example of an accumulator-based machine illustrates several aspects of the implementation of instructions, the design of the instruction set, and the allocation of bits. The TC2 has <a id="_idIndexMarker519"/>a 3-bit opcode giving us eight operations. Or <span class="No-Break">does it?</span></p>&#13;
			<p lang="en-GB">The direction bit, Dir, is employed only by the <strong class="source-inline">LDA</strong>/<strong class="source-inline">STA</strong> instruction. If we removed this bit from the opcode field, we would have a 4-bit opcode giving 16 instructions. Since <strong class="source-inline">LDA</strong> and <strong class="source-inline">STA</strong> would now be separate instructions, our eight-instruction computer would have nine instructions, leaving 16 – 9 = 7 new (i.e., unallocated) opcodes. We could have also used the direction flag with <strong class="source-inline">ADD</strong> and <strong class="source-inline">SUB</strong> instructions allowing the destination to be either the accumulator or memory. Consider the following example. The current TC2 simulator can increment variables <em class="italic">x</em> and <em class="italic">y</em> using the <span class="No-Break">following code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      LDA  x</span>&#13;
<span>      ADD  #1</span>&#13;
<span>      STA  x</span>&#13;
<span>      LDA  y</span>&#13;
<span>      ADD  #1</span>&#13;
<span>      STA  y</span></pre>&#13;
			<p lang="en-GB">By extending the addition operation (<strong class="source-inline">ADDA </strong>to add to the accumulator and <strong class="source-inline">ADDM</strong> to add to memory), we can now write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      LDAA #1   <span class="sc-comment">; Load accumulator with 1</span></span>&#13;
<span>      ADDM x    <span class="sc-comment">; Add accumulator to memory location x</span></span>&#13;
<span>      ADDM y    <span class="sc-comment">; Add accumulator to memory location y</span></span></pre>&#13;
			<p lang="en-GB">This enhancement <a id="_idIndexMarker520"/>halves the number of instructions, because we load the accumulator with the literal once and then add it to two different memory locations. The new code for the <strong class="source-inline">ADD</strong> operation is <span class="No-Break">as follows:</span></p>&#13;
			<pre><span class="sc-top" lang="en-GB"> if OpCode == 1:                 <span class="sc-comment"># Test for ADDA or ADDM instruction</span></span>&#13;
<span class="sc-top" lang="en-GB">    if Dir == 0:                 <span class="sc-comment"># Test for add to accumulator (Dir=0) or add to memory (Dir =1)</span></span>&#13;
<span class="sc-top" lang="en-GB">       if Mode == 0:             <span class="sc-comment"># Test for ADDA literal or direct </span><span class="sc-comment">memory operand</span></span>&#13;
<span class="sc-top" lang="en-GB">          Acc = Acc + Lit        <span class="sc-comment"># If mode is 0, then it's </span><span class="sc-comment">a literal operand</span></span>&#13;
<span class="sc-top" lang="en-GB">       else:                     <span class="sc-comment"># If mode is 1, then it's a direct </span><span class="sc-comment">memory access</span></span>&#13;
<span class="sc-top" lang="en-GB">          MAR = Lit              <span class="sc-comment"># Literal (address) to MAR</span></span>&#13;
<span class="sc-top" lang="en-GB">          MBR = Memory[MAR]      <span class="sc-comment"># Do a read to get operand </span><span class="sc-comment">in MBR</span></span>&#13;
<span class="sc-top" lang="en-GB">          Acc = MBR + Acc        <span class="sc-comment"># and send it to the </span><span class="sc-comment">accumulator</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    if Dir == 1:                 <span class="sc-comment">#</span> <span class="sc-comment">ADDM: add to memory version of ADD</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       MAR = Lit                 <span class="sc-comment">#</span> <span class="sc-comment">Set up the memory address</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       MBR = Memory[MAR]         <span class="sc-comment">#</span> <span class="sc-comment">Read memory contents</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       MBR = MBR + Acc           <span class="sc-comment">#</span> <span class="sc-comment">Add accumulator to memory</span></span>&#13;
<span class="sc-bottom" lang="en-GB">       Memory[MAR] = MBR         <span class="sc-comment">#</span> <span class="sc-comment">And write back the result</span></span></pre>&#13;
			<p lang="en-GB">What else can we do to extend the instruction set? We allocated <em class="italic">three</em> opcodes to the branch group. That was <a id="_idIndexMarker521"/>very wasteful. Since each of these branch instructions has a direction and a mode bit that is unused, we can press these bits into service (i.e., redefine their meaning). Consider the arrangement of <span class="No-Break"><em class="italic">Table 8.3</em></span><span class="No-Break">:</span></p>&#13;
			<table id="table002-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Operation</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Direction</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break CharOverride-1">Mode</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BRA</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">0</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">0</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break">Undefined</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">0</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">1</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BEQ</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">1</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">0</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BNE</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">1</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-3">1</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption">Table 8.3 – Re-purposing the direction and mode bits</p>&#13;
			<p lang="en-GB">We have used the <strong class="source-inline">Dir</strong> and <strong class="source-inline">Mode</strong> instruction bits to select the branch type. As a bonus, we have a spare operation that is marked <em class="italic">undefined</em>. The code for the branch group is as follows. We’ve used shading to help identify the blocks. Note that in this example, we demonstrate how branches can be made program <span class="No-Break">counter relative:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if OpCode == 3:                                <span class="sc-comment"># Test for the branch group</span></span>&#13;
<span>   if Dir == 0:                                <span class="sc-comment"># Direction 0 for unconditional</span></span>&#13;
<span>      if Mode == 0: PC = PC + Lit - 1          <span class="sc-comment"># If Mode is </span><span class="sc-comment">zero then unconditional branch</span></span>&#13;
<span>      else: run = 0                            <span class="sc-comment"># If Mode is 1 then this is </span><span class="sc-comment">undefined so stop</span></span>&#13;
<span>   else:</span>&#13;
<span>      if Dir == 1:                             <span class="sc-comment"># If direction is 1, it's a </span><span class="sc-comment">conditional branch</span></span>&#13;
<span>         if Mode == 0:                         <span class="sc-comment"># If mode is 0 then we have a BNE</span></span>&#13;
<span>            if Z == 0: PC = PC + Lit - 1       <span class="sc-comment"># Branch on </span><span class="sc-comment">Z = 0 (not zero)</span></span>&#13;
<span>         else:                                 <span class="sc-comment"># If Mode is 1 we have a BEQ</span></span>&#13;
<span>            if Z == 1: PC = PC + Lit - 1       <span class="sc-comment"># Branch on </span><span class="sc-comment">Z = 1 (zero)</span></span></pre>&#13;
			<p lang="en-GB">This code looks <a id="_idIndexMarker522"/>a little more complex than it is, because we have <strong class="source-inline">if</strong> statements nested four deep when we test for op-code, direction, mode, and then Z-bit. However, this example demonstrates how instruction bits can be reused to increase the number of instructions at the cost of <span class="No-Break">decoding complexity.</span></p>&#13;
			<p lang="en-GB">There’s still room to maneuver and squeeze more functionality out of the instruction set. Look at the <strong class="source-inline">CLR</strong> instruction. We use the mode bit to clear memory or the accumulator. How about being a little creative and using the <em class="italic">direction</em> bit to provide another operation? Incrementing a register or memory is a common operation, so let’s provide that. We can use <strong class="source-inline">Dir == 0</strong> for <strong class="source-inline">CLR</strong> and <strong class="source-inline">Dir == 1</strong> for <strong class="source-inline">INC</strong> Memory/accumulator. The block shaded in gray is the original clear and the block shaded in blue is the new <span class="No-Break">increment operation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if OpCode == 6:                    <span class="sc-comment"># Test for clear mem/Acc or increment mem/Acc</span></span>&#13;
<span>    if Dir == 0:                   <span class="sc-comment"># Direction = 0 for clear operation</span></span>&#13;
<span>        if Mode == 0:              <span class="sc-comment"># If Mode = 0</span></span>&#13;
<span>           Acc = 0                 <span class="sc-comment"># Then clear accumulator</span></span>&#13;
<span>        else:</span>&#13;
<span>           MAR = Lit               <span class="sc-comment"># If Mode = 1</span></span>&#13;
<span>           Memory[MAR] = 0         <span class="sc-comment"># Then clear memory location</span></span>&#13;
<span>    else:                          <span class="sc-comment"># Direction = 1 for increment</span></span>&#13;
<span class="sc-grey" lang="en-GB">        if Mode == 0:              <span class="sc-comment"># If Mode = 0</span></span>&#13;
<span class="sc-grey" lang="en-GB">           Acc = Acc + 1           <span class="sc-comment"># Then increment accumulator</span></span>&#13;
<span class="sc-grey" lang="en-GB">        else:</span>&#13;
<span class="sc-grey" lang="en-GB">           MAR = Lit               <span class="sc-comment"># If Mode = 1</span></span>&#13;
<span class="sc-grey" lang="en-GB">           MBR = Memory[MAR]       <span class="sc-comment"># Then increment memory </span><span class="sc-comment">location</span></span>&#13;
<span class="sc-grey" lang="en-GB">           MBR = MBR + 1           <span class="sc-comment"># Increment memory in MBR</span></span>&#13;
<span class="sc-grey">           Memory[MAR] = MBR       <span class="sc-comment"># Write back incremented </span><span class="sc-comment">memory value</span></span></pre>&#13;
			<p lang="en-GB">Finally, consider <a id="_idIndexMarker523"/>the <strong class="source-inline">STOP</strong> (halt) instruction with the <strong class="source-inline">111DMLLLLL</strong> opcode. Here, we have 7 bits doing nothing. That is 2<span class="superscript">7</span> = 128 combinations. If we were to reserve one code for halt, say, <strong class="source-inline">1110000000</strong>, we could allocate codes 1110000001 to <strong class="source-inline">1111111111</strong> to new instructions. The next section extends this architecture to create a more <span class="No-Break">realistic simulator.</span></p>&#13;
			<h1 id="_idParaDest-139" lang="en-GB"><a id="_idTextAnchor145"/>TC3: A CISC machine with a register-to-memory architecture</h1>&#13;
			<p lang="en-GB">In this <a id="_idIndexMarker524"/>section, you will learn about the design of a simulator that implements a CISC-style instruction set architecture, providing both register-to-register and register-to-memory operations. TC3 is a more sophisticated version of TC2 with a more <span class="No-Break">practical architecture.</span></p>&#13;
			<p lang="en-GB">TC3 supports register direct, register indirect, memory direct, and literal addressing modes. For example, <strong class="source-inline">AND [R2], #129</strong> performs a logical <strong class="source-inline">AND</strong> between the contents of the memory location pointed at by register <strong class="source-inline">R2</strong> and the binary <span class="No-Break">value </span><span class="No-Break"><strong class="source-inline">10000001</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We have included memory direct operations. These are intended to illustrate the features of a computer, rather than being practical. Early 8-bit microprocessors like the Motorola 6800 let you operate on memory directly. Most modern processors don’t. TC3 can access, say, memory at location 12 with <strong class="source-inline">MOV</strong> <span class="pcode-bold">R2</span>,<strong class="source-inline">M:12</strong>. This instruction loads register 2 with the contents of memory location 12. Note the syntax. A TC3 instruction provides a <a id="_idIndexMarker525"/>single literal field that can serve as a literal or a memory address, but not both at the same time. I’ve used <strong class="source-inline">#</strong> to indicate a literal and <strong class="source-inline">M:</strong> to indicate a memory address; consider <strong class="source-inline">MOV </strong><span class="pcode-bold">R2</span>,<strong class="source-inline">M:12</strong> and <strong class="source-inline">MOV </strong><span class="pcode-bold">R2</span>,<strong class="source-inline">#12</strong>. The former loads register <strong class="source-inline">R2</strong> with the contents of memory location <strong class="source-inline">12</strong>, and the latter loads <strong class="source-inline">R2</strong> with the integer <strong class="source-inline">12</strong>. With a single literal field in the instruction, TC3 can’t support an instruction like <span class="No-Break"><strong class="source-inline">MOV M:12,#127.</strong></span></p>&#13;
			<h2 id="_idParaDest-140" lang="en-GB"><a id="_idTextAnchor146"/>The TC3 instruction set architecture</h2>&#13;
			<p lang="en-GB">The TC3 simulator is a one-and-a-half address CISC processor with a 24-bit instruction and an 8-bit data word length. This makes it a Harvard machine, because it has separate data and <a id="_idIndexMarker526"/>program memory. We have taken this approach for two reasons. First, an 8-bit data word is easy to work with from an educational point of view. Second, a 24-bit instruction provides functionality, without either using a large 32-bit word or employing variable-length instructions like some <span class="No-Break">CISC processors.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em> describes the TC3’s instruction format, which has an instruction class and an op-code field, an addressing mode field, two register fields, and a literal field. The format is the same for <span class="No-Break">all instructions.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer051" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_8.4_B19624.jpg" alt="Figure 8.4 – Instruction format of the TC3" width="1282" height="282"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 8.4 – Instruction format of the TC3</p>&#13;
			<p lang="en-GB">We use 8-bit registers, an 8-bit address, and an 8-bit literal to simplify the design. The data space is restricted to 2<span class="superscript">8</span> = 256 locations, since the literal can access only 256 locations. Changing the instruction width to 32 bits and expanding the literal to 16 bits would provide a data space of <span class="No-Break">65,536 locations.</span></p>&#13;
			<p lang="en-GB">The TC3 has eight general-purpose registers, <strong class="source-inline">R0</strong> to <strong class="source-inline">R7</strong>. It requires 6 bits to provide source and destination register fields The instruction field is 6 bits wide and is divided into a 2-bit instruction-class field and a 4-bit op-code field. This allows up to 64 instructions with a maximum of 16 in each class. We took this approach (instruction class and op-code) to simplify the design. This is a rather inefficient approach in terms of instruction-space usage, because most instructions fall within one class and other classes are <span class="No-Break">nearly empty.</span></p>&#13;
			<p lang="en-GB">The 4-bit mode field defines an instruction’s attributes (e.g., addressing modes). The TC3 supports the <a id="_idIndexMarker527"/>addressing modes defined by <em class="italic">Table 8.4</em>, that is, no-operand instructions, one-register instructions, instructions with a literal, and two-operand instructions. Although the TC3 supports only two operands (register + register and register + literal), there are three fields in the instruction. Consequently, the computer could be easily modified to provide three-operand instructions. We chose this approach to simplify instruction encoding and decoding. An alternative approach would be to provide two operand fields – a register field and a register or <span class="No-Break">literal field:</span></p>&#13;
			<table id="table003-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Mode</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Address</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Example</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">RTL</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Class</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">0</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break">No operand</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STOP</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">1</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break">Single register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">INC R1</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[R1]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[R1] + 1</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">1</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">2</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break">Literal offset</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BEQ 123</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[pc]</strong> <span class="CharOverride-2">←</span> <span class="No-Break"><strong class="source-inline">123</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">2</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">3</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break">Reserved</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">4</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Literal <span class="No-Break">to register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV R1,#M</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[R1]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">M</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">5</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register <span class="No-Break">to register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV R1,R2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[R1]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">6</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect <span class="No-Break">to register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV R1,[R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[R1]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[[</strong><span class="No-Break"><strong class="source-inline">R2]]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">7</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register to <span class="No-Break">register indirect</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV [R1],R2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[[R1]]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">8</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect to <span class="No-Break">register indirect</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV [R1],[R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[[R1]]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[[</strong><span class="No-Break"><strong class="source-inline">R2]]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">9</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register <span class="No-Break">to memory</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV M:123,R2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">M[123] ← [</strong><span class="No-Break"><strong class="source-inline">R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">10</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Register indirect <span class="No-Break">to memory</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-2" lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV M:123,[R2]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">M[123]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[[</strong><span class="No-Break"><strong class="source-inline">R2]]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">11</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Memory <span class="No-Break">to register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV R1,M:123</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[R1]</strong> <span class="CharOverride-2">←</span> <span class="No-Break"><strong class="source-inline">M[123]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">12</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB">Memory to <span class="No-Break">register indirect</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-2" lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV [R1],M:123</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="source-inline">[[R1]]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">M[123] </strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">13-15</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-6">Reserved</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
						<td class="No-Table-Style CellOverride-2"/>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption">Table 8.4 – TC3 processor addressing modes</p>&#13;
			<p lang="en-GB">Consider the following assembly language program that runs on this computer. We wish to add together two vectors plus an integer, that is, <em class="italic">z</em><span class="subscript">i = x</span><span class="subscript">i + yi + 5</span> for <em class="italic">i</em> = 0 to 3. The following code <a id="_idIndexMarker528"/>should be largely self-explanatory. Literals are prefixed with #, and a label in an instruction is terminated with a colon. The first part of the code uses the <strong class="source-inline">RND R5</strong> instruction to fill vectors <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong> with random numbers to <span class="No-Break">aid testing.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      Code          <span class="sc-comment">@ Comment</span><span class="sc-comment CharOverride-7">                        </span><span class="sc-comment">Instruction encoding</span></span>&#13;
<span>      MOV  R0,#     <span class="sc-comment">@ Point to memory location 8</span></span>&#13;
<span>Next: RND  R5       <span class="sc-comment">@ REPEAT: generate random value in r5</span></span>&#13;
<span>      MOV  [R0],R5  <span class="sc-comment">@ store r5 at location pointed at by r0</span></span>&#13;
<span>      DEC  R0       <span class="sc-comment">@ decrement r0 pointer</span></span>&#13;
<span>      BNE  Next     <span class="sc-comment">@ UNTIL zero</span></span>&#13;
<span>      EQU  X,#1     <span class="sc-comment">@ Vector X memory 1 to 4</span></span>&#13;
<span>      EQU  Y,#5     <span class="sc-comment">@ Vector Y memory 5 to 8</span></span>&#13;
<span>      EQU  Z,#9     <span class="sc-comment">@ Vector Z memory 9 to 12</span></span>&#13;
<span>      MOV  R0,#X    <span class="sc-comment">@ r0 points to array X</span><span class="sc-comment CharOverride-7">              </span><span class="sc-comment"> </span><span class="sc-comment CharOverride-7"> </span><span class="sc-comment"> </span><span class="sc-comment CharOverride-7">  </span><span class="sc-comment"> 00 0000 0010 000 000 00000001</span></span>&#13;
<span>      MOV  R1,#Y    <span class="sc-comment">@ r1 points to array Y</span><span class="sc-comment CharOverride-7">   </span><span class="sc-comment CharOverride-7">               </span><span class="sc-comment"> 00 0000 0010 001 000 00000101</span></span>&#13;
<span>      MOV  R2,#Z    <span class="sc-comment">@ r2 points to array Z</span><span class="sc-comment CharOverride-7">               </span><span class="sc-comment">  </span><span class="sc-comment CharOverride-7"> </span><span class="sc-comment">    00 0000 0010 010 000 00001001</span></span>&#13;
<span>      MOV  R3,#4    <span class="sc-comment">@ r3 number of elements to add in r3</span><span class="sc-comment CharOverride-7">       </span><span class="sc-comment"> 00 0000 0010 011 000 00000100</span></span>&#13;
<span>Loop: MOV  R4,[R0]  <span class="sc-comment">@ Get xi</span><span class="sc-comment CharOverride-7">                        </span><span class="sc-comment"> </span><span class="sc-comment CharOverride-7">  </span><span class="sc-comment"> 00 0000 0000 100 000 00000000</span></span>&#13;
<span>      ADD  R4,#5    <span class="sc-comment">@ Add 5 to xi</span><span class="sc-comment CharOverride-7">                      </span><span class="sc-comment"> </span><span class="sc-comment CharOverride-7"> </span><span class="sc-comment"> 00 0001 0010 100 000 00000101</span></span>&#13;
<span>      ADD  R4,[R1]  <span class="sc-comment">@ Add xi + 5 to yi Memory to reg operation</span><span class="sc-comment CharOverride-7">   </span><span class="sc-comment"> 00 0001 0001 100 001 00000000</span></span>&#13;
<span>      MOV  [R2],R4  <span class="sc-comment">@ Store result in array Z</span><span class="sc-comment CharOverride-7">                </span><span class="sc-comment"> 00 0000 0100 010 100 00000000</span></span>&#13;
<span>      INC  R0       <span class="sc-comment">@ Increment pointer to array X</span><span class="sc-comment CharOverride-7">           </span><span class="sc-comment">  00 1100 0000 000 000 00000000</span></span>&#13;
<span>      INC  R1       <span class="sc-comment">@ Increment pointer to array Y</span><span class="sc-comment CharOverride-7">          </span><span class="sc-comment">     00 1100 0000 001 000 00000000</span></span>&#13;
<span>      INC  R2       <span class="sc-comment">@ Increment pointer to array Z</span><span class="sc-comment CharOverride-7">           </span><span class="sc-comment">  00 1100 0000 010 000 00000000</span></span>&#13;
<span>      DEC  R3       <span class="sc-comment">@ Decrement loop counter</span><span class="sc-comment CharOverride-7">             </span><span class="sc-comment">   00 1101 0000 011 000 00000000</span></span>&#13;
<span>      BNE  Loop     <span class="sc-comment">@ Continue until counter 0</span><span class="sc-comment CharOverride-7">              </span><span class="sc-comment">01 0011 0000 000 000 00000100</span></span></pre>&#13;
			<p lang="en-GB">This example <a id="_idIndexMarker529"/>uses literal, register direct, and register indirect (pointer-based) addressing. We have provided the binary code of each instruction with the class, op-code, addressing mode, registers, and <span class="No-Break">literal fields.</span></p>&#13;
			<p lang="en-GB">Initially, we didn’t construct an assembler for this simulator. However, it was such a pain to hand-code the instructions that an assembler was incorporated. The key to both the assembler and simulator is the <strong class="source-inline">mode</strong> field of the instruction, which indicates the <span class="No-Break">addressing mode.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When an instruction in mnemonic form is read, it is examined, and its addressing modes and operands are used to determine the four mode bits required by the instruction. The reverse action is carried out when the instruction is executed, and the mode bits are used to implement the appropriate addressing modes. For example, if the instruction is <strong class="source-inline">LDR </strong><strong class="source-inline">R6,#5</strong>, the mode is <strong class="source-inline">4</strong> and the assembler stores <strong class="source-inline">6</strong> in the first register field and <strong class="source-inline">5</strong> in the literal field. When the instruction is executed, the simulator uses the mode bits, <strong class="source-inline">0100</strong>, to determine that the destination register is <strong class="source-inline">110</strong> and the literal <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">00000101</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The first part of the TC3 simulator is given as follows. We create two lists: one for the program memory and one for the data memory (pMem and dMem). The instructions in program memory are imported from a file. The data memory is set up as 16 locations that are initialized to 0. The text file containing the source program is src and is processed to reformat instructions and remove <span class="No-Break">assembler directives.</span></p>&#13;
			<p lang="en-GB">The shaded <a id="_idIndexMarker530"/>section of the code was added to detect the <strong class="source-inline">'END'</strong> directive in the source code, which terminates the assembly processing and acts as a <strong class="source-inline">STOP</strong> when the code is executed. I added it for convenience. I sometimes want to test one or two instructions but don’t want to write a new source code program. I can put the code under test at the top of an existing program, followed by <strong class="source-inline">END</strong>. All code after <strong class="source-inline">END</strong> is ignored. Later, I can delete the new code <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">END</strong></span><span class="No-Break">.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sTab = {}                             <span class="sc-comment"># Symbol table for equates and labels name:integerValue</span></span>&#13;
<span>pMem = []                             <span class="sc-comment"># Program </span><span class="sc-comment">memory (initially empty)</span></span>&#13;
<span>dMem = [0]*16                         <span class="sc-comment"># Data </span><span class="sc-comment">memory. Initialized and 16 locations</span></span>&#13;
<span>reg  = [0]*8                          <span class="sc-comment"># Register </span><span class="sc-comment">set</span></span>&#13;
<span>z,c,n = 0,0,0                         <span class="sc-comment"># Define </span><span class="sc-comment">and status flags: zero, carry, negative</span></span>&#13;
<span>testCode = "E:\\AwPW\\TC3_NEW_1.txt"  <span class="sc-comment"># Source </span><span class="sc-comment">filename on my computer</span></span>&#13;
<span>with open(testCode) as src:           <span class="sc-comment"># Open the source file containing the assembly program</span></span>&#13;
<span>    lines = src.readlines()           <span class="sc-comment"># Read the </span><span class="sc-comment">program into lines</span></span>&#13;
<span>src = [i[0:-1].lstrip() for i in lines ]</span>&#13;
<span>                                      <span class="sc-comment"># Remove the /n newline from each line of the source code</span></span>&#13;
<span>src = [i.split("<span class="sc-comment">@")[0] for i in src]</span>          <span class="sc-comment"> # Remove </span><span class="sc-comment">comments in the code</span></span>&#13;
<span>src = [i for i in src if i != '']     <span class="sc-comment"># Remove </span><span class="sc-comment">empty lines</span></span>&#13;
<span>for i in range(0,len(src)):           <span class="sc-comment"># Scan </span><span class="sc-comment">source code line-by-line</span></span>&#13;
<span>    src[i] = src[i].replace(',',' ')  <span class="sc-comment"># Replace </span><span class="sc-comment">commas by a space</span></span>&#13;
<span>    src[i] = src[i].upper()           <span class="sc-comment"># Convert </span><span class="sc-comment">to upper-case</span></span>&#13;
<span>    src[i] = src[i].split()           <span class="sc-comment"># Split </span><span class="sc-comment">into tokens (label, mnemonic, operands)</span></span>&#13;
<span class="sc-grey" lang="en-GB">src1 = []                             <span class="sc-comment"># Set up dummy source file, initially empty</span></span>&#13;
<span class="sc-grey" lang="en-GB">for i in range (0,len(src)):          <span class="sc-comment"># Read </span><span class="sc-comment">source and stop on first END instruction</span></span>&#13;
<span class="sc-grey" lang="en-GB">    src1.append(src[i])               <span class="sc-comment"># Append </span><span class="sc-comment">each line to dummy source file</span></span>&#13;
<span class="sc-grey" lang="en-GB">    if src[i][0] == 'END': break      <span class="sc-comment"># Stop on </span><span class="sc-comment">'END' token</span></span>&#13;
<span class="sc-grey" lang="en-GB">src = src1                            <span class="sc-comment"># Copy </span><span class="sc-comment">dummy file to source (having stopped on 'END')</span></span>&#13;
<span class="sc-bottom" lang="en-GB">for i in range (0,len(src)):          <span class="sc-comment"># Deal with equates of the form EQU PQR 25</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    if src[i][0] == 'EQU':            <span class="sc-comment"># If the </span><span class="sc-comment">line is 3 or more tokens and first token is EQU</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        sTab[src[i][1]] = getL(src[i][2])      <span class="sc-comment"># Put token </span><span class="sc-comment">in symbol table as integer</span></span>&#13;
<span class="sc-bottom" lang="en-GB">src = [i for i in src if i.count('EQU') == 0]  <span class="sc-comment"># Remove </span><span class="sc-comment">lines with "EQU" from source code</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The following code takes an instruction in assembly language form, tokenizes it, and converts it into the bit pattern of an instruction. In the following code, we use ic as the instruction counter, which steps through the source program line <span class="No-Break">by line.</span></p>&#13;
			<p lang="en-GB">One issue we <a id="_idIndexMarker531"/>must deal with is the label. Some instructions have one and some don’t. That means that the mnemonic is token <strong class="source-inline">0</strong> for an instruction without a label, and token <strong class="source-inline">1</strong> if there is a label. The Python code checks for a label (which ends in a colon). If a label is found, <strong class="source-inline">j</strong> is set to <strong class="source-inline">1</strong>, and, if not found,<strong class="source-inline"> j</strong> is set to <strong class="source-inline">0</strong>. We then use <strong class="source-inline">j</strong> to calculate the location of tokens in the instruction. The tLen variable is the number of tokens in <span class="No-Break">an instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for ic in range(0,len(src)):           <span class="sc-comment"># ASSEMBLY </span><span class="sc-comment">LOOP (ic = instruction counter)</span></span>&#13;
<span>    t0,t1,t2 = '', '', ''              <span class="sc-comment"># Prepare to assign tokens. Initialize to null string</span></span>&#13;
<span>    if src[ic][0][-1] != ':':          <span class="sc-comment"># If the </span><span class="sc-comment">first token doesn't end in colon, it's an instruction</span></span>&#13;
<span>        j = 0                          <span class="sc-comment"># j = 0 for</span><span class="sc-comment">line starting with mnemonic</span></span>&#13;
<span>    else:                              <span class="sc-comment"># If the </span><span class="sc-comment">first token ends in a colon it's a label</span></span>&#13;
<span>        j = 1                          <span class="sc-comment"># j = 1 if </span><span class="sc-comment">mnemonic is second token</span></span>&#13;
<span>    t0 = src[ic][j]                    <span class="sc-comment"># Set t0 to mnemonic j selects first or second token</span></span>&#13;
<span>    if len(src[ic]) &gt; 1+j: t1 = src[ic][j+1]  <span class="sc-comment"># Set t1 to </span><span class="sc-comment">ingle operand</span></span>&#13;
<span>    if len(src[ic]) &gt; 2+j: t2 = src[ic][j+2]  <span class="sc-comment"># Set t2 to </span><span class="sc-comment">second operand</span></span>&#13;
<span>    tLen = len(src[ic]) - j - 1         <span class="sc-comment"># tLen is </span><span class="sc-comment">the number of tokens (adjusted for any label)</span></span></pre>&#13;
			<p lang="en-GB">The next section <a id="_idIndexMarker532"/>of the assembler does all the work. Here, we generate the binary code. Unlike other simulators we’ve developed, we use directories and lists to detect registers, as the following (partial) <span class="No-Break">code shows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>rName   = {'R0':0,'R1':1,'R2':2,'R3':3}  <span class="sc-comment"># Relate </span><span class="sc-comment">register name to numeric value (lookup table)</span></span>&#13;
<span>rNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3}</span>&#13;
<span>                                         <span class="sc-comment"># Look for register indirect addressing (lookup table)</span></span>&#13;
<span>iClass0 = ['STOP', 'NOP', 'END']         <span class="sc-comment"># Instruction class 00 mnemonic with no operands</span></span>&#13;
<span>iClass1 = ['BRA',  'BEQ', 'BNE','CZN' ]  <span class="sc-comment"># Instruction class 01 mnemonic with literal operand</span></span></pre>&#13;
			<p lang="en-GB">Now, we can take a token and ask whether it’s in <strong class="source-inline">rName</strong> to detect <strong class="source-inline">R0 </strong>to <strong class="source-inline">R7</strong>, or whether it’s in <strong class="source-inline">rNamInd</strong> to detect whether it’s <strong class="source-inline">[R0]</strong> to <strong class="source-inline">[R7]</strong>. Moreover, we can use the mnemonic from an instruction and ask whether it’s in each class in turn in order to determine the two class bits of the instruction; for example, if <strong class="source-inline">t0</strong> is the first token (corresponding to the mnemonic), we can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if t0 in iClass0: mode = 0.</span></pre>&#13;
			<p lang="en-GB">Similarly, we can use if t1 in <strong class="source-inline">rNamInd</strong> to determine whether the second token is a register used as a pointer (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">[R4]</strong></span><span class="No-Break">).</span></p>&#13;
			<p lang="en-GB">The most complex <a id="_idIndexMarker533"/>class of instructions is <strong class="source-inline">iClass3</strong>, which deals with two-operand instructions, such as <strong class="source-inline">ADD [R3],R4</strong>. In this case, token <strong class="source-inline">t0</strong> would be <strong class="source-inline">'ADD'</strong>, token <strong class="source-inline">t1</strong> would be <strong class="source-inline">'</strong><strong class="source-inline">[r3]'</strong>, and token <strong class="source-inline">t2</strong> would be <strong class="source-inline">'R4'</strong>. To identify the class of this instruction, we look for a first operand, which is an indirect register, and a second operand, which is a register, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code"> if (t1 in rNamInd) and (t2 in rName): mode = 7</pre>&#13;
			<p lang="en-GB">The code that determines the mode of an instruction is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binC = 0                                  <span class="sc-comment"># Initialize binary code for this instruction to all zeros</span></span>&#13;
<span>opCode = mnemon[t0]                       <span class="sc-comment"># Look up op-code in table mnemon using token t0</span></span>&#13;
<span>iClass = opCode &gt;&gt; 4                      <span class="sc-comment"># Get two most significant bits of op-code (i.e., class)</span></span>&#13;
<span>if   t0 in iClass0:                       <span class="sc-comment"># If in iClass0 it's a single instruction, no operands</span></span>&#13;
<span>    mode = 0                              <span class="sc-comment"># The mode is 0 for everything in this class</span></span>&#13;
<span>    binC = (mnemon[t0] &lt;&lt; 18)             <span class="sc-comment"># All fields zero except op_code</span></span>&#13;
<span>elif t0 in iClass1:                       <span class="sc-comment"># If in iClass1 it's an 0p-code plus offset (e.g., branch)</span></span>&#13;
<span>    mode = 1                              <span class="sc-comment"># All class 1 instruction are mode 1 (op-code plus literal)</span></span>&#13;
<span>    binC = (mnemon[t0] &lt;&lt; 18)+(mode &lt;&lt; 14)+getL(t1)</span>&#13;
<span>                                          <span class="sc-comment"># Create binary code for Class1 instruction</span></span>&#13;
<span>elif t0 in iClass2:                       <span class="sc-comment"># If in iClass2 it's an op-code plus register number</span></span>&#13;
<span>    mode = 2                              <span class="sc-comment"># All iClass2 instructions are mode 2</span></span>&#13;
<span>    binC = (mnemon[t0] &lt;&lt; 18)+(mode &lt;&lt; 14)+(rName[t1] &lt;&lt; 11</span>&#13;
<span>                                          <span class="sc-comment"># Construct binary code of instruction</span></span>&#13;
<span>elif t0 in iClass3:                       <span class="sc-comment"># All data-processing and movement ops in iClass3</span></span>&#13;
<span>    if   (t1 in rName) and (t2[0] == '#'): <span class="sc-comment"># Look for register name and literal for mode 4</span></span>&#13;
<span>        mode = 4</span>&#13;
<span>    elif (t1 in rName) and (t2 in rName): <span class="sc-comment"># Look for register name and register name for mode 5</span></span>&#13;
<span>        mode = 5</span>&#13;
<span>    elif (t1 in rName) and (t2 in rNamInd):   <span class="sc-comment"># Look for R0,[R2]) format</span></span>&#13;
<span>        mode = 6</span>&#13;
<span>    elif (t1 in rNamInd) and (t2 in rName):   <span class="sc-comment"># Look for instruction format [R1],R2</span></span>&#13;
<span>        mode = 7</span>&#13;
<span>    elif (t1 in rNamInd) and (t2 in rNamInd): <span class="sc-comment"># Look for two register indirect names [R1],[R2]</span></span>&#13;
<span>        mode = 8</span>&#13;
<span>    elif (t1[0:2] == 'M:') and (t2 in rName):</span>&#13;
<span>                                      <span class="sc-comment"># Look for memory address M: and reg name M:12,r4</span></span>&#13;
<span>        mode = 9</span>&#13;
<span>    elif (t1[0:2] == 'M:') and (t2 in rNamInd): <span class="sc-comment"># Look for M:12,[R4] format</span></span>&#13;
<span>        mode = 10</span>&#13;
<span>    elif (t1 in rName) and (t2[0:2] == 'M:'): <span class="sc-comment"># Look for register name and literal prefixed by M:</span></span>&#13;
<span>        mode = 11</span>&#13;
<span>    elif (t1 in rNamInd) and (t2[0:2] == 'M:'):</span>&#13;
<span>                                      <span class="sc-comment"># Look for register indirect name and literal prefixed by M:</span></span>&#13;
<span>        mode = 12</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">After extracting the instruction class, op-code, and mode, the final step is to get the actual register numbers and any literals. In the following fragment of code, we define the two register <a id="_idIndexMarker534"/>fields and the literal field, respectively. These are <strong class="source-inline">rField1</strong>, <strong class="source-inline">rField2</strong>, and <strong class="source-inline">lField</strong> and are all initialized to <strong class="source-inline">0</strong>, because instructions without three fields have the corresponding bits set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Here, we use the list as a very convenient method for extracting fields rather than combined if and or operators. For example, register field <strong class="source-inline">1</strong> is used by modes <strong class="source-inline">4</strong>, <strong class="source-inline">5</strong>, <strong class="source-inline">6</strong>, and <strong class="source-inline">11</strong>. We could write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span> if (mode == 4) or (mode == 5) or (mode == 6) or (mode == 11):</span></pre>&#13;
			<p lang="en-GB">However, we can write instead, which is far easier <span class="No-Break">to read:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span> if mode in [4,5,6,11]:</span></pre>&#13;
			<p lang="en-GB">The following code shows how the three register/literal fields <span class="No-Break">are evaluated:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  <span class="sc-comment"># Insert op_Code and mode fields in instruction</span></span>&#13;
<span>rField1, rField2, lField = 0, 0, 0        <span class="sc-comment"># Calculate register and literal fields. Initialize to zero</span></span>&#13;
<span>if mode in [4,5,6,11]: rField1 = rName[t1] <span class="sc-comment"># Convert </span><span class="sc-comment">register names into register numbers</span></span>&#13;
<span>if mode in [7,8,12]:   rField1 = rNamInd[t1]</span>&#13;
<span>if mode in [5,7,9]:    rField2 = rName[t2] <span class="sc-comment"># rField2 is </span><span class="sc-comment">second register field</span></span>&#13;
<span>if mode in [6,8,10]:   rField2 = rNamInd[t2]</span>&#13;
<span>if mode in [4,11,12]:  lField  = getL(t2)</span>&#13;
<span>                                  <span class="sc-comment"># if (mode==4) or (mode==11) or (mode==12): lField = getL(t2)</span></span>&#13;
<span>if mode in [9,10]:     lField  = getL(t1)</span>&#13;
<span>                                  <span class="sc-comment"># if (mode == 9) or (mode == 10): lField = getL(t1) Literal field</span></span></pre>&#13;
			<p lang="en-GB">The following two <a id="_idIndexMarker535"/>lines of the code-generation logic insert the register/literal fields by shifting and executing OR on bits and append the current binary instruction, binC, to the program <span class="No-Break">memory, pMem:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binC = binC + (rField1 &lt;&lt; 11) + rField2 &lt;&lt; 8) + lField</span>&#13;
<span>                                  <span class="sc-comment"># Binary code with register and literal fields</span></span>&#13;
<span>pMem.append(binC)                 <span class="sc-comment"># Append instruction to program memory</span></span></pre>&#13;
			<h2 id="_idParaDest-141" lang="en-GB"><a id="_idTextAnchor147"/>Features of the simulator</h2>&#13;
			<p lang="en-GB">The simulator <a id="_idIndexMarker536"/>part of TC3 is relatively straightforward. Here, I’ll simply provide a few comments on some of its features to aid in understanding <span class="No-Break">the code.</span></p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">1.	</strong><span class="No-Break"><strong class="bold">Printing data</strong></span></p>&#13;
			<p lang="en-GB">The number of items to be displayed increased during the simulator’s development. So, we created a list of strings, one for each item to be printed, and then concatenated the items. For example, this is the print mechanism I used to display data <span class="No-Break">during assembly:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>### Display assembly details of each instruction for diagnostics</span>&#13;
<span>pcF  = "{0:&lt;20}".format(" ".join(src[ic]))    <span class="sc-comment"># 1. instruction</span></span>&#13;
<span>icF  = 'pc = ' + "{:&lt;3}".format(ic)           <span class="sc-comment"># 2. pc</span></span>&#13;
<span>binF = format(binC, "024b")                   <span class="sc-comment"># 3. Binary encoding</span></span>&#13;
<span>iClF = 'Class = '+ str(iClass)                <span class="sc-comment"># 4. instruction class</span></span>&#13;
<span>modF = 'mode = ' + str(mode)                  <span class="sc-comment"># 5. instruction mode. Convert mode to string</span></span>&#13;
<span>t0F  = "{:&lt;5}".format(t0)                     <span class="sc-comment"># 6. token 0 (mnemonic)</span></span>&#13;
<span>t1F  = "{:&lt;5}".format(t1)                     <span class="sc-comment"># 7. token 1 (register field 1)</span></span>&#13;
<span>t2F  = "{:&lt;10}".format(t2)                    <span class="sc-comment"># 8. token 2 (register field 2 or literal)</span></span>&#13;
<span>print(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F)   <span class="sc-comment"># Print these fields</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">displayLevel</strong> parameter <a id="_idIndexMarker537"/>is included to determine what information was printed during the assembly process. For example, we could write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if displayLevel &gt; 4: print('Binary code =', xyz)</span></pre>&#13;
			<p lang="en-GB">This would print binary code only when debugging is required by setting the variable to <strong class="source-inline">5</strong> <span class="No-Break">or greater.</span></p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">2.	Implementing add </strong><span class="No-Break"><strong class="bold">with carry</strong></span></p>&#13;
			<p lang="en-GB">When I implemented the ALU with its numbered functions, I initially forgot to include <strong class="source-inline">ADC</strong>, add with carry. Rather than renumbering the functions, I converted the <strong class="source-inline">ADD</strong> into a dual <strong class="source-inline">ADD</strong>/<strong class="source-inline">ADC</strong> operation by first performing an addition. Then, if the op-code was an <strong class="source-inline">ADC</strong>, add the <span class="No-Break">carry bit:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>elif fun == 1:                             <span class="sc-comment"># ADD:</span></span>&#13;
<span>        res = (op1 + op2)                  <span class="sc-comment"># Perform </span><span class="sc-comment">addition of operands</span></span>&#13;
<span>        if thisOp == 'ADC': res = res + c  <span class="sc-comment"># If operation </span><span class="sc-comment">ADC then add carry bit</span></span></pre>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">3.	Dealing with simple </strong><span class="No-Break"><strong class="bold">instruction classes</strong></span></p>&#13;
			<p lang="en-GB">Here is the code <a id="_idIndexMarker538"/>used to deal with class 1 instructions. We do not have to worry about decoding the mode as there is only one mode for this class. Of course, the class could be extended (in the future) by the addition of <span class="No-Break">other modes.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>elif opClass == 1:                         <span class="sc-comment"># Class 1 operation instructions </span><span class="sc-comment">with literal operand</span></span>&#13;
<span>    if    thisOp == 'BRA': pc = lit        <span class="sc-comment"># BRA Branch </span><span class="sc-comment">unconditionally PC = L</span></span>&#13;
<span>    elif (thisOp == 'BEQ') and (z == 1): pc = lit    <span class="sc-comment"># BEQ </span><span class="sc-comment">Branch on zero</span></span>&#13;
<span>    elif (thisOp == 'BNE') and (z == 0): pc = lit    <span class="sc-comment"># BNE </span><span class="sc-comment">Branch on not zero</span></span>&#13;
<span>    elif  thisOp == 'CZN':                 <span class="sc-comment"># Set/clear c, z, and </span><span class="sc-comment">n flags</span></span>&#13;
<span>        c = (lit &amp; 0b100) &gt;&gt; 2             <span class="sc-comment"># Bit 2 of literal is c</span></span>&#13;
<span>        z = (lit &amp; 0b010) &gt;&gt; 1             <span class="sc-comment"># Bit 1 of literal </span><span class="sc-comment">is z</span></span>&#13;
<span>        n = (lit &amp; 0b001)                  <span class="sc-comment"># Bit 0 of literal is n</span></span></pre>&#13;
			<p lang="en-GB">Class 1 instructions have an op-code and literal and are generally used to implement branch operations. Notice that we compare the current instruction with a name (e.g., <strong class="source-inline">'BRA'</strong>) rather than an op-code, as we did in other simulators. The use of a table of reverse op-code-to-mnemonic translations makes life <span class="No-Break">much easier.</span></p>&#13;
			<p lang="en-GB">We have added a <strong class="source-inline">CZN</strong> (carry zero negative) instruction, which allows us to preset condition codes; for example, <strong class="source-inline">CZN #%101</strong> sets <strong class="source-inline">c</strong> and <strong class="source-inline">n</strong> to <strong class="source-inline">1</strong>, and <strong class="source-inline">z</strong> to <strong class="source-inline">0</strong>. Computers often have an operation that allows you to test condition codes, clear them, set them, and toggle (<span class="No-Break">flip) them.</span></p>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">4.	</strong><span class="No-Break"><strong class="bold">Handling literals</strong></span></p>&#13;
			<p lang="en-GB">TC3’s numeric values <a id="_idIndexMarker539"/>can be expressed in several formats, for example, binary, where we represent <strong class="source-inline">8</strong> by <strong class="source-inline">%1000</strong>. Literal processing in TC3 must also deal with special formats, such as M:12, which indicates a memory address. The following function performs all the literal processing and handles several formats. It can also deal with literals that are symbolic names that must be looked up in the <span class="No-Break">symbol table:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def getL(lit8):                               <span class="sc-comment"># Convert string to integer</span></span>&#13;
<span>    lit8v = 9999                              <span class="sc-comment"># Dummy default</span></span>&#13;
<span>    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  <span class="sc-comment"># Strip M: prefix from memory literal addresses</span></span>&#13;
<span>    if lit8[0:1]   == '#':  lit8  = lit8[1:]  <span class="sc-comment"># Strip # prefix from literal addresses</span></span>&#13;
<span>    if   type(lit8) == int: lit8v = lit8      <span class="sc-comment"># If integer, return it</span></span>&#13;
<span>    elif lit8.isnumeric():  lit8v = int(lit8) <span class="sc-comment"># If decimal in text form convert to integer</span></span>&#13;
<span>    elif lit8 in sTab:      lit8v = sTab[lit8]       <span class="sc-comment"># If in symbol table, retrieve it</span></span>&#13;
<span>    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  <span class="sc-comment"># If binary string convert to int</span></span>&#13;
<span>    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) <span class="sc-comment"># If hex string convert it to int</span></span>&#13;
<span>    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) &amp; 0xFF</span>&#13;
<span>                                               <span class="sc-comment"># If decimal negative convert to signed int</span></span>&#13;
<span>    return(lit8v)                              <span class="sc-comment"># Return integer corresponding to text string</span></span></pre>&#13;
			<p class="ParaOverride-3" lang="en-GB"><strong class="bold">5.	</strong><span class="No-Break"><strong class="bold">Result Writeback</strong></span></p>&#13;
			<p lang="en-GB">After performing an ALU operation or a data movement, the resulting operand must be written back into the computer. However, because we have specified a two-operand CISC-style format, the result of a calculation can be written to a register (like any RISC operation), it can be <a id="_idIndexMarker540"/>written to a memory location pointed at by a register, or it can be written to a memory operation specified by its address. The following fragment of code demonstrates <span class="No-Break">TC3’s writeback:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>op3 = alu(fun,op1,op2)                          <span class="sc-comment"># Call ALU to perform the </span><span class="sc-comment">function</span></span>&#13;
<span>if mode in [4,5,6,11]: reg[reg1] = op3          <span class="sc-comment"># Writeback ALU </span><span class="sc-comment">result in op3 to a register</span></span>&#13;
<span>elif mode in [7,8,12]: dMem[reg[reg1]] = op3    <span class="sc-comment"># Writeback result to mem pointed at by reg</span></span>&#13;
<span>elif mode in [9,10]:   dMem[lit]       = op3    <span class="sc-comment"># Writeback result to memory</span></span></pre>&#13;
			<h3 lang="en-GB">Sample output</h3>&#13;
			<p lang="en-GB">The following is a <a id="_idIndexMarker541"/>sample of the output from the simulator that demonstrates integer handling. We have written a program with six different ways of inputting a literal. In each case, we load the literal into register <strong class="source-inline">r0</strong>. The source program is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span> EQU www,#42</span>&#13;
<span> MOV r0,#12</span>&#13;
<span> MOV r0,#%11010</span>&#13;
<span> MOV r0,#0xAF</span>&#13;
<span> MOV r0,#-5</span>&#13;
<span> MOV r0,M:7</span>&#13;
<span> MOV r0,#www</span>&#13;
<span> NOP</span>&#13;
<span> STOP</span>&#13;
<span> END</span></pre>&#13;
			<p lang="en-GB">In the following code block, we have the output of TC3. This output has been designed for the purpose <a id="_idIndexMarker542"/>of developing and testing the simulator (for example, following the <span class="No-Break">assembly process):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Source code                     This is the tokenized source code</span>&#13;
<span>['MOV', 'R0', '#12']</span>&#13;
<span>['MOV', 'R0', '#%11010']</span>&#13;
<span>['MOV', 'R0', '#0XAF']</span>&#13;
<span>['MOV', 'R0', '#-5']</span>&#13;
<span>['MOV', 'R0', 'M:7']</span>&#13;
<span>['MOV', 'R0', '#WWW']</span>&#13;
<span>['NOP']</span>&#13;
<span>['STOP']</span>&#13;
<span>['END']</span>&#13;
<span>Equate and branch table          This is the symbol table. Only one entry</span>&#13;
<span>WWW      42</span></pre>&#13;
			<p lang="en-GB">The following is <a id="_idIndexMarker543"/>the output during the assembly and <span class="No-Break">analysis phase:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Assembly loop</span>&#13;
<span>MOV R0 #12     pc=0 110000010000000000001100 Class=3 mode=4 MOV  <span class="sc-comment"> </span>t1=R0 #12</span>&#13;
<span>MOV R0 #%11010 <span class="sc-comment">  </span>pc=1 1110000010000000000011010 <span class="sc-comment">  </span>Class=3 <span class="sc-comment"> </span>mode=4 <span class="sc-comment">  </span>MOV  <span class="sc-comment"> </span>t1=R0 #%11010</span>&#13;
<span>MOV R0 #0XAF   pc=2 110000010000000010101111 Class=3 mode=4 <span class="sc-comment"> </span>MOV  t1=R0 #0XAF</span>&#13;
<span>MOV R0 #-5     pc=3 110000010000000011111011 Class=3 mode=4 <span class="sc-comment"> </span>MOV  t1=R0 #-5</span>&#13;
<span>MOV R0 M:7     pc=4 110000101100000000000111 Class=3 mode=11<span class="sc-comment"> </span>MOV  t1=R0 M:7</span>&#13;
<span>MOV R0 #WWW    pc=5 110000010000000000101010 Class=3 mode=4 <span class="sc-comment"> </span>MOV  t1=R0 #WWW</span>&#13;
<span>NOP            pc=6 000000000000000000000000 Class=0 mode=0 <span class="sc-comment"> </span>NOP  t1 =</span>&#13;
<span>STOP           pc=7 001110000000000000000000 Class=0 mode=0 <span class="sc-comment"> </span>STOP t1 =</span>&#13;
<span>END            pc=8 001111000000000000000000 Class=0 mode=0 <span class="sc-comment"> </span>END  t1 =</span>&#13;
<span>110000010000000000001100      This is the program in binary form</span>&#13;
<span>110000010000000000011010</span>&#13;
<span>110000010000000010101111</span>&#13;
<span>110000010000000011111011</span>&#13;
<span>110000101100000000000111</span>&#13;
<span>110000010000000000101010</span>&#13;
<span>000000000000000000000000</span>&#13;
<span>001110000000000000000000</span></pre>&#13;
			<pre class="source-code">001111000000000000000000</pre>&#13;
			<p lang="en-GB">In the following code block, we have the single-step execution output. It’s been edited to help fit it <a id="_idIndexMarker544"/>on the page. We printed only two memory locations for each line. The literal in the instruction and its value in <strong class="source-inline">r0</strong> are printed <span class="No-Break">in bold:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>EXECUTE</span>&#13;
<span>MOV R0 <strong class="bold">#12</strong>     pc=0  110000010000000000001100 Class=3 mode=4  </span>&#13;
<span>Reg=<strong class="bold">0c</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span>&#13;
<span>MOV R0 <strong class="bold">#%11010</strong> pc=1  110000010000000000011010 Class=3 mode=4  </span>&#13;
<span>Reg=<strong class="bold">1a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span>&#13;
<span>MOV R0 <strong class="bold">#0XAF</strong>   pc=2  110000010000000010101111 Class=3 mode=4  </span>&#13;
<span>Reg=<strong class="bold">af</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1</span>&#13;
<span>MOV R0 <strong class="bold">#-5</strong>     pc=3  110000010000000011111011 Class=3 mode=4  </span>&#13;
<span>Reg=<strong class="bold">fb</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1</span>&#13;
<span>MOV R0 <strong class="bold">M:7</strong>     pc=4  110000101100000000000111 Class=3 mode=11 </span>&#13;
<span>Reg=<strong class="bold">07</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span>&#13;
<span>MOV R0 <strong class="bold">#WWW</strong>    pc=5  110000010000000000101010 Class=3 mode=4  </span>&#13;
<span>Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span>&#13;
<span>NOP            pc=6  000000000000000000000000 Class=0 mode=0  </span>&#13;
<span>Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span>&#13;
<span>STOP           pc=7  001110000000000000000000 Class=0 mode=0  </span>&#13;
<span>Reg=<strong class="bold">2a</strong> 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0</span></pre>&#13;
			<h1 id="_idParaDest-142" lang="en-GB"><a id="_idTextAnchor148"/>The complete TC3 code</h1>&#13;
			<p lang="en-GB">We have discussed the design of TC3. Here, we present the code of a complete simulator. There are some slight differences between the descriptive fragments of code we described in the <a id="_idIndexMarker545"/>previous section and this more complete simulator. This is followed by a sample run of the simulator. The first part of the code defines the instruction modes and provides a simple source program that will <span class="No-Break">be executed:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>### TC3 CISC machine</span>&#13;
<span>### Demonstration register-to-memory architecture Designed 22 January 2022.</span>&#13;
<span>### Instruction formats and addressing modes</span>&#13;
<span>### Mode 0:  NOP, STOP        <span class="sc-comment">No operand length 1</span></span>&#13;
<span>### Mode 1:  INC R1           <span class="sc-comment">Single register operand</span></span>&#13;
<span>### Mode 2:  BEQ XXX          <span class="sc-comment">Literal operand</span></span>&#13;
<span>### Mode 3:  Reserved</span>&#13;
<span>### Mode 4:  MOV r1,literal   <span class="sc-comment">Two-operand, register and literal</span></span>&#13;
<span>### Mode 5:  MOV r1,r2        <span class="sc-comment">Two-operand, register to register</span></span>&#13;
<span>### Mode 6:  MOV r1,[r2]      <span class="sc-comment">Two-operand, register indirect to register</span></span>&#13;
<span>### Mode 7:  MOV [r1],r2      <span class="sc-comment">Two-operand, register to register indirect</span></span>&#13;
<span>### Mode 8:  MOV [r1],[r2]    <span class="sc-comment">Two-operand, register indirect to register indirect</span></span>&#13;
<span>### Mode 9:  MOV M,r2         <span class="sc-comment">Two-operand, register to memory address</span></span>&#13;
<span>### Mode 10: MOV M,[r2]       <span class="sc-comment">Two-operand, register indirect to memory address</span></span>&#13;
<span>### Mode 11: MOV r1,M         <span class="sc-comment">Two-operand, memory address to register</span></span>&#13;
<span>### Mode 12: MOV [r1],M       <span class="sc-comment">Two-operand, memory address to register indirect</span></span>&#13;
<span>### The sample test code</span>&#13;
<span>###       MOV  r0,#8      <span class="sc-comment">@ Memory locations 1 to 8 with random numbers</span></span>&#13;
<span>### Next: RND  r5</span>&#13;
<span>###       MOV  [r0],r5</span>&#13;
<span>###       DEC  r0</span>&#13;
<span>###       BNE  Next</span>&#13;
<span>###       EQU   X,#1      <span class="sc-comment">@ Vector 1</span></span>&#13;
<span>###       EQU   Y,#5      <span class="sc-comment">@ Vector 5</span></span>&#13;
<span>###       EQU   Z,#9      <span class="sc-comment">@ Vector 9</span></span>&#13;
<span>###       MOV   r1,#X     <span class="sc-comment">@ r0 points to array X</span><span class="sc-comment CharOverride-7">       </span>  <span class="sc-comment CharOverride-7">  </span>  <span class="sc-comment"> 11 0000 0100 000 000 00000001</span></span>&#13;
<span>###       MOV   r2,#Y     <span class="sc-comment">@ r1 points to array Y</span><span class="sc-comment CharOverride-7">        </span>    <span class="sc-comment CharOverride-7">  </span><span class="sc-comment">11 0000 0100 001 000 00000101</span></span>&#13;
<span>###       MOV   r3,#Z     <span class="sc-comment">@ r2 points to array Z</span><span class="sc-comment CharOverride-7">         </span>    <span class="sc-comment">  11 0000 0100 010 000 00001001</span></span>&#13;
<span>###       MOV   r4,#6     <span class="sc-comment">@ r4 number of elements to add</span>      <span class="sc-comment">11 0000 0100 011 000 00000100</span></span>&#13;
<span>### Loop: MOV   r5,[r1]   <span class="sc-comment">@ REPEAT: Get xi</span><span class="sc-comment CharOverride-7">               </span> <span class="sc-comment"> 11 0000 0110 100 000 00000000</span></span>&#13;
<span>###       ADD   r5,#6     <span class="sc-comment">@ Add 6 to xi</span><span class="sc-comment CharOverride-7">                </span> <span class="sc-comment CharOverride-7">  </span><span class="sc-comment">11 0001 0100 100 000 00000101</span></span>&#13;
<span>###       ADD   r5,[r2]   <span class="sc-comment">@ Add xi + 5 to yi</span><span class="sc-comment CharOverride-7">             </span>  <span class="sc-comment CharOverride-7"> </span><span class="sc-comment"> 11 0001 0110 100 001 00000000</span></span>&#13;
<span>###       MOV   [r3],r5   <span class="sc-comment">@ Store result in array Z</span><span class="sc-comment CharOverride-7">    </span>      <span class="sc-comment CharOverride-7">  </span><span class="sc-comment">11 0000 0111 010 100 00000000</span></span>&#13;
<span>###       INC   r1        <span class="sc-comment">@ Increment pointer to array X </span>       <span class="sc-comment">10 0000 0010 000 000 00000000</span></span>&#13;
<span>###       INC   r2        <span class="sc-comment">@ Increment pointer to array Y </span>       <span class="sc-comment">10 0000 0010 001 000 00000000</span></span>&#13;
<span>###       INC   r3        <span class="sc-comment">@ Increment pointer to array Z </span>      <span class="sc-comment">   10 0000 0010 010 000 00000000</span></span>&#13;
<span>###       DEC   r4        <span class="sc-comment">@ Decrement loop counter</span><span class="sc-comment CharOverride-7">       </span>  <span class="sc-comment">  10 0001 0010 011 000 00000000</span></span>&#13;
<span>###       BNE   Loop      <span class="sc-comment">@ Continue until counter zero</span><span class="sc-comment CharOverride-7">  </span>     <span class="sc-comment">  01 0010 0001 000 000 00000100</span></span>&#13;
<span>###       STOP                                        <span class="sc-comment">00 1111 0000 000 000 00000000</span></span></pre>&#13;
			<p lang="en-GB">The following block contains the dictionaries for instruction decoding and register lookup. We’ve provided <a id="_idIndexMarker546"/>reverse lookup so that you can look up a mnemonic to get its code or look up the code to get the mnemonic. Similarly, we’ve provided lookup for registers, such as <strong class="source-inline">R0</strong> and <strong class="source-inline">R2</strong>, and indirect registers, such as <strong class="source-inline">[R0]</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">[R1]:</strong></span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>import random                                 <span class="sc-comment"># Get library of random number operations</span></span>&#13;
<span><span class="sc-comment">### Dictionaries and variables</span></span>&#13;
<span>mnemon  = {'MOV':48,'MOVE':48,'ADD':49,'SUB':50,'CMP':51,'NOT':52,'AND':53, \</span>&#13;
<span>           'OR':54,'EOR':55,'ONES':56, 'MRG':57,'FFO':58,'LSL':59,'LSR':60, \</span>&#13;
<span>           'ADC':61,'INC':32,'DEC':33,'RND':34,'CZN':19,'TST':36,'NOP':0,   \</span>&#13;
<span>           'BRA':16,'BEQ':17,'BNE':18,'STOP':14,'END':15}</span>&#13;
<span>mnemonR = {48:'MOV',49:'ADD',50:'SUB',51:'CMP',52:'NOT',53:'AND',54:'OR',   \</span>&#13;
<span>           55:'EOR',56:'ONES',57:'MRG',58:'FFO',59:'LSL',60:'LSR',61:'ADC', \</span>&#13;
<span>           32:'INC',33:'DEC', 34:'RND',19:'CZN',36:'TST',0:'NOP',16:'BRA',  \</span>&#13;
<span>           17:'BEQ',18:'BNE',14:'STOP',15:'END'}</span>&#13;
<span>rName   = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} <span class="sc-comment"># Register tab</span></span>&#13;
<span>rNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3,'[R4]':4,' \</span>&#13;
<span>           '[R5]':5,'[R6]':6,'[R7]':7}                       <span class="sc-comment"># Indirect registers</span></span>&#13;
<span>iClass0 = ['STOP', 'NOP','END']         <span class="sc-comment"># class 00 mnemonic with no operands</span></span>&#13;
<span>iClass1 = ['BRA','BEQ','BNE','CZN']     <span class="sc-comment"># class 01 mnemonic with literal operand</span></span>&#13;
<span>iClass2 = ['INC','DEC','RND','TST']     <span class="sc-comment"># class 10 mnemonic with register operand</span></span>&#13;
<span>iClass3 = ['MOV','MOVE','ADD','ADC','SUB','CMP', 'NOT','AND','OR', \</span>&#13;
<span>           'EOR','ONES','MRG','FFO','LSL','LSR']   <span class="sc-comment"># class 11 mnemonic two operands</span></span>&#13;
<span>sTab = {}                              <span class="sc-comment"># Symbol table for equates and labels name:integerValue</span></span>&#13;
<span>pMem = []                              <span class="sc-comment"># Program memory (initially empty)</span></span>&#13;
<span>dMem = [0]*16                          <span class="sc-comment"># Data memory</span></span>&#13;
<span>reg  = [0]*8                           <span class="sc-comment"># Register set</span></span>&#13;
<span>z,c,n = 0,0,0                          <span class="sc-comment"># Define and clear flags zero, carry, negative</span></span></pre>&#13;
			<p lang="en-GB">The following two functions provide the ability to read integer operands in various formats, and an ALU that <a id="_idIndexMarker547"/>performs arithmetic and logic operations. Both of these functions can be expanded to provide <span class="No-Break">additional capabilities:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def getL(lit8):                                <span class="sc-comment"># Convert string to integer</span></span>&#13;
<span>    lit8v = 9999                               <span class="sc-comment"># Dummy default</span></span>&#13;
<span>    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  <span class="sc-comment"># Strip M: prefix from memory literal addresses</span></span>&#13;
<span>    if lit8[0:1]   == '#':  lit8  = lit8[1:]   <span class="sc-comment"># Strip # prefix from literal addresses</span></span>&#13;
<span>    if   type(lit8) == int: lit8v = lit8       <span class="sc-comment"># If integer, return it</span></span>&#13;
<span>    elif lit8.isnumeric():  lit8v = int(lit8)  <span class="sc-comment"># If decimal in text from convert to integer</span></span>&#13;
<span>    elif lit8 in sTab:      lit8v = sTab[lit8] <span class="sc-comment"># If in symbol table, retrieve it</span></span>&#13;
<span>    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  <span class="sc-comment"># If binary string convert to int</span></span>&#13;
<span>    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) <span class="sc-comment"># If hex string convert to int</span></span>&#13;
<span>    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) &amp; 0xFF</span>&#13;
<span>                                               <span class="sc-comment"># If decimal negative convert to signed int</span></span>&#13;
<span>    return(lit8v)                              <span class="sc-comment"># Return integer corresponding to text string</span></span>&#13;
<span>def alu(fun,op1,op2):             <span class="sc-comment"># Perform arithmetic and logical operations on operands 1 and 2</span></span>&#13;
<span>    global z,n,c                               <span class="sc-comment"># Make flags global</span></span>&#13;
<span>    z,n,c = 0,0,0                              <span class="sc-comment"># Clear status flags initially</span></span>&#13;
<span>    if   fun == 0: res = op2             <span class="sc-comment"># MOV: Perform data copy from source to destination</span></span>&#13;
<span>    elif fun == 1:                       <span class="sc-comment"># ADD: Perform addition - and ensure 8 bits plus carry</span></span>&#13;
<span>        res = (op1 + op2)                      <span class="sc-comment">#</span> <span class="sc-comment">Do addition of operands</span></span>&#13;
<span>        if thisOp == 'ADC': res = res + c      <span class="sc-comment">#</span> <span class="sc-comment">If operation ADC then add carry bit</span></span>&#13;
<span>    elif fun == 2: res = (op1 - op2)           <span class="sc-comment"># </span><strong class="source-inline">SUB</strong><span class="sc-comment">: Perform subtraction</span></span>&#13;
<span>    elif fun == 3: res = op1 - op2        <span class="sc-comment"># </span><strong class="source-inline">CMP</strong><span class="sc-comment">: Same as subtract without writeback</span></span>&#13;
<span>    elif fun == 4: res = op1 &amp; op2        <span class="sc-comment"># </span><strong class="source-inline">AND</strong><span class="sc-comment">: Perform bitwise AND</span></span>&#13;
<span>    elif fun == 5: res = op1 | op2        <span class="sc-comment"># </span><strong class="source-inline">OR</strong></span>&#13;
<span>    elif fun == 6: res = ~op2             <span class="sc-comment"># </span><strong class="source-inline">NOT</strong></span>&#13;
<span>    elif fun == 7: res = op1 ^ op2        <span class="sc-comment"># </span><strong class="source-inline">XOR</strong></span>&#13;
<span>    elif fun == 8:</span>&#13;
<span>        res = op2 &lt;&lt; 1                    <span class="sc-comment"># </span><strong class="source-inline">LSL</strong><span class="sc-comment">: Perform single logical shift left</span></span>&#13;
<span>    elif fun == 9:</span>&#13;
<span>        res = op2 &gt;&gt; 1                    <span class="sc-comment"># </span><strong class="source-inline">LSR</strong><span class="sc-comment">: Perform single logical shift right</span></span>&#13;
<span>    elif fun == 10:                       <span class="sc-comment"># </span><strong class="source-inline">ONES</strong><span class="sc-comment"> (Count number of 1s in register)</span></span>&#13;
<span>       onesCount = 0                      <span class="sc-comment"># Clear the 1s counter</span></span>&#13;
<span>       for i in range (0,8):        <span class="sc-comment"># For i = 0 to 7 (test each bit) AND with 10000000 to get msb</span></span>&#13;
<span>           if op2 &amp; 0x80 == 0x80:         <span class="sc-comment"># If msb is set</span></span>&#13;
<span>               onesCount = onesCount + 1  <span class="sc-comment"># increment the 1s counter</span></span>&#13;
<span>           op2 = op2 &lt;&lt; 1                 <span class="sc-comment"># shift the operand one place left</span></span>&#13;
<span>       res = onesCount                    <span class="sc-comment"># Destination operand is 1s count</span></span>&#13;
<span>    elif fun == 11:                       <span class="sc-comment"># </span><strong class="source-inline">MRG</strong><span class="sc-comment"> (merge alternate bits of two registers)</span></span>&#13;
<span>         t1 = op1 &amp; 0b10101010            <span class="sc-comment"># Get even source operand bits</span></span>&#13;
<span>         t2 = op2 &amp; 0b01010101            <span class="sc-comment"># Get odd destination operand bits</span></span>&#13;
<span>         res = t1 | t2                    <span class="sc-comment"># Merge them using an OR</span></span>&#13;
<span>    elif fun == 12:                       <span class="sc-comment"># </span><strong class="source-inline">FFO</strong><span class="sc-comment"> (Find position of leading 1)</span></span>&#13;
<span>        res = 8                           <span class="sc-comment"># Set default position 8 (i.e., leading 1 not found)</span></span>&#13;
<span>        for i  in range (0,8):            <span class="sc-comment"># Examine the bits one by one</span></span>&#13;
<span>          temp = op2 &amp; 0x80               <span class="sc-comment"># AND with 10000000 to get leading bit and save</span></span>&#13;
<span>          op2 = op2 &lt;&lt; 1                  <span class="sc-comment"># Shift operand left</span></span>&#13;
<span>          res = res - 1                   <span class="sc-comment"># Decrement place counter</span></span>&#13;
<span>          if temp == 128: break           <span class="sc-comment"># If the last tested bit was 1 then jump out of loop</span></span>&#13;
<span>    if res &amp; 0xFF == 0:        z = 1      <span class="sc-comment"># TEST FLAGS z = 1 if bits 0 to 7 all 0</span></span>&#13;
<span>    if res &amp; 0x80 == 0x80:     n = 1      <span class="sc-comment"># If bit 7 is one, set the carry bit</span></span>&#13;
<span>    if res &amp; 0x100 == 0x100:   c = 1      <span class="sc-comment"># carry bit set if bit 8 set</span></span>&#13;
<span>    if (thisOp == 'LSR') and (op2 &amp; 1 == 1): c = 1</span>&#13;
<span>                                          <span class="sc-comment"># Deal with special case of shift right (carry out is lsb)</span></span>&#13;
<span>    return(res &amp; 0xFF)                    <span class="sc-comment"># Return and ensure value eight bits</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">trace()</strong> function prints the <a id="_idIndexMarker548"/>state of the processor as a program is executed. This can be modified to change the amount, layout, and format of <span class="No-Break">the data:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def trace():                                          <span class="sc-comment"># Function to print execution data</span></span>&#13;
<span>    cF   = "{0:&lt;20}".format(" ".join(src[pcOld]))     <span class="sc-comment"># 1. instruction</span></span>&#13;
<span>    icF  = 'pc = ' + "{:&lt;3}".format(pcOld)            <span class="sc-comment"># 2. pc</span></span>&#13;
<span>    binF = format(inst, "024b")                       <span class="sc-comment"># 3. binary code</span></span>&#13;
<span>    iClF = 'Class = '+ str(iClass)                    <span class="sc-comment"># 4. instruction class</span></span>&#13;
<span>    modF = 'mode = ' + str(mode)   <span class="sc-comment"># 5. instruction mode NOTE we have to convert mode to string</span></span>&#13;
<span>    t0F  = "{:&lt;5}".format(t0)                        <span class="sc-comment"># 6. token 0 (mnemonic)</span></span>&#13;
<span>    t1F  = "{:&lt;5}".format(t1)                        <span class="sc-comment"># 7. token 1 (register field 1)</span></span>&#13;
<span>    t2F  = "{:&lt;10}".format(t2)                       <span class="sc-comment"># 8. token 2 (register field 2 or literal)</span></span>&#13;
<span>    rF   = 'Reg = '+ ' '.join('%02x' % b for b in reg<span class="sc-comment">)</span>  <span class="sc-comment"># 9. Registers in hex format</span></span>&#13;
<span>    m    = dMem[0:11]                                <span class="sc-comment"># 10. First 10 memory locations</span></span>&#13;
<span>    mF   = 'Mem = '+ " ".join("%02x" % b for b in m) <span class="sc-comment"># 11. Hex-formatted memory values</span></span>&#13;
<span>    ccrF = 'C = '+ str(c) + ' Z = ' + str(z) +' N = ' + str(n) <span class="sc-comment"># 12. Condition codes</span></span>&#13;
<span>    x = input('&gt;&gt;&gt; ')                               <span class="sc-comment"># 13. Wait for keyboard input (return)</span></span>&#13;
<span>    print(cF,icF,binF,iClF, modF, rF, mF,ccrF)      <span class="sc-comment"># 14. Print the computer status data</span></span>&#13;
<span>    return()</span>&#13;
<span>testCode = "E:\\AwPW\\TC3_NEW_1.txt"  <span class="sc-comment"># Source filename on my computer</span></span>&#13;
<span>with open(testCode) as src:           <span class="sc-comment"># Open source file with assembly language program</span></span>&#13;
<span>    lines = src.readlines()           <span class="sc-comment"># Read the program into lines</span></span>&#13;
<span>src.close()                           <span class="sc-comment"># Close the source file</span></span>&#13;
<span>src = [i[0:-1].lstrip()  for i in lines ]</span>&#13;
<span>                                      <span class="sc-comment"># Remove the /n newline from each line of the source code</span></span>&#13;
<span>src = [i.split("@")[0] for i in src]  <span class="sc-comment"># Remove comments in the code</span></span>&#13;
<span>src = [i for i in src if i != '']     <span class="sc-comment"># Remove empty lines</span></span>&#13;
<span>for i in range(0,len(src)):           <span class="sc-comment"># Scan source code line by line</span></span>&#13;
<span>    src[i] = src[i].replace(',',' ')  <span class="sc-comment"># Replace commas by a space</span></span>&#13;
<span>    src[i] = src[i].upper()           <span class="sc-comment"># Convert to upper-case</span></span>&#13;
<span>    src[i] = src[i].split()           <span class="sc-comment"># Split into tokens (label, mnemonic, operands)</span></span>&#13;
<span>src1 = []                             <span class="sc-comment"># Set up dummy source file, initially empty</span></span>&#13;
<span>for i in range (0,len(src)):          <span class="sc-comment"># Read source and stop on first END operation</span></span>&#13;
<span>    src1.append(src[i])               <span class="sc-comment"># Append line to dummy source file</span></span>&#13;
<span>    if src[i][0] == 'END': break      <span class="sc-comment"># Stop on 'END' token</span></span>&#13;
<span>src = src1                            <span class="sc-comment"># Copy dummy file to source (having stopped on 'END')</span></span>&#13;
<span>for i in range (0,len(src)):          <span class="sc-comment"># Deal with equates of the form EQU PQR 25</span></span>&#13;
<span>    if src[i][0] == 'EQU':            <span class="sc-comment"># If the line is 3 or more tokens and first token is EQU</span></span>&#13;
<span>        sTab[src[i][1]] = getL(src[i][2])</span>&#13;
<span>                                      <span class="sc-comment"># Put token in symbol table as integer</span></span>&#13;
<span>src = [i for i in src if i.count("EQU") == 0]</span>&#13;
<span>                            <span class="sc-comment"># Remove lines with 'EQU' from source code (these are not instructions)</span></span>&#13;
<span>for i in range(0,len(src)):           <span class="sc-comment"># Add label addresses to symbol table</span></span>&#13;
<span>    if src[i][0][-1] == ':':          <span class="sc-comment"># If first token is a label with : terminator</span></span>&#13;
<span>        sTab.update({src[i][0][0:-1]:i}) <span class="sc-comment"># add it to the symbol table.</span></span>&#13;
<span>xLm = 0                               <span class="sc-comment"># Length of maximum instruction (for printing)</span></span>&#13;
<span>for i in range (0,len(src)):          <span class="sc-comment"># Step through source array</span></span>&#13;
<span>    xL = len(' '.join(src[i]))       <span class="sc-comment"># Get the length of each line after joining tokens</span></span>&#13;
<span>    if xL &gt; xLm: xLm = xL            <span class="sc-comment"># If xL &gt; xLm</span>  <span class="sc-comment">NOTE: This facility is not used in this version</span></span>&#13;
<span>print('Source code')                 <span class="sc-comment"># Display tokenized source code</span></span>&#13;
<span>for i in range(0,len(src)): print(src[i])</span>&#13;
<span>print("\nEquate and branch table\n") <span class="sc-comment"># Display the symbol table</span></span>&#13;
<span>for x,y in sTab.items():             <span class="sc-comment"># Step through the symbol table dictionary structure</span></span>&#13;
<span>    print("{:&lt;8}".format(x),y)       <span class="sc-comment"># Display each line as label and value</span></span>&#13;
<span>print('\nAssembly loop \n')</span>&#13;
<span>for ic in range(0,len(src)):         <span class="sc-comment"># ASSEMBLY LOOP (ic = instruction counter)</span></span>&#13;
<span>    t0,t1,t2 = '','',''              <span class="sc-comment"># Prepare to assign tokens. Initialize to null string</span></span>&#13;
<span>    if src[ic][0][-1] != ':':        <span class="sc-comment"># If the first token doesn't end in colon, its an instruction</span></span>&#13;
<span>        j = 0                        <span class="sc-comment"># j = 0 for line starting with mnemonic</span></span>&#13;
<span>    else:                            <span class="sc-comment"># If the first token ends in a colon it's a label</span></span>&#13;
<span>        j = 1                        <span class="sc-comment"># j = 1 if mnemonic is second token</span></span>&#13;
<span>    t0 = src[ic][j]                  <span class="sc-comment"># Set t0 to mnemonic</span></span>&#13;
<span>    if len(src[ic]) &gt; 1+j: t1 = src[ic][j+1]   <span class="sc-comment"># Set t1 to single operand</span></span>&#13;
<span>    if len(src[ic]) &gt; 2+j: t2 = src[ic][j+2]   <span class="sc-comment"># Set t2 to second operand</span></span>&#13;
<span>    tLen = len(src[ic]) - j - 1      <span class="sc-comment"># tLen is the number of tokens (adjusted for any label)</span></span>&#13;
<span>    binC = 0                         <span class="sc-comment"># Initialize binary code for this instruction to all zeros</span></span>&#13;
<span>    opCode = mnemon[t0]              <span class="sc-comment"># Look up op-code in table mnemon using token t0</span></span>&#13;
<span>    iClass = opCode &gt;&gt; 4             <span class="sc-comment"># Get two most significant bits of op-code (i.e., class)</span></span>&#13;
<span>    if   t0 in iClass0:              <span class="sc-comment"># If in iClass0 it's a single instruction, no operands</span></span>&#13;
<span>        mode = 0                     <span class="sc-comment"># The mode is 0 for everything in this class</span></span>&#13;
<span>        binC = (mnemon[t0] &lt;&lt; 18)    <span class="sc-comment"># All fields zero except op_code</span></span>&#13;
<span>    elif t0 in iClass1:              <span class="sc-comment"># If in iClass1 it's an op-code plus offset (e.g., branch)</span></span>&#13;
<span>        mode = 1                     <span class="sc-comment"># All class 1 instruction are mode 1 (op-code plus literal)</span></span>&#13;
<span>        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  + getL(t1)</span>&#13;
<span>                                     <span class="sc-comment"># Create binary code with operation plus address (literal)</span></span>&#13;
<span>    elif t0 in iClass2:              <span class="sc-comment"># If in iClass2 it's an op-code plus register number</span></span>&#13;
<span>        mode = 2                     <span class="sc-comment"># All instruction are mode 2</span></span>&#13;
<span>        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)  + (rName[t1] &lt;&lt; 11)</span>&#13;
<span>                                     <span class="sc-comment"># Create binary code</span></span>&#13;
<span>    elif t0 in iClass3:        <span class="sc-comment"># Two-operand inst. All data-processing and movement ops in iClass3</span></span>&#13;
<span>        if   (t1 in rName) and (t2[0] == '#'):</span>&#13;
<span>                               <span class="sc-comment"># Look for register name and literal for mode 4</span></span>&#13;
<span>            mode = 4</span>&#13;
<span>        elif (t1 in rName) and (t2 in rName):</span>&#13;
<span>                               <span class="sc-comment"># Look for register name and register name for mode 5</span></span>&#13;
<span>            mode = 5</span>&#13;
<span>        elif (t1 in rName) and (t2 in rNamInd):</span>&#13;
<span>                               <span class="sc-comment"># Look for register name and register indirect name (r1,[r2])</span></span>&#13;
<span>            mode = 6</span>&#13;
<span>        elif (t1 in rNamInd) and (t2 in rName):</span>&#13;
<span>                                     <span class="sc-comment"># Look for register indirect name and register ([r1],r2)</span></span>&#13;
<span>            mode = 7</span>&#13;
<span>        elif (t1 in rNamInd) and (t2 in rNamInd):</span>&#13;
<span>                                     <span class="sc-comment"># Look for two register indirect names ([r1],[r2])</span></span>&#13;
<span>            mode = 8</span>&#13;
<span>        elif (t1[0:2] == 'M:') and (t2 in rName):</span>&#13;
<span>                                     <span class="sc-comment"># Look for literal prefixed by M: and register name (M:12,r4)</span></span>&#13;
<span>            mode = 9</span>&#13;
<span>        elif (t1[0:2] == 'M:') and (t2 in rNamInd):</span>&#13;
<span>                               <span class="sc-comment"># Look for literal prefixed by M: and register indirect name</span> <span class="sc-comment">(M:12,[r4])</span></span>&#13;
<span>            mode = 10</span>&#13;
<span>        elif (t1 in rName) and (t2[0:2] == 'M:'):</span>&#13;
<span>                                     <span class="sc-comment"># Look for register name and literal prefixed by M:</span></span>&#13;
<span>            mode = 11</span>&#13;
<span>        elif (t1 in rNamInd) and (t2[0:2] == 'M:'):</span>&#13;
<span>                                     <span class="sc-comment"># Look for register indirect name and literal prefixed by M:</span></span>&#13;
<span>            mode = 12</span>&#13;
<span>        binC = (mnemon[t0] &lt;&lt; 18) + (mode &lt;&lt; 14)</span>&#13;
<span>                                     <span class="sc-comment"># Insert op_Code and mode fields in the instruction</span></span>&#13;
<span>        rField1, rField2, lField = 0, 0, 0  <span class="sc-comment"># Calculate register and literal fields. Initialize to zero</span></span>&#13;
<span>        if mode in [4,5,6,11]: rField1 = rName[t1]</span>&#13;
<span>                               <span class="sc-comment"># Convert register names into register numbers rField1is first register</span></span>&#13;
<span>        if mode in [7,8,12]:   rField1 = rNamInd[t1]</span>&#13;
<span>        if mode in [5,7,9]:    rField2 = rName[t2]   <span class="sc-comment"># rField2 is second register field</span></span>&#13;
<span>        if mode in [6,8,10]:   rField2 = rNamInd[t2]</span>&#13;
<span>        if mode in [4,11,12]:  lField  = getL(t2)</span>&#13;
<span>                                  <span class="sc-comment"># if (mode == 4) or (mode == 11) or (mode == 12): Get literal</span></span>&#13;
<span>        if mode in [9,10]:     lField  = getL(t1)</span>&#13;
<span>                                  <span class="sc-comment"># if (mode == 9) or (mode == 10):</span>  <span class="sc-comment">lField = getL(t1) Literal field</span></span>&#13;
<span>        binC = binC+(rField1 &lt;&lt; 11)+(rField2 &lt;&lt; 8)+lField</span>&#13;
<span>                                     <span class="sc-comment"># Binary code with register and literal fields added</span></span>&#13;
<span>    pMem.append(binC)                <span class="sc-comment"># Append instruction to program memory in pMem</span></span>&#13;
<span>### <span class="sc-comment">Display the assembly details of each instruction (this is for diagnostics)</span></span>&#13;
<span>    pcF  = '{0:&lt;20}'.format(' '.join(src[ic])) <span class="sc-comment"># 1. instruction</span></span>&#13;
<span>    icF  = 'pc = ' + '{:&lt;3}'.format(ic)        <span class="sc-comment"># 2. pc</span></span>&#13;
<span>    binF = format(binC, '024b')                <span class="sc-comment"># 3. binary code</span></span>&#13;
<span>    iClF = 'Class = '+ str(iClass)             <span class="sc-comment"># 4. instruction class</span></span>&#13;
<span>    modF = 'mode = ' + str(mode)           <span class="sc-comment"># 5. instruction mode NOTE convert mode to string</span></span>&#13;
<span>    t0F  = '{:&lt;5}'.format(t0)              <span class="sc-comment"># 6. token 0 (mnemonic)</span></span>&#13;
<span>    t1F  = '{:&lt;5}'.format(t1)              <span class="sc-comment"># 7. token 1 (register field 1)</span></span>&#13;
<span>    t2F  = '{:&lt;10}'.format(t2)             <span class="sc-comment"># 8. token 2 (register field 2 or literal)</span></span>&#13;
<span>    print(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F) <span class="sc-comment"># Print these fields</span></span>&#13;
<span>print('\nEXECUTE \n')</span>&#13;
<span><span class="sc-comment">### EXECUTE LOOP</span>   <span class="sc-comment"># reverse assemble the binary instruction to recover the fields and execute the instruction</span></span>&#13;
<span>pc = 0                                     <span class="sc-comment"># Reset the program counter to 0</span></span>&#13;
<span>run = True                         <span class="sc-comment"># run flag: True to execute, False to stop (stop on END or STOP)</span></span>&#13;
<span>while run == True:                         <span class="sc-comment"># MAIN LOOP</span></span>&#13;
<span>    op1, op2, op3 = 0,0,0                  <span class="sc-comment"># Initialize data operands</span></span>&#13;
<span>    inst = pMem[pc]        <span class="sc-comment"># Fetch current instruction. inst is the binary op-code executed in this cycle</span></span>&#13;
<span>    pcOld = pc                             <span class="sc-comment"># Remember current pc for printing/display</span></span>&#13;
<span>    pc = pc + 1                            <span class="sc-comment"># Increment program counter for next cycle</span></span>&#13;
<span>    iClass = inst &gt;&gt; 22                    <span class="sc-comment"># Extract operation class 0 to 3 (top two bits)</span></span>&#13;
<span>    opCode = (inst &gt;&gt; 18)   &amp; 0b111111     <span class="sc-comment"># Extract the current op-code</span></span>&#13;
<span>    mode   = (inst &gt;&gt; 14)   &amp; 0b1111       <span class="sc-comment"># Extract the addressing mode</span></span>&#13;
<span>    reg1   = (inst &gt;&gt; 11)   &amp; 0b0111       <span class="sc-comment"># Extract register 1 number</span></span>&#13;
<span>    reg2   = (inst &gt;&gt;  8)   &amp; 0b0111       <span class="sc-comment"># Extract register 2 number</span></span>&#13;
<span>    lit    = inst           &amp; 0b11111111   <span class="sc-comment"># Extract the 8-bit literal in the least significant bits</span></span></pre>&#13;
			<p lang="en-GB">The following is the <a id="_idIndexMarker549"/>instruction execution part of the program. Note that instructions are executed in the order of <span class="No-Break">their class:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">### EXECUTE THE CODE</span></span>&#13;
<span>    thisOp = mnemonR[opCode]               <span class="sc-comment"># Reverse assemble. Get mnemonic from op-code</span></span>&#13;
<span>    if iClass == 0:                        <span class="sc-comment"># Class 0 no-operand instructions</span></span>&#13;
<span>        if thisOp == 'END' or thisOp == 'STOP': run = False</span>&#13;
<span>                                           <span class="sc-comment"># If END or STOP clear run flag to stop execution</span></span>&#13;
<span>        if opCode == 'NOP': pass           <span class="sc-comment"># If NOP then do nothing and "pass"</span></span>&#13;
<span>    elif iClass == 1:                      <span class="sc-comment"># Class 1 operation </span></span>&#13;
<span>                                           <span class="sc-comment"># Class 1 branch and instr with literal operands</span></span>&#13;
<span>        if    thisOp == 'BRA': pc = lit    <span class="sc-comment"># BRA Branch unconditionally PC = L</span></span>&#13;
<span>        elif (thisOp == 'BEQ') and (z == 1): pc = lit  <span class="sc-comment"># BEQ Branch on zero</span></span>&#13;
<span>        elif (thisOp == 'BNE') and (z == 0): pc = lit  <span class="sc-comment"># BNE Branch on not zero</span></span>&#13;
<span>        elif thisOp == 'CZN':                          <span class="sc-comment"># Set/clear c, z, and n flags</span></span>&#13;
<span>            c = (lit &amp; 0b100) &gt;&gt; 2                     <span class="sc-comment"># Bit 2 of literal is c</span></span>&#13;
<span>            z = (lit &amp; 0b010) &gt;&gt; 1                     <span class="sc-comment"># Bit 1 of literal is z</span></span>&#13;
<span>            n = (lit &amp; 0b001)              <span class="sc-comment"># Bit 0 of literal is c</span></span>&#13;
<span>    elif iClass == 2:                      <span class="sc-comment"># Class 0 single-register operand</span></span>&#13;
<span>        if   thisOp == 'INC': reg[reg1] = alu(1,reg[reg1],1)</span>&#13;
<span>                                           <span class="sc-comment"># Call ALU with second operand 1 to do increment</span></span>&#13;
<span>        elif thisOp == 'DEC': reg[reg1] = alu(2,reg[reg1],1)   <span class="sc-comment"># Decrement register</span></span>&#13;
<span>        elif thisOp == 'RND': reg[reg1] = random.randint(0,0xFF)</span>&#13;
<span>                                           <span class="sc-comment"># Generate random number in range 0 to 0xFF</span></span>&#13;
<span>        elif thisOp == 'TST':              <span class="sc-comment"># Test a register: return z and n flags. Set c to 0</span></span>&#13;
<span>            z, n, c = 0, 0, 0                      <span class="sc-comment">#</span> <span class="sc-comment">Set all flags to 0</span></span>&#13;
<span>            if reg[reg1] == 0:           z = 1     <span class="sc-comment">#</span> <span class="sc-comment">If operand 0 set z flag</span></span>&#13;
<span>            if reg[reg1] &amp; 0x80 == 0x80: n = 1     <span class="sc-comment">#</span> <span class="sc-comment">If operand ms bit 1 set n bit</span></span>&#13;
<span>    elif iClass == 3:                      <span class="sc-comment"># Class 3 operation: Two operands.</span></span>&#13;
<span>        if   mode in [4,5,6,11]: op1 = reg[reg1]</span>&#13;
<span>                                           <span class="sc-comment"># Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2</span></span>&#13;
<span>        elif mode in [7,8,12]:   op1 = dMem[reg[reg1]]</span>&#13;
<span>                                           <span class="sc-comment"># Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2</span></span>&#13;
<span>        elif mode in [9,10]:     op1 = lit <span class="sc-comment"># MOV M:12,r3 moves register to memory</span></span>&#13;
<span>        if   mode in [4,11,12]:  op2 = lit <span class="sc-comment"># Mode second operand literal</span></span>&#13;
<span>        elif mode in [5,7,9]:    op2 = reg[reg2]</span>&#13;
<span>                                           <span class="sc-comment"># Modes with second operand contents of register</span></span>&#13;
<span>        elif mode in [6,8,10]:   op2 = dMem[reg[reg2]]</span>&#13;
<span>                                           <span class="sc-comment"># Second operand pointed at by register</span></span>&#13;
<span>        if thisOp == 'MOV' : fun = 0       <span class="sc-comment"># Use mnemonic to get function required by ALU</span></span>&#13;
<span>        if thisOp == 'ADD' : fun = 1       <span class="sc-comment"># ADD and ADC use same function</span></span>&#13;
<span>        if thisOp == 'ADC' : fun = 1</span>&#13;
<span>        if thisOp == 'SUB' : fun = 2</span>&#13;
<span>        if thisOp == 'AND' : fun = 4</span>&#13;
<span>        if thisOp == 'OR'  : fun = 5</span>&#13;
<span>        if thisOp == 'NOT' : fun = 6</span>&#13;
<span>        if thisOp == 'EOR' : fun = 7</span>&#13;
<span>        if thisOp == 'LSL' : fun = 8</span>&#13;
<span>        if thisOp == 'LSR' : fun = 9</span>&#13;
<span>        if thisOp == 'ONES': fun = 10</span>&#13;
<span>        if thisOp == 'MRG' : fun = 11</span>&#13;
<span>        if thisOp == 'FFO' : fun = 12</span>&#13;
<span>        op3 = alu(fun,op1,op2)             <span class="sc-comment"># Call ALU to perform the function</span></span>&#13;
<span>        if   mode in [4,5,6,11]: reg[reg1]       = op3</span>&#13;
<span>                                           <span class="sc-comment"># Writeback ALU result in op3 result to a register</span></span>&#13;
<span>        elif mode in [7,8,12]:   dMem[reg[reg1]] = op3</span>&#13;
<span>                                            <span class="sc-comment"># Writeback result to mem pointed at by reg</span></span>&#13;
<span>        elif mode in [9,10]:     dMem[lit]       = op3</span>&#13;
<span>                                            <span class="sc-comment"># Writeback the result to memory</span></span>&#13;
<span>    trace()                                 <span class="sc-comment"># Display the results line by line</span></span></pre>&#13;
			<h2 id="_idParaDest-143" lang="en-GB"><a id="_idTextAnchor149"/>A sample run of TC3</h2>&#13;
			<p lang="en-GB">Here is the output <a id="_idIndexMarker550"/>from a sample run of TC3. We have provided the source code that is executed, the equate and branch table, the assembled code, and then the output of <span class="No-Break">a run:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB"><span class="No-Break">Source code</span></li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>['MOV', 'R0', '#8']</span>&#13;
<span>['NEXT:', 'RND', 'R5']</span>&#13;
<span>['MOV', '[R0]', 'R5']</span>&#13;
<span>['DEC', 'R0']</span>&#13;
<span>['BNE', 'NEXT']</span>&#13;
<span>['MOV', 'R1', '#X']</span>&#13;
<span>['MOV', 'R2', '#Y']</span>&#13;
<span>['MOV', 'R3', '#Z']</span>&#13;
<span>['MOV', 'R4', '#6']</span>&#13;
<span>['LOOP:', 'MOV', 'R5', '[R1]']</span>&#13;
<span>['ADD', 'R5', '#6']</span>&#13;
<span>['ADD', 'R5', '[R2]']</span>&#13;
<span>['MOV', '[R3]', 'R5']</span>&#13;
<span>['INC', 'R1']</span>&#13;
<span>['INC', 'R2']</span>&#13;
<span>['INC', 'R3']</span>&#13;
<span>['DEC', 'R4']</span>&#13;
<span>['BNE', 'LOOP']</span>&#13;
<span>['STOP', '00', '1111', '0']</span></pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">Equate and <a id="_idIndexMarker551"/><span class="No-Break">branch table</span></li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>X        1</span>&#13;
<span>Y        5</span>&#13;
<span>Z        9</span>&#13;
<span>NEXT     1</span></pre>&#13;
			<pre class="source-code">LOOP     9</pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3"><span class="No-Break">Assembly </span><span class="No-Break"><a id="_idIndexMarker552"/></span><span class="No-Break">loop</span></li>&#13;
			</ol>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>MOV R0 #8    pc=0   110000010000000000001000 Class=3 mode=4 MOV t1=R0 #8</span>&#13;
<span>NEXT: RND R5 pc=1   100010001010100000000000 Class=2 mode=2 RND   t1=R5</span>&#13;
<span>MOV [R0] R5  pc=2   110000011100010100000000 Class=3 mode=7 MOV   t1=[R0]  R5</span>&#13;
<span>DEC R0       pc=3   100001001000000000000000 Class=2 mode=2 DEC   t1=R0</span>&#13;
<span>BNE NEXT     pc=4   010010000100000000000001 Class=1 mode=1 BNE   t1=NEXT</span>&#13;
<span>MOV R1 #X    pc=5   110000010000100000000001 Class=3 mode=4 MOV   t1=R1    #X</span>&#13;
<span>MOV R2 #Y    pc=6   110000010001000000000101 Class=3 mode=4 MOV   t1=R2    #Y</span>&#13;
<span>MOV R3 #Z    pc=7   110000010001100000001001 Class=3 mode=4 MOV   t1=R3    #Z</span>&#13;
<span>MOV R4 #6    pc=8   110000010010000000000110 Class=3 mode=4 MOV   t1=R4   #6</span>&#13;
<span>LOOP: MOV R5 [R1]  pc=9   110000011010100100000000 Class=3 mode=6 MOV   t1=R5    [R1]</span>&#13;
<span>ADD R5 #6    pc=10  110001010010100000000110 Class=3 mode=4 ADD   t1=R5   #6</span>&#13;
<span>ADD R5 [R2]  pc=11  110001011010101000000000 Class=3 mode=6 ADD   t1=R5   R2]</span>&#13;
<span>MOV [R3] R5  pc=12  110000011101110100000000 Class=3 mode=7 MOV   t1=[R3]  R5</span>&#13;
<span>INC R1       pc=13  100000001000100000000000 Class=2 mode=2 INC   t1=R1</span>&#13;
<span>INC R2       pc=14  100000001001000000000000 Class=2 mode=2 INC   t1=R2</span>&#13;
<span>INC R3       pc=15  100000001001100000000000 Class=2 mode=2 INC   t1=R3</span>&#13;
<span>DEC R4       pc=16  100001001010000000000000 Class=2 mode=2 DEC   t1=R4</span>&#13;
<span>BNE LOOP     pc=17  010010000100000000001001 Class=1 mode=1 BNE   t1=LOOP</span>&#13;
<span>STOP 00 1111 0  pc=18  001110000000000000000000 Class=0 mode=0 STOP  t1=00    1111</span></pre>&#13;
			<ol>&#13;
				<li lang="en-GB" value="4"><span class="No-Break">EXECUTE</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We have provided only a few lines of the traced output and reformatted them to fit on the page. </p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; </span>&#13;
<span>MOV R0 #8            pc = 0   110000010000000000001000 </span>&#13;
<span>Class = 3 mode = 4 </span>&#13;
<span>Reg = 08 00 00 00 00 00 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 00 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 0</span>&#13;
<span>NEXT: RND R5         pc = 1   100010001010100000000000 </span>&#13;
<span>Class = 2 mode = 2 </span>&#13;
<span>Reg = 08 00 00 00 00 8f 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 00 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 0</span>&#13;
<span>MOV [R0] R5         pc = 2   110000011100010100000000 </span>&#13;
<span>Class = 3 mode = 7 </span>&#13;
<span>Reg = 08 00 00 00 00 8f 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 8f 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 1</span>&#13;
<span>DEC R0             pc = 3   100001001000000000000000 </span>&#13;
<span>Class = 2 mode = 2 </span>&#13;
<span>Reg = 07 00 00 00 00 8f 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 8f 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 0</span>&#13;
<span>BNE NEXT             pc = 4   010010000100000000000001 </span>&#13;
<span>Class = 1 mode = 1 </span>&#13;
<span>Reg = 07 00 00 00 00 8f 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 8f 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 0</span>&#13;
<span>NEXT: RND R5         pc = 1   100010001010100000000000 </span>&#13;
<span>Class = 2 mode = 2 </span>&#13;
<span>Reg = 07 00 00 00 00 35 00 00 </span>&#13;
<span>Mem = 00 00 00 00 00 00 00 00 8f 00 00 </span>&#13;
<span>C = 0 Z = 0 N = 0</span></pre>&#13;
			<p class="callout-heading" lang="en-GB">Note</p>&#13;
			<p class="callout" lang="en-GB">Output not displayed to <span class="No-Break">save space</span></p>&#13;
			<p lang="en-GB">In the next section, we’ll look at <a id="_idIndexMarker553"/>one component of simulators in greater detail, <span class="No-Break">the ALU.</span></p>&#13;
			<h1 id="_idParaDest-144" lang="en-GB"><a id="_idTextAnchor150"/>Arithmetic and Logic Unit (ALU)</h1>&#13;
			<p lang="en-GB">And now for something different. We have used an ALU in all the simulators. Here, you will learn about <a id="_idIndexMarker554"/>the ALU in greater detail and about <span class="No-Break">its testing.</span></p>&#13;
			<p lang="en-GB">The following Python code demonstrates the implementation of an 8-bit, 16-function ALU. We have added several <em class="italic">contemporary operations</em> that some computers provide, such as modulus, minimum, and maximum. The alu function is called with the <strong class="source-inline">op</strong>, <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, <strong class="source-inline">cIn</strong>, and <strong class="source-inline">display</strong> parameters. The <strong class="source-inline">op</strong> parameter is in the range 0 to 15 and defines the function. The <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> parameters are two 8-bit integers in the range 0 to 255, <strong class="source-inline">cin</strong> is a carry in, and <strong class="source-inline">display</strong> is a flag. When display is <strong class="source-inline">0</strong>, no data is printed. When <strong class="source-inline">display</strong> is <strong class="source-inline">1</strong>, the inputs and results are printed by the function. This feature is <span class="No-Break">for debugging.</span></p>&#13;
			<p lang="en-GB">This code demonstrates the use of Python’s if...elif construct to decode the arithmetic operation. We have also included a <em class="italic">dictionary structure</em> that enables us to print out the operation code by name. In this case, the dictionary is <strong class="source-inline">allOps</strong> and is written <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">AllOps = {0:'clr', 1:'add',2:'sub',3:'mul'}    <span class="sc-comment"># just four entries to make easy reading.</span></pre>&#13;
			<p lang="en-GB">Another feature is that we can easily print data in binary form. The <strong class="source-inline">print(bin(c))</strong> operation prints <strong class="source-inline">c</strong> in binary form. However, because we are using 8-bit arithmetic and wish to see leading zeros, we can force an 8-bit output by using the zfill; that is <span class="No-Break"><strong class="source-inline">print(bin(c).zfill(8))</strong></span><span class="No-Break"> method.</span></p>&#13;
			<p lang="en-GB">Alternatively, we can use <strong class="source-inline">print('Result', format(c,'08b'))</strong> to print the <strong class="source-inline">c</strong> variable as an 8-bit <span class="No-Break">binary string.</span></p>&#13;
			<p lang="en-GB">A Python function can return multiple values as a <em class="italic">tuple</em>. A tuple is a Python list of immutable values that cannot be changed; for example, if you write return (<strong class="source-inline">c</strong>, <strong class="source-inline">z</strong>, <strong class="source-inline">n</strong>, <strong class="source-inline">v</strong> <strong class="source-inline">cOut</strong>), you are returning a tuple that consists of the function we calculated and the <strong class="source-inline">z</strong>, <strong class="source-inline">n</strong>, <strong class="source-inline">v</strong>, and <strong class="source-inline">cOut</strong> flags. These can’t be changed, but they can be assigned to variables in the calling program; take the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>result,Zero,Neg,oVerflow,carry = alu(0,A,B,0,1)</span></pre>&#13;
			<p lang="en-GB">Note the calculation of overflow. The <strong class="source-inline">v-bit</strong> is set if the sign bits of the two operands are the same and the <a id="_idIndexMarker555"/>sign bit of the result is different. Overflow is valid only for addition and subtraction. The modulus function returns a positive value if the input parameter is negative in two’s complement terms. We do this by inverting the bits and <span class="No-Break">adding 1.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># This function simulates an 8-bit ALU and provides 16 operations</span></span>&#13;
<span><span class="sc-comment"># It is called by alu(op,a,b,cIn,display). Op defines the ALU function</span></span>&#13;
<span><span class="sc-comment"># a,b and cIn are the two inputs and the carry in</span></span>&#13;
<span><span class="sc-comment"># If display is 1, the function prints all input and output on the terminal</span></span>&#13;
<span><span class="sc-comment"># Return values: q, z, n, v, cOut) q is the result</span></span>&#13;
<span>def alu(op,a,b,cIn,display):</span>&#13;
<span>    allOps = {0:'clr', 1:'add',2:'sub',3:'mul',4:'div',5:'and',6:'or', \</span>&#13;
<span>              7:'not', 8:'eor', 9:'lsl',10:'lsr', 11:'adc',12:'sbc',   \</span>&#13;
<span>              13:'min',14:'max',15:'mod'}</span>&#13;
<span>    a, b = a &amp; 0xFF, b &amp; 0xFF             <span class="sc-comment"># Ensure the </span><span class="sc-comment">input is 8 bits</span></span>&#13;
<span>    cOut,z,n,v = 0,0,0,0                  <span class="sc-comment"># Clear all </span><span class="sc-comment">status flags</span></span>&#13;
<span>    if   op == 0:   q = 0                 <span class="sc-comment"># Code 0000 clear</span></span>&#13;
<span>    elif op == 1:   q = a + b             <span class="sc-comment"># Code 0001 add</span></span>&#13;
<span>    elif op == 2:   q = a - b             <span class="sc-comment"># Code 0010 </span><span class="sc-comment">subtract</span></span>&#13;
<span>    elif op == 3:   q = a * b             <span class="sc-comment"># Code 0011 </span><span class="sc-comment">multiply</span></span>&#13;
<span>    elif op == 4:   q = a // b            <span class="sc-comment"># Code 0100 </span><span class="sc-comment">divide</span></span>&#13;
<span>    elif op == 5:   q = a &amp; b             <span class="sc-comment"># Code 0100 </span><span class="sc-comment">bitwise AND</span></span>&#13;
<span>    elif op == 6:   q = a | b             <span class="sc-comment"># Code 0100</span><span class="sc-comment">bitwise OR</span></span>&#13;
<span>    elif op == 7:   q = ~a                <span class="sc-comment"># Code 0111 </span><span class="sc-comment">bitwise negate (logical complement)</span></span>&#13;
<span>    elif op == 8:   q = a ^ b             <span class="sc-comment"># Code 0100 </span><span class="sc-comment">bitwise EOR</span></span>&#13;
<span>    elif op == 9:   q = a &lt;&lt; b            <span class="sc-comment"># Code 0100 </span><span class="sc-comment">bitwise logical shift left b places</span></span>&#13;
<span>    elif op == 10:  q = a &gt;&gt; b            <span class="sc-comment"># Code 0100 </span><span class="sc-comment">bitwise logical shift right b places</span></span>&#13;
<span>    elif op == 11:  q = a + b + cIn       <span class="sc-comment"># Code 0100 add </span><span class="sc-comment">with carry in</span></span>&#13;
<span>    elif op == 12:  q = a - b - cIn       <span class="sc-comment"># Code 0100 </span><span class="sc-comment">subtract with borrow in</span></span>&#13;
<span>    elif op == 13:                        <span class="sc-comment"># Code 1101 q = </span><span class="sc-comment">minimum(a,b)</span></span>&#13;
<span>       if a &gt; b: q = b</span>&#13;
<span>       else:     q = a</span>&#13;
<span>    elif op == 14:                        <span class="sc-comment"># Code 1110 </span><span class="sc-comment">q = maximum(a,b)</span></span>&#13;
<span>       if a &gt; b: q = a                    <span class="sc-comment"># Note: in </span><span class="sc-comment">unsigned terms</span></span>&#13;
<span>       else:     q = b</span>&#13;
<span>    elif op == 15:                        <span class="sc-comment"># Code 1111 </span>q = mod(a)</span>&#13;
<span>       if a &gt; 0b01111111: q = (~a+1)&amp;0xFF <span class="sc-comment"># if a is </span><span class="sc-comment">negative q = -a (2s comp)</span></span>&#13;
<span>       else:     q = a                    <span class="sc-comment"># if a is </span><span class="sc-comment">positive q =</span>  <span class="sc-comment">a</span></span>&#13;
<span><strong class="bold"># Prepare to exit: Setup flags</strong></span>&#13;
<span>    cOut = (q&amp;0x100)&gt;&gt;8                   <span class="sc-comment"># Carry out is </span><span class="sc-comment">bit 8</span></span>&#13;
<span>    q    =  q &amp; 0xFF                      <span class="sc-comment"># Constrain </span><span class="sc-comment">result to 8 bits</span></span>&#13;
<span>    n    = (q &amp; 0x80)&gt;&gt;7                  <span class="sc-comment"># AND q with </span><span class="sc-comment">10000000 and shift right 7 times</span></span>&#13;
<span>    if q == 0: z = 1                      <span class="sc-comment"># Set z bit if </span><span class="sc-comment">result zero</span></span>&#13;
<span>    p1 = ( (a&amp;0x80)&gt;&gt;7)&amp; ((b&amp;0x80)&gt;&gt;7)&amp;~((q&amp;0x80)&gt;&gt;7)</span>&#13;
<span>    p2 = (~(a&amp;0x80)&gt;&gt;7)&amp;~((b&amp;0x80)&gt;&gt;7)&amp; ((q&amp;0x80)&gt;&gt;7)</span>&#13;
<span>    if p1 | p2 == True: v = 1             <span class="sc-comment"># Calculate </span><span class="sc-comment">v-bit (overflow)</span></span>&#13;
<span>    if display == 1:                      <span class="sc-comment"># Display </span><span class="sc-comment">parameters and results</span></span>&#13;
<span>       a,b = a&amp;0xFF, b&amp;0xFF               <span class="sc-comment"># Force both </span><span class="sc-comment">inputs to 8 bits</span></span>&#13;
<span>       print('Op =',allOps[op],'Decimals: a =',a,' b =',b, \</span>&#13;
<span>             'cIn =',cIn,'Result =',q)</span>&#13;
<span>       print('Flags: Z =',z, 'N =',n, 'V =',v, 'C =',cOut)</span>&#13;
<span>       print('Binaries A =',format(a,'08b'), 'B =',format(b,'08b'), \</span>&#13;
<span>             'Carry in =',format(cIn,'01b'), 'Result =',format(q,'08b'))</span>&#13;
<span>       print ()</span>&#13;
<span>    return (q, z, n, v, cOut)             <span class="sc-comment"># Return c </span><span class="sc-comment">(result), and flags as a tuple</span></span></pre>&#13;
			<h2 id="_idParaDest-145" lang="en-GB"><a id="_idTextAnchor151"/>Testing the ALU</h2>&#13;
			<p lang="en-GB">We will now demonstrate testing the ALU. A <strong class="source-inline">while</strong> loop is created and two integers are inputted using <a id="_idIndexMarker556"/>Python’s keyboard input function and the <strong class="source-inline">.split()</strong> method to divide the input string into substrings. For example, you can enter add 3 5 to perform the addition of 3 and 5. A null input (i.e., a return) ends <span class="No-Break">the sequence.</span></p>&#13;
			<p lang="en-GB">I have arranged the code so that you can see only the parameters entered as needed for the operation, for example, add 3,7, mod 5, or sbc 3 4 1. To make it easier to test logic functions, you can enter parameters in binary <strong class="source-inline">(%10110</strong>) or hexadecimal <strong class="source-inline">($</strong><span class="No-Break"><strong class="source-inline">3B</strong></span><span class="No-Break">) format.</span></p>&#13;
			<p lang="en-GB">A feature of the <a id="_idIndexMarker557"/>test code is that I use a reverse dictionary. This allows you to enter a function by its name, rather <span class="No-Break">than number.</span></p>&#13;
			<p lang="en-GB">The following is the code I used to test <span class="No-Break">the ALU:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>#### MAIN BODY</span>&#13;
<span>def literal(lit):</span>&#13;
<span>    if   lit.isnumeric(): lit =  int(lit)        <span class="sc-comment"># If </span><span class="sc-comment">decimal convert to integer</span></span>&#13;
<span>    elif lit[0]  == '%': lit =  int(lit[1:],2)   <span class="sc-comment"># If </span><span class="sc-comment">binary string convert to int</span></span>&#13;
<span>    elif lit[0:1]== '$': lit =  int(lit[1:],16)  <span class="sc-comment"># If hex </span><span class="sc-comment">string convert to int</span></span>&#13;
<span>    elif lit[0]  == '-': lit = -int(lit[1:])&amp;0xFF <span class="sc-comment"># If </span><span class="sc-comment">negative convert to signed int</span></span>&#13;
<span>    return(lit)</span>&#13;
<span>opsRev = {'clr':0,'add':1,'sub':2,'mul':3,'div':4,'and':5,'or':6,     \</span>&#13;
<span>          'not':7,'eor':8,'lsl':9,'lsr':10,'adc':11,'sbc':12,         \</span>&#13;
<span>          'min':13,'max':14,'mod':15}</span>&#13;
<span>x,y,op1,op2,cIn = 0,0,0,0,0                      <span class="sc-comment"># Dummy value prior to test in while loop</span></span>&#13;
<span>while True:</span>&#13;
<span>    x = input('Enter operation and values ')</span>&#13;
<span>    if x == '': break                            <span class="sc-comment"># Exit on </span><span class="sc-comment">return</span></span>&#13;
<span>    y = x.split()                                <span class="sc-comment"># Divide </span><span class="sc-comment">into tokens</span></span>&#13;
<span>    print (y)                                    <span class="sc-comment"># Show </span><span class="sc-comment">the input</span></span>&#13;
<span>    fun = opsRev[y[0]]                           <span class="sc-comment"># Convert </span><span class="sc-comment">function name into number</span></span>&#13;
<span>    if len(y) &gt; 1: op1 = literal(y[1])           <span class="sc-comment"># One </span><span class="sc-comment">parameter</span></span>&#13;
<span>    if len(y) &gt; 2: op2 = literal(y[2])           <span class="sc-comment"># Two </span><span class="sc-comment">parameters</span></span>&#13;
<span>    if len(y) &gt; 3: cIn = literal(y[3])           <span class="sc-comment"># Three </span><span class="sc-comment">parameters</span></span>&#13;
<span>    q, z, n, v, cOut  = alu(fun,op1,op2,cIn,1)   <span class="sc-comment"># Call </span><span class="sc-comment">the ALU function</span></span>&#13;
<span>                                                 <span class="sc-comment"># Repeat </span><span class="sc-comment">until return entered</span></span></pre>&#13;
			<p lang="en-GB">Here’s some <a id="_idIndexMarker558"/>sample output from a <span class="No-Break">test run:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Enter operation and values add 25 $1F</span>&#13;
<span>['add', '25', '$1F']</span>&#13;
<span>Operation =  add Decimals: a = 25  b = 31 cIn = 0 Result = 56</span>&#13;
<span>Flags: Z = 0 N = 0 V = 0 C = 0</span>&#13;
<span>Binaries A = 00011001 B = 00011111 Carry in = 0 Result = 00111000</span>&#13;
<span>Enter operation and values add %11111111 1</span>&#13;
<span>['add', '%11111111', '1']</span>&#13;
<span>Operation =  add Decimals: a = 255  b = 1 cIn = 0 Result = 0</span>&#13;
<span>Flags: Z = 1 N = 0 V = 0 C = 1</span>&#13;
<span>Binaries A = 11111111 B = 00000001 Carry in = 0 Result = 00000000</span>&#13;
<span>Enter operation and values add 126 2</span>&#13;
<span>['add', '126', '2']</span>&#13;
<span>Operation =  add Decimals: a = 126  b = 2 cIn = 0 Result = 128</span>&#13;
<span>Flags: Z = 0 N = 1 V = 1 C = 0</span>&#13;
<span>Binaries A = 01111110 B = 00000010 Carry in = 0 Result = 10000000</span>&#13;
<span>Enter operation and values add 7 -2</span>&#13;
<span>['add', '7', '-2']</span>&#13;
<span>Operation =  add Decimals: a = 7  b = 254 cIn = 0 Result = 5</span>&#13;
<span>Flags: Z = 0 N = 0 V = 0 C = 1</span>&#13;
<span>Binaries A = 00000111 B = 11111110 Carry in = 0 Result = 00000101</span>&#13;
<span>Enter operation and values add 128 -2</span>&#13;
<span>['add', '128', '-2']</span>&#13;
<span>Operation =  add Decimals: a = 128  b = 254 cIn = 0 Result = 126</span>&#13;
<span>Flags: Z = 0 N = 0 V = 1 C = 1</span>&#13;
<span>Binaries A = 10000000 B = 11111110 Carry in = 0 Result = 01111110</span>&#13;
<span>Enter operation and values and $A7 %11110001</span>&#13;
<span>['and', '$A7', '%11110001']</span>&#13;
<span>Operation =  and Decimals: a = 167  b = 241 cIn = 0 Result = 161</span>&#13;
<span>Flags: Z = 0 N = 1 V = 0 C = 0</span>&#13;
<span>Binaries A = 10100111 B = 11110001 Carry in = 0 Result = 10100001</span>&#13;
<span>Enter operation and values lsl %11100011 2</span>&#13;
<span>['lsl', '%11100011', '2']</span>&#13;
<span>Operation =  lsl Decimals: a = 227  b = 2 cIn = 0 Result = 140</span>&#13;
<span>Flags: Z = 0 N = 1 V = 0 C = 1</span>&#13;
<span>Binaries A = 11100011 B = 00000010 Carry in = 0 Result = 10001100</span>&#13;
<span>Enter operation and values</span></pre>&#13;
			<h1 id="_idParaDest-146" lang="en-GB"><a id="_idTextAnchor152"/>A final example: TC4</h1>&#13;
			<p lang="en-GB">In this example, we provide <a id="_idIndexMarker559"/>a new simulator that introduces you to some new elements of Python, such as the ability to include the date and time. This final example of a computer simulator brings some of the things we have discussed together and creates a simulator with a 32-bit instruction memory and a 16-bit data memory. Consequently, this is not a von Neumann machine because it has different program and data memories. TC4 incorporates several modifications to demonstrate both simplifications <span class="No-Break">and additions.</span></p>&#13;
			<p lang="en-GB">We’ll present the code <a id="_idIndexMarker560"/>first and then add some comments via the labels that indicate points of interest. Shaded parts of the code have comments following <span class="No-Break">the code:</span></p>&#13;
			<pre><span class="sc-top" lang="en-GB">import re                          <span class="sc-comment"># Library for regular expressions for removing spaces</span>  <span class="sc-comment">(See 1)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">from random import  *              <span class="sc-comment"># Random nu<a id="_idTextAnchor153"/>mber library</span></span>&#13;
<span class="sc-bottom" lang="en-GB">import sys                         <span class="sc-comment"># Operating system call library</span></span>&#13;
<span class="sc-grey" lang="en-GB">from datetime import date          <span class="sc-comment"># Import date function</span>                      <span class="sc-comment">(See 2)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">bPt = []                           <span class="sc-comment"># Breakpoint table (labels and PC values)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">bActive = 0</span>&#13;
<span class="sc-grey" lang="en-GB">today = date.today()               <span class="sc-comment"># Get today's date</span>                         <span class="sc-comment">(See 2)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">print('Simulator', today, '\n')</span>&#13;
<span class="sc-bottom" lang="en-GB">deBug, trace, bActive  = 0, 0, 0   <span class="sc-comment"># Turn off debug, trace and breakpoint modes</span>      <span class="sc-comment"> (See 3)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">x1 = input('D for debug &gt;&gt;&gt; ')     <span class="sc-comment"># Get command input</span></span>&#13;
<span class="sc-bottom" lang="en-GB">if x1.upper() == 'D': deBug = 1    <span class="sc-comment"># Turn on debug mode if 'D' or 'd' entered</span></span>&#13;
<span class="sc-grey" lang="en-GB">x2 = input('T or B')               <span class="sc-comment"># Get command input</span></span>&#13;
<span class="sc-bottom" lang="en-GB">x2 = x2.upper()                    <span class="sc-comment"># Convert to upper-case</span></span>&#13;
<span class="sc-bottom" lang="en-GB">if x2 == 'T': trace = 1            <span class="sc-comment"># Turn on trace mode if 'T' or 't' entered</span></span>&#13;
<span class="sc-grey" lang="en-GB">elif x2 == 'B':                    <span class="sc-comment"># If 'B' or 'b' get breakpoints until 'Q' input </span>         <span class="sc-comment">(See 4)</span></span>&#13;
<span class="sc-grey" lang="en-GB">    next = True</span>&#13;
<span class="sc-grey" lang="en-GB">    bActive = 1                    <span class="sc-comment"># Set breakpoint active mode</span></span>&#13;
<span class="sc-grey" lang="en-GB">    while next == True:            <span class="sc-comment"># Get breakpoint as either label or PC value</span></span>&#13;
<span class="sc-grey" lang="en-GB">        y = input('Breakpoint ')</span>&#13;
<span class="sc-grey" lang="en-GB">        y = y.upper()</span>&#13;
<span class="sc-grey" lang="en-GB">        bPt.append(y)              <span class="sc-comment"># Put breakpoint (upper-case) in table</span></span>&#13;
<span class="sc-grey" lang="en-GB">        if y == 'Q': next = False</span>&#13;
<span class="sc-grey" lang="en-GB">    if deBug == 1:                 <span class="sc-comment"># Display breakpoint table if in debug mode</span></span>&#13;
<span class="sc-grey" lang="en-GB">        print ('\nBreakpoint table')</span>&#13;
<span class="sc-grey" lang="en-GB">        for i in range (0,len(bPt)): print(bPt[i])</span>&#13;
<span class="sc-grey" lang="en-GB">        print()</span>&#13;
<span class="sc-bottom" lang="en-GB">print()</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">memProc()</strong> function deals with <a id="_idIndexMarker561"/>the data memory and allows you to store <a id="_idIndexMarker562"/>data in memory and even ASCII code. This function processes <span class="No-Break">assembler directives:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def memProc(src):                                <span class="sc-comment"># Memory processing</span>   </span>&#13;
<span>    global memPoint, memD                        <span class="sc-comment"># Deal with directives</span></span>&#13;
<span>    for i in range(len(src)):                    <span class="sc-comment"># and remove directives from source code</span></span>&#13;
<span>        if src[i][0] == '.WORD':                 <span class="sc-comment"># Test for .word directive</span></span>&#13;
<span>            lit = get_lit(src[i],2)              <span class="sc-comment"># Get the literal value</span></span>&#13;
<span>            sTab.update({src[i][1]:memPoint})    <span class="sc-comment"># Bind literal name to the memory address</span></span>&#13;
<span>            memD[memPoint] = lit                 <span class="sc-comment"># Store the literal in memory</span></span>&#13;
<span>            memPoint = memPoint + 1              <span class="sc-comment"># Move the memory pointer on one word</span></span>&#13;
<span>        if src[i][0] == '.ASCII':                <span class="sc-comment"># .ASCII: test for an ASCII character</span></span>&#13;
<span>            sTab.update({src[i][1]:memPoint})    <span class="sc-comment"># Bind name to memory address</span></span>&#13;
<span>            character = ord(src[i][2])           <span class="sc-comment"># Convert character to numeric form</span></span>&#13;
<span>            memD[memPoint] = character        <span class="sc-comment"># Store the character in memory as ASCII code</span></span>&#13;
<span>            memPoint = memPoint + 1           <span class="sc-comment"># Move the memory pointer on</span></span>&#13;
<span>        if src[i][0] == '.DSW':               <span class="sc-comment"># Test for .DSW to reserve locations in memory</span></span>&#13;
<span>            sTab.update({src[i][1]:memPoint}) <span class="sc-comment"># Save name in table and bind to memory address</span></span>&#13;
<span>            memPoint = memPoint + int(src[i][2]) <span class="sc-comment"># Move memory pointer by space required</span></span>&#13;
<span>    src = [i  for i in src if i[0] != '.WORD']   <span class="sc-comment"># Remove .word from source</span></span>&#13;
<span>    src = [i  for i in src if i[0] != '.ASCII']  <span class="sc-comment"># Remove .ASCII from source</span></span>&#13;
<span>    src = [i  for i in src if i[0] != '.DSW']    <span class="sc-comment"># Remove .DSW from source</span></span>&#13;
<span>    memD[memPoint] = 'END'                    <span class="sc-comment"># Add terminator to data memory (for display)</span></span></pre>&#13;
			<pre class="source-code">    return(src)</pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">get_reg()</strong> function determines <a id="_idIndexMarker563"/>the number of a register. It first looks in the symbol table to determine whether the name is symbolic. Otherwise, it extracts the register number from <span class="No-Break">the predicate:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def get_reg(pred,p):                     <span class="sc-comment"># Extract a register number from predicate</span></span>&#13;
<span>    reg = pred[p]                        <span class="sc-comment"># Read token p is the predicate</span></span>&#13;
<span>    if reg in sTab:                      <span class="sc-comment"># Check if this is a symbolic name</span></span>&#13;
<span>        reg = sTab.get(reg)              <span class="sc-comment"># If symbolic name read it </span><span class="sc-comment">from symbol table</span></span>&#13;
<span>        reg = int(reg[1:])               <span class="sc-comment"># Convert register name into </span><span class="sc-comment">number</span></span>&#13;
<span>    else: reg = int(reg[1:])             <span class="sc-comment"># If not symbolic name </span><span class="sc-comment">convert name into number</span></span>&#13;
<span>    return(reg)                          <span class="sc-comment"># Otherwise return the register number</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">get_lit()</strong> function extracts <a id="_idIndexMarker564"/>a literal from the predicate. As in the case of register names, it is able to deal with <a id="_idIndexMarker565"/>symbolic values by first looking for the name in the symbol table. If there is no symbolic name, the text is converted into the appropriate integer by observing and dealing with <span class="No-Break">any prefixes:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def get_lit(pred,p):                              <span class="sc-comment"># Extract literal from place p in predicate</span></span>&#13;
<span>    global sTab                                   <span class="sc-comment"># We need the symbol table</span></span>&#13;
<span>    lit = pred[p]                                 <span class="sc-comment"># Read the literal from the predicate</span></span>&#13;
<span>    if lit in sTab:                               <span class="sc-comment"># If literal is in symbol table, look it up</span></span>&#13;
<span>        lit = int(sTab.get(lit))</span>&#13;
<span>    else:                                         <span class="sc-comment"># Convert literal format to an integer</span></span>&#13;
<span>        if   lit[0]   == "%": lit = int(pred[-1][1:],2)   <span class="sc-comment"># If prefix % then binary</span></span>&#13;
<span>        elif lit[0:2] == "0X": lit = int(pred[-1][2:],16)</span>&#13;
<span>                                                     <span class="sc-comment"># If prefix 0X then hexadecimal</span></span>&#13;
<span>        elif lit[0].isnumeric(): lit = int(pred[-1]) <span class="sc-comment"># If numeric get it</span></span>&#13;
<span>        elif lit[0].isalpha(): lit = ord(lit)        <span class="sc-comment"># Convert ASCII character to integer</span></span>&#13;
<span>        elif lit[0:2] == "0X": lit = int(pred[-1][2:],16)</span>&#13;
<span>                                                     <span class="sc-comment"># If prefix 0X then hexadecimal</span></span>&#13;
<span>        else:  lit = 0                               <span class="sc-comment"># Default (error) value 0</span></span>&#13;
<span>    return(lit)</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">display()</strong> function takes care <a id="_idIndexMarker566"/>of displaying data after each instruction has <a id="_idIndexMarker567"/>been executed. In this case, the data values are converted into hexadecimal format and turned <span class="No-Break">into strings:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def display():                                <span class="sc-comment"># Print the state after each instruction</span></span>&#13;
<span>    thisOp = ' '.join(src[pcOld])             <span class="sc-comment"># Join this </span><span class="sc-comment">op-code's tokens into a string</span></span>&#13;
<span>    a =[format(x,'04x') for x in r]           <span class="sc-comment"># Format registers </span><span class="sc-comment">into hex strings</span></span>&#13;
<span>    b = (' ').join(a)                         <span class="sc-comment"># Join the hex strings with </span><span class="sc-comment">a space</span></span>&#13;
<span>    f1 = f'{pcOld:&lt;4}'                        <span class="sc-comment"># Format the PC as a string</span></span>&#13;
<span>    f2 = f'{thisOp:&lt;18}'                      <span class="sc-comment"># Format the instruction to </span><span class="sc-comment">fixed width</span></span>&#13;
<span>    print('PC =',f1,'Reg =',b,'Z =',z,'N =',n,'C =',c,f2)       <span class="sc-comment"># Print the data</span></span></pre>&#13;
			<pre class="source-code">    return()</pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">alu()</strong> function performs <a id="_idIndexMarker568"/>arithmetic operations. This example is very rudimentary and provides only basic operations. Since we have covered ALU elsewhere, it’s not necessary to be comprehensive. You can easily add new <span class="No-Break">functions yourself:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def alu(a,b,f):    <span class="sc-comment"># ALU for addition/subtraction and flag calculation</span>                    <span class="sc-comment">(See 6)</span></span>&#13;
<span><span class="sc-comment"># a and b are the numbers to add/subtract and f the function</span></span>&#13;
<span>    global z,c,n                      <span class="sc-comment"># Make flags global</span></span>&#13;
<span>    z,c,n = 0,0,0                     <span class="sc-comment"># Clear flags initially</span></span>&#13;
<span>    if f == 1: s = a + b              <span class="sc-comment"># f = 1 for add</span></span>&#13;
<span>    if f == 2: s = a - b              <span class="sc-comment"># f = 2 for subtract</span></span>&#13;
<span>    s = s &amp; 0x1FFFF                   <span class="sc-comment"># Constrain result to 17 bits</span></span>&#13;
<span>    if s &gt; 0xFFFF: c = 1              <span class="sc-comment"># Carry set if 17th bit 1</span></span>&#13;
<span>    if 0x8000 &amp; s == 0x8000 : n = 1   <span class="sc-comment"># Bit 15 set to 1 for negative</span></span>&#13;
<span>    if s &amp; 0xFFFF == 0: z = 1         <span class="sc-comment"># Zero flag set to 1 if bits 0-15 all 0</span></span>&#13;
<span>    s = 0xFFFF &amp; s                    <span class="sc-comment"># Ensure 16-bit result</span></span>&#13;
<span>    return(s)</span>&#13;
<span>codes = {"STOP":(0,0),"NOP":(0,1),"RND":(1,4),"BRA":(2,5),"BEQ":(2,6),      \</span>&#13;
<span>         "BNE":(2,7),"MOV":(3,8),"LDRM":(4,9),"LDRL":(4,10),"LDRI":(7,11),  \</span>&#13;
<span>         "LDRI+":(7,12),"STRM":(4,13),"STRI":(7,14),"STRI+":(7,15),         \</span>&#13;
<span>         "ADD":(5,16),"ADDL":(6,17),"SUB":(5,18),"SUBL":(6,19),             \</span>&#13;
<span>         "AND":(5,20),"ANDL":(6,21),"OR":(5,22),"ORL":(6,23), "EOR":(5,24), \</span>&#13;
<span>         "EORL":(6,25),"CMP":(3,26),"CMPL":(4,27),"LSL":(3,28),             \</span>&#13;
<span>         "LSR":(3,29),"ROL":(3,30),"ROR": (3,31), "BSR":(2,32),             \</span>&#13;
<span>         "RTS":(0,33),"PUSH":(1,34),"POP":(1,35),"BL":(2,36),"RL":(0,37),   \</span>&#13;
<span>         "INC":(1,48), "DEC":(1,49), "PRT":(1,3), "BHS": (2,71)}</span>&#13;
<span><span class="sc-comment"># Style Code Format (a,b) where a is the </span><span class="sc-comment"><a id="_idIndexMarker569"/></span><span class="sc-comment">instruction style and b is the actual op-code</span></span>&#13;
<span># 0     <span class="sc-comment">Zero operand</span>              <span class="sc-comment"> </span>STOP</span>&#13;
<span># 1     <span class="sc-comment">Destination register operand</span>    INC  R0</span>&#13;
<span># 2     <span class="sc-comment">Literal operand</span>             <span class="sc-comment"> </span>BEQ  5</span>&#13;
<span># 3     <span class="sc-comment">Two registers: Rd, Rs1</span>         <span class="sc-comment"> </span>MOV  R2,R4</span>&#13;
<span># 4     <span class="sc-comment">Register and literal Rd L</span>       <span class="sc-comment">  </span>LDR  R6,23</span>&#13;
<span># 5     <span class="sc-comment">Three registers: Rd, Rs1, Rs2</span>     <span class="sc-comment">  </span>ADD  R1,R2,R3</span>&#13;
<span># 6     <span class="sc-comment">Two registers, literal Rs, Rd1, L</span>    ADDL R1,R2,9</span>&#13;
<span># 7     <span class="sc-comment">Indexed, Rd, Rs, L</span>            LDRI R4,(R6,8)</span>&#13;
<span># 8     <span class="sc-comment">UNDEFINED</span></span>&#13;
<span>testFile = 'E:/ArchitectureWithPython/TC4_test.txt'  <span class="sc-comment"># Source filename on my computer</span></span>&#13;
<span>with open(testFile) as myFile:        <span class="sc-comment"># Open source file with assembly language program</span></span>&#13;
<span>    lines = myFile.readlines()        <span class="sc-comment"># Read the program into lines</span></span>&#13;
<span>myFile.close()                        <span class="sc-comment"># Close the source file (not actually needed)</span></span>&#13;
<span>lines = [i[0:-1]  for i in lines ]    <span class="sc-comment"># Remove the /n newline from each line of the source code</span></span>&#13;
<span>src = lines                        <span class="sc-comment"># Copy lines to variable scr (i.e., source code)</span></span>&#13;
<span>if deBug == 1:                     <span class="sc-comment"># If in debug mode print the source file</span>           <span class="sc-comment">(See 3)</span></span>&#13;
<span>    print('Debug mode: original source file')</span>&#13;
<span>    for i in range(0,len(src)): print(i, src[i])    <span class="sc-comment"># Listing file</span></span></pre>&#13;
			<p lang="en-GB">Here, we carry out the usual cleaning up of the source text in the assembly language file and prepare the text <a id="_idIndexMarker570"/>for later parsing and analysis. Note that we use a regular expression to remove multiple spaces. This is a feature we do not use in this book, but it is worthwhile investigating if you are doing extensive <span class="No-Break">text processing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for i in range(0,len(src)):              <span class="sc-comment"># Remove comments from source</span></span>&#13;
<span>   src[i] = src[i].split('@',1)[0]       <span class="sc-comment"># Split line on first occurrence of @ and keep first item</span></span>&#13;
<span>src = [i.strip(' ') for i in src ]          <span class="sc-comment"># Remove leading and trailing spaces</span></span>&#13;
<span>src = [i for i in src if i != '']           <span class="sc-comment"># Remove blank lines</span></span>&#13;
<span>src = [i.upper() for i in src]              <span class="sc-comment"># Convert lower- to upper-case</span></span>&#13;
<span>src = [re.sub('+', ' ',i) for i in src ]    <span class="sc-comment"># Remove multiple spaces</span>     1</span>&#13;
<span>src = [i.replace(', ',' ') for i in src]    <span class="sc-comment"># Replace commas space by single space</span></span>&#13;
<span>src = [i.replace('[','') for i in src]      <span class="sc-comment"># Remove [ in register indirect mode</span></span>&#13;
<span>src = [i.replace(']','') for i in src]      <span class="sc-comment"># Remove [</span></span>&#13;
<span>src = [i.replace(',',' ') for i in src]     <span class="sc-comment"># Replace commas by spaces</span></span>&#13;
<span>src = [i for i in src if i[0] != '@']       <span class="sc-comment"># Remove lines with just a comment</span></span>&#13;
<span>src = [i.split(' ')  for i in src]          <span class="sc-comment"># Tokenize</span></span>&#13;
<span>if deBug == 1:                              <span class="sc-comment"># If in debug mode print the source file</span></span>&#13;
<span>    print('\nProcessed source file\n')</span>&#13;
<span>    [print(i) for i in src]</span>&#13;
<span><span class="sc-comment"># Initialize key variables</span></span>&#13;
<span><span class="sc-comment"># memP program memory, memD data memory</span></span>&#13;
<span>sTab = {}                                   <span class="sc-comment"># Set up symbol table for labels and equates</span></span>&#13;
<span>memP = [0] * 64                             <span class="sc-comment"># Define program memory</span></span>&#13;
<span>memD = [0] * 64                             <span class="sc-comment"># Define data memory</span></span>&#13;
<span>memPoint = 0                                <span class="sc-comment"># memPoint points to next free</span>  <span class="sc-comment">location</span></span>&#13;
<span>[sTab.update({i[1]:i[2]}) for i in src if i[0] == '.EQU']</span>&#13;
<span>                                            <span class="sc-comment"># Scan source file and deal with equates</span></span>&#13;
<span>src = [i  for i in src if i[0] != '.EQU']   <span class="sc-comment"># Remove equates from source</span></span>&#13;
<span>src = memProc(src)                          <span class="sc-comment"># Deal with memory-related directives</span></span>&#13;
<span>for i in range (0,len(src)):                <span class="sc-comment"># Insert labels in symbol table</span></span>&#13;
<span>    if src[i][0][-1]== ':': sTab.update({src[i][0][0:-1]:i})</span>&#13;
<span>                                            <span class="sc-comment"># Remove the colon from labels</span></span>&#13;
<span>print('\nSymbol table\n')</span>&#13;
<span>for x,y in sTab.items(): print("{:&lt;8}".format(x),y)    <span class="sc-comment"># Display symbol table</span></span>&#13;
<span>if deBug == 1:</span>&#13;
<span>    print("\nListing with assembly directives removed\n")</span>&#13;
<span>    for i in range(0,len(src)):             <span class="sc-comment"># Step through each line of code</span></span>&#13;
<span>        z = ''                              <span class="sc-comment"># Create empty string for non-labels</span></span>&#13;
<span>        if src[i][0][-1] != ':': z = '        '</span>&#13;
<span>                                            <span class="sc-comment"># Create 8-char empty first spaced</span></span>&#13;
<span>        for j in range(0,len(src[i])):      <span class="sc-comment"># Scan all tokens of instruction</span></span>&#13;
<span>            y = src[i][j]                   <span class="sc-comment"># Get a token</span></span>&#13;
<span>            y = y.ljust(8)                  <span class="sc-comment"># Pad it with spaces with a width of 8 characters</span></span>&#13;
<span>            z = z + y                       <span class="sc-comment"># Add it to the line</span></span>&#13;
<span>        print(str(i).ljust(3),z)            <span class="sc-comment"># Print line number and instruction</span></span>&#13;
<span>if deBug == 1:                              <span class="sc-comment"># Display data memory for debugging</span></span>&#13;
<span>    print("\nData memory")</span>&#13;
<span>    [print(memD[i]) for i in range(0,memPoint+1)]  <span class="sc-comment"># print pre-loaded data in memory</span></span>&#13;
<span>    print()</span>&#13;
<span><span class="sc-comment">#### MAIN ASSEMBLY LOOP</span></span>&#13;
<span>if deBug == 1: print('Assembled instruction\n')    <span class="sc-comment"># If in debug mode print heading</span> <span class="sc-comment">4</span></span></pre>&#13;
			<p lang="en-GB">Now, we execute the code. The program counter is first initialized to 0. Of course, we could have started at <a id="_idIndexMarker571"/>any arbitrary point or even provided assembly language directives to preset the pc. After setting the pc, we read an instruction and <span class="No-Break">parse it.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc = 0</span>&#13;
<span>for pc in range(0,len(src)):</span>&#13;
<span>    rD,rS1,rS2,lit = 0,0,0,0                      <span class="sc-comment"># Initialize operand fields</span></span>&#13;
<span>    if src[pc][0][-1] != ':':                     <span class="sc-comment"># Extract mnemonic and predicate</span></span>&#13;
<span>        mnem  = src[pc][0]</span>&#13;
<span>        if len(src[pc]) &gt; 1: pred = src[pc][1:]   <span class="sc-comment"># Check for single mnemonic only</span></span>&#13;
<span>        else: pred = '[]'                         <span class="sc-comment"># If only mnemonic with no predicate</span></span>&#13;
<span>    else:</span>&#13;
<span>        mnem  = src[pc][1]                        <span class="sc-comment"># For lines with a label</span></span>&#13;
<span>        if len(src[pc]) &gt; 2: pred = src[pc][2:]   <span class="sc-comment"># Get predicate if one exists</span></span>&#13;
<span>        else: pred = '[]'                         <span class="sc-comment"># If only mnemonic, no pred</span></span>&#13;
<span>    if mnem in codes:</span>&#13;
<span>       opFormat = codes.get(mnem)                 <span class="sc-comment"># Read of op-code format of mnemonic</span></span></pre>&#13;
			<pre class="source-code">    else: print('Illegal opcode ERROR, mnem')     <span class="sc-comment"># Display error message</span></pre>&#13;
			<p lang="en-GB">Now, we can use <strong class="source-inline">opFormat</strong> to extract the required parameters from <span class="No-Break">the predicate:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># OP-CODE FORMATS</span>&#13;
<span>    if opFormat[0] == 1:            <span class="sc-comment"># Type 1 single register rD: inc r0</span></span>&#13;
<span>        rD = get_reg(pred,0)</span>&#13;
<span>    if opFormat[0] == 2:            <span class="sc-comment"># Type 2 literal operand: BEQ 24</span></span>&#13;
<span>        lit = get_lit(pred,-1)</span>&#13;
<span>    if opFormat[0] == 3:            <span class="sc-comment"># Type 3 two registers dD, rS1: MOV r3,R0</span></span>&#13;
<span>        rD  = get_reg(pred,0)</span>&#13;
<span>        rS1 = get_reg(pred,1)</span>&#13;
<span>    if opFormat[0] == 4:            <span class="sc-comment"># Type 4 register and literal Rd, lit: LDRL R1,34</span></span>&#13;
<span>        rD  = get_reg(pred,0)</span>&#13;
<span>        lit = get_lit(pred,-1)</span>&#13;
<span>    if opFormat[0] == 5:            <span class="sc-comment"># Type 5 three registers Rd, Rs1 Rs2: ADD</span>  <span class="sc-comment">R1,R2,R3</span></span>&#13;
<span>        rD  = get_reg(pred,0)</span>&#13;
<span>        rS1 = get_reg(pred,1)</span>&#13;
<span>        rS2 = get_reg(pred,2)</span>&#13;
<span>    if opFormat[0] == 6:            <span class="sc-comment"># Type 6 two registers and lit Rd, Rs1 lit: ADD</span>  <span class="sc-comment">R1,R2,lit</span></span>&#13;
<span>        rD  = get_reg(pred,0)</span>&#13;
<span>        rS1 = get_reg(pred,1)</span>&#13;
<span>        lit = get_lit(pred,-1)</span>&#13;
<span>    if opFormat[0] == 7:            <span class="sc-comment"># Type 7 two registers and lit Rd, Rs1 lit: LDR</span>  <span class="sc-comment">R1,(R2,lit)</span></span>&#13;
<span>        rD  = get_reg(pred,0)</span>&#13;
<span>        pred[1] = pred[1].replace('(','')    <span class="sc-comment"># Remove brackets</span></span>&#13;
<span>        pred[2] = pred[2].replace(')','')</span>&#13;
<span>        rS1 = get_reg(pred,1)</span>&#13;
<span>        lit = get_lit(pred,-1)</span>&#13;
<span>    if opFormat[0] == 8:                     <span class="sc-comment"># Type 8 UNDEFINED</span></span>&#13;
<span>        pass</span></pre>&#13;
			<p lang="en-GB">In this example of a simulator, we create the binary code to be executed. The various parameters extracted <a id="_idIndexMarker572"/>from the predicate have to be moved into the appropriate place to create the final binary <span class="No-Break">code, </span><span class="No-Break"><strong class="source-inline">binCode</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    opCd     = opFormat[1] &lt;&lt; 25    <span class="sc-comment"># Move op-code to left-most 7 bits</span></span>&#13;
<span>    rDs      = rD          &lt;&lt; 22    <span class="sc-comment"># Move destination reg into place</span></span>&#13;
<span>    rS1s     = rS1         &lt;&lt; 19    <span class="sc-comment"># Move source reg 1 in place</span></span>&#13;
<span>    rS2s     = rS2         &lt;&lt; 16    <span class="sc-comment"># Move source reg 2 in place</span></span>&#13;
<span>    binCode=opCd|rDs|rS1s|rS2s|lit  <span class="sc-comment"># Assemble the instruction by combining fields</span></span>&#13;
<span>    memP[pc] = binCode              <span class="sc-comment"># Store 32-bit binary code in program memory</span></span>&#13;
<span>    if deBug == 1:                  <span class="sc-comment"># If in debug mode show the binary output of the assembler</span></span>&#13;
<span>        a1 = f'{pc:&lt;4}'             <span class="sc-comment"># Format for the PC (4 chars wide)</span></span>&#13;
<span>        a2 = format(binCode,'032b') <span class="sc-comment"># Create 32-bit binary string for op-code</span></span>&#13;
<span>        a3 = f'{mnem:&lt;5}'           <span class="sc-comment"># Format the mnemonic to 5 places</span></span>&#13;
<span>        a4 = f'{rD:&lt;4}'             <span class="sc-comment"># Format source register to 4 places</span></span>&#13;
<span>        a5 = f'{rS1:&lt;4}'</span>&#13;
<span>        a6 = f'{rS2:&lt;4}'</span>&#13;
<span>        a7 = f'{lit:&lt;6}'</span>&#13;
<span>        print('PC =',a1,a2,a3,a4,a5,a6,a7,src[pc]) <span class="sc-comment"># Assemble items and print them</span></span>&#13;
<span><span class="sc-comment"># CODE EXECUTE LOOP</span></span>&#13;
<span>print('\nExecute code\n')</span></pre>&#13;
			<p lang="en-GB">This block initializes variables, registers, memory, and the stack pointer before we enter the code execution loop. Note that we create a stack with 16 entries. The stack pointer is set to <strong class="source-inline">16</strong>, which is one <a id="_idIndexMarker573"/>below the bottom of the stack. When the first item is pushed, the stack pointer is pre-decremented to <strong class="source-inline">15</strong>, the bottom of the available <span class="No-Break">stack area:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>r = [<a id="_idTextAnchor154"/>0] * 8                                   <span class="sc-comment"># Register set</span></span>&#13;
<span>stack = [0] * 16                              <span class="sc-comment"># stack with 16 locations</span>           <span class="sc-comment">See 7</span></span>&#13;
<span>sp = 16                                       <span class="sc-comment"># stack pointer initialize to bottom of stack +</span> 1</span>&#13;
<span>lr = 0                                        <span class="sc-comment"># link register initialize to 0</span></span>&#13;
<span>run = 1                                       <span class="sc-comment"># run = 1 to execute code</span></span>&#13;
<span>pc = 0                                        <span class="sc-comment"># Initialize program counter</span></span>&#13;
<span>z,c,n = 0,0,0                                 <span class="sc-comment"># Clear flag bits. Only z-bit is used</span></span>&#13;
<span>while run == 1:                               <span class="sc-comment"># Main loop</span></span>&#13;
<span>    instN = memP[pc]                          <span class="sc-comment"># Read instruction</span></span>&#13;
<span>    pcOld = pc                                <span class="sc-comment"># Remember the pc (for printing)</span></span>&#13;
<span>    pc = pc + 1                               <span class="sc-comment"># Point to the next instruction</span></span>&#13;
<span>    op  = (instN &gt;&gt; 25) &amp; 0b1111111           <span class="sc-comment"># Extract the op-code (7 most-significant bits)</span></span>&#13;
<span>    rD  = (instN &gt;&gt; 22) &amp; 0b111               <span class="sc-comment"># Extract the destination register</span></span>&#13;
<span>    rS1 = (instN &gt;&gt; 19) &amp; 0b111               <span class="sc-comment"># Extract source register 1</span></span>&#13;
<span>    rS2 = (instN &gt;&gt; 16) &amp; 0b111               <span class="sc-comment"># Extract source register 2</span></span>&#13;
<span>    lit = (instN      ) &amp; 0xFFFF              <span class="sc-comment"># Extract literal in least-significant 16 bits</span></span>&#13;
<span>    rDc = r[rD]                               <span class="sc-comment"># Read destination register contents)</span></span>&#13;
<span>    rS1c = r[rS1]                             <span class="sc-comment"># Read source register 1 contents</span></span>&#13;
<span>    rS2c = r[rS2]                             <span class="sc-comment"># Read source register 2 contents</span></span></pre>&#13;
			<p lang="en-GB">Here, the instructions <a id="_idIndexMarker574"/>are executed. Note we used an <strong class="source-inline">if</strong> statement for each instruction. This was used during the initial development phase. In practice, an if...elif structure would be <span class="No-Break">more suitable:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># Instruction execution</span></span>&#13;
<span>    if op == 0b0000001:           <span class="sc-comment"># NOP</span>   <span class="sc-comment">Nothing to see here ...</span> <span class="sc-comment">it's NOP so just drop out</span></span>&#13;
<span>        pass</span>&#13;
<span>    if op == 0b0000100:           <span class="sc-comment"># RND</span>     <span class="sc-comment"># RND r0 generates random number in r0</span></span>&#13;
<span>       r[rD] = randint(0,0xFFFF)</span>&#13;
<span>    if op == 0b0000101:           <span class="sc-comment"># BRA</span>     <span class="sc-comment"># Branch to the label or literal. Absolute address</span></span>&#13;
<span>        pc = lit</span>&#13;
<span>    if op == 0b0000110:           <span class="sc-comment"># BEQ</span>     <span class="sc-comment"># Branch on zero flag</span></span>&#13;
<span>        if z == 1: pc = lit</span>&#13;
<span>    if op == 0b0000111:           <span class="sc-comment"># BNE</span>     <span class="sc-comment"># Branch on not zero</span></span>&#13;
<span>        if z != 1: pc = lit<a id="_idTextAnchor155"/></span>&#13;
<span>    if op == 0b1000111:           <span class="sc-comment"># BHS</span>    <span class="sc-comment"># Branch on unsigned higher or same</span>     <span class="sc-comment">(See 8)</span></span>&#13;
<span>        if c == 0 : pc = lit</span>&#13;
<span>    if op == 0b0001000:           <span class="sc-comment"># MOV</span>    <span class="sc-comment"># Copy one register to another</span></span>&#13;
<span>        r[rD] = rS1c</span>&#13;
<span>    if op == 0b0001001:           <span class="sc-comment"># LDRM</span>    <span class="sc-comment"># Load register from address in memory</span></span>&#13;
<span>        r[rD] = memD[lit]</span>&#13;
<span>    if op == 0b0001010:           <span class="sc-comment"># LDRL</span>    <span class="sc-comment"># Load register with a literal</span></span>&#13;
<span>        r[rD] = lit</span>&#13;
<span>    if op == 0b0001011:           <span class="sc-comment"># LDRI</span>    <span class="sc-comment"># Load register indirect with offset; LDRI r1,[r2,4]</span></span>&#13;
<span>        r[rD] = memD[rS1c + lit]</span>&#13;
<span>    if op == 0b0001100:           <span class="sc-comment"># LDRI+</span>   <span class="sc-comment"># Auto-indexed. Increment pointer after use</span> <span class="sc-comment">(See 9)</span></span>&#13;
<span>        r[rD] = memD[rS1c + lit]</span>&#13;
<span>        r[rS1] = rS1c + 1</span>&#13;
<span>    if op == 0b0001101:           <span class="sc-comment"># STRM</span>    <span class="sc-comment">#</span></span>&#13;
<span>        memD[lit] = rDc</span>&#13;
<span>    if op == 0b0001110:           <span class="sc-comment"># STRI</span>     <span class="sc-comment"># Store register indexed</span></span>&#13;
<span>        memD[rS1c + lit] = rDc</span>&#13;
<span>    if op == 0b0001111:           <span class="sc-comment"># STRI+</span>    <span class="sc-comment"># Auto indexed</span></span>&#13;
<span>        memD[rS1c + lit] = rDc</span>&#13;
<span>        r[rS1] = rS1c + 1</span>&#13;
<span>    if op == 0b0010000:           <span class="sc-comment"># ADD</span>     <span class="sc-comment"># r1 = r2 + r3</span></span>&#13;
<span>        r[rD] = alu(rS1c,rS2c,1)</span>&#13;
<span>    if op == 0b0010001:           <span class="sc-comment"># ADDL</span>    <span class="sc-comment"># r1 = r2 + literal</span></span>&#13;
<span>        r[rD] = alu(rS1c,lit,1)</span>&#13;
<span>    if op == 0b0010010:                    <span class="sc-comment"># SUB</span></span>&#13;
<span>        r[rD] = alu(rS1c,rS2c,2)</span>&#13;
<span>    if op == 0b0010011:                    <span class="sc-comment"># SUBL</span></span>&#13;
<span>        r[rD] = alu(rS1c,lit,2)</span>&#13;
<span>    if op == 0b0010100:                    <span class="sc-comment"># AND</span></span>&#13;
<span>        r[rD] = (rS1c &amp; rS2c) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0010101:                    <span class="sc-comment"># ANDL</span></span>&#13;
<span>        r[rD] = (rS1c &amp; lit) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0010110:                    <span class="sc-comment"># OR</span></span>&#13;
<span>        r[rD] = (rS1c | rS2c) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0010111:                    <span class="sc-comment"># ORL</span></span>&#13;
<span>        r[rD] = (rS1c | lit) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0011000:                    <span class="sc-comment"># EOR (XOR)</span></span>&#13;
<span>        r[rD] = (rS1c ^ rS2c) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0011001:                    <span class="sc-comment"># EORL (XORL)</span></span>&#13;
<span>        r[rD] = (rS1c ^ lit) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0011010:                    <span class="sc-comment"># CMP</span></span>&#13;
<span>        diff = alu(rDc,rS1c,2)</span>&#13;
<span>    if op == 0b0011011:                    <span class="sc-comment"># CMPL</span></span>&#13;
<span>        diff = alu(rDc,lit,2)</span>&#13;
<span>    if op == 0b0011100:                    <span class="sc-comment"># LSL</span></span>&#13;
<span>        r[rD] = (rS1c &lt;&lt; 1) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0011101:                    <span class="sc-comment"># LSR</span></span>&#13;
<span>        r[rD] = (rS1c &gt;&gt; 1) &amp; 0xFFFF</span>&#13;
<span>    if op == 0b0011110:                    <span class="sc-comment"># ROL</span></span>&#13;
<span>        bitLost = (rS1c &amp; 0x8000) &gt;&gt; 16</span>&#13;
<span>        rS1c = (rS1c &lt;&lt; 1) &amp; 0xFFFF</span>&#13;
<span>        r[rD] = rS1c | bitLost</span>&#13;
<span>    if op == 0b0011111:                    <span class="sc-comment"># ROR</span></span>&#13;
<span>        bitLost = (rS1c &amp; 0x0001)</span>&#13;
<span>        rS1c = (rS1c &gt;&gt; 1) &amp; 0xFFFF</span>&#13;
<span>        r[rD] = rS1c | (bitLost &lt;&lt; 16)</span></pre>&#13;
			<p lang="en-GB">In the following <a id="_idIndexMarker575"/>code we’ve included stack-based operations for the sake of demonstrating stack usage and <span class="No-Break">for versatility:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if op == 0b0100000:    <span class="sc-comment"># BSR</span></span>&#13;
<span>        sp = sp - 1</span>&#13;
<span>        stack[sp] = pc</span>&#13;
<span>        pc = lit</span>&#13;
<span>    if op == 0b0100001:                    <span class="sc-comment"># RTS</span></span>&#13;
<span>        pc = stack[sp]</span>&#13;
<span>        sp = sp + 1</span>&#13;
<span>    if op == 0b0100010:                    <span class="sc-comment"># PUSH</span>                       (<span class="sc-comment">See 7)</span></span>&#13;
<span>        sp = sp - 1</span>&#13;
<span>        stack[sp] = rDc</span>&#13;
<span>    if op == 0b0100011:                    <span class="sc-comment"># POP</span>                        (<span class="sc-comment">See 7)</span></span>&#13;
<span>        r[rD] = stack[sp]</span>&#13;
<span>        sp = sp + 1</span>&#13;
<span>    if op == 0b0100100:                    <span class="sc-comment"># BL branch with link</span>               <span class="sc-comment">(See 10)</span></span>&#13;
<span>        lr = pc</span>&#13;
<span>        pc = lit</span>&#13;
<span>    if op == 0b0100101:                    <span class="sc-comment"># RL return from link</span></span>&#13;
<span>        pc = lr</span>&#13;
<span>    if op == 0b0110000:                    <span class="sc-comment"># INC</span></span>&#13;
<span>        r[rD] = alu(rDc,1,1)</span>&#13;
<span>    if op == 0b0110001:                    <span class="sc-comment"># DEC</span></span>&#13;
<span>        r[rD] = alu(rDc,1,2)</span>&#13;
<span>    if op == 0b0000011:    <span class="sc-comment"># PRT r0 displays the ASCII character in register r0</span>             <span class="sc-comment">See 11</span></span>&#13;
<span>        character = chr(r[rD])</span>&#13;
<span>        print(character)</span>&#13;
<span>    if op == 0b0000000:                    <span class="sc-comment"># STOP</span></span>&#13;
<span>        run = 0</span>&#13;
<span><span class="sc-comment"># END OF CODE EXECUTION </span><span class="sc-comment"><a id="_idIndexMarker576"/></span><span class="sc-comment">Deal with display</span></span>&#13;
<span>    if bActive ==1:                        <span class="sc-comment"># Are breakpoints active?</span></span>&#13;
<span>        if src[pcOld][0] in bPt:           <span class="sc-comment"># If the current label or mnemonic is in the table</span></span>&#13;
<span>            display()                      <span class="sc-comment"># display the data</span></span>&#13;
<span>        if str(pcOld) in bPt:              <span class="sc-comment"># If the current PC (i.e., pcOld) is in the table display</span></span>&#13;
<span>            display()</span>&#13;
<span>    if trace == 1:                         <span class="sc-comment"># If in trace mode, display registers</span></span>&#13;
<span>        x = input('&lt;&lt; ')                   <span class="sc-comment"># Wait for keyboard entry (any key will do)</span></span>&#13;
<span>        display()                          <span class="sc-comment"># then display current operation</span></span>&#13;
<span>    elif bActive != 1: display()           <span class="sc-comment"># If not trace and not breakpoints, display registers</span></span>&#13;
<span>    if run == 0:                           <span class="sc-comment"># Test for end of program</span>             <span class="sc-comment">See 12</span></span>&#13;
<span>        print('End of program')            <span class="sc-comment"># If end, say 'Goodbye'</span></span>&#13;
<span>        sys.exit()                         <span class="sc-comment"># and return</span></span></pre>&#13;
			<h2 id="_idParaDest-147" lang="en-GB"><a id="_idTextAnchor156"/>Comments on TC4</h2>&#13;
			<p lang="en-GB">We have not <a id="_idIndexMarker577"/>provided a detailed discussion of this program because it follows the same pattern as earlier simulators. However, we have highlighted some of its principal features. The following numbers correspond to the numbers (at the end of the comment field) in the shaded lines of <span class="No-Break">the code:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB">Call regular expressions library. This is a library that handles regular expressions that offer a very powerful means of processing text. In this example, we use only one simple example of regular <span class="No-Break">text processing.</span></li>&#13;
				<li lang="en-GB">The <strong class="source-inline">src = [re.sub(' +', ' ',i) for i in src ]</strong> Python expression uses a regular expression to remove multiple spaces from a text string. We have included this to point you in the direction of regular expressions for more sophisticated <span class="No-Break">text manipulation.</span></li>&#13;
				<li lang="en-GB">The <strong class="source-inline">from datetime import date</strong> operation imports a method date from datetime that can be used to display the date and time. This is useful for labeling your output during <span class="No-Break">a run.</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">TC4 has an optional debugging facility. We can select three options. Entering ‘D’ provides a debugging facility by printing the source program as it is processed. We can see the original source code, the source code without comments and assembly directives, and the processed version, which includes the binary output after assembly. The ‘T’ option provides a line-by-line trace function that executes a line <a id="_idIndexMarker578"/>of code each time the <em class="italic">Enter</em> key is pressed. The ‘B’ option supports breakpoints where the output is printed only at a breakpoint. The breakpoint may be a label, a mnemonic, or the PC value. Note that in breakpoint mode, only breakpoint lines <span class="No-Break">are displayed.</span></li>&#13;
				<li lang="en-GB">Entering <strong class="source-inline">T</strong> or <strong class="source-inline">B</strong> at the prompt can be used to set up a trace mode or enter instructions or PC values into the breakpoint table. Unusually, this is performed once at the beginning of the program and not during the <span class="No-Break">execution phase.</span></li>&#13;
				<li lang="en-GB">The function processes the source code and deals with assembly directives related to setting up the data memory, for example, loading data values with the <strong class="source-inline">.WORD</strong> directive. It also supports storing an ASCII character in memory and reserving a named memory location <span class="No-Break">for data.</span></li>&#13;
				<li lang="en-GB">The most important directive is <strong class="source-inline">.WORD</strong>, which stores a numeric value in memory and gives that address a symbolic value. For example, if the next free data memory location were <strong class="source-inline">20</strong>, then the<strong class="source-inline">.WORD TIME 100</strong> expression would store the number <strong class="source-inline">100 </strong>at memory location <strong class="source-inline">20</strong> and bind the name <strong class="source-inline">time</strong> to <strong class="source-inline">100</strong>. The<strong class="source-inline">.DSW</strong> (define storage word) directive simply reserves memory locations for future data access and names the address of the first location; for example, if the current memory location is <strong class="source-inline">10</strong>, then <strong class="source-inline">.DSW XYZ 5</strong> frees five memory locations (<strong class="source-inline">10</strong>, <strong class="source-inline">11</strong>, <strong class="source-inline">12</strong>, <strong class="source-inline">13</strong>, and <strong class="source-inline">14</strong>) and binds the names <strong class="source-inline">XYZ</strong> to <strong class="source-inline">10</strong>. The memory pointer is moved to <strong class="source-inline">15</strong>, the next free location. The <strong class="source-inline">memPoint</strong> variable is the memory pointer that keeps track of where data is to be stored in data memory during the assembly phase. The <strong class="source-inline">.ASCII</strong> directive is there for demonstration purposes. The <strong class="source-inline">.ASCII PQR</strong> directive would store the ASCII code for the character <strong class="source-inline">'T'</strong> <span class="No-Break">in memory.</span></li>&#13;
				<li lang="en-GB">These directives are removed from the source code after they have done <span class="No-Break">their job.</span></li>&#13;
				<li lang="en-GB">We have created <a id="_idIndexMarker579"/>a very simple ALU that implements only add and subtract. This was done to keep the program small and concentrate on more interesting instructions in this final example. Simple logic operations are directly implemented in the code execution of the program, in the style </li>&#13;
			</ol>&#13;
			<p lang="en-GB"><strong class="source-inline">if thisOpcode == 'AND': result = a &amp; b</strong>.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="10">TC4 provides several stack operations (push and pull). We initially create a separate stack. TC4’s stack does not use the data memory. This feature is for demonstration and can <span class="No-Break">be expanded.</span></li>&#13;
				<li lang="en-GB">Real computers normally contain a far wider range of conditional branches than we have in this book. Here, we demonstrate one such branch operation, <strong class="source-inline">BHS</strong>, which means branch if higher or same. This operation forces a branch if two values are compared and <strong class="source-inline">x</strong> &gt; <strong class="source-inline">y</strong> or <strong class="source-inline">x</strong> = <strong class="source-inline">y</strong>. Note that this applies to unsigned numbers (i.e., not two’s complement). This condition is met if the carry bit, <strong class="source-inline">c</strong>, is <strong class="source-inline">0</strong> after a comparison. <strong class="source-inline">BHS</strong> and <strong class="source-inline">BCC</strong> (branch on carry 0) are synonyms. For example, if <strong class="source-inline">x = 1000</strong> and <strong class="source-inline">y = 0100</strong>, <strong class="source-inline">x</strong> &gt; <strong class="source-inline">y</strong> if the numbers are unsigned (4 &gt; -8) and y &gt; <strong class="source-inline">x</strong> (8 &gt; 4) if the numbers <span class="No-Break">are signed.</span></li>&#13;
				<li lang="en-GB">The <strong class="source-inline">LDRI+</strong> operation performs a pointer-based load register operation and then increments the <span class="No-Break">pointer register.</span></li>&#13;
				<li lang="en-GB">We have provided an interesting branch and return operation like that of the ARM’s branch with link. The <strong class="source-inline">BL</strong> operation jumps to a target address and saves the return address in a special register called the link register, <strong class="source-inline">rl</strong>. At the end of the subroutine, the <strong class="source-inline">RL</strong> (return from link) instruction returns to the instruction after the call. This mechanism allows only one call, because a second call would overwrite the <a id="_idIndexMarker580"/>return address in the <span class="No-Break">link register.</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">To demonstrate direct printing, the <strong class="source-inline">PRT</strong> operation displays the character corresponding to the ASCII code in the register; for example, if R1 contains 0x42, the <strong class="source-inline">PRT R2</strong> operation would display <strong class="source-inline">B</strong> on <span class="No-Break">the console.</span></li>&#13;
				<li lang="en-GB">When the program has been executed, the <strong class="source-inline">sys.exit()</strong> library function exits <span class="No-Break">the program.</span></li>&#13;
				<li lang="en-GB">Here’s an example of code that can be executed by TC4. It’s been badly set out in order to test TC4’s ability to <span class="No-Break">process text:</span>&#13;
<pre class="source-code">&#13;
<span class="sc-comment">@ TC4_test</span>&#13;
<span class="sc-comment">@ 31 Oct 2021</span>&#13;
<span>      .equ abc 4</span>&#13;
<span>.word aaa abc</span>&#13;
<span>.word bbb 5</span>&#13;
<span>.dsw   dataA 6             <span class="sc-comment">@ data area to store numbers</span></span>&#13;
<span>.word  end 0xFFFF</span>&#13;
<span> ldrl r0,0xF</span>&#13;
<span> addl r1,r7,2</span>&#13;
<span> bl lk</span>&#13;
<span>back: rnd r0</span>&#13;
<span>       ldrl r3,dataA       <span class="sc-comment">@ r3 points at data area</span></span>&#13;
<span>       ldrm r4,bbb         <span class="sc-comment">@ r4 contains value to store</span></span>&#13;
<span> ldrl r5,4                 <span class="sc-comment">@number of words to store</span></span>&#13;
<span>loop: nop                  <span class="sc-comment">@</span></span>&#13;
<span>      bsr sub1</span>&#13;
<span>      dec r5</span>&#13;
<span> bne loop</span>&#13;
<span> stop</span>&#13;
<span>sub1: stri r4,[r3,0]</span>&#13;
<span>   inc r3</span>&#13;
<span>   addl r4,r4,2</span>&#13;
<span>   cmpl r4,9</span>&#13;
<span>   bne skip</span>&#13;
<span>   addl r4,r4,6</span>&#13;
<span>skip:  rts</span>&#13;
<span>lk: ldrl r6,%11100101</span>&#13;
<span>        andl r7,r6,0xF0</span>&#13;
<span> rl</span></pre></li>&#13;
			</ol>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This example ends <a id="_idIndexMarker581"/>the section of this book on designing simulators in Python. In the next part, we’ll look at a <span class="No-Break">real computer.</span></p>&#13;
			<h1 id="_idParaDest-148" lang="en-GB"><a id="_idTextAnchor157"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we have extended our overview of simulator design. We started with one of the simplest simulators of them all, the <em class="italic">zero-address machine</em>; that is, the <em class="italic">stack computer</em>, TC0. This simulator is not a true computer, because it does not include conditional and branch operations. However, it demonstrates the use of the stack as a means of performing <span class="No-Break">chained calculations.</span></p>&#13;
			<p lang="en-GB">We then looked at the instruction set architecture (IAS) of a classic 8-bit computer, with its simple one-address instruction format, where all operations are applied to a single accumulator (i.e., register) and the contents of a memory location or <span class="No-Break">a literal.</span></p>&#13;
			<p lang="en-GB">The one-address machine is followed by the simulation of a multi-register CISC ISA that allows operations between two registers or between a register and the contents of a memory location. The simulator we developed had a 22-bit address just to demonstrate that you can have instructions of <span class="No-Break">any width.</span></p>&#13;
			<p lang="en-GB">We also looked at the simulator of an ALU to further demonstrate the way in which arithmetic operations can <span class="No-Break">be simulated.</span></p>&#13;
			<p lang="en-GB">Finally, we presented a register-to-register machine with separate data and <span class="No-Break">instruction memories.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we’ll change course and introduce the ARM-based Raspberry Pi microprocessor, which can be used to write programs in Python, and learn how to program a real 32-bit ARM microprocessor in <span class="No-Break">assembly language.</span></p>&#13;
		</div>&#13;
	</div></body></html>