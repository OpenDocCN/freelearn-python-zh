- en: <st c="0">7</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Using Non-Relational Data Storage</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="35">Most applications that use voluminous or big data, and continuously
    increase every user transaction, do not use relational databases for storage.</st>
    <st c="182">Applications such as scientific information management systems, sales-related
    applications, stocks and investment-related software, and location finders are
    some applications that may utilize data from various types of data structures,
    such as objects, lists, dictionaries, and bytes.</st> <st c="467">This data can
    be structured (for example, Excel-formatted medical records and CSV-formatted
    location data), semi-structured (for example, XML data of sales inventory and
    emails), and non-structured (for example, images, videos, social media postings,
    and Word documents).</st> <st c="739">Relational databases do not have the support
    to manage this data, but</st> **<st c="809">NoSQL</st>** <st c="814">databases
    do.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="828">NoSQL, which stands for</st> **<st c="853">Not Only SQL</st>**<st
    c="865">, is a schemaless form</st> <st c="887">of data storage that has no concepts
    of rows and columns to hold records of information.</st> <st c="977">Like any
    framework, Flask, when used to build big data applications, can support access
    to these non-relational databases to manage data for data mining, modeling, analytics,
    and</st> <st c="1156">graphical projections.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1178">The main goal of this chapter is to showcase how to install and
    configure the different NoSQL databases and how a Flask application can connect
    to these databases and perform</st> **<st c="1354">INSERT</st>**<st c="1360">,</st>
    **<st c="1362">UPDATE</st>**<st c="1368">,</st> **<st c="1370">DELETE</st>**<st
    c="1376">, and</st> **<st c="1382">QUERY</st>** <st c="1387">transactions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1401">This chapter will cover the following topics – this will provide
    you with an initial step toward building big data applications</st> <st c="1530">with
    Flask:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1541">Managing non-relational data using</st> <st c="1577">Apache HBase</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1589">Utilizing the column storage of</st> <st c="1622">Apache Cassandra</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1638">Storing search data</st> <st c="1659">in Redis</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1667">Handling BSON-based documents</st> <st c="1698">with MongoDB</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1710">Managing key-based JSON documents</st> <st c="1745">with Couchbase</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1759">Establishing a data relationship</st> <st c="1793">with Neo4J</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1803">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1826">This chapter highlights a</st> *<st c="1853">Tutor Finder</st>*
    <st c="1865">application that accepts students and tutor profiles.</st> <st c="1920">The
    application’s main objective is to provide a platform for vying students looking
    for personal tutors or trainers with different expertise.</st> <st c="2063">Aside
    from profiling, it has a</st> *<st c="2094">payment module</st>* <st c="2108">for
    students to pay their tutor’s fees based on payment modes,</st> *<st c="2172">course
    modules</st>* <st c="2186">for course details, and</st> *<st c="2211">search modules</st>*
    <st c="2225">to find the appropriate tutor and student profiles.</st> <st c="2278">The
    application is unique and experimental because it showcases all the NoSQL databases
    as its backend storage to serve as a specimen for this chapter.</st> <st c="2430">On
    the other hand, the application utilizes the</st> *<st c="2478">factory pattern</st>*
    <st c="2493">as its main project structure design.</st> <st c="2532">All files
    are available</st> <st c="2556">at</st> [<st c="2559">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07)<st
    c="2640">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2641">Managing non-relational data using Apache HBase</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2689">One of the</st> <st c="2700">most popular</st> <st c="2713">NoSQL
    databases is the</st> `<st c="3208">byte[]</st>` <st c="3214">type.</st> <st c="3221">This</st>
    `<st c="3226">byte[]</st>` <st c="3232">data is handled by the column families,
    which are composed of</st> *<st c="3295">column qualifiers</st>* <st c="3312">or</st>
    *<st c="3316">columns</st>*<st c="3323">, each stored in a</st> *<st c="3342">cell</st>*<st
    c="3346">. Each column qualifier addresses one</st> *<st c="3384">data field</st>*
    <st c="3394">with a</st> *<st c="3402">timestamp</st>* <st c="3411">that keeps
    track of the versions of each column field in</st> <st c="3469">every update.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3482">Regarding column-oriented databases, this chapter will concentrate
    solely on integrating Apache HBase into our Flask application.</st> <st c="3613">Initially,
    like any database, we’ll design the HBase tables first before integrating them</st>
    <st c="3703">into Flask.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3714">Designing HBase tables</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3737">One of the leverages of using</st> <st c="3767">relational databases
    is the availability of many design tools that can assist us with planning and
    organizing the table schema using different normalization levels.</st> <st c="3933">Only
    a few data modeling</st> <st c="3957">tools, such as</st> `<st c="4168">payments</st>`
    <st c="4176">and</st> `<st c="4181">bookings</st>` <st c="4189">HBase tables using
    the UML class diagramming approach.</st> *<st c="4245">Figure 7</st>**<st c="4253">.1</st>*
    <st c="4255">shows the UML design for the</st> `<st c="4285">payments</st>` <st
    c="4293">and</st> `<st c="4298">bookings</st>` <st c="4306">tables:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – HBase table design for payments and bookings](img/B19383_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4372">Figure 7.1 – HBase table design for payments and bookings</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4429">The</st> `<st c="4434">payments</st>` <st c="4442">and</st> `<st
    c="4447">bookings</st>` <st c="4455">contexts signify the two tables of the HBase
    database.</st> <st c="4511">The</st> `<st c="4515">payments</st>` <st c="4523">table
    has two column families, namely</st> `<st c="4562">PaymentDetails</st>` <st c="4576">and</st>
    `<st c="4581">PaymentItems</st>`<st c="4593">. The</st> `<st c="4599">bookings</st>`
    <st c="4607">table has one column</st> <st c="4629">family,</st> `<st c="4637">BookingDetails</st>`<st
    c="4651">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4652">Note that</st> `<st c="4663">PaymentDetails</st>` <st c="4677">has</st>
    `<st c="4682">id</st>`<st c="4684">,</st> `<st c="4686">stud_id</st>`<st c="4693">,</st>
    `<st c="4695">tutor_id</st>`<st c="4703">,</st> `<st c="4705">ccode</st>`<st c="4710">,
    and</st> `<st c="4716">fee</st>` <st c="4719">as column qualifiers, while</st>
    `<st c="4748">PaymentItems</st>` <st c="4760">has</st> `<st c="4765">id</st>`<st
    c="4767">,</st> `<st c="4769">receipt_id</st>`<st c="4779">, and</st> `<st c="4785">amount</st>`<st
    c="4791">. Furthermore,</st> `<st c="4806">BookingDetails</st>` <st c="4820">has</st>
    `<st c="4825">id</st>`<st c="4827">,</st> `<st c="4829">tutor_id</st>`<st c="4837">,</st>
    `<st c="4839">stud_id</st>`<st c="4846">, and</st> `<st c="4852">date_booked</st>`
    <st c="4863">columns.</st> <st c="4873">A sample record in JSON format will look</st>
    <st c="4914">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5302">The actual name of the column qualifier, when accessed via the
    Flask app, is a</st> *<st c="5382">concatenation</st>* <st c="5395">of the column
    family and the column name itself.</st> <st c="5445">An example from the given
    record</st> <st c="5478">is</st> `<st c="5481">details:stud_id</st>`<st c="5496">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5497">Now that we’ve designed</st> <st c="5521">the table structure,
    let’s look at how we can install and configure the Apache HBase and Apache Hadoop
    platforms.</st> <st c="5636">We’ll start by</st> <st c="5651">using Java.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5662">Setting up the baseline requirements</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5699">Apache HBase is a Java-based platform, and all</st> <st c="5746">its
    components</st> <st c="5761">depend on</st> `<st c="5933">JAVA_HOME</st>` <st
    c="5942">system environment variable in your Windows, Linux, or macOS environment
    and update</st> `<st c="6027">CLASSPATH</st>` <st c="6036">to help HBase access
    the JDK commands in Java’s</st> `<st c="6085">/bin</st>` <st c="6089">folder so
    that it can perform server startup and</st> <st c="6139">shutdown operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6159">Since Apache HBase</st> <st c="6178">is a distributed storage that
    uses</st> `<st c="6255">hadoop-3.3.6/hadoop-3.3.6.tar.gz</st>` <st c="6287">file
    from</st> [<st c="6298">https://hadoop.apache.org/releases.html</st>](https://hadoop.apache.org/releases.html)
    <st c="6337">and unzip it to the same local drive where the HBase installation
    folder is.</st> <st c="6415">Create a</st> `<st c="6424">HADOOP_HOME</st>` <st
    c="6435">file and update the</st> `<st c="6456">CLASSPATH</st>` <st c="6465">variable
    of the operating system to make the Hadoop</st> `<st c="6518">/bin</st>` <st c="6522">commands
    available to HBase during startup.</st> <st c="6567">Let’s have a brief look at
    the Apache Hadoop framework to understand</st> <st c="6636">this better.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6648">Configuring Apache Hadoop</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6674">Apache Hadoop is a Java-based</st> <st c="6704">framework that
    manages scalable big data processing across a distributed cluster setup.</st>
    <st c="6793">It is popular due to its</st> *<st c="6818">MapReduce</st>* <st c="6827">algorithm,
    which performs data processing in parallel across cluster(s) of nodes, making
    the framework’s distributed operations fast.</st> <st c="6962">Moreover, the</st>
    <st c="6975">framework has</st> **<st c="6990">HDFS</st>** <st c="6994">a filesystem.</st>
    <st c="7009">This is where it contains the input and</st> <st c="7049">output
    datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7065">The</st> *<st c="7070">MapReduce</st>* <st c="7079">process starts
    with these big</st> <st c="7109">datasets being stored in HDFS by the Flask application.</st>
    <st c="7166">They’re passed through the internal Hadoop servers, which run the</st>
    `<st c="7232">Map()</st>` <st c="7237">function to break down this data into tuples
    of key-value pairs.</st> <st c="7303">Then, these groups of key-value data blocks
    undergo another process called</st> `<st c="7378">Reduce()</st>`<st c="7386">,
    which is performed by other Hadoop servers.</st> <st c="7432">This exposes these
    data blocks to various reduce functions, such as summation, averaging, concatenation,
    compression, ordering, and shuffling, and then saves them as output datasets</st>
    <st c="7614">in HDFS.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7622">Aside from the</st> *<st c="7638">MapReduce</st>* <st c="7647">distributed
    data process, HBase needs Hadoop’s HDFS because of the high latency batch processing
    operations it gives to the HBase platform.</st> <st c="7788">In return, HBase
    enables read/write transactions to access the data stored in HDFS and can provide
    a thrift server so that third-party applications can access the</st> <st c="7951">big
    datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7964">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7979">A</st> *<st c="7982">thrift server</st>* <st c="7995">is a Hive-compatible</st>
    <st c="8017">interface in HBase that enables multi-language support, allowing
    applications developed in Python, Java, C#, C++, NodeJS, Go, PHP, and JavaScript
    to access big data.</st> <st c="8183">The term</st> *<st c="8192">Hive</st>*<st
    c="8196">, on the other</st> <st c="8211">hand, refers to a client application
    that runs on top of Hadoop and has powerful SQL utilities that are used to implement
    CRUD operations for</st> <st c="8353">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8368">Here’s the step-by-step procedure to set up a Hadoop platform with
    a</st> <st c="8438">single-node cluster:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8458">Go to the installation folder of</st> *<st c="8492">Apache Hadoop
    3.3.6</st>* <st c="8511">and open</st> `<st c="8521">/etc/hadoop/core-site.xml</st>`<st
    c="8546">. Then, set the</st> `<st c="8562">fs.defaultFS</st>` <st c="8574">property.</st>
    <st c="8585">This indicates the default location of</st> *<st c="8624">NameNode</st>*
    <st c="8632">(master node) in the cluster – in our case, the default</st> <st
    c="8688">filesystem.</st> <st c="8701">Its value is a URL address to which</st>
    *<st c="8737">DataNode</st>* <st c="8745">(slave node) will send a heartbeat.</st>
    *<st c="8782">NameNode</st>* <st c="8790">contains the metadata of the data stored
    in HDFS, while</st> *<st c="8847">DataNode</st>* <st c="8855">contains the big
    datasets.</st> <st c="8883">Here is our</st> `<st c="8895">core-site.xml</st>`
    <st c="8908">file:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9033">Inside the same installation folder, create a custom folder called</st>
    `<st c="9101">data</st>` <st c="9105">with two sub-folders called</st> `<st c="9134">datanode</st>`
    <st c="9142">and</st> `<st c="9147">namenode</st>`<st c="9155">, as shown in</st>
    *<st c="9169">Figure 7</st>**<st c="9177">.2</st>*<st c="9179">. These folders
    will eventually contain the configuration files of</st> *<st c="9246">DataNode</st>*
    <st c="9254">and</st> *<st c="9259">NameNode</st>*<st c="9267">, respectively:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The DataNode and NameNode config folders](img/B19383_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="9388">Figure 7.2 – The DataNode and NameNode config folders</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9441">Next, open</st> `<st c="9453">/etc/hadoop/hdfs-site.xml</st>` <st
    c="9478">and declare the newly created</st> `<st c="9509">datanode</st>` <st c="9517">and</st>
    `<st c="9522">namenode</st>` <st c="9530">folders as the final config locations
    of their respective nodes.</st> <st c="9596">Also, set the</st> `<st c="9610">dfs.replication</st>`
    <st c="9625">property to</st> `<st c="9638">1</st>` <st c="9639">since we only
    have a single node</st> <st c="9673">cluster for our</st> *<st c="9689">Tutor
    Finder</st>* <st c="9701">project.</st> <st c="9711">Here is our</st> `<st c="9723">hdf-site.xml</st>`
    <st c="9735">file:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10125">Since our project will use Hadoop installed in Windows, download
    the</st> `<st c="10195">hadoop-3.3.6-src.tar.gz</st>` <st c="10218">file from</st>
    `<st c="10229">https://hadoop.apache.org/releases.html</st>` <st c="10268">and
    compile the Hadoop source files using Maven to generate Hadoop binaries for Windows,
    such as</st> `<st c="10366">winutils.exe</st>`<st c="10378">,</st> `<st c="10380">hadoop.dll</st>`<st
    c="10390">, and</st> `<st c="10396">hdfs.dll</st>`<st c="10404">. Drop these files
    into the</st> `<st c="10432">/</st>``<st c="10433">bin</st>` <st c="10436">folder.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="10444">Format the new active</st> *<st c="10467">NameNode</st>*<st c="10475">(s)
    by running the following command at the</st> <st c="10520">command line:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10555">This command will clean up the</st> *<st c="10587">NameNode</st>*<st
    c="10595">(s) if they have existing</st> <st c="10622">stored metadata.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10638">Now, we can start setting</st> <st c="10664">up a version of Apache
    HBase that’s compatible with Apache</st> <st c="10724">Hadoop 3.3.6.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10737">Configuring Zookeeper and Apache HBase</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10776">Apache HBase depends</st> <st c="10797">on Apache Zookeeper</st>
    <st c="10817">when running its clusters, so the next step is to install and configure
    a Zookeeper server.</st> **<st c="10910">Apache Zookeeper</st>** <st c="10926">is
    a high-performance service that manages distributed and cloud-based applications
    by providing synchronization and centralized services and maintains details of
    these applications.</st> <st c="11110">Note that this project utilizes Zookeeper
    bundled with HBase, so you shouldn’t install Zookeeper separately unless the setup
    involves</st> <st c="11244">multiple clusters.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11262">Now, download</st> *<st c="11277">Apache HBase 2.5.5</st>*<st
    c="11295">, the most compatible HBase distribution, to Apache Hadoop 3.3.6\.</st>
    <st c="11361">Unzip it to the folder where Hadoop resides.</st> <st c="11406">Then,
    configure HBase by performing the</st> <st c="11446">following steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11462">First, create an</st> `<st c="11480">HBASE_HOME</st>` <st c="11490">system
    environment variable that registers the HBase</st> <st c="11544">installation
    folder.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="11564">Create two folders inside the installation folder,</st> `<st c="11616">hbase</st>`
    <st c="11621">and</st> `<st c="11626">zookeeper</st>`<st c="11635">. These will
    serve as the root folders of HBase and the built-in Zookeeper</st> <st c="11710">server,
    respectively.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="11731">Inside the installation folder, open</st> `<st c="11769">/conf/hbase-site.xml</st>`<st
    c="11789">. Here, set the</st> `<st c="11805">hbase.rootdir</st>` <st c="11818">property
    so that it points to the</st> `<st c="11853">hbase</st>` <st c="11858">folder
    and the</st> `<st c="11874">hbase.zookeeper.property.dataDir</st>` <st c="11906">property
    so that it points to the</st> `<st c="11941">zookeeper</st>` <st c="11950">folder.</st>
    <st c="11959">Now, register the</st> `<st c="11977">hbase.zookeeper.quorum</st>`
    <st c="11999">property.</st> <st c="12010">This will indicate the Zookeeper server’s
    host.</st> <st c="12058">Then, set the</st> `<st c="12072">hbase.cluster.distributed</st>`
    <st c="12097">property.</st> <st c="12108">This will specify the type of HBase
    server setup.</st> <st c="12158">The following is our</st> `<st c="12179">hbase-site.xml</st>`
    <st c="12193">file:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="12744">Next, open</st> `<st c="12756">/bin/hbase.cmd</st>` <st c="12770">if
    you’re on Windows and search for the</st> `<st c="12811">java_arguments</st>`
    <st c="12825">property.</st> <st c="12836">Remove</st> `<st c="12843">%HEAP_SETTINGS%</st>`
    <st c="12858">so that the new statement will be</st> <st c="12893">as follows:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="12995">Open</st> `<st c="13001">/conf/hbase-env.cmd</st>` <st c="13020">and
    add</st> <st c="13028">the following</st> `<st c="13043">JAVA_HOME</st>` <st c="13052">and</st>
    `<st c="13057">HBASE_*</st>` <st c="13064">details</st> <st c="13072">to</st>
    <st c="13076">the file:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14017">Our</st> *<st c="14022">Tutor Finding</st>* <st c="14035">project
    uses</st> *<st c="14049">Java JDK 11</st>* <st c="14060">to run the HBase database
    server.</st> <st c="14095">So, the usual garbage collectors that work with Java
    1.8 are now deprecated and invalid.</st> <st c="14184">The most suitable GC option
    for the HBase platform that uses Java JDK 11 to achieve better server performance</st>
    <st c="14294">is</st> *<st c="14297">G1GC</st>*<st c="14301">.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="14302">Finally, go to the</st> `<st c="14322">/bin</st>` <st c="14326">folder</st>
    <st c="14333">and run the</st> `<st c="14346">start-hbase</st>` <st c="14357">command</st>
    <st c="14365">to start the server.</st> *<st c="14387">Figure 7</st>**<st c="14395">.3</st>*
    <st c="14397">shows a snapshot of the HBase logs while</st> <st c="14439">at startup:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Starting up the HBase server](img/B19383_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15289">Figure 7.3 – Starting up the HBase server</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15330">To stop the server, run</st> `<st c="15355">stop-hbase</st>`<st
    c="15365">, then</st> `<st c="15372">hbase master stop --</st>``<st c="15392">shutDownCluster</st>`<st
    c="15408">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="15409">The HBase server log, shown in</st> *<st c="15441">Figure 7</st>**<st
    c="15449">.4</st>*<st c="15451">, shows the Zookeeper server fetching all the
    Hadoop configuration files to handle all the Hadoop cluster(s) and providing the
    necessary</st> <st c="15588">operational services:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Starting up Zookeeper with the Hadoop cluster(s)](img/B19383_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16885">Figure 7.4 – Starting up Zookeeper with the Hadoop cluster(s)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16946">Now that we’ve made</st> <st c="16966">these server</st> <st c="16979">configurations,
    let’s run the HBase client so that we can create our</st> `<st c="17049">payments</st>`
    <st c="17057">and</st> `<st c="17062">bookings</st>` <st c="17070">tables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17078">Setting up the HBase shell</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17105">Apache HBase has a built-in interactive</st> <st c="17145">shell
    client created via Java that can communicate with HDFS for big data.</st> <st
    c="17221">The command to spawn the shell is</st> `<st c="17255">hbase shell</st>`<st
    c="17266">. In Apache HBase 2.5.5, running this command will give us the following</st>
    <st c="17339">error message:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17663">The reason behind this error is the missing JAR files that the
    client shell requires from the installation.</st> <st c="17772">So, to fix this
    error, download</st> `<st c="17804">jansi-1.18.jar</st>` <st c="17818">and</st>
    `<st c="17823">jruby-complete-9.2.13.0.jar</st>` <st c="17850">from the Maven
    repository and place them in the</st> `<st c="17899">/lib</st>` <st c="17903">directory.</st>
    <st c="17915">Then, go to the</st> `<st c="17931">/lib</st>` <st c="17935">folder
    and run the following command to open the</st> <st c="17985">client shell:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*<st c="18085">Figure 7</st>**<st c="18094">.5</st>* <st c="18096">shows the
    given command opening the</st> <st c="18133">HBase shell:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Invoking the HBase shell](img/B19383_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="19652">Figure 7.5 – Invoking the HBase shell</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19689">The warnings that appear in the logs are due to the collisions
    of SL4J log libraries from Hadoop’s</st> `<st c="19789">/common/lib</st>` <st
    c="19800">and HBase’s</st> `<st c="19813">/lib/client-facing-thirdparty</st>`<st
    c="19842">. Removing redundancies from among these logger libraries can fix these
    warnings.</st> <st c="19924">Now that we’ve finalized the table</st> <st c="19958">designs
    and set up the HBase environment, we’ll build the</st> <st c="20017">HBase tables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20030">Creating the HBase tables</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="20056">The HBase client application</st> <st c="20085">has different
    commands ready to pursue administrative, table, data manipulation, cluster-related,
    and general operations for HBase datasets.</st> <st c="20227">It can interact
    with HBase storage based on these commands.</st> *<st c="20287">Figure 7</st>**<st
    c="20295">.6</st>* <st c="20297">shows common general-purpose commands, such as</st>
    `<st c="20345">whoami</st>`<st c="20351">, which checks the user information that’s
    been logged in the shell, and</st> `<st c="20424">version</st>`<st c="20431">,
    which specifies the version of the running HBase.</st> <st c="20483">It also shows
    the</st> `<st c="20501">status</st>` <st c="20507">command, which specifies the
    status of the server and the average load value – that is, the average number
    of regions per region server across</st> <st c="20651">all servers:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Running general-purpose HBase commands](img/B19383_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21320">Figure 7.6 – Running general-purpose HBase commands</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21371">Most enterprise applications rely on DBA</st> <st c="21412">for
    table design and creation.</st> <st c="21444">For HBase database users, the data
    modelers allow the application’s data layer to generate the tables at every server
    startup.</st> <st c="21571">But often, developers build the tables before development
    using the HBase shell.</st> <st c="21652">In our application, for instance, the</st>
    `<st c="21690">payments</st>` <st c="21698">and</st> `<st c="21703">bookings</st>`
    <st c="21711">tables are generated beforehand using the HBase</st> `<st c="21760">create</st>`
    <st c="21766">command.</st> *<st c="21776">Figure 7</st>**<st c="21784">.7</st>*
    <st c="21786">shows how to use the</st> `<st c="21808">create</st>` <st c="21814">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Using the create and list commands](img/B19383_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="22250">Figure 7.7 – Using the create and list commands</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22297">To create an HBase table, use the</st> `<st c="22332">create</st>`
    <st c="22338">command with the</st> <st c="22356">following parameters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22377">The single or double-quoted table name (for example,</st> `<st
    c="22431">'bookings'</st>` <st c="22441">or</st> `<st c="22445">"payments"</st>`<st
    c="22455">).</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22458">The quoted column family’s name(s) or dictionaries containing
    the column family’s attributes, including</st> `<st c="22563">NAME</st>` <st c="22567">and
    other properties such as</st> `<st c="22597">VERSIONS</st>`<st c="22605">, with
    their values all</st> <st c="22629">in quotes.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="22639">Figure 7</st>**<st c="22648">.7</st>* <st c="22650">shows the</st>
    `<st c="22661">payments</st>` <st c="22669">table being created</st> <st c="22689">with
    the</st> `<st c="22699">details</st>` <st c="22706">and</st> `<st c="22711">items</st>`
    <st c="22716">column families, each with only a maximum of five versions.</st>
    <st c="22777">The</st> `<st c="22781">VERSIONS</st>` <st c="22789">property sets
    the maximum allowable number of updates imposed on the column family’s columns.</st>
    <st c="22884">So, if the</st> `<st c="22895">payments</st>` <st c="22903">table
    has</st> `<st c="22914">VERSIONS</st>` <st c="22922">set to</st> `<st c="22930">5</st>`<st
    c="22931">, the maximum number of allowed updates on the values of its column
    families is at most five times only.</st> <st c="23036">The timestamp that’s given
    to each cell storage of the column qualifier traces</st> <st c="23115">these updates.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23129">Now, to view all the tables, use the</st> `<st c="23167">list</st>`
    <st c="23171">command.</st> <st c="23181">There is also the</st> `<st c="23199">describe</st>`
    <st c="23207">command, which you can use to check the metadata information of
    each table (for example,</st> `<st c="23297">describe "bookings"</st>`<st c="23316">).</st>
    <st c="23320">To drop a table, disable the table first (for example,</st> `<st
    c="23375">disable "bookings"</st>`<st c="23393">) before dropping it (for example,
    via</st> `<st c="23433">drop "bookings"</st>`<st c="23448">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23451">After creating the tables</st> <st c="23477">in HBase storage,
    we can integrate our HBase database into our</st> <st c="23541">Flask application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23559">Establishing an HBase connection</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="23592">Many modern Python libraries</st> <st c="23621">that can integrate
    HBase into Flask are proprietary, such as</st> <st c="23682">this CData Python
    driver (</st>[<st c="23709">https://www.cdata.com/drivers/hbase/download/python/</st>](https://www.cdata.com/drivers/hbase/download/python/)<st
    c="23762">), which can utilize SQLAlchemy to manage HBase storage.</st> <st c="23820">But
    there is one reliable and popular Python driver in the</st> *<st c="23879">PyPI</st>*
    <st c="23883">repository that can integrate any Python application into Hbase:
    the</st> <st c="23953">HappyBase library.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23971">The</st> `<st c="23976">happybase</st>` <st c="23985">module is
    a standard Python library that uses the</st> *<st c="24036">Python Thrift</st>*
    <st c="24049">library to connect to any HBase database using the</st> *<st c="24101">Thrift</st>*
    <st c="24107">service, which is already part of the Apache HBase</st> <st c="24159">2.5.5
    platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24174">To utilize the</st> `<st c="24190">happybase</st>` <st c="24199">module,
    install it using the</st> `<st c="24229">pip</st>` <st c="24232">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24263">For</st> *<st c="24268">Tutor Finder</st>* <st c="24280">to establish
    a connection to HBase and create multiple threads for reusable connections, the
    application factory function in</st> `<st c="24406">__init__.py</st>` <st c="24417">must
    import</st> `<st c="24430">ConnectionPool</st>` <st c="24444">from the</st> `<st
    c="24454">happybase</st>` <st c="24463">module and provide it the</st> `<st c="24490">host</st>`
    <st c="24494">and</st> `<st c="24499">port</st>` <st c="24503">values of the Thrift
    gateway, as well as the number of connections in the pool.</st> <st c="24584">The
    following script shows the application factory function,</st> `<st c="24645">create_app()</st>`<st
    c="24657">, that initiates the</st> `<st c="24678">happybase</st>` <st c="24687">setup:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25016">The entry point to the HBase platform is the</st> `<st c="25062">Connection</st>`
    <st c="25072">class.</st> <st c="25080">The</st> `<st c="25084">Connection</st>`
    <st c="25094">class creates an open socket to the HBase database through the Thrift
    service.</st> <st c="25174">But</st> `<st c="25178">ConnectionPool</st>` <st c="25192">provides
    faster access than the single</st> `<st c="25232">Connection</st>` <st c="25242">instance,
    especially if the Flask application is in asynchronous mode.</st> <st c="25314">The
    only requirement is for the application to use a</st> `<st c="25367">with</st>`
    <st c="25371">context manager for the connection pool to spawn a</st> `<st c="25423">Connection</st>`
    <st c="25433">instance, assign a thread to it, and dispose of the thread when
    the transaction ends, eventually returning</st> <st c="25540">the connection’s
    state to</st> <st c="25567">the pool.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25576">Let’s use</st> `<st c="25587">ConnectionPool</st>` <st c="25601">to
    build the</st> <st c="25615">repository layer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25632">Building the repository layer</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="25662">The</st> `<st c="25667">ConnectionPool</st>` <st c="25681">instance</st>
    <st c="25690">from</st> `<st c="25696">create_app()</st>` <st c="25708">provides
    the</st> `<st c="25722">Connection</st>` <st c="25732">instance that implements
    the CRUD transactions.</st> <st c="25781">But it needs a</st> `<st c="25796">with</st>`
    <st c="25800">context manager to spawn a</st> `<st c="25828">Connection</st>`
    <st c="25838">instance or reuse a connection state from the pool so that the thread
    can run the CRUD transactions using the</st> `<st c="25949">happybase</st>` <st
    c="25958">utility methods.</st> <st c="25976">The following script shows the repository
    class that uses the</st> `<st c="26038">ConnectionPool</st>` <st c="26052">instance
    to implement the CRUD transactions for the</st> `<st c="26105">payments</st>`
    <st c="26113">table:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26674">The</st> `<st c="26679">PaymentRepository</st>` <st c="26696">class
    requires a</st> `<st c="26714">ConnectionPool</st>` <st c="26728">instance (</st>`<st
    c="26739">pool</st>`<st c="26744">) as a constructor argument</st> <st c="26772">for
    its instantiation.</st> <st c="26796">The</st> `<st c="26800">pool</st>` <st c="26804">object
    has a</st> `<st c="26818">connection()</st>` <st c="26830">method that returns
    an HBase connection that provides the</st> `<st c="26889">happybase</st>` <st
    c="26898">utility methods for CRUD transactions.</st> <st c="26938">With the help
    of a thread, the connection object has a</st> `<st c="26993">table()</st>` <st
    c="27000">utility that accesses the HBase table and returns a</st> `<st c="27053">Table</st>`
    <st c="27058">object that provides several methods to execute database transactions,
    such</st> <st c="27135">as</st> `<st c="27138">put()</st>`<st c="27143">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27144">The</st> `<st c="27149">put()</st>` <st c="27154">method performs
    both</st> *<st c="27176">INSERT</st>* <st c="27182">and</st> *<st c="27187">UPDATE</st>*
    <st c="27193">transactions.</st> <st c="27208">It requires</st> `<st c="27220">rowkey</st>`
    <st c="27226">as its primary parameter for inserting a record in dictionary format.</st>
    <st c="27297">The dictionary record consists of a</st> *<st c="27333">column qualifier-value
    pair</st>*<st c="27360">, wherein all the values should be byte strings or any
    type converted into</st> `<st c="27435">bytes</st>` <st c="27440">by the</st>
    `<st c="27448">encode('utf-8')</st>` <st c="27463">method.</st> <st c="27472">Also,</st>
    `<st c="27478">rowkey</st>` <st c="27484">should always be a byte string.</st>
    <st c="27517">The given</st> `<st c="27527">upsert_details()</st>` <st c="27543">inserts
    payment records into the</st> `<st c="27577">payments</st>` <st c="27585">table
    of the</st> <st c="27599">HBase database.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27614">Aside from</st> `<st c="27626">put()</st>`<st c="27631">, the</st>
    `<st c="27637">Table</st>` <st c="27642">object has a</st> `<st c="27656">delete()</st>`
    <st c="27664">method that deletes a record using its</st> `<st c="27704">rowkey</st>`<st
    c="27710">. The following</st> `<st c="27726">delete_payment_details()</st>` <st
    c="27750">function of</st> `<st c="27763">PaymentRepository</st>` <st c="27780">highlights
    payment details being deleted from the</st> `<st c="27831">payments</st>` <st
    c="27839">table:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28082">Aside from</st> `<st c="28094">rowkey</st>`<st c="28100">, the</st>
    `<st c="28106">delete()</st>` <st c="28114">method</st> <st c="28121">needs the
    name of the column family or families in its</st> `<st c="28177">columns</st>`
    <st c="28184">parameter, which means deleting the whole record.</st> <st c="28235">But
    sometimes, deletion requires only removing the column qualifier(s) or column(s)
    instead of the entire row so that only the column qualifier name(s) appear in
    the</st> `<st c="28401">columns</st>` <st c="28408">parameter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28419">The</st> `<st c="28424">Table</st>` <st c="28429">object has a</st>
    `<st c="28443">rows()</st>` <st c="28449">method that returns a</st> `<st c="28472">Tuple</st>`
    <st c="28477">value or list of tuples, each containing</st> `<st c="28519">rowkey</st>`
    <st c="28525">and the record in</st> `<st c="28544">bytes</st>`<st c="28549">.
    This method has two parameters, the</st> *<st c="28587">row key</st>* <st c="28594">and</st>
    *<st c="28599">column family or families</st>* <st c="28624">of the data records
    in the search.</st> <st c="28660">Here,</st> `<st c="28666">select_records_ids()</st>`
    <st c="28686">returns a list of payment records based on a selected list of row
    keys with some specified</st> <st c="28778">column families:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29281">The</st> `<st c="29286">rows()</st>` <st c="29292">method returns
    a</st> `<st c="29310">Tuple</st>` <st c="29315">value or tuples</st> <st c="29331">containing
    the</st> *<st c="29347">row key</st>* <st c="29354">as the first element and the</st>
    *<st c="29384">records</st>* <st c="29391">in dictionary format as the second
    element.</st> <st c="29436">Thus, we only need to shift the dictionary part using
    a list comprehension, as depicted in the code.</st> <st c="29537">Also, decoding
    each dictionary of fields will avoid JSON errors in Flask during its</st> `<st
    c="29621">Response</st>` <st c="29629">generation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29641">For its input, the</st> `<st c="29661">select_records_ids()</st>`
    <st c="29681">function can accept JSON requests containing the row keys of the
    records in search, as</st> <st c="29769">shown here:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29825">Alternatively, it can accept both the row keys and the column
    families, such as for the following</st> <st c="29924">request data:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29991">It can also accept specific column qualifiers that need to appear
    in the search output, as shown in the</st> <st c="30095">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30215">Another way of retrieving data</st> <st c="30245">in the</st>
    `<st c="30253">happybase</st>` <st c="30262">module is through the</st> `<st c="30285">scan()</st>`
    <st c="30291">method, which returns a generator of tuples – similar tuples returned
    by</st> `<st c="30365">rows()</st>`<st c="30371">. Here,</st> `<st c="30379">select_all_records()</st>`
    <st c="30399">shows how to use</st> `<st c="30417">scan()</st>` <st c="30423">to
    retrieve all the</st> <st c="30444">payment records:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30805">The method requires a</st> `<st c="30828">for</st>` <st c="30831">loop
    to extract all these records from the generator and decode all the details, which
    includes the column qualifier as the key and the value of each key, before adding
    them to a list.</st> <st c="31017">This retrieval consumes less running time than
    using lots of list and dictionary comprehensions</st> <st c="31113">with</st>
    `<st c="31118">rows()</st>`<st c="31124">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31125">Another advantage</st> <st c="31143">of using</st> `<st c="31153">scan()</st>`
    <st c="31159">instead of</st> `<st c="31171">rows()</st>` <st c="31177">is its
    advanced feature to filter records using the predicate conditions on columns,
    similar to a</st> `<st c="31276">WHERE</st>` <st c="31281">clause in a SQL statement.</st>
    <st c="31309">The following query transaction retrieves all payment records with
    a specific</st> *<st c="31387">tutor ID</st>* <st c="31395">specified by</st>
    <st c="31409">the client:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31866">The</st> `<st c="31871">scan()</st>` <st c="31877">method has
    a</st> `<st c="31891">filter</st>` <st c="31897">parameter that accepts a</st>
    *<st c="31923">filter string</st>* <st c="31936">constituting the</st> *<st c="31954">filter
    class</st>* <st c="31966">and its</st> *<st c="31975">constructor arguments</st>*<st
    c="31996">, which will streamline the search.</st> <st c="32032">The</st> `<st
    c="32036">filter</st>` <st c="32042">parameter indicates what filter class to
    instantiate to build the appropriate search constraints.</st> <st c="32141">The
    given</st> `<st c="32151">select_records_tutor()</st>` <st c="32173">function
    uses</st> `<st c="32188">SingleColumnValueFilter</st>`<st c="32211">, which filters
    rows based on a value constraint given to the</st> *<st c="32273">column family</st>*<st
    c="32286">,</st> *<st c="32288">column qualifier</st>*<st c="32304">,</st> *<st
    c="32306">conditional operator</st>*<st c="32326">, and</st> `<st c="32332">BinaryComparator
    (binary)</st>`<st c="32357">. Aside from</st> `<st c="32370">SingleColumnValueFilter</st>`<st
    c="32393">, here are some widely used types of filter classes that can create
    search conditions for the</st> `<st c="32487">scan()</st>` <st c="32493">method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="32501">RowFilter</st>`<st c="32511">: Accepts a comparison operator
    and the preferred comparator (for example,</st> `<st c="32587">ByteComparator</st>`<st
    c="32601">,</st> `<st c="32603">RegexStringComparator</st>`<st c="32624">, and
    so on) needed to compare the indicated value with each</st> <st c="32685">row
    key.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="32693">QualifierFilter</st>`<st c="32709">: Accepts a conditional operator
    and the preferred comparator (for example,</st> `<st c="32786">ByteComparator</st>`<st
    c="32800">,</st> `<st c="32802">RegexStringComparator</st>`<st c="32823">, and
    so on) needed to compare the column qualifier name of each row with the</st> <st
    c="32901">given value.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="32913">ColumnRangeFilter</st>`<st c="32931">: Accepts the minimum range
    column and maximum range column and then checks if the indicated value falls between
    the range</st> <st c="33055">column values.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="33069">ValueFilter</st>`<st c="33081">: Accepts a conditional operator
    and the preferred comparator needed to compare the value to each</st> <st c="33180">field
    value.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33192">Aside from</st> `<st c="33204">BinaryComparator</st>`<st c="33220">,
    other comparators that provide conversion and comparison methods</st> <st c="33286">for
    a filter class are</st> `<st c="33310">BinaryPrefixComparator</st>`<st c="33332">,</st>
    `<st c="33334">RegexStringComparator</st>`<st c="33355">,</st> <st c="33357">and</st>
    `<st c="33361">SubStringComparator</st>`<st c="33380">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33381">In the next section, we’ll apply</st> `<st c="33415">PaymentsRepository</st>`
    <st c="33433">so that we can store and retrieve payment details in and from the</st>
    `<st c="33500">payments</st>` <st c="33508">table.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33515">Applying a repository to API functions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="33554">The following API function</st> <st c="33581">uses</st> `<st c="33587">upsert_details()</st>`
    <st c="33603">from</st> `<st c="33609">PaymentRepository</st>` <st c="33626">to
    perform an</st> *<st c="33641">INSERT</st>* <st c="33647">transaction after receiving
    JSON request data from</st> <st c="33699">the client:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34135">The repository’s</st> `<st c="34153">select_all_records()</st>`
    <st c="34173">provides the following</st> `<st c="34197">list_all_payments()</st>`
    <st c="34216">function to render</st> <st c="34235">all the records from the</st>
    `<st c="34261">payments</st>` <st c="34269">table:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34473">Here,</st> `<st c="34480">pool</st>` <st c="34484">is the</st>
    `<st c="34492">ConnectionPool</st>` <st c="34506">instance that was created in
    the</st> `<st c="34540">create_app()</st>` <st c="34552">factory from the</st>
    `<st c="34570">__init__.py</st>` <st c="34581">file of the</st> `<st c="34594">modules</st>`
    <st c="34601">package.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34610">Now, for</st> `<st c="34620">happybase</st>` <st c="34629">to
    work, start up the</st> *<st c="34652">thrift server</st>*<st c="34665">. Let’s
    showcase the Apache Thrift framework in the</st> <st c="34717">HBase platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34732">Running the thrift server</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<st c="35027">hbase thrift start</st>` <st c="35045">command.</st> *<st c="35055">Figure
    7</st>**<st c="35063">.8</st>* <st c="35065">shows the logs after starting up
    the</st> <st c="35103">thrift server:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Running a built-in HBase thrift server](img/B19383_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="35871">Figure 7.8 – Running a built-in HBase thrift server</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35922">Apache Thrift will only run if Apache HBase, Hadoop, and Zookeeper
    are</st> <st c="35994">all running.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36006">The</st> `<st c="36011">happybase</st>` <st c="36020">module is
    non-Flask-specific, which means any Python client can use it to connect to the</st>
    `<st c="36110">HBase</st>` <st c="36115">server.</st> <st c="36124">The thrift
    server will always bridge between the client and HBase considering that the Python
    library uses the</st> *<st c="36235">Thrift 1</st>* <st c="36243">or</st> *<st
    c="36247">2</st>* <st c="36248">library to establish a connection.</st> <st c="36284">The</st>
    `<st c="36288">happybase</st>` <st c="36297">module uses the Thrift</st> <st c="36321">1
    library.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36331">Now that we’ve created Flask repository transactions for the HBase
    database, let’s explore a type of NoSQL storage that uses columns and rows for</st>
    <st c="36478">data storage.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36491">Utilizing the column storage of Apache Cassandra</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="36540">Apache Cassandra</st>** <st c="36557">is a</st> *<st c="36563">column-family</st>*
    <st c="36576">NoSQL database</st> <st c="36591">that can also hold</st> <st c="36610">large
    amounts of data.</st> <st c="36634">HBase can share big data</st> <st c="36658">across
    its regions using auto-sharding, which makes HBase horizontally scalable.</st>
    <st c="36740">Likewise, Cassandra supports adding more nodes horizontally to improve
    server throughput, a characteristic of horizontal scaling.</st> <st c="36870">But
    there are also some differences between the two storages in terms of their architectures,
    table read and write performances, data</st> <st c="37004">modeling approaches,
    and</st> <st c="37029">query</st> <st c="37035">languages.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37045">Let’s start by designing our</st> `<st c="37075">course</st>`<st
    c="37081">,</st> `<st c="37083">degree_level</st>`<st c="37095">,</st> `<st c="37097">student</st>`<st
    c="37104">, and</st> `<st c="37110">student_perf</st>` <st c="37122">Cassandra
    tables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37140">Designing Cassandra tables</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="37167">Unlike HBase, Cassandra stores</st> <st c="37198">its data per
    row, grouping all column fields, thus why the data model approach is a</st> *<st
    c="37283">column family</st>*<st c="37296">. Its database transactions are atomic,
    isolated, and durable, but with eventual</st> <st c="37376">or tunable consistency,
    so it doesn’t offer an</st> **<st c="37424">Atomicity, Consistency, Isolation,
    Durability</st>** <st c="37469">(</st>**<st c="37471">ACID</st>**<st c="37475">)
    model like a</st> **<st c="37491">relational database management system</st>**
    <st c="37528">(</st>**<st c="37530">RDBMS</st>**<st c="37535">).</st> <st c="37539">Sometimes,
    the Cassandra setup favors</st> <st c="37576">higher-availability performance
    over atomic and</st> <st c="37625">isolated transactions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37647">This project used</st> *<st c="37666">draw.io</st>* <st c="37673">to
    design the tables in Cassandra using UML class diagrams.</st> *<st c="37734">Figure
    7</st>**<st c="37742">.9</st>* <st c="37744">shows the data model for the project’s
    Cassandra</st> <st c="37794">data storage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Cassandra table designs using UML](img/B19383_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="38370">Figure 7.9 – Cassandra table designs using UML</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38416">Each Cassandra table must</st> <st c="38442">have a primary key.</st>
    <st c="38463">But, unlike in RDBMS, a primary key in</st> *<st c="38502">column-family</st>*
    <st c="38515">storage has at least one</st> *<st c="38541">partition key</st>*
    <st c="38554">and zero or more</st> *<st c="38572">clustering keys</st>*<st c="38587">.
    Since Cassandra storage runs on a distributed environment of clusters and nodes,
    the</st> *<st c="38674">partition key</st>* <st c="38687">evenly distributes the
    row data across the clustered storage.</st> <st c="38750">On the other hand, the</st>
    *<st c="38773">clustering key</st>* <st c="38787">sorts and manages the rows of
    data in a table.</st> <st c="38835">Also, the performance of the query transactions
    is the ultimate basis of the table design; the faster the query will be, the better</st>
    <st c="38967">the design.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38978">Let’s install Apache Cassandra so that we can realize our</st>
    <st c="39037">table design.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39050">Installing and configuring Apache Cassandra</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="39094">Download the ZIP</st> <st c="39111">file for Apache</st> <st c="39127">Cassandra
    at</st> [<st c="39141">https://cassandra.apache.org/_/download.html</st>](https://cassandra.apache.org/_/download.html)<st
    c="39185">. The</st> **<st c="39191">general availability</st>** <st c="39211">(</st>**<st
    c="39213">GA</st>**<st c="39215">) versions 3.x and below</st> <st c="39240">support
    Windows but not version 4.x.</st> <st c="39278">Since the project uses version
    4.1.3, Windows PowerShell with WSL2 installed must be used to configure and run</st>
    <st c="39389">the server.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39400">After unzipping the file, enable the Ubuntu firewall using the</st>
    `<st c="39464">sudo</st>` <st c="39468">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39493">Then, allow non-WSL clients to access ports</st> *<st c="39538">7000</st>*
    <st c="39542">(port for cluster communication),</st> *<st c="39577">9042</st>*
    <st c="39581">(default port for client access), and</st> *<st c="39620">7199</st>*
    <st c="39624">(port for JMX) using the following</st> `<st c="39660">sudo</st>`
    <st c="39664">commands:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39734">Apache Cassandra 4.1.3 requires</st> *<st c="39767">Java 11</st>*
    <st c="39774">as its virtual machine, so run the following</st> `<st c="39820">sudo</st>`
    <st c="39824">command to install Java SDK 11 in the</st> <st c="39863">Ubuntu
    environment:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39914">After, go to the</st> `<st c="39932">/conf</st>` <st c="39937">directory
    of Cassandra’s installation folder and open the</st> `<st c="39996">jvm11-server.options</st>`
    <st c="40016">file.</st> <st c="40023">Comment all the</st> *<st c="40039">CMS</st>*
    <st c="40042">GC option details and uncomment</st> *<st c="40075">G1GC</st>*<st
    c="40079">, the default GC option for</st> <st c="40107">Java 11.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40115">Finally, run the following command from the</st> `<st c="40160">/</st>``<st
    c="40161">conf</st>` <st c="40165">directory:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40189">To shut down the Cassandra server, use the</st> `<st c="40233">nodetool</st>`
    `<st c="40242">drain</st>` <st c="40247">command.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40256">Now, let’s open the Cassandra shell client to create</st> <st
    c="40309">the project’s tables and learn</st> **<st c="40341">Cassandra Query
    Language</st>** <st c="40365">(</st>**<st c="40367">CQL</st>**<st c="40370">)
    commands.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40382">Running the CQL shell client</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="40411">Cassandra 4.1.3 has</st> <st c="40431">a query language called</st>
    `<st c="40625">cqlsh</st>` <st c="40630">command in the</st> `<st c="40646">/conf</st>`
    <st c="40651">directory.</st> *<st c="40663">Figure 7</st>**<st c="40671">.10</st>*
    <st c="40674">shows the process of opening the</st> *<st c="40708">CQL</st>* *<st
    c="40712">shell</st>* <st c="40717">(</st>`<st c="40719">cqlsh</st>`<st c="40724">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Running the cqlsh command](img/B19383_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="40952">Figure 7.10 – Running the cqlsh command</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40991">CQL has</st> `<st c="41130">create</st>` <st c="41136">|</st>`<st
    c="41138">alter</st>` <st c="41143">|</st> `<st c="41146">drop keyspace</st>`<st
    c="41159">,</st> `<st c="41161">create</st>` <st c="41167">|</st> `<st c="41170">alter</st>`
    <st c="41175">|</st> `<st c="41178">drop table</st>`<st c="41188">,</st> `<st
    c="41190">use</st>`<st c="41193">, and</st> `<st c="41199">truncate</st>` <st
    c="41207">statements.</st> <st c="41220">For DML, it has</st> `<st c="41236">insert</st>`<st
    c="41242">,</st> `<st c="41244">delete</st>`<st c="41250">,</st> `<st c="41252">update</st>`<st
    c="41258">, and</st> `<st c="41264">batch</st>` <st c="41269">commands.</st> <st
    c="41280">For query transactions, it utilizes the</st> `<st c="41320">select</st>`
    <st c="41326">clause like in SQL.</st> <st c="41347">However, the</st> `<st c="41360">where</st>`
    <st c="41365">clause is limited only to partition, clustering, and composite keys.</st>
    <st c="41435">Some CQL commands end with</st> <st c="41462">a semicolon.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41474">CQL has general-purpose</st> <st c="41498">commands such as</st>
    `<st c="41516">show version</st>`<st c="41528">,</st> `<st c="41530">expand</st>`<st
    c="41536">, and</st> `<st c="41542">describe</st>`<st c="41550">. To check all
    the clusters, run the</st> `<st c="41587">describe cluster</st>` <st c="41603">command.</st>
    <st c="41613">To check all the keyspaces, run the</st> `<st c="41649">describe
    keyspaces</st>` <st c="41667">command.</st> <st c="41677">To list all the tables
    in a keyspace, run the</st> `<st c="41723">describe tables</st>` <st c="41738">command.</st>
    *<st c="41748">Figure 7</st>**<st c="41756">.11</st>* <st c="41759">shows a series
    of CQL commands that view Cassandra’s</st> <st c="41813">data storage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Running CQL general-purpose commands](img/B19383_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="42521">Figure 7.11 – Running CQL general-purpose commands</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42571">Running the</st> `<st c="42584">describe</st>` <st c="42592">command
    on a table returns the metadata description of the Cassandra table, as shown in</st>
    *<st c="42681">Figure 7</st>**<st c="42689">.12</st>*<st c="42692">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Running the describe command on tables](img/B19383_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="43661">Figure 7.12 – Running the describe command on tables</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43713">A</st> *<st c="43716">cluster</st>* <st c="43723">contains more
    than one data</st> <st c="43751">center, and a</st> *<st c="43766">data center</st>*
    <st c="43777">can have more than one node.</st> <st c="43807">Each</st> *<st c="43812">node</st>*
    <st c="43816">must have a keyspace to hold all the tables, materialized views,
    user-defined types, functions, and aggregates.</st> <st c="43929">So, the first
    thing you must do with the CQL shell client is run the</st> `<st c="43998">create
    keyspace</st>` <st c="44013">command before building the project’s tables.</st>
    <st c="44060">The following code creates</st> `<st c="44087">packtspace</st>`<st
    c="44097">, which holds the tables of</st> <st c="44125">our application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44272">The</st> *<st c="44277">replication strategy</st>* <st c="44297">that’s
    used is called</st> `<st c="44320">NetworkTopologyStrategy</st>`<st c="44343">.
    It makes</st> `<st c="44354">packtspace</st>` <st c="44364">open for replication
    and data storage expansion in the long run and also applicable for</st> <st c="44453">production
    deployment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44475">After creating</st> `<st c="44491">packspace</st>`<st c="44500">,
    you can manually create the</st> `<st c="44530">course</st>`<st c="44536">,</st>
    `<st c="44538">student</st>`<st c="44545">,</st> `<st c="44547">degree_level</st>`<st
    c="44559">, and</st> `<st c="44565">student_perf</st>` <st c="44577">tables in</st>
    `<st c="44588">keyspace</st>` <st c="44596">using the CQL command.</st> <st c="44620">However,
    DataStax has a</st> `<st c="44644">cassandra-driver</st>` <st c="44660">module
    that establishes a database connection to Cassandra and generates tables using
    the entity or model classes.</st> <st c="44776">Let’s use this external module</st>
    <st c="44806">to build the application’s</st> <st c="44834">model layer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44846">Establishing a database connection</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="44881">The</st> `<st c="44886">cassandra-driver</st>` <st c="44902">module
    is a Python</st> <st c="44921">client driver that integrates Apache Cassandra
    into the Flask application.</st> <st c="44997">It contains classes and methods
    that will only be available after installing the module using the</st> `<st c="45095">pip</st>`
    <st c="45098">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="45136">For our</st> *<st c="45145">Tutor Finder</st>* <st c="45157">to
    establish a Cassandra database connection, import</st> `<st c="45211">setup()</st>`
    <st c="45218">from the</st> `<st c="45228">cassandra.cqlengine.connection</st>`
    <st c="45258">module in the</st> `<st c="45273">__init__.py</st>` <st c="45284">file
    of the</st> `<st c="45297">modules</st>` <st c="45304">package and invoke</st>
    `<st c="45324">setup()</st>` <st c="45331">inside the</st> `<st c="45343">create_app()</st>`
    <st c="45355">factory method with the arguments for its</st> `<st c="45398">hosts</st>`<st
    c="45403">,</st> `<st c="45405">default_keyspace</st>`<st c="45421">, and</st>
    `<st c="45427">protocol_version</st>` <st c="45443">parameters.</st> <st c="45456">The
    following snippet shows the</st> <st c="45488">whole process:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: import uuid <st c="46941">from cassandra.cqlengine.columns import UUID, Text,
    Float,</st> <st c="46999">DateTime, Integer, Blob</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47023">from cassandra.cqlengine.models import Model</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="47068">from cassandra.cqlengine.management import sync_table</st> class
    Course(<st c="47136">Model</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: id      = <st c="47151">UUID</st>(primary_key=True, default=uuid.uuid4)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code    = <st c="47202">Text</st>(primary_key=True, max_length=20, required=True,clustering_order="ASC")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: title   = <st c="47287">Text</st>(required=True, max_length=100)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: req_hrs = <st c="47334">Float</st>(required=True, default = 0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total_cost = <st c="47382">Float</st>(required=True, default = 0.0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: course_offered  = <st c="47436">DateTime</st>()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: level = <st c="47456">Integer</st>(required=True, default=-1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description   = <st c="47506">Text</st>(required=False, max_length=200) <st
    c="47544">def get_json(self):</st> return {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''id'': str(self.id),'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''code'': self.code,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''title'' : self.title,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''req_hrs'': self.req_hrs,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''total_cost'': self.total_cost,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''course_offered'': self.course_offered,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''level'': self.level,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''description'': self.description'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'class DegreeLevel(<st c="48401">Model</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: id = <st c="48416">UUID</st>(primary_key=True, default=uuid.uuid4)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code = <st c="48467">Integer</st>(primary_key=True,required=True, clustering_order="ASC")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = <st c="48546">Text</st>(required=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'class Student(Model):'
  prefs: []
  type: TYPE_NORMAL
- en: id = UUID(primary_key=True, default=uuid.uuid4)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: std_id = Text(primary_key=True,required=True, max_length=12, clustering_order="ASC")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: firstname = Text(required=True, max_length=60)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: midname = Text(required=True, max_length=60)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'class StudentPerf(Model):'
  prefs: []
  type: TYPE_NORMAL
- en: id = UUID(primary_key=True, default=uuid.uuid4)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: std_id = Text(primary_key=True,required=True, max_length=12)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: course_code = Text(required=True, max_length=20)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sync_table(Course)
  prefs: []
  type: TYPE_NORMAL
- en: sync_table(DegreeLevel)
  prefs: []
  type: TYPE_NORMAL
- en: sync_table(Student)
  prefs: []
  type: TYPE_NORMAL
- en: sync_table(StudentPerf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51070">from modules.models.db.cassandra_models import Course</st> from
    datetime import datetime
  prefs: []
  type: TYPE_NORMAL
- en: from typing import Dict, Any
  prefs: []
  type: TYPE_NORMAL
- en: 'class CourseRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pass
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def insert_course(self, details:Dict[str, Any]):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try: <st c="51287">Course.create(**details)</st> return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'def update_course(self, details:Dict[str, Any]):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="51622">rec = Course.objects.filter(</st><st c="51650">code=str(details[''code'']))</st><st
    c="51677">.allow_filtering().get()</st> del details[''id'']'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: del details['code'] <st c="51740">rec.update(**details)</st> return True
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'def delete_course_code(self, code):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="52369">rec = Course.objects.filter(code=code)</st><st c="52407">.allow_filtering().get()</st><st
    c="52431">rec.delete()</st> return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'def search_by_code(self, code:str): <st c="53087">result = Course.objects.filter(code=code).allow_filtering().get()</st><st
    c="53152">records = dict(result)</st> return records'
  prefs: []
  type: TYPE_NORMAL
- en: 'def search_all_courses(self): <st c="53221">result = Course.objects.all()</st><st
    c="53250">records = [course.get_json() for course in result]</st> return records'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: sudo apt-add-repository ppa:redislabs/redis
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get update
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get upgrade
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get install redis-server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: pip install redis-om
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="60274">import redis</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load) <st c="60478">redis</st> in the
    URI indicates that the connection is a Redis standalone one to database <st c="60563">0</st>
    in localhost at port <st c="60586">6379</st>. All responses of the <st c="60613">redis-om</st>
    transactions are decoded into strings because the <st c="60672">decode_responses</st>
    parameter is assigned a value of <st c="60722">True</st>. All these string results
    are in <st c="60760">UTF-8</st> encoding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="60775">At this point, the</st> `<st c="60795">redis-om</st>` <st c="60803">module
    is ready</st> <st c="60819">to build the application’s</st> <st c="60847">model
    layer.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="60859">Implementing the model layer</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="61031">redis-py</st>` <st c="61039">module.</st> <st c="61048">Each
    model class contains the hash fields with types validated by Pydantic validators.</st>
    <st c="61135">Once instantiated, the model object will hold the values of the
    keys before inserting them into</st> <st c="61230">the database with the auto-generated</st>
    **<st c="61268">hash value</st>** <st c="61278">or</st> **<st c="61282">pk</st>**<st
    c="61284">.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="61285">The</st> `<st c="61290">redis-om</st>` <st c="61298">module has
    the</st> `<st c="61314">HashModel</st>` <st c="61323">class, which will implement
    the entity classes of the application.</st> <st c="61391">The</st> `<st c="61395">HashModel</st>`
    <st c="61404">class is a representation of a Redis hash.</st> <st c="61448">It
    captures the key-value pairs and uses its instance methods to manage the data.</st>
    <st c="61530">It automatically generates the primary key or hash key for each
    model object.</st> <st c="61608">The following are the</st> `<st c="61630">HashModel</st>`
    <st c="61639">classes for the</st> *<st c="61656">course</st>*<st c="61662">,</st>
    *<st c="61664">student</st>*<st c="61671">, and</st> *<st c="61677">tutor</st>*
    <st c="61682">data:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <st c="63322">from modules.models.db.redis_models import SearchCourse</st> from
    typing import Dict, Any
  prefs: []
  type: TYPE_NORMAL
- en: 'class SearchCourseRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pass
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def insert_course(self, details:Dict[str, Any]):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try: <st c="63517">course = SearchCourse(**details)</st><st c="63549">course.save()</st>
    return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'def update_course(self, details:Dict[str, Any]):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="64071">record = SearchCourse.get(details[''pk''])</st><st c="64111">record.update(**details)</st>
    return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'def delete_course(self, pk):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="64389">SearchCourse.delete(pk)</st> return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'def select_course(self, pk):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="64992">record = SearchCourse.get(pk)</st><st c="65021">return record.dict()</st>
    except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return None
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def select_all_course(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: records = list() <st c="65133">for id in SearchCourse.all_pks():</st><st c="65166">records.append(SearchCourse.get(id).dict())</st>
    return records
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"records": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"code": "PY-201",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"description": "Advanced Python",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"level": 3, <st c="65496">"pk": "01HDH2VPZBGJJ16JKE3KE7RGPQ",</st> "req_hrs":
    50.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"title": "Advanced Python Programming",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"total_cost": 15000.0'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"code": "PY-101",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"description": "Intro to Python programming",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"level": 1, <st c="65692">"pk": "01HDH2SVYR7AYMRD28RE6HSHYB",</st> "req_hrs":
    45.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"title": "Python Basics",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"total_cost": 5000.0'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: mongod.exe --dbpath="c:\data\db"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="69233">from mongoengine.connection import connect</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load <st c="69455">connect()</st> method
    requires <st c="69481">db name</st>, <st c="69490">host</st>, <st c="69496">port</st>,
    and the type of <st c="69518">UUID</st> the server will use to recognize the UUID
    primary key. This can be <st c="69590">unspecified</st>, <st c="69603">standard</st>,
    <st c="69613">pythonLegacy</st>, <st c="69627">javaLegacy</st>, or <st c="69642">csharpLegacy</st>.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="69655">On the other hand, the client</st> <st c="69685">can invoke the</st>
    `<st c="69701">disconnect()</st>` <st c="69713">method to close</st> <st c="69730">the
    connection.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="69745">Now, let’s build the model layer using the helper classes from
    the</st> `<st c="69813">flask-mongoengine</st>` <st c="69830">module.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="69838">Building the model layer</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="69863">The</st> `<st c="69868">flask-mongoengine</st>` <st c="69885">module
    has a</st> `<st c="70151">Document</st>` <st c="70159">base class to build the
    login details of</st> <st c="70201">our application:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: from typing import Dict, Any
  prefs: []
  type: TYPE_NORMAL
- en: from modules.models.db.mongo_models import TutorLogin
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: 'class TutorLoginRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def insert_login(self, details:Dict[str, Any]) -> bool:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try: <st c="74051">login = TutorLogin(**details)</st><st c="74080">login.save()</st>
    except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'def update_login(self, id:int, details:Dict[str, Any]) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="74894">login = TutorLogin.objects(id=id).get()</st><st c="74933">login.update(**details)</st>
    except:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'def delete_login(self, id:int) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="75360">login = TutorLogin.objects(id=id).get()</st><st c="75399">login.delete()</st>
    except:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: <st c="75840">def get_all_login(self):</st><st c="75865">login = TutorLogin.objects()</st>
    return json.loads(login.to_json()) <st c="75930">def get_login(self, id:int):</st><st
    c="75958">login = TutorLogin.objects(id=id).get()</st><st c="75998">return login.to_json()</st><st
    c="76021">def get_login_username(self, username:str,</st> <st c="76064">password:str):</st><st
    c="76079">login = TutorLogin.objects(username=username,</st> <st c="76125">password=password).get()</st>
    return login.to_json()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: from typing import Dict, Any
  prefs: []
  type: TYPE_NORMAL
- en: from modules.models.db.mongo_models import TutorLogin, Tutor
  prefs: []
  type: TYPE_NORMAL
- en: 'class TutorProfileRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_tutor_profile(self, details:Dict[str, Any]) -> bool:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try: <st c="76949">login = TutorLogin.objects(id=details[''id''])</st> <st
    c="76993">.get()</st> del details[''id''] <st c="77018">profile = Tutor(**details)</st><st
    c="77044">login.update(tutor=profile)</st> except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'def delete_tutor_profile(self, id:int) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="77462">login = TutorLogin.objects(id=id).get()</st><st c="77501">login.update(tutor=None)</st>
    except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: from typing import Dict, Any
  prefs: []
  type: TYPE_NORMAL
- en: from modules.models.db.mongo_models import Savings, TutorLogin
  prefs: []
  type: TYPE_NORMAL
- en: 'class SavingsRepository: <st c="78396">def add_savings(self, details:Dict[str,
    Any]):</st> try: <st c="78448">login = TutorLogin.objects(id=details[''id''])</st>
    <st c="78492">.get()</st><st c="78498">del details[''id'']</st><st c="78516">savings
    = Savings(**details)</st><st c="78545">login.update(push__tutor__savings=savings)</st>
    except Exception as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="78843">def delete_savings(self, details:Dict[str, Any]):</st> try: <st
    c="78899">login = TutorLogin.objects(id=details[''id''])</st> .get() <st c="78950">login.update(pull__tutor__savings__acct_number=</st>
    <st c="78997">details[''acct_number''])</st> except Exception as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: pip install couchbase
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: <st c="83840">from couchbase.auth import PasswordAuthenticator</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83889">from couchbase.cluster import Cluster</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="83927">from couchbase.options import ClusterOptions</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load) <st c="84069">auth = PasswordAuthenticator("sjctrags",
    "packt2255",)</st><st c="84123">cluster = Cluster('couchbase://localhost',</st>
    <st c="84166">ClusterOptions(auth))</st> cluster.wait_until_ready(timedelta(seconds=5))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: global cb <st c="84285">Cluster</st> object has a <st c="84306">wait_until_ready()</st>
    method that pings to the Couchbase services regarding the connection status and
    returns control to <st c="84424">create_app()</st> once the connection is ready.
    But calling this method slows down the startup of the Flask server. Our application
    has only invoked the method for experimentation purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="84608">After a successful</st> <st c="84628">setup, we must ensure the</st>
    `<st c="84654">Bucket</st>` <st c="84660">object is ready for implementing the</st>
    <st c="84698">repository layer.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="84715">Creating the repository layer</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="84745">The repository layer</st> <st c="84766">needs the</st> `<st c="84777">Bucket</st>`
    <st c="84783">object from</st> `<st c="84796">create_app()</st>` <st c="84808">to
    implement the CRUD transactions.</st> <st c="84845">The</st> `<st c="84849">Bucket</st>`
    <st c="84855">object has a</st> `<st c="84869">scope()</st>` <st c="84876">method
    that will access the container space that contains the collections.</st> <st c="84952">It
    returns a</st> `<st c="84965">Scope</st>` <st c="84970">object that emits</st>
    `<st c="84989">collection()</st>`<st c="85001">, which retrieves the preferred
    document collections.</st> <st c="85055">Here,</st> `<st c="85061">DirectMessageRepository</st>`
    <st c="85084">manages all the direct messages that students send to trainers and</st>
    <st c="85152">vice versa:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: <st c="85455">The</st> `<st c="85460">dm_insert()</st>` <st c="85471">method
    gives us access to the</st> `<st c="85502">tfs</st>` <st c="85505">scope and its</st>
    `<st c="85520">direct_messages</st>` <st c="85535">document collections.</st>
    <st c="85558">Its main goal is to insert the details of a chat message between
    the tutor and trainer into the document collection using the given key through
    the collection’s</st> `<st c="85719">insert()</st>` <st c="85727">method.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="85735">On the other hand, the</st> `<st c="85759">update_dm()</st>` <st
    c="85770">method uses the collection’s</st> `<st c="85800">upsert()</st>` <st
    c="85808">method to update a JSON document using</st> <st c="85848">a key:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: <st c="86115">The collection’s</st> `<st c="86133">remove()</st>` <st c="86141">method
    deletes</st> <st c="86156">a document from the collection.</st> <st c="86189">This
    can be seen in the following</st> `<st c="86223">delete_dm()</st>` <st c="86234">transaction,
    where it removes a chat message using</st> <st c="86286">its</st> `<st c="86290">key</st>`<st
    c="86293">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: <st c="86551">Couchbase, unlike MongoDB, uses a SQL-like</st> <st c="86594">mechanism
    called</st> *<st c="86612">N1QL</st>* <st c="86616">to retrieve documents.</st>
    <st c="86640">The following</st> *<st c="86654">DELETE</st>* <st c="86660">transaction
    uses the N1QL query transaction instead of the collection’s</st> `<st c="86733">delete()</st>`
    <st c="86741">method:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: <st c="86969">The</st> `<st c="86974">Scope</st>` <st c="86979">instance, derived
    from the</st> `<st c="87007">Bucket</st>` <st c="87013">object’s</st> `<st c="87023">scope()</st>`
    <st c="87030">method, has a</st> `<st c="87045">query()</st>` <st c="87052">method
    that executes a query statement in string form.</st> <st c="87108">The query statement
    should have its collection and field names enclosed in ticks (</st>[PRE57]<st
    c="87193">), while its string constraint values should be in single quotes.</st>
    <st c="87260">Thus, we have the</st> ``<st c="87278">delete from `direct_messages`
    where `sender_id` LIKE '{sender},'</st>`` <st c="87342">query statement in</st>
    `<st c="87362">delete_dm_sender()</st>`<st c="87380">, where</st> `<st c="87388">sender</st>`
    <st c="87394">is a</st> <st c="87400">parameter value.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="87416">The advantage of using N1QL queries in</st> *<st c="87456">DELETE</st>*
    <st c="87462">and</st> *<st c="87467">UPDATE</st>* <st c="87473">transactions
    is that the key is not the only basis</st> <st c="87524">for performing these
    operations.</st> <st c="87558">The</st> *<st c="87562">DELETE</st>* <st c="87568">operation
    can base its document removal on other fields, such as removing a chat message
    using the given</st> <st c="87674">sender ID:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*<st c="87904">N1QL</st>* <st c="87909">is popular in retrieving JSON documents
    from the keyspace with or without constraints.</st> <st c="87997">The following
    query transaction uses the</st> *<st c="88038">SELECT</st>* <st c="88044">query
    statement to retrieve all the documents in the</st> `<st c="88098">direct_messages</st>`
    <st c="88113">collections:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: <st c="88327">Couchbase can be a suitable form of backend storage for Flask
    applications when managing a dump of JSON data.</st> <st c="88438">Flask and Couchbase
    can build fast, scalable, and efficient microservices or distributed applications
    with rapid development and less database administration.</st> <st c="88597">However,
    compared to HBase, Redis, Cassandra, MongoDB, and Couchbase, Flask can integrate</st>
    <st c="88686">with graph databases, such as Neo4J, for</st> <st c="88728">graph-related
    algorithms.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="88753">Establishing a data relationship with Neo4J</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="88797">Neo4J</st>** <st c="88803">is a NoSQL database that focuses</st>
    <st c="88836">on relationships</st> <st c="88853">between data.</st> <st c="88868">Instead</st>
    <st c="88875">of documents, it stores nodes, relationships, and the properties
    that link these nodes.</st> <st c="88964">Neo4J is also known as a popular graph
    database because the concept relies on a graph model composed of nodes and lines
    directed</st> <st c="89093">between nodes.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="89107">Before integrating our application into the Neo4J database, we
    must install the current version of the Neo4J platform using</st> <st c="89232">Neo4J
    Desktop.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="89246">Installing Neo4J Desktop</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="89271">Neo4J Desktop provides</st> <st c="89294">a local development
    environment and includes all the functionality needed to learn the database, from
    creating a custom local database to starting</st> <st c="89441">the Neo4J browser.</st>
    <st c="89461">Its installer can be found</st> <st c="89488">at</st> [<st c="89491">https://neo4j.com/download/</st>](https://neo4j.com/download/)<st
    c="89518">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="89519">Once it’s been installed, create a Neo4J project that will contain
    the local databases and configuration settings.</st> <st c="89635">Aside from
    the project’s name, the process will also ask for a username and password for
    its authentication details.</st> <st c="89752">Once you’ve done this, delete its
    default Movie database and create the necessary graph database.</st> *<st c="89850">Figure
    7</st>**<st c="89858">.20</st>* <st c="89861">shows</st> **<st c="89868">Packt
    Flask Project</st>** <st c="89887">with a</st> **<st c="89895">Tutor</st>** <st
    c="89900">database:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.20 – The Neo4J Desktop dashboard](img/B19383_07_020.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="90213">Figure 7.20 – The Neo4J Desktop dashboard</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="90254">There are so many ways Flask can connect to a graph database,
    and one of them is through the</st> `<st c="90348">py2neo</st>` <st c="90354">library.</st>
    <st c="90364">We’ll take a closer look at this in the</st> <st c="90404">next
    section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="90417">Establishing a connection to the database</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="90459">To start, install</st> `<st c="90478">py2neo</st>` <st c="90484">using</st>
    <st c="90491">the</st> `<st c="90495">pip</st>` <st c="90498">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: <st c="90526">Next, create a</st> `<st c="90542">neo4j_config.py</st>` <st c="90557">module
    in the main project folder with the following script to ensure</st> <st c="90628">database
    connectivity:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: <st c="90771">Now, calling the given</st> `<st c="90795">db_auth()</st>` <st
    c="90804">method will initiate the bolts connection protocol with the host, port,
    and authentication details to open a connection for our</st> *<st c="90933">Tutor
    Finder</st>* <st c="90945">application through</st> <st c="90965">the</st> `<st
    c="90970">Graph</st>` <st c="90975">instance, the object responsible for repository</st>
    <st c="91024">layer implementation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="91045">Implementing the repository</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="91333">Graph</st>` <st c="91338">instance has several utility methods
    to derive the building blocks of the module, namely</st> `<st c="91428">SubGraph</st>`<st
    c="91436">,</st> `<st c="91438">Node</st>`<st c="91442">,</st> `<st c="91444">NodeMatcher</st>`<st
    c="91455">, and</st> `<st c="91461">Relationship</st>`<st c="91473">. Here,</st>
    `<st c="91481">StudentNodeRepository</st>` <st c="91502">showcases the use of
    py2neo’s API classes and methods in managing the</st> <st c="91573">student nodes:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: <st c="92018">The</st> `<st c="92023">insert_student_node()</st>` <st c="92044">method
    creates a</st> `<st c="92062">Student</st>` <st c="92069">node and stores its
    details in the graph database.</st> <st c="92121">A node is the fundamental unit
    of data in Neo4J; it can be an independent node or connected to other nodes through</st>
    <st c="92236">a relationship.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="92251">There are two ways to create a node</st> <st c="92287">using the</st>
    `<st c="92298">py2neo</st>` <st c="92304">library:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="92313">Running a query with Cypher’s</st> *<st c="92344">CREATE</st>*
    <st c="92350">transaction using Graph’s</st> `<st c="92377">query()</st>` <st
    c="92384">or</st> `<st c="92388">run()</st>` <st c="92393">methods.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="92402">Persisting the</st> `<st c="92418">Node</st>` <st c="92422">object
    using the</st> `<st c="92440">Graph</st>` <st c="92445">object’s</st> `<st c="92455">create()</st>`
    <st c="92463">method.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="92471">Creating a node requires transaction</st> <st c="92508">management,
    so we must start a</st> `<st c="92540">Transaction</st>` <st c="92551">context
    to commit all the data manipulation operations.</st> <st c="92608">Here,</st>
    `<st c="92614">insert_student_node()</st>` <st c="92635">creates a</st> `<st c="92646">Transaction</st>`
    <st c="92657">object to create a logical context for the node creation operation
    for the</st> `<st c="92733">Graph</st>` <st c="92738">object’s</st> `<st c="92748">commit()</st>`
    <st c="92756">method</st> <st c="92764">to commit:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '*<st c="93173">NodeManager</st>* <st c="93185">can locate a specific node</st>
    <st c="93212">given the criteria in key-value pairs.</st> <st c="93252">Here,</st>
    `<st c="93258">update_student_node()</st>` <st c="93279">uses the</st> `<st c="93289">match()</st>`
    <st c="93296">method from</st> `<st c="93309">NodeManager</st>` <st c="93320">to
    single out a</st> `<st c="93337">Node</st>` <st c="93341">object with the specific</st>
    `<st c="93367">student_id</st>` <st c="93377">value.</st> <st c="93385">After
    retrieving a graph node, if there is one, you must call the</st> `<st c="93451">Node</st>`
    <st c="93455">object’s</st> `<st c="93465">update()</st>` <st c="93473">method
    with the</st> `<st c="93490">kwargs</st>` <st c="93496">value of the new data.</st>
    <st c="93520">To merge the updated</st> `<st c="93541">Node</st>` <st c="93545">object
    with its committed version, invoke the</st> `<st c="93592">Graph</st>` <st c="93597">object’s</st>
    `<st c="93607">push()</st>` <st c="93613">method and perform</st> <st c="93633">a
    commit.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="93642">Another way of searching and retrieving a</st> `<st c="93685">Node</st>`
    <st c="93689">match is through the</st> `<st c="93711">Graph</st>` <st c="93716">object’s</st>
    `<st c="93726">query()</st>` <st c="93733">method.</st> <st c="93742">It can execute</st>
    *<st c="93757">CREATE</st>* <st c="93763">and other Cipher manipulation commands
    because it has auto-commit features.</st> <st c="93840">But in most cases, it
    is applied in node retrieval transactions.</st> <st c="93905">Here,</st> `<st
    c="93911">delete_student_node()</st>` <st c="93932">uses the</st> `<st c="93942">query()</st>`
    <st c="93949">method with the</st> `<st c="93966">MATCH</st>` <st c="93971">command
    to retrieve a specific node</st> <st c="94008">for deletion:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: <st c="94342">The</st> `<st c="94347">Graph</st>` <st c="94352">object’s</st>
    `<st c="94362">query()</st>` <st c="94369">method returns</st> `<st c="94385">Cursor</st>`<st
    c="94391">, which is a navigator for streams of nodes.</st> <st c="94436">The</st>
    `<st c="94440">Graph</st>` <st c="94445">object has a</st> `<st c="94459">delete()</st>`
    <st c="94467">method that can delete any nodes retrieved by</st> `<st c="94514">query()</st>`<st
    c="94521">, but the nodes should be in</st> *<st c="94550">SubGraph</st>* <st
    c="94558">form.</st> <st c="94565">To delete the retrieved nodes, convert the</st>
    `<st c="94608">Cursor</st>` <st c="94614">object into a</st> *<st c="94629">SubGraph</st>*
    <st c="94637">by calling it from the</st> `<st c="94661">to_subgraph()</st>` <st
    c="94674">method.</st> <st c="94683">Then, call</st> `<st c="94694">commit()</st>`
    <st c="94702">to handle the whole</st> <st c="94723">delete transaction.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="94742">Retrieving nodes in</st> `<st c="94763">py2neo</st>` <st c="94769">can
    utilize</st> <st c="94781">either</st> `<st c="94789">NodeManager</st>` <st c="94800">or
    the</st> `<st c="94808">Graph</st>` <st c="94813">object’s</st> `<st c="94823">query()</st>`
    <st c="94830">method.</st> <st c="94839">Here,</st> `<st c="94845">get_student_node()</st>`
    <st c="94863">retrieves a specific</st> `<st c="94885">Student</st>` <st c="94892">node
    filtered by student ID using</st> `<st c="94927">NodeMatcher</st>`<st c="94938">,
    while</st> `<st c="94946">select_student_nodes()</st>` <st c="94968">uses</st>
    `<st c="94974">query()</st>` <st c="94981">to retrieve a list of</st> `<st c="95004">Student</st>`
    <st c="95011">nodes:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: <st c="95351">The</st> `<st c="95356">dict()</st>` <st c="95362">function converts
    a</st> `<st c="95383">Node</st>` <st c="95387">object into a dictionary, thus
    wrapping a</st> `<st c="95430">Student</st>` <st c="95437">node with the</st>
    `<st c="95452">dict()</st>` <st c="95458">function in the given</st> `<st c="95481">get_student_node()</st>`<st
    c="95499">. On the other hand,</st> `<st c="95520">Cursor</st>` <st c="95526">has
    a</st> `<st c="95533">data()</st>` <st c="95539">function to convert the streams
    of</st> `<st c="95575">Node</st>` <st c="95579">objects into a list of dictionary
    elements.</st> <st c="95624">So,</st> `<st c="95628">select_student_nodes()</st>`
    <st c="95650">returns the stream of</st> `<st c="95673">Student</st>` <st c="95680">nodes</st>
    <st c="95686">as a list of</st> `<st c="95700">Student</st>` <st c="95707">records.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="95716">Summary</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="95724">There are lots of NoSQL databases that can store non-relational
    data for big data applications built with Flask 3.x.</st> <st c="95842">Flask
    can</st> `<st c="95852">PUT</st>`<st c="95855">,</st> `<st c="95857">GET</st>`<st
    c="95860">, and</st> `<st c="95866">SCAN</st>` <st c="95870">data in HBase using
    HDFS, access the Cassandra database, execute</st> `<st c="95936">HGET</st>` <st
    c="95940">an</st> `<st c="95944">HSET</st>` <st c="95948">with Redis, perform
    CRUD operations in Couchbase and MongoDB, and manage nodes with Neo4J.</st> <st
    c="96040">Although there are changes in some support modules, such as in</st>
    `<st c="96103">flask-mongoengine</st>`<st c="96120">, because of the transformations
    in the Flask internal modules (for example, the removal of</st> `<st c="96212">flask.json</st>`<st
    c="96222">), Flask can still adapt to other Python module extensions and workarounds
    to connect to and manage its data, such as using the FastAPI-compatible</st> <st
    c="96370">Redis OM.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="96379">In general, this chapter showcased Flask’s compatibility with
    almost all the efficient, popular, and widely used NoSQL databases.</st> <st c="96510">It
    is also a Python framework that’s fit for building big data applications for many
    enterprises and scientific development because it supports many</st> <st c="96659">NoSQL
    storages.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="96674">The next chapter is about using Flask to implement task management</st>
    <st c="96742">with workflows.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
