- en: Chapter 9. Network Monitoring and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing packets on your network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving packets in the pcap format using the pcap dumper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an extra header in HTTP packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning the ports of a remote host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the IP address of a packet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaying traffic by reading from a saved pcap file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning the broadcast of packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents some interesting Python recipes for network security monitoring
    and vulnerability scanning. We begin by sniffing packets on a network using the
    `pcap` library. Then, we start using `Scapy`, which is a Swiss knife type of library
    that can do many similar tasks. Some common tasks in packet analysis are presented
    using `Scapy`, such as saving a packet in the `pcap` format, adding an extra header,
    and modifying the IP address of a packet.
  prefs: []
  type: TYPE_NORMAL
- en: Some other advanced tasks on network intrusion detection are also included in
    this chapter, for example, replaying traffic from a saved `pcap` file and broadcast
    scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing packets on your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in sniffing packets on your local network, this recipe
    can be used as the starting point. Remember that you may not be able to sniff
    packets other than what is destined to your machine, as decent network switches
    will only forward traffic that is designated to your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to install the `pylibpcap` library (Version 0.6.4 or greater) for this
    recipe to work. It's available at SourceForge ([http://sourceforge.net/projects/pylibpcap/](http://sourceforge.net/projects/pylibpcap/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install the `construct` library, which can be installed from
    PyPI via `pip` or `easy_install`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can supply command-line arguments, for example, the network interface name
    and TCP port number, for sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.1 gives the code for sniffing packets on your network, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script passing the command-line arguments, `--iface=eth0` and
    `--port=80`, this script will sniff all the HTTP packets from your web browser.
    So, after running this script, if you access [http://www.google.com](http://www.google.com)
    on your browser, you can then see a raw packet output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on the `pcapObject()` class from the `pcap` library to create
    an instance of sniffer. In the `main()` method, an instance of this class is created,
    and a filter is set using the `setfilter()` method so that only the HTTP packets
    are captured. Finally, the `dispatch()` method starts sniffing and sends the sniffed
    packet to the `print_packet()` function for postprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: In the `print_packet()` function, if a packet has data, the payload is extracted
    using the `ip_stack.parse()` method from the `construct` library. This library
    is useful for low-level data processing.
  prefs: []
  type: TYPE_NORMAL
- en: Saving packets in the pcap format using the pcap dumper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **pcap** format, abbreviated from **packet capture**, is a common file format
    for saving network data. More details on the pcap format can be found at [http://wiki.wireshark.org/Development/LibpcapFileFormat](http://wiki.wireshark.org/Development/LibpcapFileFormat).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save your captured network packets to a file and later re-use
    them for further processing, this recipe can be a working example for you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use the `Scapy` library to sniff packets and write to a
    file. All utility functions and definitions of `Scapy` can be imported using the
    wild card import, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is only for demonstration purposes and not recommended for production code.
  prefs: []
  type: TYPE_NORMAL
- en: The `sniff()` function of `Scapy` takes the name of a callback function. Let's
    write a callback function that will write the packets onto a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.2 gives the code for saving packets in the pcap format using the
    pcap dumper, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the `sniff()` and `wrpacp()` utility functions of the `Scapy`
    library to capture all the network packets and dump them onto a file. After capturing
    a packet via `sniff()`, the `write_cap()` function is called on that packet. Some
    global variables are used to work on packets one after another. For example, packets
    are stored in a `pkts[]`list and packet and variable counts are used. When the
    value of the count is 3, the `pkts` list is dumped onto a file named `pcap1.pcap`,
    the count variable is reset so that we can continue capturing another three packets
    and dumped onto `pcap2.pcap`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the `test_dump_file()` function, assume the presence of the first dump file,
    `pcap1.dump`, in the working directory. Now, `sniff()` is used with an offline
    parameter, which captured packets from the file instead of network. Here, the
    packets are decoded one after another using the `hexdump()` function. The contents
    of the packets are then printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an extra header in HTTP packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you would like to manipulate an application by supplying a custom
    HTTP header that contains custom information. For example, adding an authorization
    header can be useful to implement the HTTP basic authentication in your packet
    capture code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us sniff the packets using the `sniff()` function of `Scapy` and define
    a callback function, `modify_packet_header()`, which adds an extra header of certain
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.3 gives the code for adding an extra header in HTTP packets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, it will show a captured packet; print the modified
    version of it and send it to the network, as shown in the following output. This
    can be verified by other packet capturing tools such as `tcpdump` or `wireshark`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we set up the packet sniffing using the `sniff()` function of **Scapy**,
    specifying `modify_packet_header()` as the callback function for each packet.
    All TCP packets having TCP and a raw layer that are destined to port `80` (HTTP)
    are considered for modification. So, the current packet header is extracted from
    the packet's payload data.
  prefs: []
  type: TYPE_NORMAL
- en: The extra header is then appended to the existing header dictionary. The packet
    is then printed on screen using the `show()` method, and for avoiding the correctness
    checking failure, the packet checksum data is removed from the packet. Finally,
    the packet is sent over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the ports of a remote host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are trying to connect to a remote host using a particular port, sometimes
    you get the message saying that `Connection is refused`. The reason for this is
    that, most likely, the server is down on the remote host. In such a situation,
    you can try to see whether the port is open or in the listening state. You can
    scan multiple ports to identify the available services in a machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Python''s standard socket library, we can accomplish this port-scanning
    task. We can take three command-line arguments: target host, and start and end
    port numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.4 gives the code for scanning the ports of a remote host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this recipe to scan your local machine''s port `1` to `100` to detect
    open ports, you will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to scan open ports of a machine using Python''s
    standard socket library. The `scan_port()` function takes three arguments: hostname,
    start port, and end port. Then, it scans the entire port range in three steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a TCP socket using the `socket()` function.
  prefs: []
  type: TYPE_NORMAL
- en: If the socket is created successfully, then resolve the IP address of the remote
    host using the `gethostbyname()` function.
  prefs: []
  type: TYPE_NORMAL
- en: If the target host's IP address is found, try to connect to the IP using the
    `connect()` function. If that's successful, then it implies that the port is open.
    Now, close the port with the `close()` function and repeat the first step for
    the next port.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the IP address of a packet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever need to create a network packet and customize the source and destination
    IP or ports, this recipe can serve as the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can take all the useful command-line arguments such as network interface
    name, protocol name, source IP, source port, destination IP, destination port,
    and optional TCP flags.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `Scapy` library to create a custom TCP or UDP packet and send
    it over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.5 gives the code for customizing the IP address of a packet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this script, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script defines a `send_packet()` function to construct the IP packet using
    `Scapy`. The source and destination addresses and ports are supplied to it. Depending
    on the protocol, for example, TCP or UDP, it constructs the correct type of packet.
    If the packet is TCP, the flags argument is used; if not, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: In order to construct a TCP packet, `Sacpy` supplies the `IP()`/`TCP()` function.
    Similarly, in order to create a UDP packet, the `IP()`/`UDP()` function is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the modified packet is sent using the `send()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Replaying traffic by reading from a saved pcap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While playing with network packets, you may need to replay traffic by reading
    from a previously saved `pcap` file. In that case, you'd like to read the `pcap`
    file and modify the source or destination IP addresses before sending them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us use `Scapy` to read a previously saved `pcap` file. If you don't have
    a `pcap` file, you can use the *Saving packets in the pcap format using pcap dumper*
    recipe of this chapter to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Then, parse the arguments from the command line and pass them to a `send_packet()`function
    along with the parsed raw packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.6 gives the code for replaying traffic by reading from a saved `pcap`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run this script, it will read the saved `pcap` file, `pcap1.pcap`, by
    default and send the packet after modifying the source and destination IP addresses
    to `1.1.1.1` and `2.2.2.2` respectively, as shown in the following output. If
    you use the `tcpdump` utility, you can see these packet transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe reads a saved `pcap` file, `pcap1.pcap`, from the disk using the
    `PcapReader()` function of `Scapy` that returns an iterator of packets. The command-line
    arguments are parsed if they are supplied. Otherwise, the default value is used
    as shown in the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line arguments and the packet list are passed to the `send_packet()`
    function. This function places the new packets in the `p_out` list and keeps track
    of the processed packets. In each packet, the payload is modified, thus changing
    the source and destination IPs. In addition to this, the `checksum` packet is
    deleted as it was based on the original IP address.
  prefs: []
  type: TYPE_NORMAL
- en: After processing one of the packets, it is sent over the network immediately.
    After that, the remaining packets are sent in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the broadcast of packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you encounter the issue of detecting a network broadcast, this recipe is
    for you. We can learn how to find the information from the broadcast packets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `Scapy` to sniff the packets arriving to a network interface. After
    each packet is captured, they can be processed by a callback function to get the
    useful information from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.7 gives the code for scanning the broadcast of packets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you can list the broadcast traffic''s source IP and
    ports. The following is a sample output from which the first octet of the IP is
    replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe sniffs packets in a network using the `sniff()` function of `Scapy`.
    It has a `monitor_packet()`callback function that does the postprocessing of packets.
    Depending on the protocol, for example, IP or TCP, it sorts the packets in a dictionary
    called `captured_data`.
  prefs: []
  type: TYPE_NORMAL
- en: If an individual IP is not already present in the dictionary, it creates a new
    entry; otherwise, it updates the dictionary with the port number for that specific
    IP. Finally, it prints the IP addresses and ports in each line.
  prefs: []
  type: TYPE_NORMAL
