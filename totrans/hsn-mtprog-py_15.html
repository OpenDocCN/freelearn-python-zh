<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer128">
<h1 id="_idParaDest-152"><em class="italic"><a id="_idTextAnchor154"/>Chapter 12</em>: Applying GOF Design Patterns – Part 1</h1>
<p>In this chapter, we will look at the concept of design patterns in Python 3 and its various categories, along with examples of how they can be applied while developing software using Python.</p>
<p>The concept of design patterns originated from the book Design Patterns Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, which was written in C++. This concept was later extended to other o<strong class="bold">bject-oriented programming </strong>(<strong class="bold">OOP</strong>) languages. </p>
<p>In this chapter, we are going to look at how these design patterns can be applied in Python using our core example of <em class="italic">ABC Megamart</em>.</p>
<p>We will cover the following main topics:</p>
<ul>
<li>An overview of design patterns</li>
<li>Exploring behavioral design patterns</li>
</ul>
<p>By the end of this chapter, you should understand some important behavioral design patterns and how they can be implemented in various applications. </p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Technical requirements</h1>
<p>The code examples in this chapter are available in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12</a>.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>An overview of design patterns</h1>
<p>Every programming language has its elements uniquely designed and communicated to others. Design patterns <a id="_idIndexMarker553"/>give a structured and well-designed approach to developing software or applications in Python. In Python, every element is an object. Design patterns express how we are going to sequence or structure these objects to perform various operations. This allows them to become reusable.</p>
<p>The design patterns are divided into three categories – behavioral, structural, and creational. In this chapter, we will cover behavioral design patterns and look at three in particular, as follows:</p>
<ul>
<li>The chain of responsibility</li>
<li>Command</li>
<li>Strategy</li>
</ul>
<p>More than 20 different design patterns are available in Python and covering all of them would require a book of its own. Therefore, we will only focus on some of the most interesting design patterns in this chapter and the next. With that, let’s explore some behavioral design patterns.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Exploring behavioral design patterns</h1>
<p>As the name suggests, behavioral design patterns deal with the behavior of objects and how they talk to <a id="_idIndexMarker554"/>each other. In this section, we will learn about the elements of the chain of responsibility, command, and strategy design patterns, which belong to the behavioral design pattern category, and understand them by applying them to <em class="italic">ABC Megamart</em>.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor158"/>Understanding the chain of responsibility</h2>
<p>The chain of responsibility is <a id="_idIndexMarker555"/>a design pattern where <a id="_idIndexMarker556"/>the responsibility of the actions that can be performed by objects are transferred from one object to another, similar to a chain of events or actions. To explain this further and to implement this design pattern, we need <a id="_idIndexMarker557"/>the following elements to be developed in our code:</p>
<ul>
<li><strong class="bold">Parent handler</strong>: A base class that defines a base function that specifies how a sequence of actions should be handled.</li>
<li><strong class="bold">Child handlers</strong>: One or more subclasses that overwrite the base function from the base class to perform the respective action.</li>
<li><strong class="bold">Exception handler</strong>: A default handler that performs a specific action in case of exceptions. It also overwrites the base function from the base class.</li>
<li><strong class="bold">Requestor</strong>: A function or method that calls the child handlers to initiate a chain of responsibility.</li>
</ul>
<p>Let’s look at the chain of responsibility with an example. </p>
<p>In this <a id="_idIndexMarker558"/>example, we will be calculating tax by state and generating <a id="_idIndexMarker559"/>an invoice for the New York and California branches of <em class="italic">ABC Megamart</em>. Follow these steps:</p>
<ol>
<li>To illustrate the design pattern further, let’s create a parent handler class named <strong class="source-inline">InvoiceHandler</strong>. In this class, we will initiate a <strong class="source-inline">next_action</strong> variable to handle the next action in the chain and define a <strong class="source-inline">handle</strong> method to handle the requested action:<p class="source-code">class InvoiceHandler(object):</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self.next_action = None</p><p class="source-code">    def handle(self,calctax):</p><p class="source-code">        self.next_action.handle(calctax)</p></li>
<li>Next, we will create a supporting class to support the actions that we are going to perform in this example. Here, we want to calculate tax for a state based on the request and generate an invoice:<p class="source-code">class InputState(object):</p><p class="source-code">    state_ny = ['NYC','NY','New York','new york']</p><p class="source-code">    state_ca = ['CA', 'California', 'california']</p></li>
</ol>
<p>The <strong class="source-inline">InputState</strong> class has two attributes for the list of acceptable values for the states of New York and California.</p>
<ol>
<li value="3">Now, let’s create another class that adds a header to the invoice, as follows: <p class="source-code">class Print_invoice(object):</p><p class="source-code">    def __init__(self,state):</p><p class="source-code">        self.state = state</p><p class="source-code">        self.header = 'State specific Sales tax is applicable </p><p class="source-code">                       for the state of ' + self.state</p></li>
<li>Next, we will create a class for the child handler that has a method for generating <a id="_idIndexMarker560"/>an invoice, calculating New York’s <a id="_idIndexMarker561"/>state-specific tax for a product, and overwriting the <strong class="source-inline">handle</strong> method from the <strong class="source-inline">InvoiceHandler</strong> class:<p class="source-code">class NYCHandler(InvoiceHandler):</p><p class="source-code">    def generate_invoice(self, header, state):</p><p class="source-code">        product = 'WashingMachine'</p><p class="source-code">        pricebeforetax = 450 + (450 * 0.19)</p><p class="source-code">        tax_rate = 0.4</p><p class="source-code">        local_rate = 0.055</p><p class="source-code">        tax = pricebeforetax * (tax_rate + local_rate)</p><p class="source-code">        finalsellingprice = pricebeforetax + tax</p><p class="source-code">        print('**************ABC Megamart*****************')</p><p class="source-code">        print('***********------------------**************')</p><p class="source-code">        print(header)</p><p class="source-code">        print('Product: ', product)</p><p class="source-code">        print('Tax: ', tax)</p><p class="source-code">        print('Total Price: ', finalsellingprice)</p><p class="source-code">        print('***********------------------**************') </p><p class="source-code">        </p><p class="source-code">    def handle(self,print_invoice):</p><p class="source-code">        if print_invoice.state in InputState.state_ny:</p><p class="source-code">            self.generate_invoice(print_invoice.header, </p><p class="source-code">                                  print_invoice.state)</p><p class="source-code">        else:</p><p class="source-code">            super(NYCHandler, self).handle(print_invoice)</p></li>
<li>Then, we <a id="_idIndexMarker562"/>will create a class for the child handler that <a id="_idIndexMarker563"/>has a method for generating an invoice, calculating California’s state-specific tax for a product, and overwriting the <strong class="source-inline">handle</strong> method from the <strong class="source-inline">InvoiceHandler</strong> class:<p class="source-code">class CAHandler(InvoiceHandler):</p><p class="source-code">    def generate_invoice(self, header, state):</p><p class="source-code">        product = 'WashingMachine'</p><p class="source-code">        pricebeforetax = 480 + (480 * 0.14)</p><p class="source-code">        tax_rate = 0.35</p><p class="source-code">        local_rate = 0.077</p><p class="source-code">        tax = pricebeforetax * (tax_rate + local_rate)</p><p class="source-code">        finalsellingprice = pricebeforetax + tax</p><p class="source-code">        print('**************ABC Megamart*****************')</p><p class="source-code">        print('***********------------------**************')</p><p class="source-code">        print(header)</p><p class="source-code">        print('Product: ', product)</p><p class="source-code">        print('Tax: ', tax)</p><p class="source-code">        print('Total Price: ', finalsellingprice)</p><p class="source-code">        print('***********------------------**************') </p><p class="source-code">        </p><p class="source-code">    def handle(self,print_invoice):</p><p class="source-code">        if print_invoice.state in InputState.state_ca:</p><p class="source-code">            self.generate_invoice(print_invoice.header, </p><p class="source-code">                                  print_invoice.state)</p><p class="source-code">        else:</p><p class="source-code">            super(CAHandler, self).handle(print_invoice)</p></li>
<li>Now, let’s <a id="_idIndexMarker564"/>define a class that will handle exceptions <a id="_idIndexMarker565"/>such as scenarios where the request does not invoke one of the child handler’s methods:<p class="source-code">class ExceptionHandler(InvoiceHandler):</p><p class="source-code">    def handle(self,print_invoice):</p><p class="source-code">        print("No branches in the state")  </p></li>
<li>Now, let’s create a requestor function that instantiates one of the child handler subclasses and initiates a chain of responsibility that transfers from one action to another:<p class="source-code">def invoice_requestor(state):</p><p class="source-code">    invoice = Print_invoice(state)</p><p class="source-code">    nychandler = NYCHandler()</p><p class="source-code">    cahandler = CAHandler()</p><p class="source-code">    nychandler.next_action = cahandler</p><p class="source-code">    cahandler.next_action = ExceptionHandler()</p><p class="source-code">    nychandler.handle(invoice)</p></li>
</ol>
<p>In the preceding code, we defined the requestor to set the next action for <strong class="source-inline">NYCHandler</strong> to <strong class="source-inline">CAHandler</strong> and the next action for <strong class="source-inline">CAHandler</strong> to be the exception handler. Let’s test this design pattern by calling the <strong class="source-inline">invoice_requestor</strong> function with the input state’s name; that is, <strong class="source-inline">CA</strong>:</p>
<pre class="source-code">invoice_requestor('CA')</pre>
<p>The preceding <a id="_idIndexMarker566"/>code returns the invoice for the state of California since <a id="_idIndexMarker567"/>we provided the input as <strong class="source-inline">CC</strong> instead of <strong class="source-inline">NY</strong>. If <strong class="source-inline">NY</strong> was provided as input, the design pattern would have invoked <strong class="source-inline">NYHandler</strong>. However, since CA was provided, the next-in-the-chain and relevant <strong class="source-inline">CAHandler</strong> is invoked as follows:  </p>
<pre class="source-code"><strong class="bold">**************ABC Megamart*****************</strong></pre>
<pre class="source-code"><strong class="bold">***********------------------**************</strong></pre>
<pre class="source-code"><strong class="bold">State specific Sales tax is applicable for the state of CA</strong></pre>
<pre class="source-code"><strong class="bold">Product:  WashingMachine</strong></pre>
<pre class="source-code"><strong class="bold">Tax:  233.6544</strong></pre>
<pre class="source-code"><strong class="bold">Total Price:  780.8544</strong></pre>
<pre class="source-code"><strong class="bold">***********------------------**************</strong></pre>
<p>If <strong class="source-inline">invoice_requestor</strong> is provided with <strong class="source-inline">NY</strong> as the input state name instead, it should call <strong class="source-inline">NYHandler</strong>, not <strong class="source-inline">CAHandler</strong>:</p>
<pre class="source-code">invoice_requestor('NYC')</pre>
<p>The preceding code returns the <strong class="source-inline">NYHandler</strong> class’s invoice and not the <strong class="source-inline">CAHandler</strong> class’s invoice, as expected:</p>
<pre class="source-code"><strong class="bold">**************ABC Megamart*****************</strong></pre>
<pre class="source-code"><strong class="bold">***********------------------**************</strong></pre>
<pre class="source-code"><strong class="bold">State specific Sales tax is applicable for the state of NYC</strong></pre>
<pre class="source-code"><strong class="bold">Product:  WashingMachine</strong></pre>
<pre class="source-code"><strong class="bold">Tax:  243.6525</strong></pre>
<pre class="source-code"><strong class="bold">Total Price:  779.1525</strong></pre>
<pre class="source-code"><strong class="bold">***********------------------**************</strong></pre>
<p>As the <a id="_idIndexMarker568"/>final part of the request, let’s call <strong class="source-inline">ExceptionHandler</strong> by <a id="_idIndexMarker569"/>providing an input state that is neither <strong class="source-inline">NY</strong> nor <strong class="source-inline">CA</strong>:</p>
<pre class="source-code">invoice_requestor('TEXAS')</pre>
<p>The preceding code returns the following output by invoking the action from <strong class="source-inline">ExceptionHandler</strong>:</p>
<p class="source-code">No branches in the state</p>
<p>Let’s connect <a id="_idIndexMarker570"/>the elements of this design pattern with its corresponding objects:</p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Figure 12.1 – Chain of responsibility classes " height="530" src="image/Figure_12.1_B13426.jpg" width="663"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Chain of responsibility classes</p>
<p>In this section, we looked at the chain of responsibility design pattern. Now, let’s look at the command design pattern.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor159"/>Learning about the command design pattern</h2>
<p>In this section, we <a id="_idIndexMarker571"/>will look at the next design <a id="_idIndexMarker572"/>pattern of interest: the command design pattern. The command design pattern can be used to create a sequence for executing commands and reverting to a previous state if a command is executed by mistake. Similar to the chain of responsibility pattern, the command design pattern is <a id="_idIndexMarker573"/>also created by defining multiple <a id="_idIndexMarker574"/>elements that can execute an action and revert the action that’s performed by an object. </p>
<p>To explain this further and to implement this design pattern, we need to develop the following elements in <a id="_idIndexMarker575"/>our code:</p>
<ul>
<li><strong class="bold">Parent command</strong>: This is a base class that defines the base functions for one or more commands that need to be executed.</li>
<li><strong class="bold">Child commands</strong>: Child commands specify one or more actions that are inherited from the parent command class and overwritten at the individual child command level.</li>
<li><strong class="bold">Executor</strong>: This is a base class for executing the child commands. It provides a method to execute the action and a method to revoke the action.</li>
<li><strong class="bold">Sub-executors</strong>: These inherit executors and overwrite the methods to execute while also revoking the actions that are performed by the child commands.</li>
<li><strong class="bold">Requestor</strong>: The requestor is a class that requests the executors to execute commands and revert to a previous state.</li>
<li><strong class="bold">Tester</strong>: This class tests if the design pattern is working as expected. </li>
</ul>
<p>Now, let’s look at this design pattern in action. To understand this design pattern, we’ll go back to <em class="italic">ABC Megamart</em> and calculate the selling price for a product, as well as apply a discount to the selling price. The command pattern <a id="_idIndexMarker576"/>can help us design billing in such a way that we can either sell at the actual selling price or apply a discount. Whenever a discount is applied by mistake, we can revert it. Similarly, whenever a discount is not applied, we can reapply it. Follow these steps:</p>
<ol>
<li value="1">Let’s start by creating the <strong class="source-inline">Billing</strong> class. This is going to be the parent command and it will have an attribute named <strong class="source-inline">sales</strong>. This is a dictionary object. There will be two abstract methods – one to apply a discount and another to remove the discount:<p class="source-code">from abc import ABC, abstractmethod</p><p class="source-code">class Billing:</p><p class="source-code">    sales = {'purchase_price': 450,</p><p class="source-code">              'profit_margin': 0.19,</p><p class="source-code">              'tax_rate': 0.4,</p><p class="source-code">              'discount_rate': 0.10</p><p class="source-code">              }        </p><p class="source-code">    @abstractmethod</p><p class="source-code">    def apply_discount(self):</p><p class="source-code">        pass</p><p class="source-code">    @abstractmethod</p><p class="source-code">    def remove_discount(self):</p><p class="source-code">        pass</p></li>
<li>Now, let’s <a id="_idIndexMarker577"/>create the first child <a id="_idIndexMarker578"/>command class, <strong class="source-inline">DiscountedBilling</strong>, which will overwrite the <strong class="source-inline">apply_discount</strong> method from its parent class, <strong class="source-inline">Billing</strong>. Applying the <strong class="source-inline">Discount</strong> method will take in the sales dictionary object from the <strong class="source-inline">Billing</strong> class and calculate the discounted price, as shown here:<p class="source-code">class DiscountedBilling(Billing):</p><p class="source-code">    def apply_discount(self):</p><p class="source-code">        sales = self.sales</p><p class="source-code">        pricebeforetax = sales['purchase_price'] + </p><p class="source-code">             sales['purchase_price'] * sales['profit_margin']</p><p class="source-code">        finalsellingprice = pricebeforetax + (pricebeforetax * </p><p class="source-code">        sales['tax_rate'])</p><p class="source-code">        sales['sellingPrice'] = finalsellingprice</p><p class="source-code">        discountedPrice = sales['sellingPrice'] * (1 – </p><p class="source-code">                          sales['discount_rate'])</p><p class="source-code">        return discountedPrice</p></li>
<li>Next, we will create the next child command class, <strong class="source-inline">ActualBilling</strong>, which will remove the discount. – That is, it will calculate the selling price without a discount:<p class="source-code">class ActualBilling(Billing):</p><p class="source-code">    def remove_discount(self):</p><p class="source-code">        sales = self.sales</p><p class="source-code">        pricebeforetax = sales['purchase_price'] + </p><p class="source-code">             sales['purchase_price'] * sales['profit_margin']</p><p class="source-code">        actualprice = pricebeforetax + (pricebeforetax * </p><p class="source-code">                      sales['tax_rate'])</p><p class="source-code">        return actualprice</p></li>
<li>Now, let’s <a id="_idIndexMarker579"/>create the base class <a id="_idIndexMarker580"/>for the executor. This will have two methods: <strong class="source-inline">exec_discount</strong> and <strong class="source-inline">revoke_discount</strong>. The first is an abstract method for executing the command that applies the discount. And the second is an abstract method for executing the command that revokes the discount:<p class="source-code">class ExecuteBilling:</p><p class="source-code">    @abstractmethod</p><p class="source-code">    def exec_discount(self):</p><p class="source-code">        pass</p><p class="source-code">    @abstractmethod</p><p class="source-code">    def revoke_discount(self):</p><p class="source-code">        pass</p></li>
<li>Now, let’s define a child class named <strong class="source-inline">ExecuteDiscountedBilling</strong> that inherits from the <strong class="source-inline">ExecuteBilling</strong> class. This will overwrite the <strong class="source-inline">exec_discount</strong> and <strong class="source-inline">revoke_discount</strong> methods from its superclass. We will call <a id="_idIndexMarker581"/>the <strong class="source-inline">apply_discount</strong> method <a id="_idIndexMarker582"/>from the <strong class="source-inline">DiscountedBilling</strong> class within the <strong class="source-inline">exec_discount</strong> method of this child class. We will also set the <strong class="source-inline">ActualBilling</strong> command class from the <strong class="source-inline">ExecuteActualBilling</strong> class within the <strong class="source-inline">revoke_discount</strong> method: <p class="source-code">class ExecuteDiscountedBilling(ExecuteBilling):</p><p class="source-code">    def __init__(self, instance):</p><p class="source-code">        self.instance = instance        </p><p class="source-code">    def exec_discount(self):</p><p class="source-code">        print('Discount applied...')</p><p class="source-code">        return self.instance.apply_discount()        </p><p class="source-code">    def revoke_discount(self, revokeInstance):</p><p class="source-code">        revokeInstance.reset(ExecuteActualBilling(</p><p class="source-code">                             ActualBilling()))</p><p class="source-code">        return revokeInstance.runcalc()</p></li>
<li>Now, let’s define a child class named <strong class="source-inline">ExecuteActualBilling</strong> that inherits from the <strong class="source-inline">ExecuteBilling</strong> class. This will overwrite the <strong class="source-inline">exec_discount</strong> and <strong class="source-inline">revoke_discount</strong> methods from its superclass. We will call the <strong class="source-inline">remove_discount</strong> method from the <strong class="source-inline">ActualBilling</strong> class within the <strong class="source-inline">exec_discount</strong> method of this child class. We will also set the <strong class="source-inline">DiscountedBilling</strong> command class from the <strong class="source-inline">ExecuteDiscountedBilling</strong> class within the <strong class="source-inline">revoke_discount</strong> method:<p class="source-code">class ExecuteActualBilling(ExecuteBilling):</p><p class="source-code">    def __init__(self, instance):</p><p class="source-code">        self.instance = instance</p><p class="source-code">        </p><p class="source-code">    def exec_discount(self):</p><p class="source-code">        print('Discount removed...')</p><p class="source-code">        return self.instance.remove_discount()</p><p class="source-code">        </p><p class="source-code">    def revoke_discount(self, revokeInstance):</p><p class="source-code">        revokeInstance.reset(ExecuteDiscountedBilling(</p><p class="source-code">                             DiscountedBilling()))</p><p class="source-code">        return revokeInstance.runcalc()</p></li>
<li>Next, we <a id="_idIndexMarker583"/>will define the requestor <a id="_idIndexMarker584"/>class, <strong class="source-inline">RequestAction</strong>, which will request the commands to be executed and reverted as required. We will also define three methods:<ul><li> The <strong class="source-inline">reset</strong> method, which will set or reset the command </li><li>The <strong class="source-inline">runcalc</strong> method, which will execute the discount calculation </li><li>The <strong class="source-inline">revert</strong> method, which will revert to the previous action by revoking the discount calculation:</li></ul></li>
</ol>
<p>In the code block:</p>
<p class="source-code">class RequestAction:</p>
<p class="source-code">    def __init__(self, action):</p>
<p class="source-code">        self.action = action</p>
<p class="source-code">    def reset(self, action):</p>
<p class="source-code">        print("Resetting command...")</p>
<p class="source-code">        self.action = action</p>
<p class="source-code">    def runcalc(self):</p>
<p class="source-code">        return self.action.exec_discount()</p>
<p class="source-code">    def revert(self):</p>
<p class="source-code">        print("Reverting the previous action...")</p>
<p class="source-code">        return self.action.revoke_discount(self)</p>
<ol>
<li value="8">Finally, we <a id="_idIndexMarker585"/>must create the <a id="_idIndexMarker586"/>final class in this design pattern to test that the command design pattern works as expected:<p class="source-code">class Tester:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        billing = Billing()</p><p class="source-code">        discount = </p><p class="source-code">                 ExecuteDiscountedBilling (DiscountedBilling())</p><p class="source-code">        actual = ExecuteActualBilling(ActualBilling())</p><p class="source-code">        requestor = RequestAction(discount)  </p><p class="source-code">        print(requestor.runcalc())</p><p class="source-code">        requestor.reset(actual)</p><p class="source-code">        print(requestor.runcalc())</p><p class="source-code">        print(requestor.revert())</p><p class="source-code">        print(requestor.revert())</p></li>
</ol>
<p>In the preceding code, we defined an object instance of the <strong class="source-inline">Billing</strong> class, followed by the instances that can be discounted and the actual <strong class="source-inline">ExecuteBilling</strong> subclasses. We also created an instance of the <strong class="source-inline">RequestAction</strong> requestor class. After that, we sequenced a set of operations to run the discount calculation, then the <strong class="source-inline">reset</strong> command, followed by rerunning <a id="_idIndexMarker587"/>the calculation to remove <a id="_idIndexMarker588"/>the discount. This will revert the previous command and thus reapply the discount before reverting the previous command, which will, in turn, remove the discount. </p>
<p>Let’s call the <strong class="source-inline">Tester</strong> class, as follows:</p>
<p class="source-code">Tester()</p>
<p>The output of the preceding code is as follows:</p>
<p class="source-code"><strong class="bold">Discount applied...</strong></p>
<p class="source-code"><strong class="bold">674.73</strong></p>
<p class="source-code"><strong class="bold">Resetting command...</strong></p>
<p class="source-code"><strong class="bold">Discount removed...</strong></p>
<p class="source-code"><strong class="bold">749.7</strong></p>
<p class="source-code"><strong class="bold">Reverting the previous action...</strong></p>
<p class="source-code"><strong class="bold">Resetting command...</strong></p>
<p class="source-code"><strong class="bold">Discount applied...</strong></p>
<p class="source-code"><strong class="bold">674.73</strong></p>
<p class="source-code"><strong class="bold">Reverting the previous action...</strong></p>
<p class="source-code"><strong class="bold">Resetting command...</strong></p>
<p class="source-code"><strong class="bold">Discount removed...</strong></p>
<p class="source-code"><strong class="bold">749.7</strong></p>
<p class="source-code"><strong class="bold">&lt;__main__.Tester at 0x261f09e3b20&gt;</strong></p>
<p>Now, let’s connect the <a id="_idIndexMarker589"/>elements of this design pattern with its corresponding objects:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 12.2 – Command design pattern classes " height="2096" src="image/Figure_12.2_B13426.jpg" width="1042"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Command design pattern classes</p>
<p>In this section, we looked at the concept of the command design pattern. Now, let’s look at the strategy design pattern.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>The strategy design pattern</h2>
<p>In this section, we’ll <a id="_idIndexMarker590"/>look at the final design pattern under the <a id="_idIndexMarker591"/>category of behavioral design patterns that we will be covering in this chapter. Let’s look at the elements of the strategy <a id="_idIndexMarker592"/>pattern, as follows:</p>
<ul>
<li><strong class="bold">Domain</strong>: A domain or base class defines all the base methods and attributes required for Python objects to perform a sequence of operations. This class also makes decisions concerning the operation that’s performed within the class according to the strategy method defined in the strategy classes.</li>
<li><strong class="bold">Strategies</strong>: These are one or more independent classes that define one specific strategy within its strategy method. The same strategy method name will be used in each of the strategy classes.</li>
<li><strong class="bold">Tester</strong>: A tester function calls the domain class and executes the strategy.</li>
</ul>
<p>To understand how the strategy design pattern is implemented, we’ll look at various billing counters that we covered in <a href="B13426_08_Final_PG_epub.xhtml#_idTextAnchor107"><em class="italic">Chapter 8</em></a>. There are various billing counters in <em class="italic">ABC Megamart</em>, including a vegetable counter, a less than 10 item counter, an electronics counter, and so on. </p>
<p>In this example, we will <a id="_idIndexMarker593"/>define a vegetable counter and an electronics counter as strategy classes. Follow these steps:</p>
<ol>
<li value="1">To begin with, we will define a domain class named <strong class="source-inline">SuperMarket</strong> with methods that do the following: <ol><li>Initialize attributes</li><li>Display details about the items in the cart</li><li>Go to a specific counter</li></ol></li>
</ol>
<p>Here is what the code for this looks like:</p>
<p class="source-code">class SuperMarket():</p>
<p class="source-code">    </p>
<p class="source-code">    def __init__(self,STRATEGY, items, name, scan, units, tax, </p>
<p class="source-code">                 itemtype = None):</p>
<p class="source-code">        self.STRATEGY = STRATEGY</p>
<p class="source-code">        self.items = items</p>
<p class="source-code">        self.name = name</p>
<p class="source-code">        self.scan = scan</p>
<p class="source-code">        self.units = units</p>
<p class="source-code">        self.tax = tax</p>
<p class="source-code">        self.itemtype = itemtype</p>
<p class="source-code">       </p>
<p class="source-code">    def return_cart(self):</p>
<p class="source-code">        cartItems = []</p>
<p class="source-code">        for i in self.items:</p>
<p class="source-code">            cartItems.append(i)</p>
<p class="source-code">        return cartItems</p>
<p class="source-code">    </p>
<p class="source-code">    def goto_counter(self):</p>
<p class="source-code">        countername = self.name</p>
<p class="source-code">        return countername</p>
<ol>
<li value="2">Next, we <a id="_idIndexMarker594"/>will define <a id="_idIndexMarker595"/>methods that do the following:<ul><li>Scan the bar codes</li><li>Add the bill details</li><li>Add the tax details</li></ul></li>
</ol>
<p>Here is the code for this:</p>
<p class="source-code">    def scan_bar_code(self):</p>
<p class="source-code">        codes = []</p>
<p class="source-code">        for i in self.scan:</p>
<p class="source-code">            codes.append(i)</p>
<p class="source-code">        return codes</p>
<p class="source-code">          </p>
<p class="source-code">    def add_billing(self):</p>
<p class="source-code">        self.codes = self.scan_bar_code()</p>
<p class="source-code">        pricetag = []</p>
<p class="source-code">        for i in self.units:</p>
<p class="source-code">            pricetag.append(i)</p>
<p class="source-code">        bill = dict(zip(self.codes, pricetag))</p>
<p class="source-code">        return bill</p>
<p class="source-code">        </p>
<p class="source-code">    def add_tax(self):</p>
<p class="source-code">        taxed = []</p>
<p class="source-code">        for i in self.tax:</p>
<p class="source-code">            taxed.append(i)</p>
<p class="source-code">        return taxed</p>
<ol>
<li value="3">The <a id="_idIndexMarker596"/>operations for calculating the bill and printing <a id="_idIndexMarker597"/>the invoice are also defined in the <strong class="source-inline">SuperMarket</strong> class. Refer to the following code:<p class="source-code">    def calc_bill(self):</p><p class="source-code">        bill = self.add_billing()</p><p class="source-code">        items = []</p><p class="source-code">        cartItems = self.return_cart()</p><p class="source-code">        calc_bill = []</p><p class="source-code">        taxes = self.add_tax()</p><p class="source-code">        for item,tax in zip(bill.items(),taxes):</p><p class="source-code">            items.append(item[1])</p><p class="source-code">            calc_bill.append(item[1] + item[1]*tax)</p><p class="source-code">        finalbill = dict(zip(cartItems, calc_bill))</p><p class="source-code">        return finalbill</p><p class="source-code">        </p><p class="source-code">    def print_invoice(self):</p><p class="source-code">        finalbill = self.calc_bill()</p><p class="source-code">        final_total = sum(finalbill.values())</p><p class="source-code">        print('**************ABC Megamart*****************')</p><p class="source-code">        print('***********------------------**************')</p><p class="source-code">        print('Counter Name: ', self.goto_counter())</p><p class="source-code">        for item,price in finalbill.items():</p><p class="source-code">            print(item,": ", price)</p><p class="source-code">        print('Total:',final_total)</p><p class="source-code">        print('***********------------------**************')</p><p class="source-code">        print('***************PAID************************')</p></li>
<li>The final method within the <strong class="source-inline">SuperMarket</strong> class is the <strong class="source-inline">pipeline_template</strong> method, which creates a pipeline for running the sequence of methods:<p class="source-code">    def pipeline_template(self):</p><p class="source-code">        self.return_cart()</p><p class="source-code">        self.goto_counter()</p><p class="source-code">        self.STRATEGY.redirect_counter()</p><p class="source-code">        self.scan_bar_code()</p><p class="source-code">        self.add_billing()</p><p class="source-code">        self.add_tax()</p><p class="source-code">        self.calc_bill()</p><p class="source-code">        self.print_invoice()</p></li>
</ol>
<p>In this <a id="_idIndexMarker598"/>method, we have called the strategy <a id="_idIndexMarker599"/>method to change the strategy that’s performed by the <strong class="source-inline">SuperMarket</strong> class.</p>
<ol>
<li value="5">Now, let’s define a simple strategy class for the vegetable counter, as follows:<p class="source-code">class VegeCounter():</p><p class="source-code">    def redirect_counter():</p><p class="source-code">        print("**************Move to Vege Counter**************")</p></li>
<li>Let’s also create a simple strategy class for the electronic counter, as follows:<p class="source-code">class ElectronicsCounter():</p><p class="source-code">    def redirect_counter():</p><p class="source-code">        print("**************Move to Electronics </p><p class="source-code">              Counter**************")</p></li>
<li>Now, we must define a tester function to test the strategy:<p class="source-code">def run_pipeline(domain = SuperMarket):</p><p class="source-code">    domain.pipeline_template()</p></li>
<li>Let’s test <a id="_idIndexMarker600"/>the strategy for the vegetable counter by <a id="_idIndexMarker601"/>running the pipeline and providing <strong class="source-inline">VegeCounter</strong> as the strategy value:<p class="source-code">run_pipeline(SuperMarket(STRATEGY = VegeCounter,</p><p class="source-code">           items = ['Onions','Tomatoes','Cabbage','Beetroot'],</p><p class="source-code">           name = ['Vegetable Counter'],</p><p class="source-code">           scan = [113323,3434332,2131243,2332783],</p><p class="source-code">           units = [10,15,12,14],</p><p class="source-code">           tax = [0.04,0.03,0.035,0.025],</p><p class="source-code">           itemtype = ['Vegetables'],</p><p class="source-code">           ))</p></li>
<li>The output for the <strong class="source-inline">VegeCounter</strong> strategy is as follows:<p class="source-code">**************Move to Vege Counter**************</p><p class="source-code">**************ABC Megamart*****************</p><p class="source-code">***********------------------**************</p><p class="source-code">Counter Name:<strong class="bold">  </strong>['Vegetable Counter']</p><p class="source-code">Onions :<strong class="bold">  </strong>10.4</p><p class="source-code">Tomatoes :<strong class="bold">  </strong>15.45</p><p class="source-code">Cabbage :<strong class="bold">  </strong>12.42</p><p class="source-code">Beetroot :<strong class="bold">  </strong>14.35</p><p class="source-code">Total: 52.620000000000005</p><p class="source-code">***********------------------**************</p><p class="source-code">***************PAID************************</p></li>
<li>Now, let’s test the strategy for the electronics counter by running the pipeline and providing <strong class="source-inline">ElectronicsCounter</strong> as the strategy value:<p class="source-code">run_pipeline(SuperMarket(STRATEGY = ElectronicsCounter,</p><p class="source-code">                    items = ['television','keyboard','mouse'],</p><p class="source-code">                    name = ['Electronics Counter'],</p><p class="source-code">                    scan = [113323,3434332,2131243],</p><p class="source-code">                    units = [100,16,14],</p><p class="source-code">                    tax = [0.04,0.03,0.035],</p><p class="source-code">                    itemtype = ['Electronics'],</p><p class="source-code">                    ))</p></li>
</ol>
<p>The <a id="_idIndexMarker602"/>output for the <strong class="source-inline">ElectronicsCounter</strong> strategy <a id="_idIndexMarker603"/>is as follows:</p>
<p class="source-code"><strong class="bold">**************Move to Electronics Counter**************</strong></p>
<p class="source-code"><strong class="bold">**************ABC Megamart*****************</strong></p>
<p class="source-code"><strong class="bold">***********------------------**************</strong></p>
<p class="source-code"><strong class="bold">Counter Name:  ['Electronics Counter']</strong></p>
<p class="source-code"><strong class="bold">television :  104.0</strong></p>
<p class="source-code"><strong class="bold">keyboard :  16.48</strong></p>
<p class="source-code"><strong class="bold">mouse :  14.49</strong></p>
<p class="source-code"><strong class="bold">Total: 134.97</strong></p>
<p class="source-code"><strong class="bold">***********------------------**************</strong></p>
<p class="source-code"><strong class="bold">***************PAID************************</strong></p>
<p>Now, let’s connect <a id="_idIndexMarker604"/>the elements of this design pattern with its corresponding objects: </p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 12.3 – Strategy pattern with classes " height="869" src="image/Figure_12.3_B13426.jpg" width="1536"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Strategy pattern with classes</p>
<p>With that, we have learned about the strategy design pattern. Now, let’s summarize this chapter.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor161"/>Summary</h1>
<p>In this chapter, we learned about behavioral design patterns by applying some of them in Python 3. In particular, we implemented the chain of responsibility, command, and strategy patterns and understood each of their elements. </p>
<p>Similar to the other chapters in this book, this chapter has been split into two parts – this chapter explained design patterns and focused on metaprogramming and its impact on Python code.</p>
<p>In the next chapter, we will continue looking at the concept of design patterns by covering examples of structural and creational design patterns.</p>
</div>
</div></body></html>