<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor157" class="pcalibre calibre4 pcalibre1"/>4</h1>
			<h1 id="_idParaDest-84" class="calibre6"><a id="_idTextAnchor158" class="pcalibre calibre4 pcalibre1"/>Writing and Building a ROS 2 Node</h1>
			<p class="calibre3">To write your own custom code with ROS 2, you will have to create ROS 2 programs, or in other words, nodes. You already discovered the concept of nodes in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>. In this chapter, we will go deeper, and you will write your first node with Python and C++.</p>
			<p class="calibre3">Before you create a node, there is a bit of setup to do: you need to create a ROS 2 workspace, in which you will build your application. In this workspace, you will then add packages to better organize your nodes. Then, in those packages, you can start to write your nodes. After you write a node, you will build it and run it.</p>
			<p class="calibre3">We will do this complete process together, with hands-on code and command lines all along the way. This is the process that you will repeat for any new node you create when developing a ROS 2 application.</p>
			<p class="calibre3">By the end of this chapter, you will be able to create your own packages and ROS 2 nodes with Python and C++. You will also be able to run and introspect your nodes from the terminal. This is the stepping stone you need in order to learn any other ROS 2 functionality. There is no topic, service, action, parameter, or launch file without nodes.</p>
			<p class="calibre3">All explanations will start with Python, followed by C++, which we’ll cover more quickly. If you only want to learn with Python, you can skip the C++ sections. However, if you want to learn with C++, reading the previous Python explanations is mandatory for comprehension.</p>
			<p class="calibre3">All the code examples for this chapter can be found in the <strong class="source-inline1">ch4</strong> folder of the book’s GitHub repository (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>).</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">Creating and setting up a ROS 2 workspace</li>
				<li class="calibre10">Creating a package</li>
				<li class="calibre10">Creating a Python node</li>
				<li class="calibre10">Creating a C++ node</li>
				<li class="calibre10">Node template for Python and C++ nodes</li>
				<li class="calibre10">Introspecting your nodes</li>
			</ul>
			<h1 id="_idParaDest-85" class="calibre6"><a id="_idTextAnchor159" class="pcalibre calibre4 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">To follow this chapter, you need the following:</p>
			<ul class="calibre9">
				<li class="calibre10">Ubuntu 24.04 installed (dual boot or virtual machine)</li>
				<li class="calibre10">ROS Jazzy</li>
				<li class="calibre10">A text editor or IDE (for example, VS Code with the ROS extension)</li>
			</ul>
			<p class="calibre3">These requirements will be valid for all chapters in <em class="italic">Part 2</em>.</p>
			<h1 id="_idParaDest-86" class="calibre6"><a id="_idTextAnchor160" class="pcalibre calibre4 pcalibre1"/>Creating and setting up a ROS 2 workspace</h1>
			<p class="calibre3">Before we write <a id="_idIndexMarker176" class="pcalibre calibre4 pcalibre1"/>any code, we need to do a bit of organization. Nodes will exist within packages, and all your packages will exist within a <strong class="bold">ROS </strong><strong class="bold">2 workspace</strong>.</p>
			<p class="calibre3">What is a ROS 2 <a id="_idIndexMarker177" class="pcalibre calibre4 pcalibre1"/>workspace? A <strong class="bold">workspace</strong> is nothing more than a folder organization in which you will create and build your packages. Your entire ROS 2 application will live within this workspace.</p>
			<p class="calibre3">To create one, you have to follow certain rules. Let’s create your first workspace step by step and correctly set it up<a id="_idTextAnchor161" class="pcalibre calibre4 pcalibre1"/>.</p>
			<h2 id="_idParaDest-87" class="calibre6"><a id="_idTextAnchor162" class="pcalibre calibre4 pcalibre1"/>Creating a workspace</h2>
			<p class="calibre3">To create <a id="_idIndexMarker178" class="pcalibre calibre4 pcalibre1"/>a workspace, you will simply create a new directory inside your home directory.</p>
			<p class="calibre3">As for the workspace’s name, let’s keep it simple for now and use something that is recognizable: <strong class="source-inline1">ros2_ws</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The name of the workspace is not important, and it will not affect anything in your application. As we are just getting started, we only have one workspace. When you make progress and start to work on several applications, the best practice is to name each workspace with the name of the application or robot. For example, if you create a workspace for a robot named <code>ABC V3</code>, then you can name it <code>abc_v3_ws</code>.</p>
			<p class="calibre3">Open a terminal, navigate to your home directory, and create the workspace:</p>
			<pre class="console">
$ cd
$ mkdir ros2_ws</pre>			<p class="calibre3">Then, enter the <a id="_idIndexMarker179" class="pcalibre calibre4 pcalibre1"/>workspace and create a new directory named <strong class="source-inline1">src</strong>. This is where you will write all the code for your ROS 2 application:</p>
			<pre class="console">
$ cd ros2_ws/
$ mkdir src</pre>			<p class="calibre3">That’s really all there is to it. To set up a new workspace, you just create a new directory (somewhere in your home directory) and create an <strong class="source-inline1">src</strong> directory inside <a id="_idTextAnchor163" class="pcalibre calibre4 pcalibre1"/>it.</p>
			<h2 id="_idParaDest-88" class="calibre6"><a id="_idTextAnchor164" class="pcalibre calibre4 pcalibre1"/>Building the workspace</h2>
			<p class="calibre3">Even if the <a id="_idIndexMarker180" class="pcalibre calibre4 pcalibre1"/>workspace is empty (we have not created any packages yet), we can still build it. To do that, follow these steps:</p>
			<ol class="calibre11">
				<li class="calibre10">Navigate to the workspace root directory. Make sure you are in the right place.</li>
				<li class="calibre10">Run the <code>colcon build</code> command. <code>colcon</code> is the build system in ROS 2, and it was installed when you installed the <code>ros-dev-tools</code> packages in <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 2</em></a>.</li>
			</ol>
			<p class="calibre3">Let’s build the workspace:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build
Summary: 0 packages finished [0.73s]</pre>			<p class="calibre3">As you can see, no packages were built, but let’s list all directories under <strong class="source-inline1">~/ros2_ws</strong>:</p>
			<pre class="console">
$ ls
build  install  log  src</pre>			<p class="calibre3">As you can see, we have three new directories: <strong class="source-inline1">build</strong>, <strong class="source-inline1">install</strong>, and <strong class="source-inline1">log</strong>. The <strong class="source-inline1">build</strong> directory will contain the intermediate files required for the overall build. In <strong class="source-inline1">log</strong>, you will find logs for each build. The most important directory for you is <strong class="source-inline1">install</strong>, which is <a id="_idIndexMarker181" class="pcalibre calibre4 pcalibre1"/>where all your nodes will be installed after you build the workspace.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You should always run <code>colcon build</code> from the root of your workspace directory, not from anywhere else. If you make a mistake and run this command from another directory (let’s say, from the <code>src</code> directory of the workspace, or inside a package), simply remove the new <code>install</code>, <code>build</code>, and <code>log</code> directories that were created in the wrong place. Then go back to the workspace root directory and build a<a id="_idTextAnchor165" class="pcalibre calibre4 pcalibre1"/>gain.</p>
			<h2 id="_idParaDest-89" class="calibre6"><a id="_idTextAnchor166" class="pcalibre calibre4 pcalibre1"/>Sourcing the workspace</h2>
			<p class="calibre3">If you <a id="_idIndexMarker182" class="pcalibre calibre4 pcalibre1"/>navigate inside the newly created <strong class="source-inline1">install</strong> directory, you can see a <strong class="source-inline1">setup.bash</strong> file:</p>
			<pre class="console">
$ cd install/
$ ls
COLCON_IGNORE       _local_setup_util_ps1.py   setup.ps1 
local_setup.bash    _local_setup_util_sh.py    setup.sh
local_setup.ps1     local_setup.zsh            setup.zsh
local_setup.sh      setup.bash</pre>			<p class="calibre3">This might look familiar. If you remember, after we installed ROS 2, we sourced a similar bash script from the ROS 2 installation directory (<strong class="source-inline1">/opt/ros/jazzy/setup.bash</strong>) so that we could use ROS 2 in our environment. We will need to do the same for our workspace.</p>
			<p class="calibre3">Every time you build your workspace, you have to source it so that the environment (the session you are in) knows about the new changes in the workspace.</p>
			<p class="calibre3">To source the workspace, source this <strong class="source-inline1">setup.bash</strong> script:</p>
			<pre class="console">
$ source ~/ros2_ws/install/setup.bash</pre>			<p class="calibre3">Then, as we previously did, we are going to add that line into our <strong class="source-inline1">.bashrc</strong>. This way, you don’t need to source the workspace every time you open a new terminal.</p>
			<p class="calibre3">Open your <strong class="source-inline1">.bashrc</strong> (located in your home directory the path is <strong class="source-inline1">~/.bashrc</strong>) using any text editor you want:</p>
			<pre class="console">
$ gedit ~/.bashrc</pre>			<p class="calibre3">Add the line to source the workspace’s <strong class="source-inline1">setup.bash</strong> script, just after the one to source the global ROS 2 installation. The order is very important here. You <a id="_idIndexMarker183" class="pcalibre calibre4 pcalibre1"/>have to source the global ROS 2 installation first, and then your workspace, not the other way around:</p>
			<pre class="source-code">
source /opt/ros/jazzy/setup.bash
source ~/ros2_ws/install/setup.bash</pre>			<p class="calibre3">Make sure to save<strong class="source-inline1">.bashrc</strong>. Now, both ROS 2 and your workspace will be sourced in any new terminal you open.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you build the workspace in an already sourced environment, you will still need to source the workspace once again as there have been some changes, and the environment is not aware of that. In this case, you can either source the workspace’s <code>setup.bash</code> script directly, source the <code>.bashrc</code>, or open a new te<a id="_idTextAnchor167" class="pcalibre calibre4 pcalibre1"/>rminal.</p>
			<p class="calibre3">Your workspace is now correctly set up, and you can build your application. Next step: creating a p<a id="_idTextAnchor168" class="pcalibre calibre4 pcalibre1"/>ackage.</p>
			<h1 id="_idParaDest-90" class="calibre6"><a id="_idTextAnchor169" class="pcalibre calibre4 pcalibre1"/>Creating a package</h1>
			<p class="calibre3">Any node <a id="_idIndexMarker184" class="pcalibre calibre4 pcalibre1"/>you create will exist within a package. Hence, to create a node, you first have to create a package (inside your workspace). You will now learn how to create your own packages, and we will see the differences between Python and C++ packages.</p>
			<p class="calibre3">But first, what exactly is a <a id="_idTextAnchor170" class="pcalibre calibre4 pcalibre1"/>package?</p>
			<h2 id="_idParaDest-91" class="calibre6"><a id="_idTextAnchor171" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 package?</h2>
			<p class="calibre3">A ROS 2 package is a sub-part of your application.</p>
			<p class="calibre3">Let’s consider <a id="_idIndexMarker185" class="pcalibre calibre4 pcalibre1"/>a robotic arm that we want to use to pick up and place objects. Before we create any node, we can try to split this application into several sub-parts, or packages.</p>
			<p class="calibre3">We could have one package to handle a camera, another package for the hardware control (motors), and yet another package to compute motion planning for the robot.</p>
			<div><div><img alt="Figure 4.1﻿ – Example of a package organization for a robot" src="img/B22403_04_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Example of a package organization for a robot</p>
			<p class="calibre3">Each package is an independent unit, responsible for one sub-part of your application.</p>
			<p class="calibre3">Packages are very useful for organizing your nodes, and also to correctly handle dependencies, as we will see later in this book.</p>
			<p class="calibre3">Now, let’s create a package, and here you have to make a choice. If you want to create a node with Python, you will create a Python package, and if you want to create a node with C++, you will create a C++ package. The architecture for each package type is quite di<a id="_idTextAnchor172" class="pcalibre calibre4 pcalibre1"/>fferent.</p>
			<h2 id="_idParaDest-92" class="calibre6"><a id="_idTextAnchor173" class="pcalibre calibre4 pcalibre1"/>Creating a Python package</h2>
			<p class="calibre3">You will create all your packages in the <strong class="source-inline1">src</strong> directory of your ROS 2 workspace. So, make sure <a id="_idIndexMarker186" class="pcalibre calibre4 pcalibre1"/>to navigate to this directory before you do anything else:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/</pre>			<p class="calibre3">Here is how to construct the command to create a package:</p>
			<ol class="calibre11">
				<li class="calibre10"><code>ros2 pkg create &lt;pkg_name&gt;</code>: This is the minimum you need to write.</li>
				<li class="calibre10">You can specify a build type with <code>--build_type &lt;build_type&gt;</code>. For a Python package, we need to use <code>ament_python</code>.</li>
				<li class="calibre10">You can also specify some optional dependencies with <code>--dependencies &lt;list_of_dependencies_separated_with_spaces&gt;</code>. It’s always possible to add dependencies later in the package.</li>
			</ol>
			<p class="calibre3">Let’s create our first package named <strong class="source-inline1">my_py_pkg</strong>. We will use this name as an example to work with the main ROS 2 concepts. Then, as we progress, we will use more meaningful names. In the <strong class="source-inline1">src</strong> directory of your workspace, run the following:</p>
			<pre class="console">
$ ros2 pkg create my_py_pkg --build-type ament_python --dependencies rclpy</pre>			<p class="calibre3">With this command, we say that we want to create a package named <strong class="source-inline1">my_py_pkg</strong>, with the <strong class="source-inline1">ament_python</strong> build type, and we specify one dependency: <strong class="source-inline1">rclpy</strong>—this is the Python library for ROS 2 that you will use in every Python node.</p>
			<p class="calibre3">This will print quite a few logs, showing you what files have been created. You might also get a <strong class="source-inline1">[WARNING]</strong> log about a missing license, but as we have no intention of publishing this package anywhere, we don’t need a license file now. You can ignore this warning.</p>
			<p class="calibre3">You can then see that there is a new directory named <strong class="source-inline1">my_py_pkg</strong>. Here is the architecture of your newly created Python package:</p>
			<pre class="source-code">
/home/&lt;user&gt;/ros2_ws/src/my_py_pkg
├── my_py_pkg
│   └── __init__.py
├── package.xml
├── resource
│   └── my_py_pkg
├── setup.cfg
├── setup.py
└── test
    ├── test_copyright.py
    ├── test_flake8.py
    └── test_pep257.py</pre>			<p class="calibre3">Not all the <a id="_idIndexMarker187" class="pcalibre calibre4 pcalibre1"/>files are important right now. We’ll see how to use those files to configure and install our nodes just a bit later.</p>
			<p class="calibre3">Here is a quick overview of the most important files and directories:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>my_py_pkg</code>: As you can see, inside the package, there is another directory with the same name. This directory already contains an <code>__init__.py</code> file. This is where we will create our Python nodes.</li>
				<li class="calibre10"><code>package.xml</code>: Every ROS 2 package (Python or C++) must contain this file. We will use it to provide more information about the package as well as dependencies.</li>
				<li class="calibre10"><code>setup.py</code>: This is where you will write the instructions to build and install your Pyt<a id="_idTextAnchor174" class="pcalibre calibre4 pcalibre1"/>hon nodes.</li>
			</ul>
			<h2 id="_idParaDest-93" class="calibre6"><a id="_idTextAnchor175" class="pcalibre calibre4 pcalibre1"/>Creating a C++ package</h2>
			<p class="calibre3">We will <a id="_idIndexMarker188" class="pcalibre calibre4 pcalibre1"/>work a lot with Python in this book, but for completeness, I will also include C++ code for all examples. They will either be explained in the book, or the code will be in the GitHub repository.</p>
			<p class="calibre3">Creating a C++ package is very similar to creating a Python package; however, the architecture of the package will be quite different.</p>
			<p class="calibre3">Make sure you navigate to the <strong class="source-inline1">src</strong> directory of your workspace, and then create a new package. Let’s use a similar pattern as we did for Python and name the package <strong class="source-inline1">my_cpp_pkg</strong>:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/
$ ros2 pkg create my_cpp_pkg --build-type ament_cmake --dependencies rclcpp</pre>			<p class="calibre3">We choose <strong class="source-inline1">ament_cmake</strong> for the build type (meaning this will be a C++ package), and we specify one dependency: <strong class="source-inline1">rclcpp</strong>—this is the C++ library for ROS 2, which we will use in every C++ node.</p>
			<p class="calibre3">Once again, you should see quite a few logs, with the newly created files, and maybe a warning <a id="_idIndexMarker189" class="pcalibre calibre4 pcalibre1"/>about the license that you can ignore.</p>
			<p class="calibre3">The architecture of your new C++ package will look like this:</p>
			<pre class="source-code">
/home/ed/ros2_ws/src/my_cpp_pkg/
├── CMakeLists.txt
├── include
│   └── my_cpp_pkg
├── package.xml
└── src</pre>			<p class="calibre3">Here is a quick explanation of the role of each file or directory:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>CMakeLists.txt</code>: This will be used to provide instructions on how to compile your C++ nodes, create libraries, and so on.</li>
				<li class="calibre10"><code>include</code> directory: In a C++ project, you may split your code into implementation files (<code>.cpp</code> extension) and header files (<code>.hpp</code> extension). If you split your C++ nodes into <code>.cpp</code> and <code>.hpp</code> files, you will put the header files inside the <code>include</code> directory.</li>
				<li class="calibre10"><code>package.xml</code>: This file is required for any kind of ROS 2 package. It contains more information <a id="_idIndexMarker190" class="pcalibre calibre4 pcalibre1"/>about the package, and dependencies on other packages.</li>
				<li class="calibre10"><code>src</code> directory: This is where you will write your C++ nodes <a id="_idTextAnchor176" class="pcalibre calibre4 pcalibre1"/>(<code>.</code><code>cpp</code> files).</li>
			</ul>
			<h2 id="_idParaDest-94" class="calibre6"><a id="_idTextAnchor177" class="pcalibre calibre4 pcalibre1"/>Building a package</h2>
			<p class="calibre3">Now that <a id="_idIndexMarker191" class="pcalibre calibre4 pcalibre1"/>you’ve created one or more packages, you can build them, even if you don’t have any nodes in the packages yet.</p>
			<p class="calibre3">To build the packages, go back to the root of your ROS 2 workspace and run <strong class="source-inline1">colcon build</strong>. Once again, and as seen previously in this chapter, where you run this command is very important.</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build
Starting &gt;&gt;&gt; my_cpp_pkg
Starting &gt;&gt;&gt; my_py_pkg
Finished &lt;&lt;&lt; my_py_pkg [1.60s]
Finished &lt;&lt;&lt; my_cpp_pkg [3.46s]
Summary: 2 packages finished [3.72s]</pre>			<p class="calibre3">Both packages have been built. You will have to do that every time you add or modify a node inside a package.</p>
			<p class="calibre3">The important thing to notice is this line: <strong class="source-inline1">Finished &lt;&lt;&lt; &lt;package_name&gt; [time]</strong>. This means that the package was correctly built. Even if you see additional warning logs, if you also see the <strong class="source-inline1">Finished</strong> line, you know the package has been built.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">After you build any package, you also have to source your workspace so that the environment is aware of the new changes. You can do any of the following:</p>
			<p class="callout">- Open a new terminal as everything is configured in the <code>.</code><code>bashrc</code> file</p>
			<p class="callout">- Source the <code>setup.bash</code> script directly (<code>source ~/ros2_ws/install/setup.bash</code>)</p>
			<p class="callout">- Source the <code>.bashrc</code> manually (<code>source ~/.bashrc</code>)</p>
			<p class="calibre3">To build only <a id="_idIndexMarker192" class="pcalibre calibre4 pcalibre1"/>a specific package, you can use the <strong class="source-inline1">--packages-select</strong> option, followed by the name of the package. Here’s an example:</p>
			<pre class="console">
$ colcon build --packages-select my_py_pkg
Starting &gt;&gt;&gt; my_py_pkg
Finished &lt;&lt;&lt; my_py_pkg [1.01s]
Summary: 1 package finished [1.26s]</pre>			<p class="calibre3">This way, you don’t need to build your entire application every time and can just focus on one package.</p>
			<p class="calibre3">Now that we have created some packages and we know how to build them, we can create nodes in the packages. But how are we going to<a id="_idTextAnchor178" class="pcalibre calibre4 pcalibre1"/> organize them?</p>
			<h2 id="_idParaDest-95" class="calibre6"><a id="_idTextAnchor179" class="pcalibre calibre4 pcalibre1"/>How are nodes organized in a package?</h2>
			<p class="calibre3">To develop a ROS 2 application, you will write code inside nodes. As seen in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">node</em> is simply the name of a ROS 2 program.</p>
			<p class="calibre3">A node is a <a id="_idIndexMarker193" class="pcalibre calibre4 pcalibre1"/>subprogram of your application, responsible for one thing. If you have two different functionalities to implement, then you will have two nodes. Nodes communicate with each other using ROS 2 communications (topics, services, and actions).</p>
			<p class="calibre3">You will organize your nodes inside packages. For one package (sub-part of your application), you can have several nodes (functionalities). To fully understand how to organize packages and nodes, you need practice and experience. For now, let’s just get an idea with an example.</p>
			<p class="calibre3">Let’s come back to the package architecture we had in <em class="italic">Figure 4</em><em class="italic">.1</em>, and add nodes inside the packages:</p>
			<div><div><img alt="Figure 4.2﻿ – Example of a package organization with nodes" src="img/B22403_04_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Example of a package organization with nodes</p>
			<p class="calibre3">As you can see, in the camera package, we could have one node responsible for handling the <a id="_idIndexMarker194" class="pcalibre calibre4 pcalibre1"/>camera hardware. This node would send images to an image processing node, and this latter would extract the coordinates of objects for the robot to pick up.</p>
			<p class="calibre3">In the meantime, a motion planning node (in the motion planning package) would compute the movements that the robot should perform, given a specific command. A path correction node can support this motion planning using the data received from the image processing node.</p>
			<p class="calibre3">Finally, to make the robot move, a hardware driver node would be responsible for hardware communication (motors, encoders) and receive commands from the motion planning node. An additional state publisher node could be here to publish additional data about the robot for other nodes to use.</p>
			<p class="calibre3">This node organization is purely fictitious and is here just to give you a general idea of how a ROS 2 application can be designed, and which roles a node can have in this application.</p>
			<p class="calibre3">Now, you are (finally) going to write your first ROS 2 node. ROS 2 requires quite a lot of installation and configuration before you can actually write some code, but good news, we have <a id="_idIndexMarker195" class="pcalibre calibre4 pcalibre1"/>completed all of this and can now focus on the code.</p>
			<p class="calibre3">We won’t do anything too complicated for now; we won’t dive into complex features or communications. We will write a basic node that you can use as a template to start any future node. We will also build the node and s<a id="_idTextAnchor180" class="pcalibre calibre4 pcalibre1"/>ee how to run it.</p>
			<h1 id="_idParaDest-96" class="calibre6"><a id="_idTextAnchor181" class="pcalibre calibre4 pcalibre1"/>Creating a Python node</h1>
			<p class="calibre3">Let’s create our first Python node, or in other words, our first ROS 2 Python program.</p>
			<p class="calibre3">The processes <a id="_idIndexMarker196" class="pcalibre calibre4 pcalibre1"/>of creating Python and C++ nodes are very different. That’s why I have written a separate section for each of them. We will start with Python, with complete step-by-step explanations. Then we will see how to do the same with C++. If you want to follow the C++ node section, make sure to read this one first.</p>
			<p class="calibre3">To create a node, you will have to do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Create a file for the node.</li>
				<li class="calibre10">Write <a id="_idIndexMarker197" class="pcalibre calibre4 pcalibre1"/>the node. We will use <strong class="bold">Object Oriented Programming</strong> (<strong class="bold">OOP</strong>), as officially recommended for ROS 2 (and almost every existing ROS 2 code you find uses OOP).</li>
				<li class="calibre10">Build the package in which the node exists.</li>
				<li class="calibre10">Run the node to test it.</li>
			</ol>
			<p class="calibre3">Let’s get started with our<a id="_idTextAnchor182" class="pcalibre calibre4 pcalibre1"/> first Python node.</p>
			<h2 id="_idParaDest-97" class="calibre6"><a id="_idTextAnchor183" class="pcalibre calibre4 pcalibre1"/>Creating a file for the node</h2>
			<p class="calibre3">To write <a id="_idIndexMarker198" class="pcalibre calibre4 pcalibre1"/>a node, we first need to create a file. Where should we create this file?</p>
			<p class="calibre3">If you remember, when we created the <strong class="source-inline1">my_py_pkg</strong> package, another <strong class="source-inline1">my_py_pkg</strong> directory was created inside the package. This is where we will write the node. For every Python package, you have to go to the directory which has the same name as the package. If your package name is <strong class="source-inline1">abc</strong>, then you’ll go to <strong class="source-inline1">~/ros2_ws/src/abc/abc/</strong>.</p>
			<p class="calibre3">Create a new file in this directory and make it executable:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_py_pkg/my_py_pkg/
$ touch my_first_node.py
$ chmod +x my_first_node.py</pre>			<p class="calibre3">After this, open this file to write in it. You can use any text editor or IDE you want here, as long as you don’t get lost in all the files.</p>
			<p class="calibre3">If you have no idea what to use, I suggest using VS Code with the ROS extension (as explained in <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 2</em></a>). This is the tool I’m using for all ROS development.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using VS Code, the best way to open it is to first navigate to the <code>src</code> directory of your workspace in a terminal, and then open it. This way, you have access to all the packages in your workspace, and it will make things easier with recognized dependencies and auto-completion:</p>
			<p class="callout"><code>$ </code><code>cd ~/r<a id="_idTextAnchor184" class="pcalibre calibre4 pcalibre1"/>os2_ws/src/</code></p>
			<p class="callout"><code>$ </code><code>code .</code></p>
			<h2 id="_idParaDest-98" class="calibre6"><a id="_idTextAnchor185" class="pcalibre calibre4 pcalibre1"/>Writing a minimal ROS 2 Python node</h2>
			<p class="calibre3">Here is the <a id="_idIndexMarker199" class="pcalibre calibre4 pcalibre1"/>starting code for any Python node you will create. You can write this code into the <strong class="source-inline1">my_first_node.py</strong> file:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
class MyCustomNode(Node):
    def __init__(self):
        super().__init__('my_node_name')
def main(args=None):
    rclpy.init(args=args)
    node = MyCustomNode()
    rclpy.spin(node)
    rclpy.shutdown()
if __name__ == '__main__':
    main()</pre>			<p class="calibre3">As you can see, we use OOP here. OOP is everywhere in ROS 2, and this is the default (and recommended) way to write a node.</p>
			<p class="calibre3">Let’s come back to this code step by step, to understand what it’s doing:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node</pre>			<p class="calibre3">We first import <strong class="source-inline1">rclpy</strong>, the Python library for ROS 2. Inside this library, we can get the <strong class="source-inline1">Node</strong> class.</p>
			<p class="calibre3">We then create a new class that inherits from the <strong class="source-inline1">rclpy </strong><strong class="source-inline1">Node</strong> class:</p>
			<pre class="source-code">
class MyCustomNode(Node):
    def __init__(self):
        super().__init__('my_node_name')</pre>			<p class="calibre3">In this class, make sure you call the parent constructor with <strong class="source-inline1">super()</strong>. This is also where you will specify the node name.</p>
			<p class="calibre3">This node <a id="_idIndexMarker200" class="pcalibre calibre4 pcalibre1"/>is not doing anything for now; we will add a few functionalities in a minute. Let's finish the code:</p>
			<pre class="source-code">
def main(args=None):
    rclpy.init(args=args)
    node = MyCustomNode()
    rclpy.spin(node)
    rclpy.shutdown()</pre>			<p class="calibre3">After the class, we create a <strong class="source-inline1">main()</strong> function in which we perform the following actions:</p>
			<ol class="calibre11">
				<li class="calibre10">Initialize ROS 2 communications with <code>rclpy.init()</code>. This should be the first line in your <code>main()</code>function.</li>
				<li class="calibre10">Create an object from the <code>MyCustomNode</code> class we wrote before. This will initialize the node. There’s no need to destroy the node later, as this will happen automatically when the program exits.</li>
				<li class="calibre10">Make the node spin. If you omit this line, the node will be created, then the program will exit, and the node will be destroyed. Making the node spin means that we block the execution here, the program stays alive, and thus the node stays alive. In the meantime, as we will see shortly, all registered callbacks for the node can be processed. When you press <em class="italic">Ctrl</em> + <em class="italic">C</em>, the node will stop spinning and this function will return.</li>
				<li class="calibre10">After the node is killed, shut down ROS 2 communications with <code>rclpy.shutdown()</code>. This will be the last line of your <code>main()</code>function.</li>
			</ol>
			<p class="calibre3">This is how all your ROS 2 programs will work. As you can see, the node is in fact an object that we create within the program (the node is not the program in itself, but still, it is quite <a id="_idIndexMarker201" class="pcalibre calibre4 pcalibre1"/>common to refer to the word “node” when we talk about the program). After being created, the node can stay alive and play its part while it is spinning. We will come back to this <em class="italic">spinning</em> shortly.</p>
			<p class="calibre3">Finally, we also have added these two lines:</p>
			<pre class="source-code">
if __name__ == '__main__':
    main()</pre>			<p class="calibre3">This is a pure Python thing and has nothing to do with ROS 2. It just means that if you run the Python script directly, the <strong class="source-inline1">main()</strong> function will be called, so you can try your program without having to install it with <strong class="source-inline1">colcon</strong>.</p>
			<p class="calibre3">Great, you have written your first minimal Python node. Before you build and run it, add one more line in the Node’s constructor, so it can do something:</p>
			<pre class="source-code">
class MyCustomNode(Node):
    def __init__(self):
        super().__init__('my_node_name')
        <strong class="bold1">self.get_logger().info("Hello World")</strong></pre>			<p class="calibre3">This line will print <strong class="source-inline1">Hello World</strong> when the node starts.</p>
			<p class="calibre3">As the <strong class="source-inline1">MyCustomNode</strong> class inherits from the <strong class="source-inline1">Node</strong> class, we get access to all the ROS 2 functionalities for nodes. This will make things quite convenient for us. Here, you have an example with the logging functionality: we get the <strong class="source-inline1">get_logger()</strong> method from <strong class="source-inline1">Node</strong>. Then, with the <strong class="source-inline1">info()</strong>method, we can print a l<a id="_idTextAnchor186" class="pcalibre calibre4 pcalibre1"/>og with the info level.</p>
			<h2 id="_idParaDest-99" class="calibre6"><a id="_idTextAnchor187" class="pcalibre calibre4 pcalibre1"/>Building the node</h2>
			<p class="calibre3">You are <a id="_idIndexMarker202" class="pcalibre calibre4 pcalibre1"/>now going to build the node so that you can run it.</p>
			<p class="calibre3">You might think: why do we need to build a Python node? Python is an interpreted language; couldn’t we just run the file itself?</p>
			<p class="calibre3">Yes, this is true: you could test the code just by running it in the terminal <strong class="source-inline1">($ python3 my_first_node.py</strong>). However, what we want to do is actually install the file in our workspace, so we can start the node with <strong class="source-inline1">ros2 run</strong>, and later on, from a launch file.</p>
			<p class="calibre3">We usually use the word “build”, because to install a Python node, we have to run <strong class="source-inline1">colcon build</strong>.</p>
			<p class="calibre3">To build (install) the node, we need to do one more thing in the package. Open the <strong class="source-inline1">setup.py</strong> file from the <strong class="source-inline1">my_py_pkg</strong> package. Locate <strong class="source-inline1">entry_points</strong> and <strong class="source-inline1">'console_scripts'</strong> at the end of the file. For each node we want to build, we have to add one line inside the <strong class="source-inline1">'</strong><strong class="source-inline1">console_scripts'</strong> array:</p>
			<pre class="source-code">
entry_points={
    'console_scripts': [
        <strong class="bold1">"test_node = my_py_pkg.my_first_node:main"</strong>
    ],
},</pre>			<p class="calibre3">Here <a id="_idIndexMarker203" class="pcalibre calibre4 pcalibre1"/>is the syntax:</p>
			<pre class="source-code">
&lt;executable_name&gt; = &lt;package_name&gt;.&lt;file_name&gt;:&lt;function_name&gt;.</pre>			<p class="calibre3">There are a few important things to correctly write this line:</p>
			<ul class="calibre9">
				<li class="calibre10">First, choose an executable name. This will be the name you use with <code>ros2 run &lt;</code><code>pkg_name&gt; &lt;executable_name&gt;</code>.</li>
				<li class="calibre10">For the filename, skip the <code>.</code><code>py</code> extension.</li>
				<li class="calibre10">The function name is <code>main</code>, as we have created a <code>main()</code> function in the code.</li>
				<li class="calibre10">If you want to add another executable for another node, don’t forget to add a comma between each executable and place one executable per line.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">When learning ROS 2, there is a common confusion between the node name, filename, and executable name:</p>
			<p class="callout">- Node name: defined inside the code, in the constructor. This is what you’ll see with the <code>ros2</code> <code>node list</code>, or in <code>rqt_graph</code>.</p>
			<p class="callout">- Filename: the file where you write the code.</p>
			<p class="callout">- Executable name: defined in <code>setup.py</code> and used with <code>ros2 run</code>.</p>
			<p class="callout">In this first example, I made sure to use a different name for each so you can be aware that these are three different things. But sometimes all three names could be the same. For example, you could create a <code>temperature_sensor.py</code> file, then name your node and your executable <code>temperature_sensor</code>.</p>
			<p class="calibre3">Now that <a id="_idIndexMarker204" class="pcalibre calibre4 pcalibre1"/>you have given the instructions to create a new executable, go to your workspace root directory and build the package:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build</pre>			<p class="calibre3">You can also add <strong class="source-inline1">--packages-select my_py_pkg</strong> to only build this package.</p>
			<p class="calibre3">The executable should now be created and installed in the workspace (it will be placed inside the <strong class="source-inline1">install</strong> directory). We can say that your Python node has<a id="_idTextAnchor188" class="pcalibre calibre4 pcalibre1"/> been built, or installed.</p>
			<h2 id="_idParaDest-100" class="calibre6"><a id="_idTextAnchor189" class="pcalibre calibre4 pcalibre1"/>Running the node</h2>
			<p class="calibre3">Now you <a id="_idIndexMarker205" class="pcalibre calibre4 pcalibre1"/>can run your first node, but just before that, make sure that the workspace is sourced in your environment:</p>
			<pre class="console">
$ source ~/.bashrc</pre>			<p class="calibre3">This file already contains the line to source the workspace; you could also just open a new terminal, or source the <strong class="source-inline1">setup.bash</strong> script from the workspace.</p>
			<p class="calibre3">You can now run your node using <strong class="source-inline1">ros2 run</strong> (if you have any doubts, go back to the experiments we did in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>):</p>
			<pre class="console">
$ ros2 run my_py_pkg test_node
[INFO] [1710922181.325254037] [my_node_name]: Hello World</pre>			<p class="calibre3">Great, we see <a id="_idIndexMarker206" class="pcalibre calibre4 pcalibre1"/>the log <strong class="source-inline1">Hello World</strong>. Your first node is successfully running. Note that we wrote <strong class="source-inline1">test_node</strong> in the <strong class="source-inline1">ros2 run</strong> command, as it’s the executable name we chose in the <strong class="source-inline1">setup.py</strong> file.</p>
			<p class="calibre3">Now, you might notice that the program is hanging there. The node is still alive because it is spinning. To st<a id="_idTextAnchor190" class="pcalibre calibre4 pcalibre1"/>op the node, press <em class="italic">Ctrl</em> + <em class="italic">C</em>.</p>
			<h2 id="_idParaDest-101" class="calibre6"><a id="_idTextAnchor191" class="pcalibre calibre4 pcalibre1"/>Improving the node – timer and callback</h2>
			<p class="calibre3">At this point, you might feel that writing, building, and running a node is a long and complicated <a id="_idIndexMarker207" class="pcalibre calibre4 pcalibre1"/>process. It’s actually not that complex, and it gets easier with each new node that you create. On top of that, modifying an existing node is even easier. Let’s see that now.</p>
			<p class="calibre3">The node we ran is very basic. Let’s add one more functionality and do something more interesting.</p>
			<p class="calibre3">Our node is printing one piece of text when it’s started. We now want to make the node print a string every second, as long as it’s alive.</p>
			<p class="calibre3">This behavior of “doing X action every Y seconds” is very common in robotics. For example, you could have a node that “reads a temperature every 2 seconds”, or that “gives a new motor command every 0.1 seconds”.</p>
			<p class="calibre3">How to <a id="_idIndexMarker208" class="pcalibre calibre4 pcalibre1"/>do that? We will add a <strong class="bold">timer</strong> to our node. A timer <a id="_idIndexMarker209" class="pcalibre calibre4 pcalibre1"/>will trigger a <strong class="bold">callback</strong> function at a specified rate.</p>
			<p class="calibre3">Let’s go back to the code and modify the <strong class="source-inline1">MyCustomNode</strong> class. The rest of the code stays the same:</p>
			<pre class="source-code">
class MyCustomNode(Node):
    def __init__(self):
        super().__init__('my_node_name')
        self.counter_ = 0
        self.timer_ = self.create_timer(1.0, self.print_hello)
    def print_hello(self):
        self.get_logger().info("Hello " + str(self.counter_))
        self.counter_ += 1</pre>			<p class="calibre3">We still have <a id="_idIndexMarker210" class="pcalibre calibre4 pcalibre1"/>the constructor with <strong class="source-inline1">super()</strong>, but now the log is in a separate method. Also, instead of just printing <strong class="source-inline1">Hello World</strong>, here we create a <strong class="source-inline1">counter_</strong> attribute that we increment every time we use the log.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you’re wondering why there is a trailing underscore <code>_</code> at the end of each class attribute, this is a common OOP convention that I follow to specify that a variable is a class attribute. It’s simply a visual help and has no other function. You can follow the same convention or use another one—just make sure to stay consistent within one project.</p>
			<p class="calibre3">The most <a id="_idIndexMarker211" class="pcalibre calibre4 pcalibre1"/>important line is the one to create the timer. To create the timer we use the <strong class="source-inline1">create_timer()</strong> method from the <strong class="source-inline1">Node</strong> class. We need to give two arguments: the rate at which we want to call the function (float number), and the callback function. Note that the callback function should be specified without any parenthesis.</p>
			<p class="calibre3">This instruction means that we want to call the <strong class="source-inline1">print_hello</strong> method every <strong class="source-inline1">1.0</strong> second.</p>
			<p class="calibre3">Let’s now try the code. As we have already specified how to create an executable from this file in the <strong class="source-inline1">setup.py</strong> file, we don’t need to do it again.</p>
			<p class="calibre3">All we have to do is to build, source, and run. Remember: “build, source, run.” Every time you create a new node, or modify an existing one, you have to “build, source, run.”</p>
			<p class="calibre3">In a terminal, go to the root directory of your ROS 2 workspace and build the package:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_py_pkg</pre>			<p class="callout-heading">Note</p>
			<p class="callout">On top of <code>--packages-select &lt;pkg_name&gt;</code>, you can add the <code>--symlink-install</code> option, so you won’t have to build the package every time you modify your Python nodes; for example, <code>$ colcon build --packages-select </code><code>my_py_pkg --symlink-install</code>.</p>
			<p class="callout">You might see some warning logs, but as long as you see the line starting with <code>Finished &lt;&lt;&lt; my_py_pkg</code>, it worked correctly. This will install the executable, but then if you modify the code, you should be able to run it without building it again.</p>
			<p class="callout">Two important things: this only works for Python packages, and you still have to build the package for any new executable you create.</p>
			<p class="calibre3">Then, from this <a id="_idIndexMarker212" class="pcalibre calibre4 pcalibre1"/>terminal or another one, source and run the following:</p>
			<pre class="console">
$ source ~/.bashrc
$ ros2 run my_py_pkg test_node
[INFO] [1710999909.533443384] [my_node_name]: Hello 0
[INFO] [1710999910.533169531] [my_node_name]: Hello 1
[INFO] [1710999911.532731467] [my_node_name]: Hello 2
[INFO] [1710999912.534052411] [my_node_name]: Hello 3</pre>			<p class="calibre3">As you can see, the process of build, source, and run is quite fast and not that complicated. Here, we can see that the node prints a log every second, and the counter increments in each new log.</p>
			<p class="calibre3">Now, how is this possible? How is the <strong class="source-inline1">print_hello()</strong> method called? We have created a timer, yes, but nowhere in the code have we actually called <strong class="source-inline1">print_hello()</strong> directly.</p>
			<p class="calibre3">It works because the node is spinning, thanks to <strong class="source-inline1">rclpy.spin(node)</strong>. This means that the node is kept alive, and all registered callbacks can be called during this time. What we do with <strong class="source-inline1">create_timer()</strong> is simply to register a callback, which can then be called when the node is spinning.</p>
			<p class="calibre3">This was your first <a id="_idIndexMarker213" class="pcalibre calibre4 pcalibre1"/>example of a callback, and as you will see in the following chapters of the book, everything runs with callbacks in ROS 2. At this point, if you still have some trouble with the syntax, the callbacks, and the spinning, don’t worry too much. As you make progress with the book, you will repeat this process many times. When learning ROS 2, understanding comes with hands-on experience.</p>
			<p class="calibre3">We are now done with this Python node. With what you’ve seen here, you should be able to create your own new Python nodes (in the same package or another package). Let’s now switch to C++. If you are only interested in learning ROS 2 with Python for<a id="_idTextAnchor192" class="pcalibre calibre4 pcalibre1"/> now, you can skip the C++ section.</p>
			<h1 id="_idParaDest-102" class="calibre6"><a id="_idTextAnchor193" class="pcalibre calibre4 pcalibre1"/>Creating a C++ node</h1>
			<p class="calibre3">We are going <a id="_idIndexMarker214" class="pcalibre calibre4 pcalibre1"/>to do exactly the same thing we did for the Python node: create a file, write the node, build, source, and run.</p>
			<p class="calibre3">Make sure you have read the previous Python section as I will not repeat everything here. We will basically just see how to apply the process for a C++ node.</p>
			<p class="calibre3">To create a C++ node, we first need a C++ package. We will use the <strong class="source-inline1">my_cpp_pkg<a id="_idTextAnchor194" class="pcalibre calibre4 pcalibre1"/></strong> package that we created previously.</p>
			<h2 id="_idParaDest-103" class="calibre6"><a id="_idTextAnchor195" class="pcalibre calibre4 pcalibre1"/>Writing a C++ node</h2>
			<p class="calibre3">Let’s create <a id="_idIndexMarker215" class="pcalibre calibre4 pcalibre1"/>a file for the node. Go to the <strong class="source-inline1">src</strong> directory inside the <strong class="source-inline1">my_cpp_pkg</strong> package and create a <strong class="source-inline1">.</strong><strong class="source-inline1">cpp</strong> file:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_cpp_pkg/src/
$ touch my_first_node.cpp</pre>			<p class="calibre3">You could also create the file directly from your IDE and not use the terminal.</p>
			<p class="calibre3">Now, if you haven’t done this previously, open your workspace with VS Code or any other IDE:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/
$ code .</pre>			<p class="calibre3">Open <strong class="source-inline1">my_first_node.cpp</strong>. Here is <a id="_idIndexMarker216" class="pcalibre calibre4 pcalibre1"/>the minimal code to write a C++ node:</p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"
class MyCustomNode : public rclcpp::Node
{
public:
    MyCustomNode() : Node("my_node_name")
    {
    }
private:
};
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared&lt;MyCustomNode&gt;();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}</pre>			<p class="callout-heading">Note</p>
			<p class="callout">If you are using VS Code and you type this code, you might see an include error for the <code>rclcpp</code> library. Make sure to save the file and wait a few seconds. If the include is still not recognized, go to the <strong class="bold">Extensions</strong> tab and disable and re-enable the ROS extension.</p>
			<p class="calibre3">As you can see (and this was similar with Python), in ROS 2 we heavily use OOP with C++ nodes.</p>
			<p class="calibre3">Let’s analyze <a id="_idIndexMarker217" class="pcalibre calibre4 pcalibre1"/>this code step by step:</p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"</pre>			<p class="calibre3">We first include <strong class="source-inline1">rclcpp</strong>, the C++ library for ROS 2. This library contains the <strong class="source-inline1">rclcpp::Node</strong> class:</p>
			<pre class="source-code">
class MyCustomNode : public rclcpp::Node
{
public:
    MyCustomNode() : Node("my_node_name")
    {
    }
private:
};</pre>			<p class="calibre3">As we did for Python, we have created a class that inherits from the <strong class="source-inline1">Node</strong> class. The syntax is different, but the principle is the same. From this <strong class="source-inline1">Node</strong> class, we will be able to access all the ROS 2 functionalities: logger, timer, and so on. As you can see, we also specify the node name in the constructor. For now, the node does nothing; we will add more functionalities in a minute:</p>
			<pre class="source-code">
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared&lt;MyCustomNode&gt;();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}</pre>			<p class="calibre3">You need a <strong class="source-inline1">main()</strong> function if you want to be able to run your C++ program. In this function, we do <a id="_idIndexMarker218" class="pcalibre calibre4 pcalibre1"/>exactly the same thing as for Python, with just some differences in the syntax:</p>
			<ol class="calibre11">
				<li class="calibre10">Initialize ROS 2 communications with <code>rclcpp::init()</code>.</li>
				<li class="calibre10">Create a node object from your newly written class. As you can see, we don’t create an object directly, but a shared pointer to that object. In ROS 2 and C++, almost everything you create will be a smart pointer (shared, unique, and so on).</li>
				<li class="calibre10">We then make the node spin with <code>rclcpp::spin()</code>.</li>
				<li class="calibre10">Finally, when the node is stopped (<em class="italic">Ctrl</em> + <em class="italic">C</em>), we shut down all ROS 2 communications with <code>rclcpp::shutdown()</code>.</li>
			</ol>
			<p class="calibre3">This structure for the <strong class="source-inline1">main()</strong> function will be very similar for all your ROS 2 programs. As you can see, once again, the node is not the program in itself. The node is created inside the program.</p>
			<p class="calibre3">Before we go further and build, source, and run our node, let’s improve it now with a timer, a callback, and a log.</p>
			<p class="calibre3">Modify the <strong class="source-inline1">MyCustomNode</strong> class, and leave the rest as it is:</p>
			<pre class="source-code">
class MyCustomNode : public rclcpp::Node
{
public:
    MyCustomNode() : Node("my_node_name"), counter_(0)
    {
        timer_ = this-&gt;create_wall_timer(std::chrono::seconds(1), std::bind(&amp;MyCustomNode::print_hello, this));
    }
    void print_hello()
    {
        RCLCPP_INFO(this-&gt;get_logger(), "Hello %d", counter_);
        counter_++;
    }
private:
    int counter_;
    rclcpp::TimerBase::SharedPtr timer_;
};</pre>			<p class="calibre3">This code <a id="_idIndexMarker219" class="pcalibre calibre4 pcalibre1"/>example will do the same thing as for the Python node. We create a timer so that we can call a callback function every <strong class="source-inline1">1.0</strong> second. In this callback function, we print <strong class="source-inline1">Hello</strong> followed by a counter that we increment every time.</p>
			<p class="calibre3">There are some specificities related to C++:</p>
			<ul class="calibre9">
				<li class="calibre10">For the timer, we have to create a class attribute. As you can see we also create a shared pointer here: <code>rclcpp::TimerBase::SharedPtr</code>.</li>
				<li class="calibre10">We use <code>this-&gt;create_wall_timer()</code> to create the timer. <code>this-&gt;</code> is not required here, but I have added it to emphasize that we are using the <code>create_wall_timer()</code> method from the <code>Node</code> class.</li>
				<li class="calibre10">To specify the callback in the timer, as we are in a C++ class, we have to use <code>std::bind(&amp;ClassName::method_name, this)</code>. Make sure you don’t use any parenthesis for the method name.</li>
			</ul>
			<p class="calibre3">The <a id="_idTextAnchor196" class="pcalibre calibre4 pcalibre1"/>node is now finished, so we can build it.</p>
			<h2 id="_idParaDest-104" class="calibre6"><a id="_idTextAnchor197" class="pcalibre calibre4 pcalibre1"/>Building and running the node</h2>
			<p class="calibre3">We can’t just run the C++ file; we first have to compile it and create an executable. To do this, we will <a id="_idIndexMarker220" class="pcalibre calibre4 pcalibre1"/>edit the <strong class="source-inline1">CMakeLists.txt</strong> file. Open this file, and after <a id="_idIndexMarker221" class="pcalibre calibre4 pcalibre1"/>a few lines, you will find something like this:</p>
			<pre class="source-code">
# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)</pre>			<p class="calibre3">The line to find <strong class="source-inline1">rclcpp</strong> is here because we provided <strong class="source-inline1">--dependencies rclcpp</strong> when we created the package with <strong class="source-inline1">ros2 pkg create</strong>. Later on, if your nodes in this package require more dependencies, you can add the dependencies here, one per line.</p>
			<p class="calibre3">Just after this line, add an extra new line, and then the following instructions:</p>
			<pre class="source-code">
add_executable(test_node src/my_first_node.cpp)
ament_target_dependencies(test_node rclcpp)
install(TARGETS
  test_node
  DESTINATION lib/${PROJECT_NAME}/
)</pre>			<p class="calibre3">To build a C++ node, we need to do three things:</p>
			<ol class="calibre11">
				<li class="calibre10">Add a new executable with the <code>add_executable()</code>function. Here, you have to choose a name for the executable (the one that will be used with <code>ros2 run &lt;pkg_name&gt; &lt;executable_name&gt;</code>), and we also have to specify the relative path to the C++ file.</li>
				<li class="calibre10">Link all dependencies for this executable with the <code>ament_target_dependencies()</code>function.</li>
				<li class="calibre10">Install the executable with the <code>install()</code>instruction, so that we can find it when we use <code>ros2 run</code>. Here, we put the executable in a <code>lib/&lt;package_name&gt;</code> directory.</li>
			</ol>
			<p class="calibre3">Then, for each new <a id="_idIndexMarker222" class="pcalibre calibre4 pcalibre1"/>executable you create, you need to repeat <em class="italic">steps 1</em> and <em class="italic">2</em> and add the executable inside the <strong class="source-inline1">install()</strong> instruction, one per line without <a id="_idIndexMarker223" class="pcalibre calibre4 pcalibre1"/>any commas. There’s no need to create a new <strong class="source-inline1">install()</strong> instruction for each executable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The end of your <code>CMakeLists.txt</code> will contain a block starting with <code>if(BUILD_TESTING)</code>, and then <code>ament_package()</code>. As we are not doing any build testing here, you can remove the entire <code>if</code> block. Just make sure to keep the <code>ament_package()</code> line, which should be the last line of the file.</p>
			<p class="calibre3">You can now build the package with <strong class="source-inline1">colcon build</strong>, which is going to create and install the executable:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_cpp_pkg</pre>			<p class="calibre3">If you get any error during the build process, make sure to fix your code first, and then build again. Then, you can source your environment, and run your executable:</p>
			<pre class="console">
$ source ~/.bashrc
$ ros2 run my_cpp_pkg test_node
[INFO] [1711006463.017149024] [my_node_name]: Hello 0
[INFO] [1711006464.018055674] [my_node_name]: Hello 1
[INFO] [1711006465.015927319] [my_node_name]: Hello 2
[INFO] [1711006466.015355747] [my_node_name]: Hello 3</pre>			<p class="calibre3">As you can see, we run the <strong class="source-inline1">test_node</strong> executable (built from <strong class="source-inline1">my_first_node.cpp</strong> file), which is going to start the <strong class="source-inline1">my_node_name</strong> node.</p>
			<p class="calibre3">You have now successfully written a C++ node. For each new node that you create, you will have to create a new C++ file, write the node class, set the build instructions for a new executable in <strong class="source-inline1">CMakeLists.txt</strong>, and build the package. Then, to start the node, source the envi<a id="_idTextAnchor198" class="pcalibre calibre4 pcalibre1"/>ronment and run the executable with <strong class="source-inline1">ros2 run</strong>.</p>
			<h1 id="_idParaDest-105" class="calibre6"><a id="_idTextAnchor199" class="pcalibre calibre4 pcalibre1"/>Node template for Python and C++ nodes</h1>
			<p class="calibre3">All the nodes we start in this book will follow the same structure. As additional help to get started <a id="_idIndexMarker224" class="pcalibre calibre4 pcalibre1"/>quickly, I have created a node template <a id="_idIndexMarker225" class="pcalibre calibre4 pcalibre1"/>you can use to write the base of any Python or C++ node. I use these templates myself when creating new nodes, as the code can be quite repetitive.</p>
			<p class="calibre3">You can copy and paste the templates either from this book directly, or download them from the GitHub repository: <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>.</p>
			<h2 id="_idParaDest-106" class="calibre6"><a id="_idTextAnchor200" class="pcalibre calibre4 pcalibre1"/>Template for a Python node</h2>
			<p class="calibre3">Use this <a id="_idIndexMarker226" class="pcalibre calibre4 pcalibre1"/>code to <a id="_idIndexMarker227" class="pcalibre calibre4 pcalibre1"/>start any new Python node:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
class MyCustomNode(Node): # MODIFY NAME
    def __init__(self):
        super().__init__("node_name") # MODIFY NAME
def main(args=None):
    rclpy.init(args=args)
    node = MyCustomNode() # MODIFY NAME
    rclpy.spin(node)
    rclpy.shutdown()
if __name__ == "__main__":
    main()</pre>			<p class="calibre3">All you have <a id="_idIndexMarker228" class="pcalibre calibre4 pcalibre1"/>to do is remove the <strong class="source-inline1">MODIFY NAME</strong> comments <a id="_idIndexMarker229" class="pcalibre calibre4 pcalibre1"/>and change the class name (<strong class="source-inline1">MyCustomNode</strong>) and the node name (<strong class="source-inline1">"node_name"</strong>). It’s better to use names that make sense. For example, if you are writing a node to read data from a temperature sensor, you could name the class <strong class="source-inline1">TemperatureSe<a id="_idTextAnchor201" class="pcalibre calibre4 pcalibre1"/>nsorNode</strong>, and the node could be <strong class="source-inline1">temperature_sensor</strong>.</p>
			<h2 id="_idParaDest-107" class="calibre6"><a id="_idTextAnchor202" class="pcalibre calibre4 pcalibre1"/>Template for a C++ node</h2>
			<p class="calibre3">Use this <a id="_idIndexMarker230" class="pcalibre calibre4 pcalibre1"/>code to <a id="_idIndexMarker231" class="pcalibre calibre4 pcalibre1"/>start any new C++ node:</p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"
class MyCustomNode : public rclcpp::Node // MODIFY NAME
{
public:
    MyCustomNode() : Node("node_name") // MODIFY NAME
    {
    }
private:
};
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared&lt;MyCustomNode&gt;(); // MODIFY NAME
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}</pre>			<p class="calibre3">Remove <a id="_idIndexMarker232" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">MODIFY NAME</strong> comments and rename <a id="_idIndexMarker233" class="pcalibre calibre4 pcalibre1"/>the class and the node.</p>
			<p class="calibre3">Those two templates will allow you to start your nodes more q<a id="_idTextAnchor203" class="pcalibre calibre4 pcalibre1"/>uickly. I recommend you to use them as much as you can.</p>
			<h1 id="_idParaDest-108" class="calibre6"><a id="_idTextAnchor204" class="pcalibre calibre4 pcalibre1"/>Introspecting your nodes</h1>
			<p class="calibre3">To finish this chapter, we will practice a bit more with the <strong class="source-inline1">ros2 node</strong> command line.</p>
			<p class="calibre3">So far, you have <a id="_idIndexMarker234" class="pcalibre calibre4 pcalibre1"/>seen how to write a node, build it, and run it. One missing part is to know how to introspect your nodes. Even if a node can run, it doesn’t mean it will do exactly what you want it to do.</p>
			<p class="calibre3">Being able to introspect your nodes will help you fix errors that you might have made in your code. It will also allow you to easily find more information about other nodes that you are starting but didn’t write (as we did in the discovery phase in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>).</p>
			<p class="calibre3">For each core concept in <em class="italic">Part 2</em>, we will take a bit of time to experiment with the command-line tools related to the concept. The command-line tool for nodes is <strong class="source-inline1">ros2 node</strong>.</p>
			<p class="calibre3">First, and before we use <strong class="source-inline1">ros2 node</strong>, we have to start a node. As a recap, to start a node, we use <strong class="source-inline1">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</strong>. If we start the Python node we have created in this chapter, we use this:</p>
			<pre class="console">
$ ros2 run my_py_pkg test_node</pre>			<p class="calibre3">Only after we have sta<a id="_idTextAnchor205" class="pcalibre calibre4 pcalibre1"/>rted a node can we do some introspection with <strong class="source-inline1">ros2 node</strong>.</p>
			<h2 id="_idParaDest-109" class="calibre6"><a id="_idTextAnchor206" class="pcalibre calibre4 pcalibre1"/>ros2 node command line</h2>
			<p class="calibre3">To list <a id="_idIndexMarker235" class="pcalibre calibre4 pcalibre1"/>all running nodes, use <strong class="source-inline1">ros2 </strong><strong class="source-inline1">node list</strong>:</p>
			<pre class="console">
$ ros2 node list
/my_node_name</pre>			<p class="calibre3">We find <a id="_idIndexMarker236" class="pcalibre calibre4 pcalibre1"/>the name of the node, which we defined in the code.</p>
			<p class="calibre3">Once we have the node name, we can get more info about it with <strong class="source-inline1">ros2 node </strong><strong class="source-inline1">info &lt;node_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 node info /my_node_name
/my_node_name
  Subscribers:
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
  Service Servers:
    /my_node_name/describe_parameters: rcl_interfaces/srv/DescribeParameters
    /my_node_name/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
    /my_node_name/get_parameters: rcl_interfaces/srv/GetParameters
    /my_node_name/get_type_description: type_description_interfaces/srv/GetTypeDescription
    /my_node_name/list_parameters: rcl_interfaces/srv/ListParameters
    /my_node_name/set_parameters: rcl_interfaces/srv/SetParameters
    /my_node_name/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
  Service Clients:
  Action Servers:
  Action Clients:</pre>			<p class="calibre3">As you <a id="_idIndexMarker237" class="pcalibre calibre4 pcalibre1"/>can see, there are quite a lot of things on the terminal. We <a id="_idIndexMarker238" class="pcalibre calibre4 pcalibre1"/>will get to know all of them in the following chapters. With <strong class="source-inline1">ros2 node info &lt;node_name&gt;</strong> you can see all topics (publisher<a id="_idTextAnchor207" class="pcalibre calibre4 pcalibre1"/>s/subscribers), services, and actions running for this node.</p>
			<h2 id="_idParaDest-110" class="calibre6"><a id="_idTextAnchor208" class="pcalibre calibre4 pcalibre1"/>Changing the node name at run time</h2>
			<p class="calibre3">As we progress throughout the book, I will give you additional tips for working with ROS 2 and <a id="_idIndexMarker239" class="pcalibre calibre4 pcalibre1"/>the command line. Here is one: when starting an executable, you can choose to use the default node name (the one defined in the code) or replace it with a new name.</p>
			<p class="calibre3">To add any additional argument to <strong class="source-inline1">ros2 run</strong>, first add <strong class="source-inline1">--ros-args</strong> (only once).</p>
			<p class="calibre3">Then, to rename the node, add <strong class="source-inline1">-r __node:=&lt;new_name&gt;</strong>. <strong class="source-inline1">-r</strong> means remap; you could also use <strong class="source-inline1">--remap</strong>. For example, if we want to name the node <strong class="source-inline1">abc</strong>, we could use this:</p>
			<pre class="console">
$ ros2 run my_py_pkg test_node --ros-args -r __node:=abc
[INFO] [1711010078.801996629] [abc]: Hello 0
[INFO] [1711010079.805748394] [abc]: Hello 1</pre>			<p class="calibre3">As you can see from the logs, instead of <strong class="source-inline1">my_node_name</strong>, we see <strong class="source-inline1">abc</strong>.</p>
			<p class="calibre3">List all running nodes:</p>
			<pre class="console">
$ ros2 node list
/abc</pre>			<p class="calibre3">This functionality can be very helpful and gives you more control over how to start a node, without <a id="_idIndexMarker240" class="pcalibre calibre4 pcalibre1"/>having to modify the code directly.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When running multiple nodes, you should make sure that each node has a unique name. Having two nodes with the same name can lead to some unexpected issues that can take a long time to debug. In the future, you will see that you may want to run the same node several times, for example, three <code>temperature_sensor</code> nodes, one each for a different sensor. You could rename them so that you have <code>tempera<a id="_idTextAnchor209" class="pcalibre calibre4 pcalibre1"/>ture_sensor_1</code>, <code>temperature_sensor_2</code>, and <code>temperature_sensor_3</code>.</p>
			<h1 id="_idParaDest-111" class="calibre6"><a id="_idTextAnchor210" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you have created your first node. Let’s do a quick recap of all the steps.</p>
			<p class="calibre3">Before creating any node, you need to follow these steps:</p>
			<ol class="calibre11">
				<li class="calibre10">You first need to create and set up a ROS 2 workspace.</li>
				<li class="calibre10">In this workspace, you can create several packages (Python or C++) that represent different sub-parts of your application.</li>
			</ol>
			<p class="calibre3">Then, in one package you can create one or several nodes. For each node, you will have to do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Create a file inside the package.</li>
				<li class="calibre10">Write the node (using the OOP template as a base).</li>
				<li class="calibre10">Set the build instructions (<code>setup.py</code> for Python, <code>CMakeLists.txt</code> for C++).</li>
				<li class="calibre10">Build the package.</li>
			</ol>
			<p class="calibre3">To run the node, don’t forget to source the workspace first, and then start the node with <strong class="source-inline1">ros2 run &lt;</strong><strong class="source-inline1">pkg_name&gt; &lt;executable_name&gt;</strong>.</p>
			<p class="calibre3">Finally, you can introspect your nodes and even change their names when you start them, using the <strong class="source-inline1">ros2 node</strong> command line.</p>
			<p class="calibre3">Feel free to come back to this chapter anytime to see the complete process of creating a node for both Python and C++. All the code is available on GitHub at <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>. There you can find the OOP template code for Python and C++, <strong class="source-inline1">my_py_pkg</strong> package, and <strong class="source-inline1">my_cpp_pkg</strong> package.</p>
			<p class="calibre3">In this chapter, you have also seen how to create a timer and a callback function. You have a better idea of how the spin mechanism works, and how it allows the node to stay alive and run the callbacks. This will be very useful for the following chapters.</p>
			<p class="calibre3">In the next chapter, we will see how nodes communicate with each other using topics. You will write your own topics (publishers/subscribers) inside nodes and experiment with them.</p>
		</div>
	</body></html>