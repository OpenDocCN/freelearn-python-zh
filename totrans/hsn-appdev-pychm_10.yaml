- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More Full Stack Frameworks – Django and Pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web frameworks we’ve covered so far were exemplary in the way they work.
    Flask is an unopinionated micro-framework. By this we mean Flask only handles
    endpoint routing and optionally, serving templated page content. FastAPI features
    a framework specifically for building RESTful APIs rather than serving content
    beyond data. It also features an asynchronous programming model reminiscent of
    modern JavaScript frameworks running in NodeJS.
  prefs: []
  type: TYPE_NORMAL
- en: There are two more frameworks you’ll find on the **New Project** menu in PyCharm
    Professional, and we’re going to cover them here. **Django** is a very popular
    framework that is, philosophically speaking, the diametric opposite of Flask.
    Django is a highly opinionated framework that attempts to make all your platform
    and framework choices for you.
  prefs: []
  type: TYPE_NORMAL
- en: The final framework we’ll talk about is **Pyramid**. Pyramid aims for the middle
    ground between Flask and Django offering more bundled features than Flask, but
    more flexibility than Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to generate a Django project using PyCharm Professional’s new project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify the major files and folders present in the templated project
    generated by PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Django-specific tooling in PyCharm for `manage.py` tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Pyramid project in PyCharm Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve already covered a lot of theory on how web applications work in earlier
    chapters, so let’s get straight into developing these two frameworks using PyCharm.
    As with other web development frameworks, these features are only available in
    the Professional edition of PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install the package managers such as `pip` and
    virtual environment tools such as `virtualenv` separately. Our examples will use
    `pip` and `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*, in case
    you are jumping into the middle of the book. I am using build PyCharm Professional
    2023.1 (build #PY-231.8109.197) with the new UI turned on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s sample source code from GitHub. We covered cloning the code in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*. You’ll
    find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-10](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s all this fuss about Django?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ask most Python developers which framework they prefer, I’ll wager it
    is an even split between Flask and Django. I’ll also wager that the Django crowd
    are raving fans of Django while Flask seems more like a thing you use to get stuff
    done. It’s like getting excited about a screwdriver. Django is a lot more opinionated,
    and as such, a lot more “in your face." You barely notice Flask because it’s just
    a piece of the puzzle. Django is all the pieces in one box, plus that glue you
    use to make puzzles into a picture, plus an expensive frame for the completed
    glued puzzle, plus a beach house so you have a place to hang your puzzle. There
    might even be little mints on the pillows in the beach house, but I make no promises.
  prefs: []
  type: TYPE_NORMAL
- en: Django, on the other hand, promises to be a web framework that handles the heavy
    lifting and repetitive aspects of web application development. Web developers
    are freed up to focus on the specific logic of their applications. Web frameworks
    usually implement common design patterns and good practices into their structure,
    so that a web application developed with a framework will be up to common standards
    by default, without its developer having to manually integrate those standards
    into the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django aims to have everything you need to develop a web application baked
    into the framework. Since that is true, you shouldn’t have to think about your
    stack at all. Django becomes more than a framework; it becomes an ethos. You become
    a fan of Django’s way. You might even say *“This is the way,”* and Django might
    say it back. Here are some things Django is good at:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Similar to Python itself, Django emphasizes the ease of developing
    and translating ideas into actual code. With straightforward yet extensive APIs,
    Django aims to accommodate a wide range of web applications and features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Web development is one of the topics in programming in which
    security is the highest priority. The Django framework offers features that navigate
    web developers, beginners, and experts alike, away from security flaws in their
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: When a website gains more clients, scalability becomes more
    and more important. Scalability in Django can be achieved in flexible and intuitive
    ways; in fact, some of the largest sites on the internet (Bitbucket, Instagram,
    Pinterest, and so on) are built with Django for that reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these are specifically addressed by Flask. In fact, Flask is not normally
    used for large web applications because it is relatively slow. Personally, I’ve
    moved all my product backend code away from Flask and into FastAPI because the
    performance is noticeably better.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, Django sounds much better than anything else we’ve talked about so
    far. Despite being a popular and powerful web framework, Django, like any technology,
    has its detractors. Some of the common criticisms and concerns raised about Django
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steep learning curve**: Some developers find Django’s learning curve to be
    relatively steep, especially for beginners with limited experience in Python or
    web development. Its extensive feature set and comprehensive nature can be overwhelming
    for newcomers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magic and abstraction**: Django’s emphasis on “batteries included” and abstraction
    can be a double-edged sword. While it saves development time, some developers
    argue that it can obscure the underlying mechanisms, making it harder to understand
    and troubleshoot complex issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overhead for small projects**: For small projects or simple websites, some
    developers feel that Django’s feature richness and structure can be overkill,
    adding unnecessary overhead and complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monolithic nature**: Critics argue that Django is a monolithic framework,
    and it may not be the best fit for microservices architectures or highly specialized
    applications where a lightweight framework might be more suitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility versus opinionated**: Django follows a particular design philosophy
    and enforces certain patterns, which some developers see as overly opinionated.
    This can lead to debates over the “Django way” of doing things versus alternative
    approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Although Django is reasonably performant, some developers
    claim that it may not be as fast as certain micro-frameworks or specialized tools.
    Performance-critical projects may require additional optimization efforts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORM limitations**: While Django’s ORM is powerful and easy to use, it may
    not cover all edge cases or offer the same level of control as writing raw SQL
    queries. In certain scenarios, developers may prefer using other ORMs or query
    builders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version upgrades**: Upgrading between major versions of Django can sometimes
    be challenging, especially for older projects heavily reliant on deprecated features.
    This can lead to maintenance issues and additional development efforts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization complexity**: While Django offers flexibility, some developers
    find it challenging to customize certain built-in components, such as the admin
    interface, to fit specific design requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and ecosystem**: Although Django has a large and active community,
    it may not have as extensive an ecosystem or as many third-party packages available
    as some other web frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that while these criticisms exist, Django has an extensive
    user base, and many developers appreciate its productivity, stability, and comprehensive
    feature set. Ultimately, the choice of a web framework depends on the specific
    needs and preferences of the project and development team.
  prefs: []
  type: TYPE_NORMAL
- en: Django framework components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django includes an inclusive set of components that make it a comprehensive
    and feature-rich framework for web development. Here are some of the key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL dispatching (routing)**: Django uses a URL dispatcher to route incoming
    HTTP requests to the appropriate view functions or class-based views. This enables
    clean and logical URL patterns for your web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View functions and class-based views**: Views in Django are responsible for
    processing user requests and returning HTTP responses. You can use simple functions
    as views or use Django’s class-based views for more organized and reusable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Django’s template system allows you to define the structure
    and layout of your web pages using HTML templates with placeholders for dynamic
    content. This separation of concerns (logic and presentation) makes it easier
    to maintain and scale your web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model-View-Template (MVT) architecture**: Similar to the **Model-View-Controller**
    (**MVC**) pattern, Django follows the MVT pattern. Models represent the data structures
    and the database schema, views handle the logic and processing, and templates
    take care of rendering the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-Relational Mapping (ORM)**: Django’s ORM is one of its defining features.
    It provides a high-level, Pythonic way to interact with databases without having
    to write raw SQL queries. It allows you to define models as Python classes, and
    the ORM handles the mapping of these models to the database tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forms**: Django includes a form-handling system that simplifies form creation,
    data validation, and handling user input. It helps in processing HTML forms and
    converting user-submitted data into Python data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin interface**: Django’s admin interface is an automatic admin interface
    that can be used to manage your application’s data models. It provides an out-of-the-box
    solution for managing model data and is customizable to fit your specific needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**: Middleware components in Django are hooks that allow you to
    process requests and responses globally before they reach the view or after they
    leave the view. It enables features including authentication, security checks,
    and request/response modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static files**: Django has built-in support for managing static files such
    as CSS, JavaScript, and images. It simplifies the process of serving static content
    during development and deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication and authorization**: Django provides a robust authentication
    system for managing user accounts, permissions, and groups. It makes it easy to
    add user registration, login, and password management functionalities to your
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I**nternationalization and localization**: Django supports internationalization
    and localization, allowing you to create applications that can be translated into
    multiple languages and adapted to various regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing framework**: Django comes with a testing framework that facilitates
    unit testing and integration testing of your application. You can write test cases
    to ensure that your code works as expected and avoid regressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that overhead, it’s a good thing we have such a capable tool in PyCharm.
    Let’s dive into creating a Django application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Django project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process is no different than most other projects. Click **File | New Project**
    then click the **Django** option as shown in *Figure 10**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Creating a new Django project is much like any other project](img/B19644_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Creating a new Django project is much like any other project'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to twirl down the **More Settings** section. Here you can set the template
    language. You can use either the **Django templating language** or **Jinja2**,
    which was what we used in [*Chapter 9*](B19644_09.xhtml#_idTextAnchor223), *Building
    a Dynamic Web Application with Flask*. Since we covered Jinja2 already, let’s
    stick with Django. You can set the name of the folder you’ll use for templates,
    and you absolutely should set a value for the **Application name** field as shown
    at the bottom of *Figure 10**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t skip the application name
  prefs: []
  type: TYPE_NORMAL
- en: If you skip the `manage.py` tooling we’ll cover later, but that’s probably not
    what you want most of the time when you are creating a new project. Furthermore,
    you should not name the application the same as the PyCharm project as it can
    cause confusion in PyCharm’s indexing, not to mention for the humans working on
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Django projects often have multiple applications within them, and the **Application
    name** setting here is used to create and name the first application within the
    project. We’re going to be building a single library application in our project.
    Since the term *library* is ambiguous in a programming book, I’ll clarify the
    name of the application so we understand the *library* is a place that serves
    books rather than a programming library.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting newly created project is shown in *Figure 10**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The Django project has been created and PyCharm opens the urls.py
    and settings.py files as a starting point](img/B19644_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The Django project has been created and PyCharm opens the urls.py
    and settings.py files as a starting point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the super long list of components, it is a little surprising how few
    files were created. PyCharm has automatically opened two as a starting point:
    `urls.py` and `settings.py`. Let’s take a look at what these and the rest of the
    files and folders are for in our newly created application.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a Django project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you might notice is the project, which I just called `djangoProject`,
    has its own set of files distinct from the application, which is in the `TheGreatBookery`
    folder. All of the files inside of the `djangoProject` folder are used in the
    deployment of your application to production, as well as to run the built-in development
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `TheGreatBookery` folder, we have a folder for database migrations.
    This is common for applications that use ORMs. You need a way to make changes
    to the production database as you roll new releases into production. You can’t
    simply drop the database and rebuild it since that would erase all your application’s
    data. There needs to be a system to migrate schema changes to the existing database
    while maintaining your existing production data. Django’s system for migrations
    utilizes migration scripts stored in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: The templates folder, which is technically outside the application’s folder,
    is where we keep our HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be able to guess the functions of the remaining files by their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin.py` is used to register modules, data models, and perhaps most obviously
    from the name, to control the admin user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps.py` provides a central place to customize and configure the behavior
    of your application within the Django project. It allows you to specify various
    settings and metadata for your application, such as the human-readable name, default
    app configuration, and signals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.py` will contain your data model, which is affected by the ORM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests.py` will house your application’s unit tests, which run using Django’s
    own testing framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views.py` will contain view functions. These are Python functions that take
    an HTTP request as an argument and return an HTTP response. Within these functions,
    you can handle the request, process data from the models or other sources, and
    generate an appropriate HTTP response, often by rendering a template with dynamic
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While this is not a book on Django, I would be remiss if I didn’t point out
    a few things in the `settings.py` file. Like Flask, Django has a built-in development
    web server that is not designed to be used in production. The `settings.py` file
    has some dangerous settings in it as hardcoded values that are appropriate for
    local development only. Open up `settings.py` and locate these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Something you should do early is make sure to draw these values from outside
    your code. You should never hardcode a secret in your application code, and you
    should never commit secrets to a revision control system! You can externalize
    these values using environment variables, `.ini` files, or `.env` files using
    libraries from `PyPi.org`. Leaving the `DEBUG` setting hardcoded can be dangerous
    because errors thrown may be plainly visible along with the stack trace and other
    details that bad actors might be able to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another setting you might want to review is the database engine. You’ll find
    these lines toward the bottom of `settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PyCharm has defaulted us to SQLite3, which is not really suitable for a production
    application. SQLite3 is a file-based database, and using it for local development
    is advantageous because it doesn’t require the installation of a server. You shouldn’t
    serve a production app with SQLite3, and in my opinion, you should develop using
    the same database you’ll use in production.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we won’t be taking this app to production so I’m going to leave the
    settings as they are. Your database will appear in the project directory as a
    file called `db.sqlite3`. We will learn about PyCharm’s database capabilities
    in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266). Know that PyCharm has a rich
    set of tools for viewing and working with databases, including SQLite3, which
    can help during development.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Django project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created the project, PyCharm created a run configuration for us. We
    covered run configurations extensively in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145).
    We simply want to run the one PyCharm generated, so simply click the green **Run**
    button shown in *Figure 10**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The Run button will start the development server](img/B19644_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The Run button will start the development server'
  prefs: []
  type: TYPE_NORMAL
- en: Running the project will open the **Run** panel at the bottom of the IDE window,
    as shown in *Figure 10**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Our project is running and being served on localhost port 8000](img/B19644_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Our project is running and being served on localhost port 8000'
  prefs: []
  type: TYPE_NORMAL
- en: We can see our project is running on port `8000`, and there’s a handy link that
    will open our default browser to the running app, as shown in *Figure 10**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Clicking the link opens the browser and displays a nice message
    letting you know everything is working](img/B19644_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Clicking the link opens the browser and displays a nice message
    letting you know everything is working'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm has effectively created a minimal working application for us. In a real
    projects, this is usually where I address deployment via **continuous integration**
    (**CI**) and **continuous delivery** (**CD**). One piece of advice I always give
    new web developers is to get the production mechanics in place as early as possible.
    If you do it right, you won’t have to mess with them again for quite a while.
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains has a very good CI/CD server called TeamCity. I used it exclusively
    for the last 10 years, having only last year switched begrudgingly to Microsoft
    Azure DevOps. TeamCity is a much better system and its definitely worth your time
    and trouble if you’re looking for a CI/CD server. JetBrains even offers plugins
    for PyCharm that allow you to control and monitor builds right from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: This, though, is a chapter on Django, so let’s keep the party rolling and move
    on to working with data models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Django models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Django application, models play a central and crucial role. They are the
    backbone of the application’s data structure and are responsible for defining
    the database schema and handling data operations. Models allow developers to interact
    with the underlying database in an object-oriented manner, making it easier to
    manage and manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: Models serve as an interface between the application and the database. They
    abstract away the complexities of SQL queries and provide a high-level API to
    perform **Create, Read, Update, Delete** (**CRUD**) operations. By using model
    methods and querysets, developers can interact with the database without having
    to write raw SQL code. Everything related to the database driving the application
    (including the things a lot of developers usually leave out, such as validation
    and constraints) can be found rolled into a Django model.
  prefs: []
  type: TYPE_NORMAL
- en: A prevalent anti-pattern that sometimes pops up with projects that forgo using
    ORMs is the use of the database to encapsulate business logic. The justification
    for this is usually that changing the database is quick, easy, and doesn’t require
    a new compilation or a new deployment. This is a foolish economy, and in a modern
    era that requires governance and documented change control, it becomes anathema.
    The senior database developer on my team, who is also a technical reviewer for
    [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), describes this practice as changing
    the tires on a semi-truck while it is traveling down the highway at 100 mph. Django
    models, though, since they are technically objects, are able to handle business
    logic effectively and without taboo. This is because only the structure of the
    data model is translated into the database while the logic remains within the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The thing you need to remember about using an ORM, which is what we’re doing
    when we create and manipulate models, is that we are working with an abstraction
    of our database. When we manipulate instances of our models we are altering data
    in the database. Likewise, when we change the structure of our classes, we are
    altering the structure of the database. There are differences between the way
    data types in your programming language work and the way they work in the database.
    We’ll see this in action later, but right now I want you to think about the fact
    that Python is a dynamic language that uses duck typing. In Python, I can alter
    any structure or type in any way that suits me. Databases on the other hand are
    static and strongly typed. Django’s ORM has its work cut out for it given the
    differences in paradigm between the way Python works with classes, types, and
    variables versus the way the database works with tables.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at creating an easy model. Locate the `models.py` file. You can find
    it displayed in *Figure 10**.6*, or you can use the navigation features in PyCharm
    by pressing *Ctrl* + *Shift* + *N* (`models.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Open the models.py file so we can add a model](img/B19644_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Open the models.py file so we can add a model'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code within will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to create two models for our Bookery application: `author` and
    `book`. To do this, let’s alter the code in `models.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve added two imports both related to time and dates. We’re going to
    use these libraries in some business logic that we will attach to the book model.
    Let’s not get ahead of ourselves, though. Let’s make a simple model to represent
    book authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The class is hopefully straightforward enough. The `Author` class inherits from
    Django’s `model.Model` class. There are two fields for the author’s first and
    last name and use the `models.CharField` type to represent what would be varchars
    in the database. Relational databases require to declare a strong type, and in
    the case of a varchar (a variable-length character field), we have to supply a
    maximum length. The dunder string method simply gives us a nice format should
    we request the contents of the model as a string. Here, we’ve elected to format
    the author’s name as last name, comma, space, and first name.
  prefs: []
  type: TYPE_NORMAL
- en: Every ORM, regardless of platform, works the same way. Its aim is to allow developers
    to work only with native language objects. With that said, they usually need their
    own type system to allow the ORM to translate between the type system of the language
    (Python) and the database. You’ll learn in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266)
    that database data types are not the same as in their programming language counterparts.
    At a minimum, differences such as calling strings as varchars are apparent, and
    types including int and float exist in both contexts. Sometimes they are even
    different between database platforms. There are datatypes in SQLite3 that are
    not present in MySQL, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: An ORM has to work everywhere, so having its own type system for models allows
    for a single type system for the developer that can be adapted to any database
    platform. It is a classic implementation of the Gang of Four’s **adapter pattern**,
    which I cover in my book *Real-World Implementation of C# Design Patterns*, published
    by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `author` class is not very fancy. Let’s do some more interesting code in
    the `Book` model code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So far we have a `Book` class inheriting from `models.Model` as before. We have
    a title field with a maximum length of 200 characters. There is an `author` field,
    but rather than make this a string, we used the `Author` class to set up a `authors`
    table, which is controlled by the `Author` class we made a minute ago. A foreign
    key relationship specifies that any `Book` we add to the database must contain
    a related (it’s a relational database) database to an existing author. Operationally,
    this means we have to make sure the author exists in the database before we can
    add the author’s books to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign key constraints serve as a form of built-in data validation but they
    also help maintain data integrity in the database by enforcing rules. If I were
    to add an author to the database, and then add a bunch of books written by that
    author, we would have a nice relationship going on between the two tables. If
    I were to then delete the author from the `authors` table, we’d still have a bunch
    of book records without a related author. They would be orphan records. Orphan
    records are bad because they take up space in the database, and they break the
    integrity of the relationship between authors and books.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, when we define the `author` field, we are defining it with a
    foreign key constraint with an actual rule covering what happens when you delete
    an author. The code that says `on_delete=models.CASCADE` tells the ORM that when
    an author is deleted, so are the records of the books they’ve written. It is called
    a cascading delete because the delete cascades from the author to the book records,
    which could in turn cascade to other tables that might have similar relationships
    to books. A well-constructed database can keep itself clean and devoid of orphan
    records regardless of how complex the database structure might be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have a date to contain the publication date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `foreign key` field didn’t add enough spice for you, let’s add one more
    thing. Since we are dealing with an object, and since objects can contain both
    data and functional logic, let’s add a function to our `Book` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This adds a field to our model, but rather than this data being stored in the
    database, it is computed at the time the method is called. We’re taking the static
    field for the publication date and computing the difference (delta) of the time
    to the current date. We’re taking into account the time zone and we’re presenting
    it as the number of days since the book was published. This allows us to show
    our users how old the book is in days, which might be used to prompt authors to
    produce new and updated editions of their books.
  prefs: []
  type: TYPE_NORMAL
- en: Performing migrations using manage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the files generated for your Django project is `manage.py`. You can see
    it in *Figure 10**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: The manage.py file provides utilities for working with your
    Django project so you don’t have to type in long commands or remember full paths](img/B19644_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The manage.py file provides utilities for working with your Django
    project so you don’t have to type in long commands or remember full paths'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `manage.py` task is to allow you to run Django-specific commands
    from the command line without having to remember the full path to your Django
    project or manually set up the Python environment. By using `manage.py`, you ensure
    that the commands are executed within the correct Django project context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common tasks you can perform with `manage.py` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`manage.py runserver`. This allows you to test your application locally during
    development. Earlier, we ran the Django project using the generated run configuration.
    We could have also used `manage.py` for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py makemigrations` and `manage.py migrate`, you can create and apply
    database migrations, respectively. This helps you manage changes to your models
    and keep your database schema up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py createsuperuser`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py test` to ensure that your application functions as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py collectstatic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py makemessages` and `manage.py compilemessages`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a short list. There are many more utilities in `manage.py`. The
    `manage.py` file serves as an entry point to Django management commands, making
    it easy to perform administrative tasks without leaving your development environment.
    Before you head down to the terminal button in PyCharm, there is actually an easier
    way to work with `manage.py`. Click **Tools | Run manage.py task...** as shown
    in *Figure 10**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: PyCharm has a dedicated tool panel for working with manage.py](img/B19644_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: PyCharm has a dedicated tool panel for working with manage.py'
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a new panel, as shown in *Figure 10**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: The Run manage.py task panel is a dedicated command-line interface
    that lets you easily invoke commands specific to Django’s manage.py file](img/B19644_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: The Run manage.py task panel is a dedicated command-line interface
    that lets you easily invoke commands specific to Django’s manage.py file'
  prefs: []
  type: TYPE_NORMAL
- en: The `manage.py` panel opens at the bottom of the IDE as many do. At first glance,
    it looks like a terminal window, but this one is specific to Django and the `manage.py`
    file. As you can see, the panel provides auto-completion to help with the commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create our migrations, you should type this command into the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The result will resemble *Figure 10**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: The result of the makemigrations command](img/B19644_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: The result of the makemigrations command'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find some messages in the `manage.py` panel as well as a new file in
    the `migrations` folder called something like `0001_initial.py`. The `makemigrations`
    command generated the code needed for the migration, but it hasn’t performed the
    migration yet. Performing the migration is what affects the changes to the database.
    In order to run the migration, type this into the `manage.py` task panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output from the command, shown in *Figure 10**.11*, indicates the database
    structure has been updated to match the models.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: The result of the migration is a set of messages and the appearance
    of our database file](img/B19644_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: The result of the migration is a set of messages and the appearance
    of our database file'
  prefs: []
  type: TYPE_NORMAL
- en: We see a bunch of SQL statements that were generated to bring the database structure
    up to match the structure of the models. We also see a new file for our database.
    If you remember, we saw earlier that the name and path of this file were set in
    the `settings.py` file. Since SQLite3 is a file database, this is the actual database
    itself. This is the kind of thing you might want to exclude from revision control
    on a real project.
  prefs: []
  type: TYPE_NORMAL
- en: The Django admin interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of the killer features of Django: it creates a web-based administrative
    panel for you. This means you don’t have to build an interface for dealing with
    users, handling logins, or creating screens for simple data entry into your model
    structure. The first thing every app needs is an administrative user or superuser.
    It is common for applications to have role-based user access, and the super-user
    is the user who can do everything, including adding new users. This kind of thing
    might take a developer two or three days to get working, but with Django, it’s
    already done.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a superuser and logging in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before users, logins, or any of the other goodies we’re talking about here work,
    you need to apply a migration that was generated for you when you created the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s head back to our `manage.py` task panel and type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just like that, by itself. This adds all the base tables for the application.
    We probably should have done this first, but I didn’t want to break the flow of
    what we were working on. OK, really I forgot, but it sounded better the other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that migration run we now have all the tables and structures in the database
    to support Django’s login and user administration feature. Next, let’s create
    the superuser. In the panel, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You are asked a set of questions designed to create a superuser for your application
    as shown in *Figure 10**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: The manage.py panel interaction for creating a superuser](img/B19644_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: The manage.py panel interaction for creating a superuser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out the management interface! While you could just use the run configuration,
    let’s see what it is like to run it from the `manage.py` task panel. Type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then click the link in the panel message shown in *Figure 10**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: This time, let’s run from the panel!](img/B19644_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: This time, let’s run from the panel!'
  prefs: []
  type: TYPE_NORMAL
- en: In truth, it is the exact same thing you would have gotten by clicking the green
    run button as we did the first time we ran the app. After clicking the link, your
    browser opens to the same page we saw before. Change the URL in the browser to
    [http://127.0.0.1:8000/admin](http://127.0.0.1:8000/admin). This will take you
    to the administrative login page shown in *Figure 10**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: The best kind of login system is the one you didn’t have to
    make yourself!](img/B19644_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: The best kind of login system is the one you didn’t have to make
    yourself!'
  prefs: []
  type: TYPE_NORMAL
- en: Type in the superuser user name and password you specified in the task panel.
    *Figure* *10**.15* shows the admin screen that should appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Without writing any code, we can add users and groups to the
    application](img/B19644_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Without writing any code, we can add users and groups to the
    application'
  prefs: []
  type: TYPE_NORMAL
- en: Click around to see everything Django has generated for us. You can add users
    and groups to the application despite not having written any code for this – Django
    handled it for us. The downside here is that it was generated based on the Django
    project’s ideas on what an admin panel should look like and how it should work.
    While it is possible to customize some of this functionality, remember that I
    keep saying that Django is *opinionated*. It has assumptions baked in. Less opinionated
    frameworks would require you to build this or use a plugin, but you would be in
    total control over how this feature was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Author and Book models to the admin interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you get users and groups for free, you do have to do a tiny bit of work
    to get authors and books to show up in the admin interface. Let’s start with the
    `Author` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `admin.py` file in `TheGreatBookery` folder and find a comment that
    says `# Register your models here`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If your app stopped or crashed, go ahead and restart it, then navigate to the
    admin page as before. You should now see **Authors** appear on the admin page,
    as shown in *Figure 10**.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: With very little effort, we can now add, edit, and delete authors](img/B19644_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: With very little effort, we can now add, edit, and delete authors'
  prefs: []
  type: TYPE_NORMAL
- en: We have the Author model; let’s add `Book`. This one is a little fancier. Remember,
    there is a relationship between Book and Author. Each Author can be related to
    many Books, or inversely, many Books are related to one Author.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is so, we want the admin interface to not only reflect this relationship
    but enforce it at the UI layer. You can just slap an import for the book model
    in and expect it to work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `admin.py` file and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an addition to the `Author` UI that allows you to add books
    inline which is to say when you add an author, you will then have the opportunity
    to add books. You can’t have books without first adding authors. Because we defined
    the relationship and the UI this way, the ability to add and edit books is part
    of administering the author. You’ll never even have the chance to mess up by adding
    books before authors, or by somehow disassociating a book from an author.
  prefs: []
  type: TYPE_NORMAL
- en: Restart your server, and refresh your browser. Nothing changed! Hang on, that’s
    OK. We haven’t tried to add an author yet. Click **Authors** and then click **Add**,
    and you’ll find the interface shown in *Figure 10**.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Our code added inline books to the UI for managing authors](img/B19644_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Our code added inline books to the UI for managing authors'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the form for adding books is now attached inline to the form
    for working with authors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Django views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The admin UI is pretty magical, but it is really only designed to create simple
    screens for managing data in a database. Sooner or later, you’re going to have
    to actually make some real screens for the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful about terminology here because the word *views* doesn’t
    mean what you might expect if you are versed in more conventional web development
    design patterns. The prevailing industry pattern is called **Model-View-Controller**
    (**MVC**). The pattern employed by Django is called **Model-View-Template** (**MVT**).
    *View* doesn’t mean the same thing between the two patterns. Let’s compare the
    two.
  prefs: []
  type: TYPE_NORMAL
- en: '| **MVC** | **MVT** |'
  prefs: []
  type: TYPE_TB
- en: '| Model refers to the data structure, usually from a database. | Model means
    the same thing as it does in MVC. |'
  prefs: []
  type: TYPE_TB
- en: '| View refers to the visual elements which is usually the user interface. |
    View refers to the controller layer, which accepts incoming requests, performs
    logic, and returns content or data. |'
  prefs: []
  type: TYPE_TB
- en: '| Controller refers to a layer that accepts incoming requests, performs logic,
    and returns content or data | Template refers to the View in MVC, which is the
    HTML or user interface elements in the application. |'
  prefs: []
  type: TYPE_TB
- en: In summary, the Django View is really the Controller, and the Django Template
    would be the View in an MVC app. So here, when we are about to make the View,
    we’re talking about the part of the app that receives requests, does something,
    then returns the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file in the `TheGreatBookery` folder. Change the code to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: from django.contrib import admin
  prefs: []
  type: TYPE_NORMAL
- en: from django.urls import path
  prefs: []
  type: TYPE_NORMAL
- en: from TheGreatBookery.views import index
  prefs: []
  type: TYPE_NORMAL
- en: urlpatterns = [
  prefs: []
  type: TYPE_NORMAL
- en: path('admin/', admin.site.urls),
  prefs: []
  type: TYPE_NORMAL
- en: path('', index, name='index')
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '{% if latest_books %}'
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% for book in latest_books %}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>{{ book.title }} by {{ book.author }}</li>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endfor %}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{% else %}'
  prefs: []
  type: TYPE_NORMAL
- en: <p>No books available.</p>
  prefs: []
  type: TYPE_NORMAL
- en: '{% endif %}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
