<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer081" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">3</h1>&#13;
    <h1 id="_idParaDest-64" class="chapterTitle">Pythonic Syntax and Common Pitfalls</h1>&#13;
    <p class="normal">In this chapter, you will learn how to write Pythonic code, along with finding out about some of the common pitfalls of Python and how to work around them. The pitfalls range from passing a list or dictionary (which are mutable) as an argument to more advanced pitfalls, such as late-binding in closures. You will also see how to fix or work around circular imports in a clean way. Some of the techniques used in the examples in this chapter might seem a bit too advanced for such an early chapter. Do not worry, though, as the inner workings will be covered later on.</p>&#13;
    <p class="normal">We will explore the following topics in this chapter:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Code style (PEP 8, <code class="inlineCode">pyflakes</code>, <code class="inlineCode">flake8</code>, and more)</li>&#13;
      <li class="bulletList">Common pitfalls (lists as function arguments, pass by value versus pass by reference, and inheritance behavior)</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">The definition of Pythonic code used in this chapter is based on commonly accepted coding guidelines and my subjective opinions. When working on a project, it is most important to stay consistent with the coding styles of that project.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-65" class="heading-1">A brief history of Python</h1>&#13;
    <p class="normal">The <a id="_idIndexMarker099"/>Python project started in December 1989 as a hobby project for Guido van Rossum during his week off around Christmas. His goal was to write an easy-to-use successor for the ABC programming language and to fix the issues that limited the applicability of the it. One of the main design goals of Python is, and has always been, readability. That is what the first part of the chapter is about: readability.</p>&#13;
    <p class="normal">To facilitate new features and to maintain that readability, the <strong class="keyWord">Python Enhancement Proposal</strong> (<strong class="keyWord">PEP</strong>) process <a id="_idIndexMarker100"/>was developed. This process allows <strong class="keyWord">anyone</strong> to submit a PEP for a new feature, library, or other addition. After a discussion on the Python mailing lists and some improvements, a decision is made to either accept or reject the proposal.</p>&#13;
    <p class="normal">The Python<a id="_idIndexMarker101"/> style guide (PEP 8: <a href="https://peps.python.org/pep-0008/"><span class="url">https://peps.python.org/pep-0008/</span></a>) was once submitted as one of those PEPs, was accepted, and has been improved regularly ever since. It has a lot of great and widely accepted conventions, as well as a few disputed ones. In particular, the maximum line length of 79 characters is a topic of much discussion. Limiting a line to 79 characters does have some merits, however. Originally, this choice was made because terminals were 80 characters wide, but these days, larger monitors allow you to place multiple files next to each other. For docstrings and comments, a 72-character limit is recommended to increase readability. Additionally, it’s the common convention for Linux/Unix man (manual) pages.</p>&#13;
    <p class="normal">While just the style guide<a id="_idIndexMarker102"/> itself does not make code Pythonic, as <em class="italic">The Zen of Python</em> (PEP 20: <a href="https://peps.python.org/pep-0020/"><span class="url">https://peps.python.org/pep-0020/</span></a>) elegantly puts it: “Beautiful is better than ugly.” PEP 8<a id="_idIndexMarker103"/> defines how code should be formatted in an exact way, while PEP 20 is more of a philosophy and mindset than anything else.</p>&#13;
    <p class="normal">For almost 30 years, all major decisions for the Python project were made by Guido van Rossum, lovingly called the <strong class="keyWord">BDFL </strong>(<strong class="keyWord">Benevolent Dictator For Life</strong>). Unfortunately, the “For Life” part of BDFL was not to be after a heated debate over PEP 572. PEP 572 (covered later in this chapter) was a proposal about assignment operators, the ability to set a variable inside an <code class="inlineCode">if</code> statement, a common practice in languages such as C, C++, C# and others. Guido van Rossum was not a fan of the syntax and opposed the PEP. This triggered a huge debate and he was met with such resistance that it moved him to step down as BDFL. It saddened many people that Guido van Rossum, universally loved by the community, felt he had to do this. I, for one, will certainly miss his insights as the decision-maker. I hope we will still see his “Time Machine” in action a few times. Guido van Rossum is thought to have a time machine, as he has repeatedly answered feature requests with “I just implemented that last night.”</p>&#13;
    <div class="note">&#13;
      <p class="normal">Without the BDFL to make the final decisions, the Python community had to come up with a new way of decision-making, and a whole list of proposals have been written to solve this issue:</p>&#13;
      <ul>&#13;
        <li class="bulletList">PEP 8010: Continu<a id="_idIndexMarker104"/>e status quo (ish): <a href="https://peps.python.org/pep-8010/"><span class="url">https://peps.python.org/pep-8010/</span></a></li>&#13;
        <li class="bulletList">PEP 8011: Like status <a id="_idIndexMarker105"/>quo but with three co-leaders: <a href="https://peps.python.org/pep-8011/"><span class="url">https://peps.python.org/pep-8011/</span></a></li>&#13;
        <li class="bulletList">PEP 8012: No<a id="_idIndexMarker106"/> central authority: <a href="https://peps.python.org/pep-8012/"><span class="url">https://peps.python.org/pep-8012/</span></a></li>&#13;
        <li class="bulletList">PEP 8013: Non-core<a id="_idIndexMarker107"/> oversight: <a href="https://peps.python.org/pep-8013/"><span class="url">https://peps.python.org/pep-8013/</span></a></li>&#13;
        <li class="bulletList">PEP 8014: Core<a id="_idIndexMarker108"/> oversight: <a href="https://peps.python.org/pep-8014/"><span class="url">https://peps.python.org/pep-8014/</span></a></li>&#13;
        <li class="bulletList">PEP 8015: Organization <a id="_idIndexMarker109"/>of the Python community: <a href="https://peps.python.org/pep-8015/"><span class="url">https://peps.python.org/pep-8015/</span></a></li>&#13;
        <li class="bulletList">PEP 8016: The <a id="_idIndexMarker110"/>Steering Council Model: <a href="https://peps.python.org/pep-8016/"><span class="url">https://peps.python.org/pep-8016/</span></a></li>&#13;
      </ul>&#13;
      <p class="normal">After a small debate, PEP 8016 - the steering council model - was accepted as the solution. PEP 81XX has been reserved for future elections of the steering council, with PEP 8100 for the 2019 election, PEP 8101 for the 2020 election, and so on.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-66" class="heading-1">Code style – What is Pythonic code?</h1>&#13;
    <p class="normal">When you first hear of <a id="_idIndexMarker111"/>Pythonic code, you might think it is a programming paradigm, similar to object-oriented or functional programming. It is actually more of a design philosophy. Python leaves you free to choose to program in an object-oriented, procedural, functional, aspect-oriented, or even logic-oriented way. These freedoms make Python a great language to write in, but they have the drawback of requiring more discipline to keep code clean and readable. PEP 8 tells us how to format code and PEP 20 is about style and how to write Pythonic code. PEP 20, the Pythonic philosophy, is about code that is:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Clean</li>&#13;
      <li class="bulletList">Simple</li>&#13;
      <li class="bulletList">Beautiful</li>&#13;
      <li class="bulletList">Explicit</li>&#13;
      <li class="bulletList">Readable</li>&#13;
    </ul>&#13;
    <p class="normal">Most of these sound like common <a id="_idIndexMarker112"/>sense, and I think they should be. There are cases, however, where there is not a single obvious way to write your code (unless you’re Dutch, of course, as you’ll read later in this chapter). That is the goal of this chapter—to help you to learn how to write beautiful Python code and understand why certain decisions have been made in the Python style guide.</p>&#13;
    <p class="normal">Let’s get started.</p>&#13;
    <h2 id="_idParaDest-67" class="heading-2">Whitespace instead of braces</h2>&#13;
    <p class="normal">One of the most common complaints about Python for non-Python programmers is the use of whitespace<a id="_idIndexMarker113"/> instead of braces. Something can be said for both cases, and in the end, it <a id="_idIndexMarker114"/>doesn’t matter that much. Since nearly every programming language already defaults to similar indenting rules even with braces, why not skip the braces altogether and make things more readable? That’s what Guido van Rossum must have thought when designing the Python language.</p>&#13;
    <p class="normal">At one point, some programmers asked Guido van Rossum whether Python would ever support braces. Since that day, braces have been available through a <code class="inlineCode">__future__</code> import. Just give it a try:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> __future__ <span class="hljs-con-keyword">import</span> braces&#13;
</code></pre>&#13;
    <p class="normal">Next, let’s talk about formatting strings.</p>&#13;
    <h2 id="_idParaDest-68" class="heading-2">Formatting strings – printf, str.format, or f-strings?</h2>&#13;
    <p class="normal">Python has supported<a id="_idIndexMarker115"/> both the printf style (<code class="inlineCode">%</code>) and <code class="inlineCode">str.format</code> for a long time, so <a id="_idIndexMarker116"/>you are most likely familiar with <a id="_idIndexMarker117"/>both already. With the introduction of Python 3.6, an extra option became available, the f-string (PEP 498). The <a id="_idIndexMarker118"/>f-string is a<a id="_idIndexMarker119"/> convenient shorthand for <code class="inlineCode">str.format</code>, which helps with brevity (and therefore, I would argue, readability).</p>&#13;
    <div class="note">&#13;
      <p class="normal">PEP 498 – Literal String <a id="_idIndexMarker120"/>Interpolation: <a href="https://peps.python.org/pep-0498/"><span class="url">https://peps.python.org/pep-0498/</span></a></p>&#13;
    </div>&#13;
    <p class="normal">The previous edition of this book mainly used the printf style because brevity is important in code samples. While the maximum line length as per PEP 8 is 79 characters, this book is limited to 66 characters before wrapping occurs. With f-strings, we finally have a concise alternative to the printf style.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal"><strong class="keyWord">Tip for running the code in this book</strong></p>&#13;
      <p class="normal">Since a large portion includes the <code class="inlineCode">&gt;&gt;&gt;</code> prefix, simply copy/paste it into IPython and it will execute the code as regular Python code.</p>&#13;
      <p class="normal">Alternatively, the GitHub repository for the book has a script to automatically convert a sample from doctest style to regular Python: <a href="https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py"><span class="url">https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py</span></a></p>&#13;
    </div>&#13;
    <p class="normal">To show the power of f-strings, let’s see a few examples of <code class="inlineCode">str.format</code> and the printf style next to each other.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">The examples in this chapter show the output as returned by the Python console. For a regular Python file, you need to add <code class="inlineCode">print()</code> to see the output.</p>&#13;
    </div>&#13;
    <h3 id="_idParaDest-69" class="heading-3">Simple formatting</h3>&#13;
    <p class="normal">Formatting a <a id="_idIndexMarker121"/>simple string:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Simple formatting</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> name = <span class="hljs-con-string">'Rick'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi %s'</span> % name&#13;
'Hi Rick'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi {}'</span>.<span class="hljs-con-built_in">format</span>(name)&#13;
'Hi Rick'&#13;
</code></pre>&#13;
    <p class="normal">Formatting a floating-point number with two decimals:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> value = <span class="hljs-con-number">1</span> / <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'%.2f'</span> % value&#13;
'0.33'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'{:.2f}'</span>.<span class="hljs-con-built_in">format</span>(value)&#13;
'0.33'&#13;
</code></pre>&#13;
    <p class="normal">The first real<a id="_idIndexMarker122"/> advantage comes when using a variable multiple times. That is not possible with the printf style without resorting to named values:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> name = <span class="hljs-con-string">'</span><span class="hljs-con-string">Rick'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> value = <span class="hljs-con-number">1</span> / <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi {0}, value: {1:.3f}. Bye {0}'</span>.<span class="hljs-con-built_in">format</span>(name, value)&#13;
'Hi Rick, value: 0.333. Bye Rick'&#13;
</code></pre>&#13;
    <p class="normal">As you can see, we used <code class="inlineCode">name</code> twice by using the reference <code class="inlineCode">{0}</code>.</p>&#13;
    <h3 id="_idParaDest-70" class="heading-3">Named variables</h3>&#13;
    <p class="normal">Using named variables<a id="_idIndexMarker123"/> is fairly similar and this is where we get introduced to the magic of f-strings:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> name = <span class="hljs-con-string">'Rick'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi %(name)s'</span> % <span class="hljs-con-built_in">dict</span>(name=name)&#13;
'Hi Rick'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi {name}'</span>.<span class="hljs-con-built_in">format</span>(name=name)&#13;
'Hi Rick'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'Hi </span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">'</span>&#13;
'Hi Rick'&#13;
</code></pre>&#13;
    <p class="normal">As you can see, with the f-strings, the variables are fetched from the scope automatically. It’s basically a shorthand for:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'Hi {name}'</span>.<span class="hljs-con-built_in">format</span>(**<span class="hljs-con-built_in">globals</span>())&#13;
'Hi Rick'&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-71" class="heading-3">Arbitrary expressions</h3>&#13;
    <p class="normal">Arbitrary expressions <a id="_idIndexMarker124"/>are where the real power of f-strings becomes visible. The features of f-strings go far beyond the string interpolation of the printf-style features. The f-strings also support full Python expressions, which means they support complex objects, calling methods, <code class="inlineCode">if </code>statements, and even loops:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment">## Accessing dict items</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> username = <span class="hljs-con-string">'wolph'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-number">456</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_dict = <span class="hljs-con-built_in">dict</span>(a=a, b=b)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'''a: </span><span class="hljs-con-subst">{some_dict[</span><span class="hljs-con-string">'a'</span><span class="hljs-con-subst">]}</span><span class="hljs-con-string">'''</span>&#13;
'a: 123'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'''sum: </span><span class="hljs-con-subst">{some_dict[</span><span class="hljs-con-string">'a'</span><span class="hljs-con-subst">] + some_dict[</span><span class="hljs-con-string">'b'</span><span class="hljs-con-subst">]}</span><span class="hljs-con-string">'''</span>&#13;
'sum: 579'&#13;
&#13;
<span class="hljs-con-comment">## Python expressions, specifically an inline if statement</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'if statement: </span><span class="hljs-con-subst">{a </span><span class="hljs-con-keyword">if</span><span class="hljs-con-subst"> a &gt; b </span><span class="hljs-con-keyword">else</span><span class="hljs-con-subst"> b}</span><span class="hljs-con-string">'</span>&#13;
'if statement: 456'&#13;
&#13;
<span class="hljs-con-comment">## Function calls</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'min: </span><span class="hljs-con-subst">{</span><span class="hljs-con-built_in">min</span><span class="hljs-con-subst">(a, b)}</span><span class="hljs-con-string">'</span>&#13;
'min: 123'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'Hi </span><span class="hljs-con-subst">{username}</span><span class="hljs-con-string">. And in uppercase: </span><span class="hljs-con-subst">{username.upper()}</span><span class="hljs-con-string">'</span>&#13;
'Hi wolph. And in uppercase: WOLPH'&#13;
&#13;
<span class="hljs-con-comment">## Loops</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">f'Squares: </span><span class="hljs-con-subst">{[x ** </span><span class="hljs-con-number">2</span><span class="hljs-con-subst"> </span><span class="hljs-con-keyword">for</span><span class="hljs-con-subst"> x </span><span class="hljs-con-keyword">in</span><span class="hljs-con-subst"> </span><span class="hljs-con-built_in">range</span><span class="hljs-con-subst">(</span><span class="hljs-con-number">5</span><span class="hljs-con-subst">)]}</span><span class="hljs-con-string">'</span>&#13;
'Squares: [0, 1, 4, 9, 16]'&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-72" class="heading-2">PEP 20, the Zen of Python</h2>&#13;
    <p class="normal"><em class="italic">The Zen of Python</em>, as mentioned in the <em class="italic">A brief history of Python</em> section earlier, is about code that not only works, but is Pythonic. Pythonic code is readable, concise, and maintainable. PEP 20 <a id="_idIndexMarker125"/>says it best:</p>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“Long time Pythoneer Tim Peters succinctly channels the BDFL’s guiding principles for Python’s design into 20 aphorisms, only 19 of which have been written down.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">The next few paragraphs will explain the intentions of these 19 aphorisms with some example code.</p>&#13;
    <p class="normal">For clarity, let’s see these aphorisms before we begin:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> this&#13;
The Zen of Python, by Tim Peters&#13;
&#13;
Beautiful is better than ugly.&#13;
Explicit is better than implicit.&#13;
Simple is better than complex.&#13;
Complex is better than complicated.&#13;
Flat is better than nested.&#13;
Sparse is better than dense.&#13;
Readability counts.&#13;
Special cases aren't special enough to break the rules.&#13;
Although practicality beats purity.&#13;
Errors should never pass silently.&#13;
Unless explicitly silenced.&#13;
In the face of ambiguity, refuse the temptation to guess.&#13;
There should be one-- and preferably only one --obvious way to do it.&#13;
Although that way may not be obvious at first unless you're Dutch.&#13;
Now is better than never.&#13;
Although never is often better than *right* now.&#13;
If the implementation is hard to explain, it's a bad idea.&#13;
If the implementation is easy to explain, it may be a good idea.&#13;
Namespaces are one honking great idea -- let's do more of those!&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-73" class="heading-3">Beautiful is better than ugly</h3>&#13;
    <p class="normal">Beauty is subjective, of course, but there are still some<a id="_idIndexMarker126"/> style rules that are good to adhere to. Rules such as (from PEP 8):</p>&#13;
    <ul>&#13;
      <li class="bulletList">Indent using spaces instead of tabs</li>&#13;
      <li class="bulletList">Line length limits</li>&#13;
      <li class="bulletList">Each statement on a separate line</li>&#13;
      <li class="bulletList">Each import on a separate line</li>&#13;
    </ul>&#13;
    <p class="normal">When in doubt, always keep in mind that consistency is more important than fixed rules. If a project prefers to use tabs instead of spaces, or vice versa, it’s better to keep the tabs/spaces like that than to potentially break existing code (and revision control history) by replacing the tabs/spaces.</p>&#13;
    <p class="normal">In short, instead of <a id="_idIndexMarker127"/>hard-to-read code like this, which shows all odd numbers below 10:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> filter_modulo = <span class="hljs-con-keyword">lambda</span> i, m: (i[j] <span class="hljs-con-keyword">for</span> j <span class="hljs-con-keyword">in</span> \&#13;
<span class="hljs-con-meta">...</span>                               <span class="hljs-con-built_in">range</span>(<span class="hljs-con-built_in">len</span>(i)) <span class="hljs-con-keyword">if</span> i[j] % m)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(filter_modulo(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>), <span class="hljs-con-number">2</span>))&#13;
[1, 3, 5, 7, 9]&#13;
</code></pre>&#13;
    <p class="normal">I would prefer:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">filter_modulo</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items, modulo</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> item % modulo:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">yield</span> item&#13;
<span class="hljs-con-meta">...</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(filter_modulo(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>), <span class="hljs-con-number">2</span>))&#13;
[1, 3, 5, 7, 9]&#13;
</code></pre>&#13;
    <p class="normal">It is simpler, easier to read, and a bit more beautiful!</p>&#13;
    <div class="note">&#13;
      <p class="normal">These examples are an early introduction to generators. Generators will be discussed more thoroughly in <em class="chapterRef">Chapter 7</em>, <em class="italic">Generators and Coroutines – Infinity, One Step at a Time</em>.</p>&#13;
    </div>&#13;
    <h3 id="_idParaDest-74" class="heading-3">Explicit is better than implicit</h3>&#13;
    <p class="normal">Imports, arguments, and variable <a id="_idIndexMarker128"/>names are just some of the many cases where explicit code is far easier to read at the cost of a little bit more effort and/or verbosity when writing the code.</p>&#13;
    <p class="normal">Here is an example of how this can go wrong:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> os <span class="hljs-con-keyword">import</span> *&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> asyncio <span class="hljs-con-keyword">import</span> *&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">assert</span> wait&#13;
</code></pre>&#13;
    <p class="normal">Where does <code class="inlineCode">wait</code> come from, in this case? You might say that it’s obvious—it comes from <code class="inlineCode">os</code>. But you would be wrong, sometimes. On Windows, the <code class="inlineCode">os</code> module doesn’t have a <code class="inlineCode">wait</code> function, so it would be <code class="inlineCode">asyncio.wait</code> instead.</p>&#13;
    <p class="normal">It could be even worse: many editors and code clean-up tools have a sort-imports feature. If the sort order of your import changes, the behavior of your project will change.</p>&#13;
    <p class="normal">The immediate fix is simple enough:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> os <span class="hljs-con-keyword">import</span> path&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> asyncio <span class="hljs-con-keyword">import</span> wait&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">assert</span> wait&#13;
</code></pre>&#13;
    <p class="normal">With this <a id="_idIndexMarker129"/>method, we have at least a way to find out where <code class="inlineCode">wait</code> came from. But I would recommend going a step further and importing by module instead, so the executing code immediately shows which function is executed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> os&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">assert</span> asyncio.wait&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">assert</span> os.path&#13;
</code></pre>&#13;
    <p class="normal">The same can be said for <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code>. While they are very useful, they can make the usage of your functions and classes a lot less obvious:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">eggs, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> arg <span class="hljs-con-keyword">in</span> args:&#13;
<span class="hljs-con-meta">...</span>         eggs += arg&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> extra_egg <span class="hljs-con-keyword">in</span> kwargs.get(<span class="hljs-con-string">'extra_eggs'</span>, []):&#13;
<span class="hljs-con-meta">...</span>         eggs += extra_egg&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> eggs&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, extra_eggs=[<span class="hljs-con-number">4</span>, <span class="hljs-con-number">5</span>])&#13;
15&#13;
</code></pre>&#13;
    <p class="normal">Without looking at the code within the function, you cannot know what to pass as <code class="inlineCode">**kwargs</code> or what <code class="inlineCode">*args</code> does. A reasonable function name can help here, of course:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">sum_ints</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     total = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> arg <span class="hljs-con-keyword">in</span> args:&#13;
<span class="hljs-con-meta">...</span>         total += arg&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> total&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sum_ints(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">5</span>)&#13;
15&#13;
</code></pre>&#13;
    <p class="normal">Documentation <a id="_idIndexMarker130"/>can obviously help for cases like these, and I use <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code> very often, but it is definitely a good idea to keep at least the most common arguments explicit. Even when it requires you to repeat the arguments for a parent class, it just makes the code much clearer. When refactoring the parent class in the future, you’ll know whether there are subclasses that still use some parameters.</p>&#13;
    <h3 id="_idParaDest-75" class="heading-3">Simple is better than complex</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">”Simple is better than complex. Complex is better than complicated.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">Keeping things simple<a id="_idIndexMarker131"/> is often much harder than you would expect. Complexity has a tendency to creep up on you. You start with a beautiful little script and, before you know it, feature creep has turned it into a complex (or worse, complicated) mess:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> math&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">primes_complicated</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     sieved = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">...</span>     i = <span class="hljs-con-number">2</span>&#13;
<span class="hljs-con-meta">...</span>     &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">while</span> <span class="hljs-con-literal">True</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> i <span class="hljs-con-keyword">not</span> <span class="hljs-con-keyword">in</span> sieved:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">yield</span> i&#13;
<span class="hljs-con-meta">...</span>             sieved[i * i] = [i]&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">for</span> j <span class="hljs-con-keyword">in</span> sieved[i]:&#13;
<span class="hljs-con-meta">...</span>                 sieved.setdefault(i + j, []).append(j)&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">del</span> sieved[i]&#13;
<span class="hljs-con-meta">...</span>         &#13;
<span class="hljs-con-meta">...</span>         i += <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(primes_complicated(), <span class="hljs-con-number">10</span>))&#13;
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]&#13;
</code></pre>&#13;
    <p class="normal">At first glance, this code might look a bit difficult. If you’re familiar with the sieve of Eratosthenes however, you’ll quickly realize what is happening. With just a little bit of effort, you will see that the algorithm isn’t all that complicated but uses a few tricks to reduce the necessary computations.</p>&#13;
    <p class="normal">We can do better, however; let’s see <a id="_idIndexMarker132"/>a different example featuring the Python 3.8 assignment operator:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">primes_complex</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     numbers = itertools.count(<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">while</span> <span class="hljs-con-literal">True</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">yield</span> (prime := <span class="hljs-con-built_in">next</span>(numbers))&#13;
<span class="hljs-con-meta">...</span>         numbers = <span class="hljs-con-built_in">filter</span>(prime.__rmod__, numbers)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(primes_complex(), <span class="hljs-con-number">10</span>))&#13;
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]&#13;
</code></pre>&#13;
    <p class="normal">This algorithm looks a bit less intimidating, but I wouldn’t call it immediately obvious at first glance. The <code class="inlineCode">prime := next(numbers)</code> is the Python 3.8 version of setting a variable and immediately returning it in the same statement. The <code class="inlineCode">prime.__rmod__</code> does a modulo with the given number to sieve in a similar fashion to the previous example.</p>&#13;
    <p class="normal">What might be confusing, however, is that the <code class="inlineCode">numbers</code> variable is being reassigned with added filters on each iteration. Let’s see a better solution:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">is_prime</span><span class="hljs-con-function">(</span><span class="hljs-con-params">number</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> number == <span class="hljs-con-number">0</span> <span class="hljs-con-keyword">or</span> number == <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> modulo <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">2</span>, number):&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> <span class="hljs-con-keyword">not</span> number % modulo:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">primes_simple</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> itertools.count():&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> is_prime(i):&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">yield</span> i&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(itertools.islice(primes_simple(), <span class="hljs-con-number">10</span>))&#13;
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]&#13;
</code></pre>&#13;
    <p class="normal">Now we’ve come to one of the most obvious methods of generating prime numbers. The <code class="inlineCode">is_prime</code> function is really simple and immediately shows what <code class="inlineCode">is_prime</code> is doing. And the <code class="inlineCode">primes_simple</code> function is nothing more than a loop with a filter.</p>&#13;
    <p class="normal">Unless you have a really <a id="_idIndexMarker133"/>good reason to go for the complicated approach, try to keep your code as simple as you can. You (and perhaps someone else) will be grateful when reading your code in the future.</p>&#13;
    <h3 id="_idParaDest-76" class="heading-3">Flat is better than nested</h3>&#13;
    <p class="normal">Nested code<a id="_idIndexMarker134"/> quickly becomes unreadable and hard to understand. There are no strict rules here, but generally, when you have multiple levels of nested loops, it is time to refactor.</p>&#13;
    <p class="normal">Just take a look at the following example, which prints a list of two-dimensional matrices. While nothing specific is wrong here, splitting it into a few more functions might make it easier to understand the purpose and also make it easier to test:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">between_and_modulo</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value, a, b, modulo</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> value &gt;= a:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> value &lt;= b:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">if</span> value % modulo:&#13;
<span class="hljs-con-meta">...</span>                 <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> between_and_modulo(i, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">9</span>, <span class="hljs-con-number">2</span>):&#13;
<span class="hljs-con-meta">...</span>         print(i, end=<span class="hljs-con-string">' '</span>)&#13;
3 5 7 9&#13;
</code></pre>&#13;
    <p class="normal">Here’s the flatter version:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">between_and_modulo</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value, a, b, modulo</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> value &lt; a:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">elif</span> value &gt; b:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">elif</span> <span class="hljs-con-keyword">not</span> value % modulo:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> between_and_modulo(i, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">9</span>, <span class="hljs-con-number">2</span>):&#13;
<span class="hljs-con-meta">...</span>         print(i, end=<span class="hljs-con-string">' '</span>)&#13;
3 5 7 9&#13;
</code></pre>&#13;
    <p class="normal">This example <a id="_idIndexMarker135"/>might be a bit contrived, but the idea is sound. Deeply nested code can easily become very unreadable and splitting code into multiple lines or even functions can help readability a lot.</p>&#13;
    <h3 id="_idParaDest-77" class="heading-3">Sparse is better than dense</h3>&#13;
    <p class="normal">Whitespace is generally a <a id="_idIndexMarker136"/>good thing. Yes, it will make your files longer and your code will take up more space, but it can help a lot with readability if you split your code logically. Let’s take an example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> f=<span class="hljs-con-keyword">lambda</span> x:<span class="hljs-con-number">0</span>**x <span class="hljs-con-keyword">or</span> x*f(x-<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> f(<span class="hljs-con-number">40</span>)&#13;
815915283247897734345611269596115894272000000000&#13;
</code></pre>&#13;
    <p class="normal">By looking at the output and the code, you might be able to guess that this is the factorial function. But its workings are probably not immediately obvious. Let’s try rewriting:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">factorial</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> <span class="hljs-con-number">0</span> ** x:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> x * factorial(x - <span class="hljs-con-number">1</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> factorial(<span class="hljs-con-number">40</span>)&#13;
815915283247897734345611269596115894272000000000&#13;
</code></pre>&#13;
    <p class="normal">By using a proper name, expanding the <code class="inlineCode">if</code> statement, and explicitly returning <code class="inlineCode">1</code>, it is suddenly much more obvious what is happening.</p>&#13;
    <h3 id="_idParaDest-78" class="heading-3">Readability counts</h3>&#13;
    <p class="normal">Shorter does not always<a id="_idIndexMarker137"/> mean easier to read. Let’s take the Fibonacci numbers. There are many ways of writing this code, many of them hard to read:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> functools <span class="hljs-con-keyword">import</span> reduce&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib=<span class="hljs-con-keyword">lambda</span> n:n <span class="hljs-con-keyword">if</span> n&lt;<span class="hljs-con-number">2</span> <span class="hljs-con-keyword">else</span> fib(n-<span class="hljs-con-number">1</span>)+fib(n-<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib(<span class="hljs-con-number">10</span>)&#13;
55&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib=<span class="hljs-con-keyword">lambda</span> n:reduce(<span class="hljs-con-keyword">lambda</span> x,y:(x[<span class="hljs-con-number">0</span>]+x[<span class="hljs-con-number">1</span>],x[<span class="hljs-con-number">0</span>]),[(<span class="hljs-con-number">1</span>,<span class="hljs-con-number">1</span>)]*(n-<span class="hljs-con-number">1</span>))[<span class="hljs-con-number">0</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib(<span class="hljs-con-number">10</span>)&#13;
55&#13;
</code></pre>&#13;
    <p class="normal">Even though there is a <a id="_idIndexMarker138"/>kind of beauty and elegance in the solutions, they are not readable. With just a few minor changes, we can change these functions to more readable functions that function similarly:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fib</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> n &lt; <span class="hljs-con-number">2</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> n&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> fib(n - <span class="hljs-con-number">1</span>) + fib(n - <span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib(<span class="hljs-con-number">10</span>)&#13;
55&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fib</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     a = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span>     b = <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(n):&#13;
<span class="hljs-con-meta">...</span>         a, b = b, a + b&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> a&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fib(<span class="hljs-con-number">10</span>)&#13;
55&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-79" class="heading-3">Practicality beats purity</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">”Special cases aren’t special enough to break the rules. Although practicality beats purity.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">Breaking the rules can be <a id="_idIndexMarker139"/>tempting at times, but it’s a slippery slope. If your quick fix is going to break the rules, you should really try to refactor it immediately. Chances are that you won’t have the time to fix it later and will regret it.</p>&#13;
    <p class="normal">No need to go overboard, though. If the solution is good enough and refactoring would be much more work, then choosing the working method might be better. Even though all of these examples pertain to imports, this guideline applies to nearly all cases.</p>&#13;
    <p class="normal">To prevent long lines, imports can be made shorter by using a few methods, adding a backslash, adding parentheses, or just shortening the imports. I will illustrate some options next:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent.futures <span class="hljs-con-keyword">import</span> ProcessPoolExecutor, \&#13;
<span class="hljs-con-meta">...</span>     CancelledError, TimeoutError&#13;
</code></pre>&#13;
    <p class="normal">This case can easily be avoided by using parentheses:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent.futures <span class="hljs-con-keyword">import</span> (&#13;
<span class="hljs-con-meta">...</span>     ProcessPoolExecutor, CancelledError, TimeoutError) &#13;
</code></pre>&#13;
    <p class="normal">Or my personal preference, importing modules instead of the separate objects:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent <span class="hljs-con-keyword">import</span> futures&#13;
</code></pre>&#13;
    <p class="normal">But what about really long imports?</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent.futures.process <span class="hljs-con-keyword">import</span> \&#13;
<span class="hljs-con-meta">...</span>     ProcessPoolExecutor &#13;
</code></pre>&#13;
    <p class="normal">In that case, I would <a id="_idIndexMarker140"/>recommend using parentheses. If you need to split the imports across multiple lines, I would recommend one line per import for readability:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent.futures.process <span class="hljs-con-keyword">import</span> (&#13;
<span class="hljs-con-meta">...</span>     ProcessPoolExecutor&#13;
<span class="hljs-con-meta">...</span> )&#13;
&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> concurrent.futures <span class="hljs-con-keyword">import</span> (&#13;
<span class="hljs-con-meta">...</span>     ProcessPoolExecutor,&#13;
<span class="hljs-con-meta">...</span>     CancelledError,&#13;
<span class="hljs-con-meta">...</span>     TimeoutError,&#13;
<span class="hljs-con-meta">...</span> )&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-80" class="heading-3">Errors should never pass silently</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">”Errors should never pass silently. Unless explicitly silenced.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">Handling errors<a id="_idIndexMarker141"/> the right way is really difficult and there is no one method that works for every situation. There are, however, better and worse methods to catch errors.</p>&#13;
    <p class="normal">Bare or too-broad exception catching can be a quick way to make your life a bit more difficult in the case of bugs. Not passing exception info at all can make you (or some other person working on the code) wonder for ages about what is happening.</p>&#13;
    <p class="normal">To illustrate a bare exception, the worst option is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> some_user_input = <span class="hljs-con-string">'123abc'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">int</span>(some_user_input)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">A much better<a id="_idIndexMarker142"/> solution is to explicitly capture only the error you need:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> some_user_input = <span class="hljs-con-string">'123abc'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">int</span>(some_user_input)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> ValueError:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">Alternatively, if you really need to capture all exceptions, make sure to log them properly:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> logging&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_user_input = <span class="hljs-con-string">'123abc'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">int</span>(some_user_input)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> Exception <span class="hljs-con-keyword">as</span> exception:&#13;
<span class="hljs-con-meta">...</span>     logging.exception(<span class="hljs-con-string">'Uncaught: {exception!r}'</span>)&#13;
</code></pre>&#13;
    <p class="normal">When using multiple lines inside a <code class="inlineCode">try</code> block, the issue of tracing bugs is aggravated even further because there is even more code that could be responsible for the hidden exception. The tracing of bugs also becomes much more difficult when the <code class="inlineCode">except</code> is accidently capturing exceptions from functions a few levels deep. For example, consider the following code block:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> some_user_input_a = <span class="hljs-con-string">'123'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_user_input_b = <span class="hljs-con-string">'abc'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">int</span>(some_user_input_a)&#13;
<span class="hljs-con-meta">...</span>     value += <span class="hljs-con-built_in">int</span>(some_user_input_b)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span>:&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-number">0</span> &#13;
</code></pre>&#13;
    <p class="normal">If an exception is raised, which line is causing it? With silent catching of the error, there is no way to know without running the code in a debugger. The exception could even be caused a few levels deeper in the code if, instead of <code class="inlineCode">int()</code>, you are using a more complex function.</p>&#13;
    <p class="normal">If you are testing for a specific exception in a specific block of code, the safer method is using the <code class="inlineCode">else</code> in the <code class="inlineCode">try</code>/<code class="inlineCode">except</code>. The <code class="inlineCode">else</code> is only executed if there was no exception.</p>&#13;
    <p class="normal">To illustrate the full<a id="_idIndexMarker143"/> strength of the <code class="inlineCode">try</code>/<code class="inlineCode">except:</code>, here is an example of all variants including the <code class="inlineCode">else</code>, <code class="inlineCode">finally</code>, and <code class="inlineCode">BaseException</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-number">1</span> / <span class="hljs-con-number">0</span>  <span class="hljs-con-comment"># Raises ZeroDivisionError</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> ZeroDivisionError:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Got zero division error'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> Exception <span class="hljs-con-keyword">as</span> exception:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Got unexpected exception: </span><span class="hljs-con-subst">{exception}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> BaseException <span class="hljs-con-keyword">as</span> exception:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Base exceptions are a special case for keyboard</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># interrupts and a few other exceptions that are not</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># technically errors.</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Got base exception: </span><span class="hljs-con-subst">{exception}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'No exceptions happened, we can continue'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">finally</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Useful cleanup functions such as closing a file</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'This code is _always_ executed'</span>)&#13;
Got zero division error&#13;
This code is _always_ executed&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-81" class="heading-3">In the face of ambiguity, refuse the temptation to guess</h3>&#13;
    <p class="normal">While guesses will work in many cases, they can bite you if you’re not careful. As already demonstrated in the <em class="italic">Explicit is better than implicit</em> section, when you have a few <code class="inlineCode">from ... import *</code>, you cannot always be certain which module is providing you with the variable you were expecting.</p>&#13;
    <p class="normal">Clear and unambiguous<a id="_idIndexMarker144"/> code generates fewer bugs so it’s always a good idea to think about what happens when someone else reads your code. A prime example of ambiguity is function calling. Take, for example, the following two function calls:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> fh_a = <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'spam'</span>, <span class="hljs-con-string">'w'</span>, -<span class="hljs-con-number">1</span>, <span class="hljs-con-literal">None</span>, <span class="hljs-con-literal">None</span>, <span class="hljs-con-string">'\n'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fh_b = <span class="hljs-con-built_in">open</span>(file=<span class="hljs-con-string">'spam'</span>, mode=<span class="hljs-con-string">'w'</span>, buffering=-<span class="hljs-con-number">1</span>, newline=<span class="hljs-con-string">'\n'</span>) &#13;
</code></pre>&#13;
    <p class="normal">These two calls have the exact same result. However, it’s obvious in the second call that the <code class="inlineCode">-1</code> is configuring the buffer. You probably know the first two arguments of <code class="inlineCode">open()</code> by heart but the others are less common.</p>&#13;
    <p class="normal">Regardless, without seeing <code class="inlineCode">help(open)</code> or viewing the documentation in another manner, it’s impossible to say whether the two are identical.</p>&#13;
    <p class="normal">Note that I don’t think <a id="_idIndexMarker145"/>you should use keyword arguments in all cases, but if there are many arguments involved and/or hard-to-identify parameters (such as numbers), it can be a good idea. A good alternative is using good variable names, which make the function call a lot more obvious:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> filename = <span class="hljs-con-string">'spam'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> mode = <span class="hljs-con-string">'w'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> buffers = -<span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fh_b = <span class="hljs-con-built_in">open</span>(filename, mode, buffers, newline=<span class="hljs-con-string">'\n'</span>)&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-82" class="heading-3">One obvious way to do it</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“There should be one—and preferably only one—obvious way to do it. Although that way may not be obvious at first unless you’re Dutch.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">In general, after thinking about a difficult problem for a while, you will find that there is one solution that is clearly preferable over the alternatives. There are times where this is not the case, however, and in such instances, it can be useful if you’re Dutch. The joke here is that Guido van Rossum, the original author of Python, is Dutch (as am I) and that only Guido knows the obvious way in some cases.</p>&#13;
    <p class="normal">The other joke is that the Perl programming language slogan is the opposite: “There’s more than one way to do it.”</p>&#13;
    <p class="normal">Now is better than never</p>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“Now is better than never. Although never is often better than *right* now.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">It’s better to fix a problem right now than push it into the future. There are cases, however, where fixing it right away is not an option. In those cases, a good alternative can be to mark a function as deprecated instead so that there is no chance of accidentally forgetting the problem:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> warnings&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> warnings.warn(<span class="hljs-con-string">'Something deprecated'</span>, DeprecationWarning)&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-83" class="heading-3">Hard to explain, easy to explain</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">As always, keep things as simple as you can. While complicated code can be nice to test with, it is more prone to bugs. The simpler you can keep things, the better.</p>&#13;
    <h3 id="_idParaDest-84" class="heading-3">Namespaces are one honking great idea</h3>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“Namespaces are one honking great idea—let’s do more of those!”</p>&#13;
    </blockquote>&#13;
    <p class="normal">Namespaces<a id="_idIndexMarker146"/> can make code a lot clearer to use. Naming them properly makes it even better. For example, assume the <code class="inlineCode">import</code> isn’t on your screen in a larger file. What does the <code class="inlineCode">loads</code> line do?</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> json <span class="hljs-con-keyword">import</span> loads&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> loads(<span class="hljs-con-string">'{}'</span>)&#13;
{}&#13;
</code></pre>&#13;
    <p class="normal">Now let’s take the version with the namespace:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> json&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> json.loads(<span class="hljs-con-string">'{}'</span>)&#13;
{}&#13;
</code></pre>&#13;
    <p class="normal">Now it is obvious that <code class="inlineCode">loads()</code> is the <code class="inlineCode">json</code> loader and not any other type of loader.</p>&#13;
    <p class="normal">Namespace shortcuts are still useful, though. Let’s look at the <code class="inlineCode">User</code> class in Django, which is used in nearly every Django project. The <code class="inlineCode">User</code> class is stored in <code class="inlineCode">django.contrib.auth.models.User</code> by default (can be overridden). Many projects use the object in the following way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">from django.contrib.auth.models import User&#13;
<span class="hljs-con-comment"># Use it as: User</span>&#13;
</code></pre>&#13;
    <p class="normal">While this is <a id="_idIndexMarker147"/>fairly clear, projects might be using multiple classes named <code class="inlineCode">User</code>, which obscures the import. Also, it might make someone think that the <code class="inlineCode">User</code> class is local to the current class. Doing the following instead lets people know that it is in a different module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">from django.contrib.auth import models&#13;
<span class="hljs-con-comment"># Use it as: models.User</span>&#13;
</code></pre>&#13;
    <p class="normal">This quickly clashes with other models’ imports, though, so I personally use the following instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">from django.contrib.auth import models as auth_models&#13;
<span class="hljs-con-comment"># Use it as auth_models.User</span>&#13;
</code></pre>&#13;
    <p class="normal">Or the shorter version:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">import django.contrib.auth.models as auth_models&#13;
<span class="hljs-con-comment"># Use it as auth_models.User</span>&#13;
</code></pre>&#13;
    <p class="normal">Now you should<a id="_idIndexMarker148"/> have some idea of what the Pythonic ideology is about—creating code that is:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Beautiful</li>&#13;
      <li class="bulletList">Readable</li>&#13;
      <li class="bulletList">Unambiguous</li>&#13;
      <li class="bulletList">Explicit enough</li>&#13;
      <li class="bulletList">Not completely void of whitespace</li>&#13;
    </ul>&#13;
    <p class="normal">So let’s move on to some more examples of how to create beautiful, readable, and simple code using the Python style guide.</p>&#13;
    <h2 id="_idParaDest-85" class="heading-2">Explaining PEP 8</h2>&#13;
    <p class="normal">The previous sections have already shown a lot of examples of using PEP 20 as a reference, but there are a few<a id="_idIndexMarker149"/> other important guidelines to note as well. The PEP 8 style guide specifies the standard Python coding conventions. </p>&#13;
    <p class="normal">Simply following the PEP 8 standard doesn’t make your code Pythonic, though, but it is most certainly a good start. Which style you use is really not that much of a concern as long as you are consistent. The only thing worse than not using a proper style guide is being inconsistent with it.</p>&#13;
    <h3 id="_idParaDest-86" class="heading-3">Duck typing</h3>&#13;
    <p class="normal">Duck typing is a <a id="_idIndexMarker150"/>method of handling variables by behavior. To quote Alex Martelli (one of my Python heroes, also nicknamed the MartelliBot by many):</p>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote">“Don’t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what subset of duck-like behavior you need to play your language-games with. If the argument fails this specific-ducklyhood-subset-test, then you can shrug, ask “why a duck?”</p>&#13;
    </blockquote>&#13;
    <p class="normal">In many cases, when people make a comparison such as <code class="inlineCode">if spam != '':</code>, they are actually just looking for anything that is considered a true value. While you can compare the value to the string value <code class="inlineCode">''</code>, you generally don’t have to make it so specific. In many cases, simply doing <code class="inlineCode">if spam:</code> is more than enough and actually functions better.</p>&#13;
    <p class="normal">For example, the following lines of code use the value of <code class="inlineCode">timestamp</code> to generate a filename:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> timestamp = <span class="hljs-con-number">12345</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> filename = <span class="hljs-con-string">f'</span><span class="hljs-con-subst">{timestamp}</span><span class="hljs-con-string">.csv'</span>&#13;
</code></pre>&#13;
    <p class="normal">Because the variable is named <code class="inlineCode">timestamp</code>, you might be tempted to check whether it is actually a <code class="inlineCode">date</code> or <code class="inlineCode">datetime</code> object, like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> datetime&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> timestamp = <span class="hljs-con-number">12345</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">isinstance</span>(timestamp, datetime.datetime):&#13;
<span class="hljs-con-meta">...</span>     filename = <span class="hljs-con-string">f'</span><span class="hljs-con-subst">{timestamp}</span><span class="hljs-con-string">.csv'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">raise</span> TypeError(<span class="hljs-con-string">f'</span><span class="hljs-con-subst">{timestamp}</span><span class="hljs-con-string"> is not a valid datetime'</span>)&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
TypeError: 12345 is not a valid datetime&#13;
</code></pre>&#13;
    <p class="normal">While this is not inherently wrong, comparing types is considered a bad practice in Python, as there is often no need.</p>&#13;
    <p class="normal">In Python, the commonly used style is<a id="_idIndexMarker151"/> <strong class="keyWord">EAFP</strong> (<strong class="keyWord">easier to ask for forgiveness than permission</strong>: <a href="https://docs.python.org/3/glossary.html#term-eafp"><span class="url">https://docs.python.org/3/glossary.html#term-eafp</span></a>), which assumes no errors but catches them if needed. Within the Python interpreter, a <code class="inlineCode">try</code>/<code class="inlineCode">except</code> block is extremely efficient if no exception is raised. Actually catching an exception is expensive, however, so this approach is mainly recommended when you don’t expect the <code class="inlineCode">try</code> to fail often.</p>&#13;
    <p class="normal">The opposite of EAFP is<a id="_idIndexMarker152"/> <strong class="keyWord">LBYL</strong> (<strong class="keyWord">look before you leap</strong>: <a href="https://docs.python.org/3/glossary.html#term-lbyl"><span class="url">https://docs.python.org/3/glossary.html#term-lbyl</span></a>), which tests for pre-conditions before other calls or lookups are made. The notable downside of this method is the potential for race conditions in multi-threaded environments. While you are checking for the existence of a key in a <code class="inlineCode">dict</code>, another thread may have removed it already.</p>&#13;
    <p class="normal">That’s why in <a id="_idIndexMarker153"/>Python, duck typing is often preferred. Just test the variable for the features you need and don’t worry about the actual type. To illustrate how little difference this can make to the end result, see the following code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> datetime&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> timestamp = datetime.date(<span class="hljs-con-number">2000</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> filename = <span class="hljs-con-string">f'</span><span class="hljs-con-subst">{timestamp}</span><span class="hljs-con-string">.csv'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(<span class="hljs-con-string">f'Filename from date: </span><span class="hljs-con-subst">{filename}</span><span class="hljs-con-string">'</span>)&#13;
Filename from date: 2000-10-05.csv&#13;
</code></pre>&#13;
    <p class="normal">Versus a string instead of a <code class="inlineCode">date</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> timestamp = <span class="hljs-con-string">'2000-10-05'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> filename = <span class="hljs-con-string">f'</span><span class="hljs-con-subst">{timestamp}</span><span class="hljs-con-string">.csv'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(<span class="hljs-con-string">f'Filename from str: </span><span class="hljs-con-subst">{filename}</span><span class="hljs-con-string">'</span>)&#13;
Filename from str: 2000-10-05.csv&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the result is identical.</p>&#13;
    <p class="normal">The same goes for converting a number to a float or an integer; instead of enforcing a certain type, just require certain features. Need something that can pass as a number? Just try to convert to <code class="inlineCode">int</code> or <code class="inlineCode">float</code>. Need a <code class="inlineCode">file</code> object? Why not just check whether there is a <code class="inlineCode">read</code> method with <code class="inlineCode">hasattr</code>?</p>&#13;
    <h3 id="_idParaDest-87" class="heading-3">Differences between value and identity comparisons</h3>&#13;
    <p class="normal">There are many methods of comparing objects in Python: greater than, bitwise operators, equal, etc., but there is one comparator that is special: the identity comparison operator. Instead of using <code class="inlineCode">if spam == eggs</code>, you would use <code class="inlineCode">if spam is eggs</code>. The first compares the <a id="_idIndexMarker154"/>value and the second compares the<a id="_idIndexMarker155"/> identity or <strong class="keyWord">memory address</strong>. Because it only compares the memory address, it’s one of the lightest and strictest lookups you can get. Whereas a value check needs to make sure that the types are comparable and perhaps check the sub-values, the identity check just checks whether the unique identifier is the same.</p>&#13;
    <div class="note">&#13;
      <p class="normal">If you’ve ever written Java, you should be familiar with this principle. In Java, a regular string comparison (<code class="inlineCode">spam == eggs</code>) will use the identity instead of the value. To compare the value, you need to use <code class="inlineCode">spam.equals(eggs)</code> to get the correct results.</p>&#13;
    </div>&#13;
    <p class="normal">These comparisons are recommended to be used when the identity of the object is expected to be constant. One obvious example of this is a comparison with <code class="inlineCode">True</code>, <code class="inlineCode">False</code>, or <code class="inlineCode">None</code>. To demonstrate this behavior, let’s look at values that evaluate to <code class="inlineCode">True</code> or <code class="inlineCode">False</code> when comparing by value, but are actually different:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a == <span class="hljs-con-literal">True</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a <span class="hljs-con-keyword">is</span> <span class="hljs-con-literal">True</span>&#13;
False&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b == <span class="hljs-con-literal">False</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b <span class="hljs-con-keyword">is</span> <span class="hljs-con-literal">False</span>&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">Similarly, you need to be careful with <code class="inlineCode">if</code> statements and <code class="inlineCode">None</code> values, which is a common pattern with default function arguments:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_unsafe_function</span><span class="hljs-con-function">(</span><span class="hljs-con-params">arg=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> <span class="hljs-con-keyword">not</span> arg:&#13;
<span class="hljs-con-meta">...</span>         arg = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> arg&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_unsafe_function(<span class="hljs-con-number">0</span>)&#13;
123&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_unsafe_function(<span class="hljs-con-literal">None</span>)&#13;
123&#13;
</code></pre>&#13;
    <p class="normal">The second one indeed needed the default argument, but the first one had an actual value that should have been used:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_safe_function</span><span class="hljs-con-function">(</span><span class="hljs-con-params">arg=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> arg <span class="hljs-con-keyword">is</span> <span class="hljs-con-literal">None</span>:&#13;
<span class="hljs-con-meta">...</span>         arg = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> arg&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_safe_function(<span class="hljs-con-number">0</span>)&#13;
0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_safe_function(<span class="hljs-con-literal">None</span>)&#13;
123&#13;
</code></pre>&#13;
    <p class="normal">Now we actually get the value that we passed along because we used an identity instead of a value check for <code class="inlineCode">arg</code>.</p>&#13;
    <p class="normal">There are a few gotchas with<a id="_idIndexMarker156"/> the identities, though. Let’s look at an example that doesn’t make any sense:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-number">200</span> + <span class="hljs-con-number">56</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-number">256</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c = <span class="hljs-con-number">200</span> + <span class="hljs-con-number">57</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> d = <span class="hljs-con-number">257</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a == b&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a <span class="hljs-con-keyword">is</span> b&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c == d&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c <span class="hljs-con-keyword">is</span> d&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">While the values are the same, the identities are different. The catch is that Python keeps an internal array of integer objects for all integers between <code class="inlineCode">-5</code> and <code class="inlineCode">256</code>; that’s why it works for <code class="inlineCode">256</code> but not for <code class="inlineCode">257</code>.</p>&#13;
    <p class="normal">To look at what Python is actually doing internally with the <code class="inlineCode">is</code> operator, you can use the <code class="inlineCode">id</code> function. When executing <code class="inlineCode">if spam is eggs</code>, Python will execute the equivalent of <code class="inlineCode">if id(spam) == id(eggs)</code> internally and <code class="inlineCode">id()</code> (at least for CPython) returns the memory address.</p>&#13;
    <h3 id="_idParaDest-88" class="heading-3">Loops</h3>&#13;
    <p class="normal">Coming from other<a id="_idIndexMarker157"/> languages, one might be tempted to use <code class="inlineCode">for</code> loops or <code class="inlineCode">while</code> loops with counters to process the items of a <code class="inlineCode">list</code>, <code class="inlineCode">tuple</code>, <code class="inlineCode">str</code>, and so on. While valid, it is more complex than needed. For example, consider this code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> my_range = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> i = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">while</span> i &lt; <span class="hljs-con-built_in">len</span>(my_range ):&#13;
<span class="hljs-con-meta">...</span>     item = my_range [i]&#13;
<span class="hljs-con-meta">...</span>     print(i, item, end=<span class="hljs-con-string">', '</span>)&#13;
<span class="hljs-con-meta">...</span>     i += <span class="hljs-con-number">1</span>&#13;
0 0, 1 1, 2 2, 3 3, 4 4,&#13;
</code></pre>&#13;
    <p class="normal">Within Python, there is no need to build a custom loop: you can simply loop the iterable object instead. Although enumerating including a counter is easily possible too:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> my_range  = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> my_range :&#13;
<span class="hljs-con-meta">...</span>     print(item, end=<span class="hljs-con-string">', '</span>)&#13;
0, 1, 2, 3, 4,&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i, item <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">enumerate</span>(my_range ):&#13;
<span class="hljs-con-meta">...</span>     print(i, item, end=<span class="hljs-con-string">', '</span>)&#13;
0 0, 1 1, 2 2, 3 3, 4 4,&#13;
</code></pre>&#13;
    <p class="normal">This can be written even shorter, of course (albeit not 100% identically, since we’re not using <code class="inlineCode">print</code>), but I wouldn’t recommend that for the sake of readability in most cases:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> my_range  = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [(i, item) <span class="hljs-con-keyword">for</span> i, item <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">enumerate</span>(my_range)]&#13;
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] &#13;
</code></pre>&#13;
    <p class="normal">The last option <a id="_idIndexMarker158"/>might be clear to some but not all. A common recommendation is to limit the usage of <code class="inlineCode">list</code>/<code class="inlineCode">dict</code>/<code class="inlineCode">set</code> comprehensions and <code class="inlineCode">map</code>/<code class="inlineCode">filter</code> statements to cases where the entire statement fits on a single line.</p>&#13;
    <h3 id="_idParaDest-89" class="heading-3">Maximum line length</h3>&#13;
    <p class="normal">Many Python programmers think 79 characters is too constricting and just keep the lines longer. While I am not going to argue for 79 characters specifically, setting a low limit is a good idea so you can easily keep multiple editors side by side. I often have four Python files open next to each other. If the line width were more than 79 characters, that simply wouldn’t fit.</p>&#13;
    <p class="normal">PEP 8 tells us to use <a id="_idIndexMarker159"/>backslashes in cases where lines get too long. While I agree that backslashes are preferable over long lines, I still think they should be avoided, if possible, since they easily generate syntax errors when manipulating code by copying/pasting and rearranging. Here’s an example from PEP 8:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">with open('/path/to/some/file/you/want/to/read') as file_1, \&#13;
        open('/path/to/some/file/being/written', 'w') as file_2:&#13;
    file_2.write(file_1.read())&#13;
</code></pre>&#13;
    <p class="normal">Instead of using backslashes, I would reformat the code by introducing extra variables so all lines are easy to read:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">filename_1 = '/path/to/some/file/you/want/to/read'&#13;
filename_2 = '/path/to/some/file/being/written'&#13;
with open(filename_1) as file_1, open(filename_2, 'w') as file_2:&#13;
    file_2.write(file_1.read())&#13;
</code></pre>&#13;
    <p class="normal">Or in this specific case of filenames, by using <code class="inlineCode">pathlib</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">import pathlib&#13;
filename_1 = pathlib.Path('/path/to/some/file/you/want/to/read')&#13;
filename_2 = pathlib.Path('/path/to/some/file/being/written')&#13;
with filename_1.open() as file_1, filename_2.open('w') as file_2:&#13;
    file_2.write(file_1.read())&#13;
</code></pre>&#13;
    <p class="normal">This is not always an <a id="_idIndexMarker160"/>option, of course, but it’s a good consideration to keep the code short and readable. It actually provides a bonus of adding more information to the code. If, instead of <code class="inlineCode">filename_1</code>, you use a name that conveys the goal of the filename, it immediately becomes clearer what you are trying to do.</p>&#13;
    <h2 id="_idParaDest-90" class="heading-2">Verifying code quality, pep8, pyflakes, and more</h2>&#13;
    <p class="normal">There are many tools for <a id="_idIndexMarker161"/>checking code quality and style in Python. The options range from <code class="inlineCode">pycodestyle</code> (previously named <code class="inlineCode">pep8</code>) for checking rules pertaining to PEP 8, to tools such as <code class="inlineCode">flake8</code>, which bundles a lot of tools and can help refactor code and track down bugs in code that appears to work.</p>&#13;
    <p class="normal">Let’s go into more detail.</p>&#13;
    <h4 class="heading-4">pycodestyle/pep8</h4>&#13;
    <p class="normal">The <code class="inlineCode">pycodestyle</code> package (previously named <code class="inlineCode">pep8</code>) is the default code style checker to start with. The <code class="inlineCode">pycodestyle</code> checker<a id="_idIndexMarker162"/> attempts to validate many of the rules suggested in PEP 8 that are considered to be the standard by the community. It doesn’t check everything that is in the PEP 8 standard, but it goes a long way and is still updated regularly to add new checks. Some of the most important things checked by <code class="inlineCode">pycodestyle</code> are as follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Indentation: While Python will not check how many spaces you use to indent, it does not help with the readability of your code</li>&#13;
      <li class="bulletList">Missing whitespace, such as <code class="inlineCode">spam=123</code></li>&#13;
      <li class="bulletList">Too much whitespace, such as <code class="inlineCode">def eggs(spam = 123):</code></li>&#13;
      <li class="bulletList">Too many or too few blank lines</li>&#13;
      <li class="bulletList">Too long lines</li>&#13;
      <li class="bulletList">Syntax and indentation errors</li>&#13;
      <li class="bulletList">Incorrect and/or superfluous comparisons (<code class="inlineCode">not in</code>, <code class="inlineCode">is not</code>, <code class="inlineCode">if spam is True</code>, and type comparisons without <code class="inlineCode">isinstance</code>)</li>&#13;
    </ul>&#13;
    <p class="normal">If some of the specific rules are not to your liking, you can easily tweak them to fit your purpose. Beyond that, the tool is not too opinionated, which makes it an ideal starting point for any Python project.</p>&#13;
    <div class="note">&#13;
      <p class="normal">An honorable mention goes out to the <code class="inlineCode">black</code> project, which is a Python formatter that automatically formats your code to largely adhere to the PEP 8 style. The name <code class="inlineCode">black</code> stems from Henry Ford’s quote: “Any customer can have a car painted any color that he wants so long as it is black.”</p>&#13;
      <p class="normal">That immediately shows the downside of <code class="inlineCode">black</code>: it offers very little in the way of customization. If you don’t like one of the rules, you are most likely out of luck.</p>&#13;
    </div>&#13;
    <h4 class="heading-4">pyflakes</h4>&#13;
    <p class="normal">The <code class="inlineCode">pyflakes</code> checker<a id="_idIndexMarker163"/> is meant to detect errors and potential bugs in your code by parsing (not importing) the code. This makes it ideal for editor integration, but it can also be used to warn you about potential issues in your code beyond that. It will warn you about:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Unused imports</li>&#13;
      <li class="bulletList">Wildcard imports (<code class="inlineCode">from module import *</code>)</li>&#13;
      <li class="bulletList">Incorrect <code class="inlineCode">__future__</code> imports (after other imports)</li>&#13;
    </ul>&#13;
    <p class="normal">More importantly, it warns you about potential bugs, such as the following:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Redefinitions of names that were imported</li>&#13;
      <li class="bulletList">Usage of undefined variables</li>&#13;
      <li class="bulletList">Referencing variables before assignment</li>&#13;
      <li class="bulletList">Duplicate argument names</li>&#13;
      <li class="bulletList">Unused local variables</li>&#13;
    </ul>&#13;
    <h4 class="heading-4">pep8-naming</h4>&#13;
    <p class="normal">The last bit of PEP 8 is <a id="_idIndexMarker164"/>covered by the <code class="inlineCode">pep8-naming</code> package. It makes sure that your naming is close to the standard dictated by PEP 8:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Class names as <code class="inlineCode">CapWord</code></li>&#13;
      <li class="bulletList">Function, variable, and argument names all in lowercase</li>&#13;
      <li class="bulletList">Constants as full uppercase and being treated as constants</li>&#13;
      <li class="bulletList">The first argument of instance methods and class methods as <code class="inlineCode">self</code> and <code class="inlineCode">cls</code>, respectively</li>&#13;
    </ul>&#13;
    <h4 class="heading-4">McCabe</h4>&#13;
    <p class="normal">Lastly, there is the McCabe<a id="_idIndexMarker165"/> complexity. It checks the complexity of code by looking at the <strong class="keyWord">Abstract Syntax Tree</strong> (<strong class="keyWord">AST</strong>), which <a id="_idIndexMarker166"/>Python builds from the source code internally. It finds out how many lines, levels, and statements are there and warns you if your code has more complexity than a preconfigured threshold. Generally, you will use McCabe through <code class="inlineCode">flake8</code>, but a manual call is possible as well. Using the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">noop</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">yield_cube_points</span><span class="hljs-function">(</span><span class="hljs-params">matrix</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> matrix:&#13;
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> x:&#13;
            <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> y:&#13;
                <span class="hljs-keyword">yield</span> (x, y, z)&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">print_cube</span><span class="hljs-function">(</span><span class="hljs-params">matrix</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> matrix:&#13;
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> x:&#13;
            <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> y:&#13;
                print(z, end=<span class="hljs-string">''</span>)&#13;
            print()&#13;
        print()&#13;
</code></pre>&#13;
    <p class="normal">McCabe<a id="_idIndexMarker167"/> will give us the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install mccabe&#13;
...&#13;
<span class="hljs-con-meta">$</span> python3 -m mccabe T_16_mccabe.py&#13;
1:0: 'noop' 1&#13;
5:0: 'yield_cube_points' 4&#13;
12:0: 'print_cube' 4&#13;
</code></pre>&#13;
    <p class="normal">At first, when you look at the <code class="inlineCode">1</code> generated by <code class="inlineCode">noop</code>, you might think <code class="inlineCode">mccabe</code> counts the lines of code. Upon further inspection, you can see this isn’t the case. Having multiple <code class="inlineCode">noop</code> operators does not increase the count and nor do the <code class="inlineCode">print</code> statements in the <code class="inlineCode">print_cube</code> function.</p>&#13;
    <p class="normal">The <code class="inlineCode">mccabe</code> tool checks the cyclomatic complexity of code. In a nutshell, this means that it counts the number of possible execution paths. Code without any control flow statements such as <code class="inlineCode">if</code>/<code class="inlineCode">for</code>/<code class="inlineCode">while</code> counts as 1, as you can see in the <code class="inlineCode">noop</code> function. A simple <code class="inlineCode">if</code> or <code class="inlineCode">if</code>/<code class="inlineCode">else</code> results in two options: one where the <code class="inlineCode">if</code> statement is <code class="inlineCode">True</code> and one where the <code class="inlineCode">if</code> statement is <code class="inlineCode">False</code>. If there is a nested <code class="inlineCode">if</code> or an <code class="inlineCode">elif</code>, this would increase further. Loops count as 2 since there is the flow of going inside the loop if there are items, and not going into the loop if there are no items.</p>&#13;
    <p class="normal">The warning <a id="_idIndexMarker168"/>threshold for <code class="inlineCode">mccabe</code> is set to 10 by default, but is configurable. If your code actually has a score of more than 10, it is time for some refactoring. Remember the advice from PEP 20.</p>&#13;
    <h4 class="heading-4">Mypy</h4>&#13;
    <p class="normal">Mypy is a <a id="_idIndexMarker169"/>tool used to check the variable types within your code. While specifying fixed types goes against duck typing, there are certainly cases where this is useful and where it will protect you from bugs.</p>&#13;
    <p class="normal">Taking the following code, for example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">some_number: <span class="hljs-built_in">int</span>&#13;
some_number = <span class="hljs-string">'</span><span class="hljs-string">test'</span>&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">mypy</code> command will tell us we’ve made a mistake:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> mypy T_17_mypy.py&#13;
T_17_mypy.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")&#13;
Found 1 error in 1 file (checked 1 source file)&#13;
</code></pre>&#13;
    <p class="normal">Note that this syntax depends on the type hinting introduced in Python 3.5. For older Python versions, you can use comments for type hints instead:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">some_number = <span class="hljs-string">'test'</span>  <span class="hljs-comment"># type: int</span>&#13;
</code></pre>&#13;
    <p class="normal">Even if you’re not using code hinting in your own code, this can still be useful to check whether your calls to external libraries are correct. If the arguments for a function of an external library changed with an update, this can quickly tell you something is wrong at the location of the mistake instead of having to trace a bug throughout your code.</p>&#13;
    <h4 class="heading-4">flake8</h4>&#13;
    <p class="normal">To run all of these tests combined, you can<a id="_idIndexMarker170"/> use <code class="inlineCode">flake8</code>, a tool that runs <code class="inlineCode">pycodestyle</code>, <code class="inlineCode">pyflakes</code>, and <code class="inlineCode">mccabe</code> by default. After running these commands, <code class="inlineCode">flake8</code> combines their outputs into a single report. Some of the warnings generated by <code class="inlineCode">flake8</code> might not fit your taste, so each and every one of the checks can be disabled, both per file and for the entire project if needed. For example, I personally disable <code class="inlineCode">W391</code> for all my projects, which warns you about blank lines at the end of a file. </p>&#13;
    <p class="normal">This is something I find useful while working on code so that I can easily jump to the end of the file and start writing code instead of having to append a few lines first.</p>&#13;
    <p class="normal">There are also many <a id="_idIndexMarker171"/>plugins available to make <code class="inlineCode">flake8</code> even more powerful.</p>&#13;
    <p class="normal">Some example plugins are:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">pep8-naming</code>: Tests <a id="_idIndexMarker172"/>PEP naming conventions</li>&#13;
      <li class="bulletList"><code class="inlineCode">flake8-docstrings</code>: Tests<a id="_idIndexMarker173"/> whether docstrings follow the PEP 257, NumPy, or Google convention. More about these conventions will be in the chapter about documentation.</li>&#13;
      <li class="bulletList"><code class="inlineCode">flake8-bugbear</code>: Finds <a id="_idIndexMarker174"/>likely bugs and design problems in your code, such as bare excepts.</li>&#13;
      <li class="bulletList"><code class="inlineCode">flake8-mypy</code>: Tests<a id="_idIndexMarker175"/> whether the types of values are consistent with the declared types.</li>&#13;
    </ul>&#13;
    <p class="normal">In general, before committing your code and/or putting it online, just run <code class="inlineCode">flake8</code> from your source directory to check everything recursively.</p>&#13;
    <p class="normal">Here is a demonstration with some poorly formatted code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">spam</span><span class="hljs-function">(</span><span class="hljs-params">a,b,c</span><span class="hljs-function">):</span>print(a,b+c)&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">eggs</span><span class="hljs-function">():</span><span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">It results in the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install flake8&#13;
...&#13;
<span class="hljs-con-meta">$</span> flake8 T_18_flake8.py&#13;
T_18_flake8.py:1:11: E231 missing whitespace after ','&#13;
T_18_flake8.py:1:13: E231 missing whitespace after ','&#13;
T_18_flake8.py:1:16: E231 missing whitespace after ':'&#13;
T_18_flake8.py:1:24: E231 missing whitespace after ','&#13;
T_18_flake8.py:2:11: E231 missing whitespace after ':'&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-91" class="heading-2">Recent additions to the Python syntax</h2>&#13;
    <p class="normal">The Python syntax has<a id="_idIndexMarker176"/> remained largely unchanged in the last decade, but we have seen a few additions, such as the f-strings, type hinting, and async functions, of course. We already covered f-strings at the beginning of this chapter, and the other two are covered by <em class="chapterRef">Chapter 9</em> and <em class="chapterRef">Chapter 13</em>, respectively, but there have a been a few other recent additions to the Python syntax that you might have missed. Additionally, in <em class="chapterRef">Chapter 4</em> you will see the dictionary merge operators added in Python 3.9.</p>&#13;
    <h3 id="_idParaDest-92" class="heading-3">PEP 572: Assignment expressions/the walrus operator</h3>&#13;
    <p class="normal">We already <a id="_idIndexMarker177"/>covered this briefly earlier in this chapter, but since Python 3.8, we have assignment expressions. If you have experience with C or C++, you have most likely seen something like this before:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span>((fh = fopen(<span class="hljs-string">"filename.txt"</span>, <span class="hljs-string">"w"</span>)) == NULL)&#13;
</code></pre>&#13;
    <p class="normal">Within C, this opens a file using <code class="inlineCode">fopen()</code>, stores the result of <code class="inlineCode">fopen()</code> in <code class="inlineCode">fh</code>, and checks whether the result of the <code class="inlineCode">fopen()</code> call is <code class="inlineCode">NULL</code>. Until Python 3.8, we always had to split these two operations into an assignment and an <code class="inlineCode">if</code> statement, assuming we also had<code class="inlineCode"> fopen()</code> and <code class="inlineCode">NULL</code> available in our Python code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">fh = fopen(<span class="hljs-string">"filename.txt"</span>, <span class="hljs-string">"w"</span>)&#13;
<span class="hljs-keyword">if</span> fh == NULL:&#13;
</code></pre>&#13;
    <p class="normal">Since Python 3.8, we can use <a id="_idIndexMarker178"/>assignment expressions to do this in a single line, similar to C:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fh := fopen(<span class="hljs-string">"filename.txt"</span>, <span class="hljs-string">"w"</span>)) == NULL:&#13;
</code></pre>&#13;
    <p class="normal">With the := operator you can assign and check the result in one operation. This can be useful when reading user input, for example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">while</span> (line := <span class="hljs-built_in">input</span>(<span class="hljs-string">'Please enter a line: '</span>)) != <span class="hljs-string">''</span>:&#13;
        <span class="hljs-comment"># Process the line here</span>&#13;
    <span class="hljs-comment"># The last line was empty, continue the script</span>&#13;
</code></pre>&#13;
    <p class="normal">This operator is often called the <a id="_idIndexMarker179"/>walrus operator because it looks slightly like the eyes and tusks of a walrus (:=).</p>&#13;
    <h3 id="_idParaDest-93" class="heading-3">PEP 634: Structural pattern matching, the switch statement</h3>&#13;
    <p class="normal">Many <a id="_idIndexMarker180"/>programmers who are new to Python wonder why it does not have a switch statement like most common programming languages. Often the lack of a switch statement has been <a id="_idIndexMarker181"/>addressed with dictionary lookups or, simply, a chain of <code class="inlineCode">if</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">else</code> statements. While those solutions work fine, I personally feel that at times my code could have been prettier and more readable with a switch statement.</p>&#13;
    <p class="normal">Since Python 3.10, we finally have a feature that is very comparable to a switch statement but so much more powerful. As is the case with the Python ternary operator (i.e. <code class="inlineCode">true_value if condition else false_value</code>), the syntax is far from a literal copy of other languages. In this case, especially, this is for the better. With most programming languages, it can be really easy to forget the <code class="inlineCode">break</code> statement in a switch, which can cause unintended side effects.</p>&#13;
    <p class="normal">At a glance, the Python<a id="_idIndexMarker182"/> implementation appears much simpler in syntax and features. Without the <code class="inlineCode">break</code> statement, you might wonder how you can match multiple patterns in a single go. Stay tuned and find out! The pattern matching feature is <em class="italic">very powerful</em> and offers many more features than you might expect. </p>&#13;
    <h4 class="heading-4">The basic match statement</h4>&#13;
    <p class="normal">First, let’s look at a basic example. This<a id="_idIndexMarker183"/> one offers little benefit but can still be easier to read than a regular <code class="inlineCode">if</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">else</code> statement:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> some_variable = <span class="hljs-con-number">123</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> match some_variable:&#13;
<span class="hljs-con-meta">...</span>     case <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Got 1'</span>)&#13;
<span class="hljs-con-meta">...</span>     case <span class="hljs-con-number">2</span>:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'</span><span class="hljs-con-string">Got 2'</span>)&#13;
<span class="hljs-con-meta">...</span>     case _:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Got something else'</span>)&#13;
Got something else&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">if</span> some_variable == <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Got 1'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">elif</span> some_variable == <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Got 2'</span>)&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Got something else'</span>)&#13;
Got something else&#13;
</code></pre>&#13;
    <p class="normal">Since we have both the <code class="inlineCode">if</code> and the <code class="inlineCode">match</code> statement here, you can easily compare them. In this case, I would go for the <code class="inlineCode">if</code> statement, but the main advantage of not having to repeat the <code class="inlineCode">some_variable ==</code> part can still be useful.</p>&#13;
    <p class="normal">The <code class="inlineCode">_</code> is the special <a id="_idIndexMarker184"/>wild card case for the match statement. It matches any value, so it can be seen as the equivalent of the <code class="inlineCode">else</code> statement.</p>&#13;
    <h4 class="heading-4">Storing the fallback as a variable</h4>&#13;
    <p class="normal">A slightly more <a id="_idIndexMarker185"/>useful example is to automatically store the result when it <a id="_idIndexMarker186"/>doesn’t match. The previous example uses an underscore (<code class="inlineCode">_</code>), which is not actually stored in <code class="inlineCode">_</code> because it is a special case, but if we name the variable differently, we can store the result:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> some_variable = <span class="hljs-con-number">123</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> match some_variable:&#13;
<span class="hljs-con-meta">...</span>     case <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Got 1'</span>)&#13;
<span class="hljs-con-meta">...</span>     case other:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Got something else:'</span>, other)&#13;
Got something else: 123&#13;
</code></pre>&#13;
    <p class="normal">In this case we store the <code class="inlineCode">else</code> case in the <code class="inlineCode">other</code> variable. Note that you cannot use <code class="inlineCode">_</code> and a variable name at the same time since they do the same thing, which would be useless.</p>&#13;
    <h4 class="heading-4">Matching from variables</h4>&#13;
    <p class="normal">You saw that a<a id="_idIndexMarker187"/> case such as <code class="inlineCode">case other:</code> will store the result in <code class="inlineCode">other</code> instead of comparing it with the value of <code class="inlineCode">other</code>, so you might be wondering if we can do the equivalent of:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> some_variable == some_value:&#13;
</code></pre>&#13;
    <p class="normal">The answer is that we can, with a caveat. Since any bare <code class="inlineCode">case variable:</code> will result in storing into a variable, we need to have something that does not match that pattern. The common way to work around this limitation is by introducing a dot: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Direction</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     LEFT = -<span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     RIGHT = <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_variable = Direction.LEFT&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> match some_variable:&#13;
<span class="hljs-con-meta">...</span>     case Direction.LEFT:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Going left'</span>)&#13;
<span class="hljs-con-meta">...</span>     case Direction.RIGHT:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Going right'</span>)&#13;
Going left&#13;
</code></pre>&#13;
    <p class="normal">As long as it<a id="_idIndexMarker188"/> cannot be interpreted as a variable name, this will work for you. When comparing with a local variable, an <code class="inlineCode">if</code> statement can always be used as well, of course.</p>&#13;
    <h4 class="heading-4">Matching multiple values in a single case</h4>&#13;
    <p class="normal">If you’re familiar with <a id="_idIndexMarker189"/>the <code class="inlineCode">switch</code> statement in many other <a id="_idIndexMarker190"/>programming languages, you might be wondering whether you can have multiple <code class="inlineCode">case</code> statements before you <code class="inlineCode">break</code>, like this, for example (C++):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">switch(variable){&#13;
    case Direction::LEFT:&#13;
    case Direction::RIGHT:&#13;
        cout &lt;&lt; <span class="hljs-string">"Going horizontal"</span> &lt;&lt; endl;&#13;
        <span class="hljs-keyword">break</span>;&#13;
    case Direction::UP:&#13;
    case Direction::DOWN:&#13;
        cout &lt;&lt; <span class="hljs-string">"Going vertical"</span> &lt;&lt; endl;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">This roughly means that if <code class="inlineCode">variable</code> is either equal to <code class="inlineCode">LEFT</code> or <code class="inlineCode">RIGHT</code>, print the <code class="inlineCode">"Going horizontal"</code> line and <code class="inlineCode">break</code>. Since the Python <code class="inlineCode">match</code> statement does not have a <code class="inlineCode">break</code>, how can we match something like this? Well, some syntax was introduced specifically for that:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Direction</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     LEFT = -<span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     UP = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span>     RIGHT = <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     DOWN = <span class="hljs-con-number">2</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_variable = Direction.LEFT&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> match some_variable:&#13;
<span class="hljs-con-meta">...</span>     case Direction.LEFT | Direction.RIGHT:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Going horizontal'</span>)&#13;
<span class="hljs-con-meta">...</span>     case Direction.UP | Direction.DOWN:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Going vertical'</span>)&#13;
Going horizontal&#13;
</code></pre>&#13;
    <p class="normal">As you can see, using<a id="_idIndexMarker191"/> the <code class="inlineCode">|</code> operator (which is also used for bitwise operations), you<a id="_idIndexMarker192"/> can test for multiple values at the same time.</p>&#13;
    <h4 class="heading-4">Matching values with guards or extra conditions</h4>&#13;
    <p class="normal">There are times<a id="_idIndexMarker193"/> when you want a more advanced comparison such as <code class="inlineCode">if variable &gt; value:</code>. Luckily, even that is possible with the <code class="inlineCode">match</code> statement using a <a id="_idIndexMarker194"/>feature called guards:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> values = -<span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> values:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'matching'</span>, value, end=<span class="hljs-con-string">': '</span>)&#13;
<span class="hljs-con-meta">...</span>     match value:&#13;
<span class="hljs-con-meta">...</span>         case negative <span class="hljs-con-keyword">if</span> negative &lt; <span class="hljs-con-number">0</span>:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">f'</span><span class="hljs-con-subst">{negative}</span><span class="hljs-con-string"> is smaller than 0'</span>)&#13;
<span class="hljs-con-meta">...</span>         case positive <span class="hljs-con-keyword">if</span> positive &gt; <span class="hljs-con-number">0</span>:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">f'</span><span class="hljs-con-subst">{positive}</span><span class="hljs-con-string"> is greater than 0'</span>)&#13;
<span class="hljs-con-meta">...</span>         case _:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'no match'</span>)&#13;
matching -1: -1 is smaller than 0&#13;
matching 0: no match&#13;
matching 1: 1 is greater than 0&#13;
</code></pre>&#13;
    <p class="normal">Note that this uses the variable name that I just introduced, but it’s a regular Python expression, so you could also compare something else. However, you always need to have the variable name before the <code class="inlineCode">if</code>. This will <em class="italic">not</em> work: <code class="inlineCode">case if ...</code>.</p>&#13;
    <h4 class="heading-4">Matching lists, tuples, and other sequences</h4>&#13;
    <p class="normal">If you <a id="_idIndexMarker195"/>are familiar with <code class="inlineCode">tuple</code> unpacking, you can probably guess how sequence <a id="_idIndexMarker196"/>matching <a id="_idIndexMarker197"/>works:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> values = (<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>), (<span class="hljs-con-number">0</span>, <span class="hljs-con-number">2</span>), (<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> values:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'matching'</span>, value, end=<span class="hljs-con-string">': '</span>)&#13;
<span class="hljs-con-meta">...</span>     match value:&#13;
<span class="hljs-con-meta">...</span>         case <span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'exactly matched 0, 1'</span>)&#13;
<span class="hljs-con-meta">...</span>         case <span class="hljs-con-number">0</span>, y:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">f'matched 0, y with y: </span><span class="hljs-con-subst">{y}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>         case x, y:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">f'matched x, y with x, y: </span><span class="hljs-con-subst">{x}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{y}</span><span class="hljs-con-string">'</span>)&#13;
matching (0, 1): exactly matched 0, 1&#13;
matching (0, 2): matched 0, y with y: 2&#13;
matching (1, 2): matched x, y with x, y: 1, 2&#13;
</code></pre>&#13;
    <p class="normal">The first case explicitly matches both of the given values, which is identical to <code class="inlineCode">if value == (0, 1):</code>.</p>&#13;
    <p class="normal">The second <a id="_idIndexMarker198"/>case explicitly <a id="_idIndexMarker199"/>matches <code class="inlineCode">0</code> for the first value, but <a id="_idIndexMarker200"/>leaves the second value as a variable and stores it in <code class="inlineCode">y</code>. Effectively this comes down to <code class="inlineCode">if value[0] == 0: y = value[1]</code>.</p>&#13;
    <p class="normal">The last case stores a variable for both the <code class="inlineCode">x</code> and <code class="inlineCode">y</code> values and will match any sequence with exactly two items.</p>&#13;
    <h4 class="heading-4">Matching sequence patterns</h4>&#13;
    <p class="normal">If you thought the previous <a id="_idIndexMarker201"/>example with the unpacking of the variables was useful, you will love this section. One of the really powerful features of the <code class="inlineCode">match</code> statement is matching based on patterns.</p>&#13;
    <p class="normal">Let’s assume we have a function that takes up to three parameters, <code class="inlineCode">host</code>, <code class="inlineCode">port</code>, and <code class="inlineCode">protocol</code>. For <code class="inlineCode">port</code> and <code class="inlineCode">protocol</code>, we can assume <code class="inlineCode">443</code> and <code class="inlineCode">https</code>, respectively, so that only leaves the <code class="inlineCode">hostname</code> as a required parameter. How can we match this so one, two, three, or more parameters are all supported and work correctly? Let’s find out:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">get_uri</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Set defaults so we only have to store changed variables</span>&#13;
<span class="hljs-con-meta">...</span>     protocol, port, paths = <span class="hljs-con-string">'https'</span>, <span class="hljs-con-number">443</span>, ()&#13;
<span class="hljs-con-meta">...</span>     match args:&#13;
<span class="hljs-con-meta">...</span>         case (hostname,):&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">pass</span>&#13;
<span class="hljs-con-meta">...</span>         case (hostname, port):&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">pass</span>&#13;
<span class="hljs-con-meta">...</span>         case (hostname, port, protocol, *paths):&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">pass</span>&#13;
<span class="hljs-con-meta">...</span>         case _:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">raise</span> RuntimeError(<span class="hljs-con-string">f'Invalid arguments </span><span class="hljs-con-subst">{args}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     path = <span class="hljs-con-string">'/'</span>.join(paths)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">f'</span><span class="hljs-con-subst">{protocol}</span><span class="hljs-con-string">://</span><span class="hljs-con-subst">{hostname}</span><span class="hljs-con-string">:</span><span class="hljs-con-subst">{port}</span><span class="hljs-con-string">/</span><span class="hljs-con-subst">{path}</span><span class="hljs-con-string">'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> get_uri(<span class="hljs-con-string">'localhost'</span>)&#13;
'https://localhost:443/'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> get_uri(<span class="hljs-con-string">'localhost'</span>, <span class="hljs-con-number">12345</span>)&#13;
'https://localhost:12345/'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> get_uri(<span class="hljs-con-string">'localhost'</span>, <span class="hljs-con-number">80</span>, <span class="hljs-con-string">'http'</span>)&#13;
'http://localhost:80/'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> get_uri(<span class="hljs-con-string">'localhost'</span>, <span class="hljs-con-number">80</span>, <span class="hljs-con-string">'http'</span>, <span class="hljs-con-string">'some'</span>, <span class="hljs-con-string">'paths'</span>)&#13;
'http://localhost:80/some/paths'&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the <code class="inlineCode">match</code> statement also handles different length sequences, which is a very useful tool to <a id="_idIndexMarker202"/>have. You could do this with <code class="inlineCode">if</code> statements as well, but I’ve never found a way to handle that in a really pretty fashion. Naturally you could still combine this with the earlier examples, so you could have a <code class="inlineCode">case</code> such as: <code class="inlineCode">case (hostname, port, 'http'):</code> if you want to invoke specific behavior. You can also apply <code class="inlineCode">*variable</code> to capture all extra variables. The <code class="inlineCode">*</code> matches 0 or more extra items in the sequence.</p>&#13;
    <h4 class="heading-4">Capturing sub-patterns</h4>&#13;
    <p class="normal">In addition to specifying <a id="_idIndexMarker203"/>a variable name to save all values into, you can also store explicit value matches:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> values = (<span class="hljs-con-number">0</span>, <span class="hljs-con-number">1</span>), (<span class="hljs-con-number">0</span>, <span class="hljs-con-number">2</span>), (<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> values:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'matching'</span>, value, end=<span class="hljs-con-string">': '</span>)&#13;
<span class="hljs-con-meta">...</span>     match value:&#13;
<span class="hljs-con-meta">...</span>         case <span class="hljs-con-number">0</span> <span class="hljs-con-keyword">as</span> x, (<span class="hljs-con-number">1</span> | <span class="hljs-con-number">2</span>) <span class="hljs-con-keyword">as</span> y:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">f'matched x, y with x, y: </span><span class="hljs-con-subst">{x}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{y}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>         case _:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'no match'</span>)&#13;
matching (0, 1): matched x, y with x, y: 0, 1&#13;
matching (0, 2): matched x, y with x, y: 0, 2&#13;
matching (1, 2): no match&#13;
</code></pre>&#13;
    <p class="normal">In this case we explicitly match <code class="inlineCode">0</code> as the first part of <code class="inlineCode">value</code>, and <code class="inlineCode">1</code> or <code class="inlineCode">2</code> as the second part of <code class="inlineCode">value</code>. And we store those in the variables <code class="inlineCode">x</code> and <code class="inlineCode">y</code>, respectively.</p>&#13;
    <div class="note">&#13;
      <p class="normal">It is important to note here that within the context of a <code class="inlineCode">case</code> statement the <code class="inlineCode">|</code> operator will always work as a or for the <code class="inlineCode">case</code>, instead of a bitwise or for the variables/values. Normally <code class="inlineCode">1 | 2</code> would result in <code class="inlineCode">3</code> because in binary <code class="inlineCode">1 = 0001</code>, <code class="inlineCode">2 = 0010</code> , and the combination of those is <code class="inlineCode">3 = 0011</code>.</p>&#13;
    </div>&#13;
    <h4 class="heading-4">Matching dictionaries and other mappings</h4>&#13;
    <p class="normal">Naturally it is also <a id="_idIndexMarker204"/>possible to <a id="_idIndexMarker205"/>match mappings (such as <code class="inlineCode">dict</code>) by key:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> values = <span class="hljs-con-built_in">dict</span>(a=<span class="hljs-con-number">0</span>, b=<span class="hljs-con-number">0</span>), <span class="hljs-con-built_in">dict</span>(a=<span class="hljs-con-number">0</span>, b=<span class="hljs-con-number">1</span>), <span class="hljs-con-built_in">dict</span>(a=<span class="hljs-con-number">1</span>, b=<span class="hljs-con-number">1</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> values:&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'matching'</span>, value, end=<span class="hljs-con-string">': '</span>)&#13;
<span class="hljs-con-meta">...</span>     match value:&#13;
<span class="hljs-con-meta">...</span>         case {<span class="hljs-con-string">'a'</span>: <span class="hljs-con-number">0</span>}:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'matched a=0:'</span>, value)&#13;
<span class="hljs-con-meta">...</span>         case {<span class="hljs-con-string">'a'</span>: <span class="hljs-con-number">0</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">b'</span>: <span class="hljs-con-number">0</span>}:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'matched a=0, b=0:'</span>, value)&#13;
<span class="hljs-con-meta">...</span>         case _:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'no match'</span>)&#13;
matching {'a': 0, 'b': 0}: matched a=0: {'a': 0, 'b': 0}&#13;
matching {'a': 0, 'b': 1}: matched a=0: {'a': 0, 'b': 1}&#13;
matching {'a': 1, 'b': 1}: no match&#13;
</code></pre>&#13;
    <p class="normal">Note that <code class="inlineCode">match</code> only checks for the given keys and values and does not care about extra keys in the mapping. This is why the first case matches both of the first two items.</p>&#13;
    <div class="note">&#13;
      <p class="normal">As you can see in the preceding example, matching happens sequentially and it will stop at the first match, not the best match. The second case is never reached in this scenario.</p>&#13;
    </div>&#13;
    <h4 class="heading-4">Matching using isinstance and attributes</h4>&#13;
    <p class="normal">If you thought the<a id="_idIndexMarker206"/> previous examples of the <code class="inlineCode">match</code> statement were <a id="_idIndexMarker207"/>impressive, get ready to be completely amazed. The way the <code class="inlineCode">match</code> statement can match instances including properties is amazingly powerful and can be incredibly useful. Just look at the following example and try to understand what is happening:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Person</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.name = name&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> values = Person(<span class="hljs-con-string">'Rick'</span>), Person(<span class="hljs-con-string">'Guido'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> values:&#13;
<span class="hljs-con-meta">...</span>     match value:&#13;
<span class="hljs-con-meta">...</span>         case Person(name=<span class="hljs-con-string">'Rick'</span>):&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'I found Rick'</span>)&#13;
<span class="hljs-con-meta">...</span>         case Person(occupation=<span class="hljs-con-string">'Programmer'</span>):&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'I found a programmer'</span>)&#13;
<span class="hljs-con-meta">...</span>         case Person() <span class="hljs-con-keyword">as</span> person:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'</span><span class="hljs-con-string">I found a person:'</span>, person.name)&#13;
I found Rick&#13;
I found a person: Guido&#13;
</code></pre>&#13;
    <p class="normal">While I will admit that the syntax is slightly confusing and, dare I say it, unPythonic, it is so useful that it still makes sense.</p>&#13;
    <p class="normal">Firstly, we will look at the <code class="inlineCode">case Person() as person:</code>. We’re discussing this first because it is important to understand what is happening here before we continue with the other examples. This <a id="_idIndexMarker208"/>line is effectively identical to <code class="inlineCode">if isinstance(value, Person):</code>. It does <em class="italic">not </em>actually instantiate the <code class="inlineCode">Person</code> class at this point, which is a bit confusing.</p>&#13;
    <p class="normal">Secondly, the <code class="inlineCode">case Person(name='Rick')</code> matches the instance type <code class="inlineCode">Person</code> and it requires the instance to <a id="_idIndexMarker209"/>have an attribute <code class="inlineCode">name</code> with value <code class="inlineCode">Rick</code>.</p>&#13;
    <p class="normal">Lastly, the <code class="inlineCode">case Person(occupation='Programmer')</code> matches <code class="inlineCode">value</code> to be a <code class="inlineCode">Person</code> instance and have an attribute called <code class="inlineCode">occupation</code> with the value <code class="inlineCode">Programmer</code>. Since that attribute does not exist, it ignores that issue silently.</p>&#13;
    <p class="normal">Note that this also works for built-in types and supports nesting:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Person</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.name = name&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> value = Person(<span class="hljs-con-number">123</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> match value:&#13;
<span class="hljs-con-meta">...</span>     case Person(name=<span class="hljs-con-built_in">str</span>() <span class="hljs-con-keyword">as</span> name):&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Found person with str name:'</span>, name)&#13;
<span class="hljs-con-meta">...</span>     case Person(name=<span class="hljs-con-built_in">int</span>() <span class="hljs-con-keyword">as</span> name):&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Found person with int name:'</span>, name)&#13;
Found person with int name: 123&#13;
</code></pre>&#13;
    <p class="normal">We have covered several examples of how the new pattern matching feature works, but you could think of many more. Since all parts can be nested, the possibilities really are endless. It might not be the perfect solution for everything, and the syntax might feel a little odd, but it is such a powerful solution that I would recommend any Python programmer learns it by heart.</p>&#13;
    <h1 id="_idParaDest-94" class="heading-1">Common pitfalls</h1>&#13;
    <p class="normal">Python is a<a id="_idIndexMarker210"/> language meant to be clear and readable without any ambiguities and unexpected behaviors. Unfortunately, these goals are not achievable in all cases, and that is why Python does have a few corner cases where it might do something different than what you were expecting.</p>&#13;
    <p class="normal">This section will show you some issues that you might encounter when writing Python code.</p>&#13;
    <h2 id="_idParaDest-95" class="heading-2">Scope matters!</h2>&#13;
    <p class="normal">There are a few cases in <a id="_idIndexMarker211"/>Python where you might not be using the scope that you are actually expecting. Some examples are when declaring a class and with function arguments, but the most annoying one is accidentally trying to overwrite a <code class="inlineCode">global</code> variable.</p>&#13;
    <h3 id="_idParaDest-96" class="heading-3">Global variables</h3>&#13;
    <p class="normal">A common problem when <a id="_idIndexMarker212"/>accessing variables from the <code class="inlineCode">global</code> scope is that setting a variable makes it local, even when accessing the <code class="inlineCode">global</code> variable.</p>&#13;
    <p class="normal">This works:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> g = <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_global</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Value: </span><span class="hljs-con-subst">{g}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print_global()&#13;
Value: 1&#13;
</code></pre>&#13;
    <p class="normal">But the following does not:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> g = <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_global</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     g += <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Value: </span><span class="hljs-con-subst">{g}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print_global()&#13;
Traceback (most recent call last):&#13;
    ...&#13;
UnboundLocalError: local variable 'g' referenced before assignment&#13;
</code></pre>&#13;
    <p class="normal">The problem is that <code class="inlineCode">g += 1</code> actually translates to <code class="inlineCode">g = g + 1</code>, and anything containing <code class="inlineCode">g =</code> makes the variable local to your scope. Since the local variable is being assigned at that point, it has no value yet and you are trying to use it.</p>&#13;
    <p class="normal">For these cases, there <a id="_idIndexMarker213"/>is the <code class="inlineCode">global</code> statement, although it is generally recommended to avoid writing to <code class="inlineCode">global</code> variables altogether because it can make your life a lot more difficult while debugging. Modern editors can help a lot to track who or what is writing to your <code class="inlineCode">global</code> variables, but restructuring your code so it purposefully passes and modifies values in a clear path can help you to avoid many bugs.</p>&#13;
    <h3 class="heading-3">Pass by reference with mutable variables</h3>&#13;
    <p class="normal">Within Python, variables<a id="_idIndexMarker214"/> are passed by reference. This means that when you do something like <code class="inlineCode">x = y</code>, both <code class="inlineCode">x</code> and <code class="inlineCode">y</code> will point to the same variable. When you change the value (not the object) of either <code class="inlineCode">x</code> or <code class="inlineCode">y</code>, the other will change as well.</p>&#13;
    <p class="normal">Since most variable types such as strings, integers, floats, and tuples are immutable, this is not a problem. Doing <code class="inlineCode">x = 123</code> won’t affect <code class="inlineCode">y</code> since we aren’t changing the value of <code class="inlineCode">x,</code> but we are replacing <code class="inlineCode">x</code> with a new object that has the value <code class="inlineCode">123</code>.</p>&#13;
    <p class="normal">With mutable variables, however, we can change the value of the object. Let’s illustrate this behavior and how to work around it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> x = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y = x&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> z = x.copy()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x.append(<span class="hljs-con-string">'x'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y.append(<span class="hljs-con-string">'y'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> z.append(<span class="hljs-con-string">'z'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x&#13;
['x', 'y']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y&#13;
['x', 'y']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> z&#13;
['z']&#13;
</code></pre>&#13;
    <p class="normal">Unless you explicitly copy the variable as we did with <code class="inlineCode">z</code>, your new variable will point to the same object.</p>&#13;
    <p class="normal">Now you might be wondering whether <code class="inlineCode">copy()</code> always works. As you might suspect, it doesn’t. The <code class="inlineCode">copy()</code> function <a id="_idIndexMarker215"/>only copies the object itself, not the values within the object. For that we have <code class="inlineCode">deepcopy()</code>, which even handles recursion safely:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> copy&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = [[<span class="hljs-con-number">1</span>], [<span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>]]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y = x.copy()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> z = copy.deepcopy(x)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x.append(<span class="hljs-con-string">'a'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x[<span class="hljs-con-number">0</span>].append(x)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x&#13;
[[1, [...]], [2, 3], 'a']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y&#13;
[[1, [...]], [2, 3]]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> z&#13;
[[1], [2, 3]]&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-97" class="heading-3">Mutable function default arguments</h3>&#13;
    <p class="normal">While the issues with mutable <a id="_idIndexMarker216"/>arguments can be easily avoided and seen in most cases, the scenario of default arguments for functions is a lot less obvious:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">append</span><span class="hljs-con-function">(</span><span class="hljs-con-params">list_=[], value=</span><span class="hljs-con-string">'value'</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>    list_.append(value)&#13;
<span class="hljs-con-meta">...</span>    <span class="hljs-con-keyword">return</span> list_&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> append(value=<span class="hljs-con-string">'a'</span>)&#13;
['a']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> append(value=<span class="hljs-con-string">'</span><span class="hljs-con-string">b'</span>)&#13;
['a', 'b']&#13;
</code></pre>&#13;
    <p class="normal">Note that this is the case for <code class="inlineCode">dict</code>, <code class="inlineCode">list</code>, <code class="inlineCode">set</code>, and several of the types in <code class="inlineCode">collections</code>. Additionally, the classes you define yourself are mutable by default.</p>&#13;
    <p class="normal">To work around this issue, you could consider changing the function to the following instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">append</span><span class="hljs-con-function">(</span><span class="hljs-con-params">list_=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, value=</span><span class="hljs-con-string">'value'</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>    <span class="hljs-con-keyword">if</span> list_ <span class="hljs-con-keyword">is</span> <span class="hljs-con-literal">None</span>:&#13;
<span class="hljs-con-meta">...</span>        list_ = []&#13;
<span class="hljs-con-meta">...</span>    list_.append(value)&#13;
<span class="hljs-con-meta">...</span>    <span class="hljs-con-keyword">return</span> list_&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> append(value=<span class="hljs-con-string">'a'</span>)&#13;
['a']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> append(value=<span class="hljs-con-string">'b'</span>)&#13;
['b']&#13;
</code></pre>&#13;
    <p class="normal">Note that we <a id="_idIndexMarker217"/>had to use <code class="inlineCode">if list_ is None</code> here. If we had done <code class="inlineCode">if not list_</code> instead, it would have ignored the given <code class="inlineCode">list_</code> if an empty <code class="inlineCode">list</code> was passed.</p>&#13;
    <h3 id="_idParaDest-98" class="heading-3">Class properties</h3>&#13;
    <p class="normal">The problem of <a id="_idIndexMarker218"/>mutable variables also occurs when defining classes. It is very easy to mix class attributes and instance attributes. This can be confusing, especially when you are coming from other languages such as C#. Let’s illustrate it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SomeClass</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     class_list = []&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.instance_list = []&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.class_list.append(<span class="hljs-con-string">'from class'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance = SomeClass()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance.class_list.append(<span class="hljs-con-string">'from instance'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance.instance_list.append(<span class="hljs-con-string">'from instance'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.class_list&#13;
['from class', 'from instance']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.instance_list&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
AttributeError: ... 'SomeClass' has no attribute 'instance_list'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance.class_list&#13;
['from class', 'from instance']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance.instance_list&#13;
['from instance']&#13;
</code></pre>&#13;
    <p class="normal">As with the function arguments, the list and dictionaries are shared. So if you want a mutable property for a class that isn’t shared between all instances, you will need to define it from within the <code class="inlineCode">__init__</code> or any other instance method.</p>&#13;
    <p class="normal">Another important <a id="_idIndexMarker219"/>thing to note when dealing with classes is that a class property will be inherited, and that’s where things might prove to be confusing. When inheriting, the original properties will stay references (unless overwritten) to the original values, even in subclasses:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Parent</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Child</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Parent</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Parent.parent_property = <span class="hljs-con-string">'parent'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Child.parent_property&#13;
'parent'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Child.parent_property = <span class="hljs-con-string">'child'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Parent.parent_property&#13;
'parent'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Child.parent_property&#13;
'child'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Child.child_property = <span class="hljs-con-string">'child'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Parent.child_property&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
AttributeError: ... 'Parent' has no attribute 'child_property'&#13;
</code></pre>&#13;
    <p class="normal">While this is to be expected due to inheritance, someone else using the class might not expect the variable to change in the meantime. After all, we modified <code class="inlineCode">Parent</code>, not <code class="inlineCode">Child</code>. </p>&#13;
    <p class="normal">There are two easy ways to prevent this. It is obviously possible to simply set the properties for every class separately. But the better solution is never to modify class properties outside of the class definition. It’s easy to forget that the property will change in multiple locations, and if it has to be modifiable anyway, it’s usually better to put it in an instance variable instead.</p>&#13;
    <h2 id="_idParaDest-99" class="heading-2">Overwriting and/or creating extra built-ins</h2>&#13;
    <p class="normal">While it can be <a id="_idIndexMarker220"/>useful in some cases, generally you will want to avoid overwriting global functions. The PEP 8 convention for naming your functions—similar to built-in statements, functions, and variables—is to use a trailing underscore.</p>&#13;
    <p class="normal">So, do not use this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#13;
</code></pre>&#13;
    <p class="normal">Instead, use the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">list_ = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#13;
</code></pre>&#13;
    <p class="normal">For lists and such, this is just a good convention. For statements such as <code class="inlineCode">from</code>, <code class="inlineCode">import</code>, and <code class="inlineCode">with</code>, it’s a requirement. Forgetting about this can lead to very confusing errors:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span> = <span class="hljs-con-built_in">list</span>((<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>&#13;
[1, 2, 3]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>((<span class="hljs-con-number">4</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">6</span>))&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: 'list' object is not callable&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> = <span class="hljs-con-string">'Some import'</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
SyntaxError: invalid syntax&#13;
</code></pre>&#13;
    <p class="normal">If you actually want to define a built-in that is available everywhere without requiring an import, that is possible. For debugging purposes, I’ve been known to add this code to a project while developing:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> builtins&#13;
<span class="hljs-keyword">import</span> inspect&#13;
<span class="hljs-keyword">import</span> pprint&#13;
<span class="hljs-keyword">import</span> re&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">pp</span><span class="hljs-function">(</span><span class="hljs-params">*args, **kwargs</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-string">'''PrettyPrint function that prints the variable name when</span>&#13;
<span class="hljs-string">    available and pprints the data'''</span>&#13;
    name = <span class="hljs-literal">None</span>&#13;
    <span class="hljs-comment"># Fetch the current frame from the stack</span>&#13;
    frame = inspect.currentframe().f_back&#13;
    <span class="hljs-comment"># Prepare the frame info</span>&#13;
    frame_info = inspect.getframeinfo(frame)&#13;
&#13;
    <span class="hljs-comment"># Walk through the lines of the function</span>&#13;
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> frame_info[<span class="hljs-number">3</span>]:&#13;
        <span class="hljs-comment"># Search for the pp() function call with a fancy regexp</span>&#13;
        m = re.search(<span class="hljs-string">r'\bpp\s*\(\s*([^)]*)\s*\)'</span>, line)&#13;
        <span class="hljs-keyword">if</span> m:&#13;
            print(<span class="hljs-string">'# %s:'</span> % m.group(<span class="hljs-number">1</span>), end=<span class="hljs-string">' '</span>)&#13;
            <span class="hljs-keyword">break</span>&#13;
&#13;
    pprint.pprint(*args, **kwargs)&#13;
&#13;
builtins.pf = pprint.pformat&#13;
builtins.pp = pp&#13;
</code></pre>&#13;
    <p class="normal">This is much too<a id="_idIndexMarker221"/> hacky for production code, but it is still useful when working on a large project where you need print statements to debug. Alternative (and better) debugging solutions can be found in <em class="chapterRef">Chapter 11</em>, <em class="italic">Debugging – Solving the Bugs</em>.</p>&#13;
    <p class="normal">The usage is quite simple:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">x = <span class="hljs-number">10</span>&#13;
pp(x)&#13;
</code></pre>&#13;
    <p class="normal">Here is the output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"># x: 10&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-100" class="heading-2">Modifying while iterating</h2>&#13;
    <p class="normal">At one point or<a id="_idIndexMarker222"/> another, you will run into this problem: while iterating through some mutable objects such as <code class="inlineCode">dict</code> and <code class="inlineCode">set</code>, you cannot modify them. All of these result in a <code class="inlineCode">RuntimeError</code> telling you that you cannot modify the object during iteration:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> dict_ = <span class="hljs-con-built_in">dict</span>(a=<span class="hljs-con-number">123</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> set_ = <span class="hljs-con-built_in">set</span>((<span class="hljs-con-number">456</span>,))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> key <span class="hljs-con-keyword">in</span> dict_:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">del</span> dict_[key]&#13;
<span class="hljs-con-meta">...</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
RuntimeError: dictionary changed size during iteration&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> set_:&#13;
<span class="hljs-con-meta">...</span>     set_.remove(item)&#13;
<span class="hljs-con-meta">...</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
RuntimeError: Set changed size during iteration&#13;
</code></pre>&#13;
    <p class="normal">For a list, it does work, but can result in very strange results, so it should definitely be avoided as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> list_ = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> list_&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> list_:&#13;
<span class="hljs-con-meta">...</span>     print(list_.pop(<span class="hljs-con-number">0</span>), end=<span class="hljs-con-string">', '</span>)&#13;
0, 1, 2, 3, 4,&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> list_&#13;
[5, 6, 7, 8, 9]&#13;
</code></pre>&#13;
    <p class="normal">While these issues can be avoided by copying the collections before usage, in many cases you are doing something wrong if you run into this issue. If manipulation is actually needed, building<a id="_idIndexMarker223"/> a new collection is often the easier way to go because the code will look more obvious. Whenever someone looks at code like this in the future, they might try to refactor it by removing the <code class="inlineCode">list()</code> since it looks futile at first glance:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> list_ = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">list</span>(list_):&#13;
<span class="hljs-con-meta">...</span>     print(list_.pop(<span class="hljs-con-number">0</span>), end=<span class="hljs-con-string">', '</span>)&#13;
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-101" class="heading-2">Catching and storing exceptions</h2>&#13;
    <p class="normal">When catching <a id="_idIndexMarker224"/>and storing exceptions in Python, you must keep in mind that <a id="_idIndexMarker225"/>for performance reasons, the stored exception is local to the <code class="inlineCode">except</code> block. The result is that you need to explicitly store the exception in a <em class="italic">different</em> variable. Simply declaring the variable before the <code class="inlineCode">try</code>/<code class="inlineCode">except</code> block does not work and will make your variable disappear:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> exception = <span class="hljs-con-literal">None</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-number">1</span> / <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> ZeroDivisionError <span class="hljs-con-keyword">as</span> exception:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exception&#13;
Traceback (most recent call last):&#13;
    ...&#13;
NameError: name 'exception' is not defined&#13;
</code></pre>&#13;
    <p class="normal">Storing the result in a new variable does work:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-number">1</span> / <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span> ZeroDivisionError <span class="hljs-con-keyword">as</span> exception:&#13;
<span class="hljs-con-meta">...</span>     new_exception = exception&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_exception&#13;
ZeroDivisionError('division by zero')&#13;
</code></pre>&#13;
    <p class="normal">As you can probably see already, this code does have a bug now. If we don’t end up in an exception, <code class="inlineCode">new_exception</code> will not be defined yet. We will either need to add an <code class="inlineCode">else</code> to the <code class="inlineCode">try</code>/<code class="inlineCode">except</code> or, better yet, pre-declare the variable before the <code class="inlineCode">try</code>/<code class="inlineCode">except</code>.</p>&#13;
    <p class="normal">We really need to save it explicitly because Python 3 automatically deletes anything saved with <code class="inlineCode">as variable</code> at the end of the <code class="inlineCode">except</code> statements. The reason for this is that exceptions in Python 3 contain a <code class="inlineCode">__traceback__</code> attribute. Having this attribute makes it much more difficult for the garbage collector to detect which memory should be freed as it introduces a recursive self-referencing cycle.</p>&#13;
    <p class="normal">Specifically, this is <code class="inlineCode">exception -&gt; traceback -&gt; exception -&gt; traceback ...</code> .</p>&#13;
    <p class="normal">This does mean that you should keep in mind that storing these exceptions can introduce memory leaks into your program. </p>&#13;
    <p class="normal">The Python garbage collector is smart enough to understand that <a id="_idIndexMarker226"/>the variables are not visible anymore and will<a id="_idIndexMarker227"/> delete the variable eventually, but it can take a lot more time because it is a far more complicated garbage collection procedure. How the garbage collection actually works is covered in <em class="chapterRef">Chapter 12</em>, <em class="italic">Performance – Tracking and Reducing Your Memory and CPU Usage</em>.</p>&#13;
    <h2 id="_idParaDest-102" class="heading-2">Late binding and closures</h2>&#13;
    <p class="normal">Closures are<a id="_idIndexMarker228"/> a method of implementing local scopes in code. They make it possible to locally define variables without overriding variables in the parent (or global) scope and hide <a id="_idIndexMarker229"/>the variables from the outside scope later. The problem with closures in Python is that Python tries to bind its variables as late as possible for performance reasons. While generally useful, it does have some unexpected side effects:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> functions = [<span class="hljs-con-keyword">lambda</span>: i <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> function <span class="hljs-con-keyword">in</span> functions:&#13;
<span class="hljs-con-meta">...</span>     print(function(), end=<span class="hljs-con-string">', '</span>)&#13;
2, 2, 2,&#13;
</code></pre>&#13;
    <p class="normal">You were probably expecting <code class="inlineCode">0, 1, 2</code> instead. Due to late binding, however, all functions get the last value of <code class="inlineCode">i</code> instead, which is <code class="inlineCode">2</code>.</p>&#13;
    <p class="normal">What should we do instead? As with the cases in earlier paragraphs, the variable needs to be made local. One option is to force <a id="_idIndexMarker230"/>immediate binding by currying the function with <code class="inlineCode">partial</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> functools <span class="hljs-con-keyword">import</span> partial&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> functions = [partial(<span class="hljs-con-keyword">lambda</span> x: x, i) <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> function <span class="hljs-con-keyword">in</span> functions:&#13;
<span class="hljs-con-meta">...</span>     print(function(), end=<span class="hljs-con-string">', '</span>)&#13;
0, 1, 2,&#13;
</code></pre>&#13;
    <p class="normal">A better solution would be to avoid binding problems altogether by not introducing extra scopes (the <code class="inlineCode">lambda</code>) that use external variables. If <code class="inlineCode">i</code> is specified as an argument to <code class="inlineCode">lambda</code>, this will not be a problem.</p>&#13;
    <h2 id="_idParaDest-103" class="heading-2">Circular imports</h2>&#13;
    <p class="normal">Even though <a id="_idIndexMarker231"/>Python is fairly tolerant<a id="_idIndexMarker232"/> of circular imports, there are some cases where you will get errors.</p>&#13;
    <p class="normal">Let’s assume we have two files:</p>&#13;
    <p class="normal"><code class="inlineCode">T_28_circular_imports_a.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> T_28_circular_imports_b&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileA</span><span class="hljs-class">:</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileC</span><span class="hljs-class">(</span><span class="hljs-params">T_28_circular_imports_b.FileB</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal"><code class="inlineCode">T_28_circular_imports_b.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> T_28_circular_imports_a&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileB</span><span class="hljs-class">(</span><span class="hljs-params">T_28_circular_imports_a.FileA</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">Running either of these files results in a circular import error:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Traceback (most recent call last):&#13;
  File "T_28_circular_imports_a.py", line 1, in &lt;module&gt;&#13;
    import T_28_circular_imports_b&#13;
  File "T_28_circular_imports_b.py", line 1, in &lt;module&gt;&#13;
    import T_28_circular_imports_a&#13;
  File "T_28_circular_imports_a.py", line 8, in &lt;module&gt;&#13;
    class FileC(T_28_circular_imports_b.FileB):&#13;
AttributeError: partially initialized module 'T_28_circular_imports_b' has no attribute 'FileB' (most likely due to a circular import)&#13;
</code></pre>&#13;
    <p class="normal">There are several ways to work around this problem. The simplest solution is to move the <code class="inlineCode">import</code> statement so the circular import doesn’t occur anymore. In this case, the <code class="inlineCode">import</code> in import <code class="inlineCode">T_28_circular_imports_a.py</code> needs to be moved between <code class="inlineCode">FileA</code> and <code class="inlineCode">FileB</code>.</p>&#13;
    <p class="normal">In most cases, the better solution is to restructure the code, however. Move the common base class to a separate file so there is no need for a circular import anymore. For the example above, that would look something like this:</p>&#13;
    <p class="normal"><code class="inlineCode">T_29_circular_imports_a.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileA</span><span class="hljs-class">:</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal"><code class="inlineCode">T_29_circular_imports_b.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> T_29_circular_imports_a&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileB</span><span class="hljs-class">(</span><span class="hljs-params">T_29_circular_imports_a.FileA</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal"><code class="inlineCode">T_29_circular_imports_c.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> T_29_circular_imports_b&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FileC</span><span class="hljs-class">(</span><span class="hljs-params">T_29_circular_imports_b.FileB</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">If that is also not possible, it can be useful to import from a function at runtime instead of at import time. Naturally this is not an easy option for class inheritance, but if you only need the import at runtime, you can defer the importing.</p>&#13;
    <p class="normal">Lastly, there is the<a id="_idIndexMarker233"/> option of dynamic imports, such as what the Django framework <a id="_idIndexMarker234"/>uses for the <code class="inlineCode">ForeignKey</code> fields. In addition to actual classes, the <code class="inlineCode">ForeignKey</code> fields also support strings, which will be imported automatically when needed. </p>&#13;
    <p class="normal">While this is a very effective way of working around the problem, it does mean that your editor, linting tools, and other tools won’t understand the object you are dealing with. To those tools, it will look like a string, so unless specific hacks are added to those, they will not assume the value to be anything besides a string.</p>&#13;
    <p class="normal">In addition, because the <code class="inlineCode">import</code> only happens at runtime, you will not notice import problems until you execute the function. That means that errors that normally would have presented themselves as soon as you run the script or application will now only show up when the function is called. This is a great recipe for hard-to-trace bugs that won’t occur for you but will for other users of the code.</p>&#13;
    <p class="normal">The pattern is still useful for cases such as plugin systems, however, as long as care is taken to avoid the caveats mentioned. Here’s a simple example to import dynamically:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> importlib&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> module_name = <span class="hljs-con-string">'sys'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> attribute = <span class="hljs-con-string">'version_info'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> module = importlib.import_module(module_name)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> module&#13;
&lt;module 'sys' (built-in)&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">getattr</span>(module, attribute).major&#13;
3&#13;
</code></pre>&#13;
    <p class="normal">Using <code class="inlineCode">importlib</code>, it is fairly<a id="_idIndexMarker235"/> easy to dynamically <code class="inlineCode">import</code> a module and by <a id="_idIndexMarker236"/>using <code class="inlineCode">getattr</code>, you can get a specific object from the module.</p>&#13;
    <h2 id="_idParaDest-104" class="heading-2">Import collisions</h2>&#13;
    <p class="normal">One problem that can be extremely<a id="_idIndexMarker237"/> confusing is having colliding imports—multiple packages/modules with the same name. I have had more than a few bug reports on my packages <a id="_idIndexMarker238"/>about cases like these.</p>&#13;
    <p class="normal">My <code class="inlineCode">numpy-stl</code> project, for example, houses the code in a package named <code class="inlineCode">stl</code>. Many people create a test file named <code class="inlineCode">stl.py</code>. When importing <code class="inlineCode">stl</code> from <code class="inlineCode">stl.py</code>, it will import itself instead of the <code class="inlineCode">stl</code> package.</p>&#13;
    <p class="normal">In addition to this, there is also the problem of packages being incompatible with each other. Common names might be used by several packages, so be careful when installing a bunch of similar packages since they might be sharing the same name. When in doubt, just create a new virtual environment and try again. Doing this can save you a lot of debugging.</p>&#13;
    <h1 id="_idParaDest-105" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter showed you what the Pythonic philosophy is all about and some of the reasoning behind it. Additionally, you have learned about the Zen of Python and what is considered beautiful and ugly within the Python community. While code style is highly personal, Python has a few very helpful guidelines that at least keep people mostly on the same page and style. </p>&#13;
    <p class="normal">In the end, we are all consenting adults; everyone has the right to write code as they sees fit. But I do request that you please read through the style guides and try to adhere to them unless you have a really good reason not to.</p>&#13;
    <p class="normal">With all that power comes great responsibility, and a few pitfalls, though there aren’t too many. Some are tricky enough to fool me regularly and I’ve been writing Python for a long time! Python improves all the time though. Many pitfalls have been taken care of since Python 2, but some will always remain. For example, circular imports and definitions can easily bite you in most languages that support them, but that doesn’t mean we’ll stop trying to improve Python.</p>&#13;
    <p class="normal">A good example of the improvements in Python over the years is the <code class="inlineCode">collections</code> module. It contains many useful collections that have been added by users because there was a need. Most of them are actually implemented in pure Python, and because of that, they are easy enough to be read by anyone. Understanding them might take a bit more effort, but I truly believe that if you make it to the end of this book, you will have no problem understanding what the collections do. Fully understanding how the internals work is something I cannot promise, though; some parts of that speak more to generic computer science than Python mastery.</p>&#13;
    <p class="normal">The next chapter will show you some of the collections available in Python and how they are constructed internally. Even though you are undoubtedly familiar with collections such as lists and dictionaries, you might not be aware of the performance characteristics involved with some of the operations. If some of the examples in this chapter were less than clear, you don’t have to worry. The next chapter will at least revisit some of them, and more will come in later chapters.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>