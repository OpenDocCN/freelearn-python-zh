- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CLI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user interface is like a joke. If you have to explain it, it’s not that good.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Martin LeBlanc
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to create **Command-Line Interface**
    ( **CLI** ) applications, also known as **Command-Line Applications** , in Python.
    A CLI is a user interface where users type commands into a console or terminal.
    Notable examples include the **Bash** and **Zsh** shells on macOS, Linux, and
    other UNIX-based operating systems, and the Windows **Command Prompt** and **PowerShell**
    . A CLI application is an application that is primarily used in such a command-line
    shell environment. One executes a CLI application by typing a command, possibly
    followed by some arguments, into the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Although **Graphical User Interfaces** ( **GUIs** ) and web applications are
    far more popular, CLI applications still have their place. They are especially
    popular among developers, system administrators, network administrators, and other
    technical users. There are several reasons for this popularity. Once you are familiar
    with the required commands, you can often perform a task much faster by typing
    commands into a CLI than by clicking through menus and buttons in a GUI. Most
    shells also allow connecting the output of one command directly to the input of
    another. This is called piping, and it allows users to combine simple commands
    into data processing pipelines to perform more complex tasks. Sequences of commands
    can be saved in scripts, allowing for repeatability and automation. It is also
    easier to document instructions to perform a task by providing exact commands
    to type, rather than explaining how to navigate a GUI or web interface.
  prefs: []
  type: TYPE_NORMAL
- en: CLI applications are much faster and easier to develop and maintain than graphical
    or web interfaces. For this reason, development teams sometimes prefer to implement
    tools for internal use as CLI applications. This allows them to reduce the time
    and effort spent on building internal tools and focus more on customer-facing
    features. Learning how to build command-line applications is also an excellent
    stepping stone toward learning how to build more complex software, such as GUI
    applications or distributed applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a command-line application for interacting
    with the railway API we studied in the previous chapter. We will use this project
    to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring a CLI application by breaking it down into sub-commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely dealing with passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will end the chapter with some suggestions for further resources where you
    can learn more about CLI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary user interface of a CLI application consists of the arguments that
    can be passed to it on the command line. Before we start exploring the railway
    CLI project, let us take a brief look at command-line arguments and the mechanisms
    Python provides for working with them.
  prefs: []
  type: TYPE_NORMAL
- en: Most applications accept various **options** (or **flags** ) as well as **positional
    arguments** . Some applications consist of several **sub-commands** , each of
    which has its own distinct set of options and positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Positional arguments represent the main data or objects that the application
    should operate on. They must be provided in a specific order and are usually not
    optional. For example, consider the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a copy of the file `original.txt` , named `copy.txt`
    . Both positional arguments ( `original.txt` and `copy.txt` ) are required, and
    changing their order would change the meaning of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Options are used to modify the behavior of an application. They are normally
    optional and typically consist either of a single letter prefixed with a hyphen
    or a word prefixed with two hyphens. Options do not need to appear in any particular
    order or position on the command line. They can even be placed after or between
    the positional arguments. For example, many applications accept a `-v` or `--verbose`
    option to enable verbose output. Some options behave like switches, turning some
    feature on (or off) simply by their presence (or absence). Other options require
    an additional argument as a value. For example, consider the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will recursively descend into the current directory and search for the
    string `hello` in all files whose names do not end with `.txt` . The `-r` option
    causes grep to recursively search a directory. Without this option, it would exit
    with an error when asked to search a directory instead of a regular file. The
    `--exclude` option requires a filename pattern ( `'*.txt'` ) as an argument and
    causes grep to exclude files matching the pattern from the search.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, options are traditionally prefixed with a forward-slash character
    ( `/` ) rather than a hyphen. However, many modern and cross-platform applications
    use hyphens for consistency with other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex applications are often divided into several sub-commands. The **Git**
    revision control system is an excellent example of this. For example, consider
    the commands
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `commit` and `ls-files` are sub-commands of the `git` application. The
    `commit` sub-command creates a new commit, using the text passed as an argument
    to the `-m` option ( `"Fix some bugs"` ) as the commit message. The `ls-files`
    command shows information about files in a Git repository. The `-m` option to
    `ls-files` instructs the command to only show files with modifications that have
    not been staged for committing.
  prefs: []
  type: TYPE_NORMAL
- en: The use of sub-commands helps to structure and organize the application interface,
    making it easier for users to find the features they need. Each sub-command can
    also have its own help messages, which means users can more easily learn how to
    use a feature without needing to read the full documentation for the entire application.
    It also promotes the modularity of the code, which improves maintainability and
    allows adding new commands without modifying existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Argument parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python applications can access the command-line arguments passed to them via
    `sys.argv` . Let us write a simple script that just prints the value of `sys.argv`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this without passing any arguments, the output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass some arguments, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `sys.argv` is a list of strings. The first element is the command
    used to run the application. The remaining elements contain the command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Simple applications that do not accept any options can simply extract positional
    arguments directly from `sys.argv` . For applications that do take options, however,
    the argument parsing logic can get complicated. Fortunately, the `argparse` module
    in the Python standard library provides a command-line argument parser that makes
    it easy to parse arguments without needing to write any complicated logic.
  prefs: []
  type: TYPE_NORMAL
- en: There are several third-party library alternatives to `argparse` . We will not
    cover any of these in this chapter, but we will provide some links for a few of
    the most popular ones at the end.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have written a script that takes `name` and `age` as positional
    arguments and prints out a greeting. Given the name `Heinrich` and age `42` ,
    it should print `"Hi Heinrich. You are 42 years old."` It accepts a custom greeting
    to use instead of `"Hi"` , via the `-g` option. Adding `-r` or `--reverse` to
    the command line results in reversing the message before printing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let us take a closer look at the `parse_arguments()` function. We start by creating
    an instance of the `ArgumentParser` class. Then, we proceed to define the arguments
    we accept by calling the `add_argument()` method. We start with the `name` and
    `age` positional arguments, providing help strings for each and specifying that
    `age` must be an integer. If no `type` is specified, the arguments will be parsed
    as strings. The next argument is an option, which can be specified on the command
    line as either `-r` or `--reverse` . The last argument is the `"-g"` option, with
    the default value `"` `Hi"` . Finally, we call the `parse_args()` method of the
    parser, to parse the command-line arguments. This will return a `Namespace` object
    containing the argument values parsed from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The `action` keyword argument to `add_argument()` defines how the parser should
    process the corresponding command-line argument. The default action, if none is
    specified, is `"store"` , which stores the value provided on the command line
    as an attribute on the object returned when parsing the arguments. The `"store_true"`
    action means that the option will be treated as a switch. If it is present on
    the command line, the parser will store the value `True` ; if it is absent, we
    get `False` . The `dest` keyword argument specifies the name of the attribute
    in which the value will be stored. If `dest` is not specified, the parser defaults
    to using the name of a positional argument, or the first long option string for
    option arguments (with the leading `--` removed). If only a short option string
    is provided, that is used (with the `-` removed).
  prefs: []
  type: TYPE_NORMAL
- en: Let us see what happens when we run this script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we provide incorrect arguments, we get a `usage` message indicating what
    the expected arguments are, as well as an error message telling us what we did
    wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `usage` message mentions a `-h` option, which we did not add. Let us see
    what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The parser automatically adds a `help` option, which shows detailed usage information,
    including the `help` strings we passed to the `add_argument()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To help you appreciate the power of `argparse` , we have added a version of
    the greeter script that does not use `argparse` in the source code for this chapter.
    You can find it in the `argument_parsing/greet.argv.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: We have only scratched the surface of what `argparse` is capable of in this
    section. We will show you a few more advanced features in the next section, as
    we explore the railway CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CLI client for the railway API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the basics of command-line argument parsing, we are
    ready to start working on a more complex CLI application. You will find the code
    for the application under the project directory in the source code for this chapter.
    Let us start by taking a look at the contents of the `project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `.env.example` file is a template for creating a `.env` configuration file
    for the railway application. The files in the `secrets` directory contain credentials
    needed to authenticate with the railway API as an admin user.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully run the examples in this section, you need to have the API from
    *Chapter 14, Introduction to API Development* , running. You also need to create
    a copy of the `.env.example` file named `.env` and ensure it contains the correct
    URL for the API.
  prefs: []
  type: TYPE_NORMAL
- en: The `railway_cli` directory is the Python package for the railway CLI application.
    The `api` sub-package contains the code for interacting with the railway API.
    In the `commands` sub-package, you will find the implementation of the sub-commands
    of the application. The `exceptions.py` module defines exceptions for errors that
    can occur within the application. `config.py` contains code for handling global
    configuration settings. The main function driving the CLI application is in `cli.py`
    . The `__main__.py` module is a special file that makes the package executable.
    When the package is executed with a command like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Python will load and execute the `__main__.py` module. Its contents are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All this module does is import the `cli` module and call the `cli.main()` function,
    which is the main entry point for the CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the railway API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we delve into the command-line interface code, we want to briefly discuss
    the API client code. Instead of looking at the code in detail, we will just give
    you a high-level overview. We leave it as an exercise for you to study the code
    in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `api` sub-package, you will find two modules, `client.py` and `schemas.py`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`schemas.py` defines `pydantic` models to represent the objects we expect to
    receive from the API (we have only defined models for stations and trains).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client.py` contains three classes and some helper functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPClient` is a generic class for making **HTTP** requests. It is a wrapper
    around a `Session` object from the `requests` library. It has methods corresponding
    to the HTTP verbs the API uses ( `get` , `post` , `put` , and `delete` ). This
    class takes care of error handling and extracting data from API responses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StationClient` is a higher-level client for interacting with the API’s station
    endpoints.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AdminClient` is a higher-level client for working with the admin endpoints.
    It has a method for authenticating users with the `users/authenticate` endpoint
    and a method for deleting a station via the `admin/stations/{station_id}` endpoint.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the command-line interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our exploration of the code with the `cli.py` module. We will
    examine it in chunks, starting with the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the standard library modules `argparse` and `sys` . We
    also import `__version__` , `config` , `commands` , and `exceptions` from the
    current package and the `Command` class from the `commands.base` module.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common convention for Python modules and packages to expose their version
    number under the name `__version__` . It is typically a string and is normally
    defined in the top-level `__init__.py` file of a package.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` function, we call `get_arg_parser()` to get an `ArgumentParser`
    instance and call its `parse_args()` method to parse the command-line arguments.
    We expect the returned `Namespace` object to have a `command` attribute, which
    should be a `Command` class. We create an instance of this class, passing it the
    parsed arguments. Finally, we call the command’s `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We handle `APIError` , `CommandError` , and `ConfigurationError` exceptions
    by calling `sys.exit()` to exit with an error message tailored to the type of
    exception that occurred. These are the only exceptions raised in our application
    code. If any other unexpected error happens, Python will terminate the application
    and print a full exception traceback to the user’s console. This may not seem
    very user-friendly, but it will make debugging much easier. Users of CLI applications
    also tend to be more technically adept and so are less likely to be put off by
    exception tracebacks than users of GUI or web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `main()` function has an optional parameter `cmdline` , which
    we pass to the `parse_args()` method. If `cmdline` is `None` , `parse_args()`
    will default to parsing arguments from `sys.argv` . However, if we pass a list
    of strings, `parse_args()` will parse that instead. Structuring the code like
    this is especially useful for unit testing as it allows us to avoid manipulating
    the global `sys.argv` in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the `Command` class and how the argument parser is set up to
    return the `Command` class to execute shortly. Let us first turn our attention
    to the `get_arg_parser()` function, though.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `get_arg_parser()` function creates and configures an `ArgumentParser` instance
    for the application. The `prog` argument specifies the program name to use in
    help messages. Normally, `argparse` takes this from `sys.argv[0]` ; however, for
    a package executed via `python -m package_name` , that is `__main__.py` , so we
    override it with the name of the package instead. The `description` argument provides
    a brief description of the program to display in the help message. The `formatter_class`
    determines how help messages are formatted ( `ArgumentDefaultsHelpFormatter` adds
    the default values of all options to the help message). We add a `"-V"` or `"--version"`
    option using the `"version"` action, which will print the `version` message and
    exit if this option is encountered on the command line. Finally, we call the `config.configure_arg_parser()`
    and `commands.configure_parsers()` functions to further configure the parser before
    returning it.
  prefs: []
  type: TYPE_NORMAL
- en: The Python import system sets the `__package__` attribute of every imported
    module to the name of the package it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will look at the command-line argument configuration
    for the `config` and `commands` modules, starting with `config` .
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files and secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides command-line arguments, many CLI applications also read settings from
    configuration files. Configuration files are often used for settings like API
    URLs that do not usually change from one invocation of an application to the next.
    It would be rather tedious for users to provide these on the command line every
    time they run an application.
  prefs: []
  type: TYPE_NORMAL
- en: Another common use case for configuration files is to supply passwords and other
    secrets. It is not considered good security practice to provide passwords as command-line
    arguments because, on most operating systems, any logged-in user can see the full
    command line of any running application. Most shells also have a command history
    feature, which can potentially expose passwords that are passed as command-line
    arguments. It is much more secure to provide passwords in configuration files
    or dedicated secret files, which are files used to configure a secret, such as
    a password. The filename corresponds to the name of the secret and the content
    of the file is the secret itself.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to remember that it is never safe to store secrets alongside
    our code. Especially if you use a versioning system, like Git or Mercurial, be
    careful never to commit any secret with the source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `railway_cli` application, the `config` module is responsible for handling
    configuration files and secrets. We use the `pydantic-settings` library, which
    we already encountered in *Chapter 14, Introduction to API Development* , to manage
    the configuration. Let us look at the code in chunks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the imports at the top of the file, we have two classes: `Settings` and
    `AdminCredentials` . Both inherit from `pydantic_settings.BaseSettings` . The
    `Settings` class defines the general configuration for the `railway_cli` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url` : is used to configure the railway API URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrets_dir` : can be used to configure a path to a directory containing secret
    files. The API admin credentials will be loaded from secret files in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AdminCredentials` class defines the credentials needed to authenticate
    with the API as an admin user. The `env_prefix` argument to the `SettingsConfigDict`
    will be prefixed to the field names when looking up values in the secrets directory.
    For example, the `password` will be looked up in a file named `railway_api_password`
    . The `AdminCredentials` class contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email` : will contain the admin email address to authenticate with. We use
    the `pydantic.EmailStr` type to ensure that it contains a valid email address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password` : will contain the admin password. We use the `pydantic.SecretStr`
    type to ensure that the value will be masked with asterisks when printed (for
    example, in application logs). If no value is provided when the class is instantiated
    (via a secret file or an argument to the class constructor), `pydantic` will call
    the function provided via the `default_factory` argument to the `Field` function.
    We use this to call the standard library `getpass` function to securely prompt
    the user for the admin password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below these class definitions, you will find the `configure_arg_parser()` function.
    Let us look at that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We use the argument parser’s `add_argument_group()` method to create an argument
    group named `"configuration"` and give it a `description` . We add options allowing
    a user to specify a configuration file name and a secrets directory to this group.
    Note that argument groups do not affect how arguments are parsed or returned.
    It only means that these arguments will be grouped together under a common heading
    in the help message.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we set the default configuration file path in this
    example to `.env` . It is, however, considered best practice to use the standard
    configuration file locations for the platform your application is running on.
    The `platformdirs` library ( [https://platformdirs.readthedocs.io](https://platformdirs.readthedocs.io)
    ) can be particularly helpful for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the `config.py` module consists of helper functions for retrieving
    the settings and admin credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `get_settings()` function creates and returns an instance of the `Settings`
    class. The `_env_file=args.config_file` argument tells `pydantic-settings` to
    load the settings from the file specified via the `--config-file` command-line
    option (which defaults to `.env` ). The `get_admin_credentials()` function creates
    and returns an instance of the `AdminCredentials` class. The `_secrets_dir` argument
    to the class specifies the secrets directory where `pydantic-settings` will look
    for the credentials. If a `--secrets-dir` option was set on the command line,
    we will use that; otherwise, use `settings.secrets_dir` . If that is also `None`
    , no secrets directory will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sub-commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The railway API has separate endpoints for listing stations, creating stations,
    getting departures, and so on. It makes sense to have a similar structure in our
    application. There are many ways of structuring the code for sub-commands. In
    this application, we have chosen to use an object-oriented approach. Each command
    is implemented as a class, with a method to configure the argument parser with
    the options and arguments it needs, and a method to execute the command. All commands
    are subclasses of the `Command` base class. You will find it in the `commands/base.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Command` class is an ordinary class. The `ClassVar` annotation
    on `name` and `help` indicates that these are expected to be class attributes,
    rather than instance attributes. The `__init__()` method takes an `argparse.Namespace`
    object, which it assigns to `self.args` . It calls `get_settings()` to load the
    configuration file. Before returning, it also creates an `HTTPClient` object (from
    `api/client.py` ) and assigns it to `self.api_client` .
  prefs: []
  type: TYPE_NORMAL
- en: The `configure_arg_parser()` class method and `execute()` method both raise
    `NotImplementedError` when called, which means that subclasses need to override
    these methods with their own implementations.
  prefs: []
  type: TYPE_NORMAL
- en: To set up argument parsing for the sub-commands, we need to create a parser
    for each sub-command and configure it by calling the `configure_arg_parser()`
    class method of the `Command` class. The `commands.configure_parsers()` function
    is responsible for this process. Let us take a look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `parser.add_subparsers()` method returns an object that can be used to attach
    sub-command parsers to the main parser. The `description` argument is used to
    generate the help text for the sub-commands, and `required=True` ensures that
    the parser will produce an error if a sub-command is not supplied on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We iterate over the list of `admin_commands` and `station_commands` and create
    a sub-parser for each of them. The `add_parser()` method expects the `name` of
    the sub-command and any arguments that can be passed to the `ArgumentParser` class.
    It returns a new `ArgumentParser` instance, which we pass to the `command.configure_arg_parser()`
    class method. Note that the `command: type[Command]` type annotation indicates
    that we expect all elements of `admin_commands` and `station_commands` to be subclasses
    of `Command` .'
  prefs: []
  type: TYPE_NORMAL
- en: The `set_defaults()` method allows us to set attributes on the namespace returned
    by the parser, independently of what is on the command line. We use this to set
    the `command` attribute for each sub-parser to the corresponding `Command` subclass.
    The `Namespace` object returned by the `parse_args()` method will only contain
    attributes from exactly one sub-parser (the one corresponding to the sub-command
    provided on the command line). Thus, when we call `args.command(args=args)` in
    the `cli.main()` function, we are guaranteed to get an instance of the command
    class for the command selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have put together all the code to configure the argument parser,
    we can look at the help text that is generated when we run the application with
    the `-h` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have trimmed some of the output and removed blank lines, but you can see
    that there is a `usage` summary showing how to use the command, followed by the
    `description` we set when creating the argument parser. This is followed by the
    global `options` section with the `-h` or `--help` option and the `-V` or `--version`
    option. Next, we get a `configuration` section with the description and options
    we configured in the `config.configure_arg_parser()` function. Finally, we have
    a `subcommands` section, with the description we passed to the argument parser’s
    `add_subparsers()` method in `commands.configure_parsers()` and a list of all
    the available sub-commands with the help string we set for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the base class for sub-commands and the code to configure the argument
    parser to work with sub-commands. Let us now look at the implementation of a sub-command.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sub-commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sub-command parsers are completely independent, so we can implement sub-commands
    without any risk that their command-line options might conflict with one another.
    We only need to ensure that the command names are unique. This means we can extend
    the application by adding commands without needing to modify any existing code.
    The class-based approach we have chosen for this application makes it easy to
    add commands. We just have to create a new `Command` subclass, define its `name`
    and `help` text, and implement the `configure_arg_parser()` and `execute()` methods.
    As an example, let us look at the code for the `create-station` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have not reproduced the imports from the top of the `commands/stations.py`
    module here. As you can see, the code for the command is quite straightforward.
    The `configure_arg_parser()` class method adds options for the station code, city,
    and country.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all three are marked as `required` . The Python `argparse` documentation
    discourages the use of `required` options; however, in some circumstances, it
    can lead to a more user-friendly interface. If a command requires more than two
    arguments with different meanings, it can become difficult for users to remember
    the correct order. Using options instead means that the order does not matter,
    and it is immediately obvious what each of the arguments means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what happens when we run this command. First, with the `-h` option
    to see the help message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The help message clearly shows how to use the command. Now we can create a
    station:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the station was created successfully and assigned the
    `id` `12` .
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our exploration of the railway CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will finish this chapter with some links to resources where you can learn
    more and some useful libraries for developing CLI applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Although we have tried to make this chapter as comprehensive as we could, the
    `argparse` module has many more features than we could showcase here. The official
    documentation at [https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)
    is excellent, though.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `argparse` is not to your liking, there are several third-party libraries
    available for command-line argument parsing. We suggest that you try them all:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Click** is by far the most popular third-party CLI library for Python. Besides
    command-line parsing, it also provides features for creating interactive applications
    (such as input prompts) and for producing colorful output. You can learn about
    it at [https://click.palletsprojects.com](https://click.palletsprojects.com) .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Typer** was created by the same developers as FastAPI. It aims to apply the
    same principles FastAPI applies to API development to CLI development. You can
    read about it at [https://typer.tiangolo.com/](https://typer.tiangolo.com/) .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pydantic Settings** , which we used for configuration management in this
    chapter and in *Chapter 14, Introduction to API development* , also supports parsing
    command-line arguments. See [https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support)
    to learn more about this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most modern shells support programmable command-line tab completion. Providing
    command-line completion can make your CLI application much easier to use. The
    `argcomplete` library ( [https://kislyuk.github.io/argcomplete/](https://kislyuk.github.io/argcomplete/)
    ) provides command-line completion in the `bash` and `zsh` shells for applications
    that use `argparse` to handle command-line arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Command Line Interface Guidelines* ( [https://clig.dev/](https://clig.dev/)
    ) is a comprehensive open-source resource with excellent advice for designing
    user-friendly command-line interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about command-line applications by developing a
    CLI client for the railway API that we created in *Chapter 14, Introduction to
    API Development* . We learned how to parse command-line arguments with the standard
    library `argparse` module. We looked at how to structure a CLI application interface
    by using sub-commands and saw how this can help us build modular applications
    that are easy to maintain and extend. We concluded the chapter with some links
    to other libraries for CLI application development in Python and some resources
    where you can learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Working with command-line applications is an excellent way to practice the skills
    you learned throughout this book. We encourage you to study the code for this
    chapter, extend it by adding more commands, and improve it by adding logging and
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to package and publish Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_15.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
