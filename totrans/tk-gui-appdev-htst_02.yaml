- en: Chapter 2. Making a Text Editor like Notepad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous project, we got a fairly high-level overview of Tkinter. Now
    that we know some things about Tkinter's core widgets, geometry management, and
    bindings of command and events to callbacks, let us apply our skill to make a
    text editor in this project.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we will also take a closer look at individual widgets and learn
    how to tweak those widgets to our custom needs.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, our goal is to build a fully-functional text editing pad with
    some cool nifty features. In its final form, the proposed editor should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some features we intend to include in the notepad are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new documents, opening and editing existing documents, and saving documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing common editing options such as cut, copy, paste, undo, and redo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching within a file for a given search term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing line numbering and the ability to show/hide line numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing theme selection to let the user choose custom color themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing about and help windows and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project you will build you first real and useful project. This project
    will provide you with further insights into the world of Tkinter. It will delve
    deeper into features of some commonly used widgets such as Menu, Menubutton, Text,
    Entry, Checkbutton, and Button widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Particularly, we will go into the finer details of the Menu, Menubar, and Text
    widgets. We will also learn to easily handle custom dialogs windows such as the
    Open, Save, Error, Warning, and Info dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project will be developed in seven consecutive iterations. The goals for
    each of these iterations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the user interface using the `pack` geometry using widgets such as Menu,
    Menubar, Text, Entry, Button, Checkbutton, and the like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement some features using Tkinter's built-in widget options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement dialogs using `ttk` dialogs and different types of Toplevel widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply some Text widget features such as text index, tag, and mark to implement
    some custom features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply some features using the Checkbutton and Radiobutton widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply some custom event binding and protocol binding to make the application
    more user-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add some miscellaneous features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first goal is to implement the visual elements of the text editor. As programmers,
    we have all used notepad or some code editor to edit our code. We are mostly aware
    of the common GUI elements of a text editor. So, without much of an introduction,
    let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first phase implements the following six widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menubutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrollbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we will cover all these in detail, you might find it helpful to look
    at the widget-specific options in the documentation of Tkinter maintained by its
    author Frederick Lundh at [http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/).
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to bookmark the official documentation page of Tck/Tk located
    at [http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The latter site includes the original Tcl/Tk reference. While it does not relate
    to Python, it provides a more detailed overview of each widget and is an equally
    useful reference. (Remember, Tkinter is just a wrapper around Tk)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also read the documentation provided with the original source code
    of Tkinter by typing these two lines in the interactive Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we will complete the implementation of most of the visual
    elements of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be using the `pack()` geometry manager to place all the widgets. We
    have chosen the `pack` manager because it is ideally suited for placing widgets
    side by side or in a top-down position. Fortunately in a text editor, we have
    all widgets placed either side-by-side or in top-down locations. Thus, it suits
    to use the `pack` manager. We could have done the same with the `grid` manager
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will start by adding the Toplevel window, one that will contain all
    other widgets using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this step we add the top menu buttons to our code. See the code in `2.01.py`.
    Menus offer a very compact way of presenting a large number of choices to the
    user without cluttering the interface. Tkinter offers two widgets to handle menus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Menubutton** widget – one that is part of the menu and appears on the
    top of application, which is always visible to the end user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Menu** widget – one that show a list of choices when the user clicks on
    any menu button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941_02_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To add top-level menu buttons, you use the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to add a File menu, we use the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we add the Edit, View, and About menus at the top. Refer to step
    2 of `2.01.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most of the Linux platforms support **tear-off menus**. When `tearoff` is set
    to `1` (enabled), the menu appears with a dotted line above the menu options.
    Clicking on the dotted line enables the user to literally tear off or separate
    the menu from the top. However, as this is not a cross-platform feature, we have
    decided to disable tear-off, marking it as `tearoff = 0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we will add menu items within each of the four menu buttons. As previously
    mentioned, all drop-down options are to be added within the menu instance. In
    our example, we add five drop-down menu choices in the File menu, namely New,
    Open, Save, Save As, and Exit menu items. See step 3 of `2.02.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, we add the following menu choices for other menus:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under **Edit** we have **Undo**, **Redo**, **Cut**, **Copy**, **Paste**, **Find
    All**, and **Select All**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **View** we have **Show Line Number**, **Show Info Bar at Bottom**, **Highlight
    Current Line**, and **Themes**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **About** we have **About** and **Help**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The format for adding menu items is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, you would create the **Undo** menu item using the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Engage Thrusters](img/7941_02_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next we will add some labels. We will add the top label, which will later hold
    the shortcut buttons. We will also add a label to the left-hand side to display
    the line numbers:![Engage Thrusters](img/7941_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The top label has been marked in a green background and the side label in a
    light cream background for illustration purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with the `pack` geometry manager, it is important to add widgets
    in the order they will appear. This is because `pack()` uses the concept of available
    space to fit the widgets. If we do not maintain the order, the widgets will start
    occupying places in the order they are introduced. This is why we cannot introduce
    the text widget before the two label widgets as they appear higher up in the display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having reserved the space, we can later add shortcut icons or line numbers
    keeping the label as the parent widget. Adding labels is easy, we have done that
    in the past. See the code in `2.02.py` step 4\. The code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have applied a colorful background to these two labels for now to differentiate
    it from the body of the Toplevel window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, let's add the Text widget and Scrollbar widget to our code. Refer to
    step 5 of the code `2.02.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is similar to all other code that we have used so far to instantiate
    widgets. Notice, however, that the scrollbar is configured to `yview` of the Text
    widget and the Text widget is configured to connect to the Scrollbar widget. This
    way, we cross connected both the widgets to each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now when you go down the Text widget, the scrollbar reacts to it. Alternatively,
    when you pull the scrollbar, the Text widget reacts in return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some new menu-specific options introduced here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accelerator`: This option is used to specify a string, typically the keyboard
    shortcut, which can be used to invoke the menu. The string specified as the accelerator
    appears next to the text of the menu item. Please note that this does not automatically
    create bindings for the keyboard shortcut. We will have to manually set them up,
    as we will see later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compound`: Specifying a `compound` option to the menu item lets you add images
    beside the common text label of the menu. A specification such as `Compound=LEFT,
    label= ''mytext'', image=myimage` means that the menu item has a compound label
    comprising of a text label and an image, where the image is to be placed on the
    left-hand side of the text. The images we use here are stored and referenced from
    a separate folder called `icons`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underline`: The `underline` option lets you specify the index of a character
    in the menu text to be underlined. The indexing starts at 0, which means that
    specifying `underline=1` underlines the second character of the text. Besides
    underlining, Tkinter also uses it to define the default bindings for keyboard
    traversal of menus. This means that we can select the menu either with the mouse
    pointer, or with the *Alt* + `<character_at_the_underlined_index>` shortcut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, to add the **New** menu item within the **File** menu, we use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we add menu choices for the **Edit** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Menu separators**'
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally within your menu items, you will come across code such as `mymenu.add_separator()`.
    This widget displays a separator bar and is solely used to organize similar menu
    items in groups, separating groups by horizontal bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the normal menu type that we implement for the **New** and **Edit**
    menus, Tkinter offers three more varieties of menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Checkbutton menu**: This menu lets you make a yes/no choice by checking/unchecking
    the menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Radiobutton menu**: This menu lets you choose one from among many different
    options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Cascade menu**: This menu only opens up to show another list of choices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our **View** menu demonstrates all these three types of menus as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first three choices under the **View** menu let the user select whether
    or not they want a certain thing to happen. The user can check/uncheck options
    against these menus and are examples of the Checkbutton menu.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth menu choice under **View** menu reads as **Themes**. Hovering over
    this menu opens another list of choices. This is an example of a **Cascade** menu
    as it only serves the purpose of opening up another list of choices.
  prefs: []
  type: TYPE_NORMAL
- en: Within the **Cascade** menu, you are presented with a list of choices for your
    editor theme. You can, however, select only one of the themes. Selecting one theme
    unselects any previous selection. This is an example of the Radiobutton menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example format for adding these three types of menu is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we need to track whether or not a selection has been made, we track
    it by adding a variable that can be `BooleanVar()`, `IntVar()`, or `Stringvar()`
    as we discussed in [Project 1](ch01.html "Chapter 1. Meet Tkinter"), *Meet Tkinter*.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of configuration options for the Menubutton and Menu widgets,
    refer to the *The basic widget methods* section in [Appendix B](apb.html "Appendix B. Quick
    Reference Sheets"), *Quick Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This concludes our first iteration. In this iteration, we have completed laying
    down the majority of visual elements of our text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of built-in Text widget options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter's Text widget comes with some handy built-in functionality to handle
    common text-related functions. Let's leverage these functionalities to implement
    some common features in our text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by implementing the Cut, Copy, and Paste features. We now have our
    editor GUI ready. If you open the program and play with the Text widget, you will
    notice that you can perform basic functions such as cut, copy, and paste in the
    text area using the keyboard shortcuts *Ctrl* + *X*, *Ctrl* + *C*, and *Ctrl*
    + *V*. All these functions exist without us having to add a single line of code
    toward these functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clearly the text widget comes built in with these events. Rather than coding
    these functions ourselves, let's use the built-in functions to add these features
    to our text editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The documentation of Tcl/Tk "universal widget methods" tells us that we can
    trigger events without any external stimulus using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To trigger the cut event for our `textPad` widget, all we need is a line of
    code such as the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s call that using a function cut, and associate it with our cut menu using
    the command callback. See the code `2.03.py` that bears the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we trigger the copy and paste functions from their respective menu
    items.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next we will move on to implementing the undo and redo features. The Tcl/Tk
    text documentation tells us that the Text widget has an unlimited undo and redo
    mechanism, provided we set the `-undo` option as `true`. To leverage this option,
    let''s first set the Text widget''s `undo` option to `true` as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now if you open your text editor and try out the undo and redo features using
    *Ctrl* + *Z* and *Ctrl* + *Y*, you will see that they work fine. We now only have
    to associate the events to functions and callback the functions from our **Undo**
    and **Redo** menus respectively. This is similar to what we did for cut, copy,
    and paste. Refer to the code in `2.03.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking advantage of some built-in Text widget options, we have successfully
    implemented the functionality of cut, copy, paste, undo, and redo into our text
    editor with minimal coding.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we managed to leverage some built-in functionality to gain a quick advantage,
    we need a more precise control over the text area, so as to bend it to our will.
    This would require the ability to target each character or location of the text
    with precision.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Text widget offers us the ability to manipulate its content using **index**,
    **tags**, and **mark** , which lets us target a position or place within the text
    area for manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indexing helps you target a particular place within a text. For example, if
    you want to mark a particular word in bold style or in red or in a different font
    size, you can do so if you know the index of the starting point and the index
    of end point to be targeted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index must be specified in one of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index format | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x.y` | The *y*th character on line *x*. |'
  prefs: []
  type: TYPE_TB
- en: '| `@x,y` | The character that covers the `x`,`y` coordinate within the text''s
    window. |'
  prefs: []
  type: TYPE_TB
- en: '| `end` | The end of the text. |'
  prefs: []
  type: TYPE_TB
- en: '| `mark` | The character after a named mark. |'
  prefs: []
  type: TYPE_TB
- en: '| `tag.first` | The first character in the text that has been tagged with a
    given tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `tag.last` | The last character in the text that has been tagged with a given
    tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `selection (SEL_FIRST, SEL_LAST)` | This corresponds to the current selection.
    The constants `SEL_FIRST` and `SEL_LAST` refer to the start position and the end
    position in the selection. Tkinter raises a TclError exception if there is no
    selection. |'
  prefs: []
  type: TYPE_TB
- en: '| `windowname` | The position of the embedded window whose name is `windowname`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `imagename` | The position of the embedded image with the name `imageName`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `INSERT` | The position of the insertion cursor. |'
  prefs: []
  type: TYPE_TB
- en: '| `CURRENT` | The position of the character closest to the mouse pointer. |'
  prefs: []
  type: TYPE_TB
- en: 'Indices can be further manipulated using modifiers and submodifiers. Some examples
    of modifiers and submodifers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`end - 1 chars` or `end - 1 c` refers to the index of one character before
    the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert +5lines` refers to the index of five lines ahead of the insertion cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertwordstart - 1 c` refers to the character just before the first one in
    the word containing the insertion cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end linestart` refers to the index of the line start of the end line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indexes are often used as arguments to functions. For example, refer to the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text.delete(1.0,END)`: This means you can delete from line 1, column 0 up
    till the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text.get(0.0, END)`: This gets the content from 0.0 up till the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text.delete(insert-1c, INSERT)`: This deletes one character at the insertion
    cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tags are used to annotate text with an identification string that can then be
    used to manipulate the tagged text. Tkinter has a built-in tag called **SEL**,
    which is automatically applied to the selected text. In addition to SEL, you can
    define your own tags. A text range can be associated with multiple tags, and the
    same tag can be used for many different text ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of tagging are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can specify the visual style for a given tag with `tag_config` using options
    such as `background(color)`, `bgstipple (bitmap)`, `borderwidth (distance)`, `fgstipple
    (bitmap)`, `font (font)`, `foreground (color)`, `justify (constant)`, `lmargin1
    (distance)`, `lmargin2 (distance)`, `offset (distance)`, `overstrike (flag)`,
    `relief (constant)`, `rmargin (distance)`, `spacing1 (distance)`, `tabs (string)`,
    `underline (flag)`, and `wrap (constant)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete reference of text indexing and tagging, type the following command
    into your Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equipped with a basic understanding of indexing and tagging, let's implement
    some more features in our code editor.
  prefs: []
  type: TYPE_NORMAL
- en: The first feature that we will implement is the "Select All" feature. We know
    that Tkinter has a built-in `SEL` tag that applies a selection to a given text
    range. We want to apply this `sel` tag to the complete text contained in our widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We simply define a function to handle this. Refer to the code in `2.04.py`
    as shown in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this we add a callback to our Select All menu item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we are done adding the Select All functionality to our code editor. If
    you now add some text to the text widget and then click on the menu item **select
    all**, it should select the entire text in your editor. Note that we have not
    bound the *Ctrl* + *A* accelerator in the menu options. The keyboard shortcut
    will therefore not work. We will make the `accelerator` function in a separate
    step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, let's complete the functioning of the **Find** menu item.![Engage Thrusters](img/7941_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here's a quick summary of the desired functionality. When a user clicks on the
    **Find** menu item, a new Toplevel window opens up. The user enters a search keyword,
    and specifies if the search is to be case-sensitive. When the user clicks on the
    **Find All** button, all matches are highlighted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For searching through the document, we will rely on the `text.search()` method.
    The `search` method takes in the following arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our editor, we define a function called `on_find` and attach it as a callback
    to our **Find** menu item (refer to the code in `2.04.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define our function `on_find` as follows (refer to the code in `2.04.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a user clicks on the **Find** menu item, it invokes a callback `on_find`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first four lines of the `on_find()` function creates a new Toplevel window,
    adds a title `Find`, specifies it geometry (size, shape, and location), and sets
    it as a transient window. Setting it to transient means that it is always drawn
    on top of its parent or root window. If you uncomment this line and click on the
    root editor window, the **Find** window will go behind the root window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next eight lines of code are pretty self-explanatory in that they set the
    widgets of the **Find** window. It adds the Label, Entry, Button, and Checkbutton
    widgets and provides for two variables, `e` and `c`, to track the value a user
    enters into the Entry widget, and whether or not the user has checked the check
    button. The widgets are arranged using the `grid` geometry manager to fit into
    the **Find** window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Find All** button has a `command` option that calls a function, `search_for()`,
    passing the search string as the first argument and whether or not the search
    is to be case-sensitive as its second argument. The third, fourth, and fifth arguments
    pass the Toplevel window, the Text widget, and the Entry widget as parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to the `search_for()` method, we override the Close button of the Find
    window and redirect it to a callback named `close_search()`. The `close_search()`
    method is defined within the `on_find()` function. This function takes care of
    removing the tag `match` that was added during the search. If we do not override
    the Close button and remove these tags, our matched string will continue to be
    marked in red and yellow, even after our searching has ended.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next we have the `search_for()`function that does the actual searching. The
    code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This part of code is the heart of the search function. It searches through the
    entire document using the `while True` loop, breaking out of the loop only if
    no more text items remain to be searched.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code first removes any previous search-related `match` tags as we do not
    want to append the results of the new search to previous search results. The function
    uses the `search()` method provided in Tkinter on the Text widget. The `search()`
    function takes the following arguments:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The method returns the starting position of the first match. We store it in
    a variable with the name `pos` and also calculate the position of the last character
    in the matched word and store it in the variable `lastpos`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For every search match that it finds, it adds a tag named `match` to the range
    of text starting from the first position to the last position. After every match,
    we set the value of `pos` to be equal to `lastpos`. This ensures that the next
    search starts after `lastpos`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop also keeps track of the number of matches using the count variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the loop, the tag `match` is configured to be of a red font color and
    with a background of yellow. The last line of this function updates the title
    of the **Find** window with the number of matches found.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of event bindings, interaction occurs between your input devices
    (keyboard/mouse) and your application. In addition to event binding, Tkinter also
    supports protocol handling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The term "protocol" means the interaction between your application and the
    window manager. An example of a protocol is `WM_DELETE_WINDOW`, which handles
    the `close` window event for your window manager. Tkinter lets you override these
    protocols handlers by mentioning your own handler for the root or Toplevel widget.
    To override our window exit protocol, we use the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you add this command, Tkinter bypasses protocol handling to your specified
    callback/handler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations! In this iteration, we have completed coding the Select All
    and Find functionality into our program.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we have been introduced to indexing and tagging—two very powerful
    concepts associated with many Tkinter widgets. You will find yourself using these
    two concepts all the time in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous code, we used a line that reads: `t2.transient(root)`. Let''s
    understand what it means here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter supports four types of Toplevel windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main Toplevel window**: These are the ones that we have constructed so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child Toplevel window**: These are the ones that are independent of the root.
    The child Toplevel behaves independently of its root but it gets destroyed if
    its parent is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transient Toplevel window**: This always appears on top of its parent. The
    transient window is hidden if the parent is minimized and it is destroyed if the
    parent is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undecorated Toplevel window**: A Toplevel window is undecorated if it does
    not have a window manager decoration around it. It is created by setting the `overrideredirect`
    flag to `1`. An undecorated window cannot be resized or moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the code in `2.05.py` for a demonstration of all these four types of Toplevel
    windows.
  prefs: []
  type: TYPE_NORMAL
- en: Working with forms and dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal for this iteration is to complete the functioning of the **File** menu
    options of **Open**, **Save**, and **Save As**.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We regularly use the **Open** and **Save** dialogs. They are common across many
    programs. We know how these menu items behave. For instance, when you click on
    the **Open** menu, it opens up a dialog form that lets you traverse to the location
    of the file you want to open. When you select a particular file and click on **Open**,
    it opens up in your editor. Similarly, we have the **Save** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we can implement these dialogs using standard Tkinter widgets, it turns
    out that they are so commonly used that a specific Tkinter module called `tkFileDialog`
    has been included in the standard Python distribution. We will not try to reinvent
    the wheel and in the spirit of less coding, we will use the `tkFileDialog` module
    to implement Open and Save functionality for our text editor as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use the module, we simply import it into the current namespace as given
    in the code file of `2.06.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify the following additional options for `tkFileDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File dialog | Configurable options | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile(mode=''r'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to open, and then it returns the opened file |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename(**options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to open but returns nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile(mode=''w'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to save as, and it returns the opened file |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename(**options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to save as but returns nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory(**options)` | parent, title, initialdir, must exist | Asks
    for a directory, and it returns the filename |'
  prefs: []
  type: TYPE_TB
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us now develop our Open function using `tkDialogBox` (refer to code`2.07.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then modify the **Open** menu to add a `command` callback to this newly-defined
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We import the `tkfileDialog` and `os` modules into the current namespace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We define our function `open_file()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare a variable in the global scope to keep track of the filename of the
    opened file. This is required to keep track of whether or not a file has been
    opened. We need this variable in the global scope, as we want this variable to
    be available to other methods such as `save()` and `save_as()`. Not specifying
    it as global would mean that it is only available within the function. So our
    `save()` and `save_as()` functions would not be able to check if a file is already
    open in the editor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `tkFileDialog.askopenfilename` to fetch the filename of the opened file.
    If the user cancels opening the file or if no file is chosen, the filename returned
    is `None`. In that case we do nothing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If, however, `tkFileDialog` returns a valid filename, we isolate the filename
    using the `os` module and add it as a title of our root window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Text widget already contains some previous text, we delete it all.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then open the given file in read mode and insert all its content into the
    text area.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After this we close the file handle `fh`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a `command` callback to our **File** | **Open** menu item.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes the coding of **File** | **Open**. If you now go and click on
    **File** | **Open** and select a text file and click on **Open**, the text area
    will be populated with the content of the text file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use of global variables is generally considered a bad programming practice because
    it is very difficult to understand a program that uses lots of global variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A global variable can be modified or accessed from many different places in
    the program, and it therefore becomes difficult to remember or work out every
    possible use of the variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A global variable is not subject to any access control, which may pose security
    hazards in certain situations, say when this program is to interact with a third
    party code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, when you work on programs in the procedural style like this one, global
    variables are sometimes unavoidable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An alternative approach to programming involves writing code in a class structure
    (also called **object-oriented programming** ), where a variable can only be accessed
    by members of predefined classes. We will see a lot of examples of object-oriented
    programming in the next project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next we will see how to save a file. There are two components for saving a
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save File
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save As
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the text pad already contains a file, we do not prompt the user for a filename.
    We simply overwrite the contents of the existing file. If there is no filename
    associated with the current content of the text area, we prompt the user with
    a **Save As** dialog. Moreover, if the text area has an open file, and the user
    clicks on **Save As**, we still prompt them with a **Save As** dialog to allow
    them to write the contents to a different filename.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code for Save and Save As is as follows (see the code in `2.07.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `save` function first tries to locate if a file is open in the text area
    using a `try` block. If a file is open, it simply overwrites the content of the
    file with the current content of the text area.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no filename associated with the text area, it simply passes the
    work to our `save_as` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save_as` function opens a dialog using `tkFileDialog.asksaveasfilename`
    and tries to get the filename provided by the user for the given file. If it succeeds,
    it opens the new file in the write mode and writes the content of text into this
    new filename. After writing, it closes the current file handler and changes the
    title of the window to reflect the new filename.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain the new filename, our `save_as` function makes use of the `os` module.
    We, therefore, need to import the `os` module into our namespace before we can
    use it to extract the current filename.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user does not specify a filename or if the user cancels the `save_as`
    operation, it simply ignores the process by using a `pass` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a `command` callback from our existing **Save** and **Save As**
    menu items to invoke these two functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now done adding Save and Save As functionality to our code editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we are at it, let''s complete our functionality of **File** | **New**.
    The code is simple. For this see the code in `2.07.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description for this code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `new_file` function begins by changing the `title` attribute of the root
    window to `Untitled`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It then sets the value of the global variable `filename` to `None`. This is
    important because our `save` and `save_As` functionality uses this global variable
    name to track whether or not the file exists or is new.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our function then deletes all the content of the Text widget, creating a fresh
    document in its place.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add a `command` callback to function from our **File** | **New**
    menu item.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes our coding of **File** | **New** into our code editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we completed coding functionality for the **New**, **Open**,
    **Save**, and **Save As** submenus, present under the **File** menu, for our editor.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we saw how to use the `tkFileDialog` module to achieve certain
    commonly-used features in our program. We also saw how we could use indexing to
    achieve a wide variety of tasks for our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with message boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this iteration, let's complete our code for the **About** and **Help** menus.
    The functionality is simple. When a user clicks on the **Help** or **About** menu,
    it pops up a message window and waits for the user to respond by clicking on a
    button. While we can easily code new Toplevel windows to show our **About** and
    **Help** popup windows, we will instead use a module called `tkMessageBox` to
    achieve this functionality. This is because the module provides an efficient way
    to handle this and similar functionalities with minimal coding.
  prefs: []
  type: TYPE_NORMAL
- en: We will also complete coding the **Exit** button functioning in this iteration.
    Currently, when a user clicks on the **Close** button, the window is simply closed.
    We want to ask the user if they really want to quit or have they clicked on the
    **Close** button accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tkMessageBox` module provides ready-made message boxes to display a wide
    variety of messages in your applications. Some of these functions are `showinfo`,
    `showwarning`, `showerror`, `askquestion`, `askyesno`, `askokcancel`, and `askretryignore`.
    These are illustrated, when in use, in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use the module, we simply import it into the current namespace as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A demonstration of commonly-used functions of `tkMessageBox` is illustrated
    in `2.08.py`. Some common usage patterns are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this module to display messages has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal coding yields functional features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messages can easily be configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages are presented with icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It presents a standardized view of common messages on each platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now code the `about` and `help` functions for our code editor. The use
    case is simple. When a user clicks on the **About** menu, it pops up a message
    with the **OK** button. Similarly, when the user clicks on the **Help** button,
    they are also prompted with a message with the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve these functionalities, we include the following code in our editor.
    (See the code in `2.09.py`)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will look at adding the Quit Confirmation feature. When the user clicks
    on **File** | **Exit**, it prompts an `Ok-Cancel` dialog to confirm the quit action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First we import `tkMessageBox` into our current namespace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define our `about` function to display a `showinfo` message box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we define our `help_box` function to display a `showinfo` message
    box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define the `exit` command with an `askokcancel` box. If the user clicks
    on **OK**, the `exit` command destroys the root window to close the window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then override the close button protocol and redirect it to be handled by
    our definition of the `exit` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add `command` callbacks to **About**, **Help**, and **Exit** menu
    items.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we completed coding the functionality for the **File** |
    **Exit**, **About** | **About**, and **About** | **Help** menu items of our code
    editor. We also saw how to use the `tkMessageBox` module to display different
    message boxes for some commonly-used message formats.
  prefs: []
  type: TYPE_NORMAL
- en: The icon toolbar and View menu functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this iteration, we will add a few more functionalities to our text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing the shortcut icon toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying line numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the current line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the color theme of the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The icon toolbar and View menu functions](img/7941_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the process, we will see more usage of indexing and tagging.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple task first. In this step we add the shortcut icon
    toolbar to our editor. Recall that we have already created a frame to hold these
    toolbar icons. Let's add these icons now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with adding a shortcut icon toolbar. While adding these icons, we
    have followed a convention. All icons have been placed in the `icons` folder.
    Moreover, the icons have been named exactly the same as the corresponding function
    that handles them. Following this convention has enabled us to loop through a
    list, simultaneously applying the icon image to each button and adding the `command`
    callback from within the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code has been placed between the shortcut frame we created earlier to place
    these icons. The code is as follows (refer to the code in `2.10.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have already created a shortcut bar in our first iteration. Now we place
    our code between the lines where we created the frame and line and where we used
    the `pack` manager to display it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a list of icons, taking care to name them exactly as the name of icons.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then iterate through a loop with length equal to the number of items in the
    icons lists. In every loop, we create a Button widget, taking the corresponding
    image and adding the respective `command` callback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before adding the `command` callback, we had to convert the string to an equivalent
    expression using the `eval` command. If we do not apply `eval`, it cannot be applied
    as an expression to our `command` callback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes our coding of the shortcut icon toolbar. Now, if you run the
    code (code `2.10.py`), it should show you a shortcut icon toolbar at the top.
    Moreover, as we have linked each button to a callback, all these shortcut icons
    should work as they should.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let us now work at showing line numbers on the left frame of the Text widget.
    This will require us to do a bit if tweaking of code at various places. So, before
    we start coding, let's take a look at what we are trying to achieve here:![Engage
    Thrusters](img/foo.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **View** menu has a menu item that lets the user choose whether or not to
    show the line numbers. We only want to show line numbers if the option is selected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the option is selected, we need to display line numbers in the left frame
    that we created earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The line number should update every time a user enters a new line, deletes a
    line, cuts or pastes text from the line, performs an undo or redo operation, opens
    an existing file, or clicks on the new menu item. In short, the line number should
    be updated after every activity that may affect line numbers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we need to define a function called `update_line_number()`. This
    function should be called after every keypress, cut, paste, undo, redo, new, and
    open definitions to see if lines have been added or removed from the text area
    and accordingly update the line numbers. We achieve this using these two strategies
    (see the code in `2.10.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bind any keypress events to our `update_line_number()` function:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add a call to our `update_line_number()` function in each of our definitions
    of cut, paste, undo, redo, new, and open
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we define our `update_line_number()` function as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recall that we have assigned a variable `showln` to our menu item earlier:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We first mark the text configuration of label as blank.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `showline` option is set to `1` (that is to say, it has been tick-marked
    in the menu item), we calculate the last line and last column in the text.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a text string consisting of numbers from 1 to the number of the
    last line, each number separated by a line break, `\n`. This string is then added
    to the left label using the `textPad.config()` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If **Show Line Number** is unchecked in the menu, the variable text remains
    blank, thereby displaying no line numbers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we update each of our previously defined cut, paste, undo, redo, new,
    and open functions to invoke the `update_line_number()` function at their end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now done adding the line number functionality to our text editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have noticed an `event=None` argument in our function definition previously
    given. We need to specify this here, because this function can be invoked from
    two places:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the event binding (we bound it to the `<Any-KeyPress>` event)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From other functions such as cut, copy, paste, undo, redo, and more
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the function is invoked from other functions, no arguments are passed.
    However, when the function is invoked from an event binding, the event object
    is passed as parameter. If we do not specify the `event=None` argument and the
    function is invoked from an event binding, it will give the following error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Last in this iteration, we will implement a feature where the user can select
    to add a highlight on the current line. (See the code in `2.10.py`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The idea is simple. We need to locate the line of the cursor and add a tag to
    the line. And finally, we need to configure that tag to appear with a different
    color background to highlight it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recall that we have already provided a menu choice to our user to decide whether
    or not to highlight the current line. We now add a `command` callback from this
    menu item to a function that we define as `toggle_highlight`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define three functions to handle this for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is given as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every time a user checks/unchecks the **View** | **Highlight Current Line**,
    it invokes our function `toggle_highlight`. This function checks if the menu item
    is checked. If it is checked, it invokes the `highlight_line` function, otherwise,
    if the menu item is unchecked, it invokes the undo highlight function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `highlight_line` function simply adds a tag called `active_line` to our
    current line, and after every one second it calls the toggle highlight function
    to check whether the current line should still be highlighted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `undo_highlight` function is invoked when the user unchecks highlighting
    in the **View** menu. Once invoked, it simply removes the `active_line` tag from
    the entire text area.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we configure our tag named `active_line` to be displayed with a different
    background color:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our code, we used the `.widget.after(ms, callback)` handler. Methods like
    this that let us perform some periodic actions are called **alarm handlers** .
    Some commonly used Tkinter alarm handlers include:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`after(delay_ms, callback, args...)`: Registers an alarm callback to be called
    after given number of millisecond'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_cancel(id)`: Cancels the given alarm callback'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_idle(callback, args...)`: Calls back only when there are no more events
    to process in the mainloop, that is, after the system becomes idle'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The info bar is simply a small area at the bottom-right corner of our Text widget,
    which displays the current line number and column number of the position of the
    cursor as shown in the following screenshot:![Engage Thrusters](img/7941_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user can choose to show/hide this info bar from the view menu; refer to
    the code in `2.11.py`. We begin by creating a Label widget within the Text widget
    and pack it in the southeast corner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In many ways, this is similar to displaying the line numbers. Here, too, the
    positions must be calculated after every keypress or after events such as cut,
    paste, undo, redo, new, open, or activities that lead to a change in cursor positions.
    Because this is so similar to our line number code, we will use the existing bindings
    and existing function `update_line_number()` to update this. To do this, we simply
    add two lines to our existing definition of the `update_line_number()` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This keeps updating the label with the line and column of the current cursor
    position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, if the user unchecks the option from the **View** menu, we need to
    hide this widget. We do this by defining a function called `show_info_bar`, which
    depending upon the user-selected choice, either applies `pack` or `pack_forget`
    to the `infobar` label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function is then connected to the existing menu item using a `command`
    callback:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Recall that while defining our **Themes** menu, we defined a color scheme dictionary
    containing the name and hexadecimal color codes as a key-value pair. Actually,
    we need two colors for each theme, one for the background and other for our foreground
    color. Let''s modify our color definition to specify two colors separated by the
    dot character (`.`). Refer to code `2.11.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our theme choice menu has already been defined earlier. Let us now add a `command`
    callback to handle the selected menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s define our `theme` function to handle the changing of themes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function is simple. It picks up the key-value pair from our defined color
    scheme dictionary. It splits the color into its two components and applies one
    color each to the Text widget foreground and background using `widget.config()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now if you select a different color from the **Themes** menu, the background
    and foreground colors change accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We completed coding our shortcut icon toolbar and all functionality of the **View**
    menu in this iteration. In the process we learned how to handle the Checkbutton
    and Radiobutton menu items. We also saw how to make compound buttons, while reinforcing
    several Tkinter options covered in previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling and the context menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this last iteration, we will add the following features to our editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title bar icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us complete our editor in this final iteration.
  prefs: []
  type: TYPE_NORMAL
- en: First we will add the event handling features. We have added the accelerator
    keyboard shortcuts to a large number of our menu items. However, merely adding
    accelerator keys does not add the required functionality. For example, pressing
    the keys *Ctrl* + *N* should create a new file, but simply adding it as an accelerator
    does not make it functional. Let's add these event handling features into our
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that all our functionality is already complete. Now we simply need to map
    the events to their related callbacks. (Refer to the code in `2.12.py.`)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply adding these lines takes care of our event bindings. However, this introduces
    a new issue for us. We have already discussed that event bindings pass the event
    object as a parameter to the bound callback. None of our previous functions are
    equipped to handle the incoming parameters. To do that we need to add the `event=None`
    parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding this optional argument allows us to use these functions with or without
    the event parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, you can also add `textPad.bind (event, lambda e: callback())`to
    ignore the `event` argument altogether.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now you can access these functions using your keyboard shortcuts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we did not bind keyboard shortcuts for cut, copy, and paste. This
    is because the Text widget comes with automatic binding for these events. If you
    add bindings for these events, it will cause cut, copy, and paste events to take
    place twice; once from the built-in widget and once from your own defined event
    handler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next we will add the context menu. But before that, we need to understand what
    a context menu is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The menu that pops up on the right-mouse-button click at the location of the
    mouse cursor is called the **context menu** or the **o**. This is shown in the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941_02_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s code this feature in our text editor. We first define our context menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then bind the right-click of a mouse with a callback named `popup`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define the method `popup`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a final touch to our application, we add a title bar icon for our editor
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Objective Complete – Mini Briefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration we added support for event handling, and added a contextual
    menu and title bar icon to our editor program.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have completed coding our editor in seven iterations. We started by placing
    all widgets on our Toplevel window. We then leveraged some built-in features of
    the Text widget to code some functionality. We learned some very important concepts
    of indexing and tagging, which you will find yourself using frequently in Tkinter
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to use the `tkfileDialog` and `tkMessageBox` modules to quickly
    code some common features in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now completed coding your text editor.
  prefs: []
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s your Hotshot challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to turn this text editor into a Python code editor. Your editor
    should allow the opening and saving of the `.py` file extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file has a `.py` extension, your editor should implement syntax highlighting
    and tab indenting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this can be easily done with external libraries, you should try to implement
    these features on your own using built-in Tkinter options that we have seen so
    far. For hints you can look at the source code of Python's built-in editor IDLE,
    which is written in Tkinter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
