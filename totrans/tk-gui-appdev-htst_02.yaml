- en: Chapter 2. Making a Text Editor like Notepad
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.制作类似记事本的文本编辑器
- en: In the previous project, we got a fairly high-level overview of Tkinter. Now
    that we know some things about Tkinter's core widgets, geometry management, and
    bindings of command and events to callbacks, let us apply our skill to make a
    text editor in this project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，我们得到了Tkinter的一个相当高级的概述。现在，我们了解了一些关于Tkinter核心小部件、几何管理和将命令和事件绑定到回调函数的知识，让我们将这些技能应用到本项目中的文本编辑器制作中。
- en: In the process, we will also take a closer look at individual widgets and learn
    how to tweak those widgets to our custom needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们还将更深入地研究各个小部件，并学习如何调整这些小部件以满足我们的定制需求。
- en: Mission Briefing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: 'In this project, our goal is to build a fully-functional text editing pad with
    some cool nifty features. In its final form, the proposed editor should look as
    follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们的目标是构建一个功能齐全的文本编辑器，并包含一些酷炫的功能。在其最终形态下，所提出的编辑器应该看起来如下：
- en: '![Mission Briefing](img/7941_02_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_02_01.jpg)'
- en: 'Some features we intend to include in the notepad are:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在记事本中包含以下功能：
- en: Creating new documents, opening and editing existing documents, and saving documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新文档、打开和编辑现有文档以及保存文档
- en: Implementing common editing options such as cut, copy, paste, undo, and redo
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现常见的编辑选项，如剪切、复制、粘贴、撤销和重做
- en: Searching within a file for a given search term
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中搜索给定的搜索词
- en: Implementing line numbering and the ability to show/hide line numbers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现行号和显示/隐藏行号的能力
- en: Implementing theme selection to let the user choose custom color themes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主题选择，让用户选择自定义颜色主题
- en: Implementing about and help windows and more
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现关于和帮助窗口等更多功能
- en: Why Is It Awesome?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: In this project you will build you first real and useful project. This project
    will provide you with further insights into the world of Tkinter. It will delve
    deeper into features of some commonly used widgets such as Menu, Menubutton, Text,
    Entry, Checkbutton, and Button widgets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将构建你的第一个真正有用的项目。这个项目将帮助你更深入地了解Tkinter的世界。它将深入探讨一些常用小部件的功能，例如菜单、菜单按钮、文本、输入框、复选框和按钮小部件。
- en: Particularly, we will go into the finer details of the Menu, Menubar, and Text
    widgets. We will also learn to easily handle custom dialogs windows such as the
    Open, Save, Error, Warning, and Info dialogs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将深入了解菜单、菜单栏和文本小部件的细节。我们还将学习如何轻松处理自定义对话框，如打开、保存、错误、警告和信息对话框。
- en: Your Hotshot Objectives
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的热辣目标
- en: 'The project will be developed in seven consecutive iterations. The goals for
    each of these iterations are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将分七个连续迭代进行开发。每个迭代的目的是如下：
- en: Set the user interface using the `pack` geometry using widgets such as Menu,
    Menubar, Text, Entry, Button, Checkbutton, and the like
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pack`几何布局和菜单、菜单栏、文本、输入框、按钮、复选框等小部件设置用户界面
- en: Implement some features using Tkinter's built-in widget options
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter内置的小部件选项实现一些功能
- en: Implement dialogs using `ttk` dialogs and different types of Toplevel widgets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ttk`对话框和不同类型的Toplevel小部件实现对话框
- en: Apply some Text widget features such as text index, tag, and mark to implement
    some custom features
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用一些文本小部件功能，如文本索引、标签和标记，以实现一些自定义功能
- en: Apply some features using the Checkbutton and Radiobutton widgets
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复选框和单选按钮小部件应用一些功能
- en: Apply some custom event binding and protocol binding to make the application
    more user-friendly
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用一些自定义事件绑定和协议绑定，使应用程序更易于使用
- en: Add some miscellaneous features
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些杂项功能
- en: Setting up the widgets
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置小部件
- en: Our first goal is to implement the visual elements of the text editor. As programmers,
    we have all used notepad or some code editor to edit our code. We are mostly aware
    of the common GUI elements of a text editor. So, without much of an introduction,
    let's get started.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是实现文本编辑器的视觉元素。作为程序员，我们所有人都使用过记事本或某些代码编辑器来编辑我们的代码。我们对文本编辑器的常见GUI元素大多有所了解。因此，无需过多介绍，让我们开始吧。
- en: Prepare for Lift Off
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备发射
- en: 'The first phase implements the following six widgets:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段实现了以下六个小部件：
- en: Menu
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单
- en: Menubutton
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单按钮
- en: Label
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Button
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Text
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Scrollbar
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动条
- en: Although we will cover all these in detail, you might find it helpful to look
    at the widget-specific options in the documentation of Tkinter maintained by its
    author Frederick Lundh at [http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将详细涵盖所有这些内容，但你可能会发现查看Tkinter作者Frederick Lundh维护的文档中的小部件特定选项很有帮助。[http://effbot.org/tkinterbook/](http://effbot.org/tkinterbook/)
- en: You might also want to bookmark the official documentation page of Tck/Tk located
    at [http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想将位于[http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/contents.htm)的Tck/Tk官方文档页面添加到书签。
- en: The latter site includes the original Tcl/Tk reference. While it does not relate
    to Python, it provides a more detailed overview of each widget and is an equally
    useful reference. (Remember, Tkinter is just a wrapper around Tk)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 后者网站包括原始Tcl/Tk参考。虽然它与Python无关，但它提供了每个小部件的更详细概述，同样是一个有用的参考。（记住，Tkinter只是Tk的包装器）
- en: 'You can also read the documentation provided with the original source code
    of Tkinter by typing these two lines in the interactive Python shell:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在交互式Python shell中输入以下两行来阅读Tkinter原始源代码提供的文档：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Engage Thrusters
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: In this iteration, we will complete the implementation of most of the visual
    elements of the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，我们将完成程序大多数视觉元素的实现。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using the `pack()` geometry manager to place all the widgets. We
    have chosen the `pack` manager because it is ideally suited for placing widgets
    side by side or in a top-down position. Fortunately in a text editor, we have
    all widgets placed either side-by-side or in top-down locations. Thus, it suits
    to use the `pack` manager. We could have done the same with the `grid` manager
    as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pack()`布局管理器来放置所有小部件。我们选择`pack`管理器，因为它非常适合放置小部件并排或自上而下排列。幸运的是，在文本编辑器中，所有小部件都放置在并排或自上而下的位置。因此，使用`pack`管理器是合适的。我们也可以使用`grid`管理器做到同样的事情。
- en: 'First, we will start by adding the Toplevel window, one that will contain all
    other widgets using the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从添加Toplevel窗口开始，该窗口将包含所有其他小部件，使用以下代码：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this step we add the top menu buttons to our code. See the code in `2.01.py`.
    Menus offer a very compact way of presenting a large number of choices to the
    user without cluttering the interface. Tkinter offers two widgets to handle menus.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将向我们的代码中添加顶级菜单按钮。请参阅`2.01.py`中的代码。菜单提供了一种非常紧凑的方式来向用户展示大量选择，而不会使界面杂乱。Tkinter提供了两个小部件来处理菜单。
- en: The **Menubutton** widget – one that is part of the menu and appears on the
    top of application, which is always visible to the end user
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单按钮**小部件——它是菜单的一部分，出现在应用程序的顶部，始终对最终用户可见'
- en: The **Menu** widget – one that show a list of choices when the user clicks on
    any menu button
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单**小部件——当用户点击任何菜单按钮时显示选择列表的小部件'
- en: '![Engage Thrusters](img/7941_02_02.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![启动推进器](img/7941_02_02.jpg)'
- en: 'To add top-level menu buttons, you use the following command:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要添加顶级菜单按钮，您可以使用以下命令：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, to add a File menu, we use the following code:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要添加文件菜单，我们使用以下代码：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, we add the Edit, View, and About menus at the top. Refer to step
    2 of `2.01.py`.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，我们在顶部添加了编辑、视图和关于菜单。请参考`2.01.py`的第2步。
- en: Most of the Linux platforms support **tear-off menus**. When `tearoff` is set
    to `1` (enabled), the menu appears with a dotted line above the menu options.
    Clicking on the dotted line enables the user to literally tear off or separate
    the menu from the top. However, as this is not a cross-platform feature, we have
    decided to disable tear-off, marking it as `tearoff = 0`.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数Linux平台支持**可撕菜单**。当`tearoff`设置为`1`（启用）时，菜单选项上方会出现一条虚线。点击虚线允许用户实际上撕下或分离菜单与顶部的连接。然而，由于这不是一个跨平台特性，我们决定禁用撕下功能，将其标记为`tearoff
    = 0`。
- en: Now we will add menu items within each of the four menu buttons. As previously
    mentioned, all drop-down options are to be added within the menu instance. In
    our example, we add five drop-down menu choices in the File menu, namely New,
    Open, Save, Save As, and Exit menu items. See step 3 of `2.02.py`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向每个四个菜单按钮中添加菜单项。如前所述，所有下拉选项都应添加在菜单实例中。在我们的示例中，我们在文件菜单中添加了五个下拉菜单选择，即新建、打开、保存、另存为和退出菜单项。请参阅`2.02.py`的第3步。
- en: 'Similarly, we add the following menu choices for other menus:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，我们为其他菜单添加以下菜单选择：
- en: Under **Edit** we have **Undo**, **Redo**, **Cut**, **Copy**, **Paste**, **Find
    All**, and **Select All**
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**编辑**下，我们有**撤销**、**重做**、**剪切**、**复制**、**粘贴**、**查找全部**和**全选**
- en: Under **View** we have **Show Line Number**, **Show Info Bar at Bottom**, **Highlight
    Current Line**, and **Themes**
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**视图**下，我们有**显示行号**、**在底部显示信息栏**、**高亮当前行**和**主题**
- en: Under **About** we have **About** and **Help**
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**关于**下，我们有**关于**和**帮助**
- en: 'The format for adding menu items is as follows:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加菜单项的格式如下：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, you would create the **Undo** menu item using the following syntax:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，您可以使用以下语法创建**撤销**菜单项：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Engage Thrusters](img/7941_02_03.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![启动推进器](img/7941_02_03.jpg)'
- en: Next we will add some labels. We will add the top label, which will later hold
    the shortcut buttons. We will also add a label to the left-hand side to display
    the line numbers:![Engage Thrusters](img/7941_02_05.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将添加一些标签。我们将添加顶部标签，它将后来包含快捷按钮。我们还将添加一个标签到左侧以显示行号：![启动推进器](img/7941_02_05.jpg)
- en: The top label has been marked in a green background and the side label in a
    light cream background for illustration purposes.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明目的，顶部标签被标记为绿色背景，侧标签被标记为浅奶油色背景。
- en: Note
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When working with the `pack` geometry manager, it is important to add widgets
    in the order they will appear. This is because `pack()` uses the concept of available
    space to fit the widgets. If we do not maintain the order, the widgets will start
    occupying places in the order they are introduced. This is why we cannot introduce
    the text widget before the two label widgets as they appear higher up in the display.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用`pack`布局管理器时，按小部件将出现的顺序添加小部件非常重要。这是因为`pack()`使用可用空间的概念来适应小部件。如果我们不保持顺序，小部件将按照它们被引入的顺序开始占用位置。这就是为什么我们不能在两个标签小部件之前引入文本小部件，因为它们在显示中位置更高。
- en: 'Having reserved the space, we can later add shortcut icons or line numbers
    keeping the label as the parent widget. Adding labels is easy, we have done that
    in the past. See the code in `2.02.py` step 4\. The code is as follows:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保留空间后，我们可以在保持标签作为父小部件的同时添加快捷图标或行号。添加标签很容易，我们以前已经这样做过了。请参阅`2.02.py`步骤4中的代码。代码如下：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have applied a colorful background to these two labels for now to differentiate
    it from the body of the Toplevel window.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们已为这两个标签应用了彩色背景，以区分Toplevel窗口的主体。
- en: Lastly, let's add the Text widget and Scrollbar widget to our code. Refer to
    step 5 of the code `2.02.py`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将文本小部件和滚动条小部件添加到我们的代码中。请参考`2.02.py`代码的步骤5。
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code is similar to all other code that we have used so far to instantiate
    widgets. Notice, however, that the scrollbar is configured to `yview` of the Text
    widget and the Text widget is configured to connect to the Scrollbar widget. This
    way, we cross connected both the widgets to each other.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码与我们迄今为止使用过的所有其他代码类似，用于实例化小部件。请注意，然而，滚动条被配置为Text小部件的`yview`，而Text小部件被配置为连接到滚动条小部件。这样，我们就将两个小部件相互交叉连接。
- en: Now when you go down the Text widget, the scrollbar reacts to it. Alternatively,
    when you pull the scrollbar, the Text widget reacts in return.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在当你向下滚动文本小部件时，滚动条会做出反应。或者，当你拉动滚动条时，文本小部件也会做出相应的反应。
- en: 'Some new menu-specific options introduced here are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入了一些新的菜单特定选项，如下所示：
- en: '`accelerator`: This option is used to specify a string, typically the keyboard
    shortcut, which can be used to invoke the menu. The string specified as the accelerator
    appears next to the text of the menu item. Please note that this does not automatically
    create bindings for the keyboard shortcut. We will have to manually set them up,
    as we will see later.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`加速器`: 此选项用于指定一个字符串，通常是键盘快捷键，可以用来调用菜单。作为加速器指定的字符串将出现在菜单项文本旁边。请注意，这不会自动创建键盘快捷键的绑定。我们稍后将手动设置它们。'
- en: '`compound`: Specifying a `compound` option to the menu item lets you add images
    beside the common text label of the menu. A specification such as `Compound=LEFT,
    label= ''mytext'', image=myimage` means that the menu item has a compound label
    comprising of a text label and an image, where the image is to be placed on the
    left-hand side of the text. The images we use here are stored and referenced from
    a separate folder called `icons`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compound`: 将`compound`选项指定给菜单项可以让您在菜单的常见文本标签旁边添加图像。例如，`Compound=LEFT, label=
    ''mytext'', image=myimage`的指定意味着菜单项有一个复合标签，由文本标签和图像组成，其中图像将放置在文本的左侧。我们在这里使用的图像存储和引用自一个名为`icons`的单独文件夹。'
- en: '`underline`: The `underline` option lets you specify the index of a character
    in the menu text to be underlined. The indexing starts at 0, which means that
    specifying `underline=1` underlines the second character of the text. Besides
    underlining, Tkinter also uses it to define the default bindings for keyboard
    traversal of menus. This means that we can select the menu either with the mouse
    pointer, or with the *Alt* + `<character_at_the_underlined_index>` shortcut.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`underline`：`underline`选项允许您指定菜单文本中字符的索引以进行下划线。索引从0开始，这意味着指定`underline=1`将下划线文本的第二个字符。除了下划线外，Tkinter还使用它来定义菜单键盘遍历的默认绑定。这意味着我们可以用鼠标指针或使用*Alt*
    + `<下划线字符索引处的字符>`快捷键来选择菜单。'
- en: 'Therefore, to add the **New** menu item within the **File** menu, we use the
    following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要在**文件**菜单中添加**新**菜单项，我们使用以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similarly, we add menu choices for the **Edit** menu.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们为**编辑**菜单添加菜单选择项。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Menu separators**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**菜单分隔符**'
- en: Occasionally within your menu items, you will come across code such as `mymenu.add_separator()`.
    This widget displays a separator bar and is solely used to organize similar menu
    items in groups, separating groups by horizontal bars.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的菜单项中，您可能会遇到`mymenu.add_separator()`之类的代码。此小部件显示一个分隔条，仅用于将相似的菜单项分组，通过水平条分隔组。
- en: 'Other than the normal menu type that we implement for the **New** and **Edit**
    menus, Tkinter offers three more varieties of menu:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们为**新**和**编辑**菜单实现的常规菜单类型外，Tkinter还提供了三种其他类型的菜单：
- en: '**The Checkbutton menu**: This menu lets you make a yes/no choice by checking/unchecking
    the menu'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框菜单**：此菜单允许您通过勾选/取消勾选菜单来做出是/否的选择'
- en: '**The Radiobutton menu**: This menu lets you choose one from among many different
    options'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单选按钮菜单**：此菜单允许您从许多不同的选项中选择一个'
- en: '**The Cascade menu**: This menu only opens up to show another list of choices'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级联菜单**：此菜单仅展开以显示另一组选择'
- en: 'Our **View** menu demonstrates all these three types of menus as shown in the
    following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**查看**菜单展示了以下截图中的这三种类型的菜单：
- en: '![Engage Thrusters](img/7941_02_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![启动推进器](img/7941_02_04.jpg)'
- en: The first three choices under the **View** menu let the user select whether
    or not they want a certain thing to happen. The user can check/uncheck options
    against these menus and are examples of the Checkbutton menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**查看**菜单下的前三个选项允许用户选择是否希望发生某些操作。用户可以检查/取消检查这些菜单中的选项，它们是复选框菜单的示例。'
- en: The fourth menu choice under **View** menu reads as **Themes**. Hovering over
    this menu opens another list of choices. This is an example of a **Cascade** menu
    as it only serves the purpose of opening up another list of choices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**查看**菜单下的第四个菜单项为**主题**。将鼠标悬停在此菜单上会打开另一组选择。这是一个级联菜单的示例，因为它仅用于打开另一组选择。'
- en: Within the **Cascade** menu, you are presented with a list of choices for your
    editor theme. You can, however, select only one of the themes. Selecting one theme
    unselects any previous selection. This is an example of the Radiobutton menu.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在**级联**菜单中，您将看到一组用于编辑主题的选择。然而，您只能选择其中一个主题。选择一个主题将取消任何之前的选中状态。这是一个单选按钮菜单的示例。
- en: 'An example format for adding these three types of menu is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这三种类型菜单的示例格式如下：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we need to track whether or not a selection has been made, we track
    it by adding a variable that can be `BooleanVar()`, `IntVar()`, or `Stringvar()`
    as we discussed in [Project 1](ch01.html "Chapter 1. Meet Tkinter"), *Meet Tkinter*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要跟踪是否已做出选择，我们通过添加一个变量来跟踪，该变量可以是`BooleanVar()`、`IntVar()`或`StringVar()`，正如我们在[项目1](ch01.html
    "第1章. 认识Tkinter")中讨论的那样，*认识Tkinter*。
- en: For a complete list of configuration options for the Menubutton and Menu widgets,
    refer to the *The basic widget methods* section in [Appendix B](apb.html "Appendix B. Quick
    Reference Sheets"), *Quick Reference Sheets*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Menubutton和Menu小部件的完整配置选项列表，请参阅[附录B](apb.html "附录 B. 快速参考表")中的*基本小部件方法*部分，*快速参考表*。
- en: Objective Complete – Mini Debriefing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: This concludes our first iteration. In this iteration, we have completed laying
    down the majority of visual elements of our text editor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们的第一次迭代结束。在本迭代中，我们已经完成了文本编辑器大多数视觉元素的布局。
- en: Leveraging the power of built-in Text widget options
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用内置Text小部件选项的强大功能
- en: Tkinter's Text widget comes with some handy built-in functionality to handle
    common text-related functions. Let's leverage these functionalities to implement
    some common features in our text editor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的Text小部件自带一些方便的内置功能来处理常见的文本相关功能。让我们利用这些功能来实现我们文本编辑器中的常见功能。
- en: Engage Thrusters
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let's start by implementing the Cut, Copy, and Paste features. We now have our
    editor GUI ready. If you open the program and play with the Text widget, you will
    notice that you can perform basic functions such as cut, copy, and paste in the
    text area using the keyboard shortcuts *Ctrl* + *X*, *Ctrl* + *C*, and *Ctrl*
    + *V*. All these functions exist without us having to add a single line of code
    toward these functionalities.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先实现剪切、复制和粘贴功能。我们现在已经准备好了编辑器GUI。如果你打开程序并玩Text小部件，你会注意到你可以在文本区域使用键盘快捷键*Ctrl*
    + *X*、*Ctrl* + *C*和*Ctrl* + *V*执行基本功能，如剪切、复制和粘贴。所有这些功能都存在，我们不必为这些功能添加任何代码。
- en: Clearly the text widget comes built in with these events. Rather than coding
    these functions ourselves, let's use the built-in functions to add these features
    to our text editor.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，文本小部件内置了这些事件。我们不必自己编写这些函数，而是使用内置函数将这些功能添加到我们的文本编辑器中。
- en: 'The documentation of Tcl/Tk "universal widget methods" tells us that we can
    trigger events without any external stimulus using the following command:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Tcl/Tk "通用小部件方法"的文档告诉我们，我们可以使用以下命令来触发事件，而无需任何外部刺激：
- en: '[PRE10]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To trigger the cut event for our `textPad` widget, all we need is a line of
    code such as the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要触发`textPad`小部件的剪切事件，我们只需要一行代码，如下所示：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s call that using a function cut, and associate it with our cut menu using
    the command callback. See the code `2.03.py` that bears the following code:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们称它为使用一个函数cut，并将其与我们的cut菜单使用命令回调关联起来。参见包含以下代码的`2.03.py`代码：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, we trigger the copy and paste functions from their respective menu
    items.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们从各自的菜单项触发复制和粘贴功能。
- en: 'Next we will move on to implementing the undo and redo features. The Tcl/Tk
    text documentation tells us that the Text widget has an unlimited undo and redo
    mechanism, provided we set the `-undo` option as `true`. To leverage this option,
    let''s first set the Text widget''s `undo` option to `true` as shown in the following
    screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将继续实现撤销和重做功能。Tcl/Tk文本文档告诉我们，Text小部件具有无限撤销和重做机制，前提是我们将`-undo`选项设置为`true`。为了利用此选项，让我们首先将Text小部件的`undo`选项设置为`true`，如下面的截图所示：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now if you open your text editor and try out the undo and redo features using
    *Ctrl* + *Z* and *Ctrl* + *Y*, you will see that they work fine. We now only have
    to associate the events to functions and callback the functions from our **Undo**
    and **Redo** menus respectively. This is similar to what we did for cut, copy,
    and paste. Refer to the code in `2.03.py`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果你打开你的文本编辑器并尝试使用*Ctrl* + *Z*和*Ctrl* + *Y*来尝试撤销和重做功能，你会看到它们工作得很好。我们现在只需要将事件与函数关联起来，并分别从我们的**撤销**和**重做**菜单回调函数。这与我们对剪切、复制和粘贴所做的是类似的。请参阅`2.03.py`中的代码。
- en: Objective Complete – Mini Briefing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简报
- en: Taking advantage of some built-in Text widget options, we have successfully
    implemented the functionality of cut, copy, paste, undo, and redo into our text
    editor with minimal coding.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 利用一些内置Text小部件选项，我们已成功地将剪切、复制、粘贴、撤销和重做功能实现到我们的文本编辑器中，而代码量最小化。
- en: Indexing and tagging
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和标记
- en: While we managed to leverage some built-in functionality to gain a quick advantage,
    we need a more precise control over the text area, so as to bend it to our will.
    This would require the ability to target each character or location of the text
    with precision.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们成功地利用了一些内置功能来获得快速的优势，但我们需要对文本区域有更精确的控制，以便按照我们的意愿弯曲它。这将需要能够以精确的方式定位文本中的每个字符或位置。
- en: Prepare for Lift Off
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: The Text widget offers us the ability to manipulate its content using **index**,
    **tags**, and **mark** , which lets us target a position or place within the text
    area for manipulation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Text小部件为我们提供了使用**索引**、**标记**和**标记**来操作其内容的能力，这使得我们可以定位文本区域中的位置或位置进行操作。
- en: Index
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: Indexing helps you target a particular place within a text. For example, if
    you want to mark a particular word in bold style or in red or in a different font
    size, you can do so if you know the index of the starting point and the index
    of end point to be targeted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以帮助你定位文本中的特定位置。例如，如果你想以粗体样式或红色或不同的字体大小标记一个特定的单词，如果你知道起始点和目标结束点的索引，你可以这样做。
- en: 'The index must be specified in one of the following formats:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 索引必须指定在以下格式之一中：
- en: '| Index format | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 索引格式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x.y` | The *y*th character on line *x*. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `x.y` | 第 *x* 行的第 *y* 个字符。|'
- en: '| `@x,y` | The character that covers the `x`,`y` coordinate within the text''s
    window. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `@x,y` | 在文本窗口内覆盖 `x`、`y` 坐标的字符。|'
- en: '| `end` | The end of the text. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `end` | 文本的末尾。|'
- en: '| `mark` | The character after a named mark. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `mark` | 命名标记后的字符。|'
- en: '| `tag.first` | The first character in the text that has been tagged with a
    given tag. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `tag.first` | 文本中带有给定标签的第一个字符。|'
- en: '| `tag.last` | The last character in the text that has been tagged with a given
    tag. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `tag.last` | 文本中带有给定标签的最后一个字符。|'
- en: '| `selection (SEL_FIRST, SEL_LAST)` | This corresponds to the current selection.
    The constants `SEL_FIRST` and `SEL_LAST` refer to the start position and the end
    position in the selection. Tkinter raises a TclError exception if there is no
    selection. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `selection (SEL_FIRST, SEL_LAST)` | 这对应于当前选择。常量 `SEL_FIRST` 和 `SEL_LAST`
    分别指选择中的起始位置和结束位置。如果没有任何选择，Tkinter 会引发 TclError 异常。|'
- en: '| `windowname` | The position of the embedded window whose name is `windowname`.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `windowname` | 嵌入窗口的名称为 `windowname` 的位置。|'
- en: '| `imagename` | The position of the embedded image with the name `imageName`.
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `imagename` | 嵌入图像的名称为 `imageName` 的位置。|'
- en: '| `INSERT` | The position of the insertion cursor. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `INSERT` | 插入光标的位置。|'
- en: '| `CURRENT` | The position of the character closest to the mouse pointer. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `CURRENT` | 鼠标指针最近的位置的字符。|'
- en: 'Indices can be further manipulated using modifiers and submodifiers. Some examples
    of modifiers and submodifers are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以使用修饰符和子修饰符进一步操作。以下是一些修饰符和子修饰符的示例：
- en: '`end - 1 chars` or `end - 1 c` refers to the index of one character before
    the end'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end - 1 chars` 或 `end - 1 c` 指的是末尾前一个字符的索引'
- en: '`insert +5lines` refers to the index of five lines ahead of the insertion cursor'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert +5lines` 指的是插入光标前方五行的索引'
- en: '`insertwordstart - 1 c` refers to the character just before the first one in
    the word containing the insertion cursor'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertwordstart - 1 c` 指的是包含插入光标的第一字的字符之前'
- en: '`end linestart` refers to the index of the line start of the end line'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end linestart` 指的是末尾行起始的索引'
- en: 'Indexes are often used as arguments to functions. For example, refer to the
    following list:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 索引通常用作函数的参数。例如，参考以下列表：
- en: '`text.delete(1.0,END)`: This means you can delete from line 1, column 0 up
    till the end'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text.delete(1.0,END)`: 这意味着您可以从第 1 行第 0 列删除到末尾'
- en: '`text.get(0.0, END)`: This gets the content from 0.0 up till the end'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text.get(0.0, END)`: 这将获取从 0.0 到末尾的内容'
- en: '`text.delete(insert-1c, INSERT)`: This deletes one character at the insertion
    cursor'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text.delete(insert-1c, INSERT)`: 这将在插入光标处删除一个字符'
- en: Tags
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: Tags are used to annotate text with an identification string that can then be
    used to manipulate the tagged text. Tkinter has a built-in tag called **SEL**,
    which is automatically applied to the selected text. In addition to SEL, you can
    define your own tags. A text range can be associated with multiple tags, and the
    same tag can be used for many different text ranges.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 标签用于使用识别字符串注释文本，然后可以使用该字符串来操作标记的文本。Tkinter 有一个内置的标签称为 **SEL**，它自动应用于所选文本。除了
    SEL 之外，您还可以定义自己的标签。文本范围可以与多个标签相关联，相同的标签可以用于许多不同的文本范围。
- en: 'Some examples of tagging are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些标记的示例：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can specify the visual style for a given tag with `tag_config` using options
    such as `background(color)`, `bgstipple (bitmap)`, `borderwidth (distance)`, `fgstipple
    (bitmap)`, `font (font)`, `foreground (color)`, `justify (constant)`, `lmargin1
    (distance)`, `lmargin2 (distance)`, `offset (distance)`, `overstrike (flag)`,
    `relief (constant)`, `rmargin (distance)`, `spacing1 (distance)`, `tabs (string)`,
    `underline (flag)`, and `wrap (constant)`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `tag_config` 选项指定给定标签的视觉样式，例如 `background(color)`、`bgstipple (bitmap)`、`borderwidth
    (distance)`、`fgstipple (bitmap)`、`font (font)`、`foreground (color)`、`justify (constant)`、`lmargin1
    (distance)`、`lmargin2 (distance)`、`offset (distance)`、`overstrike (flag)`、`relief
    (constant)`、`rmargin (distance)`、`spacing1 (distance)`、`tabs (string)`、`underline
    (flag)` 和 `wrap (constant)`。
- en: 'For a complete reference of text indexing and tagging, type the following command
    into your Python interactive shell:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取文本索引和标记的完整参考，请在您的 Python 交互式外壳中输入以下命令：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Engage Thrusters
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Equipped with a basic understanding of indexing and tagging, let's implement
    some more features in our code editor.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基本的索引和标记知识后，让我们在我们的代码编辑器中实现一些更多功能。
- en: The first feature that we will implement is the "Select All" feature. We know
    that Tkinter has a built-in `SEL` tag that applies a selection to a given text
    range. We want to apply this `sel` tag to the complete text contained in our widget.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的第一项功能是“全选”功能。我们知道Tkinter有一个内置的`SEL`标签，它将选择应用于给定的文本范围。我们希望将此`sel`标签应用于我们小部件中包含的完整文本。
- en: 'We simply define a function to handle this. Refer to the code in `2.04.py`
    as shown in the following code snippet:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需定义一个函数来处理这种情况。请参考以下代码片段中的`2.04.py`代码：
- en: '[PRE16]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this we add a callback to our Select All menu item:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此之后，我们向我们的全选菜单项添加了一个回调：
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we are done adding the Select All functionality to our code editor. If
    you now add some text to the text widget and then click on the menu item **select
    all**, it should select the entire text in your editor. Note that we have not
    bound the *Ctrl* + *A* accelerator in the menu options. The keyboard shortcut
    will therefore not work. We will make the `accelerator` function in a separate
    step.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了向我们的代码编辑器添加全选功能。如果你现在向文本小部件中添加一些文本，然后点击菜单项**全选**，它应该选择编辑器中的全部文本。请注意，我们没有在菜单选项中绑定*Ctrl*
    + *A*快捷键。因此，键盘快捷键将不起作用。我们将在单独的步骤中实现`accelerator`函数。
- en: Next, let's complete the functioning of the **Find** menu item.![Engage Thrusters](img/7941_02_06.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们完成**查找**菜单项的功能。![Engage Thrusters](img/7941_02_06.jpg)
- en: Here's a quick summary of the desired functionality. When a user clicks on the
    **Find** menu item, a new Toplevel window opens up. The user enters a search keyword,
    and specifies if the search is to be case-sensitive. When the user clicks on the
    **Find All** button, all matches are highlighted.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个快速的功能总结。当用户点击**查找**菜单项时，会打开一个新的Toplevel窗口。用户输入一个搜索关键字，并指定搜索是否区分大小写。当用户点击**查找全部**按钮时，所有匹配项都会被突出显示。
- en: 'For searching through the document, we will rely on the `text.search()` method.
    The `search` method takes in the following arguments:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于在文档中搜索，我们将依赖于`text.search()`方法。`search`方法接受以下参数：
- en: '[PRE18]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For our editor, we define a function called `on_find` and attach it as a callback
    to our **Find** menu item (refer to the code in `2.04.py`):'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的编辑器，我们定义了一个名为`on_find`的函数，并将其作为回调附加到我们的**查找**菜单项（请参考`2.04.py`中的代码）：
- en: '[PRE19]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then define our function `on_find` as follows (refer to the code in `2.04.py`):'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的函数`on_find`如下（请参考`2.04.py`中的代码）：
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码的描述如下：
- en: When a user clicks on the **Find** menu item, it invokes a callback `on_find`.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**查找**菜单项时，它调用一个回调`on_find`。
- en: The first four lines of the `on_find()` function creates a new Toplevel window,
    adds a title `Find`, specifies it geometry (size, shape, and location), and sets
    it as a transient window. Setting it to transient means that it is always drawn
    on top of its parent or root window. If you uncomment this line and click on the
    root editor window, the **Find** window will go behind the root window.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_find()`函数的前四行创建了一个新的Toplevel窗口，添加了一个标题`查找`，指定了它的几何形状（大小、形状和位置），并将其设置为临时窗口。将其设置为临时窗口意味着它始终位于其父窗口或根窗口之上。如果你取消注释此行并点击根编辑窗口，**查找**窗口将位于根窗口之后。'
- en: The next eight lines of code are pretty self-explanatory in that they set the
    widgets of the **Find** window. It adds the Label, Entry, Button, and Checkbutton
    widgets and provides for two variables, `e` and `c`, to track the value a user
    enters into the Entry widget, and whether or not the user has checked the check
    button. The widgets are arranged using the `grid` geometry manager to fit into
    the **Find** window.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下八行代码相当直观，它们设置了**查找**窗口的控件。它添加了Label、Entry、Button和Checkbutton控件，并为两个变量`e`和`c`提供了跟踪用户输入到Entry控件中的值以及用户是否检查了复选框的功能。这些控件使用`grid`几何管理器排列，以适应**查找**窗口。
- en: The **Find All** button has a `command` option that calls a function, `search_for()`,
    passing the search string as the first argument and whether or not the search
    is to be case-sensitive as its second argument. The third, fourth, and fifth arguments
    pass the Toplevel window, the Text widget, and the Entry widget as parameters.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找全部**按钮有一个`command`选项，它调用一个函数`search_for()`，将搜索字符串作为第一个参数传递，并将搜索是否区分大小写作为第二个参数传递。第三个、第四个和第五个参数将Toplevel窗口、Text小部件和Entry小部件作为参数传递。'
- en: Prior to the `search_for()` method, we override the Close button of the Find
    window and redirect it to a callback named `close_search()`. The `close_search()`
    method is defined within the `on_find()` function. This function takes care of
    removing the tag `match` that was added during the search. If we do not override
    the Close button and remove these tags, our matched string will continue to be
    marked in red and yellow, even after our searching has ended.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`search_for()`方法之前，我们覆盖了查找窗口的关闭按钮，并将其重定向到名为`close_search()`的回调。`close_search()`方法定义在`on_find()`函数中。此函数负责删除在搜索过程中添加的`match`标签。如果我们不覆盖关闭按钮并删除这些标签，即使我们的搜索已经结束，匹配的字符串也会继续用红色和黄色标记。
- en: 'Next we have the `search_for()`function that does the actual searching. The
    code is as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`search_for()`函数，它执行实际的搜索。代码如下：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The description of the code is listed as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This part of code is the heart of the search function. It searches through the
    entire document using the `while True` loop, breaking out of the loop only if
    no more text items remain to be searched.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码是搜索功能的核心。它使用`while True`循环遍历整个文档，只有当没有更多文本项需要搜索时才会退出循环。
- en: 'The code first removes any previous search-related `match` tags as we do not
    want to append the results of the new search to previous search results. The function
    uses the `search()` method provided in Tkinter on the Text widget. The `search()`
    function takes the following arguments:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码首先删除任何先前的搜索相关`match`标签，因为我们不希望将新搜索的结果附加到先前的搜索结果上。该函数使用Tkinter在Text小部件上提供的`search()`方法。`search()`函数接受以下参数：
- en: '[PRE22]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method returns the starting position of the first match. We store it in
    a variable with the name `pos` and also calculate the position of the last character
    in the matched word and store it in the variable `lastpos`.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法返回第一个匹配项的起始位置。我们将其存储在一个名为`pos`的变量中，并计算匹配单词中最后一个字符的位置，并将其存储在变量`lastpos`中。
- en: For every search match that it finds, it adds a tag named `match` to the range
    of text starting from the first position to the last position. After every match,
    we set the value of `pos` to be equal to `lastpos`. This ensures that the next
    search starts after `lastpos`.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于它找到的每个搜索匹配项，它都会在从第一个位置到最后一个位置的文本范围内添加一个名为`match`的标签。每次匹配后，我们将`pos`的值设置为等于`lastpos`。这确保了下一次搜索从`lastpos`之后开始。
- en: The loop also keeps track of the number of matches using the count variable.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环还使用`count`变量跟踪匹配的数量。
- en: Outside the loop, the tag `match` is configured to be of a red font color and
    with a background of yellow. The last line of this function updates the title
    of the **Find** window with the number of matches found.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环外部，`match`标签被配置为红色字体颜色，背景为黄色。此函数的最后一行更新**查找**窗口的标题，显示找到的匹配数量。
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the case of event bindings, interaction occurs between your input devices
    (keyboard/mouse) and your application. In addition to event binding, Tkinter also
    supports protocol handling.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在事件绑定的情况下，您的输入设备（键盘/鼠标）与您的应用程序之间发生交互。除了事件绑定之外，Tkinter还支持协议处理。
- en: 'The term "protocol" means the interaction between your application and the
    window manager. An example of a protocol is `WM_DELETE_WINDOW`, which handles
    the `close` window event for your window manager. Tkinter lets you override these
    protocols handlers by mentioning your own handler for the root or Toplevel widget.
    To override our window exit protocol, we use the following command:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “协议”一词指的是您的应用程序与窗口管理器之间的交互。一个协议的例子是`WM_DELETE_WINDOW`，它处理窗口管理器的`close`窗口事件。Tkinter允许您通过指定根或Toplevel小部件的自己的处理程序来覆盖这些协议处理程序。要覆盖我们的窗口退出协议，我们使用以下命令：
- en: '[PRE23]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you add this command, Tkinter bypasses protocol handling to your specified
    callback/handler.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦添加此命令，Tkinter就会绕过您指定的回调/处理程序进行协议处理。
- en: Objective Complete – Mini Briefing
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简报
- en: Congratulations! In this iteration, we have completed coding the Select All
    and Find functionality into our program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在这个迭代中，我们已经将全选和查找功能编码到我们的程序中。
- en: More importantly, we have been introduced to indexing and tagging—two very powerful
    concepts associated with many Tkinter widgets. You will find yourself using these
    two concepts all the time in your projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们介绍了索引和标签——这两个与许多Tkinter小部件相关的非常强大的概念。您将在您的项目中经常使用这两个概念。
- en: Classified Intel
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类智能
- en: 'In the previous code, we used a line that reads: `t2.transient(root)`. Let''s
    understand what it means here.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用了一条读取为`t2.transient(root)`的行。让我们来理解这里的含义。
- en: 'Tkinter supports four types of Toplevel windows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter支持四种类型的Toplevel窗口：
- en: '**Main Toplevel window**: These are the ones that we have constructed so far.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主Toplevel窗口**：这是我们迄今为止构建的窗口。'
- en: '**Child Toplevel window**: These are the ones that are independent of the root.
    The child Toplevel behaves independently of its root but it gets destroyed if
    its parent is destroyed.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子Toplevel窗口**：这些是独立于根的窗口。子Toplevel窗口独立于其根窗口，但如果其父窗口被销毁，它也会被销毁。'
- en: '**Transient Toplevel window**: This always appears on top of its parent. The
    transient window is hidden if the parent is minimized and it is destroyed if the
    parent is destroyed.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态Toplevel窗口**：这个窗口始终位于其父窗口之上。如果父窗口最小化，瞬态窗口将被隐藏；如果父窗口被销毁，瞬态窗口也将被销毁。'
- en: '**Undecorated Toplevel window**: A Toplevel window is undecorated if it does
    not have a window manager decoration around it. It is created by setting the `overrideredirect`
    flag to `1`. An undecorated window cannot be resized or moved.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未装饰的Toplevel窗口**：如果一个Toplevel窗口周围没有窗口管理器装饰，则称为未装饰的。它通过将`overrideredirect`标志设置为`1`来创建。未装饰的窗口不能调整大小或移动。'
- en: See the code in `2.05.py` for a demonstration of all these four types of Toplevel
    windows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`2.05.py`中的代码，以演示这四种类型的Toplevel窗口。
- en: Working with forms and dialogs
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与表单和对话框一起工作
- en: The goal for this iteration is to complete the functioning of the **File** menu
    options of **Open**, **Save**, and **Save As**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本次迭代的目的是完成**文件**菜单中的**打开**、**保存**和**另存为**选项的功能。
- en: Prepare for Lift Off
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: We regularly use the **Open** and **Save** dialogs. They are common across many
    programs. We know how these menu items behave. For instance, when you click on
    the **Open** menu, it opens up a dialog form that lets you traverse to the location
    of the file you want to open. When you select a particular file and click on **Open**,
    it opens up in your editor. Similarly, we have the **Save** dialog.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用**打开**和**保存**对话框。它们在许多程序中都很常见。我们知道这些菜单项的行为。例如，当你点击**打开**菜单时，它会打开一个对话框，让你导航到你想要打开的文件的位置。当你选择一个特定的文件并点击**打开**时，它会在你的编辑器中打开。同样，我们还有**保存**对话框。
- en: 'While we can implement these dialogs using standard Tkinter widgets, it turns
    out that they are so commonly used that a specific Tkinter module called `tkFileDialog`
    has been included in the standard Python distribution. We will not try to reinvent
    the wheel and in the spirit of less coding, we will use the `tkFileDialog` module
    to implement Open and Save functionality for our text editor as shown in the following
    screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用标准的Tkinter小部件实现这些对话框，但它们被如此频繁地使用，以至于一个名为`tkFileDialog`的特定Tkinter模块已被包含在标准的Python发行版中。我们不会试图重新发明轮子，并且本着少编码的精神，我们将使用`tkFileDialog`模块来实现文本编辑器的打开和保存功能，如下面的截图所示：
- en: '![Prepare for Lift Off](img/7941_02_07.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_02_07.jpg)'
- en: 'To use the module, we simply import it into the current namespace as given
    in the code file of `2.06.py`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模块，我们只需将其导入当前命名空间，如`2.06.py`代码文件中所示：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can specify the following additional options for `tkFileDialog`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为`tkFileDialog`指定以下附加选项：
- en: '| File dialog | Configurable options | Description |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 文件对话框 | 可配置选项 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `askopenfile(mode=''r'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to open, and then it returns the opened file |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfile(mode=''r'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, 和 `multiple` | 询问要打开的文件名，然后返回打开的文件 |'
- en: '| `askopenfilename(**options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to open but returns nothing |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfilename(**options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, 和 `multiple` | 询问要打开的文件名，但不返回任何内容 |'
- en: '| `asksaveasfile(mode=''w'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to save as, and it returns the opened file |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfile(mode=''w'', **options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, 和 `multiple` | 询问要保存的文件名，并返回打开的文件 |'
- en: '| `asksaveasfilename(**options)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, and `multiple` | Asks for a filename
    to save as but returns nothing |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfilename(**options**)` | `parent`, `title`, `message`, `defaultextension`,
    `filetypes`, `initialdir`, `initialfile`, 和 `multiple` | 询问要保存的文件名，但返回空值 |'
- en: '| `askdirectory(**options)` | parent, title, initialdir, must exist | Asks
    for a directory, and it returns the filename |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `askdirectory(**options**)` | `parent`, `title`, `initialdir`, `must exist`
    | 询问目录，并返回文件名 |'
- en: Engage Thrusters
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 然后，我们启动推进器。
- en: 'Let us now develop our Open function using `tkDialogBox` (refer to code`2.07.py`):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在使用`tkDialogBox`（参考代码`2.07.py`）开发我们的打开函数：
- en: '[PRE25]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We then modify the **Open** menu to add a `command` callback to this newly-defined
    method:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们修改**打开**菜单，为此新定义的方法添加一个`command`回调。
- en: '[PRE26]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The description of the code is listed as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We import the `tkfileDialog` and `os` modules into the current namespace.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`tkfileDialog`和`os`模块导入当前命名空间。
- en: We define our function `open_file()`.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了我们的函数`open_file()`。
- en: We declare a variable in the global scope to keep track of the filename of the
    opened file. This is required to keep track of whether or not a file has been
    opened. We need this variable in the global scope, as we want this variable to
    be available to other methods such as `save()` and `save_as()`. Not specifying
    it as global would mean that it is only available within the function. So our
    `save()` and `save_as()` functions would not be able to check if a file is already
    open in the editor.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在全局范围内声明一个变量来跟踪打开文件的文件名。这是为了跟踪文件是否已被打开。我们需要这个变量在全局范围内，因为我们希望这个变量对其他方法如`save()`和`save_as()`可用。如果不指定为全局，则意味着它仅在函数内部可用。所以我们的`save()`和`save_as()`函数将无法检查编辑器中是否已打开文件。
- en: We use `tkFileDialog.askopenfilename` to fetch the filename of the opened file.
    If the user cancels opening the file or if no file is chosen, the filename returned
    is `None`. In that case we do nothing.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`tkFileDialog.askopenfilename`获取打开文件的文件名。如果用户取消打开文件或没有选择文件，返回的文件名是`None`。在这种情况下，我们不做任何事情。
- en: If, however, `tkFileDialog` returns a valid filename, we isolate the filename
    using the `os` module and add it as a title of our root window.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果`tkFileDialog`返回一个有效的文件名，我们使用`os`模块隔离文件名，并将其添加为我们根窗口的标题。
- en: If the Text widget already contains some previous text, we delete it all.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本小部件已经包含一些之前的文本，我们将其全部删除。
- en: We then open the given file in read mode and insert all its content into the
    text area.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们以读取模式打开指定的文件，并将所有内容插入到文本区域中。
- en: After this we close the file handle `fh`.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们关闭文件句柄`fh`。
- en: Finally, we add a `command` callback to our **File** | **Open** menu item.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们向我们的**文件** | **打开**菜单项添加一个`command`回调。
- en: This completes the coding of **File** | **Open**. If you now go and click on
    **File** | **Open** and select a text file and click on **Open**, the text area
    will be populated with the content of the text file.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了**文件** | **打开**的编码。如果你现在去点击**文件** | **打开**，选择一个文本文件并点击**打开**，文本区域将填充文本文件的内容。
- en: Note
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use of global variables is generally considered a bad programming practice because
    it is very difficult to understand a program that uses lots of global variables.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常认为使用全局变量是一种不良的编程实践，因为它很难理解使用大量全局变量的程序。
- en: A global variable can be modified or accessed from many different places in
    the program, and it therefore becomes difficult to remember or work out every
    possible use of the variable.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全局变量可以在程序中的许多不同地方修改或访问，因此很难记住或确定变量的所有可能用途。
- en: A global variable is not subject to any access control, which may pose security
    hazards in certain situations, say when this program is to interact with a third
    party code.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全局变量不受任何访问控制的约束，这可能在某些情况下造成安全风险，例如当此程序与第三方代码交互时。
- en: However, when you work on programs in the procedural style like this one, global
    variables are sometimes unavoidable.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，当你像这样在程序中以过程式风格工作时，全局变量有时是不可避免的。
- en: An alternative approach to programming involves writing code in a class structure
    (also called **object-oriented programming** ), where a variable can only be accessed
    by members of predefined classes. We will see a lot of examples of object-oriented
    programming in the next project.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程的另一种方法是编写类结构中的代码（也称为**面向对象编程**），其中变量只能由预定义类的成员访问。在下一个项目中，我们将看到许多面向对象编程的例子。
- en: 'Next we will see how to save a file. There are two components for saving a
    file:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何保存文件。保存文件有两个组件：
- en: Save File
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Save As
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另存为
- en: If the text pad already contains a file, we do not prompt the user for a filename.
    We simply overwrite the contents of the existing file. If there is no filename
    associated with the current content of the text area, we prompt the user with
    a **Save As** dialog. Moreover, if the text area has an open file, and the user
    clicks on **Save As**, we still prompt them with a **Save As** dialog to allow
    them to write the contents to a different filename.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文本区域已经包含文件，我们不会提示用户输入文件名。我们只是简单地覆盖现有文件的内容。如果文本区域的当前内容没有关联的文件名，我们将使用 **另存为**
    对话框提示用户。此外，如果文本区域有一个打开的文件，并且用户点击 **另存为**，我们仍然会提示他们使用 **另存为** 对话框，以便他们可以将内容写入不同的文件名。
- en: 'The code for Save and Save As is as follows (see the code in `2.07.py`):'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存和另存为的代码如下（请参阅 `2.07.py` 中的代码）：
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The description of the code is listed as follows:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The `save` function first tries to locate if a file is open in the text area
    using a `try` block. If a file is open, it simply overwrites the content of the
    file with the current content of the text area.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save` 函数首先尝试使用 `try` 块定位文本区域是否已打开文件。如果文件已打开，它将简单地用文本区域的当前内容覆盖文件内容。'
- en: If there is no filename associated with the text area, it simply passes the
    work to our `save_as` function.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本区域没有关联的文件名，它将简单地将工作传递给我们的 `save_as` 函数。
- en: The `save_as` function opens a dialog using `tkFileDialog.asksaveasfilename`
    and tries to get the filename provided by the user for the given file. If it succeeds,
    it opens the new file in the write mode and writes the content of text into this
    new filename. After writing, it closes the current file handler and changes the
    title of the window to reflect the new filename.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save_as` 函数使用 `tkFileDialog.asksaveasfilename` 打开一个对话框，并尝试获取用户为给定文件提供的文件名。如果成功，它将以写入模式打开新文件，并将文本内容写入此新文件名。写入后，它关闭当前文件句柄，并将窗口标题更改为反映新文件名。'
- en: To obtain the new filename, our `save_as` function makes use of the `os` module.
    We, therefore, need to import the `os` module into our namespace before we can
    use it to extract the current filename.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取新的文件名，我们的 `save_as` 函数使用了 `os` 模块。因此，在我们能够使用它来提取当前文件名之前，我们需要将 `os` 模块导入到我们的命名空间中。
- en: If the user does not specify a filename or if the user cancels the `save_as`
    operation, it simply ignores the process by using a `pass` command.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户没有指定文件名或用户取消 `save_as` 操作，它将简单地使用 `pass` 命令忽略该过程。
- en: Finally, we add a `command` callback from our existing **Save** and **Save As**
    menu items to invoke these two functions.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们向现有的 **保存** 和 **另存为** 菜单项添加了一个 `command` 回调，以调用这两个函数。
- en: We are now done adding Save and Save As functionality to our code editor.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经完成了向代码编辑器添加保存和另存为功能。
- en: 'While we are at it, let''s complete our functionality of **File** | **New**.
    The code is simple. For this see the code in `2.07.py`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此同时，让我们完成 **文件** | **新建** 的功能。代码很简单。为此，请参阅 `2.07.py` 中的代码：
- en: '[PRE28]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The description for this code is listed as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码的描述如下：
- en: The `new_file` function begins by changing the `title` attribute of the root
    window to `Untitled`.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_file` 函数首先将根窗口的 `title` 属性更改为 `Untitled`。'
- en: It then sets the value of the global variable `filename` to `None`. This is
    important because our `save` and `save_As` functionality uses this global variable
    name to track whether or not the file exists or is new.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它将全局变量 `filename` 的值设置为 `None`。这很重要，因为我们的 `save` 和 `save_As` 功能使用这个全局变量名来跟踪文件是否存在或是否为新文件。
- en: Our function then deletes all the content of the Text widget, creating a fresh
    document in its place.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们的函数删除了 Text 小部件的所有内容，在其位置创建了一个新的文档。
- en: Finally, we add a `command` callback to function from our **File** | **New**
    menu item.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们向 **文件** | **新建** 菜单项添加了一个 `command` 回调函数。
- en: This completes our coding of **File** | **New** into our code editor.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了我们将代码编辑器中的 **文件** | **新建** 的编码。
- en: Objective Complete – Mini Briefing
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简报
- en: In this iteration, we completed coding functionality for the **New**, **Open**,
    **Save**, and **Save As** submenus, present under the **File** menu, for our editor.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们完成了编辑器下 **文件** 菜单中 **新建**、**打开**、**保存** 和 **另存为** 子菜单的功能编码。
- en: More importantly, we saw how to use the `tkFileDialog` module to achieve certain
    commonly-used features in our program. We also saw how we could use indexing to
    achieve a wide variety of tasks for our programs.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们看到了如何使用`tkFileDialog`模块来实现程序中的某些常用功能。我们还看到了如何使用索引来实现我们程序的各种任务。
- en: Working with message boxes
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与消息框一起工作
- en: In this iteration, let's complete our code for the **About** and **Help** menus.
    The functionality is simple. When a user clicks on the **Help** or **About** menu,
    it pops up a message window and waits for the user to respond by clicking on a
    button. While we can easily code new Toplevel windows to show our **About** and
    **Help** popup windows, we will instead use a module called `tkMessageBox` to
    achieve this functionality. This is because the module provides an efficient way
    to handle this and similar functionalities with minimal coding.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，让我们完成**关于**和**帮助**菜单的代码。功能很简单。当用户点击**帮助**或**关于**菜单时，它会弹出一个消息窗口并等待用户通过点击按钮进行响应。虽然我们可以轻松地编写新的Toplevel窗口来显示我们的**关于**和**帮助**弹出窗口，但我们将使用一个名为`tkMessageBox`的模块来实现此功能。这是因为该模块提供了一种以最小编码方式处理此类和类似功能的高效方法。
- en: We will also complete coding the **Exit** button functioning in this iteration.
    Currently, when a user clicks on the **Close** button, the window is simply closed.
    We want to ask the user if they really want to quit or have they clicked on the
    **Close** button accidentally.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在这个迭代中完成**退出**按钮功能的编码。目前，当用户点击**关闭**按钮时，窗口只是简单地关闭。我们希望询问用户他们是否真的想要退出，或者他们是否意外地点击了**关闭**按钮。
- en: Prepare for Lift Off
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'The `tkMessageBox` module provides ready-made message boxes to display a wide
    variety of messages in your applications. Some of these functions are `showinfo`,
    `showwarning`, `showerror`, `askquestion`, `askyesno`, `askokcancel`, and `askretryignore`.
    These are illustrated, when in use, in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkMessageBox`模块提供了现成的消息框，可以在您的应用程序中显示各种消息。其中一些函数是`showinfo`、`showwarning`、`showerror`、`askquestion`、`askyesno`、`askokcancel`和`askretryignore`。以下截图展示了它们在使用时的示例：'
- en: '![Prepare for Lift Off](img/7941_02_08.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_02_08.jpg)'
- en: 'To use the module, we simply import it into the current namespace as shown
    in the following command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模块，我们只需将其导入到当前命名空间中，如下所示：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A demonstration of commonly-used functions of `tkMessageBox` is illustrated
    in `2.08.py`. Some common usage patterns are mentioned as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkMessageBox`的常用功能在`2.08.py`中进行了演示。以下是一些常见的使用模式：'
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using this module to display messages has the following advantages:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模块显示消息有以下优点：
- en: Minimal coding yields functional features
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化编码即可实现功能特性
- en: The messages can easily be configured
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可以轻松配置
- en: Messages are presented with icons
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息带有图标
- en: It presents a standardized view of common messages on each platform
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在每个平台上呈现了常见消息的标准化视图
- en: Engage Thrusters
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let us now code the `about` and `help` functions for our code editor. The use
    case is simple. When a user clicks on the **About** menu, it pops up a message
    with the **OK** button. Similarly, when the user clicks on the **Help** button,
    they are also prompted with a message with the **OK** button.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的代码编辑器编写`about`和`help`函数。用例很简单。当用户点击**关于**菜单时，它会弹出一个带有**OK**按钮的消息。同样，当用户点击**帮助**按钮时，他们也会被提示一个带有**OK**按钮的消息。
- en: To achieve these functionalities, we include the following code in our editor.
    (See the code in `2.09.py`)
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了实现这些功能，我们在编辑器中包含了以下代码。（参见`2.09.py`中的代码）
- en: '[PRE31]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we will look at adding the Quit Confirmation feature. When the user clicks
    on **File** | **Exit**, it prompts an `Ok-Cancel` dialog to confirm the quit action.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨添加**退出确认**功能。当用户点击**文件** | **退出**时，它将弹出一个`Ok-Cancel`对话框以确认退出操作。
- en: '[PRE32]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The description of the code is listed as follows:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: First we import `tkMessageBox` into our current namespace.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将`tkMessageBox`导入到当前命名空间中。
- en: We then define our `about` function to display a `showinfo` message box.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的`about`函数来显示一个`showinfo`消息框。
- en: Similarly, we define our `help_box` function to display a `showinfo` message
    box.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们定义了我们的`help_box`函数来显示一个`showinfo`消息框。
- en: We then define the `exit` command with an `askokcancel` box. If the user clicks
    on **OK**, the `exit` command destroys the root window to close the window.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个带有`askokcancel`框的`exit`命令。如果用户点击**OK**，则`exit`命令销毁根窗口以关闭窗口。
- en: We then override the close button protocol and redirect it to be handled by
    our definition of the `exit` command.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后覆盖了关闭按钮的协议，并将其重定向到我们定义的`exit`命令处理。
- en: Finally, we add `command` callbacks to **About**, **Help**, and **Exit** menu
    items.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们向**关于**、**帮助**和**退出**菜单项添加`command`回调。
- en: Objective Complete – Mini Briefing
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简要说明
- en: In this iteration, we completed coding the functionality for the **File** |
    **Exit**, **About** | **About**, and **About** | **Help** menu items of our code
    editor. We also saw how to use the `tkMessageBox` module to display different
    message boxes for some commonly-used message formats.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们完成了代码编辑器中**文件**|**退出**、**关于**|**关于**和**关于**|**帮助**菜单项的功能编码。我们还看到了如何使用`tkMessageBox`模块来显示不同格式的常用消息框。
- en: The icon toolbar and View menu functions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标工具栏和视图菜单功能
- en: 'In this iteration, we will add a few more functionalities to our text editor:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将向我们的文本编辑器添加更多功能：
- en: Showing the shortcut icon toolbar
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示快捷图标工具栏
- en: Displaying line numbers
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示行号
- en: Highlighting the current line
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高亮当前行
- en: Changing the color theme of the editor
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改编辑器的颜色主题
- en: '![The icon toolbar and View menu functions](img/7941_02_09.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图标工具栏和视图菜单功能](img/7941_02_09.jpg)'
- en: In the process, we will see more usage of indexing and tagging.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将看到更多索引和标记的使用。
- en: Engage Thrusters
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let's start with a simple task first. In this step we add the shortcut icon
    toolbar to our editor. Recall that we have already created a frame to hold these
    toolbar icons. Let's add these icons now.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从一项简单的任务开始。在这个步骤中，我们将快捷图标工具栏添加到我们的编辑器中。回想一下，我们已经创建了一个框架来容纳这些工具栏图标。现在让我们添加这些图标。
- en: Let's start with adding a shortcut icon toolbar. While adding these icons, we
    have followed a convention. All icons have been placed in the `icons` folder.
    Moreover, the icons have been named exactly the same as the corresponding function
    that handles them. Following this convention has enabled us to loop through a
    list, simultaneously applying the icon image to each button and adding the `command`
    callback from within the loop.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加快捷图标工具栏开始。在添加这些图标时，我们已经遵循了一个约定。所有图标都已放置在`icons`文件夹中。此外，图标的命名与处理它们的相应函数完全一致。遵循这个约定使我们能够同时在一个列表中循环，将图标图像应用于每个按钮，并在循环中添加`command`回调。
- en: 'The code has been placed between the shortcut frame we created earlier to place
    these icons. The code is as follows (refer to the code in `2.10.py`):'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码已经被放置在我们之前创建的快捷框架中，用于放置这些图标。代码如下（参考`2.10.py`中的代码）：
- en: '[PRE33]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The description of the code is listed as follows:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We have already created a shortcut bar in our first iteration. Now we place
    our code between the lines where we created the frame and line and where we used
    the `pack` manager to display it.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的第一次迭代中，我们已经创建了一个快捷栏。现在我们将代码放置在我们创建框架和行的行之间，以及我们使用`pack`管理器显示它的地方。
- en: We create a list of icons, taking care to name them exactly as the name of icons.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个图标列表，注意要将其命名为与图标名称完全一致。
- en: We then iterate through a loop with length equal to the number of items in the
    icons lists. In every loop, we create a Button widget, taking the corresponding
    image and adding the respective `command` callback.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过一个长度等于图标列表中项目数量的循环进行迭代。在每次循环中，我们创建一个按钮小部件，获取相应的图像并添加相应的`command`回调。
- en: Before adding the `command` callback, we had to convert the string to an equivalent
    expression using the `eval` command. If we do not apply `eval`, it cannot be applied
    as an expression to our `command` callback.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加`command`回调之前，我们必须使用`eval`命令将字符串转换为等效的表达式。如果我们不应用`eval`，它就不能作为表达式应用于我们的`command`回调。
- en: This completes our coding of the shortcut icon toolbar. Now, if you run the
    code (code `2.10.py`), it should show you a shortcut icon toolbar at the top.
    Moreover, as we have linked each button to a callback, all these shortcut icons
    should work as they should.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了我们快捷图标工具栏的编码。现在，如果您运行代码（代码`2.10.py`），它应该会在顶部显示快捷图标工具栏。此外，由于我们已经将每个按钮链接到回调，所有这些快捷图标都应该按预期工作。
- en: Let us now work at showing line numbers on the left frame of the Text widget.
    This will require us to do a bit if tweaking of code at various places. So, before
    we start coding, let's take a look at what we are trying to achieve here:![Engage
    Thrusters](img/foo.jpg)
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在努力在文本小部件的左侧框架上显示行号。这需要我们在代码的多个地方进行一些调整。因此，在我们开始编码之前，让我们看看我们在这里试图实现什么：![启动推进器](img/foo.jpg)
- en: The **View** menu has a menu item that lets the user choose whether or not to
    show the line numbers. We only want to show line numbers if the option is selected.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**菜单中有一个菜单项，允许用户选择是否显示行号。我们只想在选中选项时显示行号。'
- en: If the option is selected, we need to display line numbers in the left frame
    that we created earlier.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果选中了选项，我们需要在之前创建的左侧框架中显示行号。
- en: The line number should update every time a user enters a new line, deletes a
    line, cuts or pastes text from the line, performs an undo or redo operation, opens
    an existing file, or clicks on the new menu item. In short, the line number should
    be updated after every activity that may affect line numbers.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当用户输入新行、删除行、从行剪切或粘贴文本、执行撤销或重做操作、打开现有文件或点击新菜单项时，行号都应该更新。简而言之，行号应该在可能影响行号的任何活动之后更新。
- en: 'Therefore, we need to define a function called `update_line_number()`. This
    function should be called after every keypress, cut, paste, undo, redo, new, and
    open definitions to see if lines have been added or removed from the text area
    and accordingly update the line numbers. We achieve this using these two strategies
    (see the code in `2.10.py`):'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们需要定义一个名为 `update_line_number()` 的函数。这个函数应该在每次按键、剪切、粘贴、撤销、重做、新建和打开定义之后被调用，以检查文本区域中是否有行被添加或删除，并相应地更新行号。我们通过以下两种策略实现这一点（请参阅
    `2.10.py` 中的代码）：
- en: 'Bind any keypress events to our `update_line_number()` function:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何按键事件绑定到我们的 `update_line_number()` 函数：
- en: '[PRE34]'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add a call to our `update_line_number()` function in each of our definitions
    of cut, paste, undo, redo, new, and open
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的剪切、粘贴、撤销、重做、新建和打开的定义中添加对 `update_line_number()` 函数的调用
- en: 'Finally, we define our `update_line_number()` function as follows:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式定义我们的 `update_line_number()` 函数：
- en: '[PRE35]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The description of the code is listed as follows:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: 'Recall that we have assigned a variable `showln` to our menu item earlier:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，我们之前已经将一个变量 `showln` 分配给了我们的菜单项：
- en: '[PRE36]'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We first mark the text configuration of label as blank.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将标签的文本配置标记为空白。
- en: If the `showline` option is set to `1` (that is to say, it has been tick-marked
    in the menu item), we calculate the last line and last column in the text.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `showline` 选项设置为 `1`（也就是说，在菜单项中勾选了），我们计算文本中的最后一行和最后一列。
- en: We then create a text string consisting of numbers from 1 to the number of the
    last line, each number separated by a line break, `\n`. This string is then added
    to the left label using the `textPad.config()` method.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个由数字组成的文本字符串，从1到最后一行的数字，每个数字之间用换行符 `\n` 分隔。然后，我们使用 `textPad.config()`
    方法将这个字符串添加到左侧标签。
- en: If **Show Line Number** is unchecked in the menu, the variable text remains
    blank, thereby displaying no line numbers.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果菜单中的 **显示行号** 未选中，变量文本保持空白，因此不显示行号。
- en: Finally, we update each of our previously defined cut, paste, undo, redo, new,
    and open functions to invoke the `update_line_number()` function at their end.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将之前定义的剪切、粘贴、撤销、重做、新建和打开函数更新，在它们的末尾调用 `update_line_number()` 函数。
- en: We are now done adding the line number functionality to our text editor.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经完成了向我们的文本编辑器添加行号功能。
- en: Note
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed an `event=None` argument in our function definition previously
    given. We need to specify this here, because this function can be invoked from
    two places:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们之前给出的函数定义中的 `event=None` 参数。我们需要在这里指定它，因为这个函数可以从两个地方调用：
- en: From the event binding (we bound it to the `<Any-KeyPress>` event)
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从事件绑定（我们将其绑定到 `<Any-KeyPress>` 事件）
- en: From other functions such as cut, copy, paste, undo, redo, and more
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自其他函数，如剪切、复制、粘贴、撤销、重做等
- en: 'When the function is invoked from other functions, no arguments are passed.
    However, when the function is invoked from an event binding, the event object
    is passed as parameter. If we do not specify the `event=None` argument and the
    function is invoked from an event binding, it will give the following error:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数从其他函数调用时，不传递任何参数。然而，当函数从事件绑定调用时，事件对象作为参数传递。如果我们不指定 `event=None` 参数，并且函数从事件绑定调用，它将给出以下错误：
- en: '[PRE37]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Last in this iteration, we will implement a feature where the user can select
    to add a highlight on the current line. (See the code in `2.10.py`)
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个迭代的最后，我们将实现一个功能，允许用户选择在当前行添加高亮。（请参阅 `2.10.py` 中的代码）
- en: The idea is simple. We need to locate the line of the cursor and add a tag to
    the line. And finally, we need to configure that tag to appear with a different
    color background to highlight it.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个想法很简单。我们需要定位光标所在的行并给该行添加一个标签。最后，我们需要配置这个标签以不同的颜色背景显示，以突出显示。
- en: 'Recall that we have already provided a menu choice to our user to decide whether
    or not to highlight the current line. We now add a `command` callback from this
    menu item to a function that we define as `toggle_highlight`:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，我们已经为用户提供了一个菜单选项来决定是否突出显示当前行。现在，我们将从这个菜单项添加一个`command`回调到一个我们定义的`toggle_highlight`函数：
- en: '[PRE38]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We define three functions to handle this for us:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了三个函数来帮我们处理这个问题：
- en: '[PRE39]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The description of the code is given as follows:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Every time a user checks/unchecks the **View** | **Highlight Current Line**,
    it invokes our function `toggle_highlight`. This function checks if the menu item
    is checked. If it is checked, it invokes the `highlight_line` function, otherwise,
    if the menu item is unchecked, it invokes the undo highlight function.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次用户勾选/取消勾选**视图** | **突出显示当前行**时，都会调用我们的`toggle_highlight`函数。这个函数检查菜单项是否被勾选。如果被勾选，它调用`highlight_line`函数；否则，如果菜单项未被勾选，它调用撤销突出显示的函数。
- en: Our `highlight_line` function simply adds a tag called `active_line` to our
    current line, and after every one second it calls the toggle highlight function
    to check whether the current line should still be highlighted.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`highlight_line`函数简单地将一个名为`active_line`的标签添加到当前行，并且每过一秒钟它调用切换突出显示的函数来检查当前行是否应该仍然被突出显示。
- en: Our `undo_highlight` function is invoked when the user unchecks highlighting
    in the **View** menu. Once invoked, it simply removes the `active_line` tag from
    the entire text area.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在**视图**菜单中取消勾选突出显示时，会调用我们的`undo_highlight`函数。一旦被调用，它简单地从整个文本区域中移除`active_line`标签。
- en: 'Finally, we configure our tag named `active_line` to be displayed with a different
    background color:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们配置我们的标签`active_line`以不同的背景颜色显示：
- en: '[PRE40]'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In our code, we used the `.widget.after(ms, callback)` handler. Methods like
    this that let us perform some periodic actions are called **alarm handlers** .
    Some commonly used Tkinter alarm handlers include:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用了`.widget.after(ms, callback)`处理程序。这种让我们执行一些周期性操作的方法被称为**闹钟处理程序**。一些常用的Tkinter闹钟处理程序包括：
- en: '`after(delay_ms, callback, args...)`: Registers an alarm callback to be called
    after given number of millisecond'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after(delay_ms, callback, args...)`: 在给定毫秒数后注册一个闹钟回调'
- en: '`after_cancel(id)`: Cancels the given alarm callback'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_cancel(id)`: 取消给定的闹钟回调'
- en: '`after_idle(callback, args...)`: Calls back only when there are no more events
    to process in the mainloop, that is, after the system becomes idle'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_idle(callback, args...)`: 只有在主循环中没有更多事件要处理时才调用回调，即系统空闲后'
- en: The info bar is simply a small area at the bottom-right corner of our Text widget,
    which displays the current line number and column number of the position of the
    cursor as shown in the following screenshot:![Engage Thrusters](img/7941_02_11.jpg)
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信息栏只是Text小部件右下角的一个小区域，显示光标位置的当前行号和列号，如下面的截图所示：![Engage Thrusters](img/7941_02_11.jpg)
- en: The user can choose to show/hide this info bar from the view menu; refer to
    the code in `2.11.py`. We begin by creating a Label widget within the Text widget
    and pack it in the southeast corner.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户可以选择从视图菜单中显示/隐藏这个信息栏；请参考`2.11.py`中的代码。我们首先在Text小部件内创建一个Label小部件，并将其打包在东南角。
- en: '[PRE41]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In many ways, this is similar to displaying the line numbers. Here, too, the
    positions must be calculated after every keypress or after events such as cut,
    paste, undo, redo, new, open, or activities that lead to a change in cursor positions.
    Because this is so similar to our line number code, we will use the existing bindings
    and existing function `update_line_number()` to update this. To do this, we simply
    add two lines to our existing definition of the `update_line_number()` function:'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在很多方面，这与显示行号类似。在这里，同样需要在每次按键或剪切、粘贴、撤销、重做、新建、打开或其他导致光标位置变化的操作之后计算位置。因为这与我们的行号代码非常相似，我们将使用现有的绑定和现有的`update_line_number()`函数来更新这个功能。为此，我们只需在我们的`update_line_number()`函数的定义中添加两行代码：
- en: '[PRE42]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This keeps updating the label with the line and column of the current cursor
    position.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会持续更新标签，显示当前光标位置的行和列。
- en: Finally, if the user unchecks the option from the **View** menu, we need to
    hide this widget. We do this by defining a function called `show_info_bar`, which
    depending upon the user-selected choice, either applies `pack` or `pack_forget`
    to the `infobar` label.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果用户从 **View** 菜单中取消选中选项，我们需要隐藏这个小部件。我们通过定义一个名为 `show_info_bar` 的函数来实现这一点，该函数根据用户选择的选项，要么应用
    `pack`，要么应用 `pack_forget` 到 `infobar` 标签。
- en: '[PRE43]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This function is then connected to the existing menu item using a `command`
    callback:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数随后通过 `command` 回调连接到现有的菜单项：
- en: '[PRE44]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Recall that while defining our **Themes** menu, we defined a color scheme dictionary
    containing the name and hexadecimal color codes as a key-value pair. Actually,
    we need two colors for each theme, one for the background and other for our foreground
    color. Let''s modify our color definition to specify two colors separated by the
    dot character (`.`). Refer to code `2.11.py`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，在定义我们的 **Themes** 菜单时，我们定义了一个包含名称和十六进制颜色代码作为键值对的颜色方案字典。实际上，我们需要为每个主题指定两种颜色，一种用于背景，另一种用于前景颜色。让我们修改我们的颜色定义，以指定由点字符（`.`）分隔的两种颜色。请参考代码
    `2.11.py`：
- en: '[PRE45]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our theme choice menu has already been defined earlier. Let us now add a `command`
    callback to handle the selected menu:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的主题选择菜单已经定义在前面。现在让我们添加一个 `command` 回调来处理选定的菜单：
- en: '[PRE46]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, let''s define our `theme` function to handle the changing of themes:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，让我们定义我们的 `theme` 函数来处理主题的更改：
- en: '[PRE47]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The function is simple. It picks up the key-value pair from our defined color
    scheme dictionary. It splits the color into its two components and applies one
    color each to the Text widget foreground and background using `widget.config()`.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数很简单。它从我们定义的颜色方案字典中获取键值对。它将颜色分成两个组成部分，并使用 `widget.config()` 将每种颜色分别应用于 Text
    小部件的前景和背景。
- en: Now if you select a different color from the **Themes** menu, the background
    and foreground colors change accordingly.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果您从 **Themes** 菜单中选择不同的颜色，背景和前景颜色将相应地改变。
- en: Objective Complete – Mini Briefing
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简报
- en: We completed coding our shortcut icon toolbar and all functionality of the **View**
    menu in this iteration. In the process we learned how to handle the Checkbutton
    and Radiobutton menu items. We also saw how to make compound buttons, while reinforcing
    several Tkinter options covered in previous sections.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们完成了快捷图标工具栏的编码，以及 **View** 菜单的所有功能。在这个过程中，我们学习了如何处理 Checkbutton 和 Radiobutton
    菜单项，还看到了如何制作复合按钮，同时强化了之前章节中涵盖的几个 Tkinter 选项。
- en: Event handling and the context menu
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理和上下文菜单
- en: 'In this last iteration, we will add the following features to our editor:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次最后的迭代中，我们将向我们的编辑器添加以下功能：
- en: Event handling
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: The context menu
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文菜单
- en: The title bar icon
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题栏图标
- en: Engage Thrusters
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let us complete our editor in this final iteration.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这次最后的迭代中完成我们的编辑器。
- en: First we will add the event handling features. We have added the accelerator
    keyboard shortcuts to a large number of our menu items. However, merely adding
    accelerator keys does not add the required functionality. For example, pressing
    the keys *Ctrl* + *N* should create a new file, but simply adding it as an accelerator
    does not make it functional. Let's add these event handling features into our
    code.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加事件处理功能。我们已经将加速器键盘快捷键添加到我们大量菜单项中。然而，仅仅添加加速键并不能添加所需的功能。例如，按下 *Ctrl* +
    *N* 应该创建一个新文件，但仅仅将其添加为加速键并不能使其生效。让我们将这些事件处理功能添加到我们的代码中。
- en: Note
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all our functionality is already complete. Now we simply need to map
    the events to their related callbacks. (Refer to the code in `2.12.py.`)
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们所有的功能已经完成。现在我们只需要将事件映射到它们相关的回调函数上。（参考 `2.12.py` 中的代码。）
- en: '[PRE48]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Simply adding these lines takes care of our event bindings. However, this introduces
    a new issue for us. We have already discussed that event bindings pass the event
    object as a parameter to the bound callback. None of our previous functions are
    equipped to handle the incoming parameters. To do that we need to add the `event=None`
    parameter.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单地添加这些行就处理了我们的事件绑定。然而，这给我们带来了一个新的问题。我们已经讨论过，事件绑定将事件对象作为参数传递给绑定的回调函数。我们之前的所有函数都没有配备处理传入参数的能力。为了做到这一点，我们需要添加
    `event=None` 参数。
- en: Adding this optional argument allows us to use these functions with or without
    the event parameter.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加这个可选参数允许我们使用这些函数，无论是否有事件参数。
- en: 'Alternatively, you can also add `textPad.bind (event, lambda e: callback())`to
    ignore the `event` argument altogether.'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '或者，你也可以添加 `textPad.bind (event, lambda e: callback())` 来完全忽略 `event` 参数。'
- en: Now you can access these functions using your keyboard shortcuts.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以通过键盘快捷键访问这些功能。
- en: Note that we did not bind keyboard shortcuts for cut, copy, and paste. This
    is because the Text widget comes with automatic binding for these events. If you
    add bindings for these events, it will cause cut, copy, and paste events to take
    place twice; once from the built-in widget and once from your own defined event
    handler.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们没有为剪切、复制和粘贴绑定键盘快捷键。这是因为文本小部件自带对这些事件的自动绑定。如果您为这些事件添加绑定，将会导致剪切、复制和粘贴事件发生两次；一次来自内置小部件，一次来自您自己定义的事件处理器。
- en: Next we will add the context menu. But before that, we need to understand what
    a context menu is.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加上下文菜单。但在那之前，我们需要了解上下文菜单是什么。
- en: 'The menu that pops up on the right-mouse-button click at the location of the
    mouse cursor is called the **context menu** or the **o**. This is shown in the
    following screenshot:'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在鼠标光标位置右键单击弹出的菜单称为**上下文菜单**或**o**。这在上面的屏幕截图中显示：
- en: '![Engage Thrusters](img/7941_02_12.jpg)'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![启动推进器](img/7941_02_12.jpg)'
- en: 'Let''s code this feature in our text editor. We first define our context menu:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在文本编辑器中编码这个功能。我们首先定义我们的上下文菜单：
- en: '[PRE49]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We then bind the right-click of a mouse with a callback named `popup`:'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们然后将鼠标右键与名为`popup`的回调函数绑定：
- en: '[PRE50]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we define the method `popup`:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们定义了`popup`方法：
- en: '[PRE51]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As a final touch to our application, we add a title bar icon for our editor
    using the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为我们应用程序的最后一笔，我们使用以下代码为编辑器添加了一个标题栏图标：
- en: '[PRE52]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Objective Complete – Mini Briefing
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简要说明
- en: In this iteration we added support for event handling, and added a contextual
    menu and title bar icon to our editor program.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们添加了对事件处理的支持，并为我们的编辑程序添加了上下文菜单和标题栏图标。
- en: Mission Accomplished
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: We have completed coding our editor in seven iterations. We started by placing
    all widgets on our Toplevel window. We then leveraged some built-in features of
    the Text widget to code some functionality. We learned some very important concepts
    of indexing and tagging, which you will find yourself using frequently in Tkinter
    projects.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了编辑器的七次迭代编码。我们首先将所有小部件放置在我们的Toplevel窗口中。然后我们利用文本小部件的一些内置功能来编码一些功能。我们学习了索引和标记的一些非常重要的概念，您将在Tkinter项目中经常使用到这些概念。
- en: We also saw how to use the `tkfileDialog` and `tkMessageBox` modules to quickly
    code some common features in our programs.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用`tkfileDialog`和`tkMessageBox`模块来快速在我们的程序中编码一些常见功能。
- en: Congratulations! You have now completed coding your text editor.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已经完成了文本编辑器的编码。
- en: A Hotshot Challenge
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热身挑战
- en: 'Here''s your Hotshot challenge:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的热身挑战：
- en: Your goal is to turn this text editor into a Python code editor. Your editor
    should allow the opening and saving of the `.py` file extension.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的目标是将这个文本编辑器转变为一个Python代码编辑器。您的编辑器应该允许打开和保存`.py`文件扩展名。
- en: If the file has a `.py` extension, your editor should implement syntax highlighting
    and tab indenting.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件具有`.py`扩展名，您的编辑器应该实现语法高亮和制表符缩进。
- en: While this can be easily done with external libraries, you should try to implement
    these features on your own using built-in Tkinter options that we have seen so
    far. For hints you can look at the source code of Python's built-in editor IDLE,
    which is written in Tkinter.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这可以通过外部库轻松完成，但您应该尝试使用我们迄今为止看到的内置Tkinter选项来自己实现这些功能。如果您需要提示，可以查看Python内置编辑器IDLE的源代码，它是用Tkinter编写的。
