<html><head></head><body>
        

                            
                    <h1 class="header-title">Signals, Slots, and Event Handlers</h1>
                
            
            
                
<p class="mce-root">In the previous chapters of this book, we covered the graphical components of the GUI application, along with an explanation of some additional functionality related to using data. However, the Qt library has a very important communicative component that realizes communication between the user and the application as a result of clicking buttons, hovering labels, dragging elements, selecting the options of the boxes, and many more choices as well. In <a href="fa7d3424-739c-4d6b-bb72-912bab24d02c.xhtml"/><a href="fa7d3424-739c-4d6b-bb72-912bab24d02c.xhtml">Chapter 10</a>, <em>Graphics Representation</em>, we introduced the <kbd>QObject</kbd> class of the Qt library that realizes functionality and is one of the base classes that facilitates communication between objects. This behavior characterizes the main target of the GUI application and needs to be learned. </p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>The signals and slots mechanism</li>
<li>Events and event handlers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Signals and slots</h1>
                
            
            
                
<p>Usually, the toolkits and frameworks that are used to develop graphical applications use mechanisms for communication known as <strong>callbacks</strong>. This method sends a callback pointer of some function to another function for the process that calls the callback if needed. The Qt library has an alternative to callbacks in the form of the signals and slots mechanism. This technique is used for communication between objects. The signal can be emitted by the object; for example, the button is clicked (signal) and calls the function (slot) in response to a particular signal.</p>
<p>We can describe the signals and slots mechanism of the Qt library as follows: all the classes that inherit from the <kbd>QObject</kbd> class in the inheritance scheme can contain signals and slots. This mechanism is known as being <strong>type-safe</strong>. The signatures of a signal must match the signatures of the receiving slots, and they can take any number of arguments of any type and still be type-safe. </p>
<p>Some of the basic signal/slot features are as follows:</p>
<ul>
<li>A signal can be connected to many slots.</li>
<li>A slot can be connected to many signals.</li>
<li>A signal can be connected to another signal.</li>
<li>A signal/slot connection can be synchronous (direct) or asynchronous (queued).</li>
<li>Signal/slot connections can be realized with threads.</li>
</ul>
<p>Now, let's describe signal and slot components separately in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Signals</h1>
                
            
            
                
<p>Signals can be defined as signal actions that are emitted by an object in order to implement a process to ensure a result. For example, when we click the button we want, the <kbd>clicked()</kbd>, <kbd>pressed()</kbd>, or <kbd>triggered()</kbd> signal will have a result in the application, such as a closed window, a change in color, an email being sent, and more. Signals are carried out by the public access functions related to the C++ language representation. In that case, when the signals are emitted, the slots that are connected to these signals are usually executed immediately as a normal function call.</p>
<p>The signals and slots mechanism is completely independent of the GUI event loop, and the code following the <kbd>emit</kbd> statement will be executed only when all slots have to be returned as results. In that case, when several slots are connected to the one signal, these slots will be executed one after the other, depending on how they have been connected. To use these signals, let's describe the basics and create a new signal. As we mentioned earlier in <a href="56109505-f6a3-4d74-96cc-0618c27d0551.xhtml">Chapter 4</a>, <em>Getting Started with PyQt and PySide</em>, the signal declaration entails a number of differences between the PyQt5 and PySide2 bindings:</p>
<ol>
<li>First of all, start from the <kbd>import</kbd> statement and add the following lines to the <kbd>utools.py</kbd> files:</li>
</ol>
<ul>
<li style="padding-left: 30px">In the case of the PyQt5 <kbd>import</kbd> statement, add this to the <kbd>utools.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5.QtCore import pyqtSignal as app_signal<br/>...</pre>
<ul>
<li style="padding-left: 30px">In the case of the PySide2 <kbd>import</kbd> statement, add this to the <kbd>utools.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2.QtCore import Signal as app_signal<br/>...</pre>
<p style="padding-left: 60px">In the context of the application, we now have the imported unbound signals as class attributes. This unbound signal can retrieve the following parameters:</p>
<pre style="padding-left: 60px">app_signal(types, name, revision, arguments)</pre>
<p style="padding-left: 60px">The parameters are defined as follows:</p>
<ul>
<li style="padding-left: 30px"><kbd>types</kbd>: The types that define the signature of this signal, such as <kbd>str</kbd>, <kbd>int</kbd>, <kbd>list</kbd>, or any Python-type object.</li>
<li style="padding-left: 30px"><kbd>name</kbd>: The name of this signal as a keyword argument.</li>
</ul>
<p class="mce-root"/>
<ul>
<li style="padding-left: 30px"><kbd>revision</kbd>: The revision of the signal that is exported to QML as a keyword argument.</li>
<li style="padding-left: 30px"><kbd>arguments</kbd>: The sequence of the names of the arguments for this signal that are exported to QML.</li>
</ul>
<ol start="2">
<li>To bind the signal, we need to reference this as an attribute of an instance of the class, and the Python bindings will automatically bind the instance to the signal in order to create a bound signal. We can do this by adding the following lines to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files. Add the bound signal to the class before the <kbd>__init__()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/><br/>    sig1 = app_signal(int)<br/><br/>    def __init__(self):<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This manner is not accidental and is recommended for the construction of signals in the application classes. Now, we can have the bound signal with an integer as the type parameter. The bound signal has the following methods: </p>
<ul>
<li style="padding-left: 30px"><kbd>sig1.connect(object, type, no_receiver_check=bool)</kbd>: This creates a connection. The methods of this signal connection are defined as follows:</li>
<li style="padding-left: 60px"><kbd>object</kbd>: The bound signal or slot as a Python callable that it is connected to.</li>
<li style="padding-left: 60px"><kbd>type</kbd>: The type of connection (<kbd>QtCore.Qt.ConnectionType</kbd>).</li>
<li style="padding-left: 60px"><kbd>no_receiver_check</kbd>: This suppresses the check that the underlying receiver instance still exists and delivers the signal anyway.</li>
<li style="padding-left: 30px"><kbd>sig1.disconnect([object])</kbd>: This disconnects one or more slots from a signal. The method of the signal disconnection is defined as an <kbd>object</kbd>; this is the bound signal or slot that acts as a Python callable that it is connected to.</li>
<li style="padding-left: 30px"><kbd>sig1.emit(*args)</kbd>: This emits a signal where <kbd>*args</kbd> is an optional sequence of the arguments that will be passed to the slot.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Slots</h1>
                
            
            
                
<p>Slots can be defined as methods that will be processed when signals are emitted and they need to realize some functionality; for example, closing a window using the <kbd>close()</kbd> function, changing the color using the <kbd>setColor(QtGui.QColor("FFFFFF"))</kbd> property, or sending a message using the <kbd>sendmail()</kbd> function of the <kbd>smtplib</kbd> Python standard library module.</p>
<p>The difference between the slots and normal functions is that slots have a special feature in the sense that the signals can be connected to them. In other words, the signal defines that some function will be a slot. In actual fact, the slot can be any Python callable, but in some cases, we can explicitly define the slot and decorate the function. Connecting to the decorated Python method has some advantages in terms of memory usage. We can create a new slot as well as a new signal. For this, we need to add the following lines to the <kbd>import</kbd> statement of the <kbd>u_tools.py</kbd> files:</p>
<ul>
<li>In the case of the PyQt5 <kbd>import</kbd> statement, add this to the <kbd>utools.py</kbd> file:</li>
</ul>
<pre style="padding-left: 60px">...<br/>from PyQt5.QtCore import pyqtSlot as app_slot<br/>...</pre>
<ul>
<li>In the case of the PySide2 <kbd>import</kbd> statement, add this to the <kbd>utools.py</kbd> file:</li>
</ul>
<pre style="padding-left: 60px">...<br/>from PySide2.QtCore import Slot as app_slot<br/>...</pre>
<p>The <kbd>import</kbd> statements are also different. The <kbd>app_slot(types, name, result, revision)</kbd> parameter can be passed to the slot. Its functions can be defined as follows:</p>
<ul>
<li><kbd>types</kbd>: The types that define the signature of this slot, such as <kbd>str</kbd>, <kbd>int</kbd>, <kbd>list</kbd>, or any Python-type object.</li>
<li><kbd>name</kbd>: The name of this slot as a keyword argument.</li>
<li><kbd>result</kbd>: The types of result that define the signature of this slot, such as <kbd>str</kbd>, <kbd>int</kbd>, <kbd>list</kbd>, or any Python-type object.</li>
<li><kbd>revision</kbd>: The revision of the slot that is exported to QML as a keyword argument.</li>
</ul>
<p>These slots are usually decorated in the following manner:</p>
<pre>...<br/>    ...<br/>    @app_slot(int, name='slot_func')<br/>    def slot_func(self, num):<br/>        # Some processing...<br/>    ...<br/>...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Signal-slot connections</h1>
                
            
            
                
<p>As we know, many GUI applications are built using the PyQt/PySide Python bindings of the Qt library. If we review the code of these applications, we will see a difference in style for the signal/slot connection constructions. We need to consider the available constructions in the application. The bound signals have <kbd>connect()</kbd>, <kbd>emit()</kbd>, and <kbd>disconnect()</kbd> methods, which provide the operations with signals and slots. The <kbd>signal()</kbd> attribute, which returns the macro signature of the signal, is also available.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">connect</h1>
                
            
            
                
<p>We can use the <kbd>triggered()</kbd> signal to connect selection options to the slots that provide some functionality for these options. The non-static connections have been used here. For demonstration purposes, however, static construction will also be used. Now, we need to look at the lines in the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> files:</p>
<pre>...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.combox1.activated.connect(self.txt_table)<br/>        self.mb1.triggered.connect(self.files)<br/>        self.mb3.triggered.connect(self.data)<br/>        self.mb4.triggered.connect(self.options)<br/>        ...<br/>        self.push_but1.clicked.connect()<br/>        self.push_but2.clicked.connect(lambda:<br/>                        self.text_edit.setText("HELLO"),<br/>                        QtCore.Qt.QueuedConnection)<br/><br/>...</pre>
<p>Let's consider the lines that are related to the signals. The combobox of the application is used to select an option between <kbd>Text</kbd> and <kbd>Table</kbd>, and is constructed as non-static using the <kbd>activated()</kbd> signal, which signals and calls the slot when the option is activated by hovering and clicking with the mouse. The top-panel menus use the <kbd>triggered()</kbd> signals to connect to the related slots, and are also non-static. The <kbd>Ok</kbd> push button will use <kbd>clicked()</kbd> signals (a non-static construction) to call the lambda function. In other words, the non-static approach can be described using the following syntax:</p>
<pre>object.signal.connect(SLOT, type=QtCore.Qt.ConnectionType)</pre>
<p>Here, <kbd>object</kbd> is a widget or another signal, <kbd>signal</kbd> is an available signal or a constructed one, the <kbd>connect()</kbd> method connects to the slot, and <kbd>SLOT</kbd> is a function/method or Python callable. The <kbd>type</kbd> parameter describes the type of connection that will be used. The following types of connection are available: </p>
<ul>
<li><kbd>QtCore.Qt.AutoConnection</kbd>—<kbd>0</kbd>: This is the default type. If the receiver of the signal is in the thread that emits the signal, <kbd>QtCore.Qt.DirectConnection</kbd> will be used. If the threads are different for the receiver and emitted signal, <kbd>QtCore.Qt.QueuedConnection</kbd> will be used.</li>
<li><kbd>QtCore.Qt.DirectConnection</kbd>—<kbd>1</kbd>: This slot is invoked immediately and executed in the thread in the same way as the emitted signal.</li>
<li><kbd>QtCore.Qt.QueuedConnection</kbd>—<kbd>2</kbd>: This slot is invoked when control returns to the event loop for the thread of the receiver, and is executed in the thread of the receiver.</li>
<li><kbd>QtCore.Qt.BlockingQueuedConnection</kbd>—<kbd>3</kbd>: This slot is invoked when control returns to the event loop for the thread of the receiver and is executed in the thread of the receiver, accompanied by blocking the signaling thread. This cannot be used if the threads of the emitted signal and receiver are the same.</li>
<li><kbd>QtCore.Qt.UniqueConnection</kbd>—<kbd>3</kbd>: A unique connection will be used, and another connection will fail if it already exists when the same signal is already connected to the same slot for the same pair of objects.</li>
</ul>
<p>Constructions of the connections using the <kbd>QObject</kbd> class are also available with the following static methods:</p>
<pre>QtCore.QObject.connect(object, SIGNAL, SLOT, type=QtCore.Qt.ConnectionType)</pre>
<p>Here, <kbd>object</kbd> is a widget, signal, and more; <kbd>SIGNAL</kbd>, as <kbd>QtCore.SIGNAL ("signal_name()")</kbd>, is an available signal or a constructed one; and <kbd>SLOT</kbd> is a function/method or Python callable that also can be <strong><kbd>QtCore.SLOT ("slot_name()")</kbd></strong>. The <kbd>type</kbd> parameter describes the type of connection that will be used. The <kbd>connect</kbd> method is used as the static function from the <kbd>QObject</kbd> class of the <kbd>QtCore</kbd> module. </p>
<p>In the case of the static function, we have the following:</p>
<pre>QtCore.QObject.connect(object1, SIGNAL, object2, SLOT, type=QtCore.Qt.ConnectionType)</pre>
<p>Here, <kbd>object1</kbd> (widget, signal, and so on) is a sender of the <kbd>QtCore.QObject</kbd> type, <kbd>SIGNAL</kbd> (<kbd>QtCore.SIGNAL ("signal_name()")</kbd>) is a signal of the <kbd>QtCore.QMetaMethod</kbd> type, <kbd>object2</kbd> (widget, signal, and so on) is a receiver of the <kbd>QtCore.QObject</kbd> type, <kbd>SLOT</kbd> (<kbd>QtCore.SLOT("slot_name()")</kbd>) is a function/method of the <kbd>QtCore.QMetaMethod</kbd> type, and <kbd>type</kbd> is the parameter of the connection that will be used.</p>
<p>In actual fact, static constructions with the <kbd>QObject</kbd> class are available with PySide and PySide2, or PyQt4. The PyQt5 binding does not support these constructions and uses the new style of the signals and slots, which was described prior to these static methods. To avoid confusion and preserve the complexity of the material, we will not proceed in this way. In our application, we will use non-static methods to establish a connection between signals and slots.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">emit</h1>
                
            
            
                
<p>In some cases, it is necessary to emit a signal from the application when it's processing. The <kbd>emit()</kbd> method can execute the emission of the signal alongside some related data (optionally) to the receiver between connected signal/slot objects. This is very useful in an application that uses threads to normalize the execution of the process, which will be covered in detail in <a href="0e64461d-9420-4c73-9607-25e90f854793.xhtml">Chapter 16</a>, <em>Threading and Multiprocessing</em>.</p>
<p>Let's consider an example related to the <kbd>emit()</kbd> method, where the application using these various data handling tools begins to work slowly. We will change the pandas tool functions that are used to open 1,000 rows, split this functionality using threads, and manipulate the 1,000,000 row/5 column table that will be written to file. For this, we need to open the <kbd>u_tools.py</kbd> files and add/change the following lines:</p>
<ol>
<li>First of all, we need to add the following lines to the <kbd>import</kbd> section of these files:</li>
</ol>
<ul>
<li style="padding-left: 30px">In the case of the PyQt5 <kbd>u_tools.py</kbd> file, add the following to the <kbd>import</kbd> section:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5.QtCore import QThread<br/>import time<br/>...</pre>
<ul>
<li style="padding-left: 30px">In the case of the PySide2 <kbd>u_tools.py</kbd> file, add the following to the <kbd>import</kbd> section:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2.QtCore import QThread<br/>import time<br/>...</pre>
<ol start="2">
<li>Before the <kbd>UTools</kbd> class, we need to add the classes with threads that will read/write CSV files with pandas.</li>
</ol>
<p style="padding-left: 60px">Add the <kbd>WPandas</kbd> class with the thread to write a CSV file:</p>
<pre style="padding-left: 60px">...<br/>class WPandas(QThread):<br/><br/>    sig1 = app_signal(object, str)<br/><br/>    def __init__(self, parent=None):<br/>        super(WPandas, self).__init__(parent) <br/><br/>    def on_source(self, datas):<br/>        self.datas = datas<br/><br/>    def run(self):<br/>        try:<br/>            import pandas<br/>            uindex = [i for i in range(self.datas[2])]<br/>            udata = {"User_Name": range(0, self.datas[2]),<br/>                     "User_email": range(0, self.datas[2]),<br/>                     "User_password": range(0, self.datas[2]),<br/>                     "User_data": range(0, self.datas[2])}<br/>            df = pandas.DataFrame(udata, columns=self.datas[3],<br/>                             index=uindex, dtype=self.datas[5])<br/>            df.index.name = "rows\columns"<br/>            if self.datas[1] == "csv":<br/>                df.to_csv(self.datas[0])<br/>            if self.datas[1] == "excel":<br/>                df.to_excel(self.datas[0])<br/>            if self.datas[1] == "html":<br/>                df.to_html(self.datas[0])<br/>            if self.datas[1] == "json":<br/>                df.to_json(self.datas[0])<br/>            if self.isFinished():<br/>                self.quit()<br/>        except Exception as err:<br/>            self.sig1.emit('', str(err))<br/>            if self.isFinished():<br/>                self.quit()<br/>...</pre>
<p style="padding-left: 60px">This class includes the <kbd>sig1</kbd> signal, which will emit the string with an error if it occurs.</p>
<ol start="3">
<li>Now, add the <kbd>RPandas</kbd> class with the thread so that you can read CSV files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class RPandas(QThread):<br/><br/>    sig1 = app_signal(object, str)<br/><br/>    def __init__(self, parent=None):<br/>        super(RPandas, self).__init__(parent)<br/><br/>    def on_source(self, datas):<br/>        self.datas = datas<br/><br/>    def run(self):<br/>        try:<br/>            import pandas<br/>            if self.datas[1] == "csv":<br/>                df = pandas.read_csv(self.datas[0],<br/>                                     chunksize=self.datas[6],<br/>                                     engine=self.datas[4]) <br/>            if self.datas[1] == "excel":<br/>                df = pandas.read_excel(self.datas[0]) <br/>            if self.datas[1] == "html":<br/>                df = pandas.read_html(self.datas[0])<br/>            if self.datas[1]== "json":<br/>                df = pandas.read_json(self.datas[0]) <br/>            pandas.options.display.max_rows = self.datas[5]<br/>            for ch in df:<br/>                self.sig1.emit(ch, '')<br/>                time.sleep(0.1)<br/>            if self.isFinished():<br/>                self.quit()<br/>        except Exception as err:<br/>            self.sig1.emit('', str(err)) <br/>            if self.isFinished():<br/>                self.quit()<br/>...</pre>
<p style="padding-left: 60px">This class includes the <kbd>sig1</kbd> signal, which will emit the <kbd>DataFrame</kbd>, signed with the <kbd>object</kbd> type, with an error, if it exists, of the <kbd>string</kbd> type. The CSV file will be read in chunks that will be emitted in a loop instead of being read all at once. This is done because large-sized files are hard to read and problems may arise when the text is added to the text fields. Because we need to remember that the text edit field is part of another thread – that is, the main GUI thread of the application – each chunk includes 10,000 rows, but only 9 rows of the chunk are displayed. This demonstrates the possibility to work with large datasets, because displaying all of this data in the application text fields can freeze the app.</p>
<p style="padding-left: 60px">In actual fact, this isn't needed because the user doesn't want to read all the rows of the file; they simply want to operate with this data and visualize it; that is key. All of the preceding threads retrieve the data outside the <kbd>on_source()</kbd> function. </p>
<ol start="4">
<li>Now, we need to continue adding/making changes to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files.</li>
</ol>
<p style="padding-left: 60px">Add the following signals before the <kbd>__init__()</kbd> function of the <kbd>UTools</kbd> class:</p>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    <br/>    ...<br/>    pandas_sig1 = app_signal(list)<br/>    pandas_sig2 = app_signal(list)<br/>    <br/>    def __init__(self):<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">This creates the bound signals for communication between the functions of this class and threads. These signals will send lists with parameters to the threads.</p>
<ol start="5">
<li>Now, we need to change the <kbd>pandas_write()</kbd> function, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def pandas_write(self, filename=None, writer="csv",<br/>                               data=None, columns=None,<br/>                               index=None, dtype=object):<br/>        data = 1000000<br/>        index = 1000000<br/>        datas = [filename, writer, data, columns, index, dtype]<br/>        self.pandas_thread1 = WPandas()<br/>        self.pandas_sig1.connect(self.pandas_thread1.on_source)<br/>        self.pandas_sig1.emit(datas)<br/>        self.pandas_thread1.start()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Here, we are replacing the data and index variables in the function. This is optional, and shows that data will be in the range of 0-1,000,000 <kbd>data</kbd>, with a number of rows that equal the 1,000,000 <kbd>index</kbd>. When an instance of the thread is created, the <kbd>pandas_sig1</kbd> signal connects to the <kbd>on_source()</kbd> function of the thread, and then emits the list with data and parameters to the thread for processing.</p>
<ol start="6">
<li>Change the <kbd>pandas_read()</kbd> function, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def pandas_read(self, filename=None, reader="csv", sep=',',<br/>                               delimiter=None, engine='python',<br/>                                        maxrows=9, chunk=10000):<br/>        datas = [filename, reader, sep, delimiter,<br/>                 engine, maxrows, chunk]<br/>        self.pandas_thread2 = RPandas()<br/>        self.pandas_sig2.connect(self.pandas_thread2.on_source)<br/>        self.pandas_sig2.emit(datas)<br/>        self.pandas_thread2.start()<br/>        return self.pandas_thread2<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function creates the instance of the thread, defines the reading parameters, such as filename, reader, and chunk size, connects to the <kbd>on_source()</kbd> function, and emits the parameter as the list. Starting the thread then returns this thread so that it can be freely used.</p>
<p>Now, we need to change the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> files. Let's get started:</p>
<ol>
<li>Change the <kbd>data()</kbd> function where the CSV file is opened with pandas:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "Pandas":<br/>            try:<br/>                pread = self.pandas_read(<br/>                            filename="data/bigtests.csv",<br/>                                   reader="csv", sep=',')<br/>                def to_field(df, er):<br/>                    if er == '':<br/>                        self.text_edit.append(<br/>                                          "\n" + str(df))<br/>                    else:<br/>                        self.stat_bar.showMessage(<br/>                                    self.actx + ' ' + er)<br/>                pread.sig1.connect(<br/>                    to_field, QtCore.Qt.QueuedConnection)<br/>                self.stat_bar.showMessage(<br/>                                   self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                              self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Here, we are adding the <kbd>sig1</kbd> signal of the thread that connects to the slot, as well as a nested <kbd>to_field()</kbd> function for appending chunks of the reading file to the text edit field of the application, or an error to the status bar.</p>
<ol start="2">
<li>The <kbd>user_data4()</kbd> function now appears as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data4(self, uname, umail, upass, udata):<br/>        try:<br/>            ucolumns = ["User_Name", "User_email",<br/>                        "User_password", "User_data"]<br/>            self.pandas_write(filename="data/bigtests.csv",<br/>                            writer="csv", columns=ucolumns)<br/>        except Exception as err:<br/>            self.error = err<br/>    ...<br/>...</pre>
<p>These examples have demonstrated how we can connect the signals to the slots (application functions) and emit various data from/to threads and to/from functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">disconnect</h1>
                
            
            
                
<p>The disconnect method for the signals is straightforward. In some cases, we need to disconnect the signal from a slot, and this is done as follows:</p>
<pre>object.signal.disconnect(SLOT)</pre>
<p>Here, <kbd>object</kbd> is a widget or another signal, <kbd>signal</kbd> is a used signal, and has a <kbd>disconnect</kbd> method, and a <kbd>SLOT</kbd>, which is a function/method or Python callable that is connected to this signal.</p>
<p>This construction disconnects the signal from a connected slot. It should be noted that the construction needs to be the same as what was used with the signal connection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Qt modules</h1>
                
            
            
                
<p>The Qt library provides several classes to realize the additional functionality with signals and slots. These classes are <strong><kbd>QSignalBlocker</kbd></strong>, <kbd>QSignalMapper</kbd>, and <kbd>QSignalTransition</kbd>. All of these are available within the <kbd>QtCore</kbd> module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSignalBlocker</h1>
                
            
            
                
<p>This class realizes an exception-safe wrapper around the <kbd>blockSignals()</kbd> methods, which blocks the signals for an item. Usually, this class can be used instead of the <kbd>blockSignals()</kbd> methods. The declaration syntax of this class is as follows:</p>
<pre><strong>signal_blocker</strong> = QtCore.QSignalBlocker()</pre>
<p>The <kbd>QSignalBlocker</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to changes in functionality:</p>
<p><kbd>signal_blocker.reblock()</kbd>: This reblocks signals that were previously unblocked.</p>
<p><kbd>signal_blocker.unblock()</kbd>: This restores the <kbd>signalsBlocked()</kbd> state to its pre-blocking state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSignalMapper</h1>
                
            
            
                
<p>This class realizes the bundles of the signals from identifiable senders and provides a collection of signals. It re-emits them with <kbd>integer</kbd>, <kbd>string</kbd>, or <kbd>widget</kbd> parameters that correspond to the sender. The declaration syntax of this class is as follows:</p>
<pre><strong>signal_mapper</strong> = QtCore.QSignalMapper()</pre>
<p>The <kbd>QSignalMapper</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions that are related to setting parameters/properties in relation to the signal mapper:</p>
<p><kbd>signal_mapper.setMapping(QtCore.QObject, int)</kbd>: This sets the mapping for the case when the <kbd>map()</kbd> function is signaled from the sender (the first parameter); the signal mapped ID (the second parameter) will be emitted.</p>
<p><kbd>signal_mapper.setMapping(QtCore.QObject, str)</kbd>: This sets the mapping for the case when the <kbd>map()</kbd> function is signaled from the sender (the first parameter); the signal mapped text (the second parameter) will be emitted.</p>
<p><kbd>signal_mapper.setMapping(QtCore.QObject, object)</kbd>: This sets the mapping for the case when the <kbd>map()</kbd> function is signaled from the sender (the first parameter); the signal mapped object (the second parameter) will be emitted.</p>
<p><kbd>signal_mapper.setMapping(QtCore.QObject, QtWidgets.QWidget)</kbd>: This sets the mapping for the case when the <kbd>map()</kbd> function is signaled from the sender (the first parameter); the signal mapped widget (the second parameter) will be emitted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the return of the current values of the signal mapper, changes in functionality, and more:</p>
<p><kbd>signal_mapper.map()</kbd>: This emits signals based on an object that sends signals to it.</p>
<p><kbd>signal_mapper.map(QtCore.QObject)</kbd>: This emits signals based on the sender specified in the parameter.</p>
<p><kbd>signal_mapper.mapping(int)</kbd>: This returns the sender of the <kbd>QtCore.QObject</kbd> type that is associated with the ID specified in the parameter.</p>
<p><kbd>signal_mapper.mapping(str)</kbd>: This returns the sender of the <kbd>QtCore.QObject</kbd> type that is associated with the text specified in the parameter.</p>
<p><kbd>signal_mapper.mapping(object)</kbd>: This returns the sender of the <kbd>QtCore.QObject</kbd> type that is associated with the object specified in the parameter.</p>
<p><kbd>signal_mapper.mapping(QtWidgets.QWidget)</kbd>: This returns the sender of the <kbd>QtCore.QObject</kbd> type that is associated with the widget specified in the parameter.</p>
<p><kbd>signal_mapper.removeMappings(QtCore.QObject)</kbd>: This removes mappings for the sender specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The available signals of the <kbd>QSignalMapper</kbd> class are as follows:</p>
<p><kbd>signal_mapper.mapped(int)</kbd>: This signal is emitted when <kbd>map()</kbd> function is signaled from an object with the ID mapping set; the ID is passed in the parameter.</p>
<p><kbd>signal_mapper.mapped(str)</kbd>: This signal is emitted when <kbd>map()</kbd> function is signaled from an object with the string mapping set; the text is passed in the parameter.</p>
<p><kbd>signal_mapper.mapped(object)</kbd>: This signal is emitted when <kbd>map()</kbd> function is signaled from an object with the object mapping set; the object is passed in the parameter.</p>
<p><kbd>signal_mapper.mapped(QtWidgets.QWidget)</kbd>: This signal is emitted when <kbd>map()</kbd> function is signaled from an object with the widget mapping set; the widget is passed in the parameter.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QSignalTransition</h1>
                
            
            
                
<p>This class realizes a signal transition. The class constructs the new signal transition with the source state, as defined in the parameter. The declaration syntax of this class is as follows:</p>
<pre><strong>signal_transit</strong> = QtCore.QSignalTransition(QtCore.QState)</pre>
<p>The <kbd>QSignalTransition</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions that are related to setting parameters/properties in relation to the signal transition:</p>
<p><kbd>signal_transit.setSenderObject(QtCore.QObject)</kbd>: This sets the sender, specified in the parameter, that will be associated with this signal's transition.</p>
<p><kbd>signal_transit.setSignal(QtCore.QByteArray)</kbd>: This sets the signal, specified in the parameter, that will be associated with this signal's transition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the signal transition, changes in functionality, and more:</p>
<p><kbd>signal_transit.senderObject()</kbd>: This returns the sender of the <kbd>QtCore.QObject</kbd> type that is associated with this signal transition.</p>
<p><kbd>signal_transit.signal()</kbd>: This returns the signal of the <kbd>QtCore.QByteArray</kbd> type that is associated with this signal transition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Events and event handlers</h1>
                
            
            
                
<p>A no less important aspect of the GUI application is the realization of events and event handlers. Events inform the application about things that have happened as a result of inside or outside activity associated with the application's processes. In the Qt library, this behavior is characterized and realized by means of the Qt event system. Through this system, events are objects that are derived from the abstract <kbd>QEvent</kbd> class of the <kbd>QtCore</kbd> module. Events can be handled by any instance of the <kbd>QObject</kbd> subclass. Usually, the events are delivered by calling a virtual function – an event handler – that provides a convenient way to handle an event that's related to the application. The event handlers usually look as follows:</p>
<pre>QEnterEvent </pre>
<p>Here, it uses the <kbd>enterEvent()</kbd> method as an event handler. The Qt framework realizes event handlers for painting, resizing, sending, showing, dropping, the mouse, the keyboard, and more. The following section describes commonly used events and event handlers that can be realized in the GUI application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QEvent</h1>
                
            
            
                
<p>This is the base class of all event classes and provides realization of the event system with the functionality of the special event types. The declaration syntax of this class is as follows:</p>
<pre><strong>event</strong> = QtCore.QEvent(QtCore.QEvent.Type)</pre>
<p>A full list of the available types that can be specified in the parameter can be found in the Qt documentation (<a href="https://doc.qt.io/">https://doc.qt.io</a>). The <kbd>QEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function is related to setting parameters/properties in relation to the event:</p>
<p><kbd>event.setAccepted(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets this event to an accepted state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the event states:</p>
<p><kbd>event.isAccepted()</kbd>: This returns <kbd>True</kbd> if this event is accepted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the event, changes in functionality, and more:</p>
<p><kbd>event.accept()</kbd>: This sets the accept flag of the event object; this event will be accepted.</p>
<p><kbd>event.ignore()</kbd>: This sets the ignore flag of the event object; this event will be ignored.</p>
<p><kbd>event.registerEventType(int)</kbd>: This registers and returns a custom event type, with hints specified in the parameter.</p>
<p><kbd>event.spontaneous()</kbd>: This returns <kbd>True</kbd> if this is a system event (outside of the application).</p>
<p><kbd>event.type()</kbd>: This returns the type of event as a <kbd>QtCore.QEvent.Type</kbd> object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def event(self, event):<br/>    return True</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QEventLoop</h1>
                
            
            
                
<p>This class provides functionality in terms of entering and leaving the event loop. The main event loop is realized when the application is started and moves to the infinite loop. The declaration syntax of this class is as follows:</p>
<pre><strong>event_loop</strong> = QtCore.QEventLoop()</pre>
<p>The <kbd>QEventLoop</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>)  related to the event loop states:</p>
<p><kbd>event.isRunning()</kbd>: This returns <kbd>True</kbd> if this event loop is running, otherwise, it returns false.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the event loop, changes in functionality, and more:</p>
<p><kbd>event_loop.exec_(QtCore.QEventLoop.ProcessEventsFlags)</kbd>: This enters the event loop and begins processing in relation to the flags specified in the parameter. The flags that can be used are as follows:</p>
<ul>
<li><kbd>QtCore.QEventLoop.AllEvents</kbd>: All events will be processed.</li>
<li><strong><kbd>QtCore.QEventLoop.ExcludeUserInputEvents</kbd></strong>: Excludes user input events in processing.</li>
<li><kbd>QtCore.QEventLoop.ExcludeSocketNotifiers</kbd>: Excludes socket notifier events in processing.</li>
<li><kbd>QtCore.QEventLoop.WaitForMoreEvents</kbd>: Processing waits for events if no pending events are available.</li>
</ul>
<p><kbd>event_loop.exit(int)</kbd>: This exits the event loop with the return code that's specified in the parameter. A return code of <kbd>0</kbd> indicates success; other non zero values indicate an error.</p>
<p><kbd>event_loop.processEvents(QtCore.QEventLoop.ProcessEventsFlags)</kbd>: This processes pending events that match flags specified in the parameter.</p>
<p><kbd>event_loop.processEvents(QtCore.QEventLoop.ProcessEventsFlags, int)</kbd>: This processes pending events that match flags (the first parameter) for a maximum time (the second parameter) in milliseconds.</p>
<p><kbd>event_loop.quit()</kbd>: This quits the event loop normally, and is similar to the <kbd>event_loop.exit(0)</kbd> method.</p>
<p><kbd>event_loop.wakeUp()</kbd>: This wakes up the event loop.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QChildEvent</h1>
                
            
            
                
<p>This class realizes the events related to the child objects. The event is sent to the objects when children are added or removed. The declaration syntax of this class is as follows:</p>
<pre><strong>child_event</strong> = QtCore.QChildEvent(QtCore.QEvent.Type, object)</pre>
<p>The available types for this event are as follows:</p>
<ul>
<li><kbd>QtCore.QEvent.ChildAdded</kbd>: A child is added to the object.</li>
<li><kbd>QtCore.QEvent.ChildRemoved</kbd>: A child is removed from the object.</li>
<li><kbd>QtCore.QEvent.ChildPolished</kbd>: A child is polished.</li>
</ul>
<p>The <kbd>QChildEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the event, changes in functionality, and more:</p>
<p><kbd>child_event.added()</kbd>: This returns <kbd>True</kbd> if the type of this event is <kbd>ChildAdded</kbd>.</p>
<p><kbd>child_event.child()</kbd>: This returns a child object of the <kbd>QtCore.QObject</kbd> type that was added or removed.</p>
<p><kbd>child_event.polished()</kbd>: This returns <kbd>True</kbd> if the type of this event is <kbd>ChildPolished</kbd>.</p>
<p><kbd>child_event.removed()</kbd>: This returns <kbd>True</kbd> if the type of this event is <kbd>ChildRemoved</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def childEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QTimerEvent</h1>
                
            
            
                
<p>This class can realize the timer events that send events to the objects at regular intervals. The declaration syntax of this class is as follows:</p>
<pre><strong>timer_event</strong> = QtCore.QTimerEvent(int)</pre>
<p>The unique ID of the timer is specified in the parameter of the event. The <kbd>QTimerEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>This function is related to the returns of the current values of the event:</p>
<p><kbd>timer_event.timerId()</kbd>: This returns the unique ID of the timer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def timerEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QActionEvent</h1>
                
            
            
                
<p>This class provides the events that appear when an action realized with the <kbd>QAction</kbd> class is added, removed, or changed. It is available with items that support action operations, such as <kbd>QMenu</kbd>. The declaration syntax of this class is as follows:</p>
<pre><strong>action_event</strong> = QtGui.QActionEvent(QtCore.QEvent.Type,<br/>                           QtWidgets.QAction, QtWidgets.QAction)</pre>
<p>The first parameter is a type of event, the second is an action, and the third is the previous action that's specified. The available types for this event are as follows:</p>
<ul>
<li><kbd>QtCore.QEvent.ActionChanged</kbd>: Action changed.</li>
<li><kbd>QtCore.QEvent.ActionAdded</kbd>: Action added to the object.</li>
<li><kbd>QtCore.QEvent.ActionRemoved</kbd>: Action removed from the object.</li>
</ul>
<p>The <kbd>QActionEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the event:</p>
<p><kbd>action_event.action()</kbd>: This returns an added, changed, or removed action.</p>
<p><kbd>action_event.before()</kbd>: If the type of action is <kbd>ActionAdded</kbd>, this returns the action that appeared previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def actionEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QDropEvent</h1>
                
            
            
                
<p>This class provides the events that appear when drag and drop actions are completed. It is available with items that support dragging operations such as <kbd>QWidget</kbd> and <kbd>QTextEdit</kbd>. The declaration syntax of this class is as follows:</p>
<pre><strong>drop_event</strong> = QtGui.QDropEvent(QtCore.QPointF, QtCore.Qt.DropActions,<br/>                           QtCore.QMimeData, QtCore.Qt.MouseButtons,<br/>                    QtCore.Qt.KeyboardModifiers, QtCore.QEvent.Drop)</pre>
<p>For the construction of the drop event, the following parameters are used:</p>
<ul>
<li>Position (the first parameter).</li>
<li>Drop actions (the second parameter).</li>
<li>MIME data (the third parameter).</li>
<li>Button states (the fourth parameter).</li>
<li>Keyboard modifiers (the fifth parameter).</li>
<li>Type (the sixth parameter).</li>
</ul>
<p>The <kbd>QDropEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function is related to setting parameters/properties in relation to the drop event:</p>
<p><kbd>drop_event.setDropAction(QtCore.Qt.DropAction)</kbd>: This sets the action, specified in the parameter, that will be used for this event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the drop event, changes in functionality, and more:</p>
<p><kbd>drop_event.acceptProposedAction()</kbd>: This sets the drop action as the proposed action for this event.</p>
<p><kbd>drop_event.dropAction()</kbd>: This returns the action of the <kbd>QtCore.Qt.DropAction</kbd> type that is used with this event.</p>
<p><kbd>drop_event.keyboardModifiers()</kbd>: This returns keyboard modifiers of the <kbd>QtCore.Qt.KeyboardModifiers</kbd> type that are used with this event.</p>
<p><kbd>drop_event.mimeData()</kbd>: This returns MIME data of the <kbd>QtCore.QMimeData</kbd> type that is used with this event.</p>
<p><kbd>drop_event.mouseButtons()</kbd>: This returns the mouse buttons of the <kbd>QtCore.Qt.MouseButtons</kbd> type that are used with this event.</p>
<p><kbd>drop_event.pos()</kbd>: This returns the position of the <kbd>QtCore.QPoint</kbd> type where the drop was made.</p>
<p><kbd>drop_event.posF()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type where the drop was made.</p>
<p><kbd>drop_event.possibleActions()</kbd>: This returns the possible drop actions of the <kbd>QtCore.Qt.DropActions</kbd> type.</p>
<p><kbd>drop_event.proposedAction()</kbd>: This returns the proposed action of the <kbd>QtCore.Qt.DropAction</kbd> type.</p>
<p><kbd>drop_event.source()</kbd>: This returns the source of the <kbd>QtCore.QObject</kbd> type that is used for drop event operations, such as a widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def dropEvent(self, event):<br/>    """Some code lines for processing..."""</pre>
<p>Event handlers of the <kbd>QDragEnterEvent</kbd>, <kbd>QDragMoveEvent</kbd>, and <kbd>QDragLeaveEvent</kbd> types, which improve the functionality of <kbd>QDropEvent</kbd>, are also available, as follows:</p>
<pre>def dragEnterEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def dragMoveEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def dragLeaveEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QEnterEvent</h1>
                
            
            
                
<p>This class handles events when the mouse cursor enters a widget, a window, or another GUI element/item. It is available with almost all items that support mouse cursor enter operations. The declaration syntax of this class is as follows:</p>
<pre><strong>enter_event</strong> = QtGui.QEnterEvent(QtCore.QPointF,<br/>                        QtCore.QPointF,QtCore.QPointF)</pre>
<p>In regard to the construction of the enter event, the following parameters are used:</p>
<ul>
<li>Local position (the first parameter).</li>
<li>Window position (the second parameter).</li>
<li>Screen position (the third parameter) of the mouse cursor relative to the receiving item.</li>
</ul>
<p>The <kbd>QEnterEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the enter event, changes in functionality, and more:</p>
<p><kbd>enter_event.globalPos()</kbd>: This returns the global position of the <kbd>QtCore.QPoint</kbd> type for the item when the enter event occurs.</p>
<p><kbd>enter_event.globalX()</kbd>: This returns the global x axis position of the mouse cursor on the item when the enter event occurs.</p>
<p><kbd>enter_event.globalY()</kbd>: This returns the global y axis position of the mouse cursor on the item when the enter event occurs.</p>
<p><kbd>enter_event.localPos()</kbd>: This returns the local position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the item when the enter event occurs.</p>
<p><kbd>enter_event.pos()</kbd>: This returns the position of the <kbd>QtCore.QPoint</kbd> type for the mouse cursor in global screen coordinates when the enter event occurs.</p>
<p><kbd>enter_event.screenPos()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the screen when the enter event occurs.</p>
<p><kbd>enter_event.windowPos()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the window when the enter event occurs.</p>
<p><kbd>enter_event.x()</kbd>: This returns the <em>x</em> position for the mouse cursor on the item when the enter event occurs.</p>
<p><kbd>enter_event.y()</kbd>: This returns the <em>y</em> position for the mouse cursor on the item when the enter event occurs,</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def enterEvent(self, event):<br/>    """Some code lines for processing..."""</pre>
<p>The leave event of the mouse cursor from the item can be realized as follows:</p>
<pre>def leaveEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QFocusEvent</h1>
                
            
            
                
<p>This class handles the focus events of an item. These events appear when the keyboard input focus changes. It is available with widgets such as <kbd>QWidget</kbd>, which support keyboard focus operations. The declaration syntax of this class is as follows:</p>
<pre><strong>focus_event</strong> = QtGui.QFocusEvent(QtCore.QEvent.Type,<br/>                                QtCore.Qt.FocusReason)</pre>
<p>In regard to the construction of the focus event, the type (the first parameter) of the event and the focus reason (the second parameter) are used. The available types for this event are as follows:</p>
<ul>
<li><kbd>QtCore.QEvent.FocusIn</kbd>: This item gains keyboard focus.</li>
<li><kbd>QtCore.QEvent.FocusOut</kbd>: This item loses keyboard focus.</li>
<li><kbd>QtCore.QEvent.FocusAboutToChange</kbd>: This item's focus is about to change.</li>
</ul>
<p>The <kbd>QFocusEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the focus event:</p>
<p><kbd>focus_event.gotFocus()</kbd>: This returns <kbd>True</kbd> if this event has a <kbd>FocusIn</kbd> type.</p>
<p><kbd>focus_event.lostFocus()</kbd>: This returns <kbd>True</kbd> if this event has a <kbd>FocusOut</kbd> type.</p>
<p><kbd>focus_event.reason()</kbd>: This returns the reason of the <kbd>QtCore.Qt.FocusReason</kbd> type for this focus event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handlers for this event are as follows:</p>
<pre>def focusInEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def focusOutEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QKeyEvent</h1>
                
            
            
                
<p>This class handles the events that appear in relation to keyboard activity. It becomes available when you press the keys of the keyboard with widgets such as <kbd>QWidget</kbd>. The declaration syntax of this class is as follows:</p>
<pre><strong>key_event</strong> = QtGui.QKeyEvent(QtCore.QEvent.Type, int,<br/>                            QtCore.Qt.KeyboardModifiers)</pre>
<p>In regard to the construction of the key event, the type (the first parameter), key (the second parameter), and keyboard modifiers (the third parameter) are used. The available types for this event are as follows:</p>
<ul>
<li><kbd>QtCore.QEvent.KeyPress</kbd>: Presses a key.</li>
<li><kbd>QtCore.QEvent.KeyRelease</kbd>: Releases a key.</li>
<li><kbd>QtCore.QEvent.ShortcutOverride</kbd>: A key press in a child.</li>
</ul>
<p>The <kbd>QKeyEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the key event states:</p>
<p><kbd>key_event.isAutoRepeat()</kbd>: This returns <kbd>True</kbd> if the key event comes from an auto-repeating key.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the key event:</p>
<p><kbd>key_event.count()</kbd>: This returns the number of keys that are available for this event.</p>
<p><kbd>key_event.key()</kbd>: This returns the code of the key, corresponding to <kbd>QtCore.Qt.Key</kbd>, that was used.</p>
<p><kbd>key_event.matches(QtGui.QKeySequence.StandardKey)</kbd>: This returns <kbd>True</kbd> if the key event matches the standard key specified in the parameter.</p>
<p><kbd>key_event.modifiers()</kbd>: This returns the keyboard modifiers of the <kbd>QtCore.Qt.KeyboardModifiers</kbd> type for this key event.</p>
<p><kbd>key_event.nativeModifiers()</kbd>: This returns the native modifiers of this key event.</p>
<p><kbd>key_event.nativeScanCode()</kbd>: This returns the scan code of this key event.</p>
<p><kbd>key_event.nativeVirtualKey()</kbd>: This returns the virtual key of this key event.</p>
<p><kbd>key_event.text()</kbd>: This returns the text that's generated with this key.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handlers for this event are as follows:</p>
<pre>def keyPressEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def keyReleaseEvent((self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QMouseEvent</h1>
                
            
            
                
<p>This class handles the events that appear in tandem with mouse activity. It is available with almost all graphical items that can interact with the mouse. The declaration syntax of this class is as follows:</p>
<pre><strong>mouse_event</strong> = QtGui.QMouseEvent(QtCore.QEvent.Type,<br/>                           QtCore.QPointF, QtCore.QPointF,<br/>                           QtCore.QPointF, QtCore.Qt.MouseButton, <br/>                           QtCore.Qt.MouseButtons,<br/>                           QtCore.Qt.KeyboardModifiers)</pre>
<p>In regard to the construction of the mouse event, the following parameters are used:</p>
<ul>
<li>Type (the first parameter).</li>
<li>Local position (the second parameter) of the cursor.</li>
<li>Window position (the third parameter) of the cursor.</li>
<li>Screen position (the fourth parameter) of the cursor.</li>
<li>The button (the fifth parameter) that caused the event.</li>
<li>Buttons (the sixth parameter) that describe the mouse/keyboard states.</li>
</ul>
<p>The available types for this event are as follows:</p>
<ul>
<li><kbd>QtCore.QEvent.MouseButtonPress</kbd>: Clicks the mouse button.</li>
<li><kbd>QtCore.QEvent.MouseButtonRelease</kbd>: Releases the mouse button.</li>
<li><kbd>QtCore.QEvent.MouseMove</kbd>: Moves the mouse over the item.</li>
<li><kbd>QtCore.QEvent.MouseButtonDblClick</kbd>: Double-clicks the mouse button.</li>
</ul>
<p>The <kbd>QMouseEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function is related to setting parameters/properties in relation to the mouse event:</p>
<p><kbd>mouse_event.setLocalPos(QtCore.QPointF)</kbd>: This sets the local position, specified in the parameter, for this mouse event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the mouse event:</p>
<p><kbd>mouse_event.button()</kbd>: This returns the button of the <kbd>QtCore.Qt.MouseButton</kbd> type that causes this mouse event.</p>
<p><kbd>mouse_event.buttons()</kbd>: This returns the button state of the <kbd>QtCore.Qt.MouseButtons</kbd> type that was generated with this mouse event.</p>
<p><kbd>mouse_event.flags()</kbd>: This returns flags of the <kbd>QtCore.Qt.MouseEventFlags</kbd> type for this mouse event.</p>
<p><kbd>mouse_event.globalPos()</kbd>: This returns the global position of the <kbd>QtCore.QPoint</kbd> type for the mouse cursor when the event occurs.</p>
<p><kbd>mouse_event.globalX()</kbd>: This returns the global <em>x</em> axis position for the mouse cursor when the mouse event occurs.</p>
<p><kbd>mouse_event.globalY()</kbd>: This returns the global <em>y</em> axis position for the mouse cursor when the mouse event occurs.</p>
<p><kbd>mouse_event.localPos()</kbd>: This returns the local position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the item when the mouse event occurs.</p>
<p><kbd>mouse_event.pos()</kbd>: This returns the position of the <kbd>QtCore.QPoint</kbd> type for the mouse cursor in global screen coordinates when the mouse event occurs.</p>
<p><kbd>mouse_event.screenPos()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the screen when the mouse event occurs.</p>
<p><kbd>mouse_event.windowPos()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the mouse cursor on the window when the mouse event occurs.</p>
<p><kbd>mouse_event.source()</kbd>: This returns the information of the <kbd>QtCore.Qt.MouseEventSource</kbd> type related to the mouse event source.</p>
<p><kbd>mouse_event.x()</kbd>: This returns the <em>x</em> position for the mouse cursor on the item when the mouse event occurs.</p>
<p><kbd>mouse_event.y()</kbd>: This returns the <em>y</em> position for the mouse cursor on the item when the mouse event occurs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handlers for this event are as follows:</p>
<pre>def mousePressEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def mouseReleaseEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def mouseMoveEvent(self, event):<br/>    """Some code lines for processing..."""<br/><br/>def mouseDoubleClickEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QWheelEvent</h1>
                
            
            
                
<p>This class handles events that appear when the mouse wheel is operated. These events are generated for mouse wheels and trackpad scroll gestures. The declaration syntax of this class is as follows:</p>
<pre><strong>wheel_event</strong> = QtGui.QWheelEvent(QtCore.QPointF, QtCore.QPointF,<br/>                                QtCore.QPoint, QtCore.QPoint,<br/>                                int, QtCore.Qt.Orientation,<br/>                                QtCore.Qt.MouseButtons,<br/>                                QtCore.Qt.KeyboardModifiers,<br/>                                QtCore.Qt.ScrollPhase,<br/>                                QtCore.Qt.MouseEventSource, bool)</pre>
<p>In regard to the construction of the wheel event, the following parameters are used:</p>
<ul>
<li>The position (the first parameter) of the mouse cursor location.</li>
<li>The global position (the second parameter).</li>
<li>The pixel delta (the third parameter) or scrolling distance in pixels on the screen.</li>
<li>The angle delta (the fourth parameter) or wheel rotation distance.</li>
<li>The qt4 delta (the fifth parameter) monodirectional rotation.</li>
<li>The qt4 orientation (the sixth parameter) monodirectional direction.</li>
<li>Mouse states (the seventh parameter).</li>
<li>Keyboard states (the eighth parameter).</li>
<li>The scrolling phase (the ninth parameter).</li>
<li>The source (the tenth parameter) of the mouse wheel or gesture.</li>
<li>The inversion (the eleventh parameter) option.</li>
</ul>
<p>The <kbd>QWheelEvent</kbd> class improves functionality by means of the following functions. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the wheel event:</p>
<p><kbd>wheel_event.angleDelta()</kbd>: This returns the distance of the <kbd>QtCore.QPoint</kbd> type for the wheel's rotation.</p>
<p><kbd>wheel_event.buttons()</kbd>: This returns the button state of the <kbd>QtCore.Qt.MouseButtons</kbd> type that was generated with this wheel event.</p>
<p class="mce-root"/>
<p><kbd>wheel_event.globalPos()</kbd>: This returns the global position of the <kbd>QtCore.QPoint</kbd> type of the pointer related to this wheel event.</p>
<p><kbd>wheel_event.globalPosF()</kbd>: This returns the global position of the <kbd>QtCore.QPointF</kbd> type of the pointer related to this wheel event.</p>
<p><kbd>wheel_event.globalX()</kbd>: This returns the global <em>x</em> axis position of the pointer related to this wheel event.</p>
<p><kbd>wheel_event.globalY()</kbd>: This returns the global <em>y</em> axis position of the pointer related to this wheel event.</p>
<p><kbd>wheel_event.inverted()</kbd>: This returns <kbd>True</kbd> if the delta values are inverted for this event.</p>
<p><kbd>wheel_event.orientation()</kbd>: This returns the orientation of the <kbd>QtCore.Qt.Orientation</kbd> type for this wheel.</p>
<p><kbd>wheel_event.phase()</kbd>: This returns the scrolling phase of this event.</p>
<p><kbd>wheel_event.pixelDelta()</kbd>: This returns the pixel delta of the <kbd>QtCore.QPoint</kbd> type as the scrolling distance on screen.</p>
<p><kbd>wheel_event.pos()</kbd>: This returns the position of the <kbd>QtCore.QPoint</kbd> type for the pointer related to the item.</p>
<p><kbd>wheel_event.posF()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the pointer related to the item.</p>
<p><kbd>wheel_event.source()</kbd>: This returns the information of the <kbd>QtCore.Qt.MouseEventSource</kbd> type related to the wheel event source.</p>
<p><kbd>wheel_event.x()</kbd>: This returns the <em>x</em> position for the pointer related to the item when the event occurs.</p>
<p><kbd>wheel_event.y()</kbd>: This returns the <em>y</em> position for the pointer related to the item when the event occurs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def wheelEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QMoveEvent</h1>
                
            
            
                
<p>This class handles events that appear in connection with the moving activity of the items. It is available with almost all graphical items where moving can be realized. The declaration syntax of this class is as follows:</p>
<pre><strong>move_event</strong> = QtGui.QMoveEvent(QtCore.QPoint, QtCore.QPoint)</pre>
<p>In regard to the construction of the move event, the new (the first parameter) and old (the second parameter) positions are used. The <kbd>QMoveEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the move event:</p>
<p><kbd>move_event.oldPos()</kbd>: This returns the old position of the <kbd>QtCore.QPoint</kbd> type for the moving item.</p>
<p><kbd>move_event.pos()</kbd>: This returns the new position of the <kbd>QtCore.QPoint</kbd> type for the moving item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def moveEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QPaintEvent</h1>
                
            
            
                
<p>This class handles events to do with painting that relates to the items. It is available with almost all graphical items where painting can be operated. As we've described in previous chapters, all the graphical elements of the Qt library are painted and, therefore, the <kbd>paintEvent()</kbd> event handler can be used for updating the graphical representation of the items. The declaration syntax of this class is as follows:</p>
<pre><strong>paint_event</strong> = QtGui.QPaintEvent(QtCore.QRect)<br/># or<br/><strong>paint_event</strong> = QtGui.QPaintEvent(QtGui.QRegion)</pre>
<p>In regard to the construction of the paint event, the rectangle or region for painting that's specified in the parameter is used. The <kbd>QPaintEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the paint event:</p>
<p><kbd>paint_event.rect()</kbd>: This returns the rectangle of the <kbd>QtCore.QRect</kbd> type that is used for the update.</p>
<p><kbd>paint_event.region()</kbd>: This returns the rectangle of the <kbd>QtGui.QRegion</kbd> type that is used for the update.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def paintEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QResizeEvent</h1>
                
            
            
                
<p>This class handles events that appear when we resize items. It is available with almost all graphical items where you can resize items. The declaration syntax of this class is as follows:</p>
<pre><strong>resize_event</strong> = QtGui.QResizeEvent(QtCore.QSize, QtCore.QSize)</pre>
<p>In regard to the construction of the resizing event, the new size (the first parameter) and old size (the second parameter) are used. The <kbd>QResizeEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the resizing event:</p>
<p><kbd>resize_event.oldSize()</kbd>: This returns the old size of the <kbd>QtCore.QSize</kbd> type for the item being resized.</p>
<p><kbd>resize_event.size()</kbd>: This returns the new size of the <kbd>QtCore.QSize</kbd> type for the item being resized.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def resizeEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QTabletEvent</h1>
                
            
            
                
<p>This class handles events related to tablet device functionality. The declaration syntax of this class is as follows:</p>
<pre><strong>tablet_event</strong> = QtGui.QTabletEvent(QtCore.QEvent.Type,<br/>                                  QtCore.QPointF,<br/>                                  QtCore.QPointF, int,<br/>                                  int, float, int, int,<br/>                                  float, float, int,<br/>                                  QtCore.Qt.KeyboardModifiers,<br/>                                  int, QtCore.Qt.MouseButton,<br/>                                  QtCore.Qt.MouseButtons)</pre>
<p>In regard to the construction of the tablet event, the following parameters are used:</p>
<ul>
<li>The type (the first parameter).</li>
<li>The position (the second parameter) where the event occurred.</li>
<li>The global position (the third parameter) in absolute coordinates.</li>
<li>The device (the fourth parameter).</li>
<li>The pointer type (the fifth parameter).</li>
<li>The pressure (the sixth parameter) exerted on the device.</li>
<li>The <em>x</em> tilt (the seventh parameter) degree for this device.</li>
<li>The <em>y</em> tilt (the eighth parameter) degree for this device.</li>
<li>The tangential pressure (the ninth parameter) of the airbrush.</li>
<li>The rotation (the tenth parameter) for this device.</li>
<li>The<em><strong> </strong>z</em> (the eleventh parameter) coordinate of the device.</li>
<li>The key state (the twelfth parameter).</li>
<li>The unique ID (the thirteenth parameter).</li>
<li>The button (the fourteenth parameter) that caused the event.</li>
<li>The button (the fifteenth parameter) state at the time of the event.</li>
</ul>
<p>The <kbd>QTabletEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the tablet event:</p>
<p><kbd>tablet_event.button()</kbd>: This returns the button of the <kbd>QtCore.Qt.MouseButton</kbd> type that causes this tablet event.</p>
<p><kbd>tablet_event.buttons()</kbd>: This returns the buttons state of the <kbd>QtCore.Qt.MouseButtons</kbd> type that was generated with this tablet event.</p>
<p><kbd>tablet_event.device()</kbd>: This returns the type of the device that generated this tablet event as <kbd>QtGui.QTabletEvent.TabletDevice</kbd>.</p>
<p><kbd>tablet_event.globalPos()</kbd>: This returns the global position of the <kbd>QtCore.QPoint</kbd> type of the device when the event occurs.</p>
<p><kbd>tablet_event.globalPosF()</kbd>: This returns the global position of the <strong><kbd>QtCore.QPointF</kbd></strong> type of the device when the event occurs.</p>
<p><kbd>tablet_event.globalX()</kbd>: This returns the global <em>x</em> axis position of the device when the tablet event occurs.</p>
<p><kbd>tablet_event.globalY()</kbd>: This returns the global <em>y</em> axis position of the device when the tablet event occurs.</p>
<p><kbd>tablet_event.hiResGlobalX()</kbd>: This returns the high-precision <em>x</em> position of this device.</p>
<p><kbd>tablet_event.hiResGlobalY()</kbd>: This returns the high-precision <em>y</em> position of this device.</p>
<p><kbd>tablet_event.pointerType()</kbd>: This returns the type of pointer as <strong><kbd>QtGui.QTabletEvent.PointerType</kbd></strong>, which generated this event.</p>
<p><kbd>tablet_event.pos()</kbd>: This returns the position of the <kbd>QtCore.QPoint</kbd> type for the device related to the item.</p>
<p><kbd>tablet_event.posF()</kbd>: This returns the position of the <kbd>QtCore.QPointF</kbd> type for the device related to the item.</p>
<p><kbd>tablet_event.pressure()</kbd>: This returns the pressure for the device from <kbd>0.0</kbd> (stylus is not on the tablet) to <kbd>1.0</kbd> (stylus is on the tablet with maximum pressure).</p>
<p><kbd>tablet_event.rotation()</kbd>: This returns the rotation of the device in degrees, where <kbd>0</kbd> means that the tip of the stylus is pointing toward the top of the tablet, a positive value means that it is turned to the right, and a negative value means that it is turned to the left.</p>
<p><kbd>tablet_event.tangentialPressure()</kbd>: This returns the tangential pressure for this device given by a finger wheel on an airbrush tool in the range of <kbd>-1.0</kbd> to <kbd>1.0</kbd>.</p>
<p><kbd>tablet_event.uniqueId()</kbd>: This returns the unique ID of this tablet device.</p>
<p><kbd>tablet_event.xTilt()</kbd>: This returns the angle according to the <em>x</em> axis between the device and the perpendicular.</p>
<p><kbd>tablet_event.yTilt()</kbd>: This returns the angle according to the <em>y</em> axis between the device and the perpendicular.</p>
<p><kbd>tablet_event.x()</kbd>: This returns the <em>x</em> position for the device related to the item when the event occurs.</p>
<p><kbd>tablet_event.y()</kbd>: This returns the <em>y</em> position for the device related to the item when the event occurs.</p>
<p><kbd>tablet_event.z()</kbd>: This returns the <em>z</em> position according to the z axis for the device; for example, as represented by a wheel on a 4D mouse.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def tabletEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QTouchEvent</h1>
                
            
            
                
<p>This class handles events that appear when we move one or more touch points on a device that supports touch operations. These devices must have a touchscreen or trackpad. To make this functionality available, the widgets or graphical items need to have the <kbd>acceptTouchEvents</kbd> attribute set to <kbd>True</kbd>. The declaration syntax of this class is as follows:</p>
<pre><strong>touch_event</strong> = QtGui.QTouchEvent(QtCore.QEvent.Type,<br/>                              QtGui.QTouchDevice,<br/>                              QtCore.Qt.KeyboardModifiers,<br/>                              QtCore.Qt.TouchPointStates,<br/>                              [QtGui.QTouchEvent.TouchPoint])</pre>
<p>In regard to the construction of the touch event, the following parameters are used:</p>
<ul>
<li>The type (the first parameter).</li>
<li>The device (the second parameter).</li>
<li>Keyboard modifiers (the third parameter).</li>
<li>Touch point states (the fourth parameter).</li>
<li>Touch points (the fifth parameter).</li>
</ul>
<p>The <kbd>QTouchEvent</kbd> class improves functionality by means of the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These are functions that are related to setting parameters/properties in relation to the touch event:</p>
<p><kbd>touch_event.setDevice(QtGui.QTouchDevice)</kbd>: This sets the device, specified in the parameter, that will be used.</p>
<p><kbd>touch_event.setTarget(QtCore.QObject)</kbd>: This sets the target (such as a widget), specified in the parameter, for this event.</p>
<p><kbd>touch_event.setTouchPoints([QtGui.QTouchEvent.TouchPoint])</kbd>: This sets the touch points, specified in the parameter, for this event.</p>
<p><kbd>touch_event.setTouchPointStates(QtCore.Qt.TouchPointStates)</kbd>: This sets the touch point states, specified in the parameter, for this event.</p>
<p><kbd>touch_event.setWindow(QtGui.QWindow)</kbd>: This sets the window, specified in the parameter, for this touch event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These are functions that are related to the returns of the current values of the touch event:</p>
<p><kbd>touch_event.device()</kbd>: This returns a device of the <kbd>QtGui.QTouchDevice</kbd> type from which the touch event occurs.</p>
<p><kbd>touch_event.target()</kbd>: This returns the target object of the <kbd>QtCore.QObject</kbd> type for the event that occurred.</p>
<p><kbd>touch_event.touchPoints()</kbd>: This returns a list of touch points for this touch event.</p>
<p><kbd>touch_event.touchPointStates()</kbd>: This returns the touch point states of the <strong><kbd>QtCore.Qt.TouchPointStates</kbd></strong> type for this <kbd>touch</kbd> event.</p>
<p><kbd>touch_event.window()</kbd>: This returns the window of the <strong><kbd>QtGui.QWindow</kbd></strong> type for the touch event that occurred.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">event handlers</h1>
                
            
            
                
<p>The handler for this event is as follows:</p>
<pre>def touchEvent(self, event):<br/>    """Some code lines for processing..."""</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional notations</h1>
                
            
            
                
<p>The Qt library has events that were not described here but that we will touch on briefly. Some of these classes, which realize the special or ordinary events, are as follows:</p>
<p><kbd>QtCore.QDynamicPropertyChangeEvent</kbd>: For dynamic property change events.</p>
<p><kbd>QtGui.QCloseEvent</kbd>: For close events with the <kbd>closeEvent()</kbd> event handler.</p>
<p><kbd>QtGui.QHideEvent</kbd>: For events related to hiding the widgets.</p>
<p><kbd>QtGui.QShowEvent</kbd>: For the widget's show events.</p>
<p><kbd>QtGui.QContextMenuEvent</kbd>: For context menu events.</p>
<p><kbd>QtGui.QExposeEvent</kbd>: For events exposed with the <kbd>exposeEvent()</kbd> event handler.</p>
<p><kbd>QtGui.QFileOpenEvent</kbd>: For events related to opening file operations.</p>
<p><kbd>QtGui.QHelpEvent</kbd>: For events related to helpful information of the point in a widget.</p>
<p><kbd>QtGui.QHoverEvent</kbd>: For mouse events related to hovering over an item with <kbd>QGraphicsItem</kbd>.</p>
<p><kbd>QtGui.QIconDragEvent</kbd>: For the main icon's dragging events.</p>
<p><kbd>QtGui.QInputEvent</kbd>: For the user's input events.</p>
<p><kbd>QtGui.QInputMethodEvent</kbd>: For input method events.</p>
<p><kbd>QtGui.QNativeGestureEvent</kbd>: For gesture events.</p>
<p><kbd>QtGui.QScrollEvent</kbd>: For scrolling events.</p>
<p><kbd>QtGui.QScrollPrepareEvent</kbd>: For scrolling preparation events.</p>
<p><kbd>QtGui.QShortcutEvent</kbd>: For key combination events.</p>
<p><kbd>QtGui.QStatusTipEvent</kbd>: For status bar events.</p>
<p><kbd>QtGui.QWhatsThisClickedEvent</kbd>: For handling hyperlinks in a <em>What's This?</em> text.</p>
<p><kbd>QtGui.QWindowStateChangeEvent</kbd>: For window state change events.</p>
<p>The classes of the <kbd>QtWidgets</kbd> module, such as <kbd>QGestureEvent</kbd> and <kbd>QGraphicsSceneEvent</kbd>, can also be used.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending events</h1>
                
            
            
                
<p>Within application development, there are instances when events may need to be sent. This can help us create more flexible functionality. To this end, static methods from the <kbd>QCoreApplication</kbd> class of the <kbd>QtCore</kbd> module can be used. The static methods can be implemented as follows:</p>
<p><kbd>QtCore.QCoreApplication.sendEvent(object, event)</kbd>: This is where the <kbd>sendEvent()</kbd> method immediately sends the event to the object. The <kbd>object</kbd> is a <kbd>QtCore.QObject</kbd>, such as a widget, button, or another item, and the <kbd>event</kbd> is a <kbd>QtCore.QEvent</kbd>, such as an enter event or a mouse event.</p>
<p><kbd>QtCore.QCoreApplication.postEvent(object, event)</kbd>: This is where the <kbd>postEvent()</kbd> method adds the event to the queue. The <kbd>object</kbd> is a <kbd>QtCore.QObject</kbd>, such as a widget, button, or another item, and the <kbd>event</kbd> is a <kbd>QtCore.QEvent</kbd>, such as an enter event or a mouse event. This method can be used with the threads in the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Events example</h1>
                
            
            
                
<p>To demonstrate events and event handlers, let's modernize our application. Usually, in the application, the event handlers that are available for the item are used. They handle some events and provide additional functionality. Here, we will cover the best way to add event handlers to the widget of the application. For this, we need to add/change some lines of the <kbd>UWid</kbd> class of both <kbd>u_style.py</kbd> files. Let's get started:</p>
<ol>
<li>First of all, change the <kbd>__init__()</kbd> function of the <kbd>UWid</kbd> class by adding additional parameters for better functionality:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UWid(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None, bg=color[1],<br/>                 bgh=color[3], minw=0, minh=0,<br/>                 maxw=None, maxh=None, fixw=None,<br/>                 fixh=None, mrg=0, pad=0, bds="solid",<br/>                 bdr=3, bdw=0, bdc=color[3]):<br/>        ...<br/>...</pre>
<p style="padding-left: 60px">This will be used for changing the parameters of the widget, depending on the widget's representation in the application, and is similar to the <kbd>UBut1</kbd> class.</p>
<ol start="2">
<li>Now, we need to add the lines to the <kbd>__init__()</kbd> function of the <kbd>UWid</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(...):<br/>        ...<br/>        self.setMinimumWidth(minw)<br/>        self.setMinimumHeight(minh)<br/>        if maxw is not None:<br/>            self.setMaximumWidth(maxw)<br/>        if maxh is not None:<br/>            self.setMaximumHeight(maxh)<br/>        if fixw is not None:<br/>            self.setFixedWidth(fixw)<br/>        if fixh is not None:<br/>            self.setFixedHeight(fixh)<br/>        self.bg, self.bgh, self.mrg, self.pad = bg, bgh, mrg, pad<br/>        self.bds, self.bdr, self.bdw, self.bdc = bds, bdr, bdw, bdc<br/>        self.setStyleSheet(self.wid_style(self.mrg, self.pad,<br/>                                          self.bg, self.bds,<br/>                                          self.bdr, self.bdw,<br/>                                          self.bgh))<br/>...</pre>
<p style="padding-left: 60px">Here, there is the option to set the fixed width/height, min/max width/height, background color, and more.</p>
<ol start="3">
<li>Now, we need to add the <kbd>wid_style()</kbd> styling function to the <kbd>UWid</kbd> class, which will be used for the restyling of this widget, depending on the events that have occurred:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(...):<br/>        ...<br/>    def wid_style(self, mrg=None, pad=None, bg=None, bds=None,<br/>                                 bdr=None, bdw=None, bdc=None):<br/>        style = """margin: %spx; padding: %spx;<br/>                background-color: %s; border-style: %s;<br/>                border-radius: %spx; border-width: %spx;<br/>                border-color: %s;""" % (mrg, pad, bg, bds, bdr,<br/>                                                      bdw, bdc)<br/>        return style <br/>...</pre>
<p style="padding-left: 60px">This is an optional function and is used to reduce the number of lines of various events. Now, we need to add the event handlers that will be used to handle events for this widget.</p>
<ol start="4">
<li>Add the <kbd>enterEvent()</kbd> handler to the <kbd>UWid</kbd> class for handling events related to the mouse cursor entering this widget:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def enterEvent(self, event):<br/>        self.setStyleSheet(self.wid_style(self.mrg, self.pad,<br/>                           self.bgh, self.bds, self.bdr,<br/>                           self.bdw, self.bdc))<br/>...</pre>
<ol start="5">
<li>Then, add the <kbd>leaveEvent()</kbd> handler to the <kbd>UWid</kbd> class for handling events related to the mouse cursor leaving this widget:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def leaveEvent(self, event):<br/>        self.setStyleSheet(self.wid_style(self.mrg, self.pad,<br/>                           self.bg, self.bds, self.bdr,<br/>                           self.bdw, self.bdc))<br/>...</pre>
<p style="padding-left: 60px">Now, if we run the <kbd>u_app.py</kbd> file, we will see the result. We can also add other event handlers by way of experimentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter considered the main principles of signal functionality and commonly used events that can be handled in the GUI application. An understanding of these basics is very important because this represents the core functionality of any modern application. A lot of GUIs aren't very useful without these mechanisms. The last example that was provided in this chapter demonstrates styling the widget relative to the events that occurred. In this way, all of the styled elements that were implemented can be extended. This chapter is an introduction to the signals and events of the Qt library. The official documentation can consolidate your knowledge in this area.</p>
<p>In the next chapter, we will cover another important aspect of any application – the realization of the threads and processes. </p>


            

            
        
    </body></html>