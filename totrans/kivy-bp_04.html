<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Kivy Networking</h1></div></div></div><p>Previously, we talked about trade-offs such as narrowing the application compatibility while aiming to broaden its feature set, for example, an Android-only application using the native API to do the heavy lifting. Now, let's explore the opposite extreme and build an app based on uncompromising, universally available functionality—networking.</p><p>In this <a id="id273" class="indexterm"/>chapter, we are going to build a Chat app, which is similar in concept to an <strong>Internet Relay Chat</strong> (<strong>IRC</strong>), but much simpler.</p><p>While certainly not a replacement for enterprise-scale behemoths like Skype, by the end of this chapter, our little app will support multi-user messaging over the Internet. This is sufficient for small and friendly groups of people.</p><p>Being friendly is actually a requirement, as we're intentionally simplifying things by not implementing authentication. This means that users are able to easily impersonate each other. Tweaking the application to sustain hostile environments and catastrophic events (such as a political debate) is left for you to do, if you feel particularly adventurous.</p><p>We're also<a id="id274" class="indexterm"/> aiming at the widest possible compatibility, at least on the server side; you will be able to use even <strong>Telnet</strong> to send and receive messages. While not as pretty as graphical Kivy apps, Telnet runs perfectly fine in Windows 95 and even MS-DOS. Chat with dinosaurs!</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>To be more historically accurate, the Telnet protocol was standardized in 1973, so it even predates the 8086 CPU and the x86 architecture. MS-DOS is much more modern in comparison, and Windows 95 is practically the future of computing.</p></div></div><p>The following important topics will be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing <a id="id275" class="indexterm"/>and testing a custom server in Python, using the <strong>Twisted</strong> framework</li><li class="listitem" style="list-style-type: disc">Developing a couple of client apps on different levels of abstraction, from simple terminal program using raw sockets to an event-driven Twisted client</li><li class="listitem" style="list-style-type: disc">Using Kivy <code class="literal">ScreenManager</code> to better organize the application UI</li><li class="listitem" style="list-style-type: disc">Employing a <code class="literal">ScrollView</code> container to efficiently present lengthy widgets on the screen</li></ul></div><p>Our application will feature the centralized, client-server architecture; such topology is very common on the Internet, and many websites and applications work this way. As you will see shortly, it's also rather easy to implement as opposed to a decentralized, peer-to-peer network.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>For the purposes of this chapter we don't differentiate a <strong>local area network</strong> (<strong>LAN</strong>) from<a id="id276" class="indexterm"/> the Internet, as it's largely irrelevant at this level of abstraction. However, note that deploying your application for large-scale consumption on the Internet, if done properly, requires knowledge in many additional areas, from setting up a secure web server and configuring the firewall to making the code scale across many processor cores and even several physical machines. In practice this may be less scary than it sounds, but still constitutes a nontrivial endeavor per se.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Writing the chat server</h1></div></div></div><p>Let's start<a id="id277" class="indexterm"/> the development with the server-side code so that we have an endpoint to connect to before we begin writing the client. For this, we'll use an excellent <strong>Twisted</strong> framework<a id="id278" class="indexterm"/> that reduces many common, low-level networking tasks to a small number of lines of clean, relatively high-level Python code.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>
<strong>Compatibility notice</strong>
</p><p>Twisted doesn't support Python 3 at the time of writing, so we'll assume that all the following Python code is intended to run on Python 2.7. It should be easy to port it to Python 3 eventually, as no deliberately incompatible design decisions are made. (On a related note, we'll also completely ignore Unicode-related issues, because resolving them properly depends on Python version.)</p></div></div><p>Twisted is an event-driven, low-level server framework, not unlike <strong>Node.js</strong> (in fact, Node.js<a id="id279" class="indexterm"/> design was influenced by Twisted). Quite similar to Kivy, the event-driven architecture means that we don't structure the code as a loop; instead, we bind a number of event listeners to the events that we deem useful for our app. Hardcore, low-level networking, such as handling incoming connections and working with raw data packets, is performed by Twisted automatically as soon as we start the server.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>In order to install Twisted on your machine, run the usual command in the terminal:</p><div><pre class="programlisting">
<strong>pip install -U twisted</strong>
</pre></div><p>There are a few caveats:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Chances are, you'll<a id="id280" class="indexterm"/> need to become root (administrator or "super user") to perform a system-wide installation. If you're on Mac OS or Linux, try prefixing the command with <code class="literal">sudo</code> if you receive an <strong>Access Denied</strong> error message.</li><li class="listitem" style="list-style-type: disc">In the event you don't have pip installed, try the <strong>easy_install twisted</strong> command (or <strong>easy_install pip</strong>, for that matter).</li><li class="listitem" style="list-style-type: disc">Alternatively, please follow the official pip installation guide at <a class="ulink" href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>. This covers Windows too.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>The protocol definition</h2></div></div></div><p>Let's talk<a id="id281" class="indexterm"/> about the protocol that we are going to use to <a id="id282" class="indexterm"/>communicate with the chat server. Since the application is going to be very unsophisticated, instead of using a full-fledged extensive protocol such as XMPP, we're going to create our own barebones protocol containing only the bits we need.</p><p>In the context of this tutorial, there are just two messages passed from client to server that we want to implement on the protocol level—connecting to server (entering the chatroom), and actually talking to other users. Everything that the server sends back to the client is rendered; no service events originate on the server.</p><p>Our protocol will be textual, like many other application-level protocols, including the universally used HTTP. This is a very practical property because it makes debugging and related activities easier. Text protocols are also generally considered more extensible and future-proof, as opposed to binary ones. The downside of plain text is mainly its size; binary enumeration tends to be more compact. This is largely irrelevant in this case and can be easily mitigated anyway using compression (this is exactly what many servers do in case of HTTP).</p><p>Now let's review the individual messages that comprise our application's protocol:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connecting to the server communicates no other information except the fact that the user is now in the chat room, so we'll send just the word <code class="literal">CONNECT</code> every time. This message is not parameterized.</li><li class="listitem" style="list-style-type: disc">Talking in the chat room is more interesting. There are two parameters: the nickname and the text message itself. Let's define the format of such message as <code class="literal">A:B</code>, where <code class="literal">A</code> is the nickname (as a direct consequence, the nickname can't contain the colon <code class="literal">:</code> character).</li></ul></div><p>From<a id="id283" class="indexterm"/> this specification, we can derive an effective <a id="id284" class="indexterm"/>algorithm (pseudo code):</p><div><pre class="programlisting">if ':' not in message
    then
        // it's a CONNECT message
        add this connection to user list
    else
        // it's a chat message
        nickname, text := message.split on ':'
        for each user in user list
            if not the same user:
                send "{nickname} said: {text}"</pre></div><p>Testing for the same user is meant to cut the unnecessary transmission of users' own messages back to them (echo).</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>The server source code</h2></div></div></div><p>With<a id="id285" class="indexterm"/> the help of the Twisted framework, our pseudocode<a id="id286" class="indexterm"/> can be translated into Python pretty much literally. The following listing contains the full source code of our <code class="literal">server.py</code> application:</p><div><pre class="programlisting">from twisted.internet import protocol, reactor

transports = set()

class Chat(protocol.Protocol):
    def dataReceived(self, data):
        transports.add(self.transport)

        if ':' not in data:
            return

        user, msg = data.split(':', 1)

        for t in transports:
            if t is not self.transport:
                t.write('{0} says: {1}'.format(user, msg))

class ChatFactory(protocol.Factory):
    def buildProtocol(self, addr):
        return Chat()

reactor.listenTCP(9096, ChatFactory())
reactor.run()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>The principle of operation</h2></div></div></div><p>This is <a id="id287" class="indexterm"/>the control flow outline that will help you understand <a id="id288" class="indexterm"/>exactly how our server works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The last line, <code class="literal">reactor.run()</code>, starts the <code class="literal">ChatFactory</code> server that listens on port 9096</li><li class="listitem" style="list-style-type: disc">When the server receives input, it invokes the <code class="literal">dataReceived()</code> callback</li><li class="listitem" style="list-style-type: disc">The <code class="literal">dataReceived()</code> method<a id="id289" class="indexterm"/> implements the pseudocode from the protocol section, sending messages to other connected clients as required</li></ul></div><p>The set of connections to clients is called <code class="literal">transports</code>. We're adding the current transport, <code class="literal">self.transport</code>, to the set unconditionally, because in the case of existing element that's a no-op, so why bother.</p><p>The rest of the listing follows the algorithm exactly. As a result, every connected user except for the one who sent the original message will receive a notification, <code class="literal">&lt;</code>
<strong>username</strong>
<code class="literal">&gt; says: &lt;</code>
<strong>message text</strong>
<code class="literal">&gt;</code>.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Notice how we didn't actually check that the connect message says <code class="literal">CONNECT</code>. That's an example of closely following the <em>network robustness</em> principle, coined by Jon Postel in the TCP specification in 1980: <em>be conservative in what you send, and liberal in what you accept</em>.</p><p>In addition to simplifying the code in this case, we're also gaining an option for a forward compatibility. Let's say that in the future release of the client, we've added a new message to the protocol, namely the imaginary <code class="literal">WHARRGARBL</code> message that does, according to its name, something truly amazing. Instead of crashing due to receiving a malformed message (in this case, because of version mismatch), an old revision of the server will just ignore such messages and continue functioning.</p><p>Specifically this aspect—compatibility between versions—can be easily handled using a number of strategies. However, there are also more difficult problems when it comes to networking and especially public networks, including malicious users trying to defeat your system and bring it down on purpose. So, practically, there is no such thing as exaggerated server stability.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Testing the server</h2></div></div></div><p>Run<a id="id290" class="indexterm"/> the server as you usually run any Python program:</p><div><pre class="programlisting">
<strong>python server.py</strong>
</pre></div><p>This command shouldn't produce any visible output. The server just sits there, waiting quietly for clients to connect. However, there are no client programs in the known universe that can speak this protocol, since we've made it all up about page and a half ago. How can we make sure that the server works?</p><p>Thankfully, this chicken and egg problem is so common in this field that there are many useful tools to do just that—send arbitrary bytes to any server, and receive and display arbitrary bytes that server sends back.</p><p>One of the standard programs suitable for fiddling with servers that use text protocols is Telnet. Like many "old school" Unix-style utilities, Telnet is a command-line program that can be used both interactively and as part of larger batch (shell) script.</p><p>Most operating systems come with the <code class="literal">telnet</code> command preinstalled. If it isn't, chances are that you're on MS Windows version 7 or greater. In this case, you can go to <strong>Control Panel</strong> | <strong>Programs and Features</strong> | <strong>Turn Windows features on or off</strong>,<strong> </strong>as shown in the following screenshot:</p><div><img src="img/B01620_04_02.jpg" alt="Testing the server"/></div><p>Then, make sure that the <strong>Telnet Client</strong> checkbox is on, as follows:</p><div><img src="img/B01620_04_03.jpg" alt="Testing the server"/></div><p>Telnet accepts two arguments: host name and port number of the server to connect to. In order to connect to the chat server with telnet, you'll need to start <code class="literal">server.py</code> first, and then in another terminal run:</p><div><pre class="programlisting">
<strong>telnet 127.0.0.1 9096</strong>
</pre></div><p>Alternatively, you can use <code class="literal">localhost</code> for host name on most systems, as this is synonymous with <code class="literal">127.0.0.1</code>; both denote the current machine.</p><p>If all<a id="id291" class="indexterm"/> went well, you will have an interactive session open where every line you type is sent to the server. Now, using the chat protocol that we discussed earlier, you can communicate with the server:</p><div><pre class="programlisting">
<strong>CONNECT</strong>
<strong>User A:Hello, world!</strong>
</pre></div><p>There will be no output, because we programmed the server in such a way that it doesn't echo messages back to their original author—that will be wasteful. So, let's open yet another terminal (and a Telnet session) so that we have two simultaneously connected users.</p><p>This is what the chat session looks like when everything is functioning properly:</p><div><img src="img/B01620_04_04.jpg" alt="Testing the server"/><div><p>An interactive chat over the network at its finest</p></div></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>If for some reason, technical or otherwise, you cannot use Telnet on your system, please don't feel particularly bad about this, as this test is not required to successfully complete the tutorial.</p><p>However, here's some (very personal, intimate even) advice that is more related to your career than to the topic of this book: do yourself a favor and get a Mac OS or Linux box, or maybe use dual-boot on the same machine. These Unix-like operating systems are much better suited for software development than Windows, and the productivity boost is totally worth the inconvenience of getting used to a new environment.</p></div></div><p>With this we can conclude that our server works: two Telnet windows are talking just fine. Now that we're done with the backend, let's build a cross-platform GUI chat client.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Screen manager</h1></div></div></div><p>Let's begin <a id="id292" class="indexterm"/>the UI development with a new concept, namely screen management. Our application at hand, the chat client, is a fitting example. There will be two application states with different UI that are completely separate from one another:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The login screen where the user enters the hostname to connect to and the desired nickname:<div><img src="img/B01620_04_05.jpg" alt="Screen manager"/></div></li><li class="listitem" style="list-style-type: disc">The chatroom screen, where the actual conversation takes place:<div><img src="img/B01620_04_06.jpg" alt="Screen manager"/></div></li></ul></div><p>Conceptually, these are the application states of the Chat app's frontend.</p><p>A straightforward approach to such UI separation will amount to managing the visible and hidden controls depending on some variable that holds the current desired UI state. This gets cumbersome very quickly as the number of widgets grow, and the boilerplate code isn't exactly fun to write anyway.</p><p>That's why<a id="id293" class="indexterm"/> the Kivy framework provides us with a container widget specifically tailored for the task, <code class="literal">ScreenManager</code>. Additionally, <code class="literal">ScreenManager</code> supports short animations to visualize the screen change, with a number of prebuilt transitions to choose from. It can be used from a Kivy language file in a completely declarative manner without touching the Python code.</p><p>Let's do just that. Add the following code in the <code class="literal">chat.kv</code> file:</p><div><pre class="programlisting">ScreenManager:
    Screen:
        name: 'login'

        BoxLayout:
            # other UI controls -- not shown

            Button:
                text: 'Connect'
                on_press: <strong>root.current = 'chatroom'</strong>

    Screen:
        name: 'chatroom'

        BoxLayout:
            # other UI controls -- not shown

            Button:
                text: 'Disconnect'
                on_press: <strong>root.current = 'login'</strong>
</pre></div><p>This is the basic structure of the program: we have a <code class="literal">ScreenManager</code> at the root and a <code class="literal">Screen</code> container for every UI state we want to have (the first one will be displayed by default). Inside the <code class="literal">Screen</code> is the usual UI: layouts, buttons, and everything we've seen so far. We'll get to it in a bit.</p><p>The code we just saw also includes screen-changing buttons, one per <code class="literal">Screen</code> instance. In order to switch the application state, we need to assign the desired screen's name to the <code class="literal">current</code> property of <code class="literal">ScreenManager</code>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Customizing the animation</h2></div></div></div><p>As stated <a id="id294" class="indexterm"/>previously, the brief animation that happens<a id="id295" class="indexterm"/> when changing screens can be customized. Kivy provides a number of such animations out of the box, found inside the <code class="literal">kivy.uix.screenmanager</code> package:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Transition class name</p>
</th><th style="text-align: left" valign="bottom">
<p>Visual effect</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">NoTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No <a id="id296" class="indexterm"/>animation, just displays the new screen immediately.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SlideTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Slides<a id="id297" class="indexterm"/> the new screen. Pass <code class="literal">'left'</code> (the default), <code class="literal">'right'</code>, <code class="literal">'up'</code>, or <code class="literal">'down'</code> to select the direction of the effect.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SwapTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>In<a id="id298" class="indexterm"/> theory, this class simulates the iOS screen-swapping animation. The actual effect looks nothing like that though.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FadeTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Fades <a id="id299" class="indexterm"/>the screen out, then fades it back in.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">WipeTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id300" class="indexterm"/>smooth directional transition using a pixel shader.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FallOutTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Shrinks<a id="id301" class="indexterm"/> an old screen towards center of the window and makes it transparent, revealing the new screen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RiseInTransition</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<a id="id302" class="indexterm"/> exact opposite of <code class="literal">FallOutTransition</code>: grows the new screen from the center, overlapping and concealing an old one.</p>
</td></tr></tbody></table></div><p>There's a <a id="id303" class="indexterm"/>small caveat in relation to setting these<a id="id304" class="indexterm"/> inside a <code class="literal">.kv</code> file: the transitions aren't imported by default, so you'll need to import the ones you want to use, using the following syntax (at the top of <code class="literal">chat.kv</code>):</p><div><pre class="programlisting">#:import RiseInTransition kivy.uix.screenmanager.RiseInTransition</pre></div><p>Now you can assign it to <code class="literal">ScreenManager</code>. Note that it's a Python class instantiation, so the parentheses at the end are required:</p><div><pre class="programlisting">ScreenManager:
    transition: RiseInTransition()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Login screen layout</h2></div></div></div><p>What<a id="id305" class="indexterm"/> happens inside the login screen, layout-wise, is<a id="id306" class="indexterm"/> very similar to the previous chapter's Sound recorder app: a <code class="literal">GridLayout</code> solves the task of aligning components on a grid.</p><p>The only thing that hasn't been used in this book yet is the <code class="literal">TextInput</code> widget. Kivy's text input behaves almost exactly like a button, with the obvious exception that you can type text into it. By default, <code class="literal">TextInput</code> is multiline, so we set the <code class="literal">multiline</code> property to <code class="literal">False</code> because multiline text inputs don't make much sense in the context of this app.</p><p>When running on a device with no physical keyboard attached, Kivy will fall back to a virtual onscreen keyboard, just as native apps do.</p><p>This is the code that implements the login screen layout (in the same Kivy language file, <code class="literal">chat.kv</code>, under <code class="literal">ScreenManager</code>):</p><div><pre class="programlisting">Screen:
    name: 'login'

    BoxLayout:
        orientation: 'vertical'

        GridLayout:
            Label:
                text: 'Server:'

            TextInput:
                id: server
                text: '127.0.0.1'

            Label:
                text: 'Nickname:'

            TextInput:
                id: nickname
                text: 'Kivy'

        Button:
            text: 'Connect'
            on_press: root.current = 'chatroom'</pre></div><p>Here, we<a id="id307" class="indexterm"/> add two text fields, <code class="literal">Server</code> and <code class="literal">Nickname</code>, with <a id="id308" class="indexterm"/>corresponding labels, and a <strong>Connect</strong> button. The event handler for the button has nothing to do with actual networking just yet and merely switches the screen to the chatroom, but this will change in the near future.</p><p>There is one interesting bit of styling needed to make a single-line <code class="literal">TextInput</code>. In addition to setting its <code class="literal">multiline</code> property to <code class="literal">False</code>, we want to align the text inside vertically in the middle (otherwise, it will stick to the top of the control, leaving a large gap at the bottom). We can achieve the proper alignment using the padding property like this:</p><div><pre class="programlisting">&lt;TextInput&gt;:
    multiline: False
    padding: [10, 0.5 * (self.height – self.line_height)]</pre></div><p>This <code class="literal">padding</code> line sets both left and right padding to 10, with top and bottom computed as <em>0.5 × (height of the widget − height of one line of text)</em>.</p><p>This is what the resulting screen looks like; it is pretty similar to other applications that we've produced during the course of this book.</p><div><img src="img/B01620_04_07.jpg" alt="Login screen layout"/><div><p>Chat application's login screen</p></div></div><p>We could<a id="id309" class="indexterm"/> start writing code that connects to the server right <a id="id310" class="indexterm"/>now, but first let's get the primary screen, the chatroom, working. This will allow us to conduct meaningful tests right away afterwards.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Chatroom screen layout</h2></div></div></div><p>Next on <a id="id311" class="indexterm"/>our list is the chatroom screen. It features <a id="id312" class="indexterm"/>a <code class="literal">ScrollView</code> widget for lengthy conversations, and since that's the first time a scrolling widget appears in this book, let's take a closer look at how it works.</p><p>The simplest <code class="literal">.kv</code> snippet to produce a scrolling widget is as follows:</p><div><pre class="programlisting">&lt;ChatLabel@Label&gt;:
    text_size: (self.width, None)  # Step 1
    halign: 'left'
    valign: 'top'
    size_hint: (1, None)  # Step 2
    height: self.texture_size[1]  # Step 3

ScrollView:
    ChatLabel:
        text: 'Insert very long text with line\nbreaks'</pre></div><p>If you add enough text to it so that it overflows the screen, it starts to scroll, similar to what you'd expect from a long list of items in iOS or Android.</p><p>This is how this layout works:</p><div><ol class="orderedlist arabic"><li class="listitem">We constrain the <code class="literal">text_size</code> width (first value) of our custom <code class="literal">Label</code> subclass to the widget's available width, and let it choose the height depending on its contents by setting the second value to <code class="literal">None</code>.</li><li class="listitem">Then, we set the vertical <code class="literal">size_hint</code> (second value) to <code class="literal">None</code> to force height of the widget to be computed independently of its container. Otherwise, it will be limited by the parent element, and thus there will be nothing to scroll.</li><li class="listitem">Now, we <a id="id313" class="indexterm"/>can set the widget's height to be equal to the <code class="literal">texture_size</code> height (note that indexing is zero-based<a id="id314" class="indexterm"/> as usual, so the second value is indeed <code class="literal">texture_size[1]</code>). This will force the <code class="literal">ChatLabel</code> to become larger than the containing widget, <code class="literal">ScrollView</code>.</li><li class="listitem">When the <code class="literal">ScrollView</code> detects that its child widget is larger than the available screen space, scrolling is enabled. It works as usual on mobile, and adds mouse wheel support on desktop.</li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Overscroll modes</h3></div></div></div><p>You <a id="id315" class="indexterm"/>can also customize the overscroll effect of a <code class="literal">ScrollView</code> to mimic a behavior native to the corresponding platform (which still looks <a id="id316" class="indexterm"/>noticeably different from native components anyway, despite being similar in concept). At the time of writing, the Android-style edge glow isn't supported out of the box; the available options are listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ScrollEffect</code>: This effect allows you to stop scrolling abruptly when you reach<a id="id317" class="indexterm"/> the end. This is similar to how desktop programs usually work, so this behavior might be desirable if the app in question is intended mostly for desktop.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DampedScrollEffect</code>: This is <a id="id318" class="indexterm"/>the default effect. It is similar to the bounce back effect found in iOS. This is arguably the best mode for mobile devices.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OpacityScrollEffect</code>: This effect <a id="id319" class="indexterm"/>is similar to <code class="literal">DampedScrollEffect</code> with added transparency when scrolling past the edge of the content.</li></ul></div><p>To use one of these settings, import it from the <code class="literal">kivy.effects</code> module and assign to the <code class="literal">ScrollView.effect_cls</code> property, similar to the <code class="literal">ScreenManager</code> transitions just discussed. We aren't going to use this, as <code class="literal">DampedScrollEffect</code> suits our application just fine.</p><p>With all of these points in mind, this is what the chatroom screen layout looks like (in <code class="literal">chat.kv</code>):</p><div><pre class="programlisting">Screen:
    name: 'chatroom'

    BoxLayout:
        orientation: 'vertical'

        Button:
            text: 'Disconnect'
            on_press: root.current = 'login'

        ScrollView:
            ChatLabel:
                id: chat_logs
                text: 'User says: foo\nUser says: bar'

        BoxLayout:
            height: 90
            orientation: 'horizontal'
            padding: 0
            size_hint: (1, None)

            TextInput:
                id: message

            Button:
                text: 'Send'
                size_hint: (0.3, 1)</pre></div><p>The<a id="id320" class="indexterm"/> last line, <code class="literal">size_hint</code>, sets the horizontal <a id="id321" class="indexterm"/>proportion of the <code class="literal">Button</code> widget to <code class="literal">0.3</code>, down from the default of <code class="literal">1</code>. This makes the <strong>Send</strong> button smaller than the message input field.</p><p>In order to set the background of the messages area to white, we can use the following code:</p><div><pre class="programlisting">&lt;ScrollView&gt;:
    canvas.before:
        Color:
            rgb: 1, 1, 1
        Rectangle:
            pos: self.pos
            size: self.size</pre></div><p>This draws a white rectangle behind the <code class="literal">ScrollView</code> unconditionally before every other drawing operation takes place. Don't forget to tweak the <code class="literal">&lt;ChatLabel&gt;</code> class, setting text color to something readable on a light background:</p><div><pre class="programlisting">#:import C kivy.utils.get_color_from_hex

&lt;ChatLabel@Label&gt;:
    color: C('#101010')</pre></div><p>This is what we have so far:</p><div><img src="img/B01620_04_08.jpg" alt="Overscroll modes"/><div><p>Chatroom screen, devoid of meaningful conversations</p></div></div><p>Again, the <strong>Disconnect</strong> button just switches screens without any networking going on behind<a id="id322" class="indexterm"/> the scenes. This is the next topic<a id="id323" class="indexterm"/> actually; as you will see shortly, implementing simple network programs in Python is not very different in terms of complexity from building a simple user interface with Kivy.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Bringing the app online</h1></div></div></div><p>This is <a id="id324" class="indexterm"/>the interesting part! We are going to establish the connection with the server, send and receive messages, and display meaningful output to users.</p><p>But first, let's take a look at the minimal, pure-Python implementation of the chat client, to see what's going on. This is low-level code using a socket to communicate. In practice, using a higher-level abstraction, like Twisted, is almost always advised; but if you're not familiar with the underlying concepts, it may be hard to grasp what happens in your code behind the scenes, which turns debugging into guesswork.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Building a simple Python client</h2></div></div></div><p>In the <a id="id325" class="indexterm"/>following listing, we're reading user input from the console using the built-in <code class="literal">readline()</code> function and displaying the output with <code class="literal">print()</code>. This means that using this simple client is not vastly different from using Telnet—the UI consists of the exact same plain text in a terminal window—but this time we implement it ourselves from scratch using sockets.</p><p>We are going to need a number of Python modules, all from the standard library: <code class="literal">socket</code>, <code class="literal">sys</code> (for <code class="literal">sys.stdin</code>, standard input file descriptor), and the <code class="literal">select</code> module to implement efficient waiting until the data is available. Assuming a new file, let's call it <code class="literal">client.py</code>:</p><div><pre class="programlisting">import select, socket, sys</pre></div><p>This program doesn't need external dependencies at all; this is as pure-Python as it gets.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Note than on Windows, <code class="literal">select</code> cannot poll file descriptors the same as sockets because of implementation details, so our code will not function correctly. Since this is only a demonstration of the low-level networking and not the final product, we aren't going to port it to marginal systems.</p></div></div><p>Now, we open the connection to server and do the usual <code class="literal">CONNECT</code> handshake:</p><div><pre class="programlisting">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 9096))
s.send('CONNECT')</pre></div><p>The next part in interesting: we wait for data to become available on either standard input (meaning that the user entered something), or the <code class="literal">s</code> socket (meaning that the server sent something our way). The waiting is achieved using the <code class="literal">select.select()</code> call:</p><div><pre class="programlisting">rlist = (sys.stdin, s)
while 1:
    read, write, fail = select.select(rlist, (), ())
    for sock in read:
        if sock == s:  # receive message from server
            data = s.recv(4096)
            print(data)
        else:  # send message entered by user
            msg = sock.readline()
            s.send(msg)</pre></div><p>Then, depending on the source of newly available data, we either print it on the screen in case of a message received from the server, or send it to the server if it's a message from the local user. Again, this is more or less what Telnet does, sans error checking.</p><p>As you can see, there is nothing inherently impossible or insanely complex in low-level networking. But for what it's worth, raw sockets are still quite cumbersome to handle and we will <a id="id326" class="indexterm"/>illustrate the high-level approach to the same code soon. However, this is what happens under the hood of any framework; ultimately, it's always sockets doing the heavy lifting, presented under a different sauce of abstractions (APIs).</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Note that in this tutorial we are not doing extensive error checking on purpose, because it will increase the amount of code by the factor of 2-3 and make it unwieldy.</p><p>There are lots of things that can go wrong over the network; it's more fragile than it's commonly perceived to be. So if you're planning to compete with Skype <em>et al.</em>, be ready to do incredible amounts of error checking and testing: network problems such as packet loss and nationwide firewalls, to name a few, will surely bite at some point. No matter how well-planned your architecture is, making network services highly available is hard.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Kivy integration with Twisted</h2></div></div></div><p>Another<a id="id327" class="indexterm"/> reason why our low-level client code is not a good fit for a Kivy application is that it relies on its own main loop (the <code class="literal">while 1:</code> part). It will take some work to make this code play well with the event loop that powers Kivy.</p><p>Instead, let's take advantage of the Twisted integration that's distributed as a part of Kivy. This also means that the same network library will be used on both the client and the server, making the code more uniform across the board.</p><p>The necessary step to make Kivy's main loop play well with Twisted is to run the following code before the Twisted framework is even imported:</p><div><pre class="programlisting">from kivy.support import install_twisted_reactor
install_twisted_reactor()

from twisted.internet import reactor, protocol</pre></div><p>The code should be at the very beginning of the <code class="literal">main.py</code> file. This is crucial to get right, otherwise everything<a id="id328" class="indexterm"/> will cease to function in obscure ways.</p><p>Now, let's implement the chat client using Twisted.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>ChatClient and ChatClientFactory</h3></div></div></div><p>On the<a id="id329" class="indexterm"/> Twisted part, there is surprisingly <a id="id330" class="indexterm"/>little to do, since the framework takes care of everything that's related to actual networking. These classes are used mostly to wire the "moving parts" of the program together.</p><p>The <code class="literal">ClientFactory</code> subclass, <code class="literal">ChatClientFactory</code>, will just store the Kivy app instance when initialized so that we can pass events to it later. Take a look at the following code:</p><div><pre class="programlisting">class ChatClientFactory(protocol.ClientFactory):
    protocol = ChatClient

    def __init__(self, app):
        self.app = app</pre></div><p>The complementary <code class="literal">ChatClient</code> class listens to <code class="literal">connectionMade</code> and <code class="literal">dataReceived</code> events from Twisted and passes them to the Kivy app:</p><div><pre class="programlisting">class ChatClient(protocol.Protocol):
    def connectionMade(self):
        self.transport.write('CONNECT')
        self.factory.app.on_connect(self.transport)

    def dataReceived(self, data):
        self.factory.app.on_message(data)</pre></div><p>Note the ubiquitous <code class="literal">CONNECT</code> handshake.</p><p>This is very different from the code utilizing raw sockets, right? At the same time, this is very similar to what happens on the server side in <code class="literal">server.py</code>. But, instead of actually handling events, we're just passing them to the <code class="literal">app</code> object.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>UI integration</h2></div></div></div><p>In order <a id="id331" class="indexterm"/>to finally see the whole picture, let's hook the networking code up to the UI and write the missing Kivy application class. The following are the cumulative updates that need to be applied to the <code class="literal">chat.kv</code> file:</p><div><pre class="programlisting">Button:  <strong># Connect button, found on login screen</strong>
    text: 'Connect'
    on_press: app.connect()

Button:  <strong># Disconnect button, on chatroom screen</strong>
    text: 'Disconnect'
    on_press: app.disconnect()

TextInput:  <strong># Message input, on chatroom screen</strong>
    id: message
    on_text_validate: app.send_msg()

Button:  <strong># Message send button, on chatroom screen</strong>
    text: 'Send'
    on_press: app.send_msg()</pre></div><p>Notice how<a id="id332" class="indexterm"/> buttons don't switch screens anymore, instead they call methods on <code class="literal">app</code>, similar to <code class="literal">ChatClient</code> event handling.</p><p>Having done that, we now need to implement a grand total of five methods that are missing from the Kivy application class: two for server-originated events that come from Twisted code (<code class="literal">on_connect</code> and <code class="literal">on_message</code>), and three more for the user interface events (<code class="literal">connect</code>, <code class="literal">disconnect</code>, and <code class="literal">send_msg</code>). This will make our Chat app actually usable.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Application logic of the client</h2></div></div></div><p>Let's begin <a id="id333" class="indexterm"/>writing the program logic in roughly the lifecycle order: from <code class="literal">connect()</code> to <code class="literal">disconnect()</code>.</p><p>In the <code class="literal">connect()</code> method, we pick up the values of <strong>Server</strong> and <strong>Nickname</strong> fields, as provided by the user. The nickname is then stored in <code class="literal">self.nick</code>, and the Twisted client connects to the specified host, as shown in the following code:</p><div><pre class="programlisting">class ChatApp(App):
    def connect(self):
        host = self.root.ids.server.text
        self.nick = self.root.ids.nickname.text
        reactor.connectTCP(host, 9096,
                           ChatClientFactory(self))</pre></div><p>Now, the <code class="literal">ChatClient.connectionMade()</code> function is called, passing control to the <code class="literal">on_connect()</code> method. We will use this event to store the connection in <code class="literal">self.conn</code> and switch screens. As discussed previously, buttons no longer switch screens directly; instead, we rely on more specific event handlers like this one:</p><div><pre class="programlisting"># From here on these are methods of the ChatApp class
def on_connect(self, conn):
    self.conn = conn
    self.root.current = 'chatroom'</pre></div><p>Now the main part: sending and receiving messages. This is very straightforward actually: to send a message we get the message text from the <code class="literal">TextInput</code>, get our nickname from <code class="literal">self.nick</code>, concatenate them together, and send the resulting line to the server. We also echo the same message onscreen and clear the message input box. The code is as follows:</p><div><pre class="programlisting">def send_msg(self):
    msg = self.root.ids.message.text
    self.conn.write('%s:%s' % (self.nick, msg))
    self.root.ids.chat_logs.text += ('%s says: %s\n' %
                                     (self.nick, msg))
    self.root.ids.message.text = ''</pre></div><p>Receiving<a id="id334" class="indexterm"/> messages is completely trivial; since we don't proactively keep track of them, just put the newly arrived message onscreen followed by a newline, and that's all:</p><div><pre class="programlisting">def on_message(self, msg):
    self.root.ids.chat_logs.text += msg + '\n'</pre></div><p>The last remaining method is <code class="literal">disconnect()</code>. It does exactly what it says on the tin: closes the connection and performs a general cleanup to return things back as they were when the program first started (notably, empties the <code class="literal">chat_logs</code> widget). Finally, it sends the user back to the login screen, so they can jump to another server or change nickname. The code is as follows:</p><div><pre class="programlisting">    def disconnect(self):
        if self.conn:
            self.conn.loseConnection()
            del self.conn
        self.root.current = 'login'
        self.root.ids.chat_logs.text = ''</pre></div><p>With this, our app finally has the ability to send and receive chat messages.</p><div><img src="img/B01620_04_09.jpg" alt="Application logic of the client"/><div><p>Chat app in action</p></div></div><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>
<strong>Caveats</strong>
</p><p>During testing, the <code class="literal">server.py</code> script should obviously be running at all times; otherwise, our app won't have an endpoint to connect to. Presently, this will result in the app staying on the login screen; in the absence of an <code class="literal">on_connect()</code> call, the user won't get to the chatroom screen.</p><p>Also, when<a id="id335" class="indexterm"/> testing on Android, make sure you enter the correct IP address of the server, as it will <em>not</em> be <code class="literal">127.0.0.1</code> anymore—that's always the local machine, so on an Android device this will mean that very device and not the computer you're working on. Use the <code class="literal">ifconfig</code> utility (called <code class="literal">ipconfig</code> on Windows for additional confusion) to determine the correct network address of your machine.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Cross-application interoperability</h2></div></div></div><p>One<a id="id336" class="indexterm"/> interesting property of the resulting application (besides the fact that it works at all) is that it's compatible with every client mentioned in this chapter. Users can connect to the server using Telnet, the pure-Python client, or the Kivy UI program—the core functionality is equally available to all of them.</p><p>This is very similar to how the Internet operates: once you have a well-defined protocol (such as HTTP), many unrelated parties can develop servers and clients that will be ultimately interoperable: web servers, web browsers, search engine crawlers, and so on.</p><p>A protocol is a higher form of an API, language- and system-independent, like a good foundation should be. While not many web developers are familiar with the API of, for example, Microsoft Silverlight released in 2007, anyone working in the field knows at least the <a id="id337" class="indexterm"/>basics of HTTP, documented in 1991. Such a level of ubiquity is nearly impossible to achieve with a library or framework.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Enhancements and eye candy</h1></div></div></div><p>Now that<a id="id338" class="indexterm"/> our chat basically works, we can apply some finishing<a id="id339" class="indexterm"/> touches to it, for example, improve the chat log presentation. Since the client already displays anything that the server sends its way, we can easily use Kivy markup (<strong>BBCode</strong>-like markup language, discussed in <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <em>Building a Clock App</em>) to style the conversation log.</p><p>To do this, let's assign a color to each user and then paint the nickname with this color and make it bold. This will help readability and generally look nicer than a wall of monochrome plain text.</p><p>We'll use <a id="id340" class="indexterm"/>the <strong>Flat UI</strong> color palette instead of generating purely random colors, because generating substantially different colors that look good when used together is by itself not an easy task.</p><p>Outgoing messages (those sent by the current user) don't come from the server and are added to chat log by the client code instead. So, we will paint the current user's nickname with a constant color right on the client.</p><p>After this update, the final code of the chat server, <code class="literal">server.py</code>, is as follows:</p><div><pre class="programlisting">colors = ['7F8C8D', 'C0392B', '2C3E50', '8E44AD', '27AE60']

class Chat(protocol.Protocol):
    def connectionMade(self):
        self.color = colors.pop()
        colors.insert(0, self.color)</pre></div><p>Given a finite list of colors, we pop one from the end of the list, and then insert it back to the front, creating a rotating buffer.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>If you're familiar with the more advanced <code class="literal">itertools</code> module from the standard library, you can rewrite the code we just saw like this:</p><div><pre class="programlisting">import itertools
colors = <strong>itertools.cycle</strong>(('7F8C8D', 'C0392B', '2C3E50', '8E44AD', '27AE60'))
def connectionMade(self):
    self.color = <strong>colors.next()</strong>
    # <strong>next(colors)</strong> in Python 3</pre></div></div></div><p>And now, we will discuss the bit where we pass the message to the client. The markup for the desired effect is very straightforward: <code class="literal">[b][color]Nickname[/color][/b]</code>. The code that makes use of it is equally simple:</p><div><pre class="programlisting">for t in transports:
    if t is not self.transport:
        t.write('[b][color={}]{}:[/color][/b] {}'
                .format(self.color, user, msg))</pre></div><p>The client in <code class="literal">main.py</code> is also updated to match formatting, as discussed earlier. Here, we have a constant color, which is different from the ones assigned by the server, so that the current user always stands out. The code is as follows:</p><div><pre class="programlisting">def send_msg(self):
    msg = self.root.ids.message.text
    self.conn.write('%s:%s' % (self.nick, msg))
    self.root.ids.chat_logs.text += (
        '[b][color=2980B9]{}:[/color][/b] {}\n'
        .format(self.nick, msg))</pre></div><p>Then, we set the <code class="literal">markup</code> property to <code class="literal">True</code> on the conversation log widget, <code class="literal">ChatLabel</code>, as shown in the following code snippet, and we're (almost) done:</p><div><pre class="programlisting">&lt;ChatLabel@Label&gt;:
    markup: True</pre></div><p>However, before <a id="id341" class="indexterm"/>we solve a problem with this approach (and there's indeed at least one serious problem here), here's the obligatory resulting screenshot. This<a id="id342" class="indexterm"/> is how the final conversation screen looks like:</p><div><img src="img/B01620_04_10.jpg" alt="Enhancements and eye candy"/><div><p>Colorful chat logs help readability and generally look better and more "polished"</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Escaping the special syntax</h2></div></div></div><p>One <a id="id343" class="indexterm"/>shortcoming in this code, as mentioned earlier, is that now we have special syntax in the protocol that's interpreted in a certain way on the client. Users can forge (or just inadvertently use, by pure chance) the BBCode-ish markup, creating unwanted visual glitches, such as assigning very large font sizes and unreadable colors. For example, if one of the users posts an unclosed <code class="literal">[i]</code> tag, all following text in the chatroom will be italicized. That's pretty bad.</p><p>In order to prevent users from highlighting text in random ways, we need to escape all markup that may exist in the message. Fortunately, Kivy provides a function to do just that, <code class="literal">kivy.utils.escape_markup</code>. Bad news is that it's been bugged since 2012.</p><p>There's a high probability that the function will have been fixed by the time you're reading this book, but for the sake of completeness, here's an implementation that works:</p><div><pre class="programlisting">def esc_markup(msg):
    return (msg.replace('&amp;', '&amp;amp;')
            .replace('[', '&amp;bl;')
            .replace(']', '&amp;br;'))</pre></div><p>With this, all<a id="id344" class="indexterm"/> characters that are special to Kivy markup are replaced with HTML-style character entities, so the markup passed through this function will be displayed as is and won't affect the rich text attributes in any way.</p><p>We need to call this function in two places, on the server when sending messages to clients, and on the client when displaying messages from self (the current user).</p><p>In <code class="literal">server.py</code>, the relevant portion of the code looks like this:</p><div><pre class="programlisting">t.write('[b][color={}]{}:[/color][/b] {}'
        .format(self.color, user,
                esc_markup(msg)))</pre></div><p>In <code class="literal">main.py</code>, the implementation is similar:</p><div><pre class="programlisting">self.root.ids.chat_logs.text += (
    '[b][color=2980B9]{}:[/color][/b] {}\n'
    .format(self.nick, esc_markup(msg)))</pre></div><p>Here, the vulnerability is patched; now users can safely send BBCode markup to each other if they choose to do so.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>Interestingly, this type of bug is also very pervasive in Internet apps. When applied to websites, it's called <strong>cross-site scripting</strong> (<strong>XSS</strong>) and allows much more damage than merely changing fonts and colors.</p><p>Don't forget to sanitize all user input in all scenarios that may involve commands (such as markup, inline scripts, even ANSI escape codes) mixed in with the data; neglecting to do so is a sure-fire disaster waiting to happen.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>What's next</h2></div></div></div><p>Obviously, this is only the beginning. The implementation at hand still has a vast number of deficiencies: user names aren't enforced to be unique, and there is no history and no support for fetching messages that have been sent while other parties were offline. Hence, bad network with frequent disconnects will render this application mostly unusable.</p><p>But what matters is that these points can certainly be addressed, and we already have a working prototype. In the start-up world, having a prototype is an attractive quality, particularly when raising funds; if you're programming for fun mostly, it's even more so, as seeing a working product is greatly motivating (as opposed to observing a pile of code that doesn't so much as run yet).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>As we saw in this chapter, client-server application development (and generally speaking, networking on the application level) isn't necessarily inherently complex. Even the low-level code utilizing sockets is quite manageable.</p><p>There are, of course, many gray areas and aspects that are hard to get right when writing an app that makes heavy use of the network. Examples of these include working around high latency, restoring an interrupted connection, and syncing across a large number of nodes (especially peer-to-peer or multi-master, when none of the machines have the full dataset).</p><p>Another relatively new class of network problems is the political one. Lately, Internet regulations are being implemented by governments of varying oppressiveness, ranging from relatively logical (for example, blocking resources promoting terrorism) to completely nonsensical (for example, banning educational sites like Wikipedia, major news sites, or video games). This type of connectivity problem is also known for high collateral damage, for example, if a <strong>content delivery network</strong> (<strong>CDN</strong>) goes down, then many sites that link to it will cease to work properly.</p><p>However, with careful programming and testing, it is certainly possible to overcome every obstacle and deliver a product of exceptional quality to your users. Rich Python infrastructure shoulders some of this burden for you, as shown in our Chat program: many low-level details are abstracted with the help of Kivy and Twisted, two excellent Python libraries.</p><p>The possibilities in this field, given the universal accessibility, are nothing short of endless. We will discuss and implement a way more interesting use case for a networked app in the next chapter, so read on.</p></div></body></html>