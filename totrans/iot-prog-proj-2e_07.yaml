- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an IoT Button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build an essential component of our IoT home security
    system: an IoT button. We will build two versions of this button, using different
    hardware bases – the M5Stack ATOM Matrix and the Raspberry Pi Pico W.'
  prefs: []
  type: TYPE_NORMAL
- en: The M5Stack ATOM Matrix is a compact ESP32-based microcontroller boasting a
    built-in dot-matrix screen that also serves as a touch button, a design choice
    that significantly reduces its size, making it a highly compact solution for IoT
    projects. Our now familiar Raspberry Pi Pico W stands as a favored microcontroller
    option, noted for its versatility and seamless integration with a wide array of
    external peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build a simple version of an IoT button, starting with the ATOM Matrix,
    before we create a more advanced version with our Raspberry Pi Pico W:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – IoT button architecture](img/B21282_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – IoT button architecture
  prefs: []
  type: TYPE_NORMAL
- en: In our design, the IoT alarm module (from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091)),
    Raspberry Pi Pico W, and M5Stack ATOM Matrix all communicate using the `IoTAlarm`
    topic, as represented by the black box with white lettering in the cloud in *Figure
    7**.1*. In our graphic, we moved the topic to the cloud since we are now familiar
    with the MQTT protocol and no longer need to represent it visually. Messages are
    presented as white boxes with black lettering, and while every device can read
    and send any message through this topic, they are configured to filter relevant
    messages and transmit device-specific ones. In *Figure 7**.1*, we see the specific
    messages each device handles as well as the difference in complexity between the
    implementation of our two IoT button microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use CloudAMQP for MQTT communication with our second IoT button, ensuring
    efficient and reliable data transmission through its scalable messaging service.
    This enhances the button’s performance and real-time data exchange reliability.
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate the creation process of these buttons, we deepen our understanding
    of MQTT communication and Python programming while getting accustomed to different
    hardware platforms. By using two distinct bases for our projects, we equip ourselves
    with the insight needed to choose the best platform for our upcoming IoT applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IoT buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our IoT button using the M5Stack ATOM Matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving on our IoT button with the Raspberry Pi Pico W
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x M5Stack ATOM Matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico WH (with headers) to use with breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Raspberry Pi Pico W (no headers) to be installed in an optional 3D-printed
    case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 24 mm arcade-style pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x mini SPST switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 0.96-inch OLED screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x LED connected with a 220 Ohm resistor (as previously used in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x SFM-27 active buzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 x M2 5 mm screws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M4 20 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x M4 nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 x M3 10 mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x M5 25 mm bolt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x M5 nut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x LED holder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot glue gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer to print optional case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IoT buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toward the end of the animated movie *WALL-E* (2008), Captain McCrea battles
    against the AI autopilot to regain control of the Axiom spaceship by pushing a
    big blue button. This results in the massive Axiom starting its hyperjump on a
    return to Earth. The single button in sci-fi often stands as a beacon of innovation,
    a dramatic tool that accentuates pivotal moments. In the case of *WALL-E*, this
    button surpasses a simple one-action result, such as sounding a buzzer, and instead
    carries the weight of humanity’s future, triggering a series of actions that eventually
    lead to the redemption and rebirth of both mankind and Earth.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build our own powerful button, although not one with
    the power of the blue button from *WALL-E*. Our button will, however, introduce
    us to the world of IoT buttons where single actions can trigger a series of automated
    tasks – in our case, interacting with the IoT alarm module we built in the last
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing IoT buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IoT buttons are central in the IoT landscape, bridging distances with the aid
    of the internet to initiate actions globally. Consider the possibility of activating
    a machine in Mumbai with a button press from Toronto or remotely triggering an
    alarm to assist a dormitory-based student in waking up on time for classes. This
    global reach transforms simple buttons into powerful tools, making daily tasks
    more efficient and connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few examples of what we can do with IoT buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart home control button**: This button facilitates control over various
    household appliances and systems through simple configured commands – a single
    or double press can control lights'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordering button**: Especially useful in retail settings, this button facilitates
    quick orders or reorders of specific products from suppliers, enhancing business
    efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback button**: These buttons can be installed in corporate or service
    environments to accumulate immediate feedback from users or customers, helping
    to maintain a high standard of service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conference room booking button**: In office spaces, these buttons can aid
    in the smooth booking of conference rooms, preventing booking conflicts and promoting
    efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart agriculture**: These buttons can streamline processes in agriculture,
    with functionalities such as immediate watering of farm sections or automated
    feed release for livestock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use our IoT button to interact with our IoT alarm module.
    For this, we will build a simple button with the M5Stack ATOM Matrix and a more
    complex button with our Raspberry Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring various technologies in IoT button development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the fast-growing field of IoT, the choice of technology can greatly affect
    the functionality and adaptability of the devices we create. In this chapter,
    we adopt this approach as we use two different yet effective platforms – the M5Stack
    ATOM Matrix and the Raspberry Pi Pico W – to construct IoT buttons with varying
    levels of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the M5Stack ATOM Matrix to build our initial button. This microcontroller
    is notable for its compactness, featuring an integrated dot-matrix screen that
    functions as a touch button. Its straightforward design not only allows for easy
    assembly but also supports a simple button solution, ideal for our first IoT button
    (see *B* in *Figure 7**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix](img/B21282_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix
  prefs: []
  type: TYPE_NORMAL
- en: Building on what we learned from the ATOM Matrix project, we then move on to
    leverage the capabilities of the Raspberry Pi Pico W (see *A* in *Figure 7**.2*).
    We know this platform for its versatility and compatibility with various peripherals.
    This offers us more customization in button development. The Raspberry Pi Pico
    W enables us to create a button with a higher degree of functionality than the
    M5Stack ATOM Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Working with two different technological bases not only broadens our understanding
    but also encourages a flexible approach to IoT project development. This progression
    from a simple to a more advanced button is designed to help us steadily build
    on our knowledge, equipping us with the insight to choose the right platform for
    future IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our IoT button using the M5Stack ATOM Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Figure 7**.1*, we depict the ATOM Matrix on the right-hand side, receiving
    a `motion` input message and issuing a `buzzer` output message. These messages
    are associated with **passive infrared** (**PIR**) sensor detections and buzzer
    activation on the IoT alarm module, respectively. Utilizing its integrated dot-matrix
    screen, which also serves as a touch button, we will use the M5Stack ATOM Matrix
    to create our first IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: Before we initiate the setup and programming of the ATOM Matrix, let’s take
    a moment to familiarize ourselves with the range of products M5Stack offers.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring M5Stack devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: M5Stack is known for its stackable development kits, suitable for hobbyists
    and professionals alike. Based on the ESP32 microcontroller, these kits offer
    functionality and scalability, crucial for IoT, AI, and robotics projects. M5Stack’s
    modules provide easy integration of various functionalities, coupled with a user-friendly
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7**.3*, we see a photo of various M5Stack devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – M5Stack devices](img/B21282_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – M5Stack devices
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the devices do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M5Stack Basic** (*A*): The M5Stack Basic is an all-encompassing central controller
    for IoT applications, powered by the Espressif ESP32 chipset housing two Xtensa®
    32-bit LX6 microprocessors with a 240 MHz peak frequency. It provides a rich array
    of development interfaces, including **Analog-to-Digital Converter** (**ADC**),
    **Digital-to-Analog Converter** (**DAC**), and **Inter-Integrated Circuit** (**I2C**),
    alongside 15 Input/Output (IO) pins. It features a 2.0-inch HD **in-plane switching**
    (**IPS**) display panel, accompanied by a speaker and microSD card slot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**M5StickC PLUS** (*B*): The M5StickC PLUS is powered by ESP32-PICO-D4 with
    Wi-Fi. It offers a large 1.14-inch screen with 135 x 240 px resolution. The board
    houses infrared, **Real-Time Clock** (**RTC**), microphone, and LED, and features
    a robust 120 mAh battery. It supports HAT and Unit product families.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**M5Stack Unit LoRaWAN915** (*C*): The M5Stack Unit LoRaWAN915 is a **LoRaWAN**
    (short for **Long Range Wide Area Network**) module designed for 915 MHz frequency
    communications, leveraging the ASR6501 chipset to enable long-distance connections
    while maintaining low power usage and high sensitivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENV III HAT** (*D*): The ENV III HAT is a versatile environmental sensor
    compatible with the M5StickC series, housing the SHT30 and QMP6988 to measure
    temperature, humidity, and atmospheric pressure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ATOM Matrix** (*E*): The ATOM Matrix is M5Stack’s most compact development
    board at 24*24 mm, offering an extensive range of GPIO pins for compact embedded
    device projects. Powered by the ESP32-PICO-D4 chip, it integrates Wi-Fi technologies
    and 4 MB of **SPI** ( short for **Serial Peripheral Interface**) flash memory.
    The board features a 5*5 RGB LED matrix, an infrared LED, a programmable button
    for added input support, and a built-in **Inertial Measurement Unit** (**IMU**)
    sensor (MPU6886).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our first IoT button, we will be using the ATOM Matrix. While we could have
    opted for the Basic, M5StickC PLUS, or the newer ATOMS3 (not shown), as all these
    devices provide a pushbutton and a screen for feedback, we chose the ATOM Matrix
    because it offers a unique blend of compactness and simplicity, making it ideal
    for this introductory project. Furthermore, its integrated dot-matrix screen,
    doubling as a touch button, presents a more intuitive and interactive experience
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: M5Stack provides intuitive tools to set up and program our ATOM Matrix. We’ll
    begin with the burner tool to configure our Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Flashing the firmware to our ATOM Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The M5Burner allows us to flash firmware onto our M5Stack devices. This tool
    simplifies the process the process for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the tool, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We download the installation file from the M5Stack website using this URL:
    [https://docs.m5stack.com/en/download](https://docs.m5stack.com/en/download).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our project, we’ll download and install the Windows version of the burner.
    Once installed, we’ll run the program and click on the **ATOM** tab on the left,
    and we should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – M5Burner ATOM screen](img/B21282_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – M5Burner ATOM screen
  prefs: []
  type: TYPE_NORMAL
- en: The `UIFlow_MATRIX` firmware is designed for the ATOM Matrix, enabling drag-and-drop
    graphical programming that translates to MicroPython. It features built-in libraries
    and offers **over-the-air** (**OTA**) updates for wireless programming. We click
    on the **Download** button to download the firmware onto our local computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the firmware has finished downloading, we click on the **Burn** button
    (formally the **Download** button) to start flashing the **UIFlow_MATRIX** firmware
    onto our ATOM Matrix. We should see a dialog requesting our Wi-Fi information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By clicking the top-right blue button, we can auto-fill our computer’s Wi-Fi
    details or enter them manually. Once entered, we click **Next** to continue. We
    should see the **Burn** screen next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We choose the port where the ATOM Matrix is connected and click the **Start**
    button to initiate the firmware burn. A progress screen will then display the
    ongoing burn status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon successful completion, we click on the green **Burn successfully, click
    here to** **return** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Burn successful](img/B21282_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Burn successful
  prefs: []
  type: TYPE_NORMAL
- en: We now have successfully installed the **UIFlow_MATRIX** firmware onto our ATOM
    Matrix. We should observe that the dot-matrix screen on our device blinks green.
    This firmware comes with dedicated libraries that we will use to create our first
    IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: With the firmware installed, it is now time to configure our ATOM Matrix so
    that we can start programming it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the ATOM Matrix for programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To program our ATOM Matrix, we’ll use M5Stack’s UIFlow, specifically its Python
    environment. UIFlow serves as an online IDE, connecting to our devices through
    an API key. For successful development, it’s essential to retrieve this key and
    properly configure our ATOM Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure our ATOM Matrix, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **M5Burner** window, we click on the **ATOM** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We click on the **Configure** button in the **UIFlow_Matrix** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – UIFlow Matrix Configure button](img/B21282_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – UIFlow Matrix Configure button
  prefs: []
  type: TYPE_NORMAL
- en: This should open the **UIFlow Configuration** dialog, and the port to which
    our ATOM Matrix is connected should be displayed. We click on **Load** to proceed
    to the next screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring us to the next screen, **UIFlow Configuration**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Main UIFlow configuration screen](img/B21282_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Main UIFlow configuration screen
  prefs: []
  type: TYPE_NORMAL
- en: Using *Figure 7**.7* as a reference, we’ll focus on the parameters highlighted
    by the boxes. Starting with **COM**, it should be set to the port where our ATOM
    Matrix is connected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **APIKEY** parameter serves as the connection bridge between the UIFlow
    IDE and our device. We take note of this key and keep it easily accessible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Start Mode** determines the device’s startup behavior. We configure it to
    **Internet Mode** for connectivity with the UIFlow IDE. After programming our
    ATOM Matrix, this mode will switch to **App Mode** automatically. To re-connect
    with the IDE after that, we’ll need to revisit **M5Burner** and reset this to
    **Internet Mode**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the **WIFI SSID** and **WIFI Password** parameters if they are not already
    set to the correct values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click on the blue **Save** button to save the parameters to our ATOM Matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our ATOM Matrix configured, we’re set to start programming and turn the
    device into our first functional IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: Turning our ATOM Matrix into an IoT button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use M5Stack’s UIFlow online IDE for development as it provides a straightforward
    coding platform for M5Stack devices. We will make use of the API key that we recorded
    from the configuration of our device to connect to the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add MicroPython code to our ATOM Matrix, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an internet-enabled browser, we navigate to the following URL: [https://flow.m5stack.com](https://flow.m5stack.com).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be presented with a screen to choose either `UIFlow1.0` or `UIFlow2.0`.
    Since we are using an ATOM Matrix, we choose UIFlow1.0 and click on **Confirm**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the IDE, we click on the **</> Python** tab so that we can program our ATOM
    Matrix in MicroPython:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – UIFlow IDE](img/B21282_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – UIFlow IDE
  prefs: []
  type: TYPE_NORMAL
- en: 'To link our ATOM Matrix to UIFlow, we click the **Api key** label at the bottom
    left of the screen to open the **Setting** screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Setting screen](img/B21282_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Setting screen
  prefs: []
  type: TYPE_NORMAL
- en: We enter the API key for our device and click **OK** to connect our ATOM Matrix
    to the UIFlow IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code editor, we overwrite the existing code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before downloading the code to our ATOM Matrix, let’s break it down. We start
    with our imports:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`from m5stack import *`: Imports all functions and classes from the M5Stack
    library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from m5ui import *`: Imports all UI-related functions and classes for M5Stack.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from uiflow import *`: Imports all UIFlow-specific functions and classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from m5mqtt import M5mqtt`: Imports the `M5mqtt` class, which allows for MQTT
    communication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import time`: Imports the standard Python `time` library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then set our screen to black with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then define a function to scan for a press of button `A` (the screen) and
    call it `buttonA_pressFor()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this method, we publish a message with the `IoTAlarm` topic and `buzzer`
    payload when button `A` is pressed for 1 second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then create an instance of the `M5mqtt` class we call `m5mqtt` with the
    given parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The device name is set to `IoTMatrix`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The MQTT broker address is set to `broker.mqtthq.com`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The MQTT port is set to `1883`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide empty strings for username and password as none are required.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the MQTT keep-alive time set to `300` seconds.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our code then subscribes to the `IoTAlarm` topic and sets the callback function
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set the RGB LED matrix color to cyan as an initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final line starts the MQTT client, enabling it to send and receive messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the code in place, we download it to our ATOM Matrix by clicking on the
    blue **Download** button located on the lower right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the code loaded onto our ATOM Matrix, we are now ready to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our IoT button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our initial tests, we’ll use the MQTTHQ web client, as previously covered
    in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), before testing our IoT button
    on our IoT alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a browser, we navigate to the following URL: [https://mqtthq.com/client](https://mqtthq.com/client).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `IoTAlarm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `motion` message and press the orange **Publish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our ATOM Matrix, we should observe that our screen turns red for 5 seconds
    before returning to its initial color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `IoTAlarm` topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our ATOM Matrix, we press and hold down the main button (the screen) for
    1 second before releasing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `buzzer` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the successful completion of our MQTTHQ tests, we are now ready to test
    our IoT button on our IoT alarm module. Using a micro-USB cable, we plug the IoT
    alarm module we created in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) into
    a USB power brick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After initializing, we wave our hand in front of the PIR sensor and observe
    the screen on our ATOM Matrix turn red for 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing and holding the primary button on our ATOM Matrix for a second and
    then releasing should trigger the buzzer on our IoT alarm module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations are in order as we have just created our first IoT button using
    the M5Stack ATOM Matrix! As the connection between our IoT alarm module and our
    IoT button is through the internet, we may place either device anywhere in the
    world and have them communicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though our ATOM Matrix comes in a convenient form factor, as do all M5Stack
    controllers, we do have a custom stand that we may mount it with (*Figure 7**.10*).
    The 3D printer files are in the `Build Files` folder of this chapter’s GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – M5Stack ATOM Matrix stand](img/B21282_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – M5Stack ATOM Matrix stand
  prefs: []
  type: TYPE_NORMAL
- en: To use the stand, we position the ATOM Matrix (see *B* in *Figure 7**.10*) into
    the stand’s cup section (see *A* in *Figure 7**.10*) with the USB-C port facing
    the stand’s base. The stand features a rear hole, accommodating an M2 5 mm screw
    (not shown) to anchor the ATOM Matrix, which has a 2 mm mounting hole at the back.
    The stand is designed to accommodate a USB-C cable or adapter at a 90-degree angle.
    Additionally, it can be mounted over an opening to conceal the USB-C cable, making
    it suitable for ceilings or shelves.
  prefs: []
  type: TYPE_NORMAL
- en: With our first IoT button completed, we are now ready to build the more complex
    second version of our button.
  prefs: []
  type: TYPE_NORMAL
- en: Improving on our IoT button with the Raspberry Pi Pico W
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our IoT alarm system becomes more complex, the limitations of the public
    MQTTHQ server become increasingly evident. Given that it’s a public platform,
    its reliability can be inconsistent. Transitioning to a reliable, private server
    would significantly enhance our development process and system dependability.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will build an improved IoT button using a Raspberry Pi Pico
    W, a buzzer, an arcade-style pushbutton, a switch, an LED, and an OLED screen
    (*Figure 7**.11*). We’re enhancing our project’s reliability and efficiency by
    moving to a private MQTT server using CloudAMQP.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Enhanced IoT button](img/B21282_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Enhanced IoT button
  prefs: []
  type: TYPE_NORMAL
- en: While using a private server is optional, it stands as a significant upgrade
    over continuing with the public MQTTHQ server. The code in this section will still
    work with the public MQTTHQ server (with configuration changes); however, by opting
    for CloudAMQP, we will improve the reliability and security of our IoT alarm system.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up an MQTT instance with CloudAMQP.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a CloudAMQP instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CloudAMQP is a managed MQTT service optimized for IoT devices and applications.
    It ensures reliable, real-time messaging with features such as WebSockets and
    retained messages. With its intuitive interface, CloudAMQP caters to both hobbyists
    and enterprises and makes an excellent choice for our IoT alarm system.
  prefs: []
  type: TYPE_NORMAL
- en: We may view the pricing of the services here – [https://www.cloudamqp.com/plans.xhtml](https://www.cloudamqp.com/plans.xhtml)
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, the free **Little Lemur** service will suffice. Upon setting
    up an account, we create an instance to use with our project. To do so, we do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in to our account will bring up the **Instances** page. To create a
    new instance, we click on the green **Create New** **Instance** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will take us to the `IoTProgrammingProjects`, set our plan to `Little Lemur`,
    and leave the **Tags** field blank. We click on the green **Select Region** button
    to go to the next screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This takes us to the `CA-Central Canada-1(Canada)` under **AWS**. We click on
    the green **Review** button to go to the next screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Confirm new instance** screen, we review our instance settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create our instance, `IoTProgrammingProjects`, we click on the green **Create**
    **instance** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get more details on our instances, we click on the link in the `IoTAlarmSystem`
    link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking the link provides our instance details, which we’ll use to connect
    our applications to the MQTT server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – MQTT connection details](img/B21282_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – MQTT connection details
  prefs: []
  type: TYPE_NORMAL
- en: Having created our instance and obtained the details, we can now update the
    alarm module code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) to integrate
    with the new MQTT server and enhance its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our alarm module code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will modify the code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091)
    for our alarm module so that it will work with our more advanced second IoT button.
    Our revised code shifts from a public MQTTHQ server to the more dependable CloudAMQP
    private server.
  prefs: []
  type: TYPE_NORMAL
- en: To support this, our new code adds `USERNAME`, `MQTT_PASSWORD`, and `DEVICE_ID`
    authentication parameters to enhance security. Another significant update is the
    `ARMED` mode, which lets us arm or disarm the system via MQTT. The modified `motion_handler()`
    function, when detecting motion, considers the `ARMED` status, sounding the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our revised code alters the LED feedback system. Beyond showing Wi-Fi
    and MQTT connection statuses, the LED also indicates if the alarm is armed by
    blinking very slowly.
  prefs: []
  type: TYPE_NORMAL
- en: The new version of our IoT alarm module code may be found under the `CloudAMQP`
    folder of this chapter’s GitHub repository. To install the code onto the IoT alarm
    module, we follow the steps outlined in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  prefs: []
  type: TYPE_NORMAL
- en: Building our Raspberry Pi Pico W IoT button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second IoT button features significant advancements in both the hardware
    and software as we make use of the Raspberry Pi Pico W. The Raspberry Pi Pico
    W and the M5Stack ATOM Matrix ESP32 both stand out as impressive microcontrollers.
    The Pico W is notable for its dual-core ARM Cortex-M0+ processor and Wi-Fi capabilities,
    whereas the ATOM Matrix brings both Wi-Fi and Bluetooth to the table with its
    ESP32 chip. However, considering our second IoT button project values computational
    strength and Wi-Fi above all, we will go with the Raspberry Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: The inclusion of an OLED screen provides us with the status of the alarm, as
    well as acting as a monitor for our MQTT messages. Software-wise, the shift from
    a public MQTTHQ server to CloudAMQP’s private server improves reliability and
    security. This move reduces risks linked to public servers.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the components for our Pico W IoT button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the second version of our IoT button, we will be using an arcade-style button
    to send a message to arm the alarm module. An OLED screen will display MQTT messages
    sent back from the IoT alarm module. A `buzzer` message sent from the IoT alarm
    module will start a melody on the active buzzer that makes up the second version
    of the IoT button assembly. To disarm the IoT alarm module, we simply toggle a
    switch from its current position.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7**.13*, we see the components that make up our Raspberry Pi Pico
    W IoT button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander](img/B21282_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander
  prefs: []
  type: TYPE_NORMAL
- en: 'The components are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Single color LED with 220 Ohm resistor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: SM-127 active buzzer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: 0.96-inch OLED screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: 24 mm arcade button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: GPIO expander board for the Raspberry Pi Pico (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Raspberry Pi Pico WH for development usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: SPST switch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For development, we will use a Raspberry Pi Pico WH but switch to the non-header
    version for installation into the custom case.
  prefs: []
  type: TYPE_NORMAL
- en: Using a GPIO expander
  prefs: []
  type: TYPE_NORMAL
- en: The use of a GPIO expander (see *E* in *Figure 7**.13*) is optional. To use
    the expander, female jumper connections are required. Using a GPIO expander offers
    the benefit of easily transitioning components to installations with the Pico
    WH in future projects, thanks to its female jumper connections.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our construction of the Raspberry Pi Pico W IoT button by examining
    the wiring diagram on a standard breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up our Raspberry Pi Pico W IoT button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Figure 7**.14*, we can see a wiring diagram for the Raspberry Pi Pico W
    IoT button. We will use a standard micro-USB cable connected to the USB port of
    the Pico WH to provide power. The 3.3 V pin from the Pico W is used to provide
    power to the rails of the breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram](img/B21282_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram
  prefs: []
  type: TYPE_NORMAL
- en: Now that our wiring is set, we’ll move on to the coding phase. We will start
    by loading the necessary packages we require for our code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the required packages for our program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The packages required to run our code for our Raspberry Pi Pico W IoT button
    are the `micropython-umqtt.simple` package and the `micropython-ssd1306` package.
    To load the packages onto our Raspberry Pi Pico W, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Thonny IDE, we click on **Tools** | **Manage packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, we type in the name of the package we would like to search
    for and then click on the **Search on** **PyPI** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then proceed to install the package by clicking on the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What to do if there are errors when loading packages?
  prefs: []
  type: TYPE_NORMAL
- en: In situations where there is an error when loading a package, we may simply
    copy the `library` folder from our GitHub repository to our Pico W. The folder
    may be found under `Second IoT Button/library-files-from-pico-w` from this chapter’s
    repository. See *Figure 7**.15* for clarification on the file structure of the
    Raspberry Pi Pico W.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to write our code, we should verify that the file structure
    on our Pico W looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Raspberry Pi Pico W library structure](img/B21282_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Raspberry Pi Pico W library structure
  prefs: []
  type: TYPE_NORMAL
- en: With our packages installed, it is now time to write our code. We will start
    with code to control the buzzer as it will be contained in a separate file from
    the main code.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the buzzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Figure 7**.1*, we see a `buzzer` message sent from the IoT alarm module.
    In our rewrite of the IoT alarm module code, a `buzzer` message is sent out when
    the alarm has been armed and motion is detected from the PIR sensor. We will use
    this message in our Raspberry Pi Pico W IoT button to activate its alarm, although
    we will use it to play a melody through its speaker. As we did with the IoT alarm
    module code, we will use a separate file for our code to activate the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we test out our code, let’s break it down:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing `Pin` and `PWM` from the `machine` module, and the `utime`
    module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `BUZZER_PIN` constant to pin number `16`, which corresponds to our
    wiring diagram (*Figure 7**.14*).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then initialize `buzzer` using the `PWM` class with the defined pin.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `play_notes()` function takes a default argument, `notes`, which is a list
    of tuples. Each tuple represents a frequency in Hertz (such as `E4`, `C4`, and
    so on) and a duration in seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each frequency-duration pair in the `notes` list, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the buzzer’s frequency to the specified frequency.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We activate the buzzer with a 50% duty cycle (`duty_u16(32768)`). This produces
    a square wave, defining the character of the sound emitted by the buzzer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We wait for the specified duration using `utime.sleep(duration)`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After playing all the notes, we turn off the buzzer (by setting its duty cycle
    to 0).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on `buzzer.py` to our Raspberry Pi Pico W.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test our code, we use the `play_notes()` function from our new buzzer script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Importing the play_notes() function](img/B21282_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Importing the play_notes() function
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate our buzzer, we simply call the function and hit *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Running the play_notes() function](img/B21282_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Running the play_notes() function
  prefs: []
  type: TYPE_NORMAL
- en: 'We should hear our buzzer play its default melody. To test our function further,
    let’s send `[(262, 1),(330, 2),(392, 0.5),(262, 1)]` notes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Playing a new melody with the play_notes() function](img/B21282_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Playing a new melody with the play_notes() function
  prefs: []
  type: TYPE_NORMAL
- en: We should notice that a different melody plays from our buzzer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our buzzer code in place, it’s now time to focus on the main code that
    will power our Raspberry Pi Pico W IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the primary functionality for our IoT button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After finalizing the buzzer script, we’re ready to develop the main code for
    our enhanced IoT button. This new iteration can arm the IoT alarm module and features
    a display screen. The screen indicates the alarm module’s status (either armed
    or disarmed) and presents the latest MQTT message from our CloudAMQP server.
  prefs: []
  type: TYPE_NORMAL
- en: When the IoT alarm module triggers, our IoT button’s buzzer provides audible
    feedback. It activates upon receiving a `buzzer` message. We use the switch on
    our IoT button assembly as a toggle to disarm the alarm on our IoT alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the code for our enhanced IoT button, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start with our imports. In a new tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define variables with values obtained from our CloudAMQP account (*Figure
    7**.12*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `on_message_received()` method serves as our MQTT client’s callback. By
    using the `global` keyword with `last_message`, we ensure updates to this variable
    are reflected globally throughout the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `connect_wifi()` function initializes and activates Pico W’s Wi-Fi. If
    not connected, it attempts to join the network using a predefined SSID and password.
    Meanwhile, an LED blinks to indicate the connection process. Upon successful connection,
    the LED stays on, and the device’s IP address is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `connect_mqtt()` function tries to establish an MQTT connection using predefined
    server details. If successful, it sets a message callback and subscribes to the
    `IoTAlarm` topic. If the connection fails, the function waits for 5 seconds and
    retries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `display_status()` function continuously updates the display every 5 seconds.
    It shows the MQTT connection status at the top, the `arm`/`disarm` status in the
    middle, and the last received MQTT message at the bottom. If connected to MQTT,
    `MQTT Connected` is displayed; otherwise, `MQTT waiting` is shown. We run this
    method in a separate thread in our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function initiates Wi-Fi and MQTT connections and continuously
    checks the button and switch states. If the button is pressed for over a second,
    an `arm` message is published via MQTT. If the switch state changes, a `disarm`
    message is sent. The function also checks for incoming MQTT messages. If an error
    occurs while checking for messages, the error is printed, and the system waits
    for 5 seconds before resuming checks. The system waits 0.1 seconds between loop
    iterations to optimize performance. We start by defining the `main()` function
    and variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define an infinite loop and check to see if the main button has been
    pressed for a second (`1000` ms) or greater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code then sends a `disarm` message if the current switch state is not equal
    to the previous switch state. This conditional check allows us to use our switch
    as a toggle and not have a defined on or off state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then initialize a new thread to run the `display_status()` function concurrently.
    By using threading, it allows the `display_status()` function to operate independently
    and simultaneously with other parts of the program, ensuring continuous updates
    to the display status without hindering or waiting for other processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we call the `main()` function, which directs the program’s core activities
    — handling connections, button inputs, and managing MQTT messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save the file, we click on `main.py` to our Raspberry Pi Pico W.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our main code written, it is time to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Running our enhanced IoT button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Executing the code on our Raspberry Pi Pico W IoT button allows it to interact
    with the IoT alarm module. The button can arm or disarm the module. We will use
    the **MQTT Explorer** app in Windows to monitor real-time MQTT messages, as well
    as send messages to test our enhanced IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by sending messages from the MQTT Explorer app. To do so, we
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Microsoft Store in Windows, we search for the MQTT Explorer app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – MQTT Explorer in the Microsoft Store
  prefs: []
  type: TYPE_NORMAL
- en: We run `main.py` on our Raspberry Pi Pico W IoT button application by either
    clicking on the **Run** button in Thonny or by plugging our Pico W into a USB
    power supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using MQTT Explorer, we create a connection called `IoTAlarmSystem` with the
    MQTT server credentials from *Figure 7**.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Creating an MQTT connection using MQTT Explorer](img/B21282_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Creating an MQTT connection using MQTT Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a message using MQTT Explorer, we type in `IoTAlarm` for the topic
    and `test` for the message before clicking on the **PUBLISH** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Sending an MQTT message](img/B21282_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Sending an MQTT message
  prefs: []
  type: TYPE_NORMAL
- en: We should observe that a `test` message appears on the OLED screen of our IoT
    button circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then press and hold the arcade pushbutton on the IoT button circuit for more
    than a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe an `arm` message on the MQTT Explorer app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should also observe the LED on the IoT alarm module start blinking every
    5 seconds. This indicates that the IoT alarm module is armed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We test the IoT alarm module by waving our hands in front of the PIR sensor.
    We should observe that the alarm goes off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe that after a short time, the alarm on the enhanced IoT button
    circuit goes off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To disarm the alarm, we toggle the switch from its current position. This should
    result in the buzzer turning off when motion is detected by the PIR sensor. This
    should also disable the buzzer on the enhanced IoT button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should congratulate ourselves as we have successfully built a basic IoT alarm
    system! For the final section of this chapter, we will install the components
    into the custom 3D-printed case.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the components in a custom case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wiring our components and running our code is an exciting step. Yet, housing
    them in a custom case elevates our project and allows us to use our application
    for practical purposes. A custom case offers not only protection but also the
    versatility to install our advanced IoT button in any desired location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7**.22*, we view the components of our custom case, all 3D printed.
    Parts *A* and *B* were produced using a **Fused Deposition Modeling** (**FDM**)
    printer, while *C* and *D* utilized a liquid resin printer. While either printer
    type is suitable, FDM printing requires careful part orientation on the print
    bed to account for layer-line strength:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Custom case for enhanced IoT button](img/B21282_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Custom case for enhanced IoT button
  prefs: []
  type: TYPE_NORMAL
- en: 'The parts of our custom case are broken down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: Backplate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: Hook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Mounting bracket wall side mount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parts may be found in the `Pico Button` subfolder of the `Build Files` folder
    in this chapter’s GitHub repository. The mounting screws and LED holder are not
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the split stand with FDM printers
  prefs: []
  type: TYPE_NORMAL
- en: The split stand in the SenseHAT case files (`Build Files` folder, [*Chapter
    1*](B21282_01.xhtml#_idTextAnchor014) repository) is ideal for FDM printing. By
    splitting and printing each half on its side, the stand gains significant strength.
    An accompanying base is also provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the components into our custom case, we follow the steps in *Figure
    7**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by installing the buzzer (see *B* in *Figure 7**.13*) into the shell
    (see *A* in *Figure 7**.22*) with two M5 10 mm bolts and two M5 nuts (*Figure
    7**.23*, *Step 1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then (*Figure 7**.23*, *Step 2*), we install the switch (*Figure 7**.13*, *G*)
    and arcade pushbutton (see *D* in *Figure 7**.13*) into their appropriate holes
    in the shell (see *A* in *Figure 7**.22*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Constructing the case for the enhanced IoT button](img/B21282_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Constructing the case for the enhanced IoT button
  prefs: []
  type: TYPE_NORMAL
- en: Using an LED holder, we install the LED with 220 Ohm resistor (see *A* in *Figure
    7**.13*) into the shell (see *A* in *Figure 7**.22*) using the left-side hole
    (*Figure 7**.23*,*Step 3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the OLED screen (see *C* in *Figure 7**.13*) into the shell (see *A*
    in *Figure 7**.22*) using 4 M2 5 mm screws or glue from a hot glue gun (*Figure
    7**.23*,*Step 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then (*Figure 7**.23*, *Step 4*), we wire the components to a new Raspberry
    Pi Pico W.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then install the hook (see *C* in *Figure 7**.22*) onto the back plate (see
    *B* in *Figure 7**.22*) using two M2 5 mm screws (*Figure 7**.23*, *Step 5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the Pico W onto the back plate (see *B* in *Figure 7**.22*) with four
    M2 5 mm screws (*Figure 7**.23*, *Step 6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then (*Figure 7**.23*, *Step* *7*), we use four M3 10 mm bolts to secure the
    back plate (see *B* in *Figure 7**.22*) to the shell (see *A* in *Figure 7**.13*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the back plate (see *B* in *Figure 7**.22*) secured to the shell (see *A*
    in *Figure 7**.22*), we connect the assembly to the mounting bracket (see *D*
    in *Figure 7**.22*) using an M5 20 mm bolt and M5 nut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the steps from the section, *Coding the primary functionality for our
    IoT button*, we install the packages and client code for our enhanced IoT button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the components securely installed, we can now position our Raspberry Pi
    Pico W IoT button in any desired location, be it a home, office, or workshop setting.
    Our design not only serves our primary alarm system purpose but also makes it
    adaptable for a multitude of other applications, expanding its utility and offering
    potential for innovative integrations in many different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored IoT buttons, starting with a description of what
    they are and where they are used. We then explored various technologies that we
    could use to build an IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceeded to build our first IoT button using a public MQTT service
    and an M5Stack ATOM Matrix. We were able to connect our IoT button to the IoT
    alarm module we built in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  prefs: []
  type: TYPE_NORMAL
- en: From there, we upgraded our MQTT server to a private one using CloudAMQP. We
    did so for reliability and security reasons as we started to build out our IoT
    alarm system more. We upgraded the code sitting on our IoT alarm module before
    building our second IoT button using a Raspberry Pi Pico W and various components.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by installing the components of our second (enhanced)
    IoT button into a 3D-printed case. Doing so transformed our circuit from an educational
    tool to a working device suitable for deployment in commercial settings.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to build our IoT alarm system by going
    back to the Raspberry Pi, where we will build a security dashboard.
  prefs: []
  type: TYPE_NORMAL
