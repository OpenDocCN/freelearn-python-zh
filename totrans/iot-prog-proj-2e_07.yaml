- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building an IoT Button
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网按钮
- en: 'In this chapter, we will build an essential component of our IoT home security
    system: an IoT button. We will build two versions of this button, using different
    hardware bases – the M5Stack ATOM Matrix and the Raspberry Pi Pico W.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们物联网家庭安全系统的一个基本组件：一个物联网按钮。我们将使用不同的硬件基础构建这个按钮的两个版本——M5Stack ATOM Matrix
    和 Raspberry Pi Pico W。
- en: The M5Stack ATOM Matrix is a compact ESP32-based microcontroller boasting a
    built-in dot-matrix screen that also serves as a touch button, a design choice
    that significantly reduces its size, making it a highly compact solution for IoT
    projects. Our now familiar Raspberry Pi Pico W stands as a favored microcontroller
    option, noted for its versatility and seamless integration with a wide array of
    external peripherals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: M5Stack ATOM Matrix 是一款紧凑型 ESP32 基于的微控制器，内置点阵显示屏，也用作触摸按钮，这种设计选择显著减小了其尺寸，使其成为物联网项目的超紧凑型解决方案。我们熟悉的
    Raspberry Pi Pico W 是一个受欢迎的微控制器选项，以其多功能性和与各种外部外围设备的无缝集成而著称。
- en: 'We will build a simple version of an IoT button, starting with the ATOM Matrix,
    before we create a more advanced version with our Raspberry Pi Pico W:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建更高级的版本之前，我们将从 ATOM Matrix 开始构建一个简单的物联网按钮：
- en: '![Figure 7.1 – IoT button architecture](img/B21282_07_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 物联网按钮架构](img/B21282_07_01.jpg)'
- en: Figure 7.1 – IoT button architecture
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 物联网按钮架构
- en: In our design, the IoT alarm module (from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091)),
    Raspberry Pi Pico W, and M5Stack ATOM Matrix all communicate using the `IoTAlarm`
    topic, as represented by the black box with white lettering in the cloud in *Figure
    7**.1*. In our graphic, we moved the topic to the cloud since we are now familiar
    with the MQTT protocol and no longer need to represent it visually. Messages are
    presented as white boxes with black lettering, and while every device can read
    and send any message through this topic, they are configured to filter relevant
    messages and transmit device-specific ones. In *Figure 7**.1*, we see the specific
    messages each device handles as well as the difference in complexity between the
    implementation of our two IoT button microcontrollers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，物联网警报模块（来自[*第 6 章*](B21282_06.xhtml#_idTextAnchor091)）、Raspberry Pi
    Pico W 和 M5Stack ATOM Matrix 都使用 `IoTAlarm` 主题进行通信，如图 7.1 中的黑色框体上的白色文字所示。在我们的图形中，我们将主题移动到云中，因为我们现在熟悉
    MQTT 协议，不再需要用视觉表示它。消息以白色框体和黑色文字表示，虽然每个设备都可以通过此主题读取和发送任何消息，但它们被配置为过滤相关消息并传输特定于设备的消息。在图
    7.1 中，我们看到每个设备处理的特定消息以及我们两个物联网按钮微控制器实现的复杂性差异。
- en: We’ll use CloudAMQP for MQTT communication with our second IoT button, ensuring
    efficient and reliable data transmission through its scalable messaging service.
    This enhances the button’s performance and real-time data exchange reliability.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 CloudAMQP 进行 MQTT 通信，与我们的第二个物联网按钮进行通信，确保通过其可扩展的消息服务实现高效可靠的数据传输。这提高了按钮的性能和实时数据交换的可靠性。
- en: As we navigate the creation process of these buttons, we deepen our understanding
    of MQTT communication and Python programming while getting accustomed to different
    hardware platforms. By using two distinct bases for our projects, we equip ourselves
    with the insight needed to choose the best platform for our upcoming IoT applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导航这些按钮的创建过程时，我们在熟悉不同硬件平台的同时，加深了对 MQTT 通信和 Python 编程的理解。通过为我们的项目使用两个不同的基础，我们为自己提供了选择最佳平台以用于即将到来的物联网应用的洞察力。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Introducing IoT buttons
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍物联网按钮
- en: Creating our IoT button using the M5Stack ATOM Matrix
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 M5Stack ATOM Matrix 创建我们的物联网按钮
- en: Improving on our IoT button with the Raspberry Pi Pico W
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi Pico W 优化我们的物联网按钮
- en: Let’s begin!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 编程的中级知识
- en: 1 x M5Stack ATOM Matrix
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 M5Stack ATOM Matrix
- en: 1 x Raspberry Pi Pico WH (with headers) to use with breadboard
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Raspberry Pi Pico WH（带引脚）用于与面包板一起使用
- en: 1 x Raspberry Pi Pico W (no headers) to be installed in an optional 3D-printed
    case
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Raspberry Pi Pico W（无引脚）将安装在一个可选的 3D 打印外壳中
- en: 1 x 24 mm arcade-style pushbutton
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 24 毫米街机式按钮
- en: 1 x mini SPST switch
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个迷你 SPST 开关
- en: 1 x 0.96-inch OLED screen
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 0.96 英寸 OLED 屏幕
- en: 1 x LED connected with a 220 Ohm resistor (as previously used in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x LED与220欧姆电阻连接（如前所述，在 [*第3章*](B21282_03.xhtml#_idTextAnchor048) 中使用）
- en: 1 x SFM-27 active buzzer
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x SFM-27主动蜂鸣器
- en: 12 x M2 5 mm screws
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12 x M2 5毫米螺丝
- en: 2 x M4 20 mm bolts
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x M4 20毫米螺栓
- en: 2 x M4 nuts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x M4螺母
- en: 4 x M3 10 mm bolts
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x M3 10毫米螺栓
- en: 1 x M5 25 mm bolt
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x M5 25毫米螺栓
- en: 1 x M5 nut
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x M5螺母
- en: 1 x LED holder
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x LED支架
- en: Hot glue gun
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热胶枪
- en: Access to a 3D printer to print optional case
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有3D打印机打印可选外壳的访问权限
- en: 'The code for this chapter may be found here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter7)'
- en: Introducing IoT buttons
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍物联网按钮
- en: Toward the end of the animated movie *WALL-E* (2008), Captain McCrea battles
    against the AI autopilot to regain control of the Axiom spaceship by pushing a
    big blue button. This results in the massive Axiom starting its hyperjump on a
    return to Earth. The single button in sci-fi often stands as a beacon of innovation,
    a dramatic tool that accentuates pivotal moments. In the case of *WALL-E*, this
    button surpasses a simple one-action result, such as sounding a buzzer, and instead
    carries the weight of humanity’s future, triggering a series of actions that eventually
    lead to the redemption and rebirth of both mankind and Earth.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画电影 *WALL-E*（2008年）的结尾，麦考瑞上校与AI自动驾驶系统对抗，通过按下一个大蓝色按钮来重新控制Axiom宇宙飞船。这导致庞大的Axiom在返回地球时启动了超光速跳跃。在科幻小说中，单个按钮通常被视为创新的灯塔，一个强调关键时刻的戏剧性工具。在
    *WALL-E* 的案例中，这个按钮超越了简单的单一动作结果，比如发出蜂鸣声，而是承载着人类未来的重量，触发了一系列行动，最终导致了人类和地球的救赎和重生。
- en: In this chapter, we will build our own powerful button, although not one with
    the power of the blue button from *WALL-E*. Our button will, however, introduce
    us to the world of IoT buttons where single actions can trigger a series of automated
    tasks – in our case, interacting with the IoT alarm module we built in the last
    chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建自己的强大按钮，虽然它没有像 *WALL-E* 中的蓝色按钮那样的力量。然而，我们的按钮将带我们进入物联网按钮的世界，在这里，单个动作可以触发一系列自动化任务——在我们的案例中，是与我们在上一章中构建的物联网警报模块进行交互。
- en: Utilizing IoT buttons
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用物联网按钮
- en: IoT buttons are central in the IoT landscape, bridging distances with the aid
    of the internet to initiate actions globally. Consider the possibility of activating
    a machine in Mumbai with a button press from Toronto or remotely triggering an
    alarm to assist a dormitory-based student in waking up on time for classes. This
    global reach transforms simple buttons into powerful tools, making daily tasks
    more efficient and connected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网按钮在物联网领域中处于核心地位，借助互联网跨越距离，在全球范围内启动动作。考虑一下从多伦多按下按钮激活孟买机器的可能性，或者远程触发警报以帮助宿舍学生按时上课。这种全球范围将简单的按钮变成了强大的工具，使日常任务更加高效和互联。
- en: 'The following are a few examples of what we can do with IoT buttons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们可以用物联网按钮做的事情：
- en: '**Smart home control button**: This button facilitates control over various
    household appliances and systems through simple configured commands – a single
    or double press can control lights'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能家居控制按钮**：这个按钮可以通过简单的配置命令控制各种家用电器和系统——单次或双击可以控制灯光'
- en: '**Ordering button**: Especially useful in retail settings, this button facilitates
    quick orders or reorders of specific products from suppliers, enhancing business
    efficiency'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单按钮**：在零售环境中特别有用，这个按钮可以促进快速订购或重新订购特定产品，从而提高业务效率'
- en: '**Feedback button**: These buttons can be installed in corporate or service
    environments to accumulate immediate feedback from users or customers, helping
    to maintain a high standard of service'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈按钮**：这些按钮可以安装在企业或服务环境中，以收集用户或客户的即时反馈，有助于保持高标准的服务'
- en: '**Conference room booking button**: In office spaces, these buttons can aid
    in the smooth booking of conference rooms, preventing booking conflicts and promoting
    efficiency'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会议室预订按钮**：在办公空间中，这些按钮可以帮助顺利预订会议室，防止预订冲突并提高效率'
- en: '**Smart agriculture**: These buttons can streamline processes in agriculture,
    with functionalities such as immediate watering of farm sections or automated
    feed release for livestock'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能农业**：这些按钮可以简化农业流程，例如立即灌溉农田区域或自动释放牲畜饲料'
- en: In this chapter, we will use our IoT button to interact with our IoT alarm module.
    For this, we will build a simple button with the M5Stack ATOM Matrix and a more
    complex button with our Raspberry Pi Pico W.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的物联网按钮与物联网报警模块进行交互。为此，我们将使用M5Stack ATOM Matrix构建一个简单的按钮，以及使用我们的Raspberry
    Pi Pico W构建一个更复杂的按钮。
- en: Exploring various technologies in IoT button development
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索物联网按钮开发中的各种技术
- en: In the fast-growing field of IoT, the choice of technology can greatly affect
    the functionality and adaptability of the devices we create. In this chapter,
    we adopt this approach as we use two different yet effective platforms – the M5Stack
    ATOM Matrix and the Raspberry Pi Pico W – to construct IoT buttons with varying
    levels of complexity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网快速发展的领域中，技术的选择可以极大地影响我们创建的设备的功能性和适应性。在本章中，我们采用这种方法，因为我们使用了两个不同但有效的平台——M5Stack
    ATOM Matrix和Raspberry Pi Pico W——来构建不同复杂程度的物联网按钮。
- en: 'We start with the M5Stack ATOM Matrix to build our initial button. This microcontroller
    is notable for its compactness, featuring an integrated dot-matrix screen that
    functions as a touch button. Its straightforward design not only allows for easy
    assembly but also supports a simple button solution, ideal for our first IoT button
    (see *B* in *Figure 7**.2*):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从M5Stack ATOM Matrix开始构建我们的初始按钮。这款微控制器以其紧凑性而著称，它集成了点阵屏幕，该屏幕作为触摸按钮使用。其简单的设计不仅便于组装，还支持简单的按钮解决方案，非常适合我们的第一个物联网按钮（见*图7.2*中的*B*）：
- en: '![Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix](img/B21282_07_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – Raspberry Pi Pico W和M5Stack ATOM Matrix](img/B21282_07_02.jpg)'
- en: Figure 7.2 – Raspberry Pi Pico W and M5Stack ATOM Matrix
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – Raspberry Pi Pico W和M5Stack ATOM Matrix
- en: Building on what we learned from the ATOM Matrix project, we then move on to
    leverage the capabilities of the Raspberry Pi Pico W (see *A* in *Figure 7**.2*).
    We know this platform for its versatility and compatibility with various peripherals.
    This offers us more customization in button development. The Raspberry Pi Pico
    W enables us to create a button with a higher degree of functionality than the
    M5Stack ATOM Matrix.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在从ATOM Matrix项目中学到的知识的基础上，我们接下来将利用Raspberry Pi Pico W的能力（见*图7.2*中的*A*）。我们因它的多功能性和与各种外围设备的兼容性而了解这个平台。这为我们提供了更多按钮开发的定制化。Raspberry
    Pi Pico W使我们能够创建一个比M5Stack ATOM Matrix具有更高功能性的按钮。
- en: Working with two different technological bases not only broadens our understanding
    but also encourages a flexible approach to IoT project development. This progression
    from a simple to a more advanced button is designed to help us steadily build
    on our knowledge, equipping us with the insight to choose the right platform for
    future IoT projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与两种不同的技术基础一起工作不仅拓宽了我们的理解，而且鼓励我们对物联网项目开发采取灵活的方法。这种从简单到更高级按钮的进步旨在帮助我们稳步积累知识，为我们选择未来物联网项目的正确平台提供洞察力。
- en: Let’s get started.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating our IoT button using the M5Stack ATOM Matrix
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用M5Stack ATOM Matrix创建我们的物联网按钮
- en: In *Figure 7**.1*, we depict the ATOM Matrix on the right-hand side, receiving
    a `motion` input message and issuing a `buzzer` output message. These messages
    are associated with **passive infrared** (**PIR**) sensor detections and buzzer
    activation on the IoT alarm module, respectively. Utilizing its integrated dot-matrix
    screen, which also serves as a touch button, we will use the M5Stack ATOM Matrix
    to create our first IoT button.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.1*中，我们展示了右侧的ATOM Matrix，它接收一个`运动`输入消息并发出一个`蜂鸣器`输出消息。这些消息分别与物联网报警模块上的**被动红外**（**PIR**）传感器检测和蜂鸣器激活相关联。利用其集成的点阵屏幕（也用作触摸按钮），我们将使用M5Stack
    ATOM Matrix来创建我们的第一个物联网按钮。
- en: Before we initiate the setup and programming of the ATOM Matrix, let’s take
    a moment to familiarize ourselves with the range of products M5Stack offers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设置和编程ATOM Matrix之前，让我们花点时间熟悉M5Stack提供的产品系列。
- en: Exploring M5Stack devices
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索M5Stack设备
- en: M5Stack is known for its stackable development kits, suitable for hobbyists
    and professionals alike. Based on the ESP32 microcontroller, these kits offer
    functionality and scalability, crucial for IoT, AI, and robotics projects. M5Stack’s
    modules provide easy integration of various functionalities, coupled with a user-friendly
    development environment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: M5Stack以其可堆叠的开发套件而闻名，适合爱好者和专业人士。这些套件基于ESP32微控制器，提供了功能和可扩展性，这对于物联网、人工智能和机器人项目至关重要。M5Stack的模块提供了易于集成的各种功能，并配备了用户友好的开发环境。
- en: 'In *Figure 7**.3*, we see a photo of various M5Stack devices:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7**.3中，我们看到了各种M5Stack设备的照片：
- en: '![Figure 7.3 – M5Stack devices](img/B21282_07_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – M5Stack设备](img/B21282_07_03.jpg)'
- en: Figure 7.3 – M5Stack devices
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – M5Stack设备
- en: 'Let’s see what the devices do:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些设备的功能：
- en: '**M5Stack Basic** (*A*): The M5Stack Basic is an all-encompassing central controller
    for IoT applications, powered by the Espressif ESP32 chipset housing two Xtensa®
    32-bit LX6 microprocessors with a 240 MHz peak frequency. It provides a rich array
    of development interfaces, including **Analog-to-Digital Converter** (**ADC**),
    **Digital-to-Analog Converter** (**DAC**), and **Inter-Integrated Circuit** (**I2C**),
    alongside 15 Input/Output (IO) pins. It features a 2.0-inch HD **in-plane switching**
    (**IPS**) display panel, accompanied by a speaker and microSD card slot.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M5Stack Basic** (*A*): M5Stack Basic是一款适用于物联网应用的全面中央控制器，由Espressif ESP32芯片组供电，内置两个Xtensa®
    32位LX6微处理器，峰值频率为240 MHz。它提供了一系列丰富的开发接口，包括**模拟数字转换器** (**ADC**)、**数字模拟转换器** (**DAC**)和**集成电路间**
    (**I2C**)，以及15个输入/输出（IO）引脚。它配备了一块2.0英寸的HD **平面切换** (**IPS**)显示屏，并配有扬声器和microSD卡槽。'
- en: '**M5StickC PLUS** (*B*): The M5StickC PLUS is powered by ESP32-PICO-D4 with
    Wi-Fi. It offers a large 1.14-inch screen with 135 x 240 px resolution. The board
    houses infrared, **Real-Time Clock** (**RTC**), microphone, and LED, and features
    a robust 120 mAh battery. It supports HAT and Unit product families.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M5StickC PLUS** (*B*): M5StickC PLUS由ESP32-PICO-D4芯片供电，内置Wi-Fi功能。它配备了一块大型的1.14英寸屏幕，分辨率为135
    x 240 px。该板集成了红外线、**实时时钟** (**RTC**)、麦克风和LED灯，并配备了强大的120 mAh电池。它支持HAT和Unit产品系列。'
- en: '**M5Stack Unit LoRaWAN915** (*C*): The M5Stack Unit LoRaWAN915 is a **LoRaWAN**
    (short for **Long Range Wide Area Network**) module designed for 915 MHz frequency
    communications, leveraging the ASR6501 chipset to enable long-distance connections
    while maintaining low power usage and high sensitivity.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M5Stack Unit LoRaWAN915** (*C*): M5Stack Unit LoRaWAN915是一款专为915 MHz频率通信设计的**LoRaWAN**（简称**长距离广域网络**）模块，利用ASR6501芯片组实现长距离连接，同时保持低功耗和高灵敏度。'
- en: '**ENV III HAT** (*D*): The ENV III HAT is a versatile environmental sensor
    compatible with the M5StickC series, housing the SHT30 and QMP6988 to measure
    temperature, humidity, and atmospheric pressure.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENV III HAT** (*D*): ENV III HAT是一款多功能的环保传感器，兼容M5StickC系列，内置SHT30和QMP6988以测量温度、湿度和大气压力。'
- en: '**ATOM Matrix** (*E*): The ATOM Matrix is M5Stack’s most compact development
    board at 24*24 mm, offering an extensive range of GPIO pins for compact embedded
    device projects. Powered by the ESP32-PICO-D4 chip, it integrates Wi-Fi technologies
    and 4 MB of **SPI** ( short for **Serial Peripheral Interface**) flash memory.
    The board features a 5*5 RGB LED matrix, an infrared LED, a programmable button
    for added input support, and a built-in **Inertial Measurement Unit** (**IMU**)
    sensor (MPU6886).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ATOM Matrix** (*E*): ATOM Matrix是M5Stack最紧凑的开发板，尺寸为24*24 mm，为紧凑型嵌入式设备项目提供了广泛的GPIO引脚。由ESP32-PICO-D4芯片供电，它集成了Wi-Fi技术，并配备了4
    MB的**串行外围接口** (**SPI**)闪存。该板具有一个5*5 RGB LED矩阵、一个红外LED、一个可编程按钮以提供额外的输入支持，以及内置的**惯性测量单元**
    (**IMU**)传感器（MPU6886）。'
- en: For our first IoT button, we will be using the ATOM Matrix. While we could have
    opted for the Basic, M5StickC PLUS, or the newer ATOMS3 (not shown), as all these
    devices provide a pushbutton and a screen for feedback, we chose the ATOM Matrix
    because it offers a unique blend of compactness and simplicity, making it ideal
    for this introductory project. Furthermore, its integrated dot-matrix screen,
    doubling as a touch button, presents a more intuitive and interactive experience
    for users.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个物联网按钮，我们将使用ATOM Matrix。虽然我们本可以选择Basic、M5StickC PLUS或更新的ATOMS3（未展示），因为这些设备都提供了按钮和屏幕以供反馈，但我们选择了ATOM
    Matrix，因为它提供了独特的小巧和简洁结合，非常适合这个入门级项目。此外，其集成的点阵屏幕，作为触摸按钮的双重功能，为用户提供了更直观和互动的体验。
- en: M5Stack provides intuitive tools to set up and program our ATOM Matrix. We’ll
    begin with the burner tool to configure our Matrix.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: M5Stack提供了直观的工具来设置和编程我们的ATOM Matrix。我们将从烧录工具开始配置我们的Matrix。
- en: Flashing the firmware to our ATOM Matrix
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将固件烧录到我们的ATOM Matrix
- en: The M5Burner allows us to flash firmware onto our M5Stack devices. This tool
    simplifies the process the process for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: M5Burner允许我们将固件烧录到我们的M5Stack设备上。这个工具简化了我们的烧录过程。
- en: 'To use the tool, we do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此工具，我们执行以下操作：
- en: 'We download the installation file from the M5Stack website using this URL:
    [https://docs.m5stack.com/en/download](https://docs.m5stack.com/en/download).'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用此URL从M5Stack网站下载安装文件：[https://docs.m5stack.com/en/download](https://docs.m5stack.com/en/download)。
- en: 'For our project, we’ll download and install the Windows version of the burner.
    Once installed, we’ll run the program and click on the **ATOM** tab on the left,
    and we should see the following screen:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将下载并安装烧录工具的Windows版本。安装完成后，我们将运行程序并点击左侧的**ATOM**标签页，我们应该看到以下屏幕：
- en: '![Figure 7.4 – M5Burner ATOM screen](img/B21282_07_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – M5Burner ATOM屏幕](img/B21282_07_04.jpg)'
- en: Figure 7.4 – M5Burner ATOM screen
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – M5Burner ATOM屏幕
- en: The `UIFlow_MATRIX` firmware is designed for the ATOM Matrix, enabling drag-and-drop
    graphical programming that translates to MicroPython. It features built-in libraries
    and offers **over-the-air** (**OTA**) updates for wireless programming. We click
    on the **Download** button to download the firmware onto our local computer.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UIFlow_MATRIX`固件是为ATOM Matrix设计的，它支持拖放图形编程，这可以转换为MicroPython。它具有内置的库，并提供无线编程的**空中传输**（**OTA**）更新。我们点击**下载**按钮将固件下载到我们的本地计算机。'
- en: Once the firmware has finished downloading, we click on the **Burn** button
    (formally the **Download** button) to start flashing the **UIFlow_MATRIX** firmware
    onto our ATOM Matrix. We should see a dialog requesting our Wi-Fi information.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件下载完成后，我们点击**烧录**按钮（以前称为**下载**按钮）开始将**UIFlow_MATRIX**固件烧录到我们的ATOM Matrix。我们应该看到一个请求我们Wi-Fi信息的对话框。
- en: By clicking the top-right blue button, we can auto-fill our computer’s Wi-Fi
    details or enter them manually. Once entered, we click **Next** to continue. We
    should see the **Burn** screen next.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击右上角的蓝色按钮，我们可以自动填写我们电脑的Wi-Fi详情或手动输入。输入后，我们点击**下一步**继续。接下来应该看到**烧录**屏幕。
- en: We choose the port where the ATOM Matrix is connected and click the **Start**
    button to initiate the firmware burn. A progress screen will then display the
    ongoing burn status.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择ATOM Matrix连接的端口，并点击**开始**按钮以启动固件烧录。然后，一个进度屏幕将显示烧录的当前状态。
- en: 'Upon successful completion, we click on the green **Burn successfully, click
    here to** **return** button:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功完成后，我们点击绿色的**烧录成功，点击此处** **返回**按钮：
- en: '![Figure 7.5 – Burn successful](img/B21282_07_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 烧录成功](img/B21282_07_05.jpg)'
- en: Figure 7.5 – Burn successful
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 烧录成功
- en: We now have successfully installed the **UIFlow_MATRIX** firmware onto our ATOM
    Matrix. We should observe that the dot-matrix screen on our device blinks green.
    This firmware comes with dedicated libraries that we will use to create our first
    IoT button.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功将**UIFlow_MATRIX**固件安装到我们的ATOM Matrix上。我们应该注意到，我们设备上的点阵屏幕会闪烁绿色。这个固件包含专用的库，我们将使用这些库来创建我们的第一个物联网按钮。
- en: With the firmware installed, it is now time to configure our ATOM Matrix so
    that we can start programming it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 固件安装后，现在是时候配置我们的ATOM Matrix，以便我们可以开始编程它。
- en: Configuring the ATOM Matrix for programming
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置ATOM Matrix以进行编程
- en: To program our ATOM Matrix, we’ll use M5Stack’s UIFlow, specifically its Python
    environment. UIFlow serves as an online IDE, connecting to our devices through
    an API key. For successful development, it’s essential to retrieve this key and
    properly configure our ATOM Matrix.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程我们的ATOM Matrix，我们将使用M5Stack的UIFlow，特别是它的Python环境。UIFlow作为一个在线IDE，通过API密钥连接到我们的设备。为了成功开发，必须检索此密钥并正确配置我们的ATOM
    Matrix。
- en: 'To configure our ATOM Matrix, we do the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的ATOM Matrix，我们执行以下操作：
- en: In the **M5Burner** window, we click on the **ATOM** tab.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**M5Burner**窗口中，我们点击**ATOM**标签页。
- en: 'We click on the **Configure** button in the **UIFlow_Matrix** section:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击**UIFlow_Matrix**部分中的**配置**按钮：
- en: '![Figure 7.6 – UIFlow Matrix Configure button](img/B21282_07_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – UIFlow Matrix配置按钮](img/B21282_07_06.jpg)'
- en: Figure 7.6 – UIFlow Matrix Configure button
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – UIFlow Matrix配置按钮
- en: This should open the **UIFlow Configuration** dialog, and the port to which
    our ATOM Matrix is connected should be displayed. We click on **Load** to proceed
    to the next screen.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该打开 **UIFlow 配置** 对话框，并且我们的 ATOM 矩阵连接的端口应该显示出来。我们点击 **加载** 以继续到下一个屏幕。
- en: 'This will bring us to the next screen, **UIFlow Configuration**:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到下一个屏幕，**UIFlow 配置**：
- en: '![Figure 7.7 – Main UIFlow configuration screen](img/B21282_07_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 主要 UIFlow 配置屏幕](img/B21282_07_07.jpg)'
- en: Figure 7.7 – Main UIFlow configuration screen
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 主要 UIFlow 配置屏幕
- en: Using *Figure 7**.7* as a reference, we’ll focus on the parameters highlighted
    by the boxes. Starting with **COM**, it should be set to the port where our ATOM
    Matrix is connected.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **图 7**.7 作为参考，我们将关注由方框突出显示的参数。从 **COM** 开始，它应该设置为我们的 ATOM 矩阵连接的端口。
- en: The **APIKEY** parameter serves as the connection bridge between the UIFlow
    IDE and our device. We take note of this key and keep it easily accessible.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**APIKEY** 参数作为 UIFlow IDE 和我们的设备之间的连接桥梁。我们注意这个密钥并保持它易于访问。'
- en: '**Start Mode** determines the device’s startup behavior. We configure it to
    **Internet Mode** for connectivity with the UIFlow IDE. After programming our
    ATOM Matrix, this mode will switch to **App Mode** automatically. To re-connect
    with the IDE after that, we’ll need to revisit **M5Burner** and reset this to
    **Internet Mode**.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动模式** 决定了设备的启动行为。我们将其配置为 **互联网模式** 以与 UIFlow IDE 连接。在编程我们的 ATOM 矩阵后，此模式将自动切换到
    **应用模式**。在此之后，要重新连接到 IDE，我们需要重新访问 **M5Burner** 并将其重置为 **互联网模式**。'
- en: We set the **WIFI SSID** and **WIFI Password** parameters if they are not already
    set to the correct values.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置正确的值，我们设置 **WIFI SSID** 和 **WIFI 密码** 参数。
- en: We click on the blue **Save** button to save the parameters to our ATOM Matrix.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击蓝色 **保存** 按钮将参数保存到我们的 ATOM 矩阵中。
- en: With our ATOM Matrix configured, we’re set to start programming and turn the
    device into our first functional IoT button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好我们的 ATOM 矩阵后，我们就可以开始编程并将设备变成我们的第一个功能性的 IoT 按钮。
- en: Turning our ATOM Matrix into an IoT button
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的 ATOM 矩阵转换为 IoT 按钮
- en: We will use M5Stack’s UIFlow online IDE for development as it provides a straightforward
    coding platform for M5Stack devices. We will make use of the API key that we recorded
    from the configuration of our device to connect to the IDE.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 M5Stack 的 UIFlow 在线 IDE 进行开发，因为它为 M5Stack 设备提供了一个直接的编码平台。我们将使用从设备配置中记录的
    API 密钥来连接到 IDE。
- en: 'To add MicroPython code to our ATOM Matrix, we do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 MicroPython 代码添加到我们的 ATOM 矩阵中，我们执行以下操作：
- en: 'In an internet-enabled browser, we navigate to the following URL: [https://flow.m5stack.com](https://flow.m5stack.com).'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个支持互联网的浏览器中，我们导航到以下 URL：[https://flow.m5stack.com](https://flow.m5stack.com)。
- en: We will be presented with a screen to choose either `UIFlow1.0` or `UIFlow2.0`.
    Since we are using an ATOM Matrix, we choose UIFlow1.0 and click on **Confirm**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到一个屏幕，可以选择 `UIFlow1.0` 或 `UIFlow2.0`。由于我们使用的是 ATOM 矩阵，我们选择 UIFlow1.0 并点击
    **确认**。
- en: 'In the IDE, we click on the **</> Python** tab so that we can program our ATOM
    Matrix in MicroPython:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 中，我们点击 **</> Python** 选项卡，这样我们就可以用 MicroPython 编程我们的 ATOM 矩阵：
- en: '![Figure 7.8 – UIFlow IDE](img/B21282_07_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – UIFlow IDE](img/B21282_07_08.jpg)'
- en: Figure 7.8 – UIFlow IDE
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – UIFlow IDE
- en: 'To link our ATOM Matrix to UIFlow, we click the **Api key** label at the bottom
    left of the screen to open the **Setting** screen:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的 ATOM 矩阵链接到 UIFlow，我们点击屏幕左下角的 **Api key** 标签以打开 **设置** 屏幕：
- en: '![Figure 7.9 – Setting screen](img/B21282_07_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 设置屏幕](img/B21282_07_09.jpg)'
- en: Figure 7.9 – Setting screen
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 设置屏幕
- en: We enter the API key for our device and click **OK** to connect our ATOM Matrix
    to the UIFlow IDE.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入设备的 API 密钥并点击 **确定** 以将我们的 ATOM 矩阵连接到 UIFlow IDE。
- en: 'In the code editor, we overwrite the existing code with the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中，我们用以下代码覆盖了现有的代码：
- en: '[PRE0]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before downloading the code to our ATOM Matrix, let’s break it down. We start
    with our imports:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在将代码下载到我们的 ATOM 矩阵之前，让我们将其分解。我们首先从导入开始：
- en: '`from m5stack import *`: Imports all functions and classes from the M5Stack
    library.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from m5stack import *`：从 M5Stack 库导入所有函数和类。'
- en: '`from m5ui import *`: Imports all UI-related functions and classes for M5Stack.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from m5ui import *`：导入所有与 UI 相关的函数和类，用于 M5Stack。'
- en: '`from uiflow import *`: Imports all UIFlow-specific functions and classes.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from uiflow import *`：导入所有 UIFlow 特定的函数和类。'
- en: '`from m5mqtt import M5mqtt`: Imports the `M5mqtt` class, which allows for MQTT
    communication.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from m5mqtt import M5mqtt`：导入 `M5mqtt` 类，允许进行 MQTT 通信。'
- en: '`import time`: Imports the standard Python `time` library.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import time`：导入标准的Python `time`库。'
- en: 'We then set our screen to black with the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令将屏幕设置为黑色：
- en: '[PRE1]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We then define a function to scan for a press of button `A` (the screen) and
    call it `buttonA_pressFor()`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个函数来扫描按钮`A`（屏幕）的按下，并称它为`buttonA_pressFor()`。
- en: In this method, we publish a message with the `IoTAlarm` topic and `buzzer`
    payload when button `A` is pressed for 1 second.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此方法中，当按钮`A`按下1秒钟时，我们使用`IoTAlarm`主题和`buzzer`有效负载发布一条消息。
- en: 'We then create an instance of the `M5mqtt` class we call `m5mqtt` with the
    given parameters:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用给定的参数创建了一个名为`m5mqtt`的`M5mqtt`类的实例：
- en: The device name is set to `IoTMatrix`.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备名称设置为`IoTMatrix`。
- en: The MQTT broker address is set to `broker.mqtthq.com`.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MQTT代理地址设置为`broker.mqtthq.com`。
- en: The MQTT port is set to `1883`.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MQTT端口设置为`1883`。
- en: We provide empty strings for username and password as none are required.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为用户名和密码提供空字符串，因为不需要它们。
- en: We set the MQTT keep-alive time set to `300` seconds.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将MQTT保持活动时间设置为`300`秒。
- en: 'Our code then subscribes to the `IoTAlarm` topic and sets the callback function
    with the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码随后订阅了`IoTAlarm`主题，并使用以下代码设置了回调函数：
- en: '[PRE2]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then set the RGB LED matrix color to cyan as an initial state:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将RGB LED矩阵颜色设置为青色作为初始状态：
- en: '[PRE3]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The final line starts the MQTT client, enabling it to send and receive messages:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一行启动MQTT客户端，使其能够发送和接收消息：
- en: '[PRE4]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the code in place, we download it to our ATOM Matrix by clicking on the
    blue **Download** button located on the lower right-hand side of the screen.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码放置到位后，我们通过点击屏幕右下角的蓝色**下载**按钮将其下载到ATOM Matrix。
- en: With the code loaded onto our ATOM Matrix, we are now ready to test it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ATOM Matrix上加载代码后，我们现在可以开始测试它。
- en: Testing our IoT button
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的物联网按钮
- en: For our initial tests, we’ll use the MQTTHQ web client, as previously covered
    in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), before testing our IoT button
    on our IoT alarm module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的初始测试中，我们将使用之前在[*第6章*](B21282_06.xhtml#_idTextAnchor091)中介绍的MQTTHQ网络客户端，在测试我们的物联网按钮在物联网警报模块上之前。
- en: 'To do this, we do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'In a browser, we navigate to the following URL: [https://mqtthq.com/client](https://mqtthq.com/client).'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，我们导航到以下URL：[https://mqtthq.com/client](https://mqtthq.com/client)。
- en: In the `IoTAlarm`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IoTAlarm`。
- en: In the `motion` message and press the orange **Publish** button.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`运动`消息中，点击橙色**发布**按钮。
- en: On our ATOM Matrix, we should observe that our screen turns red for 5 seconds
    before returning to its initial color.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的ATOM Matrix上，我们应该观察到我们的屏幕在5秒钟后变回初始颜色。
- en: In the `IoTAlarm` topic.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IoTAlarm`主题中。
- en: On our ATOM Matrix, we press and hold down the main button (the screen) for
    1 second before releasing.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的ATOM Matrix上，我们按住并保持主按钮（屏幕）1秒钟，然后释放。
- en: In the `buzzer` message.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`buzzer`消息中。
- en: With the successful completion of our MQTTHQ tests, we are now ready to test
    our IoT button on our IoT alarm module. Using a micro-USB cable, we plug the IoT
    alarm module we created in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) into
    a USB power brick.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MQTTHQ测试成功完成后，我们现在可以开始测试我们在物联网警报模块上的物联网按钮。使用微型USB线，我们将我们在[*第6章*](B21282_06.xhtml#_idTextAnchor091)中创建的物联网警报模块插入到USB电源砖中。
- en: After initializing, we wave our hand in front of the PIR sensor and observe
    the screen on our ATOM Matrix turn red for 5 seconds.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化后，我们在PIR传感器前挥动手，观察ATOM Matrix上的屏幕在5秒钟内变为红色。
- en: Pressing and holding the primary button on our ATOM Matrix for a second and
    then releasing should trigger the buzzer on our IoT alarm module.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住并保持ATOM Matrix上的主按钮（屏幕）一秒钟，然后释放，应该会在我们的物联网警报模块上触发蜂鸣器。
- en: Congratulations are in order as we have just created our first IoT button using
    the M5Stack ATOM Matrix! As the connection between our IoT alarm module and our
    IoT button is through the internet, we may place either device anywhere in the
    world and have them communicate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺我们刚刚使用M5Stack ATOM Matrix创建了我们的第一个物联网按钮！由于我们的物联网警报模块和物联网按钮之间的连接是通过互联网进行的，因此我们可以将这两个设备放置在世界上的任何地方，并使它们进行通信。
- en: 'Even though our ATOM Matrix comes in a convenient form factor, as do all M5Stack
    controllers, we do have a custom stand that we may mount it with (*Figure 7**.10*).
    The 3D printer files are in the `Build Files` folder of this chapter’s GitHub
    repository:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的ATOM Matrix具有方便的形状，就像所有M5Stack控制器一样，但我们确实有一个定制的支架，我们可以将其安装在上面（*图7**.10*）。3D打印机文件位于本章GitHub存储库的`Build
    Files`文件夹中：
- en: '![Figure 7.10 – M5Stack ATOM Matrix stand](img/B21282_07_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – M5Stack ATOM Matrix支架](img/B21282_07_10.jpg)'
- en: Figure 7.10 – M5Stack ATOM Matrix stand
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – M5Stack ATOM Matrix底座
- en: To use the stand, we position the ATOM Matrix (see *B* in *Figure 7**.10*) into
    the stand’s cup section (see *A* in *Figure 7**.10*) with the USB-C port facing
    the stand’s base. The stand features a rear hole, accommodating an M2 5 mm screw
    (not shown) to anchor the ATOM Matrix, which has a 2 mm mounting hole at the back.
    The stand is designed to accommodate a USB-C cable or adapter at a 90-degree angle.
    Additionally, it can be mounted over an opening to conceal the USB-C cable, making
    it suitable for ceilings or shelves.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用底座，我们将ATOM Matrix（见**图7.10**中的**B**）放入底座的杯形部分（见**图7.10**中的**A**），USB-C端口朝向底座的底部。底座有一个后孔，可以容纳一个M2
    5毫米螺丝（未显示）以固定ATOM Matrix，它后面有一个2毫米的安装孔。底座设计用来容纳一个90度角的USB-C电缆或适配器。此外，它还可以覆盖一个开口以隐藏USB-C电缆，使其适用于天花板或架子。
- en: With our first IoT button completed, we are now ready to build the more complex
    second version of our button.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个物联网按钮完成之后，我们现在准备构建按钮的更复杂第二个版本。
- en: Improving on our IoT button with the Raspberry Pi Pico W
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico W改进我们的物联网按钮
- en: As our IoT alarm system becomes more complex, the limitations of the public
    MQTTHQ server become increasingly evident. Given that it’s a public platform,
    its reliability can be inconsistent. Transitioning to a reliable, private server
    would significantly enhance our development process and system dependability.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的物联网警报系统变得越来越复杂，公共MQTTHQ服务器的局限性变得越来越明显。鉴于它是一个公共平台，其可靠性可能不一致。转向一个可靠、私有的服务器将显著提高我们的开发过程和系统可靠性。
- en: In this section, we will build an improved IoT button using a Raspberry Pi Pico
    W, a buzzer, an arcade-style pushbutton, a switch, an LED, and an OLED screen
    (*Figure 7**.11*). We’re enhancing our project’s reliability and efficiency by
    moving to a private MQTT server using CloudAMQP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Raspberry Pi Pico W、蜂鸣器、街机风格的按钮、开关、LED和OLED屏幕（**图7.11**）来构建一个改进的物联网按钮。通过迁移到使用CloudAMQP的私有MQTT服务器，我们提高了项目的可靠性和效率。
- en: '![Figure 7.11 – Enhanced IoT button](img/B21282_07_11.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 改进的物联网按钮](img/B21282_07_11.jpg)'
- en: Figure 7.11 – Enhanced IoT button
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 改进的物联网按钮
- en: While using a private server is optional, it stands as a significant upgrade
    over continuing with the public MQTTHQ server. The code in this section will still
    work with the public MQTTHQ server (with configuration changes); however, by opting
    for CloudAMQP, we will improve the reliability and security of our IoT alarm system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用私有服务器是可选的，但它相对于继续使用公共MQTTHQ服务器来说是一个显著的升级。本节中的代码仍然可以使用公共MQTTHQ服务器（需要配置更改）；然而，通过选择CloudAMQP，我们将提高我们物联网警报系统的可靠性和安全性。
- en: We will start by setting up an MQTT instance with CloudAMQP.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用CloudAMQP设置一个MQTT实例。
- en: Setting up a CloudAMQP instance
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置CloudAMQP实例
- en: CloudAMQP is a managed MQTT service optimized for IoT devices and applications.
    It ensures reliable, real-time messaging with features such as WebSockets and
    retained messages. With its intuitive interface, CloudAMQP caters to both hobbyists
    and enterprises and makes an excellent choice for our IoT alarm system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CloudAMQP是一个针对物联网设备和应用程序优化的托管MQTT服务。它确保了具有WebSocket和保留消息等功能的可靠、实时消息传递。凭借其直观的界面，CloudAMQP既适合爱好者也适合企业，是我们物联网警报系统的绝佳选择。
- en: We may view the pricing of the services here – [https://www.cloudamqp.com/plans.xhtml](https://www.cloudamqp.com/plans.xhtml)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此查看服务的定价 – [https://www.cloudamqp.com/plans.xhtml](https://www.cloudamqp.com/plans.xhtml)
- en: 'For our purposes, the free **Little Lemur** service will suffice. Upon setting
    up an account, we create an instance to use with our project. To do so, we do
    the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的需求，免费的**小狐猴**服务就足够了。在设置账户后，我们创建一个实例用于我们的项目。为此，我们执行以下操作：
- en: Logging in to our account will bring up the **Instances** page. To create a
    new instance, we click on the green **Create New** **Instance** button.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录我们的账户将显示**实例**页面。要创建一个新的实例，我们点击绿色的**创建新实例**按钮。
- en: This will take us to the `IoTProgrammingProjects`, set our plan to `Little Lemur`,
    and leave the **Tags** field blank. We click on the green **Select Region** button
    to go to the next screen.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到`IoTProgrammingProjects`，将我们的计划设置为`Little Lemur`，并留空**标签**字段。我们点击绿色的**选择区域**按钮进入下一屏幕。
- en: This takes us to the `CA-Central Canada-1(Canada)` under **AWS**. We click on
    the green **Review** button to go to the next screen.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到**AWS**下的`CA-Central Canada-1(Canada)`。我们点击绿色的**审查**按钮进入下一屏幕。
- en: In the **Confirm new instance** screen, we review our instance settings.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**确认新实例**界面，我们审查我们的实例设置。
- en: To create our instance, `IoTProgrammingProjects`, we click on the green **Create**
    **instance** button.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的实例`IoTProgrammingProjects`，我们点击绿色的**创建** **实例**按钮。
- en: To get more details on our instances, we click on the link in the `IoTAlarmSystem`
    link.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取更多关于我们实例的详细信息，我们点击`IoTAlarmSystem`链接。
- en: 'Clicking the link provides our instance details, which we’ll use to connect
    our applications to the MQTT server:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击链接提供了我们的实例详情，我们将使用这些详情将我们的应用程序连接到MQTT服务器：
- en: '![Figure 7.12 – MQTT connection details](img/B21282_07_12.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – MQTT连接详情](img/B21282_07_12.jpg)'
- en: Figure 7.12 – MQTT connection details
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – MQTT连接详情
- en: Having created our instance and obtained the details, we can now update the
    alarm module code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) to integrate
    with the new MQTT server and enhance its functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的实例并获取详细信息后，我们现在可以更新警报模块代码，从[*第6章*](B21282_06.xhtml#_idTextAnchor091)更新到与新的MQTT服务器集成并增强其功能。
- en: Modifying our alarm module code
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改我们的警报模块代码
- en: We will modify the code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091)
    for our alarm module so that it will work with our more advanced second IoT button.
    Our revised code shifts from a public MQTTHQ server to the more dependable CloudAMQP
    private server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改[*第6章*](B21282_06.xhtml#_idTextAnchor091)中的代码，以便我们的警报模块与更先进的第二个物联网按钮一起工作。我们的修订代码从公共MQTTHQ服务器转移到更可靠的CloudAMQP私有服务器。
- en: To support this, our new code adds `USERNAME`, `MQTT_PASSWORD`, and `DEVICE_ID`
    authentication parameters to enhance security. Another significant update is the
    `ARMED` mode, which lets us arm or disarm the system via MQTT. The modified `motion_handler()`
    function, when detecting motion, considers the `ARMED` status, sounding the buzzer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们的新代码添加了`USERNAME`、`MQTT_PASSWORD`和`DEVICE_ID`认证参数，以增强安全性。另一个重大更新是`ARMED`模式，它允许我们通过MQTT激活或解除系统。当检测到运动时，修改后的`motion_handler()`函数会考虑`ARMED`状态，发出蜂鸣声。
- en: Finally, our revised code alters the LED feedback system. Beyond showing Wi-Fi
    and MQTT connection statuses, the LED also indicates if the alarm is armed by
    blinking very slowly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的修订代码改变了LED反馈系统。除了显示Wi-Fi和MQTT连接状态外，LED还会通过非常缓慢的闪烁来指示警报是否被激活。
- en: The new version of our IoT alarm module code may be found under the `CloudAMQP`
    folder of this chapter’s GitHub repository. To install the code onto the IoT alarm
    module, we follow the steps outlined in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们物联网警报模块代码的新版本可以在本章GitHub仓库的`CloudAMQP`文件夹中找到。要将代码安装到物联网警报模块，我们遵循[*第6章*](B21282_06.xhtml#_idTextAnchor091)中概述的步骤。
- en: Building our Raspberry Pi Pico W IoT button
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的Raspberry Pi Pico W物联网按钮
- en: The second IoT button features significant advancements in both the hardware
    and software as we make use of the Raspberry Pi Pico W. The Raspberry Pi Pico
    W and the M5Stack ATOM Matrix ESP32 both stand out as impressive microcontrollers.
    The Pico W is notable for its dual-core ARM Cortex-M0+ processor and Wi-Fi capabilities,
    whereas the ATOM Matrix brings both Wi-Fi and Bluetooth to the table with its
    ESP32 chip. However, considering our second IoT button project values computational
    strength and Wi-Fi above all, we will go with the Raspberry Pi Pico W.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个物联网按钮在硬件和软件方面都有显著的进步，因为我们使用了Raspberry Pi Pico W。Raspberry Pi Pico W和M5Stack
    ATOM Matrix ESP32都作为令人印象深刻的微控制器脱颖而出。Pico W因其双核ARM Cortex-M0+处理器和Wi-Fi功能而引人注目，而ATOM
    Matrix则通过其ESP32芯片带来了Wi-Fi和蓝牙。然而，考虑到我们的第二个物联网按钮项目更重视计算能力和Wi-Fi，我们将选择Raspberry Pi
    Pico W。
- en: The inclusion of an OLED screen provides us with the status of the alarm, as
    well as acting as a monitor for our MQTT messages. Software-wise, the shift from
    a public MQTTHQ server to CloudAMQP’s private server improves reliability and
    security. This move reduces risks linked to public servers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加OLED屏幕为我们提供了警报的状态，同时也充当了我们的MQTT消息的监控器。从公共MQTTHQ服务器切换到CloudAMQP的私有服务器在软件上提高了可靠性和安全性。这一举措降低了与公共服务器相关的风险。
- en: Looking at the components for our Pico W IoT button
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看我们的Pico W物联网按钮的组件
- en: For the second version of our IoT button, we will be using an arcade-style button
    to send a message to arm the alarm module. An OLED screen will display MQTT messages
    sent back from the IoT alarm module. A `buzzer` message sent from the IoT alarm
    module will start a melody on the active buzzer that makes up the second version
    of the IoT button assembly. To disarm the IoT alarm module, we simply toggle a
    switch from its current position.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们物联网按钮的第二版，我们将使用街机风格的按钮来发送消息以启动警报模块。OLED 屏幕将显示从物联网警报模块发送回来的 MQTT 消息。从物联网警报模块发送的
    `buzzer` 消息将在构成物联网按钮第二版组装的活性蜂鸣器上启动旋律。要解除警报模块的警报，我们只需将开关从当前位置切换即可。
- en: 'In *Figure 7**.13*, we see the components that make up our Raspberry Pi Pico
    W IoT button:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7*.13 中，我们看到组成我们的 Raspberry Pi Pico W 物联网按钮的组件：
- en: '![Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander](img/B21282_07_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 物联网按钮 V2 电路连接到 Pico GPIO 扩展器](img/B21282_07_13.jpg)'
- en: Figure 7.13 – IoT button V2 circuit arranged on a Pico GPIO expander
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 物联网按钮 V2 电路连接到 Pico GPIO 扩展器
- en: 'The components are the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是组件：
- en: '*A*: Single color LED with 220 Ohm resistor'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：220 欧姆电阻的单色 LED'
- en: '*B*: SM-127 active buzzer'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*：SM-127 活性蜂鸣器'
- en: '*C*: 0.96-inch OLED screen'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*：0.96 英寸 OLED 屏幕'
- en: '*D*: 24 mm arcade button'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*：24 毫米街机按钮'
- en: '*E*: GPIO expander board for the Raspberry Pi Pico (optional)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*：Raspberry Pi Pico 的 GPIO 扩展板（可选）'
- en: '*F*: Raspberry Pi Pico WH for development usage'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*：用于开发用途的 Raspberry Pi Pico WH'
- en: '*G*: SPST switch'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*：单刀单掷开关'
- en: For development, we will use a Raspberry Pi Pico WH but switch to the non-header
    version for installation into the custom case.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发，我们将使用 Raspberry Pi Pico WH，但在安装到定制外壳时将切换到无头版本。
- en: Using a GPIO expander
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPIO 扩展器
- en: The use of a GPIO expander (see *E* in *Figure 7**.13*) is optional. To use
    the expander, female jumper connections are required. Using a GPIO expander offers
    the benefit of easily transitioning components to installations with the Pico
    WH in future projects, thanks to its female jumper connections.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 扩展器的使用（见 *图 7*.13 中的 *E*）是可选的。要使用扩展器，需要女性跳线连接。使用 GPIO 扩展器的好处是，由于其女性跳线连接，可以轻松地将组件过渡到未来项目中使用
    Pico WH 的安装。
- en: We will start our construction of the Raspberry Pi Pico W IoT button by examining
    the wiring diagram on a standard breadboard.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查标准面包板上的接线图来开始构建 Raspberry Pi Pico W 物联网按钮。
- en: Wiring up our Raspberry Pi Pico W IoT button
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接我们的 Raspberry Pi Pico W 物联网按钮
- en: 'In *Figure 7**.14*, we can see a wiring diagram for the Raspberry Pi Pico W
    IoT button. We will use a standard micro-USB cable connected to the USB port of
    the Pico WH to provide power. The 3.3 V pin from the Pico W is used to provide
    power to the rails of the breadboard:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7*.14 中，我们可以看到 Raspberry Pi Pico W 物联网按钮的接线图。我们将使用标准微型 USB 线连接到 Pico WH
    的 USB 端口以供电。Pico W 的 3.3 V 引脚用于为面包板的轨道供电：
- en: '![Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram](img/B21282_07_14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – Raspberry Pi Pico W 物联网按钮接线图](img/B21282_07_14.jpg)'
- en: Figure 7.14 – Raspberry Pi Pico W IoT button wiring diagram
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – Raspberry Pi Pico W 物联网按钮接线图
- en: Now that our wiring is set, we’ll move on to the coding phase. We will start
    by loading the necessary packages we require for our code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好接线，我们将进入编码阶段。我们将首先加载我们代码所需的必要软件包。
- en: Setting up the required packages for our program
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置程序所需的软件包
- en: 'The packages required to run our code for our Raspberry Pi Pico W IoT button
    are the `micropython-umqtt.simple` package and the `micropython-ssd1306` package.
    To load the packages onto our Raspberry Pi Pico W, we do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们 Raspberry Pi Pico W 物联网按钮代码所需的软件包是 `micropython-umqtt.simple` 软件包和 `micropython-ssd1306`
    软件包。要将软件包加载到我们的 Raspberry Pi Pico W 上，我们执行以下操作：
- en: Using the Thonny IDE, we click on **Tools** | **Manage packages**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Thonny IDE，我们点击 **工具** | **管理软件包**。
- en: In the search box, we type in the name of the package we would like to search
    for and then click on the **Search on** **PyPI** button.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，我们输入我们想要搜索的软件包名称，然后点击 **在 PyPI 上搜索** 按钮。
- en: We then proceed to install the package by clicking on the **Install** button.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过点击 **安装** 按钮来安装软件包。
- en: What to do if there are errors when loading packages?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载软件包时出现错误，该怎么办？
- en: In situations where there is an error when loading a package, we may simply
    copy the `library` folder from our GitHub repository to our Pico W. The folder
    may be found under `Second IoT Button/library-files-from-pico-w` from this chapter’s
    repository. See *Figure 7**.15* for clarification on the file structure of the
    Raspberry Pi Pico W.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载包时出现错误的情况下，我们可能只需将GitHub仓库中的`library`文件夹复制到我们的Pico W中。该文件夹可以在此章节的仓库中找到，位于`Second
    IoT Button/library-files-from-pico-w`。参见*图7.15*以了解Raspberry Pi Pico W的文件结构。
- en: 'Before proceeding to write our code, we should verify that the file structure
    on our Pico W looks like the following:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续编写代码之前，我们应该验证我们的Pico W上的文件结构如下：
- en: '![Figure 7.15 – Raspberry Pi Pico W library structure](img/B21282_07_15.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – Raspberry Pi Pico W库结构](img/B21282_07_15.jpg)'
- en: Figure 7.15 – Raspberry Pi Pico W library structure
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – Raspberry Pi Pico W库结构
- en: With our packages installed, it is now time to write our code. We will start
    with code to control the buzzer as it will be contained in a separate file from
    the main code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了我们的包之后，现在是时候编写我们的代码了。我们将从控制蜂鸣器的代码开始，因为这将包含在主代码之外的一个单独的文件中。
- en: Activating the buzzer
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活蜂鸣器
- en: In *Figure 7**.1*, we see a `buzzer` message sent from the IoT alarm module.
    In our rewrite of the IoT alarm module code, a `buzzer` message is sent out when
    the alarm has been armed and motion is detected from the PIR sensor. We will use
    this message in our Raspberry Pi Pico W IoT button to activate its alarm, although
    we will use it to play a melody through its speaker. As we did with the IoT alarm
    module code, we will use a separate file for our code to activate the buzzer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.1*中，我们看到来自物联网警报模块的`buzzer`消息。在我们重写的物联网警报模块代码中，当警报被激活并且PIR传感器检测到运动时，会发送一个`buzzer`消息。我们将在我们的Raspberry
    Pi Pico W物联网按钮中使用此消息来激活其警报，尽管我们将使用它通过其扬声器播放旋律。像物联网警报模块代码一样，我们将使用单独的文件来激活蜂鸣器。
- en: 'To do this, we do the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Raspberry Pi Pico W连接到USB端口并启动Thonny。我们可以使用Raspberry Pi或另一个操作系统来做这件事。
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过从屏幕的右下角选择它来激活Pico W上的MicroPython环境。
- en: 'In a new tab, we enter the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新标签中，我们输入以下代码：
- en: '[PRE5]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we test out our code, let’s break it down:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们测试代码之前，让我们将其分解：
- en: We start by importing `Pin` and `PWM` from the `machine` module, and the `utime`
    module.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`machine`模块导入`Pin`和`PWM`，以及`utime`模块。
- en: We set the `BUZZER_PIN` constant to pin number `16`, which corresponds to our
    wiring diagram (*Figure 7**.14*).
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`BUZZER_PIN`常量设置为引脚号`16`，这对应于我们的布线图（*图7.14*）。
- en: We then initialize `buzzer` using the `PWM` class with the defined pin.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用定义的引脚通过`PWM`类初始化`buzzer`。
- en: Our `play_notes()` function takes a default argument, `notes`, which is a list
    of tuples. Each tuple represents a frequency in Hertz (such as `E4`, `C4`, and
    so on) and a duration in seconds.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`play_notes()`函数有一个默认参数`notes`，它是一个元组列表。每个元组代表赫兹频率（例如`E4`、`C4`等）和持续时间（以秒为单位）。
- en: 'For each frequency-duration pair in the `notes` list, we do the following:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`notes`列表中的每个频率-持续时间对，我们执行以下操作：
- en: We set the buzzer’s frequency to the specified frequency.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将蜂鸣器的频率设置为指定的频率。
- en: We activate the buzzer with a 50% duty cycle (`duty_u16(32768)`). This produces
    a square wave, defining the character of the sound emitted by the buzzer.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以50%的占空比（`duty_u16(32768)`）激活蜂鸣器。这产生一个方波，定义了蜂鸣器发出的声音的特性。
- en: We wait for the specified duration using `utime.sleep(duration)`.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`utime.sleep(duration)`等待指定的时间。
- en: After playing all the notes, we turn off the buzzer (by setting its duty cycle
    to 0).
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在播放所有音符后，我们将蜂鸣器关闭（通过将其占空比设置为0）。
- en: To save the file, we click on `buzzer.py` to our Raspberry Pi Pico W.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击`buzzer.py`到我们的Raspberry Pi Pico W。
- en: 'To test our code, we use the `play_notes()` function from our new buzzer script:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的代码，我们使用新蜂鸣器脚本中的`play_notes()`函数：
- en: '![Figure 7.16 – Importing the play_notes() function](img/B21282_07_16.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 导入play_notes()函数](img/B21282_07_16.jpg)'
- en: Figure 7.16 – Importing the play_notes() function
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 导入play_notes()函数
- en: 'To activate our buzzer, we simply call the function and hit *Enter*:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要激活我们的蜂鸣器，我们只需调用该函数并按*Enter*键：
- en: '![Figure 7.17 – Running the play_notes() function](img/B21282_07_17.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17 – 运行play_notes()函数](img/B21282_07_17.jpg)'
- en: Figure 7.17 – Running the play_notes() function
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 运行 play_notes() 函数
- en: 'We should hear our buzzer play its default melody. To test our function further,
    let’s send `[(262, 1),(330, 2),(392, 0.5),(262, 1)]` notes to it:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该听到蜂鸣器播放其默认旋律。为了进一步测试我们的函数，让我们向其发送 `[(262, 1),(330, 2),(392, 0.5),(262, 1)]`
    音符：
- en: '![Figure 7.18 – Playing a new melody with the play_notes() function](img/B21282_07_18.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 使用 play_notes() 函数播放新旋律](img/B21282_07_18.jpg)'
- en: Figure 7.18 – Playing a new melody with the play_notes() function
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 使用 play_notes() 函数播放新旋律
- en: We should notice that a different melody plays from our buzzer.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到蜂鸣器播放了不同的旋律。
- en: With our buzzer code in place, it’s now time to focus on the main code that
    will power our Raspberry Pi Pico W IoT button.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的蜂鸣器代码就绪后，现在是时候专注于为主板供电的 Raspberry Pi Pico W IoT 按钮编写主要代码了。
- en: Coding the primary functionality for our IoT button
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写我们 IoT 按钮的主要功能代码
- en: After finalizing the buzzer script, we’re ready to develop the main code for
    our enhanced IoT button. This new iteration can arm the IoT alarm module and features
    a display screen. The screen indicates the alarm module’s status (either armed
    or disarmed) and presents the latest MQTT message from our CloudAMQP server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成蜂鸣器脚本后，我们准备好开发增强型 IoT 按钮的主要代码。这个新版本可以启动 IoT 报警模块，并具有显示屏。屏幕指示报警模块的状态（要么是已启动，要么是解除），并显示来自
    CloudAMQP 服务器的最新 MQTT 消息。
- en: When the IoT alarm module triggers, our IoT button’s buzzer provides audible
    feedback. It activates upon receiving a `buzzer` message. We use the switch on
    our IoT button assembly as a toggle to disarm the alarm on our IoT alarm module.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IoT 报警模块触发时，我们的 IoT 按钮的蜂鸣器提供可听反馈。它在接收到 `buzzer` 消息时激活。我们使用 IoT 按钮组件上的开关作为切换，以解除
    IoT 报警模块的警报。
- en: 'To create the code for our enhanced IoT button, we do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的增强型 IoT 按钮创建代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 Raspberry Pi Pico W 连接到 USB 端口并启动 Thonny。我们可以使用 Raspberry Pi 或其他操作系统来完成此操作。
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在屏幕的右下角选择 MicroPython 环境以激活 Pico W。
- en: 'We will start with our imports. In a new tab, we enter the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导入开始。在新标签页中，我们输入以下代码：
- en: '[PRE6]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then define variables with values obtained from our CloudAMQP account (*Figure
    7**.12*):'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义变量，其值来自我们的 CloudAMQP 账户（*图 7**.12*）：
- en: '[PRE7]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `on_message_received()` method serves as our MQTT client’s callback. By
    using the `global` keyword with `last_message`, we ensure updates to this variable
    are reflected globally throughout the code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_message_received()` 方法作为我们的 MQTT 客户端的回调。通过使用 `global` 关键字与 `last_message`，我们确保此变量的更新在代码的全球范围内反映：'
- en: '[PRE8]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `connect_wifi()` function initializes and activates Pico W’s Wi-Fi. If
    not connected, it attempts to join the network using a predefined SSID and password.
    Meanwhile, an LED blinks to indicate the connection process. Upon successful connection,
    the LED stays on, and the device’s IP address is displayed:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_wifi()` 函数初始化并激活 Pico W 的 Wi-Fi。如果未连接，它尝试使用预定义的 SSID 和密码加入网络。同时，LED
    闪烁以指示连接过程。成功连接后，LED 保持点亮，并显示设备的 IP 地址：'
- en: '[PRE9]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `connect_mqtt()` function tries to establish an MQTT connection using predefined
    server details. If successful, it sets a message callback and subscribes to the
    `IoTAlarm` topic. If the connection fails, the function waits for 5 seconds and
    retries:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_mqtt()` 函数尝试使用预定义的服务器详情建立 MQTT 连接。如果成功，它设置消息回调并订阅 `IoTAlarm` 主题。如果连接失败，函数将等待
    5 秒并重试：'
- en: '[PRE10]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `display_status()` function continuously updates the display every 5 seconds.
    It shows the MQTT connection status at the top, the `arm`/`disarm` status in the
    middle, and the last received MQTT message at the bottom. If connected to MQTT,
    `MQTT Connected` is displayed; otherwise, `MQTT waiting` is shown. We run this
    method in a separate thread in our code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`display_status()` 函数每 5 秒更新一次显示。它显示 MQTT 连接状态在顶部，`arm`/`disarm` 状态在中间，以及底部接收到的最新
    MQTT 消息。如果连接到 MQTT，则显示 `MQTT 已连接`；否则，显示 `MQTT 等待连接`。我们在代码中单独的线程中运行此方法：'
- en: '[PRE11]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `main()` function initiates Wi-Fi and MQTT connections and continuously
    checks the button and switch states. If the button is pressed for over a second,
    an `arm` message is published via MQTT. If the switch state changes, a `disarm`
    message is sent. The function also checks for incoming MQTT messages. If an error
    occurs while checking for messages, the error is printed, and the system waits
    for 5 seconds before resuming checks. The system waits 0.1 seconds between loop
    iterations to optimize performance. We start by defining the `main()` function
    and variables:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数启动 Wi-Fi 和 MQTT 连接，并持续检查按钮和开关状态。如果按钮被按下超过一秒钟，将通过 MQTT 发布 `启动` 消息。如果开关状态发生变化，则发送
    `解除警报` 消息。该函数还会检查传入的 MQTT 消息。如果在检查消息时发生错误，则打印错误，系统等待 5 秒后继续检查。系统在循环迭代之间等待 0.1
    秒以优化性能。我们首先定义 `main()` 函数和变量：'
- en: '[PRE12]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we define an infinite loop and check to see if the main button has been
    pressed for a second (`1000` ms) or greater:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个无限循环并检查主按钮是否被按下超过一秒钟（`1000` 毫秒）或更长时间：
- en: '[PRE13]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our code then sends a `disarm` message if the current switch state is not equal
    to the previous switch state. This conditional check allows us to use our switch
    as a toggle and not have a defined on or off state:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前开关状态不等于上一个开关状态，我们的代码会发送一个 `解除警报` 消息。这种条件检查使我们能够将开关用作切换，而不是定义一个明确的开启或关闭状态：
- en: '[PRE14]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then initialize a new thread to run the `display_status()` function concurrently.
    By using threading, it allows the `display_status()` function to operate independently
    and simultaneously with other parts of the program, ensuring continuous updates
    to the display status without hindering or waiting for other processes:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们初始化一个新的线程来并发运行 `display_status()` 函数。通过使用线程，它允许 `display_status()` 函数独立且同时与其他程序部分一起操作，确保显示状态持续更新，而不会阻碍或等待其他进程：
- en: '[PRE15]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we call the `main()` function, which directs the program’s core activities
    — handling connections, button inputs, and managing MQTT messages:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用 `main()` 函数，该函数指导程序的核心活动——处理连接、按钮输入和管理 MQTT 消息：
- en: '[PRE16]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To save the file, we click on `main.py` to our Raspberry Pi Pico W.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击 `main.py` 到我们的 Raspberry Pi Pico W。
- en: With our main code written, it is time to test it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码编写完成后，是时候对其进行测试了。
- en: Running our enhanced IoT button
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行增强的物联网按钮
- en: Executing the code on our Raspberry Pi Pico W IoT button allows it to interact
    with the IoT alarm module. The button can arm or disarm the module. We will use
    the **MQTT Explorer** app in Windows to monitor real-time MQTT messages, as well
    as send messages to test our enhanced IoT button.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Raspberry Pi Pico W 物联网按钮应用程序上执行代码允许它与物联网警报模块交互。按钮可以启动或解除警报模块。我们将使用 Windows
    中的 **MQTT 探索器** 应用程序来监控实时 MQTT 消息，以及发送消息来测试我们的增强型物联网按钮。
- en: 'We will start by sending messages from the MQTT Explorer app. To do so, we
    do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从 MQTT 探索器应用程序发送消息。为此，我们执行以下操作：
- en: 'From the Microsoft Store in Windows, we search for the MQTT Explorer app:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 的 Microsoft Store 中，我们搜索 MQTT 探索器应用：
- en: '![](img/B21282_07_19.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_07_19.jpg)'
- en: Figure 7.19 – MQTT Explorer in the Microsoft Store
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – Microsoft Store 中的 MQTT 探索器
- en: We run `main.py` on our Raspberry Pi Pico W IoT button application by either
    clicking on the **Run** button in Thonny or by plugging our Pico W into a USB
    power supply.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在 Thonny 中点击 **运行** 按钮或将我们的 Pico W 插入 USB 电源供应来在我们的 Raspberry Pi Pico W
    物联网按钮应用程序上运行 `main.py`。
- en: 'Using MQTT Explorer, we create a connection called `IoTAlarmSystem` with the
    MQTT server credentials from *Figure 7**.12*:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MQTT 探索器，我们创建了一个名为 `IoTAlarmSystem` 的连接，该连接使用来自 *图 7.12* 的 MQTT 服务器凭据：
- en: '![Figure 7.20 – Creating an MQTT connection using MQTT Explorer](img/B21282_07_20.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 使用 MQTT 探索器创建 MQTT 连接](img/B21282_07_20.jpg)'
- en: Figure 7.20 – Creating an MQTT connection using MQTT Explorer
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 使用 MQTT 探索器创建 MQTT 连接
- en: 'To send a message using MQTT Explorer, we type in `IoTAlarm` for the topic
    and `test` for the message before clicking on the **PUBLISH** button:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MQTT 探索器发送消息时，我们在主题中输入 `IoTAlarm`，在消息中输入 `test`，然后点击 **发布** 按钮：
- en: '![Figure 7.21 – Sending an MQTT message](img/B21282_07_21.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – 发送 MQTT 消息](img/B21282_07_21.jpg)'
- en: Figure 7.21 – Sending an MQTT message
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 发送 MQTT 消息
- en: We should observe that a `test` message appears on the OLED screen of our IoT
    button circuit.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到一条 `test` 消息出现在我们的物联网按钮电路的 OLED 屏幕上。
- en: We then press and hold the arcade pushbutton on the IoT button circuit for more
    than a second.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们按下并保持物联网按钮电路上的街机按钮超过一秒钟。
- en: We should observe an `arm` message on the MQTT Explorer app.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在 MQTT 探索器应用程序上观察到 `arm` 消息。
- en: We should also observe the LED on the IoT alarm module start blinking every
    5 seconds. This indicates that the IoT alarm module is armed.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该注意到 IoT 警报模块上的 LED 每 5 秒闪烁一次。这表明 IoT 警报模块已武装。
- en: We test the IoT alarm module by waving our hands in front of the PIR sensor.
    We should observe that the alarm goes off.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在 PIR 传感器前挥动手来测试 IoT 警报模块。我们应该观察到警报响起。
- en: We should observe that after a short time, the alarm on the enhanced IoT button
    circuit goes off.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到，经过一段时间后，增强型 IoT 按钮电路上的警报会关闭。
- en: To disarm the alarm, we toggle the switch from its current position. This should
    result in the buzzer turning off when motion is detected by the PIR sensor. This
    should also disable the buzzer on the enhanced IoT button.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解除警报，我们将开关从当前位置切换。这应该导致当 PIR 传感器检测到运动时，蜂鸣器关闭。这也应该禁用增强型 IoT 按钮上的蜂鸣器。
- en: We should congratulate ourselves as we have successfully built a basic IoT alarm
    system! For the final section of this chapter, we will install the components
    into the custom 3D-printed case.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为自己鼓掌，因为我们已经成功构建了一个基本的 IoT 警报系统！在本章的最后部分，我们将把组件安装到定制的 3D 打印外壳中。
- en: Installing the components in a custom case
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在定制外壳中安装组件
- en: Wiring our components and running our code is an exciting step. Yet, housing
    them in a custom case elevates our project and allows us to use our application
    for practical purposes. A custom case offers not only protection but also the
    versatility to install our advanced IoT button in any desired location.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 布线我们的组件和运行我们的代码是一个令人兴奋的步骤。然而，将它们装入定制外壳可以使我们的项目提升一个层次，并允许我们为实际用途使用我们的应用程序。定制外壳不仅提供保护，而且具有安装我们的高级
    IoT 按钮在任何所需位置的灵活性。
- en: 'In *Figure 7**.22*, we view the components of our custom case, all 3D printed.
    Parts *A* and *B* were produced using a **Fused Deposition Modeling** (**FDM**)
    printer, while *C* and *D* utilized a liquid resin printer. While either printer
    type is suitable, FDM printing requires careful part orientation on the print
    bed to account for layer-line strength:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7**.22* 中，我们查看我们定制外壳的组件，全部为 3D 打印。部件 *A* 和 *B* 使用 **Fused Deposition Modeling**
    (**FDM**) 打印机生产，而 *C* 和 *D* 使用液体树脂打印机。虽然任何打印机类型都适用，但 FDM 打印需要在打印床上仔细定位部件以考虑层线强度：
- en: '![Figure 7.22 – Custom case for enhanced IoT button](img/B21282_07_22.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – 增强型 IoT 按钮的定制外壳](img/B21282_07_22.jpg)'
- en: Figure 7.22 – Custom case for enhanced IoT button
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 增强型 IoT 按钮的定制外壳
- en: 'The parts of our custom case are broken down as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定制外壳的部件如下分解：
- en: '*A*: Shell'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*: 外壳'
- en: '*B*: Backplate'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*: 后盖'
- en: '*C*: Hook'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*: 插件'
- en: '*D*: Mounting bracket wall side mount'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*: 壁侧安装支架'
- en: All parts may be found in the `Pico Button` subfolder of the `Build Files` folder
    in this chapter’s GitHub repository. The mounting screws and LED holder are not
    shown.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 所有部件都可以在本章 GitHub 存储库的 `Build Files` 文件夹的 `Pico Button` 子文件夹中找到。安装螺丝和 LED 座未显示。
- en: Printing the split stand with FDM printers
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FDM 打印机打印分割支架
- en: The split stand in the SenseHAT case files (`Build Files` folder, [*Chapter
    1*](B21282_01.xhtml#_idTextAnchor014) repository) is ideal for FDM printing. By
    splitting and printing each half on its side, the stand gains significant strength.
    An accompanying base is also provided.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: SenseHAT 外壳文件中的分割支架（`Build Files` 文件夹，[*第 1 章*](B21282_01.xhtml#_idTextAnchor014)
    存储库）非常适合 FDM 打印。通过分割并打印每个半边，支架获得了显著强度。还提供了一个配套底座。
- en: 'To install the components into our custom case, we follow the steps in *Figure
    7**.23*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要将组件安装到我们的定制外壳中，我们遵循 *图 7**.23* 中的步骤：
- en: We start by installing the buzzer (see *B* in *Figure 7**.13*) into the shell
    (see *A* in *Figure 7**.22*) with two M5 10 mm bolts and two M5 nuts (*Figure
    7**.23*, *Step 1*).
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用两个 M5 10 毫米螺栓和两个 M5 螺母（见 *B* 在 *图 7**.13* 中）将蜂鸣器（见 *A* 在 *图 7**.22* 中）安装到外壳上。
- en: 'Then (*Figure 7**.23*, *Step 2*), we install the switch (*Figure 7**.13*, *G*)
    and arcade pushbutton (see *D* in *Figure 7**.13*) into their appropriate holes
    in the shell (see *A* in *Figure 7**.22*):'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后（*图 7**.23*，*步骤 2*），我们将开关（*图 7**.13*，*G*）和街机按钮（见 *D* 在 *图 7**.13* 中）安装到外壳中相应的孔中（见
    *A* 在 *图 7**.22* 中）：
- en: '![Figure 7.23 – Constructing the case for the enhanced IoT button](img/B21282_07_23.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – 构建增强型 IoT 按钮的外壳](img/B21282_07_23.jpg)'
- en: Figure 7.23 – Constructing the case for the enhanced IoT button
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 构建增强型 IoT 按钮的外壳
- en: Using an LED holder, we install the LED with 220 Ohm resistor (see *A* in *Figure
    7**.13*) into the shell (see *A* in *Figure 7**.22*) using the left-side hole
    (*Figure 7**.23*,*Step 3*).
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LED支架，我们将220欧姆电阻的LED（见*图7**.13*中的*A*）安装到外壳中（见*图7**.22*中的*A*），使用左侧孔（见*图7**.23*，*步骤3*）。
- en: We secure the OLED screen (see *C* in *Figure 7**.13*) into the shell (see *A*
    in *Figure 7**.22*) using 4 M2 5 mm screws or glue from a hot glue gun (*Figure
    7**.23*,*Step 4*).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用4个M2 5毫米螺丝或热胶枪的胶水（见*图7**.23*，*步骤4*）将OLED屏幕（见*图7**.13*中的*C*）固定到外壳（见*图7**.22*中的*A*）。
- en: Then (*Figure 7**.23*, *Step 4*), we wire the components to a new Raspberry
    Pi Pico W.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后（见*图7**.23*，*步骤4*），我们将组件连接到新的树莓派Pico W。
- en: We then install the hook (see *C* in *Figure 7**.22*) onto the back plate (see
    *B* in *Figure 7**.22*) using two M2 5 mm screws (*Figure 7**.23*, *Step 5*).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用两个M2 5毫米螺丝将钩子（见*图7**.22*中的*C*）安装到背板上（见*图7**.22*中的*B*）（见*图7**.23*，*步骤5*）。
- en: We secure the Pico W onto the back plate (see *B* in *Figure 7**.22*) with four
    M2 5 mm screws (*Figure 7**.23*, *Step 6*).
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用四个M2 5毫米螺丝（见*图7**.23*，*步骤6*）将Pico W固定在背板上（见*图7**.22*中的*B*）。
- en: Then (*Figure 7**.23*, *Step* *7*), we use four M3 10 mm bolts to secure the
    back plate (see *B* in *Figure 7**.22*) to the shell (see *A* in *Figure 7**.13*).
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后（见*图7**.23*，*步骤7*），我们使用四个M3 10毫米螺栓将背板（见*图7**.22*中的*B*）固定到外壳（见*图7**.13*中的*A*）。
- en: With the back plate (see *B* in *Figure 7**.22*) secured to the shell (see *A*
    in *Figure 7**.22*), we connect the assembly to the mounting bracket (see *D*
    in *Figure 7**.22*) using an M5 20 mm bolt and M5 nut.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将背板（见*图7**.22*中的*B*）固定到外壳（见*图7**.22*中的*A*）后，我们使用M5 20毫米螺栓和M5螺母将组件连接到安装支架（见*图7**.22*中的*D*）。
- en: Using the steps from the section, *Coding the primary functionality for our
    IoT button*, we install the packages and client code for our enhanced IoT button.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“为我们的物联网按钮编码主要功能”部分的步骤，我们安装了我们的增强型物联网按钮的软件包和客户端代码。
- en: With the components securely installed, we can now position our Raspberry Pi
    Pico W IoT button in any desired location, be it a home, office, or workshop setting.
    Our design not only serves our primary alarm system purpose but also makes it
    adaptable for a multitude of other applications, expanding its utility and offering
    potential for innovative integrations in many different scenarios.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件安全安装后，我们现在可以将我们的树莓派Pico W物联网按钮放置在任何希望的位置，无论是家庭、办公室还是车间环境。我们的设计不仅服务于我们的主要警报系统目的，而且使其适用于多种其他应用，扩大其用途，并在许多不同场景中提供创新的集成潜力。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored IoT buttons, starting with a description of what
    they are and where they are used. We then explored various technologies that we
    could use to build an IoT button.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了物联网按钮，从描述它们是什么以及它们在哪里使用开始。然后，我们探讨了我们可以用来构建物联网按钮的各种技术。
- en: We then proceeded to build our first IoT button using a public MQTT service
    and an M5Stack ATOM Matrix. We were able to connect our IoT button to the IoT
    alarm module we built in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后开始使用公共MQTT服务和M5Stack ATOM Matrix构建我们的第一个物联网按钮。我们能够将我们的物联网按钮连接到我们在[*第6章*](B21282_06.xhtml#_idTextAnchor091)中构建的物联网警报模块。
- en: From there, we upgraded our MQTT server to a private one using CloudAMQP. We
    did so for reliability and security reasons as we started to build out our IoT
    alarm system more. We upgraded the code sitting on our IoT alarm module before
    building our second IoT button using a Raspberry Pi Pico W and various components.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们使用CloudAMQP将我们的MQTT服务器升级为私有服务器。我们这样做是为了可靠性和安全性的原因，因为我们开始构建我们的物联网警报系统。在用树莓派Pico
    W和各种组件构建第二个物联网按钮之前，我们升级了物联网警报模块上的代码。
- en: We finished the chapter by installing the components of our second (enhanced)
    IoT button into a 3D-printed case. Doing so transformed our circuit from an educational
    tool to a working device suitable for deployment in commercial settings.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将我们的第二个（增强型）物联网按钮的组件安装到3D打印的盒子里来结束本章。这样做将我们的电路从教育工具转变为适合在商业环境中部署的工作设备。
- en: In the next chapter, we will continue to build our IoT alarm system by going
    back to the Raspberry Pi, where we will build a security dashboard.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建我们的物联网警报系统，回到树莓派，在那里我们将构建一个安全仪表板。
