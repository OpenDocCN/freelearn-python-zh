- en: Home Automation Using the Raspberry Pi Zero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the title of the chapter suggests, we will discuss home improvement projects
    involving the Raspberry Pi Zero in this chapter. We selected our projects such
    that each example could be executed as a weekend project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Voice-activated personal assistant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web framework-based appliance control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical activity motivation tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart lawn sprinkler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voice activated personal assistant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first project, we are going to emulate personal assistants such as Google
    Home ([https://madeby.google.com/home/](https://madeby.google.com/home/)) and
    Amazon Echo ([http://a.co/cQ6zJk6](http://a.co/cQ6zJk6)) using a Raspberry Pi
    Zero. We will build an application where we can add reminders and events to a
    calendar and controlling appliances.
  prefs: []
  type: TYPE_NORMAL
- en: We will be making use of **houndify** ([houndify.com](http://houndify.com))—a
    tool that is designed to provide interactions with smart devices. We will install
    the requisite software tools on the Raspberry Pi Zero. We will interface a button
    to the Raspberry Pi Zero's GPIO. We will write some code to create reminders and
    turn on/off appliances using *Houndify*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following accessories (apart from your Raspberry Pi Zero) are recommended
    for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Item** | **Source** | **Price (in USD)** |'
  prefs: []
  type: TYPE_TB
- en: '| USB sound card | [http://a.co/824dfM8](http://a.co/824dfM8) | 8.79 |'
  prefs: []
  type: TYPE_TB
- en: '| Microphone amplifier board with adjustable gain | [https://www.adafruit.com/products/1713](https://www.adafruit.com/products/1713)
    | 7.95 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.5 mm auxiliary cable | [https://www.adafruit.com/products/2698](https://www.adafruit.com/products/2698)
    | 2.50 |'
  prefs: []
  type: TYPE_TB
- en: '| Momentary push button set | [https://www.adafruit.com/products/1009](https://www.adafruit.com/products/1009)
    | 5.95 |'
  prefs: []
  type: TYPE_TB
- en: '| Breadboard, resistors, jumper wires, and capacitors | N. A. | N. A. |'
  prefs: []
  type: TYPE_TB
- en: '| Speaker (suggestion) | [http://a.co/3h9uaTI](http://a.co/3h9uaTI) | 14.99
    |'
  prefs: []
  type: TYPE_TB
- en: Installing requisite packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is installing the requisite packages for the project. This includes
    the following packages: `python3-pyaudio python3-numpy`. They may be installed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: A push button is interfaced to the Raspberry Pi Zero's GPIO. When the GPIO button
    is pressed, the recorder is turned on (at the start of a beep sound from the speaker).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recorder accepts the user request and processes it using the `Houndify`
    library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assistant processes the audio file using `Houndify` and responds to the
    user request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this project, we are using a push button to start listening to user requests,
    whereas commercially available products, such as Amazon's Echo or the Google Home,
    have special hardware (along with software) to enable this capability. We are
    using a push button to simplify the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the audio tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will connect the USB sound card, speaker, and the microphone
    for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the speaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to connect to speakers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the USB sound card to your Raspberry Pi Zero and find out if the USB
    sound card enumerates using the `lsusb` command (on your Raspberry Pi Zero''s
    command-line terminal):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_001.png)'
  prefs: []
  type: TYPE_IMG
- en: USB sound card enumeration
  prefs: []
  type: TYPE_NORMAL
- en: Cheap USB sound cards typically have an input terminal (to connect a microphone)
    and an output terminal (to connect a speaker). Both the terminals are standard
    3.5 mm jacks. The input terminal is pink and typically marked with a microphone
    symbol. The output terminal is green and marked with a speaker symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a speaker to the output terminal (green) of the USB sound card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On your Raspberry Pi Zero''s command-line terminal, list all the audio sources
    connected to your Raspberry Pi Zero using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the `aplay` command's output, the sound card is listed as `card
    1`. We need this information to set the USB sound card as the default audio source
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your sound configuration file from the command line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the configuration file''s source is set to `card 1` (the soundcard):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save the configuration file (by pressing *Ctrl *+ *X* and press *Y* to confirm
    the name of the file. Press *Enter* to save the file. Refer to [Chapter 11](83036e86-f65c-46ed-996d-4f1aeeab5022.xhtml), *Tips
    and Tricks* chapter for a detailed tutorial) and reboot your Raspberry Pi Zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'On reboot, test if the speaker works by downloading a wave file ([Freesound.org](http://Freesound.org)
    has plenty of wave files). From the command-line terminal, play your file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If everything is configured properly, you should be able to play audio using
    your USB sound card and speaker. If you are not able to play the audio, check
    the connections and make sure that your USB sound card is enumerated correctly
    and you have chosen the right audio source in the configuration file. In the next
    section, we will set up the microphone.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the microphone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be setting up an omnidirectional microphone to listen
    for commands/inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We tested off-the-shelf electret microphones, and the audio quality was not
    sufficient to perform speech recognition on the recorded audio samples. As an
    alternative, we recommend boundary microphones for a wide pickup, for example,
    [http://a.co/8YKSy4c](http://a.co/8YKSy4c).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'MAX9814 with omnidirectional microphone Source: Adafruit.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'The gain of the amplifier can be set to three levels: **60 dB** when the gain
    pin is unconnected, **50 dB** when the gain pin is connected to ground, and **40
    dB** when the gain pin is connected to **V[dd]**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect **Vdd** and the **GND** pins to the **5V** and **GND** pins of the Raspberry
    Pi's GPIO pins (,pins 4 and 6 of the Raspberry Pi's GPIO).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut the 3.5 mm cable into two halves. It consists of three wires connected to
    the **Tip**, **Ring** and **Sleeve** of the 3.5 mm connector (as shown in the
    picture here). Use a multimeter to identify the **Sleeve**, **Tip**, and **Ring**
    wires of the 3.5 mm connector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Cut the auxiliary cable and identify the three wires of the cable
  prefs: []
  type: TYPE_NORMAL
- en: Connect a 100 mF electrolytic capacitor to the output of the amplifier where
    the positive lead is connected to the output and the other end is connected to
    the tip of the 3.5 mm connector. The ground pin of the amplifier is connected
    to the sleeve of the 3.5 mm connector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Microphone connections to the 3.5 mm connector
  prefs: []
  type: TYPE_NORMAL
- en: The microphone is ready to use. Power the microphone using the GPIO pins of
    the Raspberry Pi Zero and plug the 3.5 mm connector into the input terminals of
    the USB sound card (marked with the microphone symbol).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microphone connected to 3.5 mm connector
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to test the microphone and set an optimal capture volume. From
    the Raspberry Pi Zero''s command-line terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will record the file for 10 seconds. Play it back using the `aplay` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to hear the recorded conversation. Check your connections
    whether you don't hear anything (**GND**, **5V**, amplifier output pins, and so
    on. We have also included additional resources for the microphone troubleshooting
    at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the recorded content is too loud or too feeble, adjust the capture volume
    using `alsamixer`. Launch `alsamixer` from the command-line terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_006.png)'
  prefs: []
  type: TYPE_IMG
- en: alsamixer control panel
  prefs: []
  type: TYPE_NORMAL
- en: Press *F5* to view all options. Use the arrow keys to adjust the value and M
    to disable autogain control. Let's move on to the next section where we build
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Houndify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Houndify** ([www.houndify.com](http://www.houndify.com)) is a tool that enables
    adding voice interaction to devices. Their free account enables performing 44
    different types of actions. Sign up for an account on their website and activate
    it (via your e-mail).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your account is activated, go to your account dashboard to create a new
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On creating a new account, a new client is automatically created. This client
    may not work properly. Delete it and create a new client from the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Create new client
  prefs: []
  type: TYPE_NORMAL
- en: Give a name to your application and select the platform to be Home Automation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_008.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the application and select the platform
  prefs: []
  type: TYPE_NORMAL
- en: The next step is selecting domains, that is, the nature of applications the
    assistant must support. Select Weather, Stock Market, Dictionary, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_009.png)'
  prefs: []
  type: TYPE_IMG
- en: Enable domains
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Save & Continue. Once you have created your new client, click on it
    (from the dashboard) to retrieve the following credentials: Client ID and Client
    Key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the Client id and the Client Key from the dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to download the SDK for Python 3.x (latest version available at
    [https://docs.houndify.com/sdks#python](https://docs.houndify.com/sdks#python)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The SDK comes with plenty of examples to get started. Let''s consider a scenario
    where you would like to find out the weather at your current location by interacting
    with the voice assistant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get your current GPS coordinates from a tool such as Google Maps. For example,
    the GPS coordinates for a specific intersection in San Francisco, California is
    37.778724, -122.414778\. Let's try to find the weather at this specific location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `sample_wave.py` file and modify `line 39` of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and from the command-line terminal, change directories to the
    `Houndify SDK folder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After processing the request, it should print a detailed response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We verified the function and setup of the Houndify SDK by testing the example.
    We uploaded an audio file to the Houndify server requesting the current weather
    information (play the audio file and find out). The `sample_wave.py` script takes
    the `client_id`, `client_key`, and the audio file as inputs. It prints out the
    output from the Houndify server.
  prefs: []
  type: TYPE_NORMAL
- en: You need to enable specific domains to retrieve specific information. For example,
    we enabled the weather domain to retrieve the weather information. It is also
    possible to add custom commands to the program.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will modify `sample_wave.py` to build our application.
  prefs: []
  type: TYPE_NORMAL
- en: Building voice commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with building our voice assistant that we can use to find
    the weather and turn on/off lights. Because we enabled the weather domain while
    setting up our Houndify account, we need to add custom commands to turn on/off
    lights:'
  prefs: []
  type: TYPE_NORMAL
- en: On your Houndify dashboard, go to your client's home page. Dashboard | Click
    on your client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate Custom Commands on the navigation bar to the left. Let's add a custom
    command each to turn on and turn off the light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete `ClientMatch #1` that comes as a template with the custom commands.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Locate Custom commands and Delete Client Match #1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Add ClientMatch to add a custom command to turn on lights. Populate
    the fields with the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expression: `["Turn"].("Lights"). ["ON"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: `{"action": "turn_light_on"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SpokenResponse: `Turning Lights On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SpokenResponseLong: `Turning your Lights On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WrittenResponse: `Turning Lights On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WrittenResponseLong: `Turning your Lights On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the preceding steps to add a command to turn lights off
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test and verify that these commands work using `sample_wave.py`. Make your own
    recording for the test. We have also provided audio files along with this chapter's
    download (available in the folder `audio_files`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a copy of `sample_wave.py` to build our assistant. We recommend
    reading through the file and familiarizing yourself with its function. The detailed
    documentation for the Houndify SDK is available at [https://docs.houndify.com/sdks/docs/python](https://docs.houndify.com/sdks/docs/python):'
  prefs: []
  type: TYPE_NORMAL
- en: In the file `stream_wav.py`, the `StreamingHoundClient` class is used to send
    audio queries, such as request for weather information and commands to turn on/off
    lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MyListener` class inherits the `HoundListener` class (from the `houndify`
    SDK).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `MyListener` class implements callback functions for three scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partial Transcription (the `onPartialTranscript` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete Transcription (the `onFinalResponse` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error State (the `onError` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make use of action intents to turning on/off lights using voice command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we implemented the custom commands on the Houndify website, we added an
    action intent for each command. For example, the action intent for turning on
    the lights was:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to turn on/off the lights based on the received action intent, we
    need to import the `OutputDevice` class from `gpiozero`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The GPIO pin that controls the light is initialized in the `__init__` method
    of the `MyListener` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On completing transcription, if an action intent is received, the lights are
    either turned on or turned off. It is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`response` is a dictionary that consists of the parsed `json` response. Refer
    to the SDK documentation and try printing the response yourself to understand
    its structure.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to announce the voice assistant's action while turning on/off lights.
    We explored different text-to-speech tools, and they sounded robotic when compared
    with off-the-shelf products such as the Google Home or Amazon Echo. We came across
    this script that makes use of the *Google Speech-to-Text engine* at [http://elinux.org/RPi_Text_to_Speech_(Speech_Synthesis)](http://elinux.org/RPi_Text_to_Speech_(Speech_Synthesis)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the script makes use of Google's text-to-speech engine, it connects
    to the Internet to fetch the transcribed audio data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new shell script from the Raspberry Pi''s command-line terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Paste the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the file executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to make use of this script to announce any actions by the assistant.
    Test it from the command line using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The system calls to announce the voice assistant actions are implemented as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test what we have built so far in this section. The preceding code snippets
    are available for download along with this chapter as `voice_assistant_inital.py`.
    Make it executable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the program as follows (audio files are also available for download with
    this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Adding a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a button to our voice assistant. This momentary push button is connected
    to pin 2 (BCM numbering) and the LED is connected to pin 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_012.png)'
  prefs: []
  type: TYPE_IMG
- en: Voice Assistant interface setup
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read the button presses, we need to import the `Button` class from
    `gpiozero`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When a button is pressed, the voice assistant needs to play a beep sound indicating
    that it is awaiting the user's command. Beep sounds of your choice can be downloaded
    from [www.freesound.org](http://www.freesound.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following the beep sound, the user command is recorded for a duration of 5
    seconds. The recorded file is then processed using the *Houndify* SDK. The following
    code snippet shows the trigger function that is called when the button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The trigger function is registered as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Connect the button and the LED to the Raspberry Pi's GPIO interface to test
    the voice assistant.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Voice assistant setup
  prefs: []
  type: TYPE_NORMAL
- en: 'The voice assistant code file is available for download along with this chapter
    as `voice_assistant.py`. Download the code sample and try the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have shared a video (on this book's site) that demonstrates the function
    of the voice assistant. Now, we have demonstrated the voice assistant using an
    LED. In order to control a table lamp, simply replace the LED with a power switch
    tail II ([http://www.powerswitchtail.com/Pages/default.aspx](http://www.powerswitchtail.com/Pages/default.aspx)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_014.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Things to keep in mind**:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `voice_assistant.py` to `/etc/rc.local` so that it starts automatically
    on boot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The entire setup can be unwieldy. Assemble the components inside an enclosure
    to organize the wiring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the project involves electrical appliances, use prescribed cables and
    terminate them properly. Ensure that the cables are connected properly. We will
    share examples of the same on our website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project ideas and enhancements**:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the assistant works only at the press of a button. How will you make
    it listen for a keyword? For example, "Ok, Google" or "Alexa"?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it possible to have a remote trigger? Think something on the lines of *Amazon
    Tap*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have lights such as Philips Hue or Internet-connected switches such as
    WeMo switch smartplug or the TP-Link Smart switch, you can control them using
    a voice assistant. IFTTT provides applets to control them yourself. Create a maker
    channel web hook to control them. Refer to Chapter 8 for examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web framework based appliance control/dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review building a dashboard in order to control appliances.
    This could be a dashboard for the aquarium where you would like to monitor all
    the requisite parameters for the tank or a dashboard for the garden where you
    can control the flow control valves for your garden based on information from
    the sensors. We will demonstrate this with a simple example and show how you can
    use it to meet your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of the `flask` framework to build our dashboard. If you haven''t
    installed the `flask` framework (from the previous chapters), you can install
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with the flask framework, we have written up some basics
    and getting started in [Chapter 7](2316ddf6-c2d7-4810-a7ab-3600a3e2549d.xhtml),
    *Requests and Web Frameworks*. We are going to discuss controlling the relay board
    (shown in the picture here) from a web dashboard (available at [http://a.co/1qE0I3U](http://a.co/1qE0I3U)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relay module
  prefs: []
  type: TYPE_NORMAL
- en: The relay board consists of eight relays that could be used to control eight
    devices. The relays are rated for 10A, 125V AC and 10A, 28V DC.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to follow safety regulations while trying to control AC appliances
    using a relay board. If you are a beginner in electronics, we recommend using
    the unit, [http://a.co/9WJtANZ](http://a.co/9WJtANZ). It comes with the requisite
    circuitry and protections (shown in the following figure). **Safety first!**
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enclosed high power relay for Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'Each relay on the 8-relay board consists of the following components: an optocoupler,
    transistor, relay, and a freewheeling diode (shown in the schematic here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_017.png)'
  prefs: []
  type: TYPE_IMG
- en: Schematic of one relay on 8-relay board (generated using fritzing)
  prefs: []
  type: TYPE_NORMAL
- en: The schematic is used to explain the function of the relay board; hence, it
    is not accurate. It is missing some discrete components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relay board requires a 5V power supply (through the Vcc pin):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vcc, GND and GPIO pins
  prefs: []
  type: TYPE_NORMAL
- en: Each relay on the relay board is controlled by pins IN1 through IN8\. Each pin
    is connected to an optocoupler (optoisolator-U1 in the schematic). The function
    of the isolator is to separate the Raspberry Pi from high voltages connected to
    the relay. It protects from any transient voltages while switching the relays
    (we have provided additional resources at the end of this chapter to better understand
    optocouplers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The phototransistor of the optocoupler is connected to the base of an NPN transistor.
    The NPN transistor's collector pin is connected to a relay, whereas the emitter
    is connected to the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The relay is driven by an active-low signal that is when a 0V signal is given
    to one of the pins, IN1 through IN8\. The phototransistor (of the optocoupler)
    sends a *high* signal to the base of the transistor. Here, the transistor acts
    as a switch. It closes the circuit and thus energizes the relay. This is basically
    the transistor switching circuit that we discussed in an earlier chapter except
    for an additional component, the optocoupler. An LED lights up indicating that
    the relay is energized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_019.png)'
  prefs: []
  type: TYPE_IMG
- en: The components of each relay circuit (labeled)
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend reading about optocouplers to understand their need and
    how an active-low signal to this relay board drives the relays.
  prefs: []
  type: TYPE_NORMAL
- en: Across each relay, there is a flywheel diode. A flywheel diode protects the
    circuit from any inductive kickback voltages of the relay when the relay is de-energized/turned
    off. (We have included a reading resource on relays and inductive kickbacks at
    the end of this chapter.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each relay has three terminals, namely the common terminal, normally open terminal,
    and the normally closed terminal. When an active-low signal is used to drive one
    of the relays, the common terminal comes into contact with the normally open terminal.
    When the relay is de-energized, the common terminal comes into contact with the
    normally closed terminal. Hence, the terminals have the name, normally open and
    normally closed (The terminals are highlighted with the labels N.O., C, and N.C.
    in the picture here).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_020.png)'
  prefs: []
  type: TYPE_IMG
- en: The terminals of a relay
  prefs: []
  type: TYPE_NORMAL
- en: The device that needs to be controlled using the web dashboard needs to be connected
    to the relay terminals, as shown in the schematic given later. For example, let's
    consider a device that is powered using a 12V adapter. The device's needs to be
    rigged such that the positive terminal of the power jack is connected to the common
    terminal of the relay. The normally open terminal is connected to the device's
    positive line. The device's ground is left untouched. Keep the power adapter plugged
    in, and the device shouldn't turn on as long as the relay is not energized. Let's
    review controlling this device using a web dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_021.png)'
  prefs: []
  type: TYPE_IMG
- en: Schematic to rig a 12V DC appliance with a relay
  prefs: []
  type: TYPE_NORMAL
- en: For an AC power appliance, we recommend using the power switch tail II or the
    AC relay unit discussed earlier in this section. They are safe for hobby grade
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building the web dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is creating the html template for the dashboard. Our dashboard
    is going to enable controlling four appliances, that is, turn them on or off:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our dashboard, we need an `html``table` where each row on the table represents
    a device, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, each device state is encapsulated in a data
    cell `<td>`, each device is represented by a `checkbox`, and the device state
    is represented by an on/off `radio` button. For example, a motor is represented
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On the dashboard, this would be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_022.png)'
  prefs: []
  type: TYPE_IMG
- en: Device represented by a checkbox and radio button
  prefs: []
  type: TYPE_NORMAL
- en: 'The table is encapsulated in an `html form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The device states are submitted to the `flask` server when the user hits the
    `energize` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/image_10_023.png)'
  prefs: []
  type: TYPE_IMG
- en: Energize button
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, we need to set up the GPIO pins used to control the relays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The list `relay_index` represents the GPIO pins being used to control the relays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before starting the server, we need to create an `OutputDevice` object (from
    the `gpiozero` module) for all the devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `OutputDevice` object meant for each device/relay is initialized and added
    to the `devices` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form is submitted (by hitting the energize button), the `POST` request
    is handled by the `energize()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are controlling four devices that are represented by `relay_x`, and their
    corresponding states are represented by `state_x`, that is, On or Off. The default
    state is Off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a form is submitted by the user, we determine if the `POST` request contains
    information related to each device. If a specific device needs to be turned on/off,
    we call the `on()`/`off()` method of that device''s object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we fetch information related to all relays as
    a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the form, each device is represented by a value `relay_x` (`relay_0` through
    `relay_3`). A `for` loop is used to determine a specific relay is turned on/off.
    The state of each device is represented by the value `state_x` where `x` corresponds
    to the device (from 0 through 3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GPIO pins used in this example are connected to the relay board pins, IN1
    through IN4\. The relay board is powered by the Raspberry Pi's GPIO power supply.
    Alternatively, you may power it using an external power supply. (You still need
    to connect the ground pin of the Raspberry Pi Zero to the relay board.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The earlier-mentioned dashboard is available along with this chapter under the
    subfolder `flask_framework_appliance` (including the `flask` server, html files,
    and so on.). In the following snapshot, the Motor and Tank Light 2 are checked
    and set to On. In the picturehere, the first and the third relay are energized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_024.png)'
  prefs: []
  type: TYPE_IMG
- en: Turning on Motor and Tank Light 2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relays 1 and 3 energized
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise for the reader**:'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we made use of a `POST` request to control devices. How would
    you make use of a `GET` request to display room temperature from a temperature
    sensor?
  prefs: []
  type: TYPE_NORMAL
- en: '**Project ideas/enhancements**:'
  prefs: []
  type: TYPE_NORMAL
- en: With some basic web design skills, you should be able to build a dashboard with
    better aesthetic appeal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that a dashboard should provide as detailed information as possible.
    Determine how data visualization tools could enhance your dashboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider replacing the checkbox and radio buttons with a sliding toggle switch
    (the type used in mobile applications).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build a dashboard for switching holiday light sequences from your local
    browser. Think of ways to compete with your neighbours during the holidays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can permanently install the relay board and the Raspberry Pi Zero in a weather
    proof enclosure as given at [http://www.mcmelectronics.com/product/21-14635](http://www.mcmelectronics.com/product/21-14635).
    Check out this book's website for some examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personal Health Improvement—Sitting is the new smoking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project makes use of specific accessories. You are welcome to substitute
    it with alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed projects that could be an enhancement around your
    living environment. In this section, we are going to write some Python code on
    the Raspberry Pi Zero and build a tool that helps improving your personal help.
  prefs: []
  type: TYPE_NORMAL
- en: According to the World Health Organization, physical activity of 150 minutes
    in a week can help you stay healthy. Recent studies have found that walking 10,000
    steps in a day can help avoid life style diseases. We have been making use of
    pedometers to keep track of our daily physical activity. It is difficult to maintain
    consistency in physical activity as we tend to ignore our personal health over
    daily commitments. For example, in the physical activity timeline shown here,
    you will note that all the physical activity is concentrated toward the end of
    the day.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_026.png)'
  prefs: []
  type: TYPE_IMG
- en: Physical activity in a day (data fetched from a commercially available pedometer)
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build a visual aid that would remind us to stay physically
    active. We believe that this tool should help put your personal fitness tracker
    to good use. The following are the recommended accessories for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pedometer**: The cost of pedometers vary anywhere from $20-$100\. We recommend
    getting a tracker from Fitbit since it comes with extensive developer resources.
    It is not required to have a tracker. We are going to demonstrate this visual
    aid using a Fitbit One ([http://a.co/8xyNSmg](http://a.co/8xyNSmg)) and suggest
    alternatives at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pimoroni Blinkt (optional)**: This is an LED strip ([https://www.adafruit.com/product/3195](https://www.adafruit.com/product/3195))
    that can be stacked on top of your Raspberry Pi Zero''s GPIO pins (shown in the
    picture here).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_10_027.png)'
  prefs: []
  type: TYPE_IMG
- en: Pimoroni Blinkt
  prefs: []
  type: TYPE_NORMAL
- en: '**Pimoroni Rainbow HAT (optional** [https://www.adafruit.com/products/3354](https://www.adafruit.com/products/3354)**)**:
    This is an add-on hardware designed for the Android Things platform on the Raspberry
    Pi. It comes with LEDs, 14-segment displays, and a buzzer. It can come handy for
    the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_10_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rainbow HAT for android things
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may add LED strips and components to this visual aid using
    your creativity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing requisite software packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is installing the requisite packages. Because we are going to
    make use of the Fitbit tracker, we need to install the `fitbit python client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are going to make use of the Pimoroni Blinkt LED strip, you should install
    the following package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are going to be making use of the rainbow HAT, the following package
    needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Getting access keys for Fitbit client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need access keys to make use of the Fitbit API. There is a script available
    from the fitbit python client repository at [https://github.com/orcasgit/python-fitbit](https://github.com/orcasgit/python-fitbit).
  prefs: []
  type: TYPE_NORMAL
- en: The access keys can also be obtained from the command-line terminal of a Linux
    or Mac OS laptop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new app at [https://dev.fitbit.com/apps](https://dev.fitbit.com/apps):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_029.png)'
  prefs: []
  type: TYPE_IMG
- en: Register a new app at dev.fitbit.com
  prefs: []
  type: TYPE_NORMAL
- en: While registering a new application, fill in the description including the name
    of your application and give a temporary description, organization, website, and
    so on, and set the OAuth 2.0 Application Type to Personal and access type to Read-Only.
    Set the callback URL to `http://127.0.0.1:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_030.png)'
  prefs: []
  type: TYPE_IMG
- en: Set callback URL
  prefs: []
  type: TYPE_NORMAL
- en: Once your application is created, copy the Client ID and Client Secret from
    application's dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_031.png)'
  prefs: []
  type: TYPE_IMG
- en: Note down the client_id and client secret
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Raspberry Pi''s command-line terminal, download the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The next step needs to be executed by opening the command-line terminal from
    your Raspberry Pi Zero's desktop (not via remote access).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the script by passing the `client id` and `client secret` as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It should launch a browser on your Raspberry Pi Zero's desktop and direct you
    to a page on [https://www.fitbit.com/home](https://www.fitbit.com/home) requesting
    your authorization to access your information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_032.png)'
  prefs: []
  type: TYPE_IMG
- en: Authorize access to your data
  prefs: []
  type: TYPE_NORMAL
- en: 'If the authorization was successful, it should redirect you to a page where
    the following information is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_033.png)'
  prefs: []
  type: TYPE_IMG
- en: Authorization to access the Fitbit API
  prefs: []
  type: TYPE_NORMAL
- en: Close the browser and copy the `refresh_token` and `access_token` information
    displayed on the command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_034.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy access_token and refresh_token
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to use the Fitbit API! Let's test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Fitbit API Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The documentation for the Fitbit API is available at [http://python-fitbit.readthedocs.org/](http://python-fitbit.readthedocs.org/).Let''s
    write a simple example to get today''s physical activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is import the `fitbit` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to initialize the `fitbit` client using the `client key`, `client secret`,
    `access_token`, and `refresh_token` earlier in this section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: According to the Fitbit API documentation, the current day's physical activity
    can be retrieved using the `intraday_time_series()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The required arguments to retrieve the physical activity include the resource
    that needs to be retrieved; that is, steps, `detail_level`, that is, the smallest
    time interval for which the given information needs to be retrieved, start times
    and the end times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The start time is 12:00 a.m. of the current day, and the end time is the current
    time. We will be making use of the `datetime` module to get the current time.
    There is a function named `strftime` that gives us the current time in the *hour:minute*
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that your Raspberry Pi Zero's OS time is correctly configured with
    the local time zone settings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fitbit` client returns a dictionary containing the current day''s physical
    activity and intraday activity in 15-minute intervals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example is available for download along with this chapter as `fitbit_client.py`.
    If you have a Fitbit tracker, register an application and test this example for
    yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the visual aid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a visual aid where we display the number of steps taken in a given
    day using an LED strip. The LED strip would light up like a progress bar based
    on the daily physical activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is importing the requisite libraries while building the visual
    aid. This includes the `fitbit` and `blinkt` libraries. We will also import some
    additional libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you have the requisite tokens discussed earlier in this section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `refresh token` is needed every `8` hours. This is a feature of the API''s
    authorization mechanism. Hence, we need a function that gets a new token using
    the existing token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the function `refresh_token()`, we are making use of the `FitbitOauth2Client`
    class to refresh the token. It is important to note that we have made use of the
    `global` keyword. The `global` keyword helps with modifying the `REFRESH_TOKEN`
    and enables the use of the new token in other parts of the program. Without the
    `global` keyword, the changes made to any variable is restricted to the `refresh_token()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In general, it is a bad practice to make use of the `global` keyword. Use it
    with your best judgement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a function to retrieve steps using the `Fitbit` class. We are
    going to use the same procedure as the previous example. Initialize the `fitbit`
    class and retrieve the steps using `intraday_time_series`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we schedule a timer that refreshes the token every `8`
    hours using the schedule library ([https://pypi.python.org/pypi/schedule](https://pypi.python.org/pypi/schedule)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We check for the steps every `15` minutes and light up the LEDs accordingly.
    Because the *Pimoroni Blinkt* consists of eight LEDs, we can light up one LED
    for every `1250` steps of physical activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For every multiple of `1250` steps, we set an LED's color to green using the
    `blinkt.set_pixel()` method. We set the next LED to a blinking red. For example,
    at the time of writing this section, the total number of steps was 1604\. This
    is (1250 x1) + 354 steps. Hence, we light up one LED in green and the next LED
    blinks red. This indicates that the steps are in progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The picture here shows the blinking red LED when the progress was less than
    `1250` steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Physical activity progress less than 1250 steps
  prefs: []
  type: TYPE_NORMAL
- en: 'After walking around, the progress shifted to the right by one LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_10_036-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Physical activity at 1604 steps
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to set off a buzzer when there is no minimum physical activity.
    This is achieved by connecting a buzzer to the GPIO pins of the Raspberry Pi Zero.
    We have demonstrated the use of a buzzer in an earlier chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The earlier example is available for download along with this chapter as `visual_aid.py`.
    We will let you figure out the logic to set off a buzzer when there is no minimum
    physical activity in a period (for example, an hour).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install this visual aid somewhere prominent and find out if it motivates you
    to stay physically active! If you make use of the *Pimoroni Rainbow HAT*, you
    can display the steps using the 14-segment display.
  prefs: []
  type: TYPE_NORMAL
- en: Smart lawn sprinkler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In drought-struck states like California, United States, there are severe restrictions
    on water usage in certain parts of the state. For example: In summer, some cities
    passed an ordinance restricting water usage to 250 gallons per day. In such states,
    it is ridiculous to find lawn sprinklers going off the day before the rain. We
    are going to build a lawn sprinkler controller that only turns on when there is
    no rain predicted for the next day.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to build a smart lawn sprinkler, we need a flow control solenoid valve
    (for example, [https://www.sparkfun.com/products/10456](https://www.sparkfun.com/products/10456)).
    Make sure that the valve can meet the water pressure requirements. This flow control
    valve can be interfaced to the Raspberry Pi Zero using a transistor switching
    circuit discussed in earlier chapters or the relay board we discussed earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will be making use of *DarkSky API* ([https://darksky.net](https://darksky.net))
    to fetch the weather information. It provides a simple response format that could
    be used to determine if it was going to rain the next day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign up for a free account at the website and get a developer key from the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'According to the API documentation, the local weather information may be obtained
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The latitude and longitudinal coordinates can be obtained using a simple web
    search. For example, the request URL for Newark, CA is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The response includes the `current`, `minutely`, and `hourly` forecasts. They
    can be excluded using the `exclude` parameter as shown in the preceding URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to turn on the sprinkler only if it is not going to rain the next
    day. According to the API documentation, the weather forecast is returned as a
    `Data Point object`. The data points include a field named `icon` that indicates
    whether it is going to be `clear`, `cloudy`, or `rainy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write a method `check_weather()` that fetches the weather for the week:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the `GET` request was successful, which can be determined by the status code
    of the response, the `json` response is decoded using the `json()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next day's weather information is available at `data["daily"]["data"][1]`
    (Print the response and verify it for yourself).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the `icon` key provides a machine-readable response, it could be used
    to turn on the sprinkler. Hence, the `check_weather()` returns `True` if it is
    going to rain and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will let you figure out interfacing the solenoid valve using the GPIO pins.
    The earlier code sample is available for download along with this chapter as `lawn_sprinkler.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise for the reader:**'
  prefs: []
  type: TYPE_NORMAL
- en: We are making use of the next day's weather information to turn on the sprinkler.
    Go through the documentation and modify the code to account for current weather
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project enhancements:**'
  prefs: []
  type: TYPE_NORMAL
- en: How would you go about adding a moisture sensor to the controller?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you interface the sensor to the Raspberry Pi Zero and make use of
    it in turn on the sprinkler?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed four projects involving the Raspberry Pi Zero (and
    Python programming) that focused on specific improvements around the house. This
    includes a voice assistant, web framework-based appliance control, physical activity
    motivation tool, and a smart lawn sprinkler. The idea behind these projects were
    to demonstrate the applications of python programming in improving our quality
    of life. We could demonstrate that it is possible to build applications (using
    the Raspberry Pi Zero) that can serve as a better alternative to expensive off-the-shelf
    products.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also recommend the following project ideas for your consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slack channel-based appliance control**: Are you concerned about the temperature
    conditions back home for your pets while you are away at work? How about setting
    up a temperature sensor to send a slack channel alert suggesting that you turn
    on the air conditioner?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabletop fountain**: Using a Raspberry Pi Zero and an RGB LED strip, you
    can create lighting effects for a tabletop fountain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bird feeder monitor**: This is something we have been working on for a while
    now. We are trying to track birds that come to feed in a backyard feeder. The
    bird feeder is equipped with a Raspberry Pi Zero and a camera. Stay tuned to this
    book''s website for some updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Holiday lights controller**: How about some special light and audio effects
    during the holidays?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controlling off-the-shelf products using Raspberry Pi Zero**: Do you have
    a lot of Wi-Fi-enabled electrical outlets lying around unused? Why not try to
    control them using your Raspberry Pi Zero (hint: *IFTTT*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pomodoro timer**: Have you heard of the Pomodoro technique for productivity?
    How about an interactive device to improve your productivity?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Resources
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting USB Soundcard as the default audio source**: [http://raspberrypi.stackexchange.com/a/44825/1470](http://raspberrypi.stackexchange.com/a/44825/1470)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arecord/aplay options**: [http://quicktoots.linux-audio.com/toots/quick-toot-arecord_and_rtmix-1.html](http://quicktoots.linux-audio.com/toots/quick-toot-arecord_and_rtmix-1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAX9814 setup tutorial**: [https://learn.adafruit.com/adafruit-agc-electret-microphone-amplifier-max9814/wiring-and-test](https://learn.adafruit.com/adafruit-agc-electret-microphone-amplifier-max9814/wiring-and-test)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding optocouplers**: [https://www.elprocus.com/opto-couplers-types-applications/](https://www.elprocus.com/opto-couplers-types-applications/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relays and kickback voltages**: [http://www.coilgun.info/theoryinductors/inductivekickback.htm](http://www.coilgun.info/theoryinductors/inductivekickback.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
