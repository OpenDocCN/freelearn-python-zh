- en: C Performance with Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is a language that extends Python by supporting the declaration of types
    for functions, variables, and classes. These typed declarations enable Cython
    to compile Python scripts to efficient C code. Cython can also act as a bridge
    between Python and C as it provides easy-to-use constructs to write interfaces
    to external C and C++ routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Cython syntax basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compile Cython programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use **static typing** to generate fast code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to efficiently manipulate arrays using typed **memoryviews**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing a sample particle simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips on using Cython in the Jupyter notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profiling tools available for Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a minimum knowledge of C is helpful, this chapter focuses only on Cython
    in the context of Python optimization. Therefore, it doesn't require any C background.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Cython extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cython syntax is, by design, a superset of Python. Cython can compile, with
    a few exceptions, most Python modules without requiring any change. Cython source
    files have the `.pyx` extension and can be compiled to produce a C file using
    the `cython` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first Cython script will contain a simple function that prints `Hello,
    World!` as the output. Create a new `hello.pyx` file containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cython` command will read `hello.pyx` and generate the `hello.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `hello.c` to a Python extension module, we will use the GCC compiler.
    We need to add some Python-specific compilation options that depend on the operating
    system. It''s important to specify the directory that contains the header files;
    in the following example, the directory is `/usr/include/python3.5/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To find your Python include directory, you can use the `distutils` utility: 
    `sysconfig.get_python_inc`. To execute it, you can simply issue the following `python
    -c "from distutils import sysconfig; print(sysconfig.get_python_inc())"` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will produce a file called `hello.so`, a C extension module that is directly
    importable into a Python session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Cython accepts both Python 2 and Python 3 as input and output languages. In
    other words, you can compile a Python 3 script `hello.pyx` file using the `-3`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated `hello.c` can be compiled without any changes to Python 2 and
    Python 3 by including the corresponding headers with the `-I` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A Cython program can be compiled in a more straightforward way using `distutils`,
    the standard Python packaging tool. By writing a `setup.py` script, we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example,
    we can write a minimal `setup.py` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first two lines of the preceding code, we import the `setup` function
    and the `cythonize` helper. The `setup` function contains a few key-value pairs
    that specify the name of the application and the extensions that need to be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile our extension module using `distutils`, you can execute the `setup.py`
    script using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, while the `--inplace` option tells the script to place the `hello.so`
    output file in the same location as the source file (instead of a build directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython modules can also be automatically compiled using `pyximport`. All that''s
    needed is a call to `pyximport.install()` at the beginning of your script (or
    you need to issue the command in your interpreter). After doing that, you can
    import `.pyx` files directly and `pyximport` will transparently compile the corresponding
    Cython modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example, when they involve a combination of C and Cython files), but it comes
    handy for testing simple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the extension is loaded, you can use the `%%cython` *cell magic* to write
    a multiline Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the IPython session namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding static types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a variable can be associated to objects of different types during
    the execution of the program. While this feature is desirable as it makes the
    language flexible and dynamic, it also adds a significant overhead to the interpreter
    as it needs to look up type and methods of the variables at runtime, making it
    difficult to perform various optimizations. Cython extends the Python language
    with explicit type declarations so that it can generate efficient C extensions
    through compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The main way to declare data types in Cython is through `cdef` statements. The
    `cdef` keyword can be used in multiple contexts, such as variables, functions,
    and extension types (statically-typed classes).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Cython, you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the `i` variable
    as a 16 bit integer in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cdef` statement supports multiple variable names on the same line along
    with optional initialization, as seen in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Typed variables are treated differently in comparison to regular variables.
    In Python, variables are often described as *labels* that refer to objects in
    memory. For example, we could assign the value `''hello''` to the `a` variable
    at any point in the program without restriction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a` variable holds a reference to the `''hello''` string. We can also freely
    assign another value (for example, the integer `1`) to the same variable later
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Python will assign the integer `1` to the `a` variable without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed variables behave quite differently and are usually described as *data
    containers:* we can only store values that fit into the container that is determined
    by its data type. For example, if we declare the `a` variable as `int`, and then
    we try to assign it to a `double`, Cython will trigger an error, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Static typing makes it easy for the compiler to perform useful optimizations.
    For example, if we declare a loop index as `int`, Cython will rewrite the loop
    in pure C without needing to step into the Python interpreter. The typing declaration
    guarantees that the type of the index will always be `int` and cannot be overwritten
    at runtime so that the compiler is free to perform the optimizations without compromising
    the program correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assess the speed gain in this case with a small test case. In the following
    example, we implement a simple loop that increments a variable 100 times. With
    Cython, the `example` function can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare the speed of an analogous, untyped, pure Python loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The speedup obtained by implementing this simple type declaration is a whopping
    100x! This works because the Cython loop has first been converted to pure C and
    then to efficient machine code, while the Python loop still relies on the slow
    interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: In Cython, it is possible to declare a variable to be of any standard C type,
    and it is also possible to define custom types using classic C constructs, such
    as `struct`, `enum`, and `typedef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting example is that if we declare a variable to be of the `object`
    type, the variable will accept any kind of Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that declaring a variable as `object` has no performance benefits as accessing
    and operating on the object will still require the interpreter to look up the
    underlying type of the variable and its attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, certain data types (such as `float` and `int` numbers) are compatible
    in the sense that they can be converted into each other. In Cython, it is possible
    to convert (*cast*) between types by surrounding the destination type between
    pointy brackets, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of each of the argument names. Functions specified in this way
    will work and perform like regular Python functions, but their arguments will
    be type-checked. We can write a `max_python` function, which returns the greater
    value between two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A function specified in this way will perform type-checking and treat the arguments
    as typed variables, just like in `cdef` definitions. However, the function will
    still be a Python function, and calling it multiple times will still need to switch
    back to the interpreter. To allow Cython for function call optimizations, we should
    declare the type of the return type using a `cdef` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Functions declared in this way are translated to native C functions and have
    much less overhead compared to Python functions. A substantial drawback is that
    they can't be used from Python, but only from Cython, and their scope is restricted
    to the same Cython file unless they're exposed in a definition file (refer to
    the *Sharing declarations* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Cython allows you to define functions that are both callable from
    Python and translatable to performant C functions. If you declare a function with
    a `cpdef` statement, Cython will generate two versions of the function: a Python
    version available to the interpreter, and a fast C function usable from Cython.
    The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be replaced by the function
    body itself. Our `max` function is a good candidate for *inlining*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define an extension type using the `cdef class` statement and declaring
    its attributes in the class body. For example, we can create an extension type--`Point`--as
    shown in the following code, which stores two coordinates (*x*, *y*) of the `double` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the declared attributes in the class methods allows Cython to bypass
    expensive Python attribute look-ups by direct access to the given fields in the
    underlying C `struct`. For this reason, attribute access in typed classes is an
    extremely fast operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `cdef class` in your code, you need to explicitly declare the type
    of the variables you intend to use at compile time. You can use the extension
    type name (such as `Point`) in any context where you will use a standard type
    (such as `double`, `float`, and `int`). For example, if we want a Cython function
    that calculates the distance from the origin (in the example, the function is
    called `norm`) of a `Point`, we have to declare the input variable as `Point`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like typed functions, typed classes have some limitations. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access attributes from Python code, you have to use the `public`
    (for read/write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, methods can be declared with the `cpdef` statement, just like
    regular functions.
  prefs: []
  type: TYPE_NORMAL
- en: Extension types do not support the addition of extra attributes at runtime.
    In order to do that, a solution is defining a Python class that is a subclass
    of the typed class and extends its attributes and methods in pure Python.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing your Cython modules, you may want to reorganize your most used
    functions and classes declaration in a separate file so that they can be reused
    in different modules. Cython allows you to put these components in a *definition
    file* and access them with `cimport` statements*.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we have a module with the `max` and `min` functions, and we want
    to reuse those functions in multiple Cython programs. If we simply write a bunch
    of functions in a `.pyx` file, the declarations will be confined to the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Definition files are also used to interface Cython with external C code. The
    idea is to copy (or, more accurately, translate) the types and function prototypes
    in the definition file and leave the implementation in the external C code that
    will be compiled and linked in a separate step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To share the `max` and `min` functions, we need to write a definition file
    with a `.pxd` extension. Such a file only contains the types and function prototypes
    that we want to share with other modules--a *public* interface. We can declare
    the prototypes of our `max` and `min` functions in a file named `mathlib.pxd`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we only write the function name and arguments without implementing
    the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function implementation goes into the implementation file with the same
    base name but the `.pyx` extension--`mathlib.pyx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `mathlib` module is now importable from another Cython module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our new Cython module, we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code. The Chebyshev distance between
    two coordinates--`(x1, y1)` and `(x2, y2)`--is defined as the maximum value of
    the difference between each coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `chebyshev` function, we will use the `max` function declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `cimport` statement will read `hello.pxd` and the `max` definition will
    be used to generate the `distance.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numerical and high performance calculations often make use of arrays. Cython
    provides an easy way to interact with them, using directly low-level C arrays,
    or the more general *typed memoryviews*.
  prefs: []
  type: TYPE_NORMAL
- en: C arrays and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C arrays are a collection of items of the same type, stored contiguously in
    memory. Before digging into the details, it is helpful to understand (or review)
    how memory is managed in C.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64 bit floating point number (`double`), the program will allocate 64 bit (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the address of a variable, we can use the *address operator* denoted
    by the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Memory addresses can be stored in special variables, *pointers*, that can be
    declared by putting a `*` prefix in front of the variable name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a pointer, and we want to grab the value contained in the address
    it''s pointing at, we can use the *dereference operator* denoted by the `*` symbol.
    Be careful, the `*` used in this context has a different meaning from the `*`
    used in the variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring a C array, the program allocates enough space to accommodate
    all the elements requested. For instance, to create an array that has 10 `double`
    values (16 bytes each), the program will reserve *16 * 10 = 160* bytes of contiguous
    space in memory. In Cython, we can declare such arrays using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare a multidimensional array, such as an array with `5` rows
    and `2` columns, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is depicted in the following
    figure. Arrays can also be ordered *column-major*, as is the case for the FORTRAN
    programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example, 0, 1, 2, 3
    ...) while when we iterate on the first dimension, we skip a few positions (0,
    2, 4, 6, 8, 1 ... ). You should always try to access memory sequentially as this
    optimizes cache and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store and retrieve elements from the array using standard indexing;
    C arrays don''t support fancy indexing or slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'C arrays have many of the same behaviors as pointers. The `arr` variable, in
    fact, points to the memory location of the first element of the array. We can
    verify that the address of the first element of the array is the same as the address
    contained in the `arr` variable using the dereference operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You should use C arrays and pointers when interfacing with the existing C libraries
    or when you need a fine control over the memory (also, they are very performant).
    This level of fine control is also prone to mistakes as it doesn't prevent you
    from accessing the wrong memory locations. For more common use cases and improved
    safety, you can use NumPy arrays or typed memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy arrays can be used as normal Python objects in Cython using their already
    optimized broadcasted operations. However, Cython provides a `numpy` module with
    better support for direct iteration.
  prefs: []
  type: TYPE_NORMAL
- en: When we normally access an element of a NumPy array, a few other operations
    take place at the interpreter level causing a major overhead. Cython can bypass
    those operations and checks by acting directly on the underlying memory area used
    by NumPy arrays, and thus obtaining impressive performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays can be declared as the `ndarray` data type. To use the data type
    in our code, we first need to `cimport` the `numpy` Cython module (which is not
    the same as the Python NumPy module). We will bind the module to the `c_np` variable
    to make the difference with the Python `numpy` module more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now declare a NumPy array by specifying its type and the number of dimensions
    between square brackets (this is called *buffer syntax*). To declare a two-dimensional
    array of type `double`, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Access to this array will be performed by directly operating on the underlying
    memory area; the operation will avoid stepping into the interpreter, giving us
    a tremendous speed boost.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will show the usage of typed numpy arrays and compare
    them with the normal Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first write the `numpy_bench_py` function that increments each element of
    `py_arr`. We declare the `i` index as an integer so that we avoid the for-loop
    overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we write the same function using the `ndarray` type. Note that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the results using `timeit`, and we can see how the typed version
    is 50x faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Typed memoryviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and NumPy arrays as well as the built-in `bytes`, `bytearray`, and `array.array`
    objects are similar in the sense that they all operate on a contiguous memory
    area (also called memory *buffer*). Cython provides a universal interface--the
    *typed memoryview--*that unifies and simplifies the access to all these data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **memoryview** is an object that maintains a reference on a specific memory
    area. It doesn''t actually own the memory, but it can read and change its contents;
    in other words, it is a *view* on the underlying data. Memoryviews can be defined
    using a special syntax. For example, we can define a memoryview of `int` and a
     two-dimensional memoryview of `double` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The same syntax applies to the declaration of any type in variables, function
    definitions, class attributes, and so on. Any object that exposes a buffer interface
    (for example, NumPy arrays, `bytes`, and `array.array` objects) will be bound
    to the memoryview automatically. For example, we can bind the memoryview to a
    NumPy array using a simple variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the memoryview does not *own* the data, but it
    only provides a way to *access* and *change* the data it is bound to; the ownership,
    in this case, is left to the NumPy array. As you can see in the following example,
    changes made through the memoryview will act on the underlying memory area and
    will be reflected in the original NumPy structure (and vice versa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In a certain sense, the mechanism behind memoryviews is similar to what NumPy
    produces when we slice an array. As we have seen in [Chapter 3](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml),
    *Fast Array Operations with NumPy and Pandas*, slicing a NumPy array does not
    copy the data but returns a view on the same memory area, and changes to the view
    will reflect on the original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoryviews also support array slicing with the standard NumPy syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy data between one memoryview and another, you can use syntax similar
    to slice assignment, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will use the typed memoryviews to declare types for the
    arrays in our particle simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Particle simulator in Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how Cython works, we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml), *Fast Array Operations
    with NumPy and Pandas*, we wrote a fairly efficient version of the `evolve` method
    using NumPy. We can rename the old version as `evolve_numpy` to differentiate
    it from the new version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx`. The module will contain
    a single Python function, `c_evolve`, that will take the particle positions, angular
    velocities, timestep, and number of steps as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we are not adding typing information; we just want to isolate the
    function and ensure that we can compile our module without errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we don''t need a return value for `c_evolve` as values are updated
    in the `r_i` array in-place. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our benchmark function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the different versions in an IPython shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start adding types to the function arguments and see how the performance
    changes. We can declare the arrays as typed memoryviews containing `double` values.
    It''s worth mentioning that if we pass an array of the `int` or `float32` type,
    the casting won''t happen automatically and we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can rewrite the loops over the particles and timesteps. We
    can declare the `i` and `j` iteration indices and the `nparticles` particle number
    as `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm is very similar to the pure Python version; we iterate over the
    particles and timesteps, and we compute the velocity and displacement vectors
    for each particle coordinate using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the `x`, `y`, `ang_speed`, `norm`, `vx`, `vy`,
    `dx`, and `dy` variables. To avoid the Python interpreter overhead, we have to
    declare them with their corresponding types at the beginning of the function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` present in the `math` module or the one in `numpy`, we will again include
    a slow Python function in our critical loop, thus killing our performance. A fast
    `sqrt` is available in the standard C library, already wrapped in the `libc.math`
    Cython module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rerun our benchmark to assess our improvements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For small particle numbers, the speed-up is massive as we obtained a 40x performance
    over the previous version. However, we should also try to test the performance
    scaling with a larger number of particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to 1000, we already decreased our speed-up to
    a more modest 6x. This is likely due to the fact that, as we increase the number
    of particles, the Python for-loop overhead becomes less and less significant compared
    to the speed of other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cython provides a feature, called *annotated view*, that helps find which lines
    are executed in the Python interpreter and which are good candidates for ulterior
    optimizations. We can turn this feature on by compiling a Cython file with the
    `-a` option. In this way, Cython will generate an HTML file containing our code
    annotated with some useful information. The usage of the `-a` option is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file displayed in the following screenshot shows our Cython file line
    by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screenshot-from-2017-02-01-19-11-43.png)'
  prefs: []
  type: TYPE_IMG
- en: Each line in the source code can appear in different shades of yellow. A more
    intense color corresponds to more interpreter-related calls, while white lines
    are translated to regular C code. Since interpreter calls substantially slow down
    execution, the objective is to make the function body as white as possible. By
    clicking on any of the lines, we can inspect the code generated by the Cython
    compiler. For example, the `v_y = x/norm` line checks that the norm is not `0` and
    raises a `ZeroDivisionError` if the condition is not verified. The `x = r_i[j,
    0]` line shows that Cython checks whether the indexes are within the bounds of
    the array. You may note that the last line is of a very intense color; by inspecting
    the code, we can see that this is actually a glitch; the code refers to a boilerplate
    related to the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython can shut down checks, such as division by zero, so that it can remove
    those extra interpreter related calls; this is usually accomplished through compiler
    directives. There are a few different ways to add compiler directives:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a decorator or a context manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a comment at the beginning of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Cython command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the Cython compiler directives, you can refer to the
    official documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to disable bounds checking for arrays, it is sufficient to decorate
    a function with `cython.boundscheck`, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `cython.boundscheck` to wrap a block of code into
    a context manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to disable bounds checking for a whole module, we can add the following
    line of code at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To alter the directives with the command-line options, you can use the `-X` option
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the extra checks in our `c_evolve` function, we can disable the
    `boundscheck` directive and enable `cdivision` (this prevents checks for `ZeroDivisionError`),
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the annotated view again, the loop body has become completely
    white--we removed all traces of the interpreter from the inner loop. In order
    to recompile, just type `python setup.py build_ext --inplace` again. By running
    the benchmark, however, we note that we didn''t obtain a performance improvement,
    suggesting that those checks are not part of the bottleneck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to profile Cython code is through the use of the `cProfile` module. As
    an example, we can write a simple function that calculates the Chebyshev distance
    between coordinate arrays. Create a `cheb.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to collect profiling information for
    the `max` and `min` functions, we need to add the `profile=True` option to the
    `mathlib.pyx` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. Most of the time seems to be spent in the `benchmark` function, meaning
    that the bottleneck is likely the pure Python for-loop. In this case, the best
    strategy will be rewriting the loop in NumPy or porting the code to Cython.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cython with Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Cython code requires substantial trial and error. Fortunately, Cython
    tools can be conveniently accessed through the Jupyter notebook for a more streamlined
    and integrated experience.
  prefs: []
  type: TYPE_NORMAL
- en: You can launch a notebook session by typing `jupyter notebook` in the command
    line and you can load the Cython magic by typing `%load_ext cython` in a cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned earlier, the `%%cython` magic can be used to compile and
    load the Cython code inside the current session. As an example, we may copy the
    contents of `cheb.py` into a notebook cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful feature of the `%%cython` magic is the `-a` option that will compile
    the code and produce an annotated view (just like the command line `-a` option)
    of the source directly in the notebook, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screenshot-from-2017-02-02-18-49-37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This allows you to quickly test different versions of your code and also use
    the other integrated tools available in Jupyter. For example, we can time and
    profile the code (provided that we activate the profile directive in the cell)
    in the same session using tools such as `%prun` and `%timeit`. For example, we
    can inspect the profiling results by taking advantage of the `%prun` magic, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screenshot-from-2017-02-02-18-56-35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to use the `line_profiler` tool we discussed in [Chapter
    1](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml), *Benchmarking and Profiling*,
    directly in the notebook. In order to support line annotations, it is necessary
    to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the `linetrace=True` and `binding=True` compiler directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the `CYTHON_TRACE=1` flag at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be easily accomplished by adding the respective arguments to the `%%cython`
    magic, and by setting the compiler directives, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code is instrumented, we can profile using the `%lprun` magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a good chunk of time is actually spent in line 16, which is
    a pure Python loop and a good candidate for further optimization.
  prefs: []
  type: TYPE_NORMAL
- en: The tools available in Jupyter notebook allow for a fast edit-compile-test cycle
    so that you can quickly prototype and save time when testing different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is a tool that bridges the convenience of Python with the speed of C.
    Compared to C bindings, Cython programs are much easier to maintain and debug,
    thanks to the tight integration and compatibility with Python and the availability
    of excellent tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types to our variables and functions.
    We also learned how to work with C arrays, NumPy arrays, and memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to spot hard-to-find interpreter related calls and how to enable `cProfile` support
    in Cython. Also, we learned how to take advantage of the Jupyter notebook for
    integrated profiling and analysis of Cython codes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore other tools that can generate fast machine
    code on the fly, without requiring compilation of our code to C ahead of time.
  prefs: []
  type: TYPE_NORMAL
