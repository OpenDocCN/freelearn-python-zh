<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-97"><a id="_idTextAnchor100"/>5</h1>
<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Designing Graphical Interfaces</h1>
<p>Many tools add their own elements to the graphical interface. In the previous chapters, we used existing menus, but we can also add new panels to the Blender window.</p>
<p>To design an interface, we must decide which elements to show and how to reach them, what information should be provided, and which actions should be allowed.</p>
<p>In this chapter, you will learn how to insert new panels into different regions of Blender, how to display information and icons, and how to add buttons that can invoke operators.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Understanding the Blender interface</li>
<li>Drawing a custom panel</li>
<li>Context and UI interaction</li>
</ul>
<h1 id="_idParaDest-99"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5</a>.</p>
<p>The example files include 2D images to be used as icons. Optionally, any 2D software can be used to create custom <code>.png</code> images, and you can use them instead.</p>
<p>To implement our interface, we will have to learn how Blender is structured. Let’s begin our journey into graphical interfaces with a deep dive into the Blender screen.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor103"/>Areas, regions, and panels</h1>
<p>The Blender <a id="_idIndexMarker299"/>window is split into <strong class="bold">areas</strong>. Each area can contain an <strong class="bold">editor</strong> of a different type, such as the <em class="italic">viewport</em> for 3D objects or the <em class="italic">sequencer</em> for editing videos. Each editor, or space, can contain <a id="_idIndexMarker300"/>one or more <strong class="bold">regions</strong>. The number and type of regions vary across different types of editors: for instance, some editors, such as the <strong class="bold">Preferences</strong> window, have a navigation sidebar, while others don’t.</p>
<p>The Blender manual explains the interface in detail: <a href="https://docs.blender.org/manual/en/3.1/interface/index.xhtml">https://docs.blender.org/manual/en/3.1/interface/index.xhtml</a>.</p>
<p>What we need to know for now is that <a id="_idIndexMarker301"/>regions can contain <strong class="bold">panels</strong>, and panels are the basic containers of graphical elements such as text, editable values, and buttons.</p>
<p>We can create new panels with Python, which makes it possible to customize any region with ease. A panel must contain information about the area and region to which it belongs:</p>
<div><div><img alt="Figure 5.1: Areas, regions, and the panel in the Blender interface" height="669" src="img/Figure_5.01_B18375.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Areas, regions, and the panel in the Blender interface</p>
<p>Internally, panels can access information about Blender and the scene so that they can display the status and properties of the objects and execute operators. Now that we are more familiar with the anatomy of the screen, we are going to create a panel that helps us deal with 3D objects.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Creating a simple panel</h1>
<p>We will start with a simple panel that contains some text and icons, and we will see how to expand this <a id="_idIndexMarker302"/>initial idea into a tool that can help manage the objects in the scene.</p>
<p>Our panel is a new class that derives from <code>bpy.types.Panel</code>. Like operators, panels require some static members to be set; otherwise, they will not work. Similar to operators, panels can have a <code>poll()</code> class method that states under which conditions the panel can be displayed.</p>
<p>Instead of using the <code>execute</code> function, panels set up and draw their content via the <code>draw(self, </code><code>context)</code> function.</p>
<p>Since we are adding a new piece to the Blender interface, we will do that inside a new add-on. It’s not mandatory, but it makes it easier to enable and disable our panel.</p>
<p>To keep our code orderly and clean, we will create a new folder for the scripts written for this chapter.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Setting the environment</h2>
<p>Let’s create <a id="_idIndexMarker303"/>a folder for <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a> in our <code>ch5</code> folder as a <strong class="bold">Scripts Folder</strong> and restart Blender.</p>
<p>Our add-on script contains a panel, much like the ones in the previous chapters contained operators:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch5/addons</code> in <strong class="bold">Visual </strong><strong class="bold">Studio Code</strong>.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>simple_panel.py</code>.</li>
<li>Open the file by double-clicking on it.</li>
</ol>
<p>We can now start writing the add-on for our panel.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Drafting our panel add-on</h2>
<p>As we <a id="_idIndexMarker304"/>know from <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, three elements are required:</p>
<ul>
<li>A <code>bl_info</code> dictionary containing basic information</li>
<li>An <code>import bpy</code> statement to access the Blender API</li>
<li>The <code>register()</code> and <code>unregister()</code> methods for enabling/disabling add-ons, respectively</li>
</ul>
<p>We also need a class for the graphical element that we want to add – in this case, a class that derives from <code>bpy.types.Panel</code>.</p>
<p>We will start with the information dictionary and add the stubs for the required elements to set a frame on which we can code a fully working UI add-on.</p>
<h3>Writing the info dictionary</h3>
<p>The <code>bl_info</code> dictionary <a id="_idIndexMarker305"/>will provide the <code>name</code> property of the add-on, its <code>author</code> and <code>version</code>, and the required <code>blender</code> version, plus a short <code>description</code>. We can also add a <code>category</code> under which the add-on is listed. Here’s what the code will look like:</p>
<pre class="source-code">
bl_info = {
    "name": "A Very Simple Panel",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 2, 0),
    "description": "Just show up a panel in the UI",
    "category": "Learning",
}</pre>
<p>Now, we can proceed with the required <code>import</code> statements and the main <code>class</code>.</p>
<h3>Drafting the Panel class</h3>
<p>Now that <a id="_idIndexMarker306"/>we’ve imported the <code>bpy</code> module, we can write a class based on <code>bpy.types.Panel</code>.</p>
<p>We can use any name for our class, but Blender recommends some guidelines:</p>
<ul>
<li>Since our panel will be part of the object properties, the class name must begin with <code>OBJECT</code></li>
<li>The name contains <code>_PT_</code> in the middle since this is a <code>Panel Type</code></li>
</ul>
<p>For now, our class will only contain a <em class="italic">docstring</em> and a <code>pass</code> statement:</p>
<pre class="source-code">
import bpy
class <strong class="bold">OBJECT_PT</strong>_very_simple(<strong class="bold">bpy.types.Panel</strong>):
    """Creates a Panel in the object context of the
    properties editor"""
    # still a draft: actual code will be added later
    pass</pre>
<p>Before adding methods and attributes, we will handle the class activation and dismissal through the registration functions.</p>
<h3>Panel registration</h3>
<p>The <code>register</code> and <code>unregister</code> functions add and remove this class to/from Blender <a id="_idIndexMarker307"/>when the add-on is enabled and disabled, respectively:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(OBJECT_PT_very_simple)
def unregister():
    bpy.utils.unregister_class(OBJECT_PT_very_simple)</pre>
<p>With that, we have created the initial structure of our panel add-on. We will now add the elements and attributes for displaying some text.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Setting display attributes</h2>
<p>Blender looks <a id="_idIndexMarker308"/>for attributes that follow the <code>bl_*</code> pattern to determine where and how the panel is displayed. Panels have the same identification attributes as operators, as we saw in <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, when we introduced the <code>Operator</code> class:</p>
<ul>
<li><code>bl_label</code>: The display name of the panel</li>
<li><code>bl_idname</code>: The unique name of the panel for internal usage</li>
</ul>
<p>Then, there are attributes used only on classes that derive from <code>bpy.types.Panels</code>:</p>
<ul>
<li><code>bl_space_type</code>: The editor to which the panel belongs</li>
<li><code>bl_region_type</code>: The region of the editor to use</li>
<li><code>bl_context</code>: The sub-region for specific objects/modes</li>
<li><code>bl_category</code>: The tab inside the region, when available</li>
</ul>
<p>All of them are static strings, and <code>bl_space_type</code>, <code>bl_region_type</code>, and <code>bl_context</code> must match specific values known to Blender as regions of the screen.</p>
<p>The possible values encompass all the available editors in Blender. That might seem overwhelming at first, but once we have an idea of where to place our panel, we can look that up in the online documentation at <a href="https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml">https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml</a>.</p>
<p>Since Blender contains many editors and each of them has its own sub-elements, we will have a look at the possible combinations.</p>
<h3>Choosing our editor view via bl_space_type</h3>
<p>First, we <a id="_idIndexMarker309"/>must decide which Blender editor we are adding our panel to. That depends mainly on the purpose of our tool and where it will be more convenient to find it. For instance, if our panel helps make videos, it will be part of the <code>bl_space_type</code>:</p>
<ul>
<li><code>EMPTY</code>: This value is not used in scripts</li>
<li><code>VIEW_3D</code>: <strong class="bold">3D Viewport</strong> for manipulating <em class="italic">objects</em></li>
<li><code>IMAGE_EDITOR</code>: <strong class="bold">UV/Image Editor</strong> to view and edit <em class="italic">images</em> and UV Maps</li>
<li><code>NODE_EDITOR</code>: <strong class="bold">Node Editor</strong> for node-based <em class="italic">shading</em> and <em class="italic">compositing</em> tools</li>
<li><code>SEQUENCE_EDITOR</code>: <strong class="bold">Video Sequencer</strong> <em class="italic">editing</em> tools</li>
<li><code>CLIP_EDITOR</code>: <strong class="bold">Movie Clip Editor</strong> for <em class="italic">motion tracking</em></li>
<li><code>DOPESHEET_EDITOR</code>: <strong class="bold">Dope Sheet</strong> for adjusting the timing of <em class="italic">keyframes</em></li>
<li><code>GRAPH_EDITOR</code>: <strong class="bold">Graph Editor</strong> for drivers and keyframe <em class="italic">interpolation</em></li>
<li><code>NLA_EDITOR</code>: <strong class="bold">Nonlinear Animation</strong> to combine and layer <em class="italic">actions</em></li>
<li><code>TEXT_EDITOR</code> <strong class="bold">Text Editor</strong> to edit <em class="italic">scripts</em> and in-file <em class="italic">documentation</em></li>
<li><code>CONSOLE</code>: <strong class="bold">Python Console</strong> for interactive script <em class="italic">development</em></li>
<li><code>INFO</code>: <strong class="bold">Info</strong> about operations, warnings, and error <em class="italic">messages</em></li>
<li><code>TOPBAR</code>: <strong class="bold">Topbar</strong> for global, <em class="italic">per-window settings</em></li>
<li><code>STATUSBAR</code>: <strong class="bold">Status Bar</strong> at the bottom of the screen for <em class="italic">general information</em></li>
<li><code>OUTLINER</code>: <strong class="bold">Outliner</strong> overview of the <em class="italic">scene tree</em> and data blocks</li>
<li><code>PROPERTIES</code>: <strong class="bold">Properties</strong> to edit the <em class="italic">attributes</em> of active objects and data blocks</li>
<li><code>FILE_BROWSER</code>: <strong class="bold">File Browser</strong> to scroll through <em class="italic">files </em><em class="italic">and assets</em></li>
<li><code>SPREADSHEET</code>: <strong class="bold">Spreadsheet</strong> to explore <em class="italic">geometry data</em> in a table</li>
<li><code>PREFERENCES</code>: <strong class="bold">Preferences</strong> to edit persistent <em class="italic">configuration</em> settings</li>
</ul>
<p>Once we have decided on the space type, we are ready to pick a region for it.</p>
<h3>Selecting a region via bl_region_type</h3>
<p>The kind <a id="_idIndexMarker311"/>of region depends on the <em class="italic">space</em> we chose in the previous step. Different editors have different regions. So, only the default value is always available. Here is a description of all the options for <code>bl_region_type</code>:</p>
<ul>
<li><code>WINDOW</code>: The <em class="italic">main</em> region of a space area. This is the default value.</li>
<li><code>HEADER</code>: A small horizontal strip for <em class="italic">menus</em> and buttons.</li>
<li><code>CHANNELS</code>: Used in older versions of Blender, left for backward compatibility.</li>
<li><code>TEMPORARY</code>: <em class="italic">Poupps</em> detached from the main window.</li>
<li><code>UI</code>: Sidebar containing object settings (toggled with <em class="italic">N</em>).</li>
<li><code>TOOLS</code>: A toolbar containing a set of interactive tools (toggled with <em class="italic">T</em>).</li>
<li><code>TOOL_PROPS</code>: Settings in <em class="italic">modal windows</em>, such as <strong class="bold">File Browser</strong>.</li>
<li><code>PREVIEW</code>: The preview area of the <strong class="bold">Video Sequencer</strong>.</li>
<li><code>HUD</code>: The operator’s <strong class="bold">Redo</strong> panel.</li>
<li><code>NAVIGATION_BAR</code>: <em class="italic">Sidebar</em> in the <strong class="bold">Preferences</strong> window.</li>
<li><code>EXECUTE</code>: <em class="italic">Bottom bar</em> in modal windows.</li>
<li><code>FOOTER</code>: A bar for displaying <em class="italic">information</em> about the current operation.</li>
<li><code>TOOL_HEADER</code>: A small horizontal strip for <em class="italic">tool settings</em>.</li>
<li><code>XR</code>: The interface for <em class="italic">virtual </em><em class="italic">reality</em> controllers.</li>
</ul>
<h3>Picking a context via bl_context</h3>
<p>Some areas <a id="_idIndexMarker312"/>change according to the current selection, active tool, or interaction mode. In that case, the <code>bl_context</code> attribute is required.</p>
<p>For instance, the <code>'SCENE'</code>, <code>'OBJECT'</code>, and <code>'CONSTRAINTS'</code>. If we are not sure about which one to use, we can just activate the tab we are interested in and check the <code>bpy.context.space_data.context = </code><code>NAME_OF_CONTEXT</code>:</p>
<div><div><img alt="Figure 5.2: UI context name in the Info Log area, after Object Properties have been selected" height="928" src="img/Figure_5.02_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: UI context name in the Info Log area, after Object Properties have been selected</p>
<p>Areas that <a id="_idIndexMarker313"/>do not follow the user context but still allow you to group their panels in tabs offer a <em class="italic">category</em> attribute instead.</p>
<h4>Grouping in tabs using bl_category</h4>
<p>Regions with <a id="_idIndexMarker314"/>arbitrary tabs will look at the <code>bl_category</code> variable to look up the correct label. If no value is given, the new panel will be added to the <strong class="bold">Miscellaneous</strong> tab. If no tab is named after that value, a new one will be created.</p>
<p>We are going to use the category attribute at the end of this chapter in conjunc<a id="_idTextAnchor108"/>tion with the <code>'VIEW_3D'</code> space type. We are going to start with the <code>'PROPERTIES'</code> editor, which does not have tabs.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor109"/>Adding a panel to the Object Properties area</h2>
<p>To add <a id="_idIndexMarker315"/>our panel to the <code>bl_space_type</code> to <code>'PROPERTIES'</code> and <code>bl_context</code> to <code>'object'</code>.</p>
<p><code>Panel</code> needs a <code>draw</code> function <a id="_idIndexMarker316"/>where the actual design takes place. At this stage, we can leave it blank:</p>
<pre class="source-code">
import bpy
class OBJECT_PT_very_simple(bpy.types.Panel):
    """Creates a Panel in the object context of the
    properties space"""
    bl_label = "A Very Simple Panel"
    bl_idname = "VERYSIMPLE_PT_layout"
    bl_space_type = <strong class="bold">'PROPERTIES'</strong>
    bl_region_type = <strong class="bold">'WINDOW'</strong>
    bl_context = <strong class="bold">'object'</strong>
    def <strong class="bold">draw</strong>(self, context):
        # add layout elements
        pass</pre>
<p>Like most runtime functions of Blender classes, <code>draw</code> takes the <code>self</code> and <code>context</code> arguments. As per Python convention, <code>self</code> is the running instance of the class, while <code>context</code> contains information about the current state of the Blender scene.</p>
<p>Now, let’s learn how the <code>draw</code> method is used to add elements to the panel’s layout.</p>
<h3>Drawing the panel’s content</h3>
<p>The <code>draw</code> function is <a id="_idIndexMarker317"/>executed continuously whenever a panel is used or updated. For this reason, it should not perform any computationally expensive task and just take care of the elements to display.</p>
<p>The elements of a panel are arranged according to its layout. Since the layout is a non-static member, it can be accessed inside the <code>draw</code> function using <code>self.layout</code>.</p>
<p>By default, all elements are stacked vertically in a <code>column</code>, but different types of layouts will provide a different way to arrange the widgets in a <code>row</code> or inside a <code>grid</code>.</p>
<p>Layouts can be also nested together for more complex arrangements. Let’s learn how to access the main layout and add elements to it.</p>
<h3>Working with layouts</h3>
<p>All layout <a id="_idIndexMarker318"/>types derive from the <code>UILayout</code> class. They have methods to add child elements or sub-layouts. The full list of attributes and methods is reported in the API documentation at https://docs.blender.org/api/3.2/bpy.types.UILayout.xhtml.</p>
<p>So, to display text, we can use the <code>UILayout.label</code> method. Here are the first few lines of code for our <code>draw</code> function:</p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        <strong class="bold">layout.label(text="A Very Simple Label")</strong></pre>
<p>If we enable this add-on and reach for the <strong class="bold">Object Properties</strong> area, we will be able to see our new panel displaying some text:</p>
<div><div><img alt="Figure 5.3: Our panel showing up in the Object Properties area" height="456" src="img/Figure_5.03_B18375.jpg" width="333"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Our panel showing up in the Object Properties area</p>
<h3>Displaying icons</h3>
<p>Labels <a id="_idIndexMarker319"/>can display <strong class="bold">icons</strong> too. There are two types of icons:</p>
<ul>
<li><em class="italic">Built-in</em> icons that come with Blender. The <code>label</code> method provides an <code>icon</code> keyword to use them.</li>
<li><em class="italic">External Images</em> can be used via the <code>icon_value</code> parameter.</li>
</ul>
<p>Blender’s native set of icons is used across the application. Each icon is identified with a keyword. For instance, <code>LIGHT</code> displays a lightbulb:</p>
<div><div><img alt="Figure 5.4: Blender icon for the LIGHT keyword" height="32" src="img/Figure_5.04_B18375.jpg" width="120"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: Blender icon for the LIGHT keyword</p>
<p>There are more than 800 built-in icons, so Blender includes an add-on for searching through them.</p>
<h4>Looking for built-in icons with the Icon Viewer add-on</h4>
<p>The <code>icon</code> in the <strong class="bold">Search </strong><strong class="bold">Bar</strong> area:</p>
<div><div><img alt="Figure 5.5: Activating the Icon Viewer add-on" height="144" src="img/Figure_5.05_B18375.jpg" width="898"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: Activating the Icon Viewer add-on</p>
<p>Once the add-on has been enabled, the <strong class="bold">Icon Viewer</strong> button appears in the header of the <strong class="bold">Python </strong><strong class="bold">Console</strong> header:</p>
<div><div><img alt="Figure 5.6: The Icon Viewer button in the Python Console header" height="215" src="img/Figure_5.06_B18375.jpg" width="1073"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6: The Icon Viewer button in the Python Console header</p>
<p>Clicking this button opens a window that shows all native icons. We can select them by left-clicking:</p>
<div><div><img alt="Figure 5.7: The Icon Viewer add-on window" height="759" src="img/Figure_5.07_B18375.jpg" width="1066"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7: The Icon Viewer add-on window</p>
<p>Selecting an <a id="_idIndexMarker321"/>icon displays the associated keyword in the top-right corner. The keyword is also copied to the clipboard. For example, if we select the <em class="italic">question mark</em> icon, which is the first icon on the top left at the time of writing, the <code>QUESTION</code> keyword will be displayed, as shown in the following figure:</p>
<div><div><img alt="Figure 5.8: The QUESTION keyword is displayed in the top-right corner" height="795" src="img/Figure_5.08_B18375.jpg" width="1036"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8: The QUESTION keyword is displayed in the top-right corner</p>
<p>We can type a search key in the filter field in the top middle, which is marked with a magnifier icon.</p>
<p>For instance, we can type <code>“info”</code> to show the <code>'INFO'</code> icon only. Now that we know their keywords, we can display those icons in this way:</p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        layout.label(text="A Very Simple Label",
                     <strong class="bold">icon='INFO'</strong>)
        layout.label(text="Isn't it great?",
                     <strong class="bold">icon='QUESTION'</strong>)</pre>
<p>Label icons <a id="_idIndexMarker322"/>are displayed before the text and are a good way to make it stand out:</p>
<div><div><img alt="Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel" height="325" src="img/Figure_5.09_B18375.jpg" width="331"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel</p>
<p>Built-in icons are always available and don’t require external files to be distributed alongside our scripts. We can also use image files when needed. The <code>bpu.utils.previews</code> module can be used to load icons from image files and retrieve them using an index number.</p>
<h4>Using custom image icons</h4>
<p>In this <a id="_idIndexMarker323"/>example, we will add the icon of a smiling face to our panel. The image file is named <code>icon_smile_64.png</code> and can be found in this chapter’s Git folder.</p>
<p>Alternatively, any image stored in <code>.png</code> format alongside the add-on’s <code>.py</code> file will work. In that case, the image filename used in the script must be changed accordingly.</p>
<p>The resolution should not be too high: a 64-pixel-wide square picture is usually more than enough:</p>
<div><div><img alt="Figure 5.10: A 64x64 smiley face" height="91" src="img/Figure_5.10_B18375.jpg" width="91"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10: A 64x64 smiley face</p>
<p>To add custom icons to Blender, our script needs to import the following:</p>
<ul>
<li>The <code>os</code> Python module, to build the icon file path and make sure it will work on all platforms</li>
<li>The <code>bpy.utils.previews</code> Blender module, to generate a Blender identifier for our icon</li>
</ul>
<p>Here is what our <code>import</code> section will look like once we import them:</p>
<pre class="source-code">
import bpy
from bpy.utils import previews
import os</pre>
<p>Our icons <a id="_idIndexMarker324"/>must be accessible everywhere in the script. We can use a global variable, a static member, or a singleton for storage. In this example, we are using a global variable as it is the simpler option.</p>
<p>So, right after the <code>import</code> section, we must add the following lines:</p>
<pre class="source-code">
# global variable for icon storage
custom_icons = None</pre>
<p>We initialize the variable as <code>None</code> since we can load and clear it inside the <code>register</code>/<code>unregister</code> function. We can also add specific functions for that. This way, the code will be easier to follow:</p>
<pre class="source-code">
def load_custom_icons():
    """Load icon from the add-on folder"""
    Addon_path = os.path.dirname(__file__)
    img_file = os.path.join(addon_path,
               "icon_smile_64.png")
    global custom_icons
    custom_icons = previews.new()
    custom_icons.load("<strong class="bold">smile_face</strong>",img_file, 'IMAGE')</pre>
<p>Then, we need a function that clears <code>custom_icons</code> when the add-on is unregistered:</p>
<pre class="source-code">
def remove_custom_icons():
    """Clear Icons loaded from file"""
    global custom_icons
    bpy.utils.previews.remove(custom_icons)</pre>
<p>These functions <a id="_idIndexMarker325"/>are then invoked in the registration section:</p>
<pre class="source-code">
def register():
    load_custom_icons()
    bpy.utils.register_class(VerySimplePanel)
def unregister():
    bpy.utils.unregister_class(VerySimplePanel)
    clear_custom_icons()</pre>
<p>Once we read the image file, we used <code>"smile_face"</code> as the first argument of <code>custom_icons.load()</code>, so that is the keyword that will be used for retrieving its identifier. Here’s the code to use in a label:</p>
<pre class="source-code">
layout.label(text="Smile", icon_value=custom_icons['smile_face'].icon_id)</pre>
<p>If we look up and execute <strong class="bold">Reload Scripts</strong> from the <em class="italic">F3</em> search panel, we will see our custom icon in the panel:</p>
<div><div><img alt="Figure 5.11: Smiley icon loaded from our file and displayed in our panel" height="144" src="img/Figure_5.11_B18375.jpg" width="273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11: Smiley icon loaded from our file and displayed in our panel</p>
<p>For now, we have <a id="_idIndexMarker326"/>used the default column layout. We will learn how to use a different arrangement in the next section.</p>
<p class="callout-heading">Where have my widgets gone?</p>
<p class="callout">Errors in the interface code fail “silently"; that is, Blender doesn’t complain visibly and instead just stops drawing the buggy panel.</p>
<p class="callout">This prevents the UI from crashing but makes our code more difficult to debug; we will only notice that some of our widgets are not displayed.</p>
<p class="callout">When that happens, the best thing to do is check the console output or the <strong class="bold">Info Log</strong> area in the <strong class="bold">Scripting</strong> workspace. It will contain <em class="italic">traceback</em> information about which line of code is failing.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor110"/>Using layouts in our panels</h1>
<p>If we are not happy with the default stacking of the global layout, we can add a layout type of our <a id="_idIndexMarker327"/>choice to it and use that instead, and we’ll get a different arrangement.</p>
<p>For instance, we can put two labels on the same line using a <code>row</code>. Also, even if we are happy with stacking our elements one under the other, it is good practice to create a <code>column</code> sub-layout anyway. This practice has at least two advantages:</p>
<ul>
<li>We preserve the panel's look, even if the default arrangement should change</li>
<li>We do not pollute the original layout</li>
</ul>
<p>Let’s see how we can change the way our widgets are stacked.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor111"/>Arranging in columns and rows</h2>
<p>We can nest more layout types together inside our <code>draw</code> function. For instance, we can place the <a id="_idIndexMarker328"/>last two labels from the previous example side by side rather than arrange them vertically. To do that, we must do two things:</p>
<ol>
<li>First, we must create a <code>column</code> and add the first label to it.</li>
<li>Then, we must create a <code>row</code>. The two labels we will add to it will be next to each other:</li>
</ol>
<pre class="source-code">
    def draw(self, context):
        col = self.layout.column()
        col.label(text="A Very Simple Label",
                  icon='INFO')
        row = col.row()
        row.label(text="Isn't it great?",
                  icon='QUESTION')
        icon_id = custom_icons["smile_face"].icon_id
        row.label(text="Smile", icon_value=icon_id)</pre>
<p>Now, our panel consists of only two lines:</p>
<div><div><img alt="Figure 5.12: The second line consists of two labels" height="105" src="img/Figure_5.12_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12: The second line consists of two labels</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor112"/>Adding frames with box layouts</h2>
<p>Other types of sub-layouts provide additional effects. For instance, a box layout is like a column, but it <a id="_idIndexMarker329"/>is framed in a smoothed rectangle. Let’s say we want to display some information from the add-on’s <code>bl_info</code>. Here, we can add these lines to the <code>draw</code> function:</p>
<pre class="source-code">
        box = col.box()
        row = box.row()
        row.label(text="version:")
        row.label(text=str(bl_info['version']))</pre>
<p>After we call <strong class="bold">Reload Scripts</strong>, we will see a frame around that information:</p>
<div><div><img alt="Figure 5.13: A box layout surrounds the version information" height="151" src="img/Figure_5.13_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13: A box layout surrounds the version information</p>
<p>We have put a caption of <code>"version"</code> and some information stating <code>bl_info['version']</code> in a row. That gives the same space to each element. To have more control over how much space is taken by the first element, we can use a <code>split</code> layout.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Using composite layouts</h2>
<p>Some layouts <a id="_idIndexMarker330"/>consist of more rows or columns. A <code>split</code> layout distributes <a id="_idIndexMarker331"/>the available space across different columns, while a <code>grid</code> layout creates rows and columns automatically.</p>
<p>We are going to use them to build a more sophisticated panel.</p>
<h3>Arranging in splits</h3>
<p>We can use the <code>split</code> method to create a layout whose columns’ width can be tweaked. The <code>factor</code> argument is optional and accepts values between <code>0.0</code> and <code>1.0</code>. Leaving it <a id="_idIndexMarker332"/>to the default value of <code>0.0</code> computes the optimal width automatically; otherwise, it sets the percentage occupied by the first column.</p>
<p>In this example, we’ll use a factor of <code>0.33</code> to give less space to the first column. Here, we will also create two columns so that we can fill them later and arrange more elements like we would in a table.</p>
<p>The following snippet displays two entries per line. The first column takes about one-third of the space:</p>
<pre class="source-code">
        # ...
        box = col.box()
        split = <strong class="bold">box.split(factor=0.33)</strong>
        <strong class="bold">left_col = split.column()</strong>
        left_col.label(text="author:")
        left_col.label(text="version:")
        <strong class="bold">right_col = split.column()</strong>
        right_col.label(text=str(bl_info['author']))
        right_col.label(text=str(bl_info['version']))</pre>
<p>Upon reloading the scripts, we will see our captions taking up one-third of the space, leaving the rest to the relevant information:</p>
<div><div><img alt="Figure 5.14: Author and version information taking one-third of the space" height="177" src="img/Figure_5.14_B18375.jpg" width="309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14: Author and version information taking one-third of the space</p>
<p>We can <a id="_idIndexMarker333"/>take advantage of dictionary methods to add more information from <code>bl_info</code>. This way, we can populate our <code>split</code> layout using a <code>for</code> loop.</p>
<h3>Populating with dictionaries</h3>
<p>Since we have created the columns already, we can add more entries using a loop. This is ideal <a id="_idIndexMarker334"/>for displaying the entries in a dictionary.</p>
<p>Let’s say that we want to show all the add-on information. In that case, we can iterate all the keyword/value pairs using the <code>items()</code> method:</p>
<pre class="source-code">
        # …
        box = col.box()
        split = box.split(factor=0.3)
        left_col = split.column()
        right_col = split.column()
        for k, v in bl_info.items():
            if not v:
                # ignore empty entries
                continue
            <strong class="bold">left_col.label(text=k)</strong>
<strong class="bold">            right_col.label(text=str(v))</strong></pre>
<p>Here, we skip <a id="_idIndexMarker335"/>unset values of <code>bl_info</code> using <code>continue</code> when <code>v</code> is empty. In these few lines, we can display all the available add-on information:</p>
<div><div><img alt="Figure 5.15: A box layout displaying bl_info" height="291" src="img/Figure_5.15_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15: A box layout displaying bl_info</p>
<p>If we are happy with leaving the column width to Blender, we can use a grid layout instead.</p>
<h3>Arranging grids</h3>
<p>A <code>grid_flow</code> layout is very convenient for arranging our elements into tables as it creates <a id="_idIndexMarker336"/>rows and columns automatically. For instance, we can display the object names from the scene on two columns by using <code>grid_flow(columns=2)</code> and adding labels to a <code>for</code> loop:</p>
<pre class="source-code">
        # ...
        col.label(text="Scene Objects:")
        grid = col.<strong class="bold">grid_flow(columns=2)</strong>
        for ob in context.scene.objects:
            <strong class="bold">grid.label(text=ob.name)</strong></pre>
<p>This code will display the names of the objects in the current scene, arranged in a two-column grid:</p>
<div><div><img alt="Figure 5.16: Object names displayed in a grid" height="378" src="img/Figure_5.16_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16: Object names displayed in a grid</p>
<p>With that, we have <a id="_idIndexMarker337"/>seen that labels can display icons too. This means we can display an icon of the object’s type beside each name, just like the outliner does.</p>
<h3>Building icon keywords</h3>
<p>A quick <a id="_idIndexMarker338"/>search in the <code>OUTLINER_OB_MESH</code> and <code>OUTLINER_OB_CURVE</code>, follow this pattern:</p>
<pre class="source-code">
OUTLINER_OB_[OBJECT_TYPE]</pre>
<p>This is depicted in the following figure:</p>
<div><div><img alt="Figure 5.17: Object type icons as displayed in the Icon Viewer area" height="278" src="img/Figure_5.17_B18375.jpg" width="428"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17: Object type icons as displayed in the Icon Viewer area</p>
<p>With that in mind, we can build those keywords using <em class="italic">string formatting</em>, a feature of Python 3 that makes combining strings and variables easier. To inform Python that we are using formatting, we must put an <code>f</code> character before the quote or apostrophe delimiters, then surround our variables with curly brackets inside the string. Here is an example:</p>
<pre class="source-code">
&gt;&gt;&gt; h = "Hello"
&gt;&gt;&gt; print(f"{h}, World!")
Hello, World!</pre>
<p>With that <a id="_idIndexMarker339"/>in mind, we get the string for the object type – for example, <code>'MESH'</code>, <code>'CURVE'</code>, or <code>'ARMATURE'</code> – using the <code>ob.type</code> attribute, then build the icon keyword using the following line:</p>
<pre class="source-code">
f'OUTLINER_OB_{ob.type}'</pre>
<p>This result can be fed to the <code>icon</code> parameter inside our loop:</p>
<pre class="source-code">
        col.label(text="Scene Objects:")
        grid = col.grid_flow(columns=2)
        for ob in context.scene.objects:
            grid.label(text=ob.name,
                       <code>icon=f'OUTLINER_OB_{ob.type}'</code>)</pre>
<p>We can reload the scripts and see how icons are displayed before names:</p>
<p class="IMG---Figure"><img alt="Figure 5.18: A custom panel listing the scene objects and their icons" height="378" src="img/Figure_5.18_B18375.png" width="306"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18: A custom panel listing the scene objects and their icons</p>
<p>We don’t want this list to take up too much space on large scenes, so we will break the loop after <a id="_idIndexMarker340"/>a certain number of objects. For instance, we can stop listing objects and display an ellipsis after the fourth listed object.</p>
<p>Leaving the ellipsis on the last line implies filling the grid row by row. To do that, we must set the <code>row_major</code> argument to <code>True</code> for our <code>grid_flow</code>:</p>
<pre class="source-code">
        col.label(text="Scene Objects:")
        grid = col.grid_flow(columns=2, <code>row_major=True</code>)
        for <code>i</code>, ob in <code>enumerate</code>(context.scene.objects):
            <code>if i &gt; 3</code>:   # stop after the third object
                grid.label(text"..")
                <code>break</code>
            grid.label(text=ob.name,
                       icon=f'OUTLINER_OB_{ob.type}')</pre>
<p class="callout-heading">A (bad) kind of magic</p>
<p class="callout">Arbitrary digits appearing in the middle of the code, such as those in <code>i &gt; 3</code>, are called <strong class="bold">magic numbers</strong>, and using <a id="_idIndexMarker341"/>them is considered bad practice as it makes it very difficult to find and change those values at a later stage.</p>
<p class="callout">A better solution is to make those numbers members of the class and access them later.</p>
<p>Storing <code>3</code> as a static <a id="_idIndexMarker342"/>member makes it easier to display the number of remaining objects. String formatting also works with numeric variables, so we can compute how many objects are left and use the result in curly brackets:</p>
<pre class="source-code">
class OBJECT_PT_very_simple(bpy.types.Panel):
    #...
    bl_context = 'object'
    <code>max_objects = 3</code>
    def draw(self, context):
        # ...
        for i, ob in enumerate(context.scene.objects):
            if <code>i &gt; self.max_objects:</code>
                <code>objects_left</code> = len(context.scene.objects)
                <code>objects_left</code> -= self.max_objects
                txt = <code>f</code>"... (<code>more {objects_left} objects</code>"
                grid.label(text=txt)
                break</pre>
<p>Since <code>max_objects</code> is an attribute of the class, it can be changed via Python.</p>
<p>Blender <a id="_idIndexMarker343"/>considers these add-ons to be Python modules, so it is possible to execute these lines in the <strong class="bold">Python Console</strong> or <strong class="bold">Text </strong><strong class="bold">Editor</strong> area:</p>
<pre class="source-code">
import very_simple_panel
very_simple_panel.<code>OBJECT_PT_very_simple.max_objects = 10</code></pre>
<p>The downside of this trick is that every reload of the add-on resets that value. A better way to change the settings in our add-on, which is by using <code>bpy.types.Preferences</code>, will be discussed in <a href="B18375_06.xhtml#_idTextAnchor129"><em class="italic">Chapter 6</em></a>:</p>
<p class="IMG---Figure"><img alt="Figure 5.19: Changing the limit displays more than three objects" height="459" src="img/Figure_5.19_B18375.png" width="428"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19: Changing the limit displays more than three objects</p>
<p>Using icons <a id="_idIndexMarker344"/>and informative text adds to the visual feedback of our UI. In the next section, we’ll take advantage of the colors from layout states to convey status information.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/>Providing color feedback</h1>
<p>Our object list will be much more useful if we can highlight which objects are selected and which <a id="_idIndexMarker345"/>are active. For instance, to reflect the selection status of an object in the color of its name, our script must perform two actions:</p>
<ol>
<li>Check whether an object is selected.</li>
<li>If it’s selected or active, display its name in a different color.</li>
</ol>
<p>Let’s learn how to perform these tasks using Blender’s API.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor115"/>Checking whether an object has been selected</h2>
<p>We can get <a id="_idIndexMarker346"/>the selection status of an object using its <code>select_get()</code> method. For instance, if the <code>'Cube'</code> object is selected, its <code>selected_get</code> method will return <code>True</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.data.objects['Cube'].select_get()
True</pre>
<p>We already know from <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">,</em> that, unlike the selection status, <code>active</code> is not a flag of the object, so how we retrieve this information is a bit different.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Checking whether an object is active</h2>
<p>To check whether <a id="_idIndexMarker347"/>an object is active, we can test whether it matches the one stored in <code>context.object</code>. Here’s what happens when <code>'Cube'</code> is the active object:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.data.objects['Cube'] == bpy.context.object
True</pre>
<p>Now that we know how to retrieve the activity status of an object, let’s look at ways we can alter the color of its labels.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Drawing layouts in red or gray</h2>
<p>Sometimes, painting text with a different color is useful to make an entry stand out. Blender <a id="_idIndexMarker348"/>doesn’t allow us to set the color of a piece of text explicitly, but we can take advantage of two specific attributes that alter the way a UI layout is displayed:</p>
<ul>
<li><code>UILayout.enabled = False</code> is meant to display an element without letting the user interact with it. This is very useful if we want to make the user aware that, even if an operation is not possible now, the interface for executing it is there to be found.</li>
<li><code>UILayout.alert = True</code> is useful for warning the user about something wrong, or potentially wrong.</li>
</ul>
<p>Those are very specific purposes, but we can take advantage of how they affect the displayed color:</p>
<ul>
<li>UI layouts whose <code>enabled</code> attribute equals <code>False</code> are <em class="italic">gray</em></li>
<li>UI layouts whose <code>alert</code> attribute equals <code>True</code> are <em class="italic">red</em></li>
</ul>
<p>So, we can <a id="_idIndexMarker349"/>use that to change the color of an entire layout. Labels are not layouts, and the <code>label()</code> method returns a <code>None</code> type. Since we cannot set those attributes directly on the text labels, we need to create a new layout for each entry of the grid and use that when we create our text:</p>
<pre class="source-code">
    # ...
    for i, ob in enumerate(context.scene.objects):
        # layout item to set entry color
        <code>item_layout = grid.column()</code>
        <code>item_layout</code>.label(text=ob.name,
                          icon=f'OUTLINER_OB_{ob.type}')</pre>
<p>We can set <code>item_layout.enabled</code> to <code>True</code> for selected objects and <code>False</code> for the unselected ones with this line:</p>
<pre class="source-code">
        item_layout.<code>enabled = ob.select_get()</code></pre>
<p>Likewise, we can set <code>item_layout.alert</code> by assigning the result of the equality test <code>(==</code>) directly:</p>
<pre class="source-code">
        item_layout.<code>alert = ob == context.object</code></pre>
<p>As we can see, the list now provides information about which objects are active and/or selected:</p>
<div><div><img alt="Figure 5.20: The active object is dark red, while unselected objects are gray" height="425" src="img/Figure_5.20_B18375.jpg" width="416"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20: The active object is dark red, while unselected objects are gray</p>
<p>We can <a id="_idIndexMarker350"/>also add buttons to perform some operations, as we’ll see in the next section.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Displaying buttons</h1>
<p>Intuitively, pushing a button performs a transformative action. Since buttons take up space, the default <a id="_idIndexMarker351"/>interface displays only the more generic operations. When we write custom interfaces, we can add more buttons based on our specific needs. This is made easier by how Blender translates operators into buttons. In this section, we’ll learn how buttons and operators are equivalent when it comes to the graphical interface.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>Using the operator method</h2>
<p>We can <a id="_idIndexMarker352"/>use the <code>UILayout.operator</code> method <a id="_idIndexMarker353"/>to display a button. In Blender, a button executes an operator. This operator is found through its identifier – that is, the <code>bl_idname</code> attribute, which we encountered in <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a> – and every operator must have it.</p>
<p>For instance, to add a button that deletes the selected objects, we must provide the identifier of the <strong class="bold">Delete</strong> operator.</p>
<p>If we use the <strong class="bold">Delete</strong> action from the <strong class="bold">Object</strong> menu or the <em class="italic">X</em> key and look into the <strong class="bold">Scripting</strong> workspace, we will find this new line in the <strong class="bold">Info </strong><strong class="bold">Log</strong> area:</p>
<pre class="source-code">
bpy.ops.object.delete(use_global=False)</pre>
<p>The part <a id="_idIndexMarker354"/>before the parentheses, <code>bpy.ops.object.delete</code>, is the operator class. We must be careful as we must not use <a id="_idIndexMarker355"/>the class itself as the argument of the operator, but the identifier of that class. We can get the identifier using the <code>idname()</code> method:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.ops.object.delete.idname()
'OBJECT_OT_delete'</pre>
<p>Using the <code>'OBJECT_OT_delete'</code> string as the argument of <code>operator()</code> will create a <strong class="bold">Delete</strong> button.</p>
<p class="callout-heading">ID please</p>
<p class="callout">Using the <code>operator</code> class instead of an operator’s identifier with <code>operator</code> causes <code>TypeError</code>: the operator and all the elements that follow it will not be displayed.</p>
<p class="callout">We can either use the <code>idname()</code> function or the identifier string directly. The function is preferred as it guarantees compatibility in case of future changes.</p>
<p>To display a <code>draw</code> function:</p>
<pre class="source-code">
col.operator(bpy.ops.object.delete.<code>idname()</code>)</pre>
<p>Here’s what we’ll see:</p>
<p class="IMG---Figure"><img alt="Figure 5.21: The Delete button has been added to the panel" height="377" src="img/Figure_5.21_B18375.png" width="306"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21: The Delete button has been added to the panel</p>
<p>Pressing <a id="_idIndexMarker356"/>the <strong class="bold">Delete</strong> button deletes the selected <a id="_idIndexMarker357"/>object. It is equivalent to invoking <strong class="bold">Object</strong> | <strong class="bold">Delete</strong> from the menu.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>Setting the operator’s text and visibility</h2>
<p>We can <a id="_idIndexMarker358"/>customize the button text or toggle the button’s <a id="_idIndexMarker359"/>display. For instance, we can hide <code>context</code>:</p>
<pre class="source-code">
        num_selected = len(context.<code>selected_objects</code>)</pre>
<p>We can reflect this information in the button label. The following snippet changes the button’s text according to the number of objects that have been selected. It also adds an “s” to the word “object” at the end so that it can use the plural form when needed:</p>
<pre class="source-code">
        if num_selected &gt; 0:
            op_txt = f"Delete {num_selected} object"
            if num_selected &gt; 1:
                op_txt += "s"  # add plural 's'
            col.operator(bpy.ops.object.delete.idname(),
                         <code>text</code>=op_txt)</pre>
<div><div><img alt="Figure 5.22: The text of the button changes according to the selection" height="406" src="img/Figure_5.22_B18375.jpg" width="622"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22: The text of the button changes according to the selection</p>
<p class="callout-heading">Nothing to hide (usually)</p>
<p class="callout">It is often <a id="_idIndexMarker362"/>said that hiding pieces of the UI is generally <a id="_idIndexMarker363"/>wrong as it leaves the user with no knowledge <a id="_idIndexMarker364"/>of where a feature can be found once the <a id="_idIndexMarker365"/>conditions have been met. This is generally a valid point, even though for didactical purposes, a disappearing button was used in the preceding example.</p>
<p class="callout">If we want to abide by the “no-hiding” rule, we can add an <code>else</code> statement containing a disabled layout:</p>
<pre class="source-code">
        if (num_selected &gt; 0):
                # …
        else:
            to_disable = col.column()
            to_disable.enabled = False
            to_disable.operator(
                          bpy.ops.object.delete.idname(),
                          text="Delete Selected"
                          )</pre>
<p class="callout">When <a id="_idIndexMarker366"/>coding, rules <a id="_idIndexMarker367"/>can <a id="_idIndexMarker368"/>be broken <a id="_idIndexMarker369"/>but not ignored!</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Overriding an operator’s settings</h2>
<p>The <code>delete</code> <a id="_idIndexMarker370"/>operator prompts a confirm dialog before deleting an object. This is its default behavior, and it can be overridden:</p>
<div><div><img alt="Figure 5.23: Clicking Delete opens a confirmation menu" height="453" src="img/Figure_5.23_B18375.jpg" width="429"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23: Clicking Delete opens a confirmation menu</p>
<p>This is <a id="_idIndexMarker371"/>reflected in the documented docstring. If we type the operator’s address and press <em class="italic">Tab</em>, the autocomplete will display two optional arguments called <code>use_global</code> and <code>confirm</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.ops.object.delete(
delete()
bpy.ops.object.delete(use_global=False, confirm=True)
Delete selected objects
&gt;&gt;&gt; bpy.ops.object.delete(</pre>
<p>You can learn more about this by looking at the API documentation. Right-clicking on the <strong class="bold">Delete</strong> button will display a menu containing a direct link:</p>
<div><div><img alt="Figure 5.24: The right-click menu of our Delete button can open the online documentation" height="460" src="img/Figure_5.24_B18375.jpg" width="469"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24: The right-click menu of our Delete button can open the online documentation</p>
<p>The documentation describes these Boolean arguments:</p>
<ul>
<li><code>use_global</code> (Boolean, optional): Delete globally or remove the object from all scenes</li>
<li><code>confirm</code> (Boolean, optional): Confirm or prompt for confirmation</li>
</ul>
<p>According t<a id="_idIndexMarker372"/>o the documentation, setting <code>use_global</code> to <code>True</code> would remove the selected objects from all the currently opened scenes. We do not want that, so we are not changing the default value.</p>
<p>The <code>confirm</code> parameter, on the other hand, is <code>True</code> by default. We need to change that to <code>False</code>, and since the button takes care of invoking the operator, we need to change that in the button’s properties.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Setting operator properties</h2>
<p>The <code>operator</code> function returns an <code>OperatorProperties</code> object, which is a class containing <a id="_idIndexMarker373"/>the attributes that can be set. Typically, we use the following code:</p>
<pre class="source-code">
    col.operator(bpy.ops.object.delete.idname(),
                 text=op_txt)</pre>
<p>Instead, we will store the properties returned by <code>operator</code> in the <code>props</code> variable so that we can change them later:</p>
<pre class="source-code">
    props = col.operator(bpy.ops.object.delete.idname(),
            text=op_txt)
    props.confirm = False</pre>
<p>This button <a id="_idIndexMarker374"/>triggers the <code>delete</code> operator, which is native to Blender. Since the interface considers Python and built-in operators equivalent, we can display buttons for our operators too.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Adding buttons for our functions</h2>
<p>We will add a button for displacing each of the selected objects randomly. This can be done to <a id="_idIndexMarker375"/>give a more “natural” look to our scene. To do that, we must write a new operator. Blender’s operators transform all the selected objects in the same way. First, we must import the <code>random</code> module at the beginning of our script:</p>
<pre class="source-code">
import bpy
from bpy.utils import previews
import os
<code>import random</code></pre>
<p>We proceed with our location function. It can be part of the operator class, but we can also write a function that stands on. The operator will call it inside its <code>execute</code> method. This function’s arguments are as follows:</p>
<ul>
<li>The objects to dislocate</li>
<li>The max number of units to add or subtract from each object’s location</li>
<li>Which axis should be affected</li>
</ul>
<p>We will feed the amount of displacement to the <code>randint</code> function, which will return a random integer number between a <code>min</code> and <code>max</code> range. We’ll do that for each of the three axes (<em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em>), so long as their entries in <code>do_axis</code> are <code>True</code>. The <code>amount</code> and <code>do_axis</code> arguments are optional. We set their default values to <code>1</code> and <code>True, True, True</code> in the function’s declaration:</p>
<pre class="source-code">
def add_random_location(objects, amount=1,
                        do_axis=(True, True, True)):
    """Add units to the locations of given objects"""
    for ob in objects:
        for i in range(3):
            if do_axis[i]:
                loc = ob.location
                loc[i] += random.randint(-amount, amount)</pre>
<p>Now, we need <a id="_idIndexMarker376"/>an operator to display in the interface. We will add properties for the <code>amount</code> and <code>do_axis</code> function arguments. To an operator, an integer and a tuple of Booleans are <code>IntProperty</code> and <code>BoolVectorProperty</code>, respectively:</p>
<pre class="source-code">
class TRANSFORM_OT_random_location(bpy.types.Operator):
    """Add units to the locations of selected objects"""
    bl_idname = "transform.add_random_location"
    bl_label = "Add random Location"
    <code>amount</code>: bpy.props.<code>IntProperty</code>(name="Amount",
                                  default=1)
    <code>axis</code>: bpy.props.<code>BoolVectorProperty</code>(
                               name="Displace Axis",
                               default=(True, True, True)
                               )</pre>
<p>The operator methods are straightforward; <code>poll</code> only makes sure that there are objects selected, while <code>execute</code> runs <code>add_random_location</code>:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.selected_objects
    def execute(self, context):
        add_random_location(context.selected_objects,
                            self.amount,
                            self.axis)
        return {'FINISHED'}</pre>
<p>Adding this operator to the layout displays a new button. As stated earlier, native and scripted operators <a id="_idIndexMarker377"/>are the same to the interfacee. In both cases, it looks for the operator’s identifier when it comes to invoking it. Scripted operators offer one small advantage, though: we can refer to their <code>bl_idname</code> attribute directly since their classes and our graphical interface belong to the same module or package.</p>
<p>Here’s our line for displaying the <strong class="bold">Add random </strong><strong class="bold">Location</strong> button:</p>
<pre class="source-code">
    col.operator(
                TRANSFORM_OT_random_location.<code>bl_idname</code>
                )</pre>
<p>And of course, we mustn’t neglect class registration and removal. Here’s the line we should add to <code>register()</code>:</p>
<pre class="source-code">
    bpy.utils.register_class(
                            TRANSFORM_OT_random_location
                            )</pre>
<p>Likewise, the add-on’s <code>unregister()</code> function should contain the following:</p>
<pre class="source-code">
    bpy.utils.unregister_class(
                            TRANSFORM_OT_random_location
                            )</pre>
<p>After invoking <strong class="bold">Reload Scripts</strong>, a new button will appear:</p>
<div><div><img alt="Figure 5.25: Our panel now displays two buttons" height="498" src="img/Figure_5.25_B18375.jpg" width="420"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25: Our panel now displays two buttons</p>
<p>Pressing this <a id="_idIndexMarker378"/>button should add random variation to the positions of selected objects since the operator properties do not pop up at execution. Even adding the <code>bl_options = {'REGISTER', 'UNDO'}</code> operator property, which we learned about in the <em class="italic">Writing the Elevator add-on</em> section in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>, would not change that: operator properties must be displayed explicitly when they are not run from the <strong class="bold">3D </strong><strong class="bold">Viewport</strong> area.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Displaying the operator properties</h2>
<p>Besides <code>poll</code> and <code>execute</code>, Blender operators involve another method, named <code>invoke</code>. The <code>invoke</code> method is run internally right before <code>execute</code>. Usually, we don’t need <a id="_idIndexMarker379"/>to define it, but in this case, we use it to tell Blender that we want to display and edit the operator properties – that is, our function arguments.</p>
<p>Besides <code>self</code> and <code>context</code>, <code>invoke</code> takes <code>event</code> as an argument. It contains information about what triggered the operator, but we don’t need that now. We only tell <code>window_manager</code> to display the properties dialog. So, we must add a few lines of code after the <code>poll</code> method:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.selected_objects
    def invoke(self, context, event):
        wm = context.window_manager
        return wm.<code>invoke_props_dialog</code>(self)</pre>
<p>Reloading the scripts and pressing the <code>add_random_location</code> function:</p>
<div><div><img alt="Figure 5.26: Using operator properties as function arguments" height="730" src="img/Figure_5.26_B18375.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26: Using operator properties as function arguments</p>
<p>With that, our <a id="_idIndexMarker380"/>object panel is finished. As a bonus, next, we will learn how to move it to a different part of the UI.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor125"/>Using different regions</h1>
<p>Usually, panels can be moved freely to another part of the interface. There are a few exceptions where <a id="_idIndexMarker381"/>repositioning a panel would not make much sense. For instance, a tool that helps select the controls of a character would be of little help in the Video Editor, and its <code>poll()</code> method might be looking for attributes, such as animation bones, outside of the animation’s <code>context</code>.</p>
<p>Outside of those cases, changing the <code>bl_*</code> attributes of a <code>Panel</code> class is enough to move our panel to a different place. Please refer to the <em class="italic">panel attributes</em> that we looked at in the <em class="italic">Creating a simple panel</em> section of this chapter.</p>
<p>So, to display our panel in the <code>bl_space_type</code> and <code>bl_region_type</code> as follows:</p>
<pre class="source-code">
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'</pre>
<div><div><img alt="Figure 5.27: Our panel has been moved to the 3D Viewport area" height="564" src="img/Figure_5.27_B18375.jpg" width="1042"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27: Our panel has been moved to the 3D Viewport area</p>
<p>By default, the <code>bl_category</code> attribute can be used to specify new or existing tabs:</p>
<pre class="source-code">
class VerySimplePanel(bpy.types.Panel):
    """Creates a Panel in the viewport properties"""
    bl_label = "A Very Simple Panel"
    bl_idname = "VERYSIMPLE_PT_layout"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Our Panel"</pre>
<p>If a Blender add-on contains more panels, putting them under the same tab is a good way to keep the interface neat:</p>
<div><div><img alt="Figure 5.28: A Viewport tab created from the bl_category attribute" height="463" src="img/Figure_5.28_B18375.jpg" width="316"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28: A Viewport tab created from the bl_category attribute</p>
<p>We have reached <a id="_idIndexMarker383"/>the end of our interface overview. There will be more UI insights in the next few chapters when we introduce lists and thumbnails, but for now, we have built a solid understanding of how to use layouts in Blender.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Summary</h1>
<p>In this chapter, we learned how to create and populate a custom <code>UIPanel</code> via Python and how to integrate that into our add-on. That gave us insight into how the Blender interface works in general and which steps we must take to add our widgets to it.</p>
<p>We also nested layouts together for a more complex appearance and displayed both native and external icons.</p>
<p>Lastly, we learned how to change our panel’s look according to the context without too much increase in complexity, as well as how to add functions to the UI.</p>
<p>This closes the first part of this book, where we gained an overall understanding of how Blender and Python work together and what Python scripts can do.</p>
<p>The add-on we have written relies on an external file called <code>icon_smile_64.png</code>. If we were to distribute it to the public, we would have to package it as a ZIP file. This is something we are going to do in <a href="B18375_06.xhtml#_idTextAnchor129"><em class="italic">Chapter 6</em></a>, which marks the beginning of <em class="italic">Part 2</em>, <em class="italic">Interactive Tools </em><em class="italic">and Animation</em>.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Questions</h1>
<ol>
<li>Is it possible for an area of the screen to host more than one editor?</li>
<li>Do all the editors consist of the same regions?</li>
<li>How do we set the editor, region, and context to which a panel belongs?</li>
<li>Must we always set a panel’s category?</li>
<li>Are the elements of a panel static or can they change dynamically?</li>
<li>Can we alter the color of a piece of text?</li>
<li>How do we display buttons?</li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-124"><a id="_idTextAnchor128"/>Part 2: Interactive Tools and Animation</h1>
<p>This part exposes modular, structured add-ons that interact with the animation system. It also introduces modal tools that capture the user input and the different steps of an operator’s execution.</p>
<p>This section comprises the following chapters:</p>
<ul>
<li><a href="B18375_06.xhtml#_idTextAnchor129"><em class="italic">Chapter 6</em></a>, <em class="italic">Structuring Our Code and Add-Ons</em></li>
<li><a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, <em class="italic">The Animation System</em></li>
<li><a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, <em class="italic">Animation Modifiers</em></li>
<li><a href="B18375_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, <em class="italic">Animation Drivers</em></li>
<li><a href="B18375_10.xhtml#_idTextAnchor247"><em class="italic">Chapter 10</em></a>, <em class="italic">Advanced and Modal Operators</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>