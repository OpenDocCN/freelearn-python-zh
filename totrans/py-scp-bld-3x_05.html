<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer116">
<h1 class="chapter-number" id="_idParaDest-97"><a id="_idTextAnchor100"/>5</h1>
<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Designing Graphical Interfaces</h1>
<p>Many tools add their own elements to the graphical interface. In the previous chapters, we used existing menus, but we can also add new panels to the <span class="No-Break">Blender window.</span></p>
<p>To design an interface, we must decide which elements to show and how to reach them, what information should be provided, and which actions should <span class="No-Break">be allowed.</span></p>
<p>In this chapter, you will learn how to insert new panels into different regions of Blender, how to display information and icons, and how to add buttons that can <span class="No-Break">invoke operators.</span></p>
<p>This chapter will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">Blender interface</span></li>
<li>Drawing a <span class="No-Break">custom panel</span></li>
<li>Context and <span class="No-Break">UI interaction</span></li>
</ul>
<h1 id="_idParaDest-99"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5</span></a><span class="No-Break">.</span></p>
<p>The example files include 2D images to be used as icons. Optionally, any 2D software can be used to create custom <strong class="source-inline">.png</strong> images, and you can use <span class="No-Break">them instead.</span></p>
<p>To implement our interface, we will have to learn how Blender is structured. Let’s begin our journey into graphical interfaces with a deep dive into the <span class="No-Break">Blender screen.</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor103"/>Areas, regions, and panels</h1>
<p>The Blender <a id="_idIndexMarker299"/>window is split into <strong class="bold">areas</strong>. Each area can contain an <strong class="bold">editor</strong> of a different type, such as the <em class="italic">viewport</em> for 3D objects or the <em class="italic">sequencer</em> for editing videos. Each editor, or space, can contain <a id="_idIndexMarker300"/>one or more <strong class="bold">regions</strong>. The number and type of regions vary across different types of editors: for instance, some editors, such as the <strong class="bold">Preferences</strong> window, have a navigation sidebar, while <span class="No-Break">others don’t.</span></p>
<p>The Blender manual explains the interface in <span class="No-Break">detail: </span><a href="https://docs.blender.org/manual/en/3.1/interface/index.xhtml"><span class="No-Break">https://docs.blender.org/manual/en/3.1/interface/index.xhtml</span></a><span class="No-Break">.</span></p>
<p>What we need to know for now is that <a id="_idIndexMarker301"/>regions can contain <strong class="bold">panels</strong>, and panels are the basic containers of graphical elements such as text, editable values, <span class="No-Break">and buttons.</span></p>
<p>We can create new panels with Python, which makes it possible to customize any region with ease. A panel must contain information about the area and region to which <span class="No-Break">it belongs:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 5.1: Areas, regions, and the panel in the Blender interface" height="669" src="image/Figure_5.01_B18375.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Areas, regions, and the panel in the Blender interface</p>
<p>Internally, panels can access information about Blender and the scene so that they can display the status and properties of the objects and execute operators. Now that we are more familiar with the anatomy of the screen, we are going to create a panel that helps us deal with <span class="No-Break">3D objects.</span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Creating a simple panel</h1>
<p>We will start with a simple panel that contains some text and icons, and we will see how to expand this <a id="_idIndexMarker302"/>initial idea into a tool that can help manage the objects in <span class="No-Break">the scene.</span></p>
<p>Our panel is a new class that derives from <strong class="source-inline">bpy.types.Panel</strong>. Like operators, panels require some static members to be set; otherwise, they will not work. Similar to operators, panels can have a <strong class="source-inline">poll()</strong> class method that states under which conditions the panel can <span class="No-Break">be displayed.</span></p>
<p>Instead of using the <strong class="source-inline">execute</strong> function, panels set up and draw their content via the <strong class="source-inline">draw(self, </strong><span class="No-Break"><strong class="source-inline">context)</strong></span><span class="No-Break"> function.</span></p>
<p>Since we are adding a new piece to the Blender interface, we will do that inside a new add-on. It’s not mandatory, but it makes it easier to enable and disable <span class="No-Break">our panel.</span></p>
<p>To keep our code orderly and clean, we will create a new folder for the scripts written for <span class="No-Break">this chapter.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Setting the environment</h2>
<p>Let’s create <a id="_idIndexMarker303"/>a folder for <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> in our <strong class="bold">Visual Studio Code</strong> project. Then, in the <strong class="bold">Blender Preferences</strong> area, set the <strong class="source-inline">ch5</strong> folder as a <strong class="bold">Scripts Folder</strong> and <span class="No-Break">restart Blender.</span></p>
<p>Our add-on script contains a panel, much like the ones in the previous chapters <span class="No-Break">contained operators:</span></p>
<ol>
<li>Select <strong class="source-inline">PythonScriptingBlender/ch5/addons</strong> in <strong class="bold">Visual </strong><span class="No-Break"><strong class="bold">Studio Code</strong></span><span class="No-Break">.</span></li>
<li>Create a new file by clicking the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">simple_panel.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by double-clicking <span class="No-Break">on it.</span></li>
</ol>
<p>We can now start writing the add-on for <span class="No-Break">our panel.</span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Drafting our panel add-on</h2>
<p>As we <a id="_idIndexMarker304"/>know from <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, three elements <span class="No-Break">are required:</span></p>
<ul>
<li>A <strong class="source-inline">bl_info</strong> dictionary containing <span class="No-Break">basic information</span></li>
<li>An <strong class="source-inline">import bpy</strong> statement to access the <span class="No-Break">Blender API</span></li>
<li>The <strong class="source-inline">register()</strong> and <strong class="source-inline">unregister()</strong> methods for enabling/disabling <span class="No-Break">add-ons, respectively</span></li>
</ul>
<p>We also need a class for the graphical element that we want to add – in this case, a class that derives <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">bpy.types.Panel</strong></span><span class="No-Break">.</span></p>
<p>We will start with the information dictionary and add the stubs for the required elements to set a frame on which we can code a fully working <span class="No-Break">UI add-on.</span></p>
<h3>Writing the info dictionary</h3>
<p>The <strong class="source-inline">bl_info</strong> dictionary <a id="_idIndexMarker305"/>will provide the <strong class="source-inline">name</strong> property of the add-on, its <strong class="source-inline">author</strong> and <strong class="source-inline">version</strong>, and the required <strong class="source-inline">blender</strong> version, plus a short <strong class="source-inline">description</strong>. We can also add a <strong class="source-inline">category</strong> under which the add-on is listed. Here’s what the code will <span class="No-Break">look like:</span></p>
<pre class="source-code">
bl_info = {
    "name": "A Very Simple Panel",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 2, 0),
    "description": "Just show up a panel in the UI",
    "category": "Learning",
}</pre>
<p>Now, we can proceed with the required <strong class="source-inline">import</strong> statements and the <span class="No-Break">main </span><span class="No-Break"><strong class="source-inline">class</strong></span><span class="No-Break">.</span></p>
<h3>Drafting the Panel class</h3>
<p>Now that <a id="_idIndexMarker306"/>we’ve imported the <strong class="source-inline">bpy</strong> module, we can write a class based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">bpy.types.Panel</strong></span><span class="No-Break">.</span></p>
<p>We can use any name for our class, but Blender recommends <span class="No-Break">some guidelines:</span></p>
<ul>
<li>Since our panel will be part of the object properties, the class name must begin <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">OBJECT</strong></span></li>
<li>The name contains <strong class="source-inline">_PT_</strong> in the middle since this is a <span class="No-Break"><strong class="source-inline">Panel Type</strong></span></li>
</ul>
<p>For now, our class will only contain a <em class="italic">docstring</em> and a <span class="No-Break"><strong class="source-inline">pass</strong></span><span class="No-Break"> statement:</span></p>
<pre class="source-code">
import bpy
class <strong class="bold">OBJECT_PT</strong>_very_simple(<strong class="bold">bpy.types.Panel</strong>):
    """Creates a Panel in the object context of the
    properties editor"""
    # still a draft: actual code will be added later
    pass</pre>
<p>Before adding methods and attributes, we will handle the class activation and dismissal through the <span class="No-Break">registration functions.</span></p>
<h3>Panel registration</h3>
<p>The <strong class="source-inline">register</strong> and <strong class="source-inline">unregister</strong> functions add and remove this class to/from Blender <a id="_idIndexMarker307"/>when the add-on is enabled and <span class="No-Break">disabled, respectively:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(OBJECT_PT_very_simple)
def unregister():
    bpy.utils.unregister_class(OBJECT_PT_very_simple)</pre>
<p>With that, we have created the initial structure of our panel add-on. We will now add the elements and attributes for displaying <span class="No-Break">some text.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Setting display attributes</h2>
<p>Blender looks <a id="_idIndexMarker308"/>for attributes that follow the <strong class="source-inline">bl_*</strong> pattern to determine where and how the panel is displayed. Panels have the same identification attributes as operators, as we saw in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, when we introduced the <span class="No-Break"><strong class="source-inline">Operator</strong></span><span class="No-Break"> class:</span></p>
<ul>
<li><strong class="source-inline">bl_label</strong>: The display name of <span class="No-Break">the panel</span></li>
<li><strong class="source-inline">bl_idname</strong>: The unique name of the panel for <span class="No-Break">internal usage</span></li>
</ul>
<p>Then, there are attributes used only on classes that derive <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">bpy.types.Panels</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">bl_space_type</strong>: The editor to which the <span class="No-Break">panel belongs</span></li>
<li><strong class="source-inline">bl_region_type</strong>: The region of the editor <span class="No-Break">to use</span></li>
<li><strong class="source-inline">bl_context</strong>: The sub-region for <span class="No-Break">specific objects/modes</span></li>
<li><strong class="source-inline">bl_category</strong>: The tab inside the region, <span class="No-Break">when available</span></li>
</ul>
<p>All of them are static strings, and <strong class="source-inline">bl_space_type</strong>, <strong class="source-inline">bl_region_type</strong>, and <strong class="source-inline">bl_context</strong> must match specific values known to Blender as regions of <span class="No-Break">the screen.</span></p>
<p>The possible values encompass all the available editors in Blender. That might seem overwhelming at first, but once we have an idea of where to place our panel, we can look that up in the online documentation <span class="No-Break">at </span><a href="https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml"><span class="No-Break">https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml</span></a><span class="No-Break">.</span></p>
<p>Since Blender contains many editors and each of them has its own sub-elements, we will have a look at the <span class="No-Break">possible combinations.</span></p>
<h3>Choosing our editor view via bl_space_type</h3>
<p>First, we <a id="_idIndexMarker309"/>must decide which Blender editor we are adding our panel to. That depends mainly on the purpose of our tool and where it will be more convenient to find it. For instance, if our panel helps make videos, it will be part of the <strong class="bold">Video Sequencer</strong>; if it is a scripting utility, we might assign it to the <em class="italic">Python Console</em> or the <em class="italic">Text Editor</em>. Blender recognizes the <a id="_idIndexMarker310"/>following values <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">bl_space_type</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">EMPTY</strong>: This value is not used <span class="No-Break">in scripts</span></li>
<li><strong class="source-inline">VIEW_3D</strong>: <strong class="bold">3D Viewport</strong> for <span class="No-Break">manipulating </span><span class="No-Break"><em class="italic">objects</em></span></li>
<li><strong class="source-inline">IMAGE_EDITOR</strong>: <strong class="bold">UV/Image Editor</strong> to view and edit <em class="italic">images</em> and <span class="No-Break">UV Maps</span></li>
<li><strong class="source-inline">NODE_EDITOR</strong>: <strong class="bold">Node Editor</strong> for node-based <em class="italic">shading</em> and <span class="No-Break"><em class="italic">compositing</em></span><span class="No-Break"> tools</span></li>
<li><strong class="source-inline">SEQUENCE_EDITOR</strong>: <strong class="bold">Video Sequencer</strong> <span class="No-Break"><em class="italic">editing</em></span><span class="No-Break"> tools</span></li>
<li><strong class="source-inline">CLIP_EDITOR</strong>: <strong class="bold">Movie Clip Editor</strong> for <span class="No-Break"><em class="italic">motion tracking</em></span></li>
<li><strong class="source-inline">DOPESHEET_EDITOR</strong>: <strong class="bold">Dope Sheet</strong> for adjusting the timing <span class="No-Break">of </span><span class="No-Break"><em class="italic">keyframes</em></span></li>
<li><strong class="source-inline">GRAPH_EDITOR</strong>: <strong class="bold">Graph Editor</strong> for drivers and <span class="No-Break">keyframe </span><span class="No-Break"><em class="italic">interpolation</em></span></li>
<li><strong class="source-inline">NLA_EDITOR</strong>: <strong class="bold">Nonlinear Animation</strong> to combine and <span class="No-Break">layer </span><span class="No-Break"><em class="italic">actions</em></span></li>
<li><strong class="source-inline">TEXT_EDITOR</strong> <strong class="bold">Text Editor</strong> to edit <em class="italic">scripts</em> and <span class="No-Break">in-file </span><span class="No-Break"><em class="italic">documentation</em></span></li>
<li><strong class="source-inline">CONSOLE</strong>: <strong class="bold">Python Console</strong> for interactive <span class="No-Break">script </span><span class="No-Break"><em class="italic">development</em></span></li>
<li><strong class="source-inline">INFO</strong>: <strong class="bold">Info</strong> about operations, warnings, and <span class="No-Break">error </span><span class="No-Break"><em class="italic">messages</em></span></li>
<li><strong class="source-inline">TOPBAR</strong>: <strong class="bold">Topbar</strong> for global, <span class="No-Break"><em class="italic">per-window settings</em></span></li>
<li><strong class="source-inline">STATUSBAR</strong>: <strong class="bold">Status Bar</strong> at the bottom of the screen for <span class="No-Break"><em class="italic">general information</em></span></li>
<li><strong class="source-inline">OUTLINER</strong>: <strong class="bold">Outliner</strong> overview of the <em class="italic">scene tree</em> and <span class="No-Break">data blocks</span></li>
<li><strong class="source-inline">PROPERTIES</strong>: <strong class="bold">Properties</strong> to edit the <em class="italic">attributes</em> of active objects and <span class="No-Break">data blocks</span></li>
<li><strong class="source-inline">FILE_BROWSER</strong>: <strong class="bold">File Browser</strong> to scroll through <em class="italic">files </em><span class="No-Break"><em class="italic">and assets</em></span></li>
<li><strong class="source-inline">SPREADSHEET</strong>: <strong class="bold">Spreadsheet</strong> to explore <em class="italic">geometry data</em> in <span class="No-Break">a table</span></li>
<li><strong class="source-inline">PREFERENCES</strong>: <strong class="bold">Preferences</strong> to edit persistent <span class="No-Break"><em class="italic">configuration</em></span><span class="No-Break"> settings</span></li>
</ul>
<p>Once we have decided on the space type, we are ready to pick a region <span class="No-Break">for it.</span></p>
<h3>Selecting a region via bl_region_type</h3>
<p>The kind <a id="_idIndexMarker311"/>of region depends on the <em class="italic">space</em> we chose in the previous step. Different editors have different regions. So, only the default value is always available. Here is a description of all the options <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">bl_region_type</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">WINDOW</strong>: The <em class="italic">main</em> region of a space area. This is the <span class="No-Break">default value.</span></li>
<li><strong class="source-inline">HEADER</strong>: A small horizontal strip for <em class="italic">menus</em> <span class="No-Break">and buttons.</span></li>
<li><strong class="source-inline">CHANNELS</strong>: Used in older versions of Blender, left for <span class="No-Break">backward compatibility.</span></li>
<li><strong class="source-inline">TEMPORARY</strong>: <em class="italic">Poupps</em> detached from the <span class="No-Break">main window.</span></li>
<li><strong class="source-inline">UI</strong>: Sidebar containing object settings (toggled <span class="No-Break">with </span><span class="No-Break"><em class="italic">N</em></span><span class="No-Break">).</span></li>
<li><strong class="source-inline">TOOLS</strong>: A toolbar containing a set of interactive tools (toggled <span class="No-Break">with </span><span class="No-Break"><em class="italic">T</em></span><span class="No-Break">).</span></li>
<li><strong class="source-inline">TOOL_PROPS</strong>: Settings in <em class="italic">modal windows</em>, such as <span class="No-Break"><strong class="bold">File Browser</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">PREVIEW</strong>: The preview area of the <span class="No-Break"><strong class="bold">Video Sequencer</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">HUD</strong>: The operator’s <span class="No-Break"><strong class="bold">Redo</strong></span><span class="No-Break"> panel.</span></li>
<li><strong class="source-inline">NAVIGATION_BAR</strong>: <em class="italic">Sidebar</em> in the <span class="No-Break"><strong class="bold">Preferences</strong></span><span class="No-Break"> window.</span></li>
<li><strong class="source-inline">EXECUTE</strong>: <em class="italic">Bottom bar</em> in <span class="No-Break">modal windows.</span></li>
<li><strong class="source-inline">FOOTER</strong>: A bar for displaying <em class="italic">information</em> about the <span class="No-Break">current operation.</span></li>
<li><strong class="source-inline">TOOL_HEADER</strong>: A small horizontal strip for <span class="No-Break"><em class="italic">tool settings</em></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">XR</strong>: The interface for <em class="italic">virtual </em><span class="No-Break"><em class="italic">reality</em></span><span class="No-Break"> controllers.</span></li>
</ul>
<h3>Picking a context via bl_context</h3>
<p>Some areas <a id="_idIndexMarker312"/>change according to the current selection, active tool, or interaction mode. In that case, the <strong class="source-inline">bl_context</strong> attribute <span class="No-Break">is required.</span></p>
<p>For instance, the <strong class="bold">Properties</strong> space changes when an entity of a different type is selected, so it is tabbed in <strong class="source-inline">'SCENE'</strong>, <strong class="source-inline">'OBJECT'</strong>, and <strong class="source-inline">'CONSTRAINTS'</strong>. If we are not sure about which one to use, we can just activate the tab we are interested in and check the <strong class="bold">Info Log</strong> area for a line stating <strong class="source-inline">bpy.context.space_data.context = </strong><span class="No-Break"><strong class="source-inline">NAME_OF_CONTEXT</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="Figure 5.2: UI context name in the Info Log area, after Object Properties have been selected" height="928" src="image/Figure_5.02_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: UI context name in the Info Log area, after Object Properties have been selected</p>
<p>Areas that <a id="_idIndexMarker313"/>do not follow the user context but still allow you to group their panels in tabs offer a <em class="italic">category</em> <span class="No-Break">attribute instead.</span></p>
<h4>Grouping in tabs using bl_category</h4>
<p>Regions with <a id="_idIndexMarker314"/>arbitrary tabs will look at the <strong class="source-inline">bl_category</strong> variable to look up the correct label. If no value is given, the new panel will be added to the <strong class="bold">Miscellaneous</strong> tab. If no tab is named after that value, a new one will <span class="No-Break">be created.</span></p>
<p>We are going to use the category attribute at the end of this chapter in conjunc<a id="_idTextAnchor108"/>tion with the <strong class="source-inline">'VIEW_3D'</strong> space type. We are going to start with the <strong class="source-inline">'PROPERTIES'</strong> editor, which does not <span class="No-Break">have tabs.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor109"/>Adding a panel to the Object Properties area</h2>
<p>To add <a id="_idIndexMarker315"/>our panel to the <strong class="bold">Object Properties</strong> area, we must set its <strong class="source-inline">bl_space_type</strong> to <strong class="source-inline">'PROPERTIES'</strong> and <strong class="source-inline">bl_context</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">'object'</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">Panel</strong> needs a <strong class="source-inline">draw</strong> function <a id="_idIndexMarker316"/>where the actual design takes place. At this stage, we can leave <span class="No-Break">it blank:</span></p>
<pre class="source-code">
import bpy
class OBJECT_PT_very_simple(bpy.types.Panel):
    """Creates a Panel in the object context of the
    properties space"""
    bl_label = "A Very Simple Panel"
    bl_idname = "VERYSIMPLE_PT_layout"
    bl_space_type = <strong class="bold">'PROPERTIES'</strong>
    bl_region_type = <strong class="bold">'WINDOW'</strong>
    bl_context = <strong class="bold">'object'</strong>
    def <strong class="bold">draw</strong>(self, context):
        # add layout elements
        pass</pre>
<p>Like most runtime functions of Blender classes, <strong class="source-inline">draw</strong> takes the <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong> arguments. As per Python convention, <strong class="source-inline">self</strong> is the running instance of the class, while <strong class="source-inline">context</strong> contains information about the current state of the <span class="No-Break">Blender scene.</span></p>
<p>Now, let’s learn how the <strong class="source-inline">draw</strong> method is used to add elements to the <span class="No-Break">panel’s layout.</span></p>
<h3>Drawing the panel’s content</h3>
<p>The <strong class="source-inline">draw</strong> function is <a id="_idIndexMarker317"/>executed continuously whenever a panel is used or updated. For this reason, it should not perform any computationally expensive task and just take care of the elements <span class="No-Break">to display.</span></p>
<p>The elements of a panel are arranged according to its layout. Since the layout is a non-static member, it can be accessed inside the <strong class="source-inline">draw</strong> function <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">self.layout</strong></span><span class="No-Break">.</span></p>
<p>By default, all elements are stacked vertically in a <strong class="source-inline">column</strong>, but different types of layouts will provide a different way to arrange the widgets in a <strong class="source-inline">row</strong> or inside <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">grid</strong></span><span class="No-Break">.</span></p>
<p>Layouts can be also nested together for more complex arrangements. Let’s learn how to access the main layout and add elements <span class="No-Break">to it.</span></p>
<h3>Working with layouts</h3>
<p>All layout <a id="_idIndexMarker318"/>types derive from the <strong class="source-inline">UILayout</strong> class. They have methods to add child elements or sub-layouts. The full list of attributes and methods is reported in the API documentation <span class="No-Break">at </span><span class="No-Break">https://docs.blender.org/api/3.2/bpy.types.UILayout.xhtml</span><span class="No-Break">.</span></p>
<p>So, to display text, we can use the <strong class="source-inline">UILayout.label</strong> method. Here are the first few lines of code for our <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        <strong class="bold">layout.label(text="A Very Simple Label")</strong></pre>
<p>If we enable this add-on and reach for the <strong class="bold">Object Properties</strong> area, we will be able to see our new panel displaying <span class="No-Break">some text:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 5.3: Our panel showing up in the Object Properties area" height="456" src="image/Figure_5.03_B18375.jpg" width="333"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Our panel showing up in the Object Properties area</p>
<h3>Displaying icons</h3>
<p>Labels <a id="_idIndexMarker319"/>can display <strong class="bold">icons</strong> too. There are two types <span class="No-Break">of icons:</span></p>
<ul>
<li><em class="italic">Built-in</em> icons that come with Blender. The <strong class="source-inline">label</strong> method provides an <strong class="source-inline">icon</strong> keyword to <span class="No-Break">use them.</span></li>
<li><em class="italic">External Images</em> can be used via the <span class="No-Break"><strong class="source-inline">icon_value</strong></span><span class="No-Break"> parameter.</span></li>
</ul>
<p>Blender’s native set of icons is used across the application. Each icon is identified with a keyword. For instance, <strong class="source-inline">LIGHT</strong> displays <span class="No-Break">a lightbulb:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 5.4: Blender icon for the LIGHT keyword" height="32" src="image/Figure_5.04_B18375.jpg" width="120"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: Blender icon for the LIGHT keyword</p>
<p>There are more than 800 built-in icons, so Blender includes an add-on for searching <span class="No-Break">through them.</span></p>
<h4>Looking for built-in icons with the Icon Viewer add-on</h4>
<p>The <strong class="bold">Icon Viewer</strong> add-on <a id="_idIndexMarker320"/>comes with the Blender installation. It can be found in the <strong class="bold">Development</strong> category or by searching for <strong class="source-inline">icon</strong> in the <strong class="bold">Search </strong><span class="No-Break"><strong class="bold">Bar</strong></span><span class="No-Break"> area:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 5.5: Activating the Icon Viewer add-on" height="144" src="image/Figure_5.05_B18375.jpg" width="898"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: Activating the Icon Viewer add-on</p>
<p>Once the add-on has been enabled, the <strong class="bold">Icon Viewer</strong> button appears in the header of the <strong class="bold">Python </strong><span class="No-Break"><strong class="bold">Console</strong></span><span class="No-Break"> header:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 5.6: The Icon Viewer button in the Python Console header" height="215" src="image/Figure_5.06_B18375.jpg" width="1073"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6: The Icon Viewer button in the Python Console header</p>
<p>Clicking this button opens a window that shows all native icons. We can select them <span class="No-Break">by left-clicking:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 5.7: The Icon Viewer add-on window" height="759" src="image/Figure_5.07_B18375.jpg" width="1066"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7: The Icon Viewer add-on window</p>
<p>Selecting an <a id="_idIndexMarker321"/>icon displays the associated keyword in the top-right corner. The keyword is also copied to the clipboard. For example, if we select the <em class="italic">question mark</em> icon, which is the first icon on the top left at the time of writing, the <strong class="source-inline">QUESTION</strong> keyword will be displayed, as shown in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 5.8: The QUESTION keyword is displayed in the top-right corner" height="795" src="image/Figure_5.08_B18375.jpg" width="1036"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8: The QUESTION keyword is displayed in the top-right corner</p>
<p>We can type a search key in the filter field in the top middle, which is marked with a <span class="No-Break">magnifier icon.</span></p>
<p>For instance, we can type <strong class="source-inline">“info”</strong> to show the <strong class="source-inline">'INFO'</strong> icon only. Now that we know their keywords, we can display those icons in <span class="No-Break">this way:</span></p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        layout.label(text="A Very Simple Label",
                     <strong class="bold">icon='INFO'</strong>)
        layout.label(text="Isn't it great?",
                     <strong class="bold">icon='QUESTION'</strong>)</pre>
<p>Label icons <a id="_idIndexMarker322"/>are displayed before the text and are a good way to make it <span class="No-Break">stand out:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel" height="325" src="image/Figure_5.09_B18375.jpg" width="331"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel</p>
<p>Built-in icons are always available and don’t require external files to be distributed alongside our scripts. We can also use image files when needed. The <strong class="source-inline">bpu.utils.previews</strong> module can be used to load icons from image files and retrieve them using an <span class="No-Break">index number.</span></p>
<h4>Using custom image icons</h4>
<p>In this <a id="_idIndexMarker323"/>example, we will add the icon of a smiling face to our panel. The image file is named <strong class="source-inline">icon_smile_64.png</strong> and can be found in this chapter’s <span class="No-Break">Git folder.</span></p>
<p>Alternatively, any image stored in <strong class="source-inline">.png</strong> format alongside the add-on’s <strong class="source-inline">.py</strong> file will work. In that case, the image filename used in the script must be <span class="No-Break">changed accordingly.</span></p>
<p>The resolution should not be too high: a 64-pixel-wide square picture is usually more <span class="No-Break">than enough:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 5.10: A 64x64 smiley face" height="91" src="image/Figure_5.10_B18375.jpg" width="91"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10: A 64x64 smiley face</p>
<p>To add custom icons to Blender, our script needs to import <span class="No-Break">the following:</span></p>
<ul>
<li>The <strong class="source-inline">os</strong> Python module, to build the icon file path and make sure it will work on <span class="No-Break">all platforms</span></li>
<li>The <strong class="source-inline">bpy.utils.previews</strong> Blender module, to generate a Blender identifier for <span class="No-Break">our icon</span></li>
</ul>
<p>Here is what our <strong class="source-inline">import</strong> section will look like once we <span class="No-Break">import them:</span></p>
<pre class="source-code">
import bpy
from bpy.utils import previews
import os</pre>
<p>Our icons <a id="_idIndexMarker324"/>must be accessible everywhere in the script. We can use a global variable, a static member, or a singleton for storage. In this example, we are using a global variable as it is the <span class="No-Break">simpler option.</span></p>
<p>So, right after the <strong class="source-inline">import</strong> section, we must add the <span class="No-Break">following lines:</span></p>
<pre class="source-code">
# global variable for icon storage
custom_icons = None</pre>
<p>We initialize the variable as <strong class="source-inline">None</strong> since we can load and clear it inside the <strong class="source-inline">register</strong>/<strong class="source-inline">unregister</strong> function. We can also add specific functions for that. This way, the code will be easier <span class="No-Break">to follow:</span></p>
<pre class="source-code">
def load_custom_icons():
    """Load icon from the add-on folder"""
    Addon_path = os.path.dirname(__file__)
    img_file = os.path.join(addon_path,
               "icon_smile_64.png")
    global custom_icons
    custom_icons = previews.new()
    custom_icons.load("<strong class="bold">smile_face</strong>",img_file, 'IMAGE')</pre>
<p>Then, we need a function that clears <strong class="source-inline">custom_icons</strong> when the add-on <span class="No-Break">is unregistered:</span></p>
<pre class="source-code">
def remove_custom_icons():
    """Clear Icons loaded from file"""
    global custom_icons
    bpy.utils.previews.remove(custom_icons)</pre>
<p>These functions <a id="_idIndexMarker325"/>are then invoked in the <span class="No-Break">registration section:</span></p>
<pre class="source-code">
def register():
    load_custom_icons()
    bpy.utils.register_class(VerySimplePanel)
def unregister():
    bpy.utils.unregister_class(VerySimplePanel)
    clear_custom_icons()</pre>
<p>Once we read the image file, we used <strong class="source-inline">"smile_face"</strong> as the first argument of <strong class="source-inline">custom_icons.load()</strong>, so that is the keyword that will be used for retrieving its identifier. Here’s the code to use in <span class="No-Break">a label:</span></p>
<pre class="source-code">
layout.label(text="Smile", icon_value=custom_icons['smile_face'].icon_id)</pre>
<p>If we look up and execute <strong class="bold">Reload Scripts</strong> from the <em class="italic">F3</em> search panel, we will see our custom icon in <span class="No-Break">the panel:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 5.11: Smiley icon loaded from our file and displayed in our panel" height="144" src="image/Figure_5.11_B18375.jpg" width="273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11: Smiley icon loaded from our file and displayed in our panel</p>
<p>For now, we have <a id="_idIndexMarker326"/>used the default column layout. We will learn how to use a different arrangement in the <span class="No-Break">next section.</span></p>
<p class="callout-heading">Where have my widgets gone?</p>
<p class="callout">Errors in the interface code fail “silently"; that is, Blender doesn’t complain visibly and instead just stops drawing the <span class="No-Break">buggy panel.</span></p>
<p class="callout">This prevents the UI from crashing but makes our code more difficult to debug; we will only notice that some of our widgets are <span class="No-Break">not displayed.</span></p>
<p class="callout">When that happens, the best thing to do is check the console output or the <strong class="bold">Info Log</strong> area in the <strong class="bold">Scripting</strong> workspace. It will contain <em class="italic">traceback</em> information about which line of code <span class="No-Break">is failing.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor110"/>Using layouts in our panels</h1>
<p>If we are not happy with the default stacking of the global layout, we can add a layout type of our <a id="_idIndexMarker327"/>choice to it and use that instead, and we’ll get a <span class="No-Break">different arrangement.</span></p>
<p>For instance, we can put two labels on the same line using a <strong class="source-inline">row</strong>. Also, even if we are happy with stacking our elements one under the other, it is good practice to create a <strong class="source-inline">column</strong> sub-layout anyway. This practice has at least <span class="No-Break">two advantages:</span></p>
<ul>
<li>We preserve the panel's look, even if the default arrangement <span class="No-Break">should change</span></li>
<li>We do not pollute the <span class="No-Break">original layout</span></li>
</ul>
<p>Let’s see how we can change the way our widgets <span class="No-Break">are stacked.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor111"/>Arranging in columns and rows</h2>
<p>We can nest more layout types together inside our <strong class="source-inline">draw</strong> function. For instance, we can place the <a id="_idIndexMarker328"/>last two labels from the previous example side by side rather than arrange them vertically. To do that, we must do <span class="No-Break">two things:</span></p>
<ol>
<li>First, we must create a <strong class="source-inline">column</strong> and add the first label <span class="No-Break">to it.</span></li>
<li>Then, we must create a <strong class="source-inline">row</strong>. The two labels we will add to it will be next to <span class="No-Break">each other:</span></li>
</ol>
<pre class="source-code">
    def draw(self, context):
        col = self.layout.column()
        col.label(text="A Very Simple Label",
                  icon='INFO')
        row = col.row()
        row.label(text="Isn't it great?",
                  icon='QUESTION')
        icon_id = custom_icons["smile_face"].icon_id
        row.label(text="Smile", icon_value=icon_id)</pre>
<p>Now, our panel consists of only <span class="No-Break">two lines:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 5.12: The second line consists of two labels" height="105" src="image/Figure_5.12_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12: The second line consists of two labels</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor112"/>Adding frames with box layouts</h2>
<p>Other types of sub-layouts provide additional effects. For instance, a box layout is like a column, but it <a id="_idIndexMarker329"/>is framed in a smoothed rectangle. Let’s say we want to display some information from the add-on’s <strong class="source-inline">bl_info</strong>. Here, we can add these lines to the <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
        box = col.box()
        row = box.row()
        row.label(text="version:")
        row.label(text=str(bl_info['version']))</pre>
<p>After we call <strong class="bold">Reload Scripts</strong>, we will see a frame around <span class="No-Break">that information:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 5.13: A box layout surrounds the version information" height="151" src="image/Figure_5.13_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13: A box layout surrounds the version information</p>
<p>We have put a caption of <strong class="source-inline">"version"</strong> and some information stating <strong class="source-inline">bl_info['version']</strong> in a row. That gives the same space to each element. To have more control over how much space is taken by the first element, we can use a <span class="No-Break"><strong class="source-inline">split</strong></span><span class="No-Break"> layout.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Using composite layouts</h2>
<p>Some layouts <a id="_idIndexMarker330"/>consist of more rows or columns. A <strong class="source-inline">split</strong> layout distributes <a id="_idIndexMarker331"/>the available space across different columns, while a <strong class="source-inline">grid</strong> layout creates rows and <span class="No-Break">columns automatically.</span></p>
<p>We are going to use them to build a more <span class="No-Break">sophisticated panel.</span></p>
<h3>Arranging in splits</h3>
<p>We can use the <strong class="source-inline">split</strong> method to create a layout whose columns’ width can be tweaked. The <strong class="source-inline">factor</strong> argument is optional and accepts values between <strong class="source-inline">0.0</strong> and <strong class="source-inline">1.0</strong>. Leaving it <a id="_idIndexMarker332"/>to the default value of <strong class="source-inline">0.0</strong> computes the optimal width automatically; otherwise, it sets the percentage occupied by the <span class="No-Break">first column.</span></p>
<p>In this example, we’ll use a factor of <strong class="source-inline">0.33</strong> to give less space to the first column. Here, we will also create two columns so that we can fill them later and arrange more elements like we would in <span class="No-Break">a table.</span></p>
<p>The following snippet displays two entries per line. The first column takes about one-third of <span class="No-Break">the space:</span></p>
<pre class="source-code">
        # ...
        box = col.box()
        split = <strong class="bold">box.split(factor=0.33)</strong>
        <strong class="bold">left_col = split.column()</strong>
        left_col.label(text="author:")
        left_col.label(text="version:")
        <strong class="bold">right_col = split.column()</strong>
        right_col.label(text=str(bl_info['author']))
        right_col.label(text=str(bl_info['version']))</pre>
<p>Upon reloading the scripts, we will see our captions taking up one-third of the space, leaving the rest to the <span class="No-Break">relevant information:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 5.14: Author and version information taking one-third of the space" height="177" src="image/Figure_5.14_B18375.jpg" width="309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14: Author and version information taking one-third of the space</p>
<p>We can <a id="_idIndexMarker333"/>take advantage of dictionary methods to add more information from <strong class="source-inline">bl_info</strong>. This way, we can populate our <strong class="source-inline">split</strong> layout using a <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop.</span></p>
<h3>Populating with dictionaries</h3>
<p>Since we have created the columns already, we can add more entries using a loop. This is ideal <a id="_idIndexMarker334"/>for displaying the entries in <span class="No-Break">a dictionary.</span></p>
<p>Let’s say that we want to show all the add-on information. In that case, we can iterate all the keyword/value pairs using the <span class="No-Break"><strong class="source-inline">items()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
        # …
        box = col.box()
        split = box.split(factor=0.3)
        left_col = split.column()
        right_col = split.column()
        for k, v in bl_info.items():
            if not v:
                # ignore empty entries
                continue
            <strong class="bold">left_col.label(text=k)</strong>
<strong class="bold">            right_col.label(text=str(v))</strong></pre>
<p>Here, we skip <a id="_idIndexMarker335"/>unset values of <strong class="source-inline">bl_info</strong> using <strong class="source-inline">continue</strong> when <strong class="source-inline">v</strong> is empty. In these few lines, we can display all the available <span class="No-Break">add-on information:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 5.15: A box layout displaying bl_info" height="291" src="image/Figure_5.15_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15: A box layout displaying bl_info</p>
<p>If we are happy with leaving the column width to Blender, we can use a grid <span class="No-Break">layout instead.</span></p>
<h3>Arranging grids</h3>
<p>A <strong class="source-inline">grid_flow</strong> layout is very convenient for arranging our elements into tables as it creates <a id="_idIndexMarker336"/>rows and columns automatically. For instance, we can display the object names from the scene on two columns by using <strong class="source-inline">grid_flow(columns=2)</strong> and adding labels to a <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop:</span></p>
<pre class="source-code">
        # ...
        col.label(text="Scene Objects:")
        grid = col.<strong class="bold">grid_flow(columns=2)</strong>
        for ob in context.scene.objects:
            <strong class="bold">grid.label(text=ob.name)</strong></pre>
<p>This code will display the names of the objects in the current scene, arranged in a <span class="No-Break">two-column grid:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 5.16: Object names displayed in a grid" height="378" src="image/Figure_5.16_B18375.jpg" width="306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16: Object names displayed in a grid</p>
<p>With that, we have <a id="_idIndexMarker337"/>seen that labels can display icons too. This means we can display an icon of the object’s type beside each name, just like the <span class="No-Break">outliner does.</span></p>
<h3>Building icon keywords</h3>
<p>A quick <a id="_idIndexMarker338"/>search in the <strong class="bold">Icon Viewer</strong> area confirms that the identifying string of object type icons, such as <strong class="source-inline">OUTLINER_OB_MESH</strong> and <strong class="source-inline">OUTLINER_OB_CURVE</strong>, follow <span class="No-Break">this pattern:</span></p>
<pre class="source-code">
OUTLINER_OB_[OBJECT_TYPE]</pre>
<p>This is depicted in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<img alt="Figure 5.17: Object type icons as displayed in the Icon Viewer area" height="278" src="image/Figure_5.17_B18375.jpg" width="428"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17: Object type icons as displayed in the Icon Viewer area</p>
<p>With that in mind, we can build those keywords using <em class="italic">string formatting</em>, a feature of Python 3 that makes combining strings and variables easier. To inform Python that we are using formatting, we must put an <strong class="source-inline">f</strong> character before the quote or apostrophe delimiters, then surround our variables with curly brackets inside the string. Here is <span class="No-Break">an example:</span></p>
<pre class="source-code">
&gt;&gt;&gt; h = "Hello"
&gt;&gt;&gt; print(f"{h}, World!")
Hello, World!</pre>
<p>With that <a id="_idIndexMarker339"/>in mind, we get the string for the object type – for example, <strong class="source-inline">'MESH'</strong>, <strong class="source-inline">'CURVE'</strong>, or <strong class="source-inline">'ARMATURE'</strong> – using the <strong class="source-inline">ob.type</strong> attribute, then build the icon keyword using the <span class="No-Break">following line:</span></p>
<pre class="source-code">
f'OUTLINER_OB_{ob.type}'</pre>
<p>This result can be fed to the <strong class="source-inline">icon</strong> parameter inside <span class="No-Break">our loop:</span></p>
<pre class="source-code">
        col.label(text="Scene Objects:")
        grid = col.grid_flow(columns=2)
        for ob in context.scene.objects:
            grid.label(text=ob.name,
                       <strong class="source-inline">icon=f'OUTLINER_OB_{ob.type}'</strong>)</pre>
<p>We can reload the scripts and see how icons are displayed <span class="No-Break">before names:</span></p>
<p class="IMG---Figure"><img alt="Figure 5.18: A custom panel listing the scene objects and their icons" height="378" src="image/Figure_5.18_B18375.png" width="306"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18: A custom panel listing the scene objects and their icons</p>
<p>We don’t want this list to take up too much space on large scenes, so we will break the loop after <a id="_idIndexMarker340"/>a certain number of objects. For instance, we can stop listing objects and display an ellipsis after the fourth <span class="No-Break">listed object.</span></p>
<p>Leaving the ellipsis on the last line implies filling the grid row by row. To do that, we must set the <strong class="source-inline">row_major</strong> argument to <strong class="source-inline">True</strong> for <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">grid_flow</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        col.label(text="Scene Objects:")
        grid = col.grid_flow(columns=2, <strong class="source-inline">row_major=True</strong>)
        for <strong class="source-inline">i</strong>, ob in <strong class="source-inline">enumerate</strong>(context.scene.objects):
            <strong class="source-inline">if i &gt; 3</strong>:   # stop after the third object
                grid.label(text"..")
                <strong class="source-inline">break</strong>
            grid.label(text=ob.name,
                       icon=f'OUTLINER_OB_{ob.type}')</pre>
<p class="callout-heading">A (bad) kind of magic</p>
<p class="callout">Arbitrary digits appearing in the middle of the code, such as those in <strong class="source-inline">i &gt; 3</strong>, are called <strong class="bold">magic numbers</strong>, and using <a id="_idIndexMarker341"/>them is considered bad practice as it makes it very difficult to find and change those values at a <span class="No-Break">later stage.</span></p>
<p class="callout">A better solution is to make those numbers members of the class and access <span class="No-Break">them later.</span></p>
<p>Storing <strong class="source-inline">3</strong> as a static <a id="_idIndexMarker342"/>member makes it easier to display the number of remaining objects. String formatting also works with numeric variables, so we can compute how many objects are left and use the result in <span class="No-Break">curly brackets:</span></p>
<pre class="source-code">
class OBJECT_PT_very_simple(bpy.types.Panel):
    #...
    bl_context = 'object'
    <strong class="source-inline">max_objects = 3</strong>
    def draw(self, context):
        # ...
        for i, ob in enumerate(context.scene.objects):
            if <strong class="source-inline">i &gt; self.max_objects:</strong>
                <strong class="source-inline">objects_left</strong> = len(context.scene.objects)
                <strong class="source-inline">objects_left</strong> -= self.max_objects
                txt = <strong class="source-inline">f</strong>"... (<strong class="source-inline">more {objects_left} objects</strong>"
                grid.label(text=txt)
                break</pre>
<p>Since <strong class="source-inline">max_objects</strong> is an attribute of the class, it can be changed <span class="No-Break">via Python.</span></p>
<p>Blender <a id="_idIndexMarker343"/>considers these add-ons to be Python modules, so it is possible to execute these lines in the <strong class="bold">Python Console</strong> or <strong class="bold">Text </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> area:</span></p>
<pre class="source-code">
import very_simple_panel
very_simple_panel.<strong class="source-inline">OBJECT_PT_very_simple.max_objects = 10</strong></pre>
<p>The downside of this trick is that every reload of the add-on resets that value. A better way to change the settings in our add-on, which is by using <strong class="source-inline">bpy.types.Preferences</strong>, will be discussed in <a href="B18375_06.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">:</span></p>
<p class="IMG---Figure"><img alt="Figure 5.19: Changing the limit displays more than three objects" height="459" src="image/Figure_5.19_B18375.png" width="428"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19: Changing the limit displays more than three objects</p>
<p>Using icons <a id="_idIndexMarker344"/>and informative text adds to the visual feedback of our UI. In the next section, we’ll take advantage of the colors from layout states to convey <span class="No-Break">status information.</span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/>Providing color feedback</h1>
<p>Our object list will be much more useful if we can highlight which objects are selected and which <a id="_idIndexMarker345"/>are active. For instance, to reflect the selection status of an object in the color of its name, our script must perform <span class="No-Break">two actions:</span></p>
<ol>
<li>Check whether an object <span class="No-Break">is selected.</span></li>
<li>If it’s selected or active, display its name in a <span class="No-Break">different color.</span></li>
</ol>
<p>Let’s learn how to perform these tasks using <span class="No-Break">Blender’s API.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor115"/>Checking whether an object has been selected</h2>
<p>We can get <a id="_idIndexMarker346"/>the selection status of an object using its <strong class="source-inline">select_get()</strong> method. For instance, if the <strong class="source-inline">'Cube'</strong> object is selected, its <strong class="source-inline">selected_get</strong> method will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.data.objects['Cube'].select_get()
True</pre>
<p>We already know from <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">,</em> that, unlike the selection status, <strong class="source-inline">active</strong> is not a flag of the object, so how we retrieve this information is a <span class="No-Break">bit different.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Checking whether an object is active</h2>
<p>To check whether <a id="_idIndexMarker347"/>an object is active, we can test whether it matches the one stored in <strong class="source-inline">context.object</strong>. Here’s what happens when <strong class="source-inline">'Cube'</strong> is the <span class="No-Break">active object:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.data.objects['Cube'] == bpy.context.object
True</pre>
<p>Now that we know how to retrieve the activity status of an object, let’s look at ways we can alter the color of <span class="No-Break">its labels.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Drawing layouts in red or gray</h2>
<p>Sometimes, painting text with a different color is useful to make an entry stand out. Blender <a id="_idIndexMarker348"/>doesn’t allow us to set the color of a piece of text explicitly, but we can take advantage of two specific attributes that alter the way a UI layout <span class="No-Break">is displayed:</span></p>
<ul>
<li><strong class="source-inline">UILayout.enabled = False</strong> is meant to display an element without letting the user interact with it. This is very useful if we want to make the user aware that, even if an operation is not possible now, the interface for executing it is there to <span class="No-Break">be found.</span></li>
<li><strong class="source-inline">UILayout.alert = True</strong> is useful for warning the user about something wrong, or <span class="No-Break">potentially wrong.</span></li>
</ul>
<p>Those are very specific purposes, but we can take advantage of how they affect the <span class="No-Break">displayed color:</span></p>
<ul>
<li>UI layouts whose <strong class="source-inline">enabled</strong> attribute equals <strong class="source-inline">False</strong> <span class="No-Break">are </span><span class="No-Break"><em class="italic">gray</em></span></li>
<li>UI layouts whose <strong class="source-inline">alert</strong> attribute equals <strong class="source-inline">True</strong> <span class="No-Break">are </span><span class="No-Break"><em class="italic">red</em></span></li>
</ul>
<p>So, we can <a id="_idIndexMarker349"/>use that to change the color of an entire layout. Labels are not layouts, and the <strong class="source-inline">label()</strong> method returns a <strong class="source-inline">None</strong> type. Since we cannot set those attributes directly on the text labels, we need to create a new layout for each entry of the grid and use that when we create <span class="No-Break">our text:</span></p>
<pre class="source-code">
    # ...
    for i, ob in enumerate(context.scene.objects):
        # layout item to set entry color
        <strong class="source-inline">item_layout = grid.column()</strong>
        <strong class="source-inline">item_layout</strong>.label(text=ob.name,
                          icon=f'OUTLINER_OB_{ob.type}')</pre>
<p>We can set <strong class="source-inline">item_layout.enabled</strong> to <strong class="source-inline">True</strong> for selected objects and <strong class="source-inline">False</strong> for the unselected ones with <span class="No-Break">this line:</span></p>
<pre class="source-code">
        item_layout.<strong class="source-inline">enabled = ob.select_get()</strong></pre>
<p>Likewise, we can set <strong class="source-inline">item_layout.alert</strong> by assigning the result of the equality test <strong class="source-inline">(==</strong>) <span class="No-Break">directly:</span></p>
<pre class="source-code">
        item_layout.<strong class="source-inline">alert = ob == context.object</strong></pre>
<p>As we can see, the list now provides information about which objects are active <span class="No-Break">and/or selected:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<img alt="Figure 5.20: The active object is dark red, while unselected objects are gray" height="425" src="image/Figure_5.20_B18375.jpg" width="416"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20: The active object is dark red, while unselected objects are gray</p>
<p>We can <a id="_idIndexMarker350"/>also add buttons to perform some operations, as we’ll see in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Displaying buttons</h1>
<p>Intuitively, pushing a button performs a transformative action. Since buttons take up space, the default <a id="_idIndexMarker351"/>interface displays only the more generic operations. When we write custom interfaces, we can add more buttons based on our specific needs. This is made easier by how Blender translates operators into buttons. In this section, we’ll learn how buttons and operators are equivalent when it comes to the <span class="No-Break">graphical interface.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>Using the operator method</h2>
<p>We can <a id="_idIndexMarker352"/>use the <strong class="source-inline">UILayout.operator</strong> method <a id="_idIndexMarker353"/>to display a button. In Blender, a button executes an operator. This operator is found through its identifier – that is, the <strong class="source-inline">bl_idname</strong> attribute, which we encountered in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> – and every operator must <span class="No-Break">have it.</span></p>
<p>For instance, to add a button that deletes the selected objects, we must provide the identifier of the <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break"> operator.</span></p>
<p>If we use the <strong class="bold">Delete</strong> action from the <strong class="bold">Object</strong> menu or the <em class="italic">X</em> key and look into the <strong class="bold">Scripting</strong> workspace, we will find this new line in the <strong class="bold">Info </strong><span class="No-Break"><strong class="bold">Log</strong></span><span class="No-Break"> area:</span></p>
<pre class="source-code">
bpy.ops.object.delete(use_global=False)</pre>
<p>The part <a id="_idIndexMarker354"/>before the parentheses, <strong class="source-inline">bpy.ops.object.delete</strong>, is the operator class. We must be careful as we must not use <a id="_idIndexMarker355"/>the class itself as the argument of the operator, but the identifier of that class. We can get the identifier using the <span class="No-Break"><strong class="source-inline">idname()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.ops.object.delete.idname()
'OBJECT_OT_delete'</pre>
<p>Using the <strong class="source-inline">'OBJECT_OT_delete'</strong> string as the argument of <strong class="source-inline">operator()</strong> will create a <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break"> button.</span></p>
<p class="callout-heading">ID please</p>
<p class="callout">Using the <strong class="source-inline">operator</strong> class instead of an operator’s identifier with <strong class="source-inline">operator</strong> causes <strong class="source-inline">TypeError</strong>: the operator and all the elements that follow it will not <span class="No-Break">be displayed.</span></p>
<p class="callout">We can either use the <strong class="source-inline">idname()</strong> function or the identifier string directly. The function is preferred as it guarantees compatibility in case of <span class="No-Break">future changes.</span></p>
<p>To display a <strong class="bold">Delete</strong> button, we must add the following line to our <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
col.operator(bpy.ops.object.delete.<strong class="source-inline">idname()</strong>)</pre>
<p>Here’s what <span class="No-Break">we’ll see:</span></p>
<p class="IMG---Figure"><img alt="Figure 5.21: The Delete button has been added to the panel" height="377" src="image/Figure_5.21_B18375.png" width="306"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21: The Delete button has been added to the panel</p>
<p>Pressing <a id="_idIndexMarker356"/>the <strong class="bold">Delete</strong> button deletes the selected <a id="_idIndexMarker357"/>object. It is equivalent to invoking <strong class="bold">Object</strong> | <strong class="bold">Delete</strong> from <span class="No-Break">the menu.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>Setting the operator’s text and visibility</h2>
<p>We can <a id="_idIndexMarker358"/>customize the button text or toggle the button’s <a id="_idIndexMarker359"/>display. For instance, we can hide <strong class="bold">Delete</strong> if there <a id="_idIndexMarker360"/>are no selected objects. Like most <a id="_idIndexMarker361"/>information about the status, selected objects can be accessed <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">context</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        num_selected = len(context.<strong class="source-inline">selected_objects</strong>)</pre>
<p>We can reflect this information in the button label. The following snippet changes the button’s text according to the number of objects that have been selected. It also adds an “s” to the word “object” at the end so that it can use the plural form <span class="No-Break">when needed:</span></p>
<pre class="source-code">
        if num_selected &gt; 0:
            op_txt = f"Delete {num_selected} object"
            if num_selected &gt; 1:
                op_txt += "s"  # add plural 's'
            col.operator(bpy.ops.object.delete.idname(),
                         <strong class="source-inline">text</strong>=op_txt)</pre>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 5.22: The text of the button changes according to the selection" height="406" src="image/Figure_5.22_B18375.jpg" width="622"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22: The text of the button changes according to the selection</p>
<p class="callout-heading">Nothing to hide (usually)</p>
<p class="callout">It is often <a id="_idIndexMarker362"/>said that hiding pieces of the UI is generally <a id="_idIndexMarker363"/>wrong as it leaves the user with no knowledge <a id="_idIndexMarker364"/>of where a feature can be found once the <a id="_idIndexMarker365"/>conditions have been met. This is generally a valid point, even though for didactical purposes, a disappearing button was used in the <span class="No-Break">preceding example.</span></p>
<p class="callout">If we want to abide by the “no-hiding” rule, we can add an <strong class="source-inline">else</strong> statement containing a <span class="No-Break">disabled layout:</span></p>
<pre class="source-code">
        if (num_selected &gt; 0):
                # …
        else:
            to_disable = col.column()
            to_disable.enabled = False
            to_disable.operator(
                          bpy.ops.object.delete.idname(),
                          text="Delete Selected"
                          )</pre>
<p class="callout">When <a id="_idIndexMarker366"/>coding, rules <a id="_idIndexMarker367"/>can <a id="_idIndexMarker368"/>be broken <a id="_idIndexMarker369"/>but <span class="No-Break">not ignored!</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Overriding an operator’s settings</h2>
<p>The <strong class="source-inline">delete</strong> <a id="_idIndexMarker370"/>operator prompts a confirm dialog before deleting an object. This is its default behavior, and it can <span class="No-Break">be overridden:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<img alt="Figure 5.23: Clicking Delete opens a confirmation menu" height="453" src="image/Figure_5.23_B18375.jpg" width="429"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23: Clicking Delete opens a confirmation menu</p>
<p>This is <a id="_idIndexMarker371"/>reflected in the documented docstring. If we type the operator’s address and press <em class="italic">Tab</em>, the autocomplete will display two optional arguments called <strong class="source-inline">use_global</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">confirm</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.ops.object.delete(
delete()
bpy.ops.object.delete(use_global=False, confirm=True)
Delete selected objects
&gt;&gt;&gt; bpy.ops.object.delete(</pre>
<p>You can learn more about this by looking at the API documentation. Right-clicking on the <strong class="bold">Delete</strong> button will display a menu containing a <span class="No-Break">direct link:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<img alt="Figure 5.24: The right-click menu of our Delete button can open the online documentation" height="460" src="image/Figure_5.24_B18375.jpg" width="469"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24: The right-click menu of our Delete button can open the online documentation</p>
<p>The documentation describes these <span class="No-Break">Boolean arguments:</span></p>
<ul>
<li><strong class="source-inline">use_global</strong> (Boolean, optional): Delete globally or remove the object from <span class="No-Break">all scenes</span></li>
<li><strong class="source-inline">confirm</strong> (Boolean, optional): Confirm or prompt <span class="No-Break">for confirmation</span></li>
</ul>
<p>According t<a id="_idIndexMarker372"/>o the documentation, setting <strong class="source-inline">use_global</strong> to <strong class="source-inline">True</strong> would remove the selected objects from all the currently opened scenes. We do not want that, so we are not changing the <span class="No-Break">default value.</span></p>
<p>The <strong class="source-inline">confirm</strong> parameter, on the other hand, is <strong class="source-inline">True</strong> by default. We need to change that to <strong class="source-inline">False</strong>, and since the button takes care of invoking the operator, we need to change that in the <span class="No-Break">button’s properties.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Setting operator properties</h2>
<p>The <strong class="source-inline">operator</strong> function returns an <strong class="source-inline">OperatorProperties</strong> object, which is a class containing <a id="_idIndexMarker373"/>the attributes that can be set. Typically, we use the <span class="No-Break">following code:</span></p>
<pre class="source-code">
    col.operator(bpy.ops.object.delete.idname(),
                 text=op_txt)</pre>
<p>Instead, we will store the properties returned by <strong class="source-inline">operator</strong> in the <strong class="source-inline">props</strong> variable so that we can change <span class="No-Break">them later:</span></p>
<pre class="source-code">
    props = col.operator(bpy.ops.object.delete.idname(),
            text=op_txt)
    props.confirm = False</pre>
<p>This button <a id="_idIndexMarker374"/>triggers the <strong class="source-inline">delete</strong> operator, which is native to Blender. Since the interface considers Python and built-in operators equivalent, we can display buttons for our <span class="No-Break">operators too.</span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Adding buttons for our functions</h2>
<p>We will add a button for displacing each of the selected objects randomly. This can be done to <a id="_idIndexMarker375"/>give a more “natural” look to our scene. To do that, we must write a new operator. Blender’s operators transform all the selected objects in the same way. First, we must import the <strong class="source-inline">random</strong> module at the beginning of <span class="No-Break">our script:</span></p>
<pre class="source-code">
import bpy
from bpy.utils import previews
import os
<strong class="source-inline">import random</strong></pre>
<p>We proceed with our location function. It can be part of the operator class, but we can also write a function that stands on. The operator will call it inside its <strong class="source-inline">execute</strong> method. This function’s arguments are <span class="No-Break">as follows:</span></p>
<ul>
<li>The objects <span class="No-Break">to dislocate</span></li>
<li>The max number of units to add or subtract from each <span class="No-Break">object’s location</span></li>
<li>Which axis should <span class="No-Break">be affected</span></li>
</ul>
<p>We will feed the amount of displacement to the <strong class="source-inline">randint</strong> function, which will return a random integer number between a <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> range. We’ll do that for each of the three axes (<em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em>), so long as their entries in <strong class="source-inline">do_axis</strong> are <strong class="source-inline">True</strong>. The <strong class="source-inline">amount</strong> and <strong class="source-inline">do_axis</strong> arguments are optional. We set their default values to <strong class="source-inline">1</strong> and <strong class="source-inline">True, True, True</strong> in the <span class="No-Break">function’s declaration:</span></p>
<pre class="source-code">
def add_random_location(objects, amount=1,
                        do_axis=(True, True, True)):
    """Add units to the locations of given objects"""
    for ob in objects:
        for i in range(3):
            if do_axis[i]:
                loc = ob.location
                loc[i] += random.randint(-amount, amount)</pre>
<p>Now, we need <a id="_idIndexMarker376"/>an operator to display in the interface. We will add properties for the <strong class="source-inline">amount</strong> and <strong class="source-inline">do_axis</strong> function arguments. To an operator, an integer and a tuple of Booleans are <strong class="source-inline">IntProperty</strong> and <span class="No-Break"><strong class="source-inline">BoolVectorProperty</strong></span><span class="No-Break">, respectively:</span></p>
<pre class="source-code">
class TRANSFORM_OT_random_location(bpy.types.Operator):
    """Add units to the locations of selected objects"""
    bl_idname = "transform.add_random_location"
    bl_label = "Add random Location"
    <strong class="source-inline">amount</strong>: bpy.props.<strong class="source-inline">IntProperty</strong>(name="Amount",
                                  default=1)
    <strong class="source-inline">axis</strong>: bpy.props.<strong class="source-inline">BoolVectorProperty</strong>(
                               name="Displace Axis",
                               default=(True, True, True)
                               )</pre>
<p>The operator methods are straightforward; <strong class="source-inline">poll</strong> only makes sure that there are objects selected, while <strong class="source-inline">execute</strong> <span class="No-Break">runs </span><span class="No-Break"><strong class="source-inline">add_random_location</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.selected_objects
    def execute(self, context):
        add_random_location(context.selected_objects,
                            self.amount,
                            self.axis)
        return {'FINISHED'}</pre>
<p>Adding this operator to the layout displays a new button. As stated earlier, native and scripted operators <a id="_idIndexMarker377"/>are the same to the interfacee. In both cases, it looks for the operator’s identifier when it comes to invoking it. Scripted operators offer one small advantage, though: we can refer to their <strong class="source-inline">bl_idname</strong> attribute directly since their classes and our graphical interface belong to the same module <span class="No-Break">or package.</span></p>
<p>Here’s our line for displaying the <strong class="bold">Add random </strong><span class="No-Break"><strong class="bold">Location</strong></span><span class="No-Break"> button:</span></p>
<pre class="source-code">
    col.operator(
                TRANSFORM_OT_random_location.<strong class="source-inline">bl_idname</strong>
                )</pre>
<p>And of course, we mustn’t neglect class registration and removal. Here’s the line we should add <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">register()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    bpy.utils.register_class(
                            TRANSFORM_OT_random_location
                            )</pre>
<p>Likewise, the add-on’s <strong class="source-inline">unregister()</strong> function should contain <span class="No-Break">the following:</span></p>
<pre class="source-code">
    bpy.utils.unregister_class(
                            TRANSFORM_OT_random_location
                            )</pre>
<p>After invoking <strong class="bold">Reload Scripts</strong>, a new button <span class="No-Break">will appear:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 5.25: Our panel now displays two buttons" height="498" src="image/Figure_5.25_B18375.jpg" width="420"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25: Our panel now displays two buttons</p>
<p>Pressing this <a id="_idIndexMarker378"/>button should add random variation to the positions of selected objects since the operator properties do not pop up at execution. Even adding the <strong class="source-inline">bl_options = {'REGISTER', 'UNDO'}</strong> operator property, which we learned about in the <em class="italic">Writing the Elevator add-on</em> section in <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, would not change that: operator properties must be displayed explicitly when they are not run from the <strong class="bold">3D </strong><span class="No-Break"><strong class="bold">Viewport</strong></span><span class="No-Break"> area.</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Displaying the operator properties</h2>
<p>Besides <strong class="source-inline">poll</strong> and <strong class="source-inline">execute</strong>, Blender operators involve another method, named <strong class="source-inline">invoke</strong>. The <strong class="source-inline">invoke</strong> method is run internally right before <strong class="source-inline">execute</strong>. Usually, we don’t need <a id="_idIndexMarker379"/>to define it, but in this case, we use it to tell Blender that we want to display and edit the operator properties – that is, our <span class="No-Break">function arguments.</span></p>
<p>Besides <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong>, <strong class="source-inline">invoke</strong> takes <strong class="source-inline">event</strong> as an argument. It contains information about what triggered the operator, but we don’t need that now. We only tell <strong class="source-inline">window_manager</strong> to display the properties dialog. So, we must add a few lines of code after the <span class="No-Break"><strong class="source-inline">poll</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.selected_objects
    def invoke(self, context, event):
        wm = context.window_manager
        return wm.<strong class="source-inline">invoke_props_dialog</strong>(self)</pre>
<p>Reloading the scripts and pressing the <strong class="bold">Add random Location</strong> button now allows us to change the <strong class="bold">Amount</strong> and Displace <strong class="bold">Axis</strong> properties given to the <span class="No-Break"><strong class="source-inline">add_random_location</strong></span><span class="No-Break"> function:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 5.26: Using operator properties as function arguments" height="730" src="image/Figure_5.26_B18375.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26: Using operator properties as function arguments</p>
<p>With that, our <a id="_idIndexMarker380"/>object panel is finished. As a bonus, next, we will learn how to move it to a different part of <span class="No-Break">the UI.</span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor125"/>Using different regions</h1>
<p>Usually, panels can be moved freely to another part of the interface. There are a few exceptions where <a id="_idIndexMarker381"/>repositioning a panel would not make much sense. For instance, a tool that helps select the controls of a character would be of little help in the Video Editor, and its <strong class="source-inline">poll()</strong> method might be looking for attributes, such as animation bones, outside of the <span class="No-Break">animation’s </span><span class="No-Break"><strong class="source-inline">context</strong></span><span class="No-Break">.</span></p>
<p>Outside of those cases, changing the <strong class="source-inline">bl_*</strong> attributes of a <strong class="source-inline">Panel</strong> class is enough to move our panel to a different place. Please refer to the <em class="italic">panel attributes</em> that we looked at in the <em class="italic">Creating a simple panel</em> section of <span class="No-Break">this chapter.</span></p>
<p>So, to display our panel in the <strong class="bold">3D Viewport</strong> area, we can change the values of <strong class="source-inline">bl_space_type</strong> and <strong class="source-inline">bl_region_type</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'</pre>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 5.27: Our panel has been moved to the 3D Viewport area" height="564" src="image/Figure_5.27_B18375.jpg" width="1042"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27: Our panel has been moved to the 3D Viewport area</p>
<p>By default, the <strong class="bold">Misc</strong> tab is <a id="_idIndexMarker382"/>used, but the <strong class="source-inline">bl_category</strong> attribute can be used to specify new or <span class="No-Break">existing tabs:</span></p>
<pre class="source-code">
class VerySimplePanel(bpy.types.Panel):
    """Creates a Panel in the viewport properties"""
    bl_label = "A Very Simple Panel"
    bl_idname = "VERYSIMPLE_PT_layout"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Our Panel"</pre>
<p>If a Blender add-on contains more panels, putting them under the same tab is a good way to keep the <span class="No-Break">interface neat:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 5.28: A Viewport tab created from the bl_category attribute" height="463" src="image/Figure_5.28_B18375.jpg" width="316"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28: A Viewport tab created from the bl_category attribute</p>
<p>We have reached <a id="_idIndexMarker383"/>the end of our interface overview. There will be more UI insights in the next few chapters when we introduce lists and thumbnails, but for now, we have built a solid understanding of how to use layouts <span class="No-Break">in Blender.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Summary</h1>
<p>In this chapter, we learned how to create and populate a custom <strong class="source-inline">UIPanel</strong> via Python and how to integrate that into our add-on. That gave us insight into how the Blender interface works in general and which steps we must take to add our widgets <span class="No-Break">to it.</span></p>
<p>We also nested layouts together for a more complex appearance and displayed both native and <span class="No-Break">external icons.</span></p>
<p>Lastly, we learned how to change our panel’s look according to the context without too much increase in complexity, as well as how to add functions to <span class="No-Break">the UI.</span></p>
<p>This closes the first part of this book, where we gained an overall understanding of how Blender and Python work together and what Python scripts <span class="No-Break">can do.</span></p>
<p>The add-on we have written relies on an external file called <strong class="source-inline">icon_smile_64.png</strong>. If we were to distribute it to the public, we would have to package it as a ZIP file. This is something we are going to do in <a href="B18375_06.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, which marks the beginning of <em class="italic">Part 2</em>, <em class="italic">Interactive Tools </em><span class="No-Break"><em class="italic">and Animation</em></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Questions</h1>
<ol>
<li>Is it possible for an area of the screen to host more than <span class="No-Break">one editor?</span></li>
<li>Do all the editors consist of the <span class="No-Break">same regions?</span></li>
<li>How do we set the editor, region, and context to which a <span class="No-Break">panel belongs?</span></li>
<li>Must we always set a <span class="No-Break">panel’s category?</span></li>
<li>Are the elements of a panel static or can they <span class="No-Break">change dynamically?</span></li>
<li>Can we alter the color of a piece <span class="No-Break">of text?</span></li>
<li>How do we <span class="No-Break">display buttons?</span></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer117">
<h1 id="_idParaDest-124"><a id="_idTextAnchor128"/>Part 2: Interactive Tools and Animation</h1>
<p>This part exposes modular, structured add-ons that interact with the animation system. It also introduces modal tools that capture the user input and the different steps of an <span class="No-Break">operator’s execution.</span></p>
<p>This section comprises the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18375_06.xhtml#_idTextAnchor129"><em class="italic">Chapter 6</em></a>, <em class="italic">Structuring Our Code and Add-Ons</em></li>
<li><a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, <em class="italic">The Animation System</em></li>
<li><a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, <em class="italic">Animation Modifiers</em></li>
<li><a href="B18375_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, <em class="italic">Animation Drivers</em></li>
<li><a href="B18375_10.xhtml#_idTextAnchor247"><em class="italic">Chapter 10</em></a>, <em class="italic">Advanced and Modal Operators</em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer118">
</div>
</div>
<div>
<div id="_idContainer119">
</div>
</div>
</div></body></html>