- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed Systems Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As technology evolves and the demand for scalable and resilient systems increases,
    understanding the fundamental patterns that govern distributed systems becomes
    paramount.
  prefs: []
  type: TYPE_NORMAL
- en: From managing communication between nodes to ensuring **fault tolerance** (**FT**)
    and consistency, this chapter explores essential design patterns that empower
    developers to architect robust distributed systems. Whether you’re building microservices
    or implementing cloud-native applications, mastering these patterns will equip
    you with the tools to tackle the complexities of distributed computing effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Throttling pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Retry pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Circuit Breaker pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other distributed systems patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).The
    additional technical requirements for the code discussed in this chapter are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Flask and Flask-Limiter, using `python -m pip install` `flask flask-limiter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install PyBreaker, using `python -m pip` `install pybreaker`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Throttling pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throttling is an important pattern we may need to use in today’s applications
    and APIs. In this context, throttling means controlling the rate of requests a
    user (or a client service) can send to a given service or API in a given amount
    of time, to protect the resources of the service from being overused. For example,
    we may limit the number of user requests for an API to 1,000 per day. Once that
    limit is reached, the next request is handled by sending an error message with
    the 429 HTTP status code to the user with a message saying that there are too
    many requests.
  prefs: []
  type: TYPE_NORMAL
- en: There are many things to understand about throttling, including which limiting
    strategy and algorithm one may use and measuring how the service is used. You
    can find technical details about the Throttling pattern in the catalog of cloud
    design patterns by Microsoft ([https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling](https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling)).
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot of examples of throttling in real life, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highway traffic management**: Traffic lights or speed limits regulate the
    flow of vehicles on a highway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Water faucet**: Adjusting the flow of water from a faucet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concert ticket sales**: When tickets for a popular concert go on sale, the
    website may limit the number of tickets each user can purchase at once to prevent
    the server from crashing due to a sudden surge in demand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Electricity usage**: Some utility companies offer plans where customers pay
    different rates based on their electricity usage during peak and off-peak hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffet line**: In a buffet, customers may be limited to taking only one plate
    of food at a time to ensure that everyone has a fair chance to eat and to prevent
    food wastage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also have examples of pieces of software that help implement throttling:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django-throttle-requests` ([https://github.com/sobotklp/django-throttle-requests](https://github.com/sobotklp/django-throttle-requests))
    is a framework for implementing application-specific rate-limiting middleware
    for Django projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-Limiter ([https://flask-limiter.readthedocs.io/en/stable/](https://flask-limiter.readthedocs.io/en/stable/))
    provides rate-limiting features to Flask routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Throttling pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is recommended when you need to ensure your system continuously
    delivers the service as expected, when you need to optimize the cost of usage
    of the service, or when you need to handle bursts in activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you may implement the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the number of total requests to an API as N/day (for example, N=1000)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of requests to an API as N/day from a given IP address, or
    from a given country or region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of reads or writes for authenticated users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the rate-limiting cases, it can be used for *resource allocation*,
    ensuring fair distribution of resources among multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Throttling pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into an implementation example, you need to know that there are
    several types of throttling, among which are Rate-Limit, IP-level Limit (based
    on a list of whitelisted IP addresses, for example), and Concurrent Connections
    Limit, to only cite those three. The first two are relatively easy to experiment
    with. We will focus on the first one here.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example of rate-limit-type throttling using a minimal web application
    developed using Flask and its Flask-Limiter extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the imports we need for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As is usual with Flask, we set up the Flask application with the following
    two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the Limiter instance; we create it by passing a key function,
    `get_remote_address` (which we imported), the application object, the default
    limits values, and other parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on that, we can define a route for the `/limited` path, which will be
    rate-limited using the default limits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add the definition for a route for the `/more_limited` path. In this
    case, we decorate the function with `@limiter.limit("2/minute")` to ensure a rate
    limit of two requests per minute. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the snippet that is conventional for Flask applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this example, run the file (`ch09/throttling_flaskapp.py`) using the
    `python ch09/throttling_flaskapp.py` command. You would get the usual output for
    a Flask application that is starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – throttling_flaskapp: Flask application example startup](img/B21896_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1 – throttling_flaskapp: Flask application example startup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you point your browser to `http://127.0.0.1:5000/limited`, you will
    see the welcome content displayed on the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Response to the /limited endpoint in the browser](img/B21896_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Response to the /limited endpoint in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets interesting if you keep hitting the **Refresh** button. The 10th time,
    the page content will change and show you a **Too Many Requests** error message,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Too many requests on the /limited endpoint](img/B21896_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Too many requests on the /limited endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s not stop here. Remember – there is a second route in the code, `/more_limited`,
    with a specific limit of two requests per minute. To test that second route, point
    your browser to `http://127.0.0.1:5000/more_limited`. You will see new welcome
    content displayed on the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Response to the /more_limited endpoint in the browser](img/B21896_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Response to the /more_limited endpoint in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hit the **Refresh** button and do it more than twice in a window of 1
    minute, we get another **Two Many Requests** message, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Too many requests on the /more_limited endpoint](img/B21896_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Too many requests on the /more_limited endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, looking at the console where the Flask server is running, you will notice
    the mention of each HTTP request received and the status code of the response
    the application sent. It should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Flask server console: Responses to the HTTP requests](img/B21896_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6 – Flask server console: Responses to the HTTP requests'
  prefs: []
  type: TYPE_NORMAL
- en: There are many possibilities for rate-limit-type throttling in a Flask application
    using the Flask-Limiter extension, as you can see on the documentation page of
    the module. The reader can find more information on the documentation page on
    how to use different strategies and storage backends such as Redis for a specific
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The Retry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrying is an approach that is increasingly needed in the context of distributed
    systems. Think about microservices or cloud-based infrastructures where components
    collaborate with each other but are not developed or deployed/operated by the
    same teams and parties.
  prefs: []
  type: TYPE_NORMAL
- en: In its daily operation, parts of a cloud-native application may experience what
    are called transient faults or failures, meaning some mini-issues that can look
    like bugs but are not due to your application itself; rather, they are due to
    some constraints outside of your control such as the networking or the external
    server/service performance. As a result, your application may malfunction (at
    least, that could be the perception of your users) or even hang in some places.
    The answer to the risk of such failures is to put in place some retry logic so
    that we pass through the issue by calling the service again, maybe immediately
    or after some wait time (such as a few seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are examples of the Retry pattern (or analogies) in our daily life, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a phone call**: Imagine you’re trying to reach a friend on the phone,
    but the call doesn’t go through because their line is busy or there’s a network
    issue. Instead of giving up immediately, you retry dialing their number after
    a short delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Withdrawing money from an ATM**: Imagine you go to an ATM to withdraw cash,
    but due to a temporary issue such as network congestion or connectivity problems,
    the transaction fails, and the machine displays an error message. Instead of giving
    up on getting cash, you wait a moment and try the transaction again. This time,
    the transaction may go through successfully, allowing you to withdraw the money
    you need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also many tools or techniques that we can consider as examples in
    the software realm since they help implement the Retry pattern, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the Retrying library ([https://github.com/rholder/retrying](https://github.com/rholder/retrying))
    is available to simplify the task of adding retry behavior to our functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pester library ([https://github.com/sethgrid/pester](https://github.com/sethgrid/pester))
    for Go developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Retry pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is recommended to alleviate the impact of identified transient
    failures while communicating with an external component or service, due to network
    failure or server overload.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the retrying approach is not recommended for handling failures such
    as internal exceptions caused by errors in the application logic itself. Also,
    we must analyze the response from the external service. If the application experiences
    frequent busy faults, it’s often a sign that the service being accessed has a
    scaling issue that should be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: We can relate retrying to the microservices architecture, where services often
    communicate over the network. The Retry pattern ensures that transient failures
    don’t cause the entire system to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of use case is *data synchronization*. When syncing data between
    two systems, retries can handle the temporary unavailability of one system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Retry pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’ll implement the Retry pattern for a database connection.
    We’ll use a decorator to handle the retry mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `import` statements for the example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add configuration for logging, which will help for observability when
    using the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We add our function that will support the decorator to automatically retry
    the execution of the decorated function up to the number of attempts specified,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `connect_to_database()` function, which simulates a database
    connection. It is decorated by the `@retry` decorator. We want the decorator to
    automatically retry the connection up to three times if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to make it convenient to test our implementation, we add the following
    testing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the example, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, when a temporary database error occurs, a retry happens. Several retry attempts
    may occur, until three. Once three unsuccessful retry attempts have occurred,
    the outcome is the failure of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the Retry pattern is a viable way to handle this type of use case involved
    with distributed systems, and a few errors (four database errors in our example)
    may mean that there is a more permanent or problematic bug that should be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The Circuit Breaker pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One approach to FT involves retries, as we have just seen. But, when a failure
    due to communication with an external component is likely to be long-lasting,
    using a retry mechanism can affect the responsiveness of the application. We might
    be wasting time and resources trying to repeat a request that’s likely to fail.
    This is where another pattern can be useful: the Circuit Breaker pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: With the Circuit Breaker pattern, you wrap a fragile function call, or an integration
    point with an external service, in a special (circuit breaker) object, which monitors
    for failures. Once the failures reach a certain threshold, the circuit breaker
    trips and all subsequent calls to the circuit breaker return with an error, without
    the protected call being made at all.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In life, we can think of a water or electricity distribution circuit where a
    circuit breaker plays an important role.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software, a circuit breaker is used in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**E-commerce checkout**: If the payment gateway is down, the circuit breaker
    can halt further payment attempts, preventing system overload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate-limited APIs**: When an API has reached its rate limit, a circuit breaker
    can stop additional requests to avoid penalties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Circuit Breaker pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already said, the Circuit Breaker pattern is recommended when you need a
    component from your system to be fault-tolerant to long-lasting failures when
    communicating with an external component, service, or resource. Next, we will
    understand how it addresses such use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Circuit Breaker pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you want to use a circuit breaker on a flaky function, a function
    that is fragile, for example, due to the networking environment it depends on.
    We are going to use the `pybreaker` library ([https://pypi.org/project/pybreaker/](https://pypi.org/project/pybreaker/))
    to show an example of implementing the Circuit Breaker pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation is an adaptation of a nice script I found in this repository:
    [https://github.com/veltra/pybreaker-playground](https://github.com/veltra/pybreaker-playground).
    Let’s go through the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with our imports, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define our circuit breaker to automatically open the circuit after five
    consecutive failures in that function. We need to create an instance of the `pybreaker.CircuitBreaker`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our version of the function to simulate fragile calls. We use
    the decorator syntax to protect things, so the new function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here’s the main part of the code, with the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this script by running the `python ch09/circuit_breaker.py` command
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Output of our program using a circuit breaker](img/B21896_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Output of our program using a circuit breaker
  prefs: []
  type: TYPE_NORMAL
- en: 'By closely looking at the output, we can see that the circuit breaker does
    its job as expected: when it is open, all `fragile_function()` calls fail immediately
    (since they raise the `CircuitBreakerError` exception) without any attempt to
    execute the intended operation. And, after a timeout of 5 seconds, the circuit
    breaker will allow the next call to go through. If that call succeeds, the circuit
    is closed; if it fails, the circuit is opened again until another timeout elapses.'
  prefs: []
  type: TYPE_NORMAL
- en: Other distributed systems patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many more distributed systems patterns than the ones we covered here.
    Among the other patterns developers and architects can use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command and Query Responsibility Segregation (CQRS)**: This pattern separates
    the responsibilities for reading and writing data, allowing for optimized data
    access and scalability by tailoring data models and operations to specific use
    cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-Phase Commit**: This distributed transaction protocol ensures atomicity
    and consistency across multiple participating resources by coordinating a two-phase
    commit process, involving a *prepare* phase followed by a *commit* phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saga**: A saga is a sequence of local transactions that together form a distributed
    transaction, providing a compensating mechanism to maintain consistency in the
    face of partial failures or aborted transactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sidecar**: The Sidecar pattern involves deploying additional helper services
    alongside primary services to enhance functionality, such as adding monitoring,
    logging, or security features without directly modifying the main application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Registry**: This pattern centralizes the management and discovery
    of services within a distributed system, allowing services to dynamically register
    and discover each other, facilitating communication and scalability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulkhead**: Inspired by ship design, the Bulkhead pattern partitions resources
    or components within a system to isolate failures and prevent cascading failures
    from impacting other parts of the system, thereby enhancing FT and resilience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these patterns addresses specific challenges inherent in distributed
    systems, offering strategies and best practices for architects and developers
    to design robust and scalable solutions capable of operating in dynamic and unpredictable
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the intricacies of distributed systems patterns,
    focusing on the Throttling, Retry, and Circuit Breaker patterns. These patterns
    are essential for building robust, fault-tolerant, and efficient distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: The skills you’ve acquired in this chapter will significantly contribute to
    your ability to design and implement distributed systems that can handle transient
    failures, service interruptions, and high loads.
  prefs: []
  type: TYPE_NORMAL
- en: The section about the Throttling pattern equipped you with the tools to manage
    service load and resource allocation effectively.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding how to implement the Retry pattern, you’ve gained the skills
    to make your operations more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: And, finally, the Circuit Breaker pattern taught you how to build fault-tolerant
    systems that can gracefully handle failures.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up this chapter, it’s crucial to remember that these patterns are
    not isolated solutions but pieces of a larger puzzle. They often work best when
    combined and tailored to fit the specific needs and constraints of your system.
    The key takeaway is to understand the underlying principles so that you can adapt
    them to create a resilient and efficient distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we briefly presented some other distributed systems patterns, which
    we cannot cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on patterns for testing.
  prefs: []
  type: TYPE_NORMAL
