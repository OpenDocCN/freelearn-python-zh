- en: Accessing and Mining Data from Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking back, we now have a fair idea of the basics of writing Python scripts
    and how to get meaningful data out of information. We have covered how to write
    Python scripts, interact with network devices, and have also worked on the basics
    of PowerShell so that we can work with both PowerShell and Python scripts. Now
    we will move towards a deeper understanding of using Python by looking at various
    examples. In this chapter we will focus on working with various Network devices
    to dig or fetch relevant information from devices, working on that information
    to create new configurations and pushing it back to the devices for added or enhanced
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We will work on some common scenarios that we may face and try to solve them
    with Python. These examples or scenarios can be extended depending on a programmer's
    needs, and can be used as a reference to achieve automation in complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key concepts we will be covering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Device configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-vendor environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 to IPv6 conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Office/DC relocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Site rollouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BYOD configs for switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device OS upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP configs/interface parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to deploy three routers with a standard base configuration. The base
    configuration remains the same on each router, but as each router is different,
    we need to automate the generation of the three config files for each router.
    The assumption is that all the routers have a standard hardware configuration
    with the same types of ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50bf4ba-cbd3-4e52-b0fc-0259d1dd9c06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the diagram, routers R1, R2, and R3 have the following cabling:'
  prefs: []
  type: TYPE_NORMAL
- en: R1 `f1/0` (FastEthernet1/0) connected R2 `f1/0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R1 `f0/0` connected to R3 `f0/0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R2 `f0/1` connected to R3 `f0/1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard config or template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding some more complexity, we need to ensure the `name-server` is different
    for each router. If each router is going to be deployed in different networks,
    here is the mapping that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: R1 -> hostname testindia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R2 -> hostname testusa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R3 -> hostname testUK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The logging host and name server will depend upon the region, so the mapping
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**India router**: logserver (1.1.1.1) and nameserver (1.1.1.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USA router**: logserver (2.1.1.1) and nameserver (2.1.1.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UK router**: logserver (3.1.1.1) and nameserver (3.1.1.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code to perform the requested task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first list is a dictionary that defines the logging host and nameserver
    config based upon the region. The `standardtemplate` variable is used to store
    the template. If we have a multi-line value that needs to be stored in a variable,
    we can use the three-quote format as we see in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we currently know the generic or default hostnames, we can just parse
    through each of the current hostnames, and, based upon the hostname values, generate
    the config. This output can be saved onto a file or can be directly generated
    from the script and pasted onto the router for the basic configuration. Similarly,
    we can enhance this by adding the IP addresses shown in the next example in the
    format `<ipaddress>` `<subnet mask`>:'
  prefs: []
  type: TYPE_NORMAL
- en: 'testindia f1/0: `10.0.0.1` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'testusa  f1/0: `10.0.0.2` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'testindia f0/0: `11.0.0.1` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'testUK f0/0: `11.0.0.2` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'testusa f0/1: `12.0.0.1` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'testUK f0/1: `12.0.0.2` `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code to perform this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we define a function that has a standard interface template. The
    template is now modified with the specific IP addresses and updated depending
    upon the calling value in the function (which is the router name). Also, we remove
    the unused lines by replacing them with a none value denoted by two double quotes
    `""` without any spaces between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the generated config, we can use a simple file handling operation
    to save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the output for both the generic template and interface configuration
    can be concatenated or added to a variable named `myfinaloutput`, and that is
    now being saved in a file called `myrouterconfig.txt` in the `C:\check` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can enhance the script by adding more functions for specific tasks
    such as **Open Shortest Path First** (**OSPF**) configs and **Border Gateway Protocol**
    (**BGP**) configs, create enhanced and complex configurations based upon specific
    router names, and store them in separate `.txt` files that would be ready for
    the final push to the network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-vendor environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we have many vendors participating in a configuration change or even
    creating various templates from scratch. We have vendors such as Arista, Cisco
    (IOS, NXOS), and Juniper that participate in network design in different layers.
    While dealing with situations such as this we need to be clear which layer each
    of the vendors is working on and create dynamic templates for each type of vendor
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a scenario in which we know the hardware platform and the role of the
    device (such as access layer, core layer, or **top of rack** (**TOR**) layer;
    we can generate configs quickly with very basic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If a device is in production, we can use the SNMP protocol to fetch information
    for that device and create dynamic values based upon the return type of devices.
  prefs: []
  type: TYPE_NORMAL
- en: As a basic idea, we can have a look at [https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB.](https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB)
  prefs: []
  type: TYPE_NORMAL
- en: This has the information on the current open standard **Managed Information
    Base** (**MIB**) that is used by SNMP to get basic device information.
  prefs: []
  type: TYPE_NORMAL
- en: Again following good practice, we should ensure we create a generic function
    that can return the device type. Additionally, SNMP **Object Identifiers (OIDs**)
    can go deep inside to fetch information such as the current number of interfaces,
    the state of the interfaces, and even which interfaces are operational so that
    we can quickly make intelligent decisions based upon a device's current health
    or information fetched from a device.
  prefs: []
  type: TYPE_NORMAL
- en: We will be installing and using the `PySNMP` libraryto query SNMP with device.
    To install it we will use the earlier method of `pip install pysnmp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic  `PySNMP`documentation can be viewed at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html](https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will try to fetch the current version of a network device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output for the preceding code when queried against a network device
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77a31f3a-e4ed-4b2d-832d-148e5a11a9bf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On our test router, we enabled SNMP using the `snmp-server community public
    RO` command, and through executing the preceding Python code written, got the
    `RO` string public to read the `sysDescr.0` value, which is in Cisco standards
    the truncated show version.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method of fetching information using SNMP, we can discover what types
    of device there are and based on the output, we can make intelligent decisions
    such as generating device-specific configs without asking for device type inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, here is an example using PySNMP to fetch the current interfaces
    on a router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when queried for interface info on our sample router is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0cae82a-c71e-4d5a-a69e-fe20240f9b9e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we use the `bulkCmd` method, which walks through all the SNMP
    values and returns the output for the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The OID `1.3.6.1.2.1.2.2.1.2` is used as reference to fetch these values from
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, we can utilize the available SNMP OIDs for different vendors
    to fetch the specific information from multiple devices and proceed with our expected
    tasks based upon the returned values.
  prefs: []
  type: TYPE_NORMAL
- en: IP configs/interface parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many instances in which we need to parse interface configs to fetch
    useful information. For example, from a list of devices, find all the interfaces
    that are trunk. Another example could be to find all the interfaces that are `admin-shutdown`
    (shutdown on the router), or even fetch the IP address configurations from interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: There might be instances wherein we need to find out whether particular IP addresses
    or subnets are configured on the router.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to extract any information is using regex. Regex is term that is
    used to match a particular pattern and either fetch the matched pattern or validate
    whether a certain pattern is present in the parsed text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most basic and important regexes that are used in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `.` | Match any character except newline |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Match the start of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Match the end of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Match 0 or more repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Match 1 or more repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Match 0 or 1 repetitions |'
  prefs: []
  type: TYPE_TB
- en: '| `\A` | Match only at the start of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Match an empty string, only at the beginning or end of a word |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Match an empty string, only when it is not at the beginning or end
    of a word |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Match digits (such as [0-9]) |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | Match any non digit (such as [^0-9]) |'
  prefs: []
  type: TYPE_TB
- en: '| `\Z` | Match only at the end of a string |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Escape special characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Match a set of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-z]` | Match any lowercase ASCII letter |'
  prefs: []
  type: TYPE_TB
- en: '| `[^]` | Match characters NOT in a set |'
  prefs: []
  type: TYPE_TB
- en: '| `A&#124;B` | Match either A or B regular expressions (non-greedy) |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Match whitespace characters (such as [ \t\n\r\f\v]) |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | Match non whitespace characters (such as [^ \t\n\r\f\v]) |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Match unicode word characters (such as  [a-zA-Z0-9_]) |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | Match any character not a Unicode word character (such as  [^a-zA-Z0-9_])
    |'
  prefs: []
  type: TYPE_TB
- en: 'From this string, My IP address is `10.10.10.20` and by subnet mask is `255.255.255.255`,
    we need to get the IP address and subnet mask using regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when the preceding code is executed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5842005f-74fc-4bdf-8fac-fb8cd53aa768.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the regex for the IP address that we used is `\d+.\d+.\d+.\d+`.
    The `\d` means a digit, and `+` means multiple repetitions, because we are looking
    for a value of multiple digits separated by three dots.
  prefs: []
  type: TYPE_NORMAL
- en: However, in our case we have this type of repetition in two places, one in the
    IP address and the other in the subnet mask, so we modify the regex to search
    for `ip address is  \d+.\d+.\d+.\d+`for the IP address and `subnet mask is \d+.\d+.\d+.\d+` for
    the subnet mask. The command `re.search` inside both the `if` loops returns true
    if a match is found, and false if a match isn't found. In the example, once we
    find the pattern in the `if` condition we use `re.search` again and extract the
    value using `.group(0)`, which now contains the matched regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Since, we are only concerned with the IP address and the subnet mask, we replace
    the other string values with a blank or none value so we only get the specific
    IP address and subnet mask values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, using the inbuilt `socket` library, there might be a reason to
    check whether the IP address (IPv4 or IPv6) is valid or not. Here is an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78441d58-8d1c-4c0d-945f-c447f5593419.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `socket` library, we validate the IPv4 and IPv6 IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another task, as we mentioned earlier, is finding the interfaces that have
    `trunk` enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09766937-eb10-44a3-9c56-c4fd4d5feac2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we need to find out the common config that separates each chunk of interface.
    As we see in every interface configuration, the word `interface` separates the
    configurations of each interface, so we split out the config in chunks on interface
    work using the `split` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have each chunk, we use the `(fa|te)\d+/\d+` `re` pattern to get the
    interface name on any chunk that contains the word `trunk`. The pattern says that
    any value that starts with `fa` or `te`, is followed by any number of digits with
    a `\`, and again is followed by any number of digits, will be a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly in the same code, we only want to know which interfaces that are
    configured as `trunk` are in the active state (not shut). Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd711c9-5afc-47ef-ae62-6bf447e5fc36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We added an extra condition to proceed with only those chunks that have `no
    shut` in addition to `trunk` keywords. In this case, we only proceed with chunks
    that meet both conditions and in the preceding example, `te3/1` is not in the
    list as it is in the `shut` state.
  prefs: []
  type: TYPE_NORMAL
- en: When validating any IP config, we can parse the config, fetch the IP addresses,
    validate each IP address (IPv4 or IPv6), and if there are any incorrect values,
    point out the incorrect values. This can help to ensure we are validating the
    IP addresses that might have crept in because of any manual copy or paste actions.
    Of course, this also means we will not see any production issues because the config
    will already be pre-validated for correctness using this logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to validate any given IPv4 or IPv6 address from a device config is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad4c8a01-4998-4f15-86f5-626c6cbfa9db.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We take each line from `sampletext` and find out the IPv4 or IPv6 IPs from each
    line. Then we parse that information into our IP validation functions, and if
    there is an incorrect IP, it will print out the IP address that is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can validate other aspects of the config by creating specific
    functions and perform a full sanity and validation check on any given config.
  prefs: []
  type: TYPE_NORMAL
- en: Device OS upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to upgrade devices such as routers, switches, and firewalls.
    It is easy to perform upgrades on one device, but we need automation to upgrade
    multiple routers. Different devices have different ways of upgrading IOS or OS
    images, and the automation or scripts are created with different methods depending
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking an example of upgrading a Cisco IOS router; there are two basic steps
    or tasks that need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the relevant OS or IOS image into `flash:` or `bootflash:`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the config to reload the router with the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Task 1: Prerequisites (to copy relevant OS or IOS image):**'
  prefs: []
  type: TYPE_NORMAL
- en: We need a FTP server that's accessible from the router and has the IOS image
    that we need on the router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need the image, the correct MD5 checksum, and the image size for validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sample code for task 1 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code is going to push the IOS image into the router. The `while` loop will
    continue to monitor the progress of code copying until the specific image size
    is not met in the directory. The moment we have specified image size, the script
    will move to the next action, which is validating the MD5 checksum.  Once the
    MD5 checksum is validated, it prints out a final confirmation that the IOS image
    is not copied and MD5 validated.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this function on any router with just a couple of tweaks to the image
    name, size, and MD5 checksums for different sets of images.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note here is the `file prompt quiet` command. This needs
    to be executed before we start copying the command, as it suppresses any confirmation
    prompts in the router. If we get these confirmation prompts, it is tough to deal
    with all the prompts, thus adding to the complexity of the code.
  prefs: []
  type: TYPE_NORMAL
- en: By adding this command, we suppress the confirmation and once we have the code
    copied, we enable it to its default state of file prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Task 2: To change the bootvar of the router to a new OS image**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we set the bootvar in Cisco, to point to the new IOS image to
    be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82c715a9-ffb6-43f3-b9c3-90f3caa1a79e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, in this code we create a command with the new image and send
    it to the router using the `send_config_set` method. This method executes the
    command under `config t`. Once this is done, we validate from the new output fetched
    from running the `show run | in boot`command again, to confirm that the bootvar
    is now pointing to the new OS image.
  prefs: []
  type: TYPE_NORMAL
- en: If all is good, then we run `wr mem` to save this new config.
  prefs: []
  type: TYPE_NORMAL
- en: Once both the tasks are completed, we need to reload the router for the change
    to take affect. There are multiple scenarios that need to be taken care of before
    a reload. A direct reload can be performed as Task 3 using the `reload` command,
    but as a best practice we need to ensure no production or live traffic is currently
    on the router, as a reload will disrupt the current traffic flow. Also, it is
    advisable to be logged into the console to validate the reload progress and for
    faster recovery if there is a reload failure.
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 to IPv6 conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways to convert an IPv4 address to an IPv6 address. In Python
    3, we have the inbuilt `ipaddress` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4955c089-e699-458b-b816-1efcb3c6d5c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are many different methods or functions in the `ipaddress` library that
    we can use for various purposes. The documentation and details can be found at [https://docs.python.org/3/library/ipaddress.html.](https://docs.python.org/3/library/ipaddress.html)
  prefs: []
  type: TYPE_NORMAL
- en: Site rollouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we continue to work with multi-vendor environments, there is a demand to
    quickly roll out devices and configs to get a particular site up and running.
    Multiple techniques can be deployed for site rollouts, which involves a standard
    set of devices connected to standard ports with a standard IOS or code image on
    each device ready to be racked and powered up.  To determine the standard **Stock
    Keeping Unit** (**SKU**) for a specific site, we can segregate it as t-shirt sizes.
    At the planning stage we can create t-shirt sizes based upon certain parameters,
    such as usage, load, and redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: At the lowest level, let's say **extra small size** (**XS**) can have a single
    router and a single switch with the router terminating at an internet link. The
    switch is connected to the `FastEthernet 0/1` (for 100 Mbps) or `Gi0/1`(for 1000
    Mbps) port on the router, and end users directly plug in to the switch to get
    access. Based upon this XS SKU (or t-shirt size), we can determine the hardware
    vendor, such as Cisco, DLink, or other network device providers, for each of the
    router and the switch.  Next, when we have finalized the hardware providers, we
    work on generating the config template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The config template is typically based on two criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Role of the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware vendor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same XS size, let's say we have Cisco 3064 (Cisco Nexus running Cisco
    NXOS) as the router, and an Alcatel switch in the switch layer. As we have now
    finalized the hardware vendor and the role of each device, we can easily create
    template configs.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, once we have the standard hardware, we also need to ensure
    the ports are standard (for example, the uplink of switch will be connected from
    port `Gi1/0` to the router's `Gi1/1`). This will help us by ensuring we create
    a near-complete template with the interface configuration also being taken into
    consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'A template contains a basic configuration with certain values being determined
    later on. It is a very generic layout that we can fill in with values from various
    inputs, such as identifying free IP addresses, the next hostname in the sequence,
    and which routing needs to be in place as a standard configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11e0779b-374e-4781-9052-5e450fbd3b77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding figure, the central Python script is calling different
    functions (with the initial inputs being the vendor and the standard role-based
    template), and fetching specific information such as free IP addresses, next available
    hostname (such as `rtr01` or `rtr05`) and routing information (such as **Enhanced
    Interior Gateway Routing Protocol** (**EIGRP**) with subnet `10.10.10.0/255` being
    advertised on the network). Each of these inputs and more (depending upon the
    requirements) are separate Python functions, with the template being changed depending
    upon the return values of the Python function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we need to get the IP address from a SQL table where the IP
    address shows as unassigned using Python (we would be using `MySQLdb` library
    in Python for this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This returns a free IP address from the SQL table that we can call into other
    functions to generate our configs. Of course, once this is given, we also need
    to update the table to ensure we set the `isfree` value in the record to `false`
    so that a new call to this function would ensure that we get the next free IP
    address in the SQL table.
  prefs: []
  type: TYPE_NORMAL
- en: Adding all of this together, we can fetch details from multiple tables and even
    call APIs for specific tools to get specialized information, and, taking the return
    values  from all of these functions or methods as inputs,  the template would
    be called with these return values replacing the variables specified in the template.
    Once the template values are filled in, the output will be the final generated
    config that is ready to be deployed on the router/network devices.
  prefs: []
  type: TYPE_NORMAL
- en: By creating this baseline automation based upon the t-shirt size specifications,
    the script can be called again with a new t-shirt size that can include a new
    set of devices, such as load balancers, multiple routers, and each of the different
    routers in different roles depending on the t-shirt size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The next step after the generation of the final config templates is to apply
    the configs to the router. It is always advisable to perform this functionality
    using the console. Once we have the basic config in place to get SSH/Telnet access
    to the device, we can keep a session open with the console while performing the
    push of the remaining configs on the various devices. Netmiko can be used for
    this purpose, with the intention of pushing all the configs using the newly generated
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the cables are connected properly, as per the standards, the next step
    is to validate the traffic and configurations. To do this we again rely on Netmiko
    to fetch routes, logs, and even specific information such as interface counters
    and BGP router tables.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we could also work on SNMP inputs to validate the current running
    health of each device. A device can sometime perform well in test conditions,
    but once production or live traffic is on its data plane, it can spike in hardware
    resources, causing latency or packet drops. The SNMP stats will give us a clear
    idea of the health of each device, such as CPU usage, memory usage, and even the
    current temperature of certain devices and its modules, to display the overall
    health of the SKU or the t-shirt size site rollout.
  prefs: []
  type: TYPE_NORMAL
- en: Office/DC relocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we need to relocate, shut down, or migrate a site to a
    different location. This involves a lot of pre-checks, pre-validations, and ensuring
    the same setup of network PoD is active in the other location.
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-vendor environment, and with the increasing SKU size based upon t-shirt
    size, keeping a track of all active sessions, traffic flows, current interface
    status, and specific routes manually is difficult. Using Python, we can create
    an automated way to create a basic checklist and it can be ensured that after
    relocation the same checklist acts as a post validation checklist.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we create a basic script that asks if we need to perform a pre-check/post-check
    and save that in files named `pre-check` and `post-check`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e726fcd4-c421-400b-94c8-b54c2c0a1acf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assume that the `precheck.txt` file was taken at the site for multiple devices
    before the migration or relocation, and `postcheck.txt` was taken at the site
    after relocation. Now let's write a quick script that compares both files and
    prints out the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a library called `difflib` to perform this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5657105f-a8e3-4959-ba83-bc03896f61a7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in `precheck.txt` and `postcheck.txt`, the files are being compared
    line by line. Anything that is unchanged is displayed as it is, but anything that
    is different is shown by either a `-` or `+`. The `-` sign at start of the line
    specifies that the specific line is from first file (which is `precheck.txt` in
    our case), and a `+` sign depicts the same line has been output in the new file
    (which is `postcheck.txt`). Using this method, we can quickly validate the differences
    between `precheck` and `postcheck` and work on fixing the relevant issues after
    the migration or relocation.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want to automatically run the script to take a backup
    of the current config of routers. In this case, let's assume that the relocation
    is planned for tomorrow. Before any activity starts we want to ensure we have
    a backup of the current device configs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple script stated would do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The script is going to parse each device in the devices list one by one, execute
    the `show run` command, and save it in the given filename (the filename is the
    same as the given device name or IP). However, the next question is how to ensure
    this runs at the scheduled time. In Linux we have cron job that we can set up
    for this, and there is also Windows Task Scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the basic process of creating the task in Task
    Scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Task Scheduler in Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '>![](img/84456129-2387-4ac2-a8bf-c1f53df878ae.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Create a Basic Task on the right side of the Task Scheduler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00a1e53b-6b7a-44ec-9cb1-f6d363d092cc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next and select the frequency of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c3fc115-aea5-45be-8b1b-7c4c2bc786fc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Next, select the time, and again click Next. Move to Start a Program.
    At this point, you need to add the details shown in the following screenshot.
    We have to provide the full path of `python.exe` in the Program/script: window,
    and in the Add arguments (optional) section, the full path of the Python script
    (with the `.py` extension) enclosed in double quotes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/49199f49-4c8e-436d-8156-a0433d3f1292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the final page, click on Finish to submit the changes and create the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b23de7e1-ff39-460f-9d89-55bd5f3de113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once this is done, you can run it manually by right-clicking on the created
    task and clicking on the Run option. If the task succeeds, it will return the
    same in the Task Scheduler window. If all is fine, the task will automatically
    run at the given time in the Task Scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be run as a service and at regular intervals, such as daily and
    hourly, depending on how frequently we want to run the script in our environment.
  prefs: []
  type: TYPE_NORMAL
- en: These scheduled backups can sometimes be taken as baseline and can also act
    as last known good configuration scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Bring Your Own Device (BYOD) configs for switches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our network becomes more scalable, we need to broaden the current architecture
    designs of our network to incorporate better switches and routers to meet the
    demand. There may be times when we have a specialized demand and a specific set
    of hardware needs to be added to our network to meet those demands.
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement may be to lower the cost while increasing the scalability.
    In this case we would need to add different vendor switches to meet the demand.
    There might also be a very specific demand for a certain office or a site. In
    this case, we need to add different vendor hardware to fulfill some specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: All of the scenarios that we have just observed have one thing in common. To
    meet demand or specific requirements, we cannot rely on a single vendor solution
    on the network. There would be a random collection of devices to ensure a particular
    set of requirements are met. This is where we introduce the term BYOD. BYOD is
    a new standard that embraces new designs, hardware, and architecture to gel with
    our current SKU or design. It can be as simple as adding a new mobile phone to
    our corporate network using wireless, or a bit more complex, such as adding specific
    vendor hardware to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Architects need to ensure they have good way of forecasting the demand and knowing
    whether the current network design or hardware can meet those demands. In any
    case, there needs to be a requirement in the initial design to ensure that cross-vendor
    platforms are supported with the current technologies. There is a bit of conflict
    in this design methodology. For example, a certain vendor, such as Cisco, has
    the neighbor discovery protocol, **Cisco-specific protocol** (**CDP**), which
    discovers the correct Cisco devices as neighbors of the current device. However,
    to ensure the CDP is discovering and showing the correct information, every device
    needs to be Cisco. On the other hand we have **Link Layer Discovery Protocol**
    (**LLDP**), which is nearly the same as CDP but is open source, so lot of other
    vendors including Cisco also have the option to perform discovery using LLDP instead
    of CDP. Now, Cisco CDP is a Cisco-specific protocol; Cisco has ensured that certain
    parameters can only be exchanged or discovered using CDP, and for that matter,
    every device participating in CDP must be a Cisco device.
  prefs: []
  type: TYPE_NORMAL
- en: LLDP, being open source, is limited to parameters that are part of open standards
    or the **Internet Engineering Task Force** (**IETF**) framework, and all vendors
    supporting LLDP only adhere to those open standards for cross-platform and hardware
    compatibility. This also results in some participating vendors not sending or
    discovering specialized parameters that are meant specifically for that vendor
    (such as Cisco). Going back to the earlier point, in this case the architecture
    design from day one needs to ensure those standards that are multi-vendor or open
    source only need to be used in a baseline design or architecture. A similar example
    to LLDP would be using open standards such as OSPF or BGP instead of EIGRP, which
    is meant only for Cisco devices.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we need to have specific roles defined and hardware or
    vendor templates that should be created based upon the device or hardware that
    we are introducing in the current design as a BYOD strategy. Keeping the open
    standard approach, we need to ensure that the templates being created are generic,
    and vendor-specific configs can later be introduced into the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNMP is a powerful protocol that helps manage a lot of these cross-vendor or
    BYOD strategies seamlessly. With a basic configuration of enabling SNMP with a
    specific read-only community string, we can create quick scripts in Python to
    get basic information from BYOD devices. Taking an example, let''s assume we have
    two devices that we need to know the type and vendor of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/632e5f8d-0b08-408f-9861-148edd3bfc17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding output, now we just need to know the IP address
    and the open standard SNMP OID, SNMPv2-MIB. `sysDescr` will give the output for
    both devices. In this case, we can see that one is Cisco 3600 and the other is
    Cisco 3700. Based upon the information returned, we can proceed with the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There are various other tasks that need to be performed based upon the BYOD
    strategy. If there was a mobile phone that you wanted to connect to your network,
    the only thing needed is a connection to a corporate network and a policy that
    you could push to the devices to check for various compliance checks such as operating
    system and anti-virus. Based upon these results, the queried devices can be placed
    in another VLAN that can be called either a quarantine VLAN, which has very limited
    access, or a corporate VLAN, which has full access to corporate resources.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, as part of the BYOD for switches strategy, we need to perform
    certain checks to ensure the device is suitable to be part of our network design.
    Yes, we need to keep an open policy for various types of device, but there needs
    to be a loosely coupled framework under which devices can qualify to be part of
    BYOD acceptance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example that ensures that a device is compatible enough to
    be part of a BYOD framework. The core requirement is the switch from Cisco and
    it should have `FastEthernet0/0` as one of the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/addb3b92-1f37-493f-8e27-ade47fdfe9a7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We parse two devices and, using open source SNMP, get the vendor and interface
    info. Next, we validate, and based upon our conditions we return a `True` or `False`.
    A true condition for all checks results in acceptance of the device as BYOD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the rule a bit. Let''s say if any device has an Ethernet interface,
    then it is not eligible for BYOD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8fbf329-19c7-45c1-aa9b-96f25d9ed2b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in this example, we validated for any interface that starts with
    the `Ethernet` keyword. The `string.startswith("given string")` function is used
    to evaluate if any given string is at the start of the string that it is being
    compared with. In our case, the device with the IP `192.168.255.248` had an Ethernet-only
    interface, which returned the value `True` for validation the Ethernet-only interface.
    As this is considered a failure for our validation, a `False` was returned, and
    the script calls it out as a BYOD acceptance failure because this specific condition
    has failed.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, we can validate and ensure multiple checks on on any number
    of devices, and ensure only those that pass the BYOD framework checks are accepted
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various complex scenarios to see how new site
    migrations and validations are performed. We also looked at the concepts of multi-vendor
    configurations, creating templates, and generating configs for devices, and also
    IPv4 to IPv6 migration techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We focused on specialized extraction of particular data, such as an IP addresses,
    validations of that data, and conditions of failure or acceptance of the data.
    Additionally, site rollouts and BYOD strategies were discussed, along with best
    practices such as t-shirt size and validations of BYOD conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper and introduce the web-enabled framework.
    This will help us create our own APIs and create browser-based Python scripts
    that can be executed from anywhere.
  prefs: []
  type: TYPE_NORMAL
