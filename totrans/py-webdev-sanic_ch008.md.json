["```py\nCross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite.\n```", "```py\n$ pip install cryptography bcrypt pyjwt\n```", "```py\n@app.get(\"/<name>\")\nasync def handler(request, name):\n    return text(f\"Hi {name}\")\n```", "```py\n    <!DOCTYPE html>\n    <html lang=\"en\">\n        <head>\n            <meta charset=\"utf-8\" />\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <title>CORS issue</title>\n        <body>\n            <h1>Loading...</h1>\n            <script>\n                const element = document.querySelector(\"h1\")\n                fetch(\"http://localhost:7777/Adam\")\n                .then(async response => {\n                    const text = await response.text()\n                    element.innerHTML = text\n                })\n            </script>\n        </body>\n    ```", "```py\n    $ sanic -s /path/to/directory\n    ```", "```py\nCross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:7777/Adam. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).\n```", "```py\ndef is_preflight(request: Request):\n    return (\n        request.method == \"OPTIONS\"\n        and \"access-control-request-method\" in request.headers\n    )\n@app.on_response\nasync def add_cors_headers(request: Request, response: HTTPResponse) -> None:\n    # Add headers here on all requests\n    if is_preflight(request):\n        # Add headers here for preflight requests\n        ...\n```", "```py\n$ curl localhost:7777 -X OPTIONS -H \"Origin: http://mysite.com\" -H \"Access-Control-Request-Method: GET\" -i\n```", "```py\norigin = request.headers.get(\"origin\")\nif not origin or origin not in request.app.config.ALLOWED_ORIGINS:\n    return\nresponse.headers[\"access-control-allow-origin\"] = origin\n```", "```py\napp = Sanic(__name__)\napp.config.ALLOWED_ORIGINS = [\"http://mysite.com\"]\n```", "```py\n    <body>\n        <h1>CORS Testing</h1>\n        <h2 id=\"foobar\">Loading...</h2>\n        <script>\n            const element = document.querySelector(\"#foobar\")\n            fetch(\"http://localhost:7777/\").then(async response => {\n                const text = await response.text()\n                element.innerHTML = `foobar='${response.headers.get(\"foobar\")}'`\n            })\n        </script>\n    </body>\n    ```", "```py\n    @app.get(\"/\")\n    async def handler(request):\n        response = text(\"Hi\")\n        response.headers[\"foobar\"] = \"hello, 123\"\n        return response\n    app.static(\"/test\", \"./test.html\")\n    ```", "```py\n    $ curl localhost:7777 -i\n    HTTP/1.1 200 OK\n    foobar: hello, 123\n    content-length: 2\n    connection: keep-alive\n    content-type: text/plain; charset=utf-8\n    Hi\n    ```", "```py\n    CORS Testing\n    foobar=‘null’\n    ```", "```py\n    response.headers[\"access-control-expose-headers\"] = \"foobar\"\n    ```", "```py\n    app.config.ALLOWED_ORIGINS = [\"http://mysite.com\", \"http://127.0.0.1:7777\"]\n    ```", "```py\n    CORS Testing\n    foobar=‘hello, 123’\n    ```", "```py\nresponse.headers[\"access-control-max-age\"] = 60 * 10\n```", "```py\nresponse.headers[\"access-control-allow-credentials\"] = \"true\"\n```", "```py\nresponse.headers[\n    \"access-control-allow-methods\"\n] = \"get,post,delete,head,patch,put,options\"\n```", "```py\n    @app.on_request\n    async def check_preflight(request: Request) -> None:\n        request.ctx.preflight = is_preflight(request)\n    ```", "```py\n    from functools import partial\n    @app.before_server_start\n    def add_info_handlers(app: Sanic, _):\n        app.router.reset()\n        for group in app.router.groups.values():\n            if \"OPTIONS\" not in group.methods:\n                app.add_route(\n                    handler=partial(\n                        options_handler,\n                        methods=group.methods\n                    ),\n                    uri=group.uri,\n                    methods=[\"OPTIONS\"],\n                    strict_slashes=group.strict,\n                    name=\"options_handler\",\n                )\n        app.router.finalize()\n    ```", "```py\n    async def options_handler(request, methods):\n        resp = response.empty()\n        if request.ctx.preflight:\n            response.headers[\"access-control-allow-credentials\"] = \"true\"\n            resp.headers[\"access-control-allow-methods\"] = \",\".join(methods)\n        return resp\n    ```", "```py\n    $ curl localhost:7777 -X OPTIONS -H \"Origin: http://mysite.com\" -H \"Access-Control-Request-Method: GET\" -i    \n    HTTP/1.1 204 No Content\n    access-control-allow-credentials: true\n    access-control-allow-methods: GET,PATCH,POST\n    vary: origin\n    access-control-allow-origin: http://mysite.com\n    access-control-expose-headers: foobar\n    connection: keep-alive\n    ```", "```py\nfetch(\"http://localhost:7777/\", {\n    headers: {counting: \"1 2 3\"}\n})\n```", "```py\nresp.headers[\"access-control-allow-headers\"] = \"counting\"\n```", "```py\nfetch(\"http://localhost:7777/\", {\n    headers: {origin: \"http://localhost:7777\"}\n})\n```", "```py\n<img src=\"http://yourapplication.com/changepassword?password=kittens123\">\n```", "```py\n<input type=\"hidden\" name=\"csrftoken\" value=\"SOMETOKEN\" />\n```", "```py\n    def csrf_protected(func):\n        def decorator(f):\n            @wraps(f)\n            async def decorated_function(request, *args, **kwargs):\n                response = f(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n                return response\n            return decorated_function\n        return decorator(func)\n    ```", "```py\n    from sanic.exceptions import Forbidden\n    class CSRFFailure(Forbidden):\n        message = \"CSRF Failure. Missing or invalid CSRF token.\"\n    ```", "```py\n    @app.on_request\n    async def check_request(request: Request):\n        request.ctx.from_browser = (\n            \"origin\" in request.headers or\n            \"browser_check\" in request.cookies\n        )\n    @app.on_response\n    async def mark_browser(_, response: HTTPResponse):\n        response.cookies[\"browser_check\"] = \"1\"\n        response.cookies[\"browser_check\"][\"domain\"] = \"mydomain.com\"\n        response.cookies[\"browser_check\"][\"httponly\"] = True\n    ```", "```py\n    origin = request.headers.get(\"origin\")\n    if request.ctx.from_browser and origin not in app.config.ALLOWED_ORIGINS:\n        raise CSRFFailure\n    ```", "```py\n    origin = request.headers.get(\"origin\")\n    if request.ctx.from_browser and (\n        origin not in app.config.ALLOWED_ORIGINS\n        or \"browser_check\" not in request.cookies\n    ):\n        raise CSRFFailure\n    ```", "```py\n    origin = request.headers.get(\"origin\")\n    if request.ctx.from_browser and (\n        origin not in app.config.ALLOWED_ORIGINS\n        or \"browser_check\" not in request.cookies\n        or not csrf_check(request)\n    ):\n        raise CSRFFailure\n    ```", "```py\n    app.config.CSRF_REF_PADDING = 12\n    app.config.CSRF_REF_LENGTH = 18\n    app.config.CSRF_SECRET = \"DZsM9KOs6YAGluhGrEo9oWw4JKTjdiOot9Z4gZ0dGqg=\"\n    ```", "```py\n    from base64 import b64encode\n    from cryptography.fernet import Fernet\n    def generate_csrf(secret, ref_length, padding) -> Tuple[str, str]:\n        cipher = Fernet(secret)\n        ref = os.urandom(ref_length)\n        pad = os.urandom(padding)\n        pretoken = cipher.encrypt(ref)\n        return ref.hex(), b64encode(pad + pretoken).decode(\"utf-8\")\n    ```", "```py\n    def verify_csrf(secret, padding, ref, token):\n        if not ref or not token:\n            raise InvalidToken(\"Token is incorrect\")\n        cipher = Fernet(secret)\n        raw = b64decode(token.encode(\"utf-8\"))\n        pretoken = raw[padding:]\n        encoded_ref = cipher.decrypt(pretoken)\n        if ref != encoded_ref.hex():\n            raise InvalidToken(\"Token is incorrect\")\n    ```", "```py\n    @app.on_response\n    async def inject_csrf_token(request: Request, response: HTTPResponse):\n        if (\n            \"csrf_token\" not in request.cookies\n             or \"ref_token\" not in request.cookies\n        ):\n            ref, token = generate_csrf(\n                request.app.config.CSRF_SECRET,\n                request.app.config.CSRF_REF_LENGTH,\n                request.app.config.CSRF_REF_PADDING,\n            )\n            response.cookies[\"ref_token\"] = ref\n            response.cookies[\"ref_token\"][\"domain\"] = \"localhost\"\n            response.cookies[\"ref_token\"][\"httponly\"] = True\n            response.cookies[\"csrf_token\"] = token\n            response.cookies[\"csrf_token\"][\"domain\"] = \"localhost\"\n    ```", "```py\ndef csrf_check(request: Request):\n    csrf_header = request.headers.get(\"x-xsrf-token\")\n    csrf_cookie = request.cookies.get(\"csrf_token\")\n    ref_token = request.cookies.get(\"ref_token\")\n    if csrf_header != csrf_cookie:\n        raise CSRFFailure\n\n    try:\n        verify_csrf(\n            request.app.config.CSRF_SECRET,\n            request.app.config.CSRF_REF_PADDING,\n            ref_token,\n            csrf_cookie,\n        )\n    except InvalidToken as e:\n        raise CSRFFailure from e\n    return True\n```", "```py\nresponse.cookies[\"myfavorite\"] = \"chocolatechip\"\nresponse.cookies[\"myfavorite\"][\"domain\"] = \"mydomain.com\"\nresponse.cookies[\"myfavorite\"][\"samesite\"] = None\nresponse.cookies[\"myfavorite\"][\"secure\"] = True\n```", "```py\nSet-Cookie: myfavorite=chocolatechip; Path=/; Domain=mydomain.com; SameSite=None; Secure\n```", "```py\nresponse.cookies[\"session_token\"] = session_token\nresponse.cookies[\"session_token\"][\"domain\"] = \"localhost\"\nresponse.cookies[\"session_token\"][\"httponly\"] = True\nresponse.cookies[\"session_token\"][\"samesite\"] = \"lax\"\nresponse.cookies[\"session_token\"][\"secure\"] = True\n```", "```py\nSet-Cookie: session_token=<TOKEN>; Path=/; Domain=localhost; HttpOnly; SameSite=lax; Secure\n```", "```py\nresponse.cookies[\"ref_token\"] = ref\nresponse.cookies[\"ref_token\"][\"domain\"] = \"localhost\"\nresponse.cookies[\"ref_token\"][\"httponly\"] = True\nresponse.cookies[\"ref_token\"][\"samesite\"] = \"strict\"\nresponse.cookies[\"ref_token\"][\"secure\"] = True\nresponse.cookies[\"csrf_token\"] = token\nresponse.cookies[\"csrf_token\"][\"domain\"] = \"localhost\"\nresponse.cookies[\"csrf_token\"][\"samesite\"] = \"strict\"\nresponse.cookies[\"csrf_token\"][\"secure\"] = True\n```", "```py\nSet-Cookie: ref_token=<TOKEN>; Path=/; Domain=localhost; HttpOnly; SameSite=strict; Secure\nSet-Cookie: csrf_token=\"<TOKEN>\"; Path=/; Domain=localhost; SameSite=strict; Secure\n```", "```py\n    from secrets import token_urlsafe\n    from bcrypt import hashpw, gensalt\n    def generate_token():\n        api_key = token_urlsafe()\n        hashed_key = hashpw(api_key.encode(\"utf-8\"), gensalt())\n        return api_key, hashed_key\n    ```", "```py\n    @app.post(\"/apikey\")\n    async def gen_handler(request):\n        api_key, hased_key = generate_token()\n        user = await get_user_from_request(request)\n        await store_hashed_key(user, hased_key)\n        return json({\"api_key\": api_key})\n    ```", "```py\n    from bcrypt import checkpw\n    from sanic.exceptions import Unauthorized\n    def api_key_required(\n        maybe_func=None,\n        *,\n        exception=Unauthorized,\n        message=\"Invalid or unknown API key\"\n    ):\n        def decorator(f):\n            @wraps(f)\n            async def decorated_function(request, *args, **kwargs):\n                user = await get_user_from_request(request)\n                is_valid = checkpw(request.token.encode(\"utf-8\"), user.hashed_key)\n                if not is_valid:\n                    raise exception(message)\n                response = f(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n                return response\n            return decorated_function\n        return decorator(maybe_func) if maybe_func else decorator\n    ```", "```py\n    Authorization: Bearer <token_here>\n    ```", "```py\n    Authorization: Token <token_here>\n    ```", "```py\n    @app.get(\"/protected\")\n    @api_key_required\n    async def protected_handler(request):\n        return text(\"hi\")\n    ```", "```py\nif not is_valid:\n    raise exception(message)\n```", "```py\nif request.ctx.from_browser or not is_valid:\n    raise exception(message)\n```", "```py\n    def session_protected(\n        maybe_func=None,\n        *,\n        exception=Unauthorized,\n        message=\"Invalid or unknown API key\"\n    ):\n        def decorator(f):\n            @wraps(f)\n            async def decorated_function(request, *args, **kwargs):\n                origin = request.headers.get(\"origin\")\n                if request.ctx.from_browser and (\n                    origin not in app.config.ALLOWED_ORIGINS\n                    or \"browser_check\" not in request.cookies\n                    or not csrf_check(request)\n                ):\n                    raise CSRFFailure\n                session_token = request.cookies.get(\"session_token\")\n                if not session_token or not await verify_session(session_token):\n                    raise exception(message)\n                response = f(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n                return response\n            return decorated_function\n        return decorator(maybe_func) if maybe_func else decorator\n    ```", "```py\n    async def verify_session(session_token):\n        try:\n            await get_session_from_database(session_token):\n        except NotFound:\n            return False\n        return True\n    ```", "```py\nAuthentication: Bearer <JWT>\n```", "```py\nconst accessToken = document.cookie\n    .split('; ')\n    .find(row => row.startsWith('access_token='))\n    .split('=')[1]\nfetch(url, {headers: {Authorization: `Bearer ${accessToken}`}})\n```", "```py\n@app.post(\"/login\")\nasync def login(request):\n    user = await authenticate_login_credentials(\n        request.json[\"username\"],\n        request.json[\"password\"],\n    )\n    access_token = generate_access_token(user)\n    response = json({\"payload\": access_token.payload})\n    response.cookies[\"access_token\"] = access_token\n    response.cookies[\"access_token\"][\"domain\"] = \"localhost\"\n    response.cookies[\"access_token\"][\"httponly\"] = True\n    response.cookies[\"access_token\"][\"samesite\"] = \"lax\"\n    response.cookies[\"access_token\"][\"secure\"] = True\n    return response\n```", "```py\n    @app.post(\"/login\")\n    async def login(request):\n        user = await authenticate_login_credentials(\n            request.json[\"username\"],\n            request.json[\"password\"],\n        )\n\n        access_token = generate_access_token(user)\n        refresh_token, hased_key = generate_token()\n        await store_refresh_token(user, hased_key)\n\n        response = json({\"payload\": access_token.payload})\n        response.cookies[\"access_token\"] = access_token\n        response.cookies[\"access_token\"][\"domain\"] = \"localhost\"\n        response.cookies[\"access_token\"][\"httponly\"] = True\n        response.cookies[\"access_token\"][\"samesite\"] = \"lax\"\n        response.cookies[\"access_token\"][\"secure\"] = True\n        response.cookies[\"refresh_token\"] = refresh_token\n        response.cookies[\"refresh_token\"][\"domain\"] = \"localhost\"\n        response.cookies[\"refresh_token\"][\"httponly\"] = True\n        response.cookies[\"refresh_token\"][\"samesite\"] = \"strict\"\n        response.cookies[\"refresh_token\"][\"secure\"] = True\n\n        return response\n    ```", "```py\n    from bcrypt import checkpw\n    from sanic.exceptions import Forbidden\n    from sanic.response import empty\n    @app.post(\"/refresh\")\n    async def refresh_access_token(request):\n        user = await get_user_from_request(request)\n        access_token = request.cookies[\"access_token\"]\n        refresh_token = request.cookies[\"refresh_token\"]\n\n        is_valid_refresh = checkpw(\n            refresh_token.encode(\"utf-8\"),\n            user.refresh_hash\n        )\n        is_valid_access = check_access_token(access_token, allow_expired=True)\n        if not is_valid_refresh or not is_valid_access:\n            return Forbidden(\"Invalid request\")\n        access_token = generate_access_token(user)\n        response = empty()\n        response.cookies[\"access_token\"] = access_token\n        response.cookies[\"access_token\"][\"domain\"] = \"localhost\"\n        response.cookies[\"access_token\"][\"httponly\"] = True\n        response.cookies[\"access_token\"][\"samesite\"] = \"lax\"\n        response.cookies[\"access_token\"][\"secure\"] = True\n        return response\n    ```", "```py\n    from datetime import timedelta\n    app.config.JWT_SECRET = \"somesecret\"\n    app.config.JWT_EXPIRATION = timedelta(minutes=10)\n    app.config.REFRESH_EXPIRATION = timedelta(hours=24)\n    app.config.COOKIE_DOMAIN = \"127.0.0.1\"\n    ```", "```py\n    from dataclasses import dataclass\n    @dataclass\n    class AccessToken:\n        payload: Dict[str, Any]\n        token: str\n        def __str__(self) -> str:\n            return self.token\n        @property\n        def header_payload(self):\n            return self._parts[0]\n        @property\n        def signature(self):\n            return self._parts[0]\n        @property\n        def _parts(self):\n            return self.token.rsplit(\".\", maxsplit=1)\n    ```", "```py\n    import jwt\n    def generate_access_token(user: User, secret: str, exp: int) -> AccessToken:\n        payload = {\n            \"whatever\": \"youwant\",\n            \"exp\": exp,\n        }\n        raw_token = jwt.encode(payload, secret, algorithm=\"HS256\")\n        access_token = AccessToken(payload, raw_token)\n        return access_token\n    To verify the token, we can do the reverse. We do have a use case for when we will accept an expired token (when using the refresh token). Therefore, we need a flag to allow us to skip the check of the exp claim.\n    def check_access_token(\n        access_token: str, secret: str, allow_expired: bool = False\n    ) -> bool:\n        try:\n            jwt.decode(\n                access_token,\n                secret,\n                algorithms=[\"HS256\"],\n                require=[\"exp\"],\n                verify_exp=(not allow_expired),\n            )\n        except jwt.exceptions.InvalidTokenError as e:\n            error_logger.exception(e)\n            return False\n    ```", "```py\n    access_token_exp = datetime.now() + request.app.config.JWT_EXPIRATION\n    refresh_token_exp = datetime.now() + request.app.config.REFRESH_EXPIRATION\n    access_token = generate_access_token(\n        user,\n        request.app.config.JWT_SECRET,\n        int(access_token_exp.timestamp()),\n    )\n    refresh_token, hased_key = generate_token()\n    await store_refresh_token(user, hased_key)\n    response = json({\"payload\": access_token.payload})\n    ```", "```py\n    set_cookie(\n        response,\n        \"access_token\",\n        access_token.header_payload,\n        httponly=False,\n        domain=request.app.config.COOKIE_DOMAIN,\n        exp=access_token_exp,\n    )\n    set_cookie(\n        response,\n        \"access_token\",\n        access_token.signature,\n        httponly=True,\n        domain=request.app.config.COOKIE_DOMAIN,\n        exp=access_token_exp,\n    )\n    set_cookie(\n        response,\n        \"refresh_token\",\n        refresh_token,\n        httponly=True,\n        samesite=\"strict\",\n        domain=request.app.config.COOKIE_DOMAIN,\n        exp=refresh_token_exp,\n    )\n    ```"]