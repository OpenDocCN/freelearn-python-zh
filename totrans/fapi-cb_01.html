<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-21"><a id="_idTextAnchor020"/>1</h1>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>First Steps with FastAPI</h1>
<p>Welcome to the exciting world of <strong class="bold">FastAPI</strong>, a modern, high-performance framework for building APIs and web applications in <strong class="bold">Python</strong>. This first chapter is your gateway to understanding and harnessing the power of FastAPI. Here, you’ll take your initial steps into setting up your development environment, creating your very first FastAPI project, and exploring its fundamental concepts.</p>
<p>FastAPI stands out for its speed, ease of use, and comprehensive documentation, making it a preferred choice for developers looking to build scalable and efficient web applications. In this chapter, you’ll practically engage in setting up FastAPI, learning how to navigate its architecture, and understanding its core components. You’ll gain hands-on experience by defining simple API endpoints, handling HTTP methods, and learning about request and response handling. These foundational skills are crucial for any developer stepping into the world of modern web development with FastAPI.</p>
<p>By the end of this chapter, you will have a solid understanding of FastAPI’s basic structure and capabilities. You’ll be able to set up a new project, define API endpoints, and have a grasp on handling data with FastAPI. This knowledge sets the stage for more advanced topics and complex applications you’ll encounter as you progress through the book.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Setting up your development environment</li>
<li>Creating a new FastAPI project</li>
<li>Understanding FastAPI basics</li>
<li>Defining your first API endpoint</li>
<li>Working with path and query parameters</li>
<li>Defining and using request and response models</li>
<li>Handling errors and exceptions</li>
</ul>
<p>Each recipe is designed to provide you with practical knowledge and direct experience, ensuring that by the end of this chapter, you’ll be well equipped to start building your own FastAPI applications.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Technical requirements</h1>
<p>To embark on your journey with FastAPI, you’ll need to set up an environment that supports Python development and FastAPI’s functionalities. Here’s a list of the technical requirements and installations needed for this chapter:</p>
<ul>
<li><strong class="bold">Python</strong>: FastAPI is built on Python, so you’ll need a Python version compatible with your FastAPI version. You can download the latest version of it from <a href="http://python.org">python.org</a>.</li>
<li><code>pip</code>, Python’s package manager. You can do it by running <code>pip install fastapi</code> from the command terminal.</li>
<li><code>pip </code><code>install uvicorn</code>.</li>
<li><strong class="bold">Integrated development environment (IDE)</strong>: An IDE such as <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), PyCharm, or any other IDE that supports Python development will be necessary for writing and testing your code.</li>
<li><strong class="bold">Postman or Swagger UI</strong>: For testing API endpoints. FastAPI automatically generates and hosts Swagger UI, so you can use it right out of the box.</li>
<li><strong class="bold">Git</strong>: Version control is essential, and Git is a widely used system. If not already installed, you can get it from <a href="http://git-scm.com">git-scm.com</a>.</li>
<li><strong class="bold">GitHub account</strong>: A GitHub account is required to access the code repositories. Sign up at <a href="http://github.com">github.com</a> if you haven’t already.</li>
</ul>
<p>The code used in the chapter is available on GitHub at the following address: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter01">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter01</a>. You can clone or download the repository at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook">https://github.com/PacktPublishing/FastAPI-Cookbook</a> to follow along on your local machine.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Setting up your development environment</h1>
<p>This recipe, dedicated to setting up your development environment, is a critical foundation for any successful project in web development. Here, you’ll learn how to install and configure all the<a id="_idIndexMarker000"/> essential tools needed to start building with FastAPI.</p>
<p>We begin by guiding you through the installation of Python, the core language behind FastAPI. Next, we’ll move on to installing FastAPI itself, along with Uvicorn, a lightning-fast ASGI server, which serves as the bedrock for running your FastAPI applications.</p>
<p>Setting up an IDE is our next stop. Whether you prefer VS Code, PyCharm, or any other Python-friendly IDE, we’ll provide tips to make your development process smoother and more efficient.</p>
<p>Lastly, we’ll introduce you to Git and GitHub – indispensable tools for version control and collaboration in modern software development. Understanding how to use these tools will not only help you manage your code effectively but also open doors to the vast world of community-driven development and resources.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting ready</h2>
<p>FastAPI works with Python, so you need to check your Python version before using it. This is an important step for setting up FastAPI. We will guide you through how to install it.</p>
<h4>Windows installation</h4>
<p>If you work on Windows, follow<a id="_idIndexMarker001"/> these steps to install Python:</p>
<ol>
<li>Visit the official Python website: <a href="http://python.org">python.org</a>.</li>
<li>Download the latest version of Python or any other version higher than 3.9.</li>
<li>Run the installer. Ensure to check the box that says <strong class="bold">Add Python to PATH</strong> before clicking <strong class="bold">Install Now</strong>.</li>
<li>After the installation, open Command Prompt and type <code>python --version</code> to confirm the<a id="_idIndexMarker002"/> installation.</li>
</ol>
<h4>macOS/Linux installation</h4>
<p>macOS usually comes with <a id="_idIndexMarker003"/>Python pre-installed; however, it might not be the latest version.</p>
<p>You can use <code>Homebrew</code> (a package manager for macOS). To install it, open the terminal and run it:</p>
<pre class="console">
$ /bin/bash -c "$(curl –fsSL https://raw.githubusercontent.com/\Homebrew/install/HEAD/install.sh)"</pre> <p>Then, you can install Python – still from the terminal – with the following command:</p>
<pre class="console">
$ brew install python</pre> <p>On Linux, you can install Python using the package manager by running the following command:</p>
<pre class="console">
$ sudo apt-get install python3</pre> <p>That’s all you need to install Python on macOS and Linux systems.</p>
<h4>Checking the installation</h4>
<p>You can then check that <a id="_idIndexMarker004"/>Python is correctly installed by running the following command in the terminal:</p>
<pre class="console">
$ python --version</pre> <p>If you installed it on Linux, the binary command is <code>python3</code>, so you can check that Python is correctly installed by running the following command:</p>
<pre class="console">
$ python3 --version</pre> <p>Once Python is installed, we want to make sure that the Python’s package manager is correctly installed. It comes with Python’s installation, and it’s called <code>pip</code>.</p>
<p>From a terminal window, run the following command:</p>
<pre class="console">
$ pip --version</pre> <p>On Linux, run the following command:</p>
<pre class="console">
$ pip3 --version</pre> <p>Once Python is<a id="_idIndexMarker005"/> installed on your computer, you can now consider installing FastAPI.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>How to do it...</h2>
<p>When you have Python and <code>pip</code> ready, we can continue with installing FastAPI, the IDE. Then, we will configure Git.</p>
<p>We will do it by following these steps:</p>
<ol>
<li>Installing FastAPI and Uvicorn</li>
<li>Setting up your IDE (VS Code or PyCharm)</li>
<li>Setting up Git and GitHub to track your project</li>
</ol>
<h3>Installing FastAPI and Uvicorn</h3>
<p>With Python set up, the <a id="_idIndexMarker006"/>next step is installing FastAPI and Uvicorn. FastAPI is the<a id="_idIndexMarker007"/> framework we’ll use to build our applications, and Uvicorn is an ASGI server that runs and serves our FastAPI applications.</p>
<p>Open your command-line interface and install FastAPI and Uvicorn together by running the following command:</p>
<pre class="console">
$ pip install fastapi[all]</pre> <p>This command installs FastAPI along with its recommended dependencies, including Uvicorn.</p>
<p>To verify the installation, you can simply run <code>uvicorn --version</code> from the terminal.</p>
<h3>Setting up your IDE</h3>
<p>Choosing the right IDE is a crucial step in your FastAPI journey. An IDE is more than just a text editor; it’s a space <a id="_idIndexMarker008"/>where you write, debug, and test your code.</p>
<p>A good IDE can significantly enhance your coding experience and productivity. For FastAPI development and Python in general, two popular choices are VS Code and PyCharm.</p>
<h4>VS Code</h4>
<p><strong class="bold">VS Code</strong> is a free, open<a id="_idIndexMarker009"/> source, lightweight IDE with powerful features. It offers excellent<a id="_idIndexMarker010"/> Python support and is highly customizable.</p>
<p>You can download and install VS Code from the official website (<code>code.visualstudio.com</code>). The installation is quite straightforward. Once installed, open VS Code, go to <code>python</code>. Install the Microsoft version, and that is it.</p>
<h4>PyCharm</h4>
<p><strong class="bold">PyCharm</strong>, created by JetBrains, is specifically <a id="_idIndexMarker011"/>tailored for Python development. It offers a broad range of tools for <a id="_idIndexMarker012"/>professional developers, including excellent support for web development frameworks such as FastAPI.</p>
<p>You can choose between a Community free edition and a Professional paid version. For the scope of the book, the Community Edition is largely sufficient, and it can be downloaded on the JetBrains website: <a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a>.</p>
<p>For PyCharm as well, the installation is straightforward.</p>
<h4>Enhancing your development experience</h4>
<p>For both IDEs – and if you use <a id="_idIndexMarker013"/>another of your choice – make sure to leverage basic perks to improve your experience as a developer and be more efficient. Here is a short checklist that I use when I approach a new IDE environment:</p>
<ul>
<li><strong class="bold">Code completion and analysis</strong>: Good IDEs provide intelligent code completion, error highlighting, and fixes, which are invaluable for efficient development</li>
<li><strong class="bold">Debugging tools</strong>: Utilize debugging features provided by the IDE to diagnose and resolve issues in your code</li>
<li><strong class="bold">Version control integration</strong>: A good IDE offers support for Git, simplifying code change tracking and repository management</li>
<li><strong class="bold">Customization</strong>: Customize<a id="_idIndexMarker014"/> your IDE by adjusting themes, key binding, and settings to match your workflow, making your development experience as comfortable and productive as possible</li>
</ul>
<h3>Setting up Git and GitHub</h3>
<p>Version control is an essential aspect of software development. Git, coupled with GitHub, forms a powerful <a id="_idIndexMarker015"/>toolset for tracking changes, collaborating, and maintaining the history of your projects. You can download the Git installer <a id="_idIndexMarker016"/>from the official website <a href="http://git-scm.com">git-scm.com</a> and install it.</p>
<p>After installation, configure Git with your username and email using the following commands in the command line:</p>
<pre class="console">
$ git config --global user.name "Your Name"
$ git config --global user.email "your.email@example.com"</pre> <p>GitHub is the platform chosen to store code examples used in the book. Sign up for a GitHub account at <a href="http://github.com">github.com</a> if you don’t already have one.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Creating a new FastAPI project</h1>
<p>Setting up a well-organized<a id="_idIndexMarker017"/> project structure is crucial for maintaining a clean code base, especially as your application grows and evolves. This recipe will guide you on how to create your first basic FastAPI project. A structured project simplifies navigation, debugging, and collaboration. For FastAPI, following best practices in structuring can significantly enhance scalability and maintainability.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Getting ready</h2>
<p>All you need to do to follow the recipe is make sure that you have your development environment set up.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>How to do it...</h2>
<p>We begin by making a project <a id="_idIndexMarker018"/>folder named <code>fastapi_start</code> that we’ll use as the root project folder.</p>
<ol>
<li>From the terminal at the root project folder level, we’ll set up our virtual environment by running the following command:<pre class="source-code">
<code>.venv</code> folder that will contain all packages required for the project within our project's root folder.</p></li> <li>Now, you need to activate the environment. If you are on Mac or Linux, run the following command:<pre class="source-code">
<code>(.venv) $</code>. Alternatively, if you check the location of the <code>python</code> binary command, it should be located within the <code>.venv</code> folder. From now on, each time you install a module with <code>pip</code>, it will be installed in the <code>.venv</code> folder, and it will be activated only if the environment is active.</pre></li> <li>Now, you can install the <code>fastapi</code> package with <code>uvicorn</code> in your environment by running the following command:<pre class="source-code">
<code>main.py</code>.</p></li> <li>This file is where your FastAPI application begins. Start by writing the import of the <code>FastAPI</code> module. Then, create an instance of the <code>FastAPI</code> class:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">This instance houses the code of your application.</p></li> <li>Next, define your first route. Routes in FastAPI are like signposts that direct requests to the <a id="_idIndexMarker019"/>appropriate function. Start with a simple route that returns a greeting to the world:<pre class="source-code">
@app.get("/")
def read_root():
    return {"Hello": "World"}</pre><p class="list-inset">You’ve just created the code for your first FastAPI application.</p></li> </ol>
<p>If you want to track the project, you can set up Git as follows:</p>
<ol>
<li>In your project’s root directory, open a terminal or Command Prompt and run the following command:<pre class="source-code">
<code>.gitignore</code> file to specify untracked files to ignore (such as <code>__pychache__</code>, .<code>venv</code>, or IDE-specific folders). You can also have a look at the one on the GitHub repository of the project at the link: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/.gitignore">https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/.gitignore</a>.</p></li> <li>Then, add your files with the following command:<pre class="source-code">
<strong class="bold">$ git add</strong> .</pre></li> <li>Then, commit them using the following command:<pre class="source-code">
<strong class="bold">$ git commit –m "Initial commit"</strong></pre></li> </ol>
<p>And that's it. You are now tracking your project with Git.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>There’s more...</h2>
<p>A well-structured project is not just about neatness; it’s about creating a sustainable and scalable environment where your application can grow and evolve. In FastAPI, this means organizing your <a id="_idIndexMarker020"/>project in a way that separates different aspects of your application logically and efficiently.</p>
<p>There is no unique and perfect structure for a FastAPI project; however, a common approach is to divide your project into several key directories:</p>
<ul>
<li><code>/src</code>: This is where your primary application code lives. Inside <code>/src</code>, you might have subdirectories for different modules of your application. For instance, you could have a <code>models</code> directory for your database models, a <code>routes</code> directory for your FastAPI routes, and a <code>services</code> directory for business logic.</li>
<li><code>/tests</code>: Keeping your tests separate from your application code is a good practice. It makes it easier to manage them and ensures that your production builds don’t include test code.</li>
<li><code>/docs</code>: Documentation is crucial for any project. Whether it’s API documentation, installation guides, or usage instructions, having a dedicated directory for documentation helps maintain clarity.</li>
</ul>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>See also</h2>
<p>You can find detailed information on how to manage virtual environments with <code>venv</code> at the following link:</p>
<ul>
<li><em class="italic">Creation of virtual </em><em class="italic">environments</em>: <a href="https://docs.python.org/3/library/venv.xhtml">https://docs.python.org/3/library/venv.xhtml</a></li>
</ul>
<p>To brush up your knowledge with Git and get familiar with adding, staging and commiting operations, have a look at this guide: </p>
<ul>
<li><em class="italic">Git simple </em><em class="italic">guide</em>: <a href="https://rogerdudler.github.io/git-guide/">https://rogerdudler.github.io/git-guide/</a></li>
</ul>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Understanding FastAPI basics</h1>
<p>As we embark on our journey <a id="_idIndexMarker021"/>with FastAPI, it’s essential to build a solid foundation. FastAPI isn’t just another web framework; it’s a powerful tool designed to make your life as a developer easier, your applications faster, and your code more robust and maintainable.</p>
<p>In this recipe, we’ll demystify the core concepts of FastAPI, delve into its unique features such as asynchronous programming, and guide you through creating and organizing your first endpoints. By the end of the recipe, you’ll have your first FastAPI server up and running – a milestone that marks the beginning of an exciting journey in modern web development.</p>
<p>FastAPI is a modern, fast web framework for building APIs with Python based on standard Python type hints.</p>
<p>Key features that define <a id="_idIndexMarker022"/>FastAPI are the following:</p>
<ul>
<li><strong class="bold">Speed</strong>: It’s one of the fastest frameworks for building APIs in Python, thanks to its underlying Starlette framework for web parts and Pydantic for data handling</li>
<li><strong class="bold">Ease of use</strong>: FastAPI is designed to be easy to use, with intuitive coding that accelerates your development time</li>
<li><strong class="bold">Automatic documentation</strong>: With FastAPI, the API documentation is generated automatically, a feature that is both a time-saver and a boon for developers</li>
</ul>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>How to do it…</h2>
<p>We will now explore how to use those features effectively with some general guidance.</p>
<p>We will go through the following steps:</p>
<ul>
<li>Applying asynchronous programming to our existing endpoints to improve time efficiency</li>
<li>Exploring routers and endpoints to better organize large code bases</li>
<li>Running your first FastAPI server with a basic configuration</li>
<li>Exploring the automatic documentation</li>
</ul>
<h3>Applying asynchronous programming</h3>
<p>One of the most powerful features of FastAPI is its support for asynchronous programming. This allows your applications to handle more requests simultaneously, making them more<a id="_idIndexMarker023"/> efficient. Asynchronous programming is a style of concurrent programming in which tasks are executed without blocking the execution of other tasks, improving the overall performance of your application. To integrate asynchronous programming smoothly, FastAPI leverages the <code>async</code>/<code>await</code> syntax (<a href="https://fastapi.tiangolo.com/async/">https://fastapi.tiangolo.com/async/</a>) and automatically integrates asynchronous functions.</p>
<p>So, the <code>read_root()</code> function in <code>main.py</code> from the previous code snippet in the <em class="italic">Creating a new FastAPI project</em> recipe can be written as follows:</p>
<pre class="source-code">
@app.get("/")
<strong class="bold">async def read_root():</strong>
    return {"Hello": "World"}</pre> <p>In this case, the behavior of the code will be exactly the same as before.</p>
<h3>Exploring routers and endpoints</h3>
<p>In FastAPI, organizing your code into routers and endpoints is a fundamental practice. This organization helps in making your code cleaner and more modular.</p>
<h4>Endpoints</h4>
<p>Endpoints are the points at <a id="_idIndexMarker024"/>which API interactions happen. In FastAPI, an endpoint is created by decorating a function with an HTTP method, such as <code>@app.get("/")</code>.</p>
<p>This signifies a <code>GET</code> request to the root of your application.</p>
<p>Consider the following code snippet:</p>
<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/")
async def read_root():
    return {"Hello": "World"}</pre> <p>In this snippet, we <a id="_idIndexMarker025"/>define an endpoint for the root URL (<code>"/"</code>). When a <code>GET</code> request is made to this URL, the <code>read_root</code> function is invoked, returning a JSON response.</p>
<h4>Routers</h4>
<p>When we need to handle <a id="_idIndexMarker026"/>multiple endpoints that are in different files, we can benefit from using routers. Routers assist us in grouping our endpoints into different modules, which makes our code base easier to maintain and understand. For example, we could use one router for operations related to users and another for operations related to products.</p>
<p>To define a router, first create a new file in the <code>fastapi_start</code> folder called <code>router_example.py</code>. Then, create the router as follows:</p>
<pre class="source-code">
from fastapi import APIRouter
router = APIRouter()
@router.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}</pre> <p>You can now reuse it and attach the router to the FastAPI server instance in <code>main.py</code>:</p>
<pre class="source-code">
<strong class="bold">import router_example</strong>
from fastapi import FastAPI
app = FastAPI()
<strong class="bold">app.include_router(router_example.router)</strong>
@app.get("/")
async def read_root():
    return {"Hello": "World"}</pre> <p>You now have the code to <a id="_idIndexMarker027"/>run the server that includes the router for the <code>GET /items</code> endpoint importer from another module.</p>
<h3>Running your first FastAPI server</h3>
<p>To run your FastAPI application, you<a id="_idIndexMarker028"/> need to point Uvicorn to your app instance. If your file is named <code>main.py</code> and your FastAPI instance is called <code>app</code>, you can start your server like this at the <code>fastapi_start</code> folder level:</p>
<pre class="console">
$ uvicorn main:app --reload</pre> <p>The <code>--reload</code> flag makes the server restart after code changes, making it ideal for development.</p>
<p>Once the server is running, you can access your API at <code>http://127.0.0.1:8000</code>. If you visit this URL in your browser, you’ll see the JSON response from the <code>"/"</code> endpoint we have just created.</p>
<h3>Exploring the automatic documentation</h3>
<p>One of the most exciting features of FastAPI is its <a id="_idIndexMarker029"/>automatic documentation. When you run your FastAPI application, two documentation interfaces are automatically generated: <strong class="bold">Swagger UI</strong> and <strong class="bold">Redoc</strong>.</p>
<p>You can access these at <code>http://127.0.0.1:8000/docs</code> for Swagger UI and <code>http://127.0.0.1:8000/redoc</code> for Redoc.</p>
<p>These interfaces provide an interactive way to explore your API and test its functionality.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>See also</h2>
<p>You can discover more about what we covered in the recipe at the following links:</p>
<ul>
<li><em class="italic">First </em><em class="italic">Steps</em>: <a href="https://fastapi.tiangolo.com/tutorial/first-steps/">https://fastapi.tiangolo.com/tutorial/first-steps/</a></li>
<li><em class="italic">Docs </em><em class="italic">URLs</em>: <a href="https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls">https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls</a></li>
<li><em class="italic">Concurrency and async / </em><em class="italic">await</em>: <a href="https://fastapi.tiangolo.com/async/">https://fastapi.tiangolo.com/async/</a></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Defining your first API endpoint</h1>
<p>Now that you have a fundamental grasp of FastAPI and your development environment is all set up, it’s time to take the <a id="_idIndexMarker030"/>next thrilling step: creating your first API endpoint.</p>
<p>This is where the real magic of FastAPI begins to shine. You’ll see how effortlessly you can build a functional API endpoint, ready to respond to HTTP requests.</p>
<p>In this recipe, you will create a basic draft of a backend service for a bookstore.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Getting ready</h2>
<p>Make sure you know how to start a basic FastAPI project from the <em class="italic">Creating a new FastAPI </em><em class="italic">project</em> recipe.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>How to do it...</h2>
<p>In the realm of web APIs, the <code>GET</code> request is perhaps the most common. It’s used to retrieve data from the server. In FastAPI, handling a <code>GET</code> request is simple and intuitive. Let’s create a basic <code>GET</code> endpoint.</p>
<p>Imagine you’re building an API for a bookstore. Your first endpoint will provide information about a book when given its ID. Here’s how you do it:</p>
<ol>
<li>Create a new <code>bookstore</code> folder that will contain the code you are going to write.</li>
<li>Create in it a <code>main.py</code> file containing the server instance:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/books/{book_id}")
async def read_book(book_id: int):
    return {
        "book_id": book_id,
        "title": "The Great Gatsby",
        "author": "F. Scott Fitzgerald"
    }</pre></li> </ol>
<p>In the preceding code snippet, the <code>@app.get("/books/{book_id}")</code> decorator tells FastAPI that this function will respond to <code>GET</code> requests at the <code>/books/{book_id}</code> path. <code>{book_id}</code> in the path is a path parameter, which you can use to pass values dynamically. FastAPI<a id="_idIndexMarker031"/> automatically extracts the <code>book_id</code> parameter and passes it to your function.</p>
<p class="callout-heading">Type hints and automatic data validation</p>
<p class="callout">Notice the use of type hints (<code>book_id: int</code>). FastAPI uses these hints to perform data validation. If a request is made with a non-integer <code>book_id</code> parameter, FastAPI automatically sends a helpful error response.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>How it works…</h2>
<p>With your <code>GET</code> endpoint defined, run your FastAPI application using Uvicorn, just as you did previously:</p>
<pre class="console">
$ uvicorn main:app --reload</pre> <p>On the terminal, you can read the message logs describing that the server is running on port <code>8000</code>.</p>
<p>One of FastAPI’s most beloved features is its automatic generation of interactive API documentation using <a id="_idIndexMarker032"/>Swagger UI. This tool allows you to test your API endpoints directly from your browser without writing any additional code, and you can directly check the presence of the newly created endpoint in i<a id="_idTextAnchor038"/>t.</p>
<h3>Using Swagger UI</h3>
<p>To test your new <code>GET</code> endpoint, navigate to <code>http://127.0.0.1:8000/docs</code> in your browser. This URL brings up the <a id="_idIndexMarker033"/>Swagger UI documentation for your FastAPI application. Here, you’ll see your <code>/books/{book_id}</code> endpoint listed. Click <a id="_idIndexMarker034"/>on it, and you’ll be able to execute a test request right from the interface. Try inputting a book ID and see the response your API generates.</p>
<h3>Postman – a versatile alternative</h3>
<p>While Swagger UI is convenient <a id="_idIndexMarker035"/>for quick tests, you might want to use a more robust tool such as Postman for more complex scenarios. Postman is an API client that lets you build, test, and document your<a id="_idIndexMarker036"/> APIs more extensively.</p>
<p>To use Postman, download and install it from Postman’s website (<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>).</p>
<p>Once installed, create a new request. Set the method to <code>GET</code> and the request URL to your FastAPI endpoint, <code>http://127.0.0.1:8000/books/1</code>. Hit <strong class="bold">Send</strong>, and Postman will display the response from your FastAPI server.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Working with path and query parameters</h1>
<p>One of the most <a id="_idIndexMarker037"/>crucial aspects of API development is handling parameters. Parameters<a id="_idIndexMarker038"/> allow your API to accept input from users, making your endpoints dynamic and responsive.</p>
<p>In this recipe, we will explore how to capture and handle path, query parameters, and test them efficiently, enhancing the flexibility and functionality of your FastAPI applications.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Getting ready</h2>
<p>To follow the recipe, make sure you know how to create a basic endpoint from the previous recipe.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>How to do it…</h2>
<p>Path parameters are<a id="_idIndexMarker039"/> parts of the URL that are expected to change. For instance, in an endpoint such as <code>/books/{book_id}</code>, <code>book_id</code> is a path parameter. FastAPI allows you to capture these parameters effortlessly and use them in your function.</p>
<ol>
<li>Let’s expand our bookstore API with a new endpoint that uses path parameters. This time, we’ll create<a id="_idIndexMarker040"/> a route to get information about a specific author:<pre class="source-code">
@app.get("/authors/{author_id}")
async def read_author(author_id: int):
    return {
        "author_id": author_id,
        "name": "Ernest Hemingway"
    }</pre><p class="list-inset">The name will not change; however, the <code>author_id</code> value will be the one provided by the query request.</p><p class="list-inset">Query parameters are used to refine or customize the response of an API endpoint. They can be included in the URL after a question mark (<code>?</code>). For instance, <code>/books?genre=fiction&amp;year=2010</code> might return only books that fall under the fiction genre released in 2010.</p></li> <li>Let’s add query parameters to our existing endpoint. Suppose we want to allow users to filter books by<a id="_idIndexMarker041"/> their publication year:<pre class="source-code">
@app.get("/books")
async def read_books(year: int = None):
    if year:
        return {
            "year": year,
            "books": ["Book 1", "Book 2"]
        }
    return {"books": ["All Books"]}</pre></li> </ol>
<p>Here, <code>year</code> is an optional<a id="_idIndexMarker042"/> query parameter. By assigning <code>None</code> as a default value, we make it optional. If a year is specified, the endpoint returns books from that year; otherwise, it returns all books.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">Using the <code>APIRouter</code> class, refactor each endpoint in a separate file and add the route to the FastAPI server.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>How it works…</h2>
<p>Now, from the command terminal, spin up the server with Uvicorn by running the following command:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Testing endpoints with path parameters can be done using Swagger UI or Postman, similar to how we tested our basic <code>GET</code> endpoint.</p>
<p>In Swagger UI, at <code>http://localhost:8000/docs</code>, navigate to your <code>/authors/{author_id}</code> endpoint. You’ll notice that it prompts you to enter an <code>author_id</code> value before you can try it out. Enter a valid integer and execute the request. You should see a response with the author’s information.</p>
<p>The <code>GET /books</code> endpoint will now show an optional field for the <code>year</code> query parameter. You can test it by entering different years and observing the varying responses.</p>
<p>If you use Postman instead, create a new <code>GET</code> request with the <code>http://127.0.0.1:8000/authors/1</code> URL. Sending this request should yield a similar response.</p>
<p>In Postman, append the query parameter to the URL like so: <code>http://127.0.0.1:8000/books?year=2021</code>. Sending<a id="_idIndexMarker043"/> this request should return books published in the year 2021.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>See also</h2>
<p>You can find more <a id="_idIndexMarker044"/>about path and query parameters in the FastAPI official documentation at the following links:</p>
<ul>
<li><em class="italic">Path </em><em class="italic">Parameters</em>: <a href="https://fastapi.tiangolo.com/tutorial/path-params/">https://fastapi.tiangolo.com/tutorial/path-params/</a></li>
<li><em class="italic">Query </em><em class="italic">Parameters</em>: <a href="https://fastapi.tiangolo.com/tutorial/query-params/">https://fastapi.tiangolo.com/tutorial/query-params/</a></li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Defining and using request and response models</h1>
<p>In the world of API development, data handling is a critical aspect that determines the robustness and reliability of your application. FastAPI simplifies this process through its seamless integration with <strong class="bold">Pydantic</strong>, a data <a id="_idIndexMarker045"/>validation and settings management library using Python type annotations. The recipe will show you how to define and use request and response models in FastAPI, ensuring your data is well structured, validated, and clearly defined.</p>
<p>Pydantic models are a<a id="_idIndexMarker046"/> powerful feature for data validation and conversion. They allow you to define the structure, type, and constraints of the data your application handles, both for incoming requests and outgoing responses.</p>
<p>In this recipe, we will see how to use Pydantic to ensure that your data conforms to the specified schema, providing an automatic layer of safety and clarity.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Getting ready</h2>
<p>This recipe requires you to know how to set up a basic endpoint in FastAPI.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>How to do it...</h2>
<p>We will break the <a id="_idIndexMarker047"/>process into the following steps:</p>
<ol>
<li>Creating the model</li>
<li>Defining the request body</li>
<li>Validating request data</li>
<li>Managing response formats</li>
</ol>
<h3>Creating the model</h3>
<p>Let’s create a Pydantic<a id="_idIndexMarker048"/> <code>BaseModel</code> class for our bookstore application in a new file called <code>models.py</code>.</p>
<p>Suppose we want to have a model for a book that includes the title, author, and publication year:</p>
<pre class="source-code">
from pydantic import BaseModel
class Book(BaseModel):
    title: str
    author: str
    year: int</pre> <p>Here, <code>Book</code> is a Pydantic <code>BaseModel</code> class with three fields: <code>title</code>, <code>author</code>, and <code>year</code>. Each field is typed, ensuring that any data conforming to this model will have these attributes with the specified data types.</p>
<h3>Defining the request body</h3>
<p>In FastAPI, Pydantic models are not just for validation. They also serve as the request body. Let’s add an<a id="_idIndexMarker049"/> endpoint to our application where users can add new books:</p>
<pre class="source-code">
from models import Book
@app.post("/book")
async def create_book(book: Book):
    return book</pre> <p>In this endpoint, when a user sends a <code>POST</code> request to the <code>/book</code> endpoint with JSON data, FastAPI automatically parses and validates it against the <code>Book</code> model. If the data is invalid, the user gets an automatic error response.</p>
<h3>Validating request data</h3>
<p>Pydantic offers advanced<a id="_idIndexMarker050"/> validation features. For instance, you can add regex validations, default values, and more:</p>
<pre class="source-code">
from pydantic import BaseModel<strong class="bold">, Field</strong>
class Book(BaseModel):
    title: str <strong class="bold">= Field(..., min_length=1, max_length=100)</strong>
    author: str <strong class="bold">= Field(..., min_length=1, max_length=50)</strong>
    year: int <strong class="bold">= Field(..., gt=1900, lt=2100)</strong></pre> <p>For an exhaustive list of validation features, have a look at Pydantic’s official documentation: <a href="https://docs.pydantic.dev/latest/concepts/fields/">https://docs.pydantic.dev/latest/concepts/fields/</a>.</p>
<p>Next, you can proceed to manage the response format.</p>
<h3>Managing response formats</h3>
<p>FastAPI allows you to define response models explicitly, ensuring that the data returned by your API matches a specific schema. This can be particularly useful for filtering out sensitive data or restructuring the response.</p>
<p>For example, let’s say you want the <code>/allbooks</code> <code>GET</code> endpoint to return a list of books, but only with their titles <a id="_idIndexMarker051"/>and authors, omitting the publication year. In <code>main.py</code>, add the following accordingly:</p>
<pre class="source-code">
from pydantic import BaseModel
class BookResponse(BaseModel):
    title: str
    author: str
@app.get("/allbooks")
async def read_all_books() -&gt; list[BookResponse]:
    return [
        {
            "id": 1,
            "title": "1984",
            "author": "George Orwell"},
        {
            "id": 1,
            "title": "The Great Gatsby",
            "author": "F. Scott Fitzgerald",
        },
    ]</pre> <p>Here, the <code>-&gt; list[BookResponse]</code> function type hint tells FastAPI to use the <code>BookResponse</code> model for responses, ensuring that only the title and author fields are included in the response JSON. Alternatively, you can specify the response type in the endpoint decorator’s <a id="_idIndexMarker052"/>arguments as follows:</p>
<pre class="source-code">
@app.get("/allbooks", response_model= list[BookResponse])
async def read_all_books() -&gt; Any:
# rest of the endpoint content</pre> <p>The <code>response_model</code> argument takes priority and can be used instead of the type hint to resolve type checker issues that may occur.</p>
<p>Check the documentation at <code>http://127.0.0.1:8000/docs</code>. Unroll the <code>/allbooks</code> endpoint details, and you will notice the example value response based on the schema as follows:</p>
<pre class="source-code">
[
  {
    "title": "string",
    "author": "string"
  }
]</pre> <p>By mastering Pydantic models in FastAPI, you are now capable of handling complex data structures with ease and precision. You’ve learned to define request bodies and manage response formats, ensuring data consistency and integrity throughout your application.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>See also</h2>
<p><strong class="bold">Pydantic</strong> is a standalone <a id="_idIndexMarker053"/>project largely used for data validation in Python with many more features than what the recipe has shown. Feel free to have a look at the official documentation at the following link:</p>
<ul>
<li><em class="italic">Pydantic</em>: <a href="https://docs.pydantic.dev/latest/">https://docs.pydantic.dev/latest/</a></li>
</ul>
<p>You can see more on response model usage at the FastAPI official documentation link:</p>
<ul>
<li><em class="italic">Response Model - Return </em><em class="italic">Type</em>: <a href="https://fastapi.tiangolo.com/tutorial/response-model/">https://fastapi.tiangolo.com/tutorial/response-model/</a></li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Handling errors and exceptions</h1>
<p>Error handling is an essential aspect of developing robust and reliable web applications. In FastAPI, managing errors and <a id="_idIndexMarker054"/>exceptions is not just about catching unexpected issues but also about proactively designing your application to respond to various error scenarios gracefully.</p>
<p>This recipe will guide you through custom error handling, validating data and handling exceptions, and testing these scenarios to ensure your FastAPI applications are resilient and user-friendly.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>How to do it…</h2>
<p>FastAPI provides built-in support for handling exceptions and errors.</p>
<p>When an error occurs, FastAPI returns a JSON response containing details about the error, which is very useful for debugging. However, there are situations where you might want to customize these error responses for better user experience or security.</p>
<p>Let’s create a custom error handler that catches a specific type of error and returns a custom response. For instance, if a requested resource is not found, you might want to return a more friendly error message.</p>
<p>To do it, in the <code>main.py</code> file, add the following code accordingly:</p>
<pre class="source-code">
from fastapi import FastAPI, HTTPException
from starlette.responses import JSONResponse
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "message": "Oops! Something went wrong"
        },
    )</pre> <p>In this example, the <code>http_exception_handler</code> function will be used to handle <code>HTTPException</code> errors. Whenever<a id="_idIndexMarker055"/> an <code>HTTPException</code> error is raised anywhere in your application, FastAPI will use this handler to return a custom response.</p>
<p>You can test the response by creating a new endpoint that raises an HTTP exception:</p>
<pre class="source-code">
@app.get("/error_endpoint")
async def raise_exception():
    raise HTTPException(status_code=400)</pre> <p>The endpoint will explicitly throw the HTTP error response to showcase the customized message defined in the previous step.</p>
<p>Now, spin the server from the command line with the following command:</p>
<pre class="source-code">
<code>http://localhost:8000/error_endpoint</code>, and you will have a JSON response like this:</p>
<pre class="source-code">
{
    "message": "Oops! Something went wrong"
}</pre> <p>The response returns the default message we defined for any HTTP exception returned by the code.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>There’s more…</h2>
<p>As discussed in the previous recipe, <em class="italic">Defining and using request and response models</em>, FastAPI uses Pydantic models for data validation. When a request is made with data that does not conform to the defined model, FastAPI automatically raises an exception and returns<a id="_idIndexMarker056"/> an error response.</p>
<p>In some cases, you might want to customize the response for validation errors. FastAPI makes this quite straightforward:</p>
<pre class="source-code">
import json
from fastapi import Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    return PlainTextResponse(
        "This is a plain text response:"
        f" \n{json.dumps(exc.errors(), indent=2)}",
        status_code=status.HTTP_400_BAD_REQUEST,
    )</pre> <p>This custom handler will catch any <code>RequestValidationError</code> error and return a plain text response with the details of the error.</p>
<p>If you try, for example, to call the <code>POST /book</code> endpoint with a number type of <code>title</code> instead of a <a id="_idIndexMarker057"/>string, you will get a response with a status code of <code>400</code> and body:</p>
<pre class="source-code">
This is a plain text response:
[
  {
    "type": "string_type",
    "loc": [
      "body",
      "author"
    ],
    "msg": "Input should be a valid string",
    "input": 3,
    "url": "https://errors.pydantic.dev/2.5/v/string_type"
  },
  {
    "type": "greater_than",
    "loc": [
      "body",
      "year"
    ],
    "msg": "Input should be greater than 1900",
    "input": 0,
    "ctx": {
      "gt": 1900
    },
    "url": "https://errors.pydantic.dev/2.5/v/greater_than"
  }
]</pre> <p>You can also, for example, mask the message to add a layer of security to protect from unwanted users using it incorrectly.</p>
<p>This is all you need to customize responses when a request validation error occurs.</p>
<p>You will use this basic <a id="_idIndexMarker058"/>knowledge as you move to the next chapter. <a href="B21025_02.xhtml#_idTextAnchor052"><em class="italic">Chapter 2</em></a> will teach you more about data management in web applications, showing you how to set up and use SQL and NoSQL databases and stressing data security. This will not only improve your technical skills but also increase your awareness of creating scalable and reliable FastAPI applications.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>See also</h2>
<p>You can find more information about customizing errors and exceptions using FastAPI in the official documentation:</p>
<ul>
<li><em class="italic">Handling </em><em class="italic">Errors</em>: <a href="https://fastapi.tiangolo.com/tutorial/handling-errors/">https://fastapi.tiangolo.com/tutorial/handling-errors/</a></li>
</ul>
</div>
</div></body></html>