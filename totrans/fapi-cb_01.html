<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer005">
<h1 class="chapter-number" id="_idParaDest-21"><a id="_idTextAnchor020"/>1</h1>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>First Steps with FastAPI</h1>
<p>Welcome to the exciting world of <strong class="bold">FastAPI</strong>, a modern, high-performance framework for building APIs and web applications in <strong class="bold">Python</strong>. This first chapter is your gateway to understanding and harnessing the power of FastAPI. Here, you’ll take your initial steps into setting up your development environment, creating your very first FastAPI project, and exploring its <span class="No-Break">fundamental concepts.</span></p>
<p>FastAPI stands out for its speed, ease of use, and comprehensive documentation, making it a preferred choice for developers looking to build scalable and efficient web applications. In this chapter, you’ll practically engage in setting up FastAPI, learning how to navigate its architecture, and understanding its core components. You’ll gain hands-on experience by defining simple API endpoints, handling HTTP methods, and learning about request and response handling. These foundational skills are crucial for any developer stepping into the world of modern web development <span class="No-Break">with FastAPI.</span></p>
<p>By the end of this chapter, you will have a solid understanding of FastAPI’s basic structure and capabilities. You’ll be able to set up a new project, define API endpoints, and have a grasp on handling data with FastAPI. This knowledge sets the stage for more advanced topics and complex applications you’ll encounter as you progress through <span class="No-Break">the book.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Setting up your <span class="No-Break">development environment</span></li>
<li>Creating a new <span class="No-Break">FastAPI project</span></li>
<li>Understanding <span class="No-Break">FastAPI basics</span></li>
<li>Defining your first <span class="No-Break">API endpoint</span></li>
<li>Working with path and <span class="No-Break">query parameters</span></li>
<li>Defining and using request and <span class="No-Break">response models</span></li>
<li>Handling errors <span class="No-Break">and exceptions</span></li>
</ul>
<p>Each recipe is designed to provide you with practical knowledge and direct experience, ensuring that by the end of this chapter, you’ll be well equipped to start building your own <span class="No-Break">FastAPI applications.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Technical requirements</h1>
<p>To embark on your journey with FastAPI, you’ll need to set up an environment that supports Python development and FastAPI’s functionalities. Here’s a list of the technical requirements and installations needed for <span class="No-Break">this chapter:</span></p>
<ul>
<li><strong class="bold">Python</strong>: FastAPI is built on Python, so you’ll need a Python version compatible with your FastAPI version. You can download the latest version of it <span class="No-Break">from </span><a href="http://python.org"><span class="No-Break">python.org</span></a><span class="No-Break">.</span></li>
<li><strong class="bold">FastAPI</strong>: Install FastAPI using <strong class="source-inline">pip</strong>, Python’s package manager. You can do it by running <strong class="source-inline">pip install fastapi</strong> from the <span class="No-Break">command terminal.</span></li>
<li><strong class="bold">Uvicorn</strong>: FastAPI requires an <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) server, and Uvicorn is a lightning-fast ASGI server implementation. Install it using <strong class="source-inline">pip </strong><span class="No-Break"><strong class="source-inline">install uvicorn</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Integrated development environment (IDE)</strong>: An IDE such as <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), PyCharm, or any other IDE that supports Python development will be necessary for writing and testing <span class="No-Break">your code.</span></li>
<li><strong class="bold">Postman or Swagger UI</strong>: For testing API endpoints. FastAPI automatically generates and hosts Swagger UI, so you can use it right out of <span class="No-Break">the box.</span></li>
<li><strong class="bold">Git</strong>: Version control is essential, and Git is a widely used system. If not already installed, you can get it <span class="No-Break">from </span><a href="http://git-scm.com"><span class="No-Break">git-scm.com</span></a><span class="No-Break">.</span></li>
<li><strong class="bold">GitHub account</strong>: A GitHub account is required to access the code repositories. Sign up at <a href="http://github.com">github.com</a> if you <span class="No-Break">haven’t already.</span></li>
</ul>
<p>The code used in the chapter is available on GitHub at the following address: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter01">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter01</a>. You can clone or download the repository at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook">https://github.com/PacktPublishing/FastAPI-Cookbook</a> to follow along on your <span class="No-Break">local machine.</span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Setting up your development environment</h1>
<p>This recipe, dedicated to setting up your development environment, is a critical foundation for any successful project in web development. Here, you’ll learn how to install and configure all the<a id="_idIndexMarker000"/> essential tools needed to start building <span class="No-Break">with FastAPI.</span></p>
<p>We begin by guiding you through the installation of Python, the core language behind FastAPI. Next, we’ll move on to installing FastAPI itself, along with Uvicorn, a lightning-fast ASGI server, which serves as the bedrock for running your <span class="No-Break">FastAPI applications.</span></p>
<p>Setting up an IDE is our next stop. Whether you prefer VS Code, PyCharm, or any other Python-friendly IDE, we’ll provide tips to make your development process smoother and <span class="No-Break">more efficient.</span></p>
<p>Lastly, we’ll introduce you to Git and GitHub – indispensable tools for version control and collaboration in modern software development. Understanding how to use these tools will not only help you manage your code effectively but also open doors to the vast world of community-driven development <span class="No-Break">and resources.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting ready</h2>
<p>FastAPI works with Python, so you need to check your Python version before using it. This is an important step for setting up FastAPI. We will guide you through how to <span class="No-Break">install it.</span></p>
<h4>Windows installation</h4>
<p>If you work on Windows, follow<a id="_idIndexMarker001"/> these steps to <span class="No-Break">install Python:</span></p>
<ol>
<li>Visit the official Python <span class="No-Break">website: </span><a href="http://python.org"><span class="No-Break">python.org</span></a><span class="No-Break">.</span></li>
<li>Download the latest version of Python or any other version higher <span class="No-Break">than 3.9.</span></li>
<li>Run the installer. Ensure to check the box that says <strong class="bold">Add Python to PATH</strong> before clicking <span class="No-Break"><strong class="bold">Install Now</strong></span><span class="No-Break">.</span></li>
<li>After the installation, open Command Prompt and type <strong class="source-inline">python --version</strong> to confirm <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker002"/></span><span class="No-Break"> installation.</span></li>
</ol>
<h4>macOS/Linux installation</h4>
<p>macOS usually comes with <a id="_idIndexMarker003"/>Python pre-installed; however, it might not be the <span class="No-Break">latest version.</span></p>
<p>You can use <strong class="source-inline">Homebrew</strong> (a package manager for macOS). To install it, open the terminal and <span class="No-Break">run it:</span></p>
<pre class="console">
$ /bin/bash -c "$(curl –fsSL https://raw.githubusercontent.com/\Homebrew/install/HEAD/install.sh)"</pre> <p>Then, you can install Python – still from the terminal – with the <span class="No-Break">following command:</span></p>
<pre class="console">
$ brew install python</pre> <p>On Linux, you can install Python using the package manager by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ sudo apt-get install python3</pre> <p>That’s all you need to install Python on macOS and <span class="No-Break">Linux systems.</span></p>
<h4>Checking the installation</h4>
<p>You can then check that <a id="_idIndexMarker004"/>Python is correctly installed by running the following command in <span class="No-Break">the terminal:</span></p>
<pre class="console">
$ python --version</pre> <p>If you installed it on Linux, the binary command is <strong class="source-inline">python3</strong>, so you can check that Python is correctly installed by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ python3 --version</pre> <p>Once Python is installed, we want to make sure that the Python’s package manager is correctly installed. It comes with Python’s installation, and it’s <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">.</span></p>
<p>From a terminal window, run the <span class="No-Break">following command:</span></p>
<pre class="console">
$ pip --version</pre> <p>On Linux, run the <span class="No-Break">following command:</span></p>
<pre class="console">
$ pip3 --version</pre> <p>Once Python is<a id="_idIndexMarker005"/> installed on your computer, you can now consider <span class="No-Break">installing FastAPI.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>How to do it...</h2>
<p>When you have Python and <strong class="source-inline">pip</strong> ready, we can continue with installing FastAPI, the IDE. Then, we will <span class="No-Break">configure Git.</span></p>
<p>We will do it by following <span class="No-Break">these steps:</span></p>
<ol>
<li>Installing FastAPI <span class="No-Break">and Uvicorn</span></li>
<li>Setting up your IDE (VS Code <span class="No-Break">or PyCharm)</span></li>
<li>Setting up Git and GitHub to track <span class="No-Break">your project</span></li>
</ol>
<h3>Installing FastAPI and Uvicorn</h3>
<p>With Python set up, the <a id="_idIndexMarker006"/>next step is installing FastAPI and Uvicorn. FastAPI is the<a id="_idIndexMarker007"/> framework we’ll use to build our applications, and Uvicorn is an ASGI server that runs and serves our <span class="No-Break">FastAPI applications.</span></p>
<p>Open your command-line interface and install FastAPI and Uvicorn together by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ pip install fastapi[all]</pre> <p>This command installs FastAPI along with its recommended dependencies, <span class="No-Break">including Uvicorn.</span></p>
<p>To verify the installation, you can simply run <strong class="source-inline">uvicorn --version</strong> from <span class="No-Break">the terminal.</span></p>
<h3>Setting up your IDE</h3>
<p>Choosing the right IDE is a crucial step in your FastAPI journey. An IDE is more than just a text editor; it’s a space <a id="_idIndexMarker008"/>where you write, debug, and test <span class="No-Break">your code.</span></p>
<p>A good IDE can significantly enhance your coding experience and productivity. For FastAPI development and Python in general, two popular choices are VS Code <span class="No-Break">and PyCharm.</span></p>
<h4>VS Code</h4>
<p><strong class="bold">VS Code</strong> is a free, open<a id="_idIndexMarker009"/> source, lightweight IDE with powerful features. It offers excellent<a id="_idIndexMarker010"/> Python support and is <span class="No-Break">highly customizable.</span></p>
<p>You can download and install VS Code from the official website (<strong class="source-inline">code.visualstudio.com</strong>). The installation is quite straightforward. Once installed, open VS Code, go to <strong class="bold">Extensions</strong> (a square icon on the left bar), and search for <strong class="source-inline">python</strong>. Install the Microsoft version, and that <span class="No-Break">is it.</span></p>
<h4>PyCharm</h4>
<p><strong class="bold">PyCharm</strong>, created by JetBrains, is specifically <a id="_idIndexMarker011"/>tailored for Python development. It offers a broad range of tools for <a id="_idIndexMarker012"/>professional developers, including excellent support for web development frameworks such <span class="No-Break">as FastAPI.</span></p>
<p>You can choose between a Community free edition and a Professional paid version. For the scope of the book, the Community Edition is largely sufficient, and it can be downloaded on the JetBrains <span class="No-Break">website: </span><a href="https://www.jetbrains.com/pycharm/download/"><span class="No-Break">https://www.jetbrains.com/pycharm/download/</span></a><span class="No-Break">.</span></p>
<p>For PyCharm as well, the installation <span class="No-Break">is straightforward.</span></p>
<h4>Enhancing your development experience</h4>
<p>For both IDEs – and if you use <a id="_idIndexMarker013"/>another of your choice – make sure to leverage basic perks to improve your experience as a developer and be more efficient. Here is a short checklist that I use when I approach a new <span class="No-Break">IDE environment:</span></p>
<ul>
<li><strong class="bold">Code completion and analysis</strong>: Good IDEs provide intelligent code completion, error highlighting, and fixes, which are invaluable for <span class="No-Break">efficient development</span></li>
<li><strong class="bold">Debugging tools</strong>: Utilize debugging features provided by the IDE to diagnose and resolve issues in <span class="No-Break">your code</span></li>
<li><strong class="bold">Version control integration</strong>: A good IDE offers support for Git, simplifying code change tracking and <span class="No-Break">repository management</span></li>
<li><strong class="bold">Customization</strong>: Customize<a id="_idIndexMarker014"/> your IDE by adjusting themes, key binding, and settings to match your workflow, making your development experience as comfortable and productive <span class="No-Break">as possible</span></li>
</ul>
<h3>Setting up Git and GitHub</h3>
<p>Version control is an essential aspect of software development. Git, coupled with GitHub, forms a powerful <a id="_idIndexMarker015"/>toolset for tracking changes, collaborating, and maintaining the history of your projects. You can download the Git installer <a id="_idIndexMarker016"/>from the official website <a href="http://git-scm.com">git-scm.com</a> and <span class="No-Break">install it.</span></p>
<p>After installation, configure Git with your username and email using the following commands in the <span class="No-Break">command line:</span></p>
<pre class="console">
$ git config --global user.name "Your Name"
$ git config --global user.email "your.email@example.com"</pre> <p>GitHub is the platform chosen to store code examples used in the book. Sign up for a GitHub account at <a href="http://github.com">github.com</a> if you don’t already <span class="No-Break">have one.</span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Creating a new FastAPI project</h1>
<p>Setting up a well-organized<a id="_idIndexMarker017"/> project structure is crucial for maintaining a clean code base, especially as your application grows and evolves. This recipe will guide you on how to create your first basic FastAPI project. A structured project simplifies navigation, debugging, and collaboration. For FastAPI, following best practices in structuring can significantly enhance scalability <span class="No-Break">and maintainability.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Getting ready</h2>
<p>All you need to do to follow the recipe is make sure that you have your development environment <span class="No-Break">set up.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>How to do it...</h2>
<p>We begin by making a project <a id="_idIndexMarker018"/>folder named <strong class="source-inline">fastapi_start</strong> that we’ll use as the root <span class="No-Break">project folder.</span></p>
<ol>
<li>From the terminal at the root project folder level, we’ll set up our virtual environment by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ python -m venv .venv</strong></pre><p class="list-inset">This will create a <strong class="source-inline">.venv</strong> folder that will contain all packages required for the project within our project's <span class="No-Break">root folder.</span></p></li> <li>Now, you need to activate the environment. If you are on Mac or Linux, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ source .venv/bin/activate</strong></pre><p class="list-inset">From Windows, run the <span class="No-Break">following command:</span></p><pre class="source-code"><strong class="bold">$ .venv\Scripts\activate</strong></pre><p class="list-inset">When the environment is active, you should see in your terminal a prefix string such as <strong class="source-inline">(.venv) $</strong>. Alternatively, if you check the location of the <strong class="source-inline">python</strong> binary command, it should be located within the <strong class="source-inline">.venv</strong> folder. From now on, each time you install a module with <strong class="source-inline">pip</strong>, it will be installed in the <strong class="source-inline">.venv</strong> folder, and it will be activated only if the environment <span class="No-Break">is active.</span></p></li> <li>Now, you can install the <strong class="source-inline">fastapi</strong> package with <strong class="source-inline">uvicorn</strong> in your environment by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ pip install fastapi uvicorn</strong></pre><p class="list-inset">Once FastAPI is installed in your environment, open your project folder with your favorite IDE and create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break">.</span></p></li> <li>This file is where your FastAPI application begins. Start by writing the import of the <strong class="source-inline">FastAPI</strong> module. Then, create an instance of the <span class="No-Break"><strong class="source-inline">FastAPI</strong></span><span class="No-Break"> class:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">This instance houses the code of <span class="No-Break">your application.</span></p></li> <li>Next, define your first route. Routes in FastAPI are like signposts that direct requests to the <a id="_idIndexMarker019"/>appropriate function. Start with a simple route that returns a greeting to <span class="No-Break">the world:</span><pre class="source-code">
@app.get("/")
def read_root():
    return {"Hello": "World"}</pre><p class="list-inset">You’ve just created the code for your first <span class="No-Break">FastAPI application.</span></p></li> </ol>
<p>If you want to track the project, you can set up Git <span class="No-Break">as follows:</span></p>
<ol>
<li>In your project’s root directory, open a terminal or Command Prompt and run the following <span class="No-Break">command:</span><pre class="source-code">
<strong class="bold">$ git init</strong></pre><p class="list-inset">This simple command prepares your project for version control <span class="No-Break">under Git.</span></p><p class="list-inset">Before committing, create a <strong class="source-inline">.gitignore</strong> file to specify untracked files to ignore (such as <strong class="source-inline">__pychache__</strong>, .<strong class="source-inline">venv</strong>, or IDE-specific folders). You can also have a look at the one on the GitHub repository of the project at the <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/.gitignore"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/.gitignore</span></a><span class="No-Break">.</span></p></li> <li>Then, add your files with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ git add</strong> .</pre></li> <li>Then, commit them using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ git commit –m "Initial commit"</strong></pre></li> </ol>
<p>And that's it. You are now tracking your project <span class="No-Break">with Git.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>There’s more...</h2>
<p>A well-structured project is not just about neatness; it’s about creating a sustainable and scalable environment where your application can grow and evolve. In FastAPI, this means organizing your <a id="_idIndexMarker020"/>project in a way that separates different aspects of your application logically <span class="No-Break">and efficiently.</span></p>
<p>There is no unique and perfect structure for a FastAPI project; however, a common approach is to divide your project into several <span class="No-Break">key directories:</span></p>
<ul>
<li><strong class="source-inline">/src</strong>: This is where your primary application code lives. Inside <strong class="source-inline">/src</strong>, you might have subdirectories for different modules of your application. For instance, you could have a <strong class="source-inline">models</strong> directory for your database models, a <strong class="source-inline">routes</strong> directory for your FastAPI routes, and a <strong class="source-inline">services</strong> directory for <span class="No-Break">business logic.</span></li>
<li><strong class="source-inline">/tests</strong>: Keeping your tests separate from your application code is a good practice. It makes it easier to manage them and ensures that your production builds don’t include <span class="No-Break">test code.</span></li>
<li><strong class="source-inline">/docs</strong>: Documentation is crucial for any project. Whether it’s API documentation, installation guides, or usage instructions, having a dedicated directory for documentation helps <span class="No-Break">maintain clarity.</span></li>
</ul>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>See also</h2>
<p>You can find detailed information on how to manage virtual environments with <strong class="source-inline">venv</strong> at the <span class="No-Break">following link:</span></p>
<ul>
<li><em class="italic">Creation of virtual </em><span class="No-Break"><em class="italic">environments</em></span><span class="No-Break">: </span><a href="https://docs.python.org/3/library/venv.xhtml"><span class="No-Break">https://docs.python.org/3/library/venv.xhtml</span></a></li>
</ul>
<p>To brush up your knowledge with Git and get familiar with adding, staging and commiting operations, have a look at this guide: </p>
<ul>
<li><em class="italic">Git simple </em><span class="No-Break"><em class="italic">guide</em></span><span class="No-Break">: </span><a href="https://rogerdudler.github.io/git-guide/"><span class="No-Break">https://rogerdudler.github.io/git-guide/</span></a></li>
</ul>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Understanding FastAPI basics</h1>
<p>As we embark on our journey <a id="_idIndexMarker021"/>with FastAPI, it’s essential to build a solid foundation. FastAPI isn’t just another web framework; it’s a powerful tool designed to make your life as a developer easier, your applications faster, and your code more robust <span class="No-Break">and maintainable.</span></p>
<p>In this recipe, we’ll demystify the core concepts of FastAPI, delve into its unique features such as asynchronous programming, and guide you through creating and organizing your first endpoints. By the end of the recipe, you’ll have your first FastAPI server up and running – a milestone that marks the beginning of an exciting journey in modern <span class="No-Break">web development.</span></p>
<p>FastAPI is a modern, fast web framework for building APIs with Python based on standard Python <span class="No-Break">type hints.</span></p>
<p>Key features that define <a id="_idIndexMarker022"/>FastAPI are <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Speed</strong>: It’s one of the fastest frameworks for building APIs in Python, thanks to its underlying Starlette framework for web parts and Pydantic for <span class="No-Break">data handling</span></li>
<li><strong class="bold">Ease of use</strong>: FastAPI is designed to be easy to use, with intuitive coding that accelerates your <span class="No-Break">development time</span></li>
<li><strong class="bold">Automatic documentation</strong>: With FastAPI, the API documentation is generated automatically, a feature that is both a time-saver and a boon <span class="No-Break">for developers</span></li>
</ul>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>How to do it…</h2>
<p>We will now explore how to use those features effectively with some <span class="No-Break">general guidance.</span></p>
<p>We will go through the <span class="No-Break">following steps:</span></p>
<ul>
<li>Applying asynchronous programming to our existing endpoints to improve <span class="No-Break">time efficiency</span></li>
<li>Exploring routers and endpoints to better organize large <span class="No-Break">code bases</span></li>
<li>Running your first FastAPI server with a <span class="No-Break">basic configuration</span></li>
<li>Exploring the <span class="No-Break">automatic documentation</span></li>
</ul>
<h3>Applying asynchronous programming</h3>
<p>One of the most powerful features of FastAPI is its support for asynchronous programming. This allows your applications to handle more requests simultaneously, making them more<a id="_idIndexMarker023"/> efficient. Asynchronous programming is a style of concurrent programming in which tasks are executed without blocking the execution of other tasks, improving the overall performance of your application. To integrate asynchronous programming smoothly, FastAPI leverages the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax (<a href="https://fastapi.tiangolo.com/async/">https://fastapi.tiangolo.com/async/</a>) and automatically integrates <span class="No-Break">asynchronous functions.</span></p>
<p>So, the <strong class="source-inline">read_root()</strong> function in <strong class="source-inline">main.py</strong> from the previous code snippet in the <em class="italic">Creating a new FastAPI project</em> recipe can be written <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@app.get("/")
<strong class="bold">async def read_root():</strong>
    return {"Hello": "World"}</pre> <p>In this case, the behavior of the code will be exactly the same <span class="No-Break">as before.</span></p>
<h3>Exploring routers and endpoints</h3>
<p>In FastAPI, organizing your code into routers and endpoints is a fundamental practice. This organization helps in making your code cleaner and <span class="No-Break">more modular.</span></p>
<h4>Endpoints</h4>
<p>Endpoints are the points at <a id="_idIndexMarker024"/>which API interactions happen. In FastAPI, an endpoint is created by decorating a function with an HTTP method, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">@app.get("/")</strong></span><span class="No-Break">.</span></p>
<p>This signifies a <strong class="source-inline">GET</strong> request to the root of <span class="No-Break">your application.</span></p>
<p>Consider the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/")
async def read_root():
    return {"Hello": "World"}</pre> <p>In this snippet, we <a id="_idIndexMarker025"/>define an endpoint for the root URL (<strong class="source-inline">"/"</strong>). When a <strong class="source-inline">GET</strong> request is made to this URL, the <strong class="source-inline">read_root</strong> function is invoked, returning a <span class="No-Break">JSON response.</span></p>
<h4>Routers</h4>
<p>When we need to handle <a id="_idIndexMarker026"/>multiple endpoints that are in different files, we can benefit from using routers. Routers assist us in grouping our endpoints into different modules, which makes our code base easier to maintain and understand. For example, we could use one router for operations related to users and another for operations related <span class="No-Break">to products.</span></p>
<p>To define a router, first create a new file in the <strong class="source-inline">fastapi_start</strong> folder called <strong class="source-inline">router_example.py</strong>. Then, create the router <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi import APIRouter
router = APIRouter()
@router.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}</pre> <p>You can now reuse it and attach the router to the FastAPI server instance <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
<strong class="bold">import router_example</strong>
from fastapi import FastAPI
app = FastAPI()
<strong class="bold">app.include_router(router_example.router)</strong>
@app.get("/")
async def read_root():
    return {"Hello": "World"}</pre> <p>You now have the code to <a id="_idIndexMarker027"/>run the server that includes the router for the <strong class="source-inline">GET /items</strong> endpoint importer from <span class="No-Break">another module.</span></p>
<h3>Running your first FastAPI server</h3>
<p>To run your FastAPI application, you<a id="_idIndexMarker028"/> need to point Uvicorn to your app instance. If your file is named <strong class="source-inline">main.py</strong> and your FastAPI instance is called <strong class="source-inline">app</strong>, you can start your server like this at the <strong class="source-inline">fastapi_start</strong> <span class="No-Break">folder level:</span></p>
<pre class="console">
$ uvicorn main:app --reload</pre> <p>The <strong class="source-inline">--reload</strong> flag makes the server restart after code changes, making it ideal <span class="No-Break">for development.</span></p>
<p>Once the server is running, you can access your API at <strong class="source-inline">http://127.0.0.1:8000</strong>. If you visit this URL in your browser, you’ll see the JSON response from the <strong class="source-inline">"/"</strong> endpoint we have <span class="No-Break">just created.</span></p>
<h3>Exploring the automatic documentation</h3>
<p>One of the most exciting features of FastAPI is its <a id="_idIndexMarker029"/>automatic documentation. When you run your FastAPI application, two documentation interfaces are automatically generated: <strong class="bold">Swagger UI</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Redoc</strong></span><span class="No-Break">.</span></p>
<p>You can access these at <strong class="source-inline">http://127.0.0.1:8000/docs</strong> for Swagger UI and <strong class="source-inline">http://127.0.0.1:8000/redoc</strong> <span class="No-Break">for Redoc.</span></p>
<p>These interfaces provide an interactive way to explore your API and test <span class="No-Break">its functionality.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>See also</h2>
<p>You can discover more about what we covered in the recipe at the <span class="No-Break">following links:</span></p>
<ul>
<li><em class="italic">First </em><span class="No-Break"><em class="italic">Steps</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/first-steps/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/first-steps/</span></a></li>
<li><em class="italic">Docs </em><span class="No-Break"><em class="italic">URLs</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls</span></a></li>
<li><em class="italic">Concurrency and async / </em><span class="No-Break"><em class="italic">await</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/async/"><span class="No-Break">https://fastapi.tiangolo.com/async/</span></a></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Defining your first API endpoint</h1>
<p>Now that you have a fundamental grasp of FastAPI and your development environment is all set up, it’s time to take the <a id="_idIndexMarker030"/>next thrilling step: creating your first <span class="No-Break">API endpoint.</span></p>
<p>This is where the real magic of FastAPI begins to shine. You’ll see how effortlessly you can build a functional API endpoint, ready to respond to <span class="No-Break">HTTP requests.</span></p>
<p>In this recipe, you will create a basic draft of a backend service for <span class="No-Break">a bookstore.</span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Getting ready</h2>
<p>Make sure you know how to start a basic FastAPI project from the <em class="italic">Creating a new FastAPI </em><span class="No-Break"><em class="italic">project</em></span><span class="No-Break"> recipe.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>How to do it...</h2>
<p>In the realm of web APIs, the <strong class="source-inline">GET</strong> request is perhaps the most common. It’s used to retrieve data from the server. In FastAPI, handling a <strong class="source-inline">GET</strong> request is simple and intuitive. Let’s create a basic <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint.</span></p>
<p>Imagine you’re building an API for a bookstore. Your first endpoint will provide information about a book when given its ID. Here’s how you <span class="No-Break">do it:</span></p>
<ol>
<li>Create a new <strong class="source-inline">bookstore</strong> folder that will contain the code you are going <span class="No-Break">to write.</span></li>
<li>Create in it a <strong class="source-inline">main.py</strong> file containing the <span class="No-Break">server instance:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/books/{book_id}")
async def read_book(book_id: int):
    return {
        "book_id": book_id,
        "title": "The Great Gatsby",
        "author": "F. Scott Fitzgerald"
    }</pre></li> </ol>
<p>In the preceding code snippet, the <strong class="source-inline">@app.get("/books/{book_id}")</strong> decorator tells FastAPI that this function will respond to <strong class="source-inline">GET</strong> requests at the <strong class="source-inline">/books/{book_id}</strong> path. <strong class="source-inline">{book_id}</strong> in the path is a path parameter, which you can use to pass values dynamically. FastAPI<a id="_idIndexMarker031"/> automatically extracts the <strong class="source-inline">book_id</strong> parameter and passes it to <span class="No-Break">your function.</span></p>
<p class="callout-heading">Type hints and automatic data validation</p>
<p class="callout">Notice the use of type hints (<strong class="source-inline">book_id: int</strong>). FastAPI uses these hints to perform data validation. If a request is made with a non-integer <strong class="source-inline">book_id</strong> parameter, FastAPI automatically sends a helpful <span class="No-Break">error response.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>How it works…</h2>
<p>With your <strong class="source-inline">GET</strong> endpoint defined, run your FastAPI application using Uvicorn, just as you <span class="No-Break">did previously:</span></p>
<pre class="console">
$ uvicorn main:app --reload</pre> <p>On the terminal, you can read the message logs describing that the server is running on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8000</strong></span><span class="No-Break">.</span></p>
<p>One of FastAPI’s most beloved features is its automatic generation of interactive API documentation using <a id="_idIndexMarker032"/>Swagger UI. This tool allows you to test your API endpoints directly from your browser without writing any additional code, and you can directly check the presence of the newly created endpoint <span class="No-Break">in i<a id="_idTextAnchor038"/>t.</span></p>
<h3>Using Swagger UI</h3>
<p>To test your new <strong class="source-inline">GET</strong> endpoint, navigate to <strong class="source-inline">http://127.0.0.1:8000/docs</strong> in your browser. This URL brings up the <a id="_idIndexMarker033"/>Swagger UI documentation for your FastAPI application. Here, you’ll see your <strong class="source-inline">/books/{book_id}</strong> endpoint listed. Click <a id="_idIndexMarker034"/>on it, and you’ll be able to execute a test request right from the interface. Try inputting a book ID and see the response your <span class="No-Break">API generates.</span></p>
<h3>Postman – a versatile alternative</h3>
<p>While Swagger UI is convenient <a id="_idIndexMarker035"/>for quick tests, you might want to use a more robust tool such as Postman for more complex scenarios. Postman is an API client that lets you build, test, and document your<a id="_idIndexMarker036"/> APIs <span class="No-Break">more extensively.</span></p>
<p>To use Postman, download and install it from Postman’s <span class="No-Break">website (</span><a href="https://www.postman.com/downloads/"><span class="No-Break">https://www.postman.com/downloads/</span></a><span class="No-Break">).</span></p>
<p>Once installed, create a new request. Set the method to <strong class="source-inline">GET</strong> and the request URL to your FastAPI endpoint, <strong class="source-inline">http://127.0.0.1:8000/books/1</strong>. Hit <strong class="bold">Send</strong>, and Postman will display the response from your <span class="No-Break">FastAPI server.</span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Working with path and query parameters</h1>
<p>One of the most <a id="_idIndexMarker037"/>crucial aspects of API development is handling parameters. Parameters<a id="_idIndexMarker038"/> allow your API to accept input from users, making your endpoints dynamic <span class="No-Break">and responsive.</span></p>
<p>In this recipe, we will explore how to capture and handle path, query parameters, and test them efficiently, enhancing the flexibility and functionality of your <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Getting ready</h2>
<p>To follow the recipe, make sure you know how to create a basic endpoint from the <span class="No-Break">previous recipe.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>How to do it…</h2>
<p>Path parameters are<a id="_idIndexMarker039"/> parts of the URL that are expected to change. For instance, in an endpoint such as <strong class="source-inline">/books/{book_id}</strong>, <strong class="source-inline">book_id</strong> is a path parameter. FastAPI allows you to capture these parameters effortlessly and use them in <span class="No-Break">your function.</span></p>
<ol>
<li>Let’s expand our bookstore API with a new endpoint that uses path parameters. This time, we’ll create<a id="_idIndexMarker040"/> a route to get information about a <span class="No-Break">specific author:</span><pre class="source-code">
@app.get("/authors/{author_id}")
async def read_author(author_id: int):
    return {
        "author_id": author_id,
        "name": "Ernest Hemingway"
    }</pre><p class="list-inset">The name will not change; however, the <strong class="source-inline">author_id</strong> value will be the one provided by the <span class="No-Break">query request.</span></p><p class="list-inset">Query parameters are used to refine or customize the response of an API endpoint. They can be included in the URL after a question mark (<strong class="source-inline">?</strong>). For instance, <strong class="source-inline">/books?genre=fiction&amp;year=2010</strong> might return only books that fall under the fiction genre released <span class="No-Break">in 2010.</span></p></li> <li>Let’s add query parameters to our existing endpoint. Suppose we want to allow users to filter books by<a id="_idIndexMarker041"/> their <span class="No-Break">publication year:</span><pre class="source-code">
@app.get("/books")
async def read_books(year: int = None):
    if year:
        return {
            "year": year,
            "books": ["Book 1", "Book 2"]
        }
    return {"books": ["All Books"]}</pre></li> </ol>
<p>Here, <strong class="source-inline">year</strong> is an optional<a id="_idIndexMarker042"/> query parameter. By assigning <strong class="source-inline">None</strong> as a default value, we make it optional. If a year is specified, the endpoint returns books from that year; otherwise, it returns <span class="No-Break">all books.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">Using the <strong class="source-inline">APIRouter</strong> class, refactor each endpoint in a separate file and add the route to the <span class="No-Break">FastAPI server.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>How it works…</h2>
<p>Now, from the command terminal, spin up the server with Uvicorn by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Testing endpoints with path parameters can be done using Swagger UI or Postman, similar to how we tested our basic <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint.</span></p>
<p>In Swagger UI, at <strong class="source-inline">http://localhost:8000/docs</strong>, navigate to your <strong class="source-inline">/authors/{author_id}</strong> endpoint. You’ll notice that it prompts you to enter an <strong class="source-inline">author_id</strong> value before you can try it out. Enter a valid integer and execute the request. You should see a response with the <span class="No-Break">author’s information.</span></p>
<p>The <strong class="source-inline">GET /books</strong> endpoint will now show an optional field for the <strong class="source-inline">year</strong> query parameter. You can test it by entering different years and observing the <span class="No-Break">varying responses.</span></p>
<p>If you use Postman instead, create a new <strong class="source-inline">GET</strong> request with the <strong class="source-inline">http://127.0.0.1:8000/authors/1</strong> URL. Sending this request should yield a <span class="No-Break">similar response.</span></p>
<p>In Postman, append the query parameter to the URL like so: <strong class="source-inline">http://127.0.0.1:8000/books?year=2021</strong>. Sending<a id="_idIndexMarker043"/> this request should return books published in the <span class="No-Break">year 2021.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>See also</h2>
<p>You can find more <a id="_idIndexMarker044"/>about path and query parameters in the FastAPI official documentation at the <span class="No-Break">following links:</span></p>
<ul>
<li><em class="italic">Path </em><span class="No-Break"><em class="italic">Parameters</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/path-params/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/path-params/</span></a></li>
<li><em class="italic">Query </em><span class="No-Break"><em class="italic">Parameters</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/query-params/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/query-params/</span></a></li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Defining and using request and response models</h1>
<p>In the world of API development, data handling is a critical aspect that determines the robustness and reliability of your application. FastAPI simplifies this process through its seamless integration with <strong class="bold">Pydantic</strong>, a data <a id="_idIndexMarker045"/>validation and settings management library using Python type annotations. The recipe will show you how to define and use request and response models in FastAPI, ensuring your data is well structured, validated, and <span class="No-Break">clearly defined.</span></p>
<p>Pydantic models are a<a id="_idIndexMarker046"/> powerful feature for data validation and conversion. They allow you to define the structure, type, and constraints of the data your application handles, both for incoming requests and <span class="No-Break">outgoing responses.</span></p>
<p>In this recipe, we will see how to use Pydantic to ensure that your data conforms to the specified schema, providing an automatic layer of safety <span class="No-Break">and clarity.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Getting ready</h2>
<p>This recipe requires you to know how to set up a basic endpoint <span class="No-Break">in FastAPI.</span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>How to do it...</h2>
<p>We will break the <a id="_idIndexMarker047"/>process into the <span class="No-Break">following steps:</span></p>
<ol>
<li>Creating <span class="No-Break">the model</span></li>
<li>Defining the <span class="No-Break">request body</span></li>
<li>Validating <span class="No-Break">request data</span></li>
<li>Managing <span class="No-Break">response formats</span></li>
</ol>
<h3>Creating the model</h3>
<p>Let’s create a Pydantic<a id="_idIndexMarker048"/> <strong class="source-inline">BaseModel</strong> class for our bookstore application in a new file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">models.py</strong></span><span class="No-Break">.</span></p>
<p>Suppose we want to have a model for a book that includes the title, author, and <span class="No-Break">publication year:</span></p>
<pre class="source-code">
from pydantic import BaseModel
class Book(BaseModel):
    title: str
    author: str
    year: int</pre> <p>Here, <strong class="source-inline">Book</strong> is a Pydantic <strong class="source-inline">BaseModel</strong> class with three fields: <strong class="source-inline">title</strong>, <strong class="source-inline">author</strong>, and <strong class="source-inline">year</strong>. Each field is typed, ensuring that any data conforming to this model will have these attributes with the specified <span class="No-Break">data types.</span></p>
<h3>Defining the request body</h3>
<p>In FastAPI, Pydantic models are not just for validation. They also serve as the request body. Let’s add an<a id="_idIndexMarker049"/> endpoint to our application where users can add <span class="No-Break">new books:</span></p>
<pre class="source-code">
from models import Book
@app.post("/book")
async def create_book(book: Book):
    return book</pre> <p>In this endpoint, when a user sends a <strong class="source-inline">POST</strong> request to the <strong class="source-inline">/book</strong> endpoint with JSON data, FastAPI automatically parses and validates it against the <strong class="source-inline">Book</strong> model. If the data is invalid, the user gets an automatic <span class="No-Break">error response.</span></p>
<h3>Validating request data</h3>
<p>Pydantic offers advanced<a id="_idIndexMarker050"/> validation features. For instance, you can add regex validations, default values, <span class="No-Break">and more:</span></p>
<pre class="source-code">
from pydantic import BaseModel<strong class="bold">, Field</strong>
class Book(BaseModel):
    title: str <strong class="bold">= Field(..., min_length=1, max_length=100)</strong>
    author: str <strong class="bold">= Field(..., min_length=1, max_length=50)</strong>
    year: int <strong class="bold">= Field(..., gt=1900, lt=2100)</strong></pre> <p>For an exhaustive list of validation features, have a look at Pydantic’s official documentation: <a href="https://docs.pydantic.dev/latest/concepts/fields/"><span class="No-Break">https://docs.pydantic.dev/latest/concepts/fields/</span></a><span class="No-Break">.</span></p>
<p>Next, you can proceed to manage the <span class="No-Break">response format.</span></p>
<h3>Managing response formats</h3>
<p>FastAPI allows you to define response models explicitly, ensuring that the data returned by your API matches a specific schema. This can be particularly useful for filtering out sensitive data or restructuring <span class="No-Break">the response.</span></p>
<p>For example, let’s say you want the <strong class="source-inline">/allbooks</strong> <strong class="source-inline">GET</strong> endpoint to return a list of books, but only with their titles <a id="_idIndexMarker051"/>and authors, omitting the publication year. In <strong class="source-inline">main.py</strong>, add the <span class="No-Break">following accordingly:</span></p>
<pre class="source-code">
from pydantic import BaseModel
class BookResponse(BaseModel):
    title: str
    author: str
@app.get("/allbooks")
async def read_all_books() -&gt; list[BookResponse]:
    return [
        {
            "id": 1,
            "title": "1984",
            "author": "George Orwell"},
        {
            "id": 1,
            "title": "The Great Gatsby",
            "author": "F. Scott Fitzgerald",
        },
    ]</pre> <p>Here, the <strong class="source-inline">-&gt; list[BookResponse]</strong> function type hint tells FastAPI to use the <strong class="source-inline">BookResponse</strong> model for responses, ensuring that only the title and author fields are included in the response JSON. Alternatively, you can specify the response type in the endpoint decorator’s <a id="_idIndexMarker052"/>arguments <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@app.get("/allbooks", response_model= list[BookResponse])
async def read_all_books() -&gt; Any:
# rest of the endpoint content</pre> <p>The <strong class="source-inline">response_model</strong> argument takes priority and can be used instead of the type hint to resolve type checker issues that <span class="No-Break">may occur.</span></p>
<p>Check the documentation at <strong class="source-inline">http://127.0.0.1:8000/docs</strong>. Unroll the <strong class="source-inline">/allbooks</strong> endpoint details, and you will notice the example value response based on the schema <span class="No-Break">as follows:</span></p>
<pre class="source-code">
[
  {
    "title": "string",
    "author": "string"
  }
]</pre> <p>By mastering Pydantic models in FastAPI, you are now capable of handling complex data structures with ease and precision. You’ve learned to define request bodies and manage response formats, ensuring data consistency and integrity throughout <span class="No-Break">your application.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>See also</h2>
<p><strong class="bold">Pydantic</strong> is a standalone <a id="_idIndexMarker053"/>project largely used for data validation in Python with many more features than what the recipe has shown. Feel free to have a look at the official documentation at the <span class="No-Break">following link:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">Pydantic</em></span><span class="No-Break">: </span><a href="https://docs.pydantic.dev/latest/"><span class="No-Break">https://docs.pydantic.dev/latest/</span></a></li>
</ul>
<p>You can see more on response model usage at the FastAPI official <span class="No-Break">documentation link:</span></p>
<ul>
<li><em class="italic">Response Model - Return </em><span class="No-Break"><em class="italic">Type</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/response-model/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/response-model/</span></a></li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Handling errors and exceptions</h1>
<p>Error handling is an essential aspect of developing robust and reliable web applications. In FastAPI, managing errors and <a id="_idIndexMarker054"/>exceptions is not just about catching unexpected issues but also about proactively designing your application to respond to various error <span class="No-Break">scenarios gracefully.</span></p>
<p>This recipe will guide you through custom error handling, validating data and handling exceptions, and testing these scenarios to ensure your FastAPI applications are resilient <span class="No-Break">and user-friendly.</span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>How to do it…</h2>
<p>FastAPI provides built-in support for handling exceptions <span class="No-Break">and errors.</span></p>
<p>When an error occurs, FastAPI returns a JSON response containing details about the error, which is very useful for debugging. However, there are situations where you might want to customize these error responses for better user experience <span class="No-Break">or security.</span></p>
<p>Let’s create a custom error handler that catches a specific type of error and returns a custom response. For instance, if a requested resource is not found, you might want to return a more friendly <span class="No-Break">error </span><span class="No-Break">message</span><span class="No-Break">.</span></p>
<p>To do it, in the <strong class="source-inline">main.py</strong> file, add the following <span class="No-Break">code accordingly:</span></p>
<pre class="source-code">
from fastapi import FastAPI, HTTPException
from starlette.responses import JSONResponse
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "message": "Oops! Something went wrong"
        },
    )</pre> <p>In this example, the <strong class="source-inline">http_exception_handler</strong> function will be used to handle <strong class="source-inline">HTTPException</strong> errors. Whenever<a id="_idIndexMarker055"/> an <strong class="source-inline">HTTPException</strong> error is raised anywhere in your application, FastAPI will use this handler to return a <span class="No-Break">custom response.</span></p>
<p>You can test the response by creating a new endpoint that raises an <span class="No-Break">HTTP exception:</span></p>
<pre class="source-code">
@app.get("/error_endpoint")
async def raise_exception():
    raise HTTPException(status_code=400)</pre> <p>The endpoint will explicitly throw the HTTP error response to showcase the customized message defined in the <span class="No-Break">previous step.</span></p>
<p>Now, spin the server from the command line with the <span class="No-Break">following command:</span></p>
<pre class="source-code">
<strong class="bold">$ uvicorn main:app</strong></pre> <p>Open the browser at <strong class="source-inline">http://localhost:8000/error_endpoint</strong>, and you will have a JSON response <span class="No-Break">like this:</span></p>
<pre class="source-code">
{
    "message": "Oops! Something went wrong"
}</pre> <p>The response returns the default message we defined for any HTTP exception returned by <span class="No-Break">the code.</span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>There’s more…</h2>
<p>As discussed in the previous recipe, <em class="italic">Defining and using request and response models</em>, FastAPI uses Pydantic models for data validation. When a request is made with data that does not conform to the defined model, FastAPI automatically raises an exception and returns<a id="_idIndexMarker056"/> an <span class="No-Break">error response.</span></p>
<p>In some cases, you might want to customize the response for validation errors. FastAPI makes this <span class="No-Break">quite straightforward:</span></p>
<pre class="source-code">
import json
from fastapi import Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
    return PlainTextResponse(
        "This is a plain text response:"
        f" \n{json.dumps(exc.errors(), indent=2)}",
        status_code=status.HTTP_400_BAD_REQUEST,
    )</pre> <p>This custom handler will catch any <strong class="source-inline">RequestValidationError</strong> error and return a plain text response with the details of <span class="No-Break">the error.</span></p>
<p>If you try, for example, to call the <strong class="source-inline">POST /book</strong> endpoint with a number type of <strong class="source-inline">title</strong> instead of a <a id="_idIndexMarker057"/>string, you will get a response with a status code of <strong class="source-inline">400</strong> <span class="No-Break">and body:</span></p>
<pre class="source-code">
This is a plain text response:
[
  {
    "type": "string_type",
    "loc": [
      "body",
      "author"
    ],
    "msg": "Input should be a valid string",
    "input": 3,
    "url": "https://errors.pydantic.dev/2.5/v/string_type"
  },
  {
    "type": "greater_than",
    "loc": [
      "body",
      "year"
    ],
    "msg": "Input should be greater than 1900",
    "input": 0,
    "ctx": {
      "gt": 1900
    },
    "url": "https://errors.pydantic.dev/2.5/v/greater_than"
  }
]</pre> <p>You can also, for example, mask the message to add a layer of security to protect from unwanted users using <span class="No-Break">it incorrectly.</span></p>
<p>This is all you need to customize responses when a request validation <span class="No-Break">error occurs.</span></p>
<p>You will use this basic <a id="_idIndexMarker058"/>knowledge as you move to the next chapter. <a href="B21025_02.xhtml#_idTextAnchor052"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> will teach you more about data management in web applications, showing you how to set up and use SQL and NoSQL databases and stressing data security. This will not only improve your technical skills but also increase your awareness of creating scalable and reliable <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>See also</h2>
<p>You can find more information about customizing errors and exceptions using FastAPI in the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">Handling </em><span class="No-Break"><em class="italic">Errors</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/handling-errors/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/handling-errors/</span></a></li>
</ul>
</div>
</div></body></html>