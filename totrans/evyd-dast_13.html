<html><head></head><body>
<div class="book" title="Chapter&#xA0;13.&#xA0;Searching: Finding What You Need" id="28FAO1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13" class="calibre1"/>Chapter 13. Searching: Finding What You Need</h1></div></div></div><p class="calibre7">Sorting your collections can be costly, but often this represents a one-time cost after the collection has been created. However, this time and energy spent up front can significantly improve performance once in the life of your application's run cycle. Even adding a new object is a much less costly process when the object is added to an already sorted collection.</p><p class="calibre7">The real performance improvement comes when it is time to search your collections for specific elements or values. In this chapter, we will examine how sorted collections greatly improve search time, depending on the search algorithm you choose. We will not discuss all of the search algorithms you can choose from, but we will examine three of the most common ones:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Linear search (sequential search)</li><li class="listitem">Binary search</li><li class="listitem">Jump search</li></ul></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Searching: Finding What You Need" id="28FAO1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Linear search"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch13lvl1sec68" class="calibre1"/>Linear search</h1></div></div></div><p class="calibre7">A search, also called a <span class="strong"><strong class="calibre16">sequential</strong></span> search, is simply a loop through a collection with some kind of comparison function to locate a matching element or value. Most linear searches return a value representing the index of the matching object in the collection, or some impossible index value such as <code class="literal">-1</code> when an object is not found. Alternative versions of this search could return the object itself or <code class="literal">null</code> if the object is not found.</p><p class="calibre7">This is the simplest form of search pattern and it carries an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) complexity cost. This complexity is consistent whether the collection is in random order or if it has already been sorted. In very small collections linear searches are perfectly acceptable and many developers make use of them daily. However, when working with very large collections it is often beneficial to find alternatives to this sequential search approach. This is particularly true when working with lists of very complex objects, such as spatial geometries, where search or analysis can be very processor-intensive operations.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note44" class="calibre1"/>Note</h3><p class="calibre7">
</p><p class="calibre7">Each of the code examples in this chapter will examine search algorithms in the form of the methods most essential to the operation, with these being detached from their parent classes. Additionally, in each case, the collection of objects being sorted will be defined at the class level, outside the example code shown here. Likewise, the subsequent object instantiation and population of those collections will be defined outside the example code. To see the full class examples, use the code examples accompanying this text.</p><p class="calibre7">
</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">The first example of the linear search algorithm is in the <code class="literal">LinearSearchIndex(int[] values, int key)</code> method. As you can see, this method is very simple and almost self-explanatory. There are two major characteristics of this implementation worth mentioning. First, the method accepts the array of <code class="literal">values</code> and the search <code class="literal">key</code>. Second, the method returns the index <code class="literal">i</code> of any matching element, or simply <code class="literal">-1</code> if the search key is not found.</p><pre class="programlisting">    public int LinearSearchIndex(int[] values, int key) 
    { 
        for (int i = 0; i &lt; values.Length - 1; i++) 
        { 
            if (values[i] == key) 
            { 
                return i; 
            } 
        } 
 
        return -1; 
    } 
</pre><p class="calibre7">The second example of a linear search is nearly identical to the first. However, in the <code class="literal">LinearSearchCustomer(Customer[] customers, int custId)</code> method, we are not searching for a value but rather for a key that represents the customer that the caller wants to retrieve. Note that the comparison is now searching the <code class="literal">customerId</code> field on the <code class="literal">Customer</code> object; if a match is found, the <code class="literal">Customer</code> at <code class="literal">customers[i]</code> is returned. If no match is found, the method returns <code class="literal">null</code>:</p><pre class="programlisting">    public Customer LinearSearchCustomer(Customer[] customers, int custId) 
    { 
        for (int i = 0; i &lt; customers.Length - 1; i++) 
        { 
            if (customers[i].customerId == custId) 
            { 
                return customers[i]; 
            } 
        } 
 
        return null; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">The Java implementation of each method is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function.</p><pre class="programlisting">    public int linearSearchIndex(int[] values, int key) 
    { 
        for (int i = 0; i &lt; values.length - 1; i++) 
        { 
            if (values[i] == key) 
            { 
                return i; 
            } 
        } 
 
        return -1; 
    } 
 
    public Customer linearSearchCustomer(Customer[] customers, int custId) 
    { 
        for (int i = 0; i &lt; customers.length - 1; i++) 
        { 
            if (customers[i].customerId == custId) 
            { 
                return customers[i]; 
            } 
        } 
 
        return null; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Since <code class="literal">NSArray</code> can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine <code class="literal">intValue</code>. Otherwise, these implementations are fundamentally the same as the C# or Java implementations:</p><pre class="programlisting">    -(NSInteger)linearSearchArray:(NSMutableArray&lt;NSNumber*&gt;*)values byKey:(NSInteger) key 
    { 
        for (int i = 0; i &lt; [values count] - 1; i++) 
        { 
            if ([values[i] intValue] == key) 
            { 
                return i; 
            } 
        } 
     
        return -1; 
    } 
 
    -(EDSCustomer*)linearSearchCustomers:(NSMutableArray&lt;NSNumber*&gt;*)customers byCustId:(NSInteger)custId 
    { 
        for (EDSCustomer *c in customers) 
        { 
            if (c.customerId == custId) 
            { 
                return c; 
            } 
        } 
        return nil; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our method must use the Swift 3.0 equivalent. Also, Swift does not allow a method to return <code class="literal">nil</code> unless the return type is explicitly declared as optional, so the <code class="literal">linearSearchCustomer( customers: [Customer], custId: Int)</code> method has a return type of <code class="literal">Customer?</code>. Otherwise, the functionality is fundamentally the same as its predecessors:</p><pre class="programlisting">    open func linearSearhIndex( values: [Int], key: Int) -&gt; Int 
    { 
        for i in 0..&lt;values.count 
        { 
            if (values[i] == key) 
            { 
                return i 
            } 
        } 
 
        return -1 
    } 
 
    open func linearSearchCustomer( customers: [Customer], custId: Int) -&gt; Customer? 
    { 
        for i in 0..&lt;customers.count 
        { 
            if (customers[i].custId == custId) 
            { 
                return customers[i] 
            } 
        } 
        return nil 
    } 
</pre></div></div>
<div class="book" title="Binary search" id="29DRA1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec69" class="calibre1"/>Binary search</h1></div></div></div><p class="calibre7">When dealing with an unsorted collection, a sequential search is probably the most reasonable approach. However, when working with a sorted collection there are better methods of finding matches to search keys. One alternative is a binary search. A binary search is typically implemented as a recursive function and works on the principle of repeatedly dividing the collection in half and searching smaller and smaller chunks of the collection until a match is found or until the search has exhausted the remaining options and turns up empty.</p><p class="calibre7">For example, given the following set of ordered values:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {8, 19, 23, 50, 75, 103, 121, 143, 201}</em></span></p><p class="calibre7">Using a linear search to find the value <code class="literal">143</code> would have a complexity cost of <span class="strong"><strong class="calibre16">O</strong></span>(8) since <code class="literal">143</code> is found at index 7 (position 8) in our collection. However, a binary search can take advantage of the sorted nature of the collection to improve upon this complexity cost.</p><p class="calibre7">We know that the collection consists of nine elements, so the binary search would begin by examining the median element at index 5 and comparing that to the key value of <code class="literal">143</code>. Since <span class="strong"><em class="calibre20">i[5] = 75</em></span>, and this is less than <code class="literal">143</code>, the set is split and the range of possible matches is reduced to only include the upper half, leaving us with:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {103, 121, 143, 201}</em></span></p><p class="calibre7">With four elements, the median element is the element at position two. Position <span class="strong"><em class="calibre20">i[2] = 121</em></span>, and this is less than <code class="literal">143</code> so the set is split and the range of possible matches is reduced to only include the upper quarter, leaving us with:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {143, 201}</em></span></p><p class="calibre7">With two elements, the median element is the element at position one. Since <span class="strong"><em class="calibre20">i[1] = 143</em></span>, we have found a match and the value can be returned. This search only cost <span class="strong"><strong class="calibre16">O</strong></span>(3), improving on the linear search time by almost 67%. Although individual results may vary, the binary search pattern is consistently more efficient than the linear search when the collection is sorted. This is a strong justification for taking the time to sort your collections before your application begins to use data supplied by them:</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">The <code class="literal">BinarySort(int[] values, int left, int right, int key)</code> begins by checking if the <code class="literal">right</code> index is greater than or equal to the <code class="literal">left</code> index. If <code class="literal">false</code>, there are no elements within the prescribed range and the analysis has been exhausted so the method returns <code class="literal">-1</code>. We'll examine why in a moment. Otherwise, method execution continues because there is at least one object in the defined range.</p><p class="calibre7">Next, the method checks whether the value at the <code class="literal">middle</code> index matches our <code class="literal">key</code>. If <code class="literal">true</code>, the <code class="literal">middle</code> index is returned. Otherwise, the method checks whether the values at the <code class="literal">middle</code> index are greater than the <code class="literal">key</code> value. If <code class="literal">true</code>, <code class="literal">BinarySort(int[] values, int left, int right, int key)</code> is called recursively with bounds that select the lower half of the current range of elements. Otherwise, the value at the <code class="literal">middle</code> index is less than the <code class="literal">key</code>, so <code class="literal">BinarySort(int[] values, int left, int right, int key)</code> is called recursively with bounds that select the upper half of the current range of elements:</p><pre class="programlisting">    public int BinarySearch(int[] values, int left, int right, int key) 
    { 
        if (right &gt;= left) 
        { 
            int middle = left + (right - left) / 2; 
 
            if (values[middle] == key) 
            { 
                return middle; 
            } 
            else if (values[middle] &gt; key) 
            { 
                return BinarySearch(values, left, middle - 1, key); 
            } 
 
            return BinarySearch(values, middle + 1, right, key); 
        } 
 
        return -1; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Apart from the name <code class="literal">binarySearch(int[] values, int left, int right, int key)</code>, the Java implementation is identical in design to the C# implementation:</p><pre class="programlisting">    public int binarySearch(int[] values, int left, int right, int key) 
    { 
        if (right &gt;= left) 
        { 
            int mid = left + (right - left) / 2; 
 
            if (values[mid] == key) 
            { 
                return mid; 
            } 
            else if (values[mid] &gt; key) 
            { 
                return binarySearch(values, left, mid - 1, key); 
            } 
    
            return binarySearch(values, mid + 1, right, key); 
        } 
 
        return -1; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Since <code class="literal">NSArray</code> can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code>. Otherwise, these implementations are fundamentally the same as the C# or Java implementations:</p><pre class="programlisting">    -(NSInteger)binarySearchArray:(NSMutableArray&lt;NSNumber*&gt;*)values withLeftIndex:(NSInteger)left 
rightIndex:(NSInteger)right
andKey:(NSInteger)key 
    { 
        if (right &gt;= left) 
        { 
            NSInteger mid = left + (right - left) / 2; 
         
            if ([values[mid] intValue] == key) 
            { 
                return mid; 
            } 
            else if ([values[mid] intValue] &gt; key) 
            { 
                return [self binarySearchArray:values withLeftIndex:left rightIndex:mid - 1 andKey:key]; 
            } 
         
            return [self binarySearchArray:values withLeftIndex:mid + 1 rightIndex:right andKey:key]; 
        } 
     
        return -1; 
    }  
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Fundamentally, the Swift implementation is the same as its predecessors:</p><pre class="programlisting">    open func binarySearch( values: [Int], left: Int, right: Int, key: Int) -&gt; Int 
    { 
        if (right &gt;= left) 
        { 
            let mid: Int = left + (right - left) / 2 
 
            if (values[mid] == key) 
            { 
                return mid 
            } 
            else if (values[mid] &gt; key) 
            { 
                return binarySearch(values: values, left: left, right: mid - 1, key: key) 
            } 
 
            return binarySearch(values: values, left: mid + 1, right: right, key: key) 
        } 
 
        return -1 
    }  
</pre></div>
<div class="book" title="Jump search"><div class="book" id="2ACBS2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec70" class="calibre1"/>Jump search</h1></div></div></div><p class="calibre7">Another search algorithm that can improve performance with sorted arrays is the <span class="strong"><strong class="calibre16">jump search</strong></span>. A jump search bears some similarity to both the linear search and binary search algorithms in that it searches blocks of elements from left to right beginning with the first block in the collection, and also because at each jump the algorithm compares the search key value to the value of the element at the current step. If the algorithm determines that the key could exist in the current subset of elements, the next step (no pun intended) is to examine each element in the current subset to determine if it is less than the key.</p><p class="calibre7">Once an element is found that is not less than the key , that element is compared to the key. If the element is equal to the key, it is returned; otherwise, it is greater than the key, which means that the key does not exist in the collection.</p><p class="calibre7">The jump length <span class="strong"><em class="calibre20">m</em></span> is not an arbitrary value, but rather is calculated based on the length of the collection using the formula <span class="strong"><em class="calibre20">m = </em></span> √<span class="strong"><em class="calibre20">n</em></span>, where <span class="strong"><em class="calibre20">n</em></span> is the total number of elements in the collection. The jump search begins by examining the value of the last object in the first block or subset.</p><p class="calibre7">For example, let's search for value <span class="strong"><em class="calibre20">143</em></span> given the following set of ordered values:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {8, 19, 23, 50, 75, 103, 121, 143, 201}</em></span></p><p class="calibre7">Since our collection contains nine elements, <span class="strong"><em class="calibre20">m = √</em></span>
<span class="strong"><em class="calibre20">n</em></span> gives us a value of 3. Since <span class="strong"><em class="calibre20">i[2] = 23</em></span>, and this is less than <span class="strong"><em class="calibre20">143</em></span>, the algorithm jumps to the next block. Next, <span class="strong"><em class="calibre20">i[4] = 103</em></span> which is also less than <span class="strong"><em class="calibre20">143</em></span> so this subset is excluded. Finally, <span class="strong"><em class="calibre20">i[8] = 201</em></span>. Since <span class="strong"><em class="calibre20">201</em></span> is greater than <span class="strong"><em class="calibre20">143</em></span>, the key could possible exist in the third subset:</p><p class="calibre7"><span class="strong"><em class="calibre20">S<sub class="calibre23">3</sub> = {121, 143, 201}</em></span></p><p class="calibre7">Next, the algorithm checks each element in this subset to determine if it is less than <span class="strong"><em class="calibre20">143</em></span>. And <span class="strong"><em class="calibre20">i[6] = 121</em></span>, so the algorithm continues its examination. Also, <span class="strong"><em class="calibre20">i[7] = 143</em></span> which is not less than <span class="strong"><em class="calibre20">143</em></span>, so the execution proceeds to the final step. Since <span class="strong"><em class="calibre20">i[7] = 143</em></span>, we have found a match to our key and the value of <span class="strong"><em class="calibre20">i</em></span> can be returned. This search cost <span class="strong"><strong class="calibre16">O</strong></span>(5), which is only slightly better than the <span class="strong"><strong class="calibre16">O</strong></span>(7) the linear search produced and slightly worse than the <span class="strong"><strong class="calibre16">O</strong></span>(3) cost we found with a binary search. However, with much larger data sets the jump search is consistently more efficient than a linear and binary search when the collection is sorted.</p><p class="calibre7">Again, sorting the collection does represent some cost in time and performance up front, but the payoff over the life span of your application's run cycle is more than justifies the effort.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">Each of our implementations of the <code class="literal">BubbleSort</code> method begins by declaring three <code class="literal">int</code> variables to track the size of the collection, the step size, and the previously evaluated index. Following this, a <code class="literal">while</code> loop uses the <code class="literal">prev</code> and <code class="literal">step</code> values to define and search subsets of the collection for a range where the <code class="literal">key</code> could exist. If no acceptable subset is found, the method returns <code class="literal">-1</code> indicating that the <code class="literal">key</code> cannot exist in this set. Otherwise, the value of <code class="literal">prev</code> and <code class="literal">step</code> identify the subset where the <code class="literal">key</code> might exist.</p><p class="calibre7">The next <code class="literal">while</code> loop examines each element within the subset to determine if it is less than the <code class="literal">key</code>. If no acceptable element is found, the method returns <code class="literal">-1</code> indicating that the <code class="literal">key</code> cannot exist in this set. Otherwise, the value of <code class="literal">prev</code> identifies the best possible match for <code class="literal">key</code> in the subset.</p><p class="calibre7">Finally, the element at <code class="literal">prev</code> is compared to the <code class="literal">key</code>. If the two values match, then <code class="literal">prev</code> is returned. Otherwise, we reach the end of execution and <code class="literal">-1</code> is returned:</p><pre class="programlisting">    public int JumpSearch(int[] values, int key) 
    { 
        int n = values.Length; 
        int step = (int)Math.Sqrt(n); 
        int prev = 0; 
 
        while (values[Math.Min(step, n) - 1] &lt; key) 
        { 
            prev = step; 
            step += (int)Math.Floor(Math.Sqrt(n)); 
            if (prev &gt;= n) 
            { 
                return -1; 
            } 
        } 
 
        while (values[prev] &lt; key) 
        { 
            prev++; 
            if (prev == Math.Min(step, n)) 
            { 
                return -1; 
            } 
        } 
 
        if (values[prev] == key) 
        { 
            return prev; 
        } 
 
        return -1; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">The Java implementation of each method is nearly identical in design to the C# implementations, except for the name of the array <code class="literal">length</code> function.</p><pre class="programlisting">    public int jumpSearch(int[] values, int key) 
    { 
        int n = values.length; 
        int step = (int)Math.sqrt(n); 
        int prev = 0; 
 
        while (values[Math.min(step, n) - 1] &lt; key) 
        { 
            prev = step; 
            step += (int)Math.floor(Math.sqrt(n)); 
            if (prev &gt;= n) 
            { 
                return -1; 
            } 
        } 
 
        while (values[prev] &lt; key) 
        { 
            prev++; 
            if (prev == Math.min(step, n)) 
            { 
                return -1; 
            } 
        } 
 
        if (values[prev] == key) 
        { 
            return prev; 
        } 
 
        return -1; 
    } 
</pre><span class="strong"><strong class="calibre16">Objective-C</strong></span><p class="calibre7">Since <code class="literal">NSArray</code> can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code>. Otherwise, this implementation is fundamentally the same as the C# or Java implementations.</p><pre class="programlisting">    -(NSInteger)jumpSearchArray:(NSMutableArray&lt;NSNumber*&gt;*)values forKey: (NSInteger)key 
    { 
        NSInteger n = [values count]; 
        NSInteger step = sqrt(n); 
     
        NSInteger prev = 0; 
        while ([values[(int)fmin(step, n)-1] intValue] &lt; key) 
        { 
            prev = step; 
            step += floor(sqrt(n)); 
            if (prev &gt;= n) 
            { 
                return -1; 
            } 
        } 
     
        while ([values[prev] intValue] &lt; key) 
        { 
            prev++; 
            if (prev == fmin(step, n)) 
            { 
                return -1; 
            } 
        } 
     
        if ([values[prev] intValue] == key) 
        { 
            return prev; 
        } 
     
        return -1; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Aside from from the extra casting of values returned from <code class="literal">sqrt()</code> and <code class="literal">floor()</code> methods, the functionality is fundamentally the same as its predecessors:</p><pre class="programlisting">    open func jumpSearch( values: [Int], key: Int) -&gt; Int 
    { 
        let n: Int = values.count 
        var step: Int = Int(sqrt(Double(n))) 
     
        var prev: Int = 0 
     
        while values[min(step, n) - 1] &lt; key 
        { 
            prev = step 
            step = step + Int(floor(sqrt(Double(n)))) 
            if (prev &gt;= n) 
            { 
                return -1 
            } 
        } 
     
        while (values[prev] &lt; key) 
        { 
            prev = prev + 1 
            if (prev == min(step, n)) 
            { 
                return -1 
            } 
        } 
     
        if (values[prev] == key) 
        { 
            return prev 
        } 
     
        return -1 
    } 
</pre></div>
<div class="book" title="Summary" id="2BASE1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec71" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we examined several search algorithms. First, we looked at linear searching, or sequential searching. Linear searching is barely even an algorithm as your code is simply looping through the elements in a collection from left to right until a match is found. This approach is useful when working with very small collections, or with collections that have not been sorted, if for no other reason than it is easy to implement from a development point of view. However, when working with large sorted datasets, there are much better alternatives.</p><p class="calibre7">The next search algorithm we examined was the binary search. Binary search algorithms essentially divide-and-conquer the collection, halving the elements into smaller and smaller subsets of the original collection until a match is found or the list of possible matches has been exhausted. Whereas a linear search has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) complexity cost, a binary search pattern has a much improved <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>) complexity cost. However, it is absolutely vital that a collection be properly sorted prior to running the binary search or the results will be meaningless.</p><p class="calibre7">Finally, we examined the jump search. Jump searches work by sequentially examining subsets of the collection that are each √<span class="strong"><em class="calibre20">n</em></span> in length where <span class="strong"><em class="calibre20">n</em></span> is the total number of elements in the collection. Although somewhat more complex to implement, and with a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>), the jump search has a vastly improved average cost complexity of <span class="strong"><strong class="calibre16">O</strong></span>(√<span class="strong"><em class="calibre20">n</em></span>) where <span class="strong"><em class="calibre20">n</em></span> is the total number of elements in the collection.</p></div></body></html>