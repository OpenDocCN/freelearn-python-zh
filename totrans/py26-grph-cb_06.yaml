- en: Chapter 6. Working with Pictures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 处理图片
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Picture formats in native Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生 Python 中的图片格式
- en: Opening an image and discovering its attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开图像并发现其属性
- en: 'The Python image Library format conversions: `.jpg, .png, .tiff, .gif`, and,
    `.bmp`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 图片库格式转换：`.jpg, .png, .tiff, .gif`，以及 `.bmp`
- en: Image rotation in the plane
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面内的图像旋转
- en: Re-sizing images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图片大小
- en: Re-sizing with correct aspect ratio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按正确宽高比调整大小
- en: Rotating images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转图片
- en: Separating color bands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离颜色带
- en: Red, green, and blue color re-mixing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色、绿色和蓝色颜色重新混合
- en: Combining images by blending
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过混合组合图片
- en: Blending images by varying percentages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整百分比混合图片
- en: Making composites with image masks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像蒙版制作合成图
- en: Offset (roll) an image horizontally and vertically
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平和垂直偏移（滚动）图片
- en: 'Geometric transformations: horizontal and vertical flipping and rotation'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何变换：水平和垂直翻转和旋转
- en: 'Filters: sharpen, blur, edge enhance, emboss, smooth, contour, and detail'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器：锐化、模糊、边缘增强、浮雕、平滑、轮廓和细节
- en: Apparent rotation by re-sizing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整大小实现的明显旋转
- en: Now we will work with raster images. These are things like photographs, bitmap
    images, and digital paintings all the image types that are NOT the vector graphic
    drawings we have been using until now. Raster images are made up of pixels, which
    is short for picture elements. Vector images are defined and processed as mathematical
    shape and color expressions that can be altered by algebra and arithmetic directly
    under your control. These vector graphics are only one part of the computer graphics
    world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理栅格图像。这些包括照片、位图图像和数字绘画等所有图像类型，它们都不是我们至今一直在使用的矢量图形绘制。栅格图像由像素组成，这是图片元素的简称。矢量图像是定义为数学形状和颜色表达式，可以在您的直接控制下通过代数和算术进行修改。这些矢量图形只是计算机图形世界的一部分。
- en: The other part is concerned with the representation and manipulation of photographic
    images and painted bitmap images, generally referred to as raster images. The
    only raster image type that Python recognizes are **GIF** (**Graphics Interchange
    Format**) images which have a limited range of color capability `GIF` can work
    with 256 different colors as opposed to 16.7 million with `.png` or `.jpg`. The
    advantage is that `GIF` image control in Python allows you to animate them, but
    basic Tkinter provides no library of functions that can manipulate and alter raster
    images.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一部分涉及照片和绘制的位图图像的表示和处理，通常被称为栅格图像。Python 识别的唯一栅格图像类型是 **GIF**（**图形交换格式**）图像，它具有有限的颜色能力；`GIF`
    可以处理 256 种不同的颜色，而 `.png` 或 `.jpg` 则有 1670 万种。优点是 `GIF` 图像在 Python 中的控制允许您使它们动画化，但基本的
    Tkinter 提供的库中没有可以操作和改变栅格图像的函数。
- en: However, there is a very useful bundle of Python modules, the **Python Imaging
    Library** (**PIL**), which is designed just for raster image manipulation. It
    has most of the basic functions that good photo editing tools have. Modules in
    the PIL easily convert from one format to another including `GIF, PNG, TIFF, JPEG,
    BMP`. and `PIL` will work with many others, but the ones mentioned previously
    are probably the most common ones. The Python Image Library is an important part
    of your general graphics tool kit and skills repertoire.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个非常有用的 Python 模块集合，即 **Python Imaging Library**（**PIL**），它是专门为栅格图像操作设计的。它具有大多数优秀的照片编辑工具所拥有的基本功能。PIL
    模块可以轻松地将一种格式转换为另一种格式，包括 `GIF, PNG, TIFF, JPEG, BMP`，并且 `PIL` 还可以与许多其他格式一起工作，但前面提到的可能是最常见的。Python
    图片库是您一般图形工具包和技能库的重要组成部分。
- en: To reduce confusion, we shall use the file extension abbreviations, like `.gif,
    .png, .jpg` and so on as the name of file formats like `GIF, PNG`, and `JPEG`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少混淆，我们将使用文件扩展名缩写，如 `.gif, .png, .jpg` 等作为 `GIF, PNG` 和 `JPEG` 等文件格式的名称。
- en: Opening an image file and discovering its attributes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开图像文件并发现其属性
- en: First we need to test if the PIL is loaded into the library where the rest of
    our Python modules are. The simplest way to test this is to try and open a file
    using the `image_open()` function of the **Image** module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要测试 PIL 是否已加载到包含我们其他 Python 模块的库中。最简单的方法是尝试使用 **Image** 模块的 `image_open()`
    函数打开一个文件。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If the Python Imaging Library (PIL) is not already installed on our file system,
    and is ready and accessible to Python, we will need to find and install it. Tkinter
    is not needed for raster image processing. You will note that there are no from
    Tkinter import * and no root = tK() or root.mainloop() statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: You can download PIL from [http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This site contains source code, MS Windows installation executables, and handbooks
    in either HTML or `PDF` formats.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best explanatory documents on PIL is a `PDF` file at New Mexico Tech
    Computer Center [http:// infohost.nmt.edu/tcc/help/pubs/pil.pdf](http://%20infohost.nmt.edu/tcc/help/pubs/pil.pdf).
    It is clear and concise.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples that follow in this chapter, all images that get saved to
    our hard drive are placed into a folder called `picsx` inside the folder `constr`.
    This is to keep the results separate from the `pics1` folder which contains all
    the input images that will be used. This saves us from the dilemma of deciding
    what to keep and what to throw away. You should keep everything in `pics1` and
    can discard anything in `picsx` as it should be simple to re-run the programs
    that created those files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the following code into an editor and save it as `image_getattributes_1.py`
    and then execute as with all previous programs. In this program, we are going
    to use the PIL to discover the attributes of a `JPG` format image. Remember that
    although Python on its own only recognizes `GIF` images, the PIL module can work
    with many image formats. Until we can get this tiny program to work we can go
    no further using PIL.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Image** module, which is part of the PIL library, has a method `Image_open()`
    which opens files that are recognizable as image files. It does not display the
    images. This may be confusing. Opening a file means that our application program
    has found where the file is located and has dealt with all the permissions and
    administration required for loading the file. When you open a file, the file header
    is read to determine the file format and extract things like mode, size, and,
    other properties required to decode the file, but the rest of the file is not
    processed until later. Mode is a term used to refer to the way the data bytes
    containing the image are to be interpreted whether a particular byte refers to
    the red channel or the transparency channel and so on. Only when the **Image**
    module gets commands to view the file, change its size, view one of the color
    channels, rotate it, or any of the dozens of things that the modules in PIL can
    do to image files, will it actually be loaded from the hard drive and into memory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If we want to view the image, then we use the `im_1\. show()` method. Just add
    the line `im.show()` at the end.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to get image attributes? When we are going to change and manipulate
    images, we need to make changes to the attributes and therefore we often need
    to be able to find out what they are originally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要获取图像属性？当我们准备更改和操作图像时，我们需要更改属性，因此我们通常需要能够找出它们的原始属性。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The **Image** module of PIL (the Python Imaging Library) can read and write
    (open and save) the common image formats. The following formats can be both read
    and written: `BMP, GIF, IM, JPG, JPEG, JPE, PCX, PNG, PBM, PPN, TIF, TIFF, XBM,
    XPM`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PIL（Python Imaging Library）的 **Image** 模块可以读取和写入（打开和保存）常见的图像格式。以下格式既可以读取也可以写入：`BMP,
    GIF, IM, JPG, JPEG, JPE, PCX, PNG, PBM, PPN, TIF, TIFF, XBM, XPM`。
- en: 'The following file formats can only be read: `PCD, DCX, PSD`. If we needed
    to store image files which were `PCD, DCX`, or `PSD`, then we would first convert
    them into one of the file formats that did work like `PNG, TIFF, JPEG`, or `BMP`.
    Python on its own, without the PIL module, only deals with `GIF` files so these
    would be preferred file formats for self-contained applications. `JPG` files are
    ubiquitous and therefore we need to prove that the code we write can use `JPG,
    GIF, PNG`, and, `BMP` formats.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件格式只能读取：`PCD, DCX, PSD`。如果我们需要存储 `PCD, DCX` 或 `PSD` 格式的图像文件，那么我们首先需要将它们转换为像
    `PNG, TIFF, JPEG` 或 `BMP` 这样的有效文件格式。Python 本身（没有 PIL 模块）只处理 `GIF` 文件，因此这些将是自包含应用程序的首选文件格式。`JPG`
    文件非常普遍，因此我们需要证明我们编写的代码可以使用 `JPG, GIF, PNG` 和 `BMP` 格式。
- en: Things we need to know about image formats
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们需要了解的关于图像格式的知识
- en: 'It is useful to know the following about file image formats:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解以下关于文件图像格式的内容是有用的：
- en: '`GIF` image files are the smallest and fastest to use and transport down a
    wire. They are probably the best balance of image quality and file size. On the
    downside, they have a limited range of colors and are not good for high quality
    pictures.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIF` 图像文件是最小且使用和传输速度最快的，它们可能是图像质量和文件大小之间的最佳平衡。缺点是它们颜色范围有限，不适合高质量图片。'
- en: '`JPEG` images are the most common ones on the web. The quality can vary from
    high to low depending on what degree of compression you specify. A large image
    can be compressed substantially, but you will lose image quality.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JPEG` 图像是网络上最常见的。质量可以从高到低变化，这取决于你指定的压缩程度。大图像可以被大量压缩，但你会失去图像质量。'
- en: '`TIFF` images are large and high quality/resolution. Detailed engineering drawings
    are often archived as `TIFF` files.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIFF` 图像体积大，质量/分辨率高。详细的工程图纸通常以 `TIFF` 文件存档。'
- en: '`PNG` images are a modern high quality replacement for `GIF` files. But Tkinter
    will not recognize them.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PNG` 图像是 `GIF` 文件的现代高质量替代品。但 Tkinter 无法识别它们。'
- en: '`BMP` images are uncompressed and a bit old fashioned but there are still many
    around. Not recommended.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BMP` 图像是不压缩的，有点过时，但仍然有很多。不推荐使用。'
- en: When working with images in PIL, PNG images are a convenient form to use. However,
    if you are preparing images for display inside Python programs on the widest variety
    of platforms, then you need to convert them into GIF format before saving them.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在 PIL 中处理图像时，PNG 图像是一种方便使用的格式。然而，如果你正在为在多种平台上显示的 Python 程序中的图像做准备，那么在保存之前你需要将它们转换为
    GIF 格式。
- en: Images and the numbers game
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像与数字游戏
- en: Image formats are like studying ancient languages the more you learn, the more
    complicated things get. But here are the basic numbers governing them that give
    you some insight.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图像格式就像学习古代语言一样，学得越多，事情就越复杂。但这里有一些基本的数字规则，可以给你一些洞察。
- en: '`GIF` has a maximum of 256 colors, but can use a lot less.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIF` 格式最多支持 256 种颜色，但可以使用更少的颜色。'
- en: '`PNG` has a maximum of about 14000, different colors.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PNG` 格式最多支持约 14000 种不同的颜色。'
- en: '`JPEG` can handle 16 million the same number of colors as the `#rrggbb` numbers
    used in the previous chapter.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JPEG` 可以处理 1600 万种颜色，与上一章中使用的 `#rrggbb` 数字相同数量的颜色。'
- en: Most images from digital cameras are compressed into JPG images and this reduces
    the range of colors. Therefore, in most cases, we can convert them to PNG images
    without apparent loss of quality.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数数码相机的图像都压缩成 JPG 格式，这会减少颜色的范围。因此，在大多数情况下，我们可以将它们转换为 PNG 图像而不会出现明显的质量损失。
- en: Open, view, and save an image in a different file format
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以不同的文件格式打开、查看和保存图像
- en: Quite often, there is some image we want to work with but it is in the wrong
    format. Most web images are `JPEG` (`.jpg`) files. Native Python will only recognize
    `GIF` (`.gif`) formats.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是我们想处理某个图像，但它处于错误的格式。大多数网络图像都是 `JPEG`（`.jpg`）文件。原生 Python 只能识别 `GIF`（`.gif`）格式。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Get hold of a `.jpg` image file and save or copy it into a directory you have
    created for this imaging work. For the purpose of these exercises we are going
    to assume there is a directory named `constr` (abbreviation for "construction
    site"). In the code, you will see images addressed in the form `/constr/pics1/images-name.ext.
    image-name.ext` is the actual image you have selected to work with. This means
    that the Python program expects to find the file you are asking it to open, inside
    a system directory called `constr`. You can change this to wherever you decide
    is the best place for you to make a mess in like an artist's studio. The path
    to retrieve your image file can even be a web address.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个 `.jpg` 图像文件，并将其保存或复制到您为这项成像工作创建的目录中。为了进行这些练习，我们将假设有一个名为 `constr` 的目录（代表“建筑工地”）。在代码中，您将看到以
    `/constr/pics1/images-name.ext` 形式引用的图像。这意味着 Python 程序期望在名为 `constr` 的系统目录中找到您请求它打开的文件。您可以将此更改为您认为最适合您在类似艺术家工作室等地方弄乱的地方。检索您的图像文件的路径甚至可以是网址。
- en: So for this example, there is an image named `duzi_leo_1.jpg`, a `JPEG` image
    stored inside a folder (directory) called `pics1` which in turn is inside `constr`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，有一个名为 `duzi_leo_1.jpg` 的图像，一个存储在名为 `pics1` 的文件夹（目录）中的 `JPEG` 图像，而
    `pics1` 文件夹又位于 `constr` 目录中。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the program shown as follows in the usual fashion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照通常的方式执行以下所示的程序。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the typical Python fashion the designers of Python have made things as simple
    as they possibly could for the coder. What happens here is that we create an instance
    `im_1` of an image object which is in `JPEG` format (extension `.jpg)` and we
    command that it be saved as `PNG` (extension `.png)`. The complex conversion takes
    place out of sight. We display the image to reassure ourselves that it has been
    found.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照典型的 Python 风格，Python 的设计者已经尽可能地为程序员简化了事情。在这里发生的事情是，我们创建了一个名为 `im_1` 的图像对象实例，该对象以
    `JPEG` 格式（扩展名为 `.jpg`）存在，并命令将其保存为 `PNG` 格式（扩展名为 `.png`）。复杂的转换在幕后进行。我们展示图像以确信它已被找到。
- en: Finally we convert it to `PNG` format and save it as `duzi_leo_2.png`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将其转换为 `PNG` 格式并保存为 `duzi_leo_2.png`。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We would like to know that we can convert any image format to any other format.
    Unfortunately image formats are something of a tower of Babel phenomenon. For
    reasons of history, technology evolution, patent restrictions, and proprietary
    commercial hegemony many image formats were not intended to be openly readable.
    For instance up until 2004, `GIF` was proprietary. `PNG` was developed as an alternative.
    The next example presents code for discovering which conversions will work on
    your platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望知道我们可以将任何图像格式转换为任何其他格式。不幸的是，图像格式有点像巴别塔现象。由于历史原因、技术演变、专利限制和专有商业霸权，许多图像格式并非旨在公开读取。例如，直到
    2004 年，`GIF` 是专有的。`PNG` 是作为替代品开发的。下一个示例将展示用于发现您平台上的哪些转换将有效的代码。
- en: Image format conversion for JPEG, PNG, TIFF, GIF, BMP
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPEG、PNG、TIFF、GIF、BMP 图像格式转换
- en: 'We start with a `PNG` format image then save it in each of the following formats:
    `JPG, PNG, GIF, TIFF`, and `BMP` and save them on the local hard drive. Then we
    take the saved image formats and convert each in turn into the other formats.
    Thus we test all the likely conversion combinations.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个 `PNG` 格式的图像开始，然后将其保存为以下每种格式：`JPG、PNG、GIF、TIFF` 和 `BMP`，并将它们保存在本地硬盘上。然后我们取保存的图像格式，逐一将其转换为其他格式。这样我们就测试了所有可能的转换组合。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to place a `JPG` image into the folder `/constr/pics1`. A specific `PNG`
    image design to emphasize flaws in the different formats is provided with the
    name `test_pattern_a.png`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一个 `JPG` 图像放入 `/constr/pics1` 文件夹中。提供了一个名为 `test_pattern_a.png` 的特定 `PNG`
    图像，旨在强调不同格式中的缺陷。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the program shown as before. Read their describing 'metadata' on the
    command terminal
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前所示执行程序。在命令终端阅读它们的描述性 '元数据'
- en: '![How to do it...](img/3845_06_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3845_06_01.jpg)'
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This conversion just works if PIL is installed. One exception is that conversions
    from `GIF` to `JPG` will not work. It is interesting to have the contents of the
    folder `/constr/pics1` already open prior to executing the program and watch the
    images successively appear as the execution takes pace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换仅在 PIL 安装的情况下有效。一个例外是，从 `GIF` 到 `JPG` 的转换将不会工作。在执行程序之前，预先打开 `/constr/pics1`
    文件夹的内容，并观察图像在执行过程中依次出现，这很有趣。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that it is difficult to notice loss of image quality for any of the image
    qualities except for `GIF` images. The problems are most noticeable when the `GIF`
    conversion algorithm has to make a choice between two similar colors as shown
    in the figure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了`GIF`图像外，很难注意到任何图像质量丢失。问题最明显的是，当`GIF`转换算法必须如图所示在两种相似颜色之间做出选择时。
- en: Does size count?
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小重要吗？
- en: The original `test_pattern_1.jpg` was 77 kilobytes. All the images derived from
    it were four to ten times larger, even the low quality `GIF` images. The reason
    is that only the `JPG` and `GIF` images are lossy, meaning that some image information
    is discarded in the conversion and it can't be recovered.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`test_pattern_1.jpg`是77千字节。所有由此派生的图像大小是四到十倍，即使是低质量的`GIF`图像。原因是只有`JPG`和`GIF`图像是损失性的，这意味着在转换过程中会丢弃一些图像信息，并且无法恢复。
- en: Image rotation in the plane of the image
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像在图像平面上的旋转
- en: We have an image lying on its side and we need to fix it up by rotating it clockwise
    by 90 degrees. We want a stored copy of the corrected image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个侧躺的图像，我们需要通过顺时针旋转90度来修复它。我们想要存储修复后的图像副本。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to place a `PNG` image into the folder `/constr/pics1`. In the following
    code, we have used the image `dusi_leo.png`. This image has prominent red and
    yellow components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一个`PNG`图像放入文件夹`/constr/pics1`中。在以下代码中，我们使用了图像`dusi_leo.png`。此图像具有突出的红色和黄色成分。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Execute the program shown as before.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前显示的程序。
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The displayed image will be correctly oriented. Note that we can rotate the
    image by amounts as small as one degree, but no smaller than that. There are other
    transformations that can rotate an image to integer multiples of 90 degrees. These
    are demonstrated under the title Multiple Transformations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的图像将正确对齐。请注意，我们可以将图像旋转到最小为一度，但不能小于这个数值。还有其他变换可以将图像旋转到90度的整数倍。这些在标题为“多重变换”的部分进行了演示。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: How would we create the effect of a smoothly rotating image? Attempting it with
    PIL on its own does not work. PIL is designed to do the calculation intensive
    operations for manipulating and transforming images. It is not possible to display
    one image after another in a time-controlled sequence. For this, you would need
    Tkinter and Tkinter will only work with `GIF` images.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建平滑旋转图像的效果？仅使用PIL是无法实现的。PIL旨在执行图像操作和变换的计算密集型操作。不可能在时间控制的序列中显示一个图像接着另一个图像。为此，你需要Tkinter，而Tkinter只与`GIF`图像一起工作。
- en: What we would do would be to first create a series of images, each slightly
    more rotated than the previous one and store each image. Later, we would run a
    Python Tkinter program that displayed the series of images in a time-controlled
    sequence. This would animate the rotation. There are difficulties related to the
    fact that the rotated images must be placed in a frame that has the same size
    and orientation as the original image. These kinds of problems are tackled in
    the next chapter. Some surprisingly effective results can be achieved.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会首先创建一系列图像，每个图像比前一个图像稍微旋转一点，并存储每个图像。稍后，我们将运行一个Python Tkinter程序，以时间控制的序列显示这些图像系列。这将使旋转动画化。与旋转图像必须放置在具有与原始图像相同大小和方向的框架中的事实相关的问题将在下一章中解决。可以取得一些令人惊讶的有效结果。
- en: Image size alteration
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像大小调整
- en: We reduce the size of a large image file (1.8 megabytes) down to 24.7 kilobytes.
    But the image gets distorted because the height-to-width ratio is not taken into
    account.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个大型图像文件（1.8兆字节）的大小减小到24.7千字节。但是图像被扭曲了，因为没有考虑到高度与宽度的比例。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对之前的食谱所做的那样，我们需要将`dusi_leo.png`图像放入文件夹`/constr/pics1`中。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To change the size of an image we need to specify the final dimensions as well
    as specify a filter type that provides rules for filling in any pixel gaps that
    result from the re-sizing process. Execute the program shown as before. The following
    image shows the result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改图像的大小，我们需要指定最终尺寸，并指定一个过滤器类型，该类型提供填充由调整大小过程产生的任何像素间隙的规则。执行之前显示的程序。以下图像显示了结果。
- en: '![How to do it...](img/3845_06_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/3845_06_02.jpg)'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here we changed the size of a picture to fit a 300x300 pixel rectangle. If the
    image is increased in size, extra pixels need to be added. If the image is reduced,
    then pixels have to be discarded. Which particular pixels are added, what color
    they will be has to be decided automatically by an algorithm in the re-sizing
    method. There are several ways provided in PIL to do this. These pixel-adding
    algorithms are made available as **filters**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将图片的大小调整为适合 300x300 像素的矩形。如果图像增大，需要添加额外的像素。如果图像减小，则必须丢弃像素。添加哪些特定的像素，它们的颜色将如何确定，必须由调整大小方法中的算法自动决定。PIL
    提供了多种方法来完成这项工作。这些像素添加算法作为 **过滤器** 提供使用。
- en: This is what filters are designed for and in the preceding example we have chosen
    to use the nearest filter. This is documented as using the value of the NEAREST
    neighboring pixel. The documentation is a bit ambiguous because it does not explain
    which nearest pixel will be selected. In a rectangular grid, the pixels to the
    north, south, east, and west are equally close. Other possible filters to use
    are BILINEAR (linear interpolation in a 2x2 environment), BICUBIC (cubic spline
    interpolation in a 4x4 environment), or ANTIALIAS (a high-quality down-sampling
    filter).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是过滤器设计的目的，在前面的例子中，我们选择使用最近的过滤器。这被记录为使用最近的邻域像素的值。文档有些含糊不清，因为它没有解释将选择哪个最近的像素。在矩形网格中，北、南、东、西的像素距离相等。其他可能的过滤器包括
    BILINEAR（在 2x2 环境中的线性插值）、BICUBIC（在 4x4 环境中的三次样条插值）或 ANTIALIAS（高质量的下采样过滤器）。
- en: Reducing images also presents dilemmas. Picture elements (pixels) need to be
    discarded. What happens if there is a sharp edge in the image going from black
    to white? Do we throw away the last black pixel and replace it with a white one?
    Or replace it with one that is somewhere in between?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 减小图像也带来了困境。图片元素（像素）需要被丢弃。如果图像中有一个从黑色到白色的锐利边缘，会发生什么？我们是丢弃最后一个黑色像素并用白色像素替换它，还是用介于两者之间的像素替换它？
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The issue of which filters are best will vary from one type of image to another.
    Experience and experimentation are needed in this changing branch of image processing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些过滤器最好的问题会因图像类型而异。在这个不断变化的图像处理分支中，需要经验和实验。
- en: How do we preserve the correct height-to-width ratio of an image?
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何保持图像的正确宽高比？
- en: As shown in this example, unless we take steps to select the right target image
    size proportions, that photo of skinny aunt Milly will end up as wide Winifred
    and some members of the family will never be on good terms anymore if the pictures
    get shown around. Therefore, we demonstrate how to preserve proportion and decorum
    in the next recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，除非我们采取措施选择正确的目标图像尺寸比例，否则瘦阿姨 Milly 的照片将变成宽 Winifred，如果照片被展示出来，家庭成员之间可能永远无法和睦相处。因此，我们在下一个菜谱中展示了如何保持比例和礼仪。
- en: Correct proportion image resizing
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确的比例图像调整大小
- en: We make a reduced size image taking precautions to preserve the correct height-to-width,
    aspect ratio of the original image. The secret is to use the `Image.size()` function
    to get the exact image size beforehand and then make sure we maintain the same
    height-to-width ratio.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作一个缩小尺寸的图像，同时注意保持原始图像的正确宽高比和长宽比。秘诀是使用 `Image.size()` 函数事先获取确切的图像大小，然后确保我们保持相同的长宽比。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前的做法，我们需要将 `dusi_leo.png` 图像放入文件夹 `/constr/pics1`。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown as before.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前显示的程序。
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Image.size()` function returns two integers, - the width, size[0], and
    height, size[1] of the opened image. We use the scaling multiplier `new_size`
    to scale both the width and the height by the same proportion.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image.size()` 函数返回两个整数，- 打开图像的宽度，size[0]，和高度，size[1]。我们使用缩放乘数 `new_size` 以相同的比例缩放宽度和高度。'
- en: Separating one color band in an image
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中分离一个颜色带
- en: We isolate just the green portion or band of an image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅隔离图像的绿色部分或颜色带。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前的做法，我们需要将 `dusi_leo.png` 图像放入文件夹 `/constr/pics1`。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown as before.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前显示的程序。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Image.split()` function separates the three color bands of red, green,
    and blue in the original `JPG` image. The red band is `source[0]`, the green band
    is `source[1]`, and the blue band is `[2]. JPG` images do not have a transparency
    (alpha) band. `PNG` images can have an alpha band. If such a `PNG` image is `split()`,
    its transparency band would have been `source[3]`. The amount of color of a specific
    pixel in the image is recorded as a byte of data. You can alter this amount by
    a similar proportion for each pixel in the split band in the line `red_band =
    source[R].point(lambda i: i * proportion)`, where proportion is a number between
    `0.0` and `1.0`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image.split()`函数将原始`JPG`图像中的红色、绿色和蓝色三个颜色波段分离出来。红色波段是`source[0]`，绿色波段是`source[1]`，蓝色波段是`[2]`。`JPG`图像没有透明度（alpha）波段。`PNG`图像可以有alpha波段。如果这样的`PNG`图像被`split()`，其透明度波段将是`source[3]`。图像中特定像素的颜色量以字节数据记录。您可以通过在分割波段中为每个像素的比例进行类似的调整来改变这个量，例如在`red_band
    = source[R].point(lambda i: i * proportion)`这一行中，其中比例是一个介于`0.0`和`1.0`之间的数字。'
- en: In this recipe, we eliminate all red and blue by using the value `0.0` for the
    proportion amount.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过将比例量设置为`0.0`来消除所有红色和蓝色。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, we mix the three colors in non-zero proportions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们以非零比例混合三种颜色。
- en: Red, green, and blue color alteration in images
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像中的红、绿、蓝颜色调整
- en: We go further in this example to make an image that re-mixes the colors of the
    original in different proportions. The same code layout is used as in the previous
    example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们进一步制作了一个重新混合原始图像颜色的图像，以不同的比例。与之前的例子使用相同的代码布局。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As before place the `dusi_leo.png` image into the folder `/constr/pics1`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将`dusi_leo.png`图像放入文件夹`/constr/pics1`中。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the following code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码。
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As before, the `Image.split()` function separates the three color bands of red,
    green, and blue from the original `JPG` image. In this case, the amounts of each
    red, green, and blue are 200%, 20%, and 0% of blue respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Image.split()`函数将原始`JPG`图像的红色、绿色和蓝色三个颜色波段分离出来。在这种情况下，红色、绿色和蓝色的比例分别是蓝色200%，20%，和0%。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Altering the proportion of colors in existing pictures is a complex and subtle
    art and as we did in the previous chapters, in the next example we provide a recipe
    that uses slide controls to allow the user to use trial and error to achieve a
    desirable color mix on a band-separated image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有图片中调整颜色比例是一种复杂而微妙的艺术，正如我们在前面的章节中所做的那样，在下一个例子中，我们提供了一个使用滑动控制来允许用户通过试错法在波段分离的图像上达到期望颜色混合的菜谱。
- en: Slider controlled color manipulation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑块控制的颜色调整
- en: We construct a tool for the purpose of obtaining a desirable color mix on a
    band-separated image. The slide control, which we have used previously, is a convenient
    device for consciously adjusting the relative proportions of color in each primary
    color band.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个工具，用于在波段分离的图像上获得期望的颜色混合。之前我们使用过的滑动控制是一个方便的设备，用于有意识地调整每个主色波段中颜色的相对比例。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Use the `dusi_leo.png` image from the folder `/constr/pics1`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件夹`/constr/pics1`中的`dusi_leo.png`图像。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the following program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下程序。
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using mouse-controlled slider positions, we adjust the amount of color intensity
    in each of the red, green, and blue channels. The scale of adjustment goes from
    zero to 200, but is scaled to a percentage value in the callback functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标控制的滑块位置，我们调整每个红色、绿色和蓝色通道中的颜色强度。调整的幅度从零到200，但在回调函数中缩放到百分比值。
- en: 'In `source = im_1.split()`, the `split()` method separates the image into red,
    green, and blue bands. The `point(lambda i: i * intensity)` method multiplies
    the color value for each pixel in a band by an ''intensity'' value and the `merge(im_1.mode,
    new_source)` method re-combines the resultant bands into a new image.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '在`source = im_1.split()`中，`split()`方法将图像分割成红色、绿色和蓝色波段。`point(lambda i: i *
    intensity)`方法将每个波段中每个像素的颜色值乘以一个`intensity`值，而`merge(im_1.mode, new_source)`方法将结果波段重新组合成一个新的图像。'
- en: In this example PIL and Tkinter are being used together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了PIL和Tkinter一起。
- en: 'If you use `from Tkinter import *`, you seem to get namespace confusion:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`from Tkinter import *`，你似乎会得到命名空间混淆：
- en: 'The interpreter says:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器说：
- en: '`" im_1 = Image.open("/a_constr/pics1/redcar.jpg")`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`" im_1 = Image.open("/a_constr/pics1/redcar.jpg")`'
- en: '`AttributeError: class Image has no attribute ''open'' "`,'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttributeError: class Image has no attribute ''open'' "`'
- en: but if you just say `import Tkinter` it seems ok.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只是说`import Tkinter`，这似乎是可行的。
- en: But of course now you have to prefix all Tkinter methods with Tkinter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然现在你必须将Tkinter的所有方法前缀为Tkinter。
- en: Combining images by blending
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过混合组合图像
- en: The effect of blending two images is like projecting two transparent slide images
    onto a projector screen from two separate projectors where the amount of light
    from each projector is controlled by proportion setting. The command is of the
    form `Image.blend(image_1, image_2, proportion-of-image_1)`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 混合两个图像的效果就像从两个不同的投影仪将两个透明的幻灯片图像投射到投影仪屏幕上，每个投影仪的光量由比例设置控制。命令的形式是`Image.blend(image_1,
    image_2, proportion-of-image_1)`。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use the two images `100_canary.png` and `100_cockcrow.png` from the folder `/constr/pics1`.
    The `100_` in the titles is a reminder that the images are 100 x 100 pixels in
    size and we will see the format, size, and type of each image printed onto the
    console.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自文件夹`/constr/pics1`的两个图像`100_canary.png`和`100_cockcrow.png`。标题中的`100_`是一个提醒，表示这些图像的大小是100
    x 100像素，我们将在控制台上看到每个图像的格式、大小和类型。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the two identical size and mode images in place, execute the following
    code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好两个大小和模式相同的图像后，执行以下代码。
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: From format information, we will see that the mode of the first image is `RGBA`
    while the second is `RGB`. Therefore, it is necessary to first convert the second
    image to `RGBA`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从格式信息中，我们可以看到第一幅图像的模式是`RGBA`，而第二幅是`RGB`。因此，首先需要将第二幅图像转换为`RGBA`。
- en: In this particular example, the proportion control was set to `0.5`. That is,
    the two images were blended together by equal amounts. If the proportion setting
    had been `0.2`, then `20%` of `im_1` would have been combined with `80%` of `im_2`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，比例控制被设置为`0.5`。这意味着两幅图像以相等的量混合在一起。如果比例设置是`0.2`，那么`im_1`的`20%`将与`im_2`的`80%`结合。
- en: More Info Section 1
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息部分1
- en: Another way of combining images would be to use a third image as a mask to control
    the positions where the mask determines both the shape and the proportion of each
    image in the resulting image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种组合图像的方法是使用第三幅图像作为遮罩来控制遮罩确定的结果图像中每个图像的形状和比例的位置。
- en: Blending images by varying percentages
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过改变百分比混合图像
- en: We blend two images with various amounts of transparency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以不同的透明度混合两个图像。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the two identical size and mode images in place, execute the following
    code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好两个大小和模式相同的图像后，执行以下代码。
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By changing the amount of alpha with which the images are blended, we can control
    the degree to which each image dominates in the result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变图像混合时使用的alpha值，我们可以控制每个图像在结果中占主导的程度。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: This kind of process performed on each frame of a movie is the kind of effect
    often used to fade from one scene to another.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在每个电影帧上执行的过程是常用于从一个场景淡出到另一个场景的效果。
- en: Make a composite image using a mask image
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用遮罩图像制作合成图像
- en: Here, we control the combination of two images using the function `Image.composite(image_1,
    image_2, mask_image)`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数`Image.composite(image_1, image_2, mask_image)`来控制两个图像的组合。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use the images `100_canary.png, 100_cockcrow.png`, and `100_sun_1.png` from
    the folder `/constr/pics1`. The `100_` in the titles is a reminder that the images
    are 100 x 100 pixels in size and we will see the format, size, and type of each
    image printed onto the console.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自文件夹`/constr/pics1`的图像`100_canary.png, 100_cockcrow.png`和`100_sun_1.png`。标题中的`100_`是一个提醒，表示这些图像的大小是100
    x 100像素，我们将在控制台上看到每个图像的格式、大小和类型。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the three identical size and mode images in place, execute the following
    code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好三个大小和模式相同的图像后，执行以下代码。
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: From format information, we will see that the mode of the first image is `RGBA`
    while the second is `RGB`. Therefore, it is necessary to first convert the second
    image to `RGBA`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从格式信息中，我们可以看到第一幅图像的模式是`RGBA`，而第二幅是`RGB`。因此，首先需要将第二幅图像转换为`RGBA`。
- en: The mask image has to be of the form `1, L`, or `RGBA` and of the same size.
    In this recipe, we have converted it to mode `L` which is a 256 value gray-scale
    image. The value of each pixel in the mask is used to multiply the source images.
    If the value of a particular pixel in a certain location was `56`, then `image_1`
    would be multiplied by `256 56 =200` and `image_2` would be multiplied by `56`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other effects like `Image.eval(function, Image)` where each pixel
    is multiplied by the function and we can convert the function to some complicated
    algebraic expression. If the image has multiple bands, then the function is applied
    to each band.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Another effect is the `Image.merge(mode, bandList)` which creates a multi-band
    image from multiple single-band images of equal size. We specify the desired mode
    of the new image. The **bandList specifier** is a sequence of single-band image
    components to be combined.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the image operations shown previously in combinations, there are an endless
    number of effects that can be achieved. We would be delving into the world of
    image and signal processing which can get extremely complex and sophisticated.
    Certain effects have become fairly standard and can be seen in the list of filtering
    options available in image-processing applications like `GIMP` and `Photoshop`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Offset (roll) image horizontally and vertically
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We see here how to roll an image. That is, to shift it to the right or left
    without losing anything - the image effectively rolls as if the edges were joined.
    The same process will work in the vertical direction.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the image `canary_a.jpg` from the folder `/constr/pics1`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following program noting that we need to import a module belonging
    to PIL called `ImageChops`. The **Chops** stands for **channel operations**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The excellent guide *Python Imaging Library* by John Shipman written in mid
    2009 does not mention ImageChops.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Flip horizontally, vertically, and rotate
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we look at a set of quick and easy transformations that are typical of
    the operations we would need in a photo viewer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `image dusi_leo_1.jpg` from the folder `/constr/pics1`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following program and see the results in `/constr/picsx`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding commands are self-explanatory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter effects: blur, sharpen, contrast, and so on'
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PIL has an **ImageFilter** module that has a useful selection of filters for
    enhancing certain characteristics of images such as sharpening features that were
    blurred. Ten of these filters are demonstrated in the following recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the images `russian_doll.png` from the folder `/constr/pics1`. Create a
    folder `/constr/picsx` for the resulting filtered images. Using a separate folder
    for the results helps prevent the folder `pics1` from becoming overcrowded with
    a heap of redundant images and work-in-progress. After each execution, we can
    delete the contents of `picsx` without the fear of losing source images for the
    recipes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the folder `/constr/picsx` on your screen before you execute the following
    code and watch as the images appear once the execution is complete. The source
    image was chosen to have a blurred Russian doll on an in-focus background because
    it allows the effects of the different filters to be readily distinguished.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows that the best filtering results are highly dependent on both
    the feature of the image we wish to enhance or suppress, as well as some subtle
    characteristics of the individual image being worked on. In the particular example
    of the Russian doll used here, the `EDGE_ENHANCE` filter is particularly effective
    for counteracting the poor focus of the doll. It improves the color contrast in
    comparison to the `SHARPEN` filter. Re-size and paste for synthetic rotation
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We want to create an animation that makes an image apparently rotate around
    a vertical axis in the middle of the picture. In this recipe, we see how the basic
    sequences of images for the animation are prepared.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We want to make a sequence of images that are progressively narrower as if they
    were a poster on a board that was being gradually rotated. Then, we want to paste
    these narrow images in the middle of a standard-sized black background. If this
    sequence were displayed as a time-controlled series of frames, we would see the
    image apparently rotating around a central vertical axis.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the image `100_canary.png` in a directory `/constr/pics1` and we place
    the results in `/constr/picsx` to avoid cluttering our source folder `/constr/pics1`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again open the folder `/constr/picsx` on your screen before you execute the
    following code and watch as the images appear once the execution is complete.
    This is not necessary but it is interesting to watch the results materialize before
    your eyes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To mimic the effect of rotation, we reduce the width of each image to `cosine(new_angle)`
    where `new_angle` is increased by 5 degrees of rotation for each image. Then we
    take this narrowed image and paste it onto a blank black square. Finally we name
    each picture in the sequence in a systematic way such as `canary0.gif, canary1.gif`,
    and so on until the last image is named `canary36.gif`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example demonstrates the kind of task the Python Imaging Library is well-suited
    to - when you need to repeatedly perform a controlled transformation on an image
    or collection of images. The images could be the frames of a video film. Effects
    like fade-in and fade-out, zoom-out, color-shift, sharpen, and blur are the obvious
    ones that can be used but your programmer's imagination will be able to come up
    with many others.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了Python图像库非常适合的任务类型——当你需要反复对一个图像或一组图像执行受控的转换时。这些图像可能是电影胶片的帧。如淡入淡出、缩放、颜色变换、锐化、模糊等效果是显而易见的，可以用到的，但你的程序员的想象力还能想出许多其他的效果。
