- en: Chapter 6. Working with Pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Picture formats in native Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening an image and discovering its attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python image Library format conversions: `.jpg, .png, .tiff, .gif`, and,
    `.bmp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image rotation in the plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-sizing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-sizing with correct aspect ratio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating color bands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red, green, and blue color re-mixing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining images by blending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blending images by varying percentages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making composites with image masks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offset (roll) an image horizontally and vertically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Geometric transformations: horizontal and vertical flipping and rotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filters: sharpen, blur, edge enhance, emboss, smooth, contour, and detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apparent rotation by re-sizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we will work with raster images. These are things like photographs, bitmap
    images, and digital paintings all the image types that are NOT the vector graphic
    drawings we have been using until now. Raster images are made up of pixels, which
    is short for picture elements. Vector images are defined and processed as mathematical
    shape and color expressions that can be altered by algebra and arithmetic directly
    under your control. These vector graphics are only one part of the computer graphics
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The other part is concerned with the representation and manipulation of photographic
    images and painted bitmap images, generally referred to as raster images. The
    only raster image type that Python recognizes are **GIF** (**Graphics Interchange
    Format**) images which have a limited range of color capability `GIF` can work
    with 256 different colors as opposed to 16.7 million with `.png` or `.jpg`. The
    advantage is that `GIF` image control in Python allows you to animate them, but
    basic Tkinter provides no library of functions that can manipulate and alter raster
    images.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a very useful bundle of Python modules, the **Python Imaging
    Library** (**PIL**), which is designed just for raster image manipulation. It
    has most of the basic functions that good photo editing tools have. Modules in
    the PIL easily convert from one format to another including `GIF, PNG, TIFF, JPEG,
    BMP`. and `PIL` will work with many others, but the ones mentioned previously
    are probably the most common ones. The Python Image Library is an important part
    of your general graphics tool kit and skills repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce confusion, we shall use the file extension abbreviations, like `.gif,
    .png, .jpg` and so on as the name of file formats like `GIF, PNG`, and `JPEG`.
  prefs: []
  type: TYPE_NORMAL
- en: Opening an image file and discovering its attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we need to test if the PIL is loaded into the library where the rest of
    our Python modules are. The simplest way to test this is to try and open a file
    using the `image_open()` function of the **Image** module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the Python Imaging Library (PIL) is not already installed on our file system,
    and is ready and accessible to Python, we will need to find and install it. Tkinter
    is not needed for raster image processing. You will note that there are no from
    Tkinter import * and no root = tK() or root.mainloop() statements.
  prefs: []
  type: TYPE_NORMAL
- en: You can download PIL from [http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)
  prefs: []
  type: TYPE_NORMAL
- en: This site contains source code, MS Windows installation executables, and handbooks
    in either HTML or `PDF` formats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best explanatory documents on PIL is a `PDF` file at New Mexico Tech
    Computer Center [http:// infohost.nmt.edu/tcc/help/pubs/pil.pdf](http://%20infohost.nmt.edu/tcc/help/pubs/pil.pdf).
    It is clear and concise.
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples that follow in this chapter, all images that get saved to
    our hard drive are placed into a folder called `picsx` inside the folder `constr`.
    This is to keep the results separate from the `pics1` folder which contains all
    the input images that will be used. This saves us from the dilemma of deciding
    what to keep and what to throw away. You should keep everything in `pics1` and
    can discard anything in `picsx` as it should be simple to re-run the programs
    that created those files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the following code into an editor and save it as `image_getattributes_1.py`
    and then execute as with all previous programs. In this program, we are going
    to use the PIL to discover the attributes of a `JPG` format image. Remember that
    although Python on its own only recognizes `GIF` images, the PIL module can work
    with many image formats. Until we can get this tiny program to work we can go
    no further using PIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Image** module, which is part of the PIL library, has a method `Image_open()`
    which opens files that are recognizable as image files. It does not display the
    images. This may be confusing. Opening a file means that our application program
    has found where the file is located and has dealt with all the permissions and
    administration required for loading the file. When you open a file, the file header
    is read to determine the file format and extract things like mode, size, and,
    other properties required to decode the file, but the rest of the file is not
    processed until later. Mode is a term used to refer to the way the data bytes
    containing the image are to be interpreted whether a particular byte refers to
    the red channel or the transparency channel and so on. Only when the **Image**
    module gets commands to view the file, change its size, view one of the color
    channels, rotate it, or any of the dozens of things that the modules in PIL can
    do to image files, will it actually be loaded from the hard drive and into memory.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to view the image, then we use the `im_1\. show()` method. Just add
    the line `im.show()` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to get image attributes? When we are going to change and manipulate
    images, we need to make changes to the attributes and therefore we often need
    to be able to find out what they are originally.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Image** module of PIL (the Python Imaging Library) can read and write
    (open and save) the common image formats. The following formats can be both read
    and written: `BMP, GIF, IM, JPG, JPEG, JPE, PCX, PNG, PBM, PPN, TIF, TIFF, XBM,
    XPM`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file formats can only be read: `PCD, DCX, PSD`. If we needed
    to store image files which were `PCD, DCX`, or `PSD`, then we would first convert
    them into one of the file formats that did work like `PNG, TIFF, JPEG`, or `BMP`.
    Python on its own, without the PIL module, only deals with `GIF` files so these
    would be preferred file formats for self-contained applications. `JPG` files are
    ubiquitous and therefore we need to prove that the code we write can use `JPG,
    GIF, PNG`, and, `BMP` formats.'
  prefs: []
  type: TYPE_NORMAL
- en: Things we need to know about image formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is useful to know the following about file image formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GIF` image files are the smallest and fastest to use and transport down a
    wire. They are probably the best balance of image quality and file size. On the
    downside, they have a limited range of colors and are not good for high quality
    pictures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JPEG` images are the most common ones on the web. The quality can vary from
    high to low depending on what degree of compression you specify. A large image
    can be compressed substantially, but you will lose image quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIFF` images are large and high quality/resolution. Detailed engineering drawings
    are often archived as `TIFF` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PNG` images are a modern high quality replacement for `GIF` files. But Tkinter
    will not recognize them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BMP` images are uncompressed and a bit old fashioned but there are still many
    around. Not recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with images in PIL, PNG images are a convenient form to use. However,
    if you are preparing images for display inside Python programs on the widest variety
    of platforms, then you need to convert them into GIF format before saving them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Images and the numbers game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Image formats are like studying ancient languages the more you learn, the more
    complicated things get. But here are the basic numbers governing them that give
    you some insight.
  prefs: []
  type: TYPE_NORMAL
- en: '`GIF` has a maximum of 256 colors, but can use a lot less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PNG` has a maximum of about 14000, different colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JPEG` can handle 16 million the same number of colors as the `#rrggbb` numbers
    used in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most images from digital cameras are compressed into JPG images and this reduces
    the range of colors. Therefore, in most cases, we can convert them to PNG images
    without apparent loss of quality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open, view, and save an image in a different file format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, there is some image we want to work with but it is in the wrong
    format. Most web images are `JPEG` (`.jpg`) files. Native Python will only recognize
    `GIF` (`.gif`) formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get hold of a `.jpg` image file and save or copy it into a directory you have
    created for this imaging work. For the purpose of these exercises we are going
    to assume there is a directory named `constr` (abbreviation for "construction
    site"). In the code, you will see images addressed in the form `/constr/pics1/images-name.ext.
    image-name.ext` is the actual image you have selected to work with. This means
    that the Python program expects to find the file you are asking it to open, inside
    a system directory called `constr`. You can change this to wherever you decide
    is the best place for you to make a mess in like an artist's studio. The path
    to retrieve your image file can even be a web address.
  prefs: []
  type: TYPE_NORMAL
- en: So for this example, there is an image named `duzi_leo_1.jpg`, a `JPEG` image
    stored inside a folder (directory) called `pics1` which in turn is inside `constr`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown as follows in the usual fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the typical Python fashion the designers of Python have made things as simple
    as they possibly could for the coder. What happens here is that we create an instance
    `im_1` of an image object which is in `JPEG` format (extension `.jpg)` and we
    command that it be saved as `PNG` (extension `.png)`. The complex conversion takes
    place out of sight. We display the image to reassure ourselves that it has been
    found.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we convert it to `PNG` format and save it as `duzi_leo_2.png`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We would like to know that we can convert any image format to any other format.
    Unfortunately image formats are something of a tower of Babel phenomenon. For
    reasons of history, technology evolution, patent restrictions, and proprietary
    commercial hegemony many image formats were not intended to be openly readable.
    For instance up until 2004, `GIF` was proprietary. `PNG` was developed as an alternative.
    The next example presents code for discovering which conversions will work on
    your platform.
  prefs: []
  type: TYPE_NORMAL
- en: Image format conversion for JPEG, PNG, TIFF, GIF, BMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with a `PNG` format image then save it in each of the following formats:
    `JPG, PNG, GIF, TIFF`, and `BMP` and save them on the local hard drive. Then we
    take the saved image formats and convert each in turn into the other formats.
    Thus we test all the likely conversion combinations.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to place a `JPG` image into the folder `/constr/pics1`. A specific `PNG`
    image design to emphasize flaws in the different formats is provided with the
    name `test_pattern_a.png`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown as before. Read their describing 'metadata' on the
    command terminal
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This conversion just works if PIL is installed. One exception is that conversions
    from `GIF` to `JPG` will not work. It is interesting to have the contents of the
    folder `/constr/pics1` already open prior to executing the program and watch the
    images successively appear as the execution takes pace.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that it is difficult to notice loss of image quality for any of the image
    qualities except for `GIF` images. The problems are most noticeable when the `GIF`
    conversion algorithm has to make a choice between two similar colors as shown
    in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: Does size count?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original `test_pattern_1.jpg` was 77 kilobytes. All the images derived from
    it were four to ten times larger, even the low quality `GIF` images. The reason
    is that only the `JPG` and `GIF` images are lossy, meaning that some image information
    is discarded in the conversion and it can't be recovered.
  prefs: []
  type: TYPE_NORMAL
- en: Image rotation in the plane of the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have an image lying on its side and we need to fix it up by rotating it clockwise
    by 90 degrees. We want a stored copy of the corrected image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to place a `PNG` image into the folder `/constr/pics1`. In the following
    code, we have used the image `dusi_leo.png`. This image has prominent red and
    yellow components.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The displayed image will be correctly oriented. Note that we can rotate the
    image by amounts as small as one degree, but no smaller than that. There are other
    transformations that can rotate an image to integer multiples of 90 degrees. These
    are demonstrated under the title Multiple Transformations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How would we create the effect of a smoothly rotating image? Attempting it with
    PIL on its own does not work. PIL is designed to do the calculation intensive
    operations for manipulating and transforming images. It is not possible to display
    one image after another in a time-controlled sequence. For this, you would need
    Tkinter and Tkinter will only work with `GIF` images.
  prefs: []
  type: TYPE_NORMAL
- en: What we would do would be to first create a series of images, each slightly
    more rotated than the previous one and store each image. Later, we would run a
    Python Tkinter program that displayed the series of images in a time-controlled
    sequence. This would animate the rotation. There are difficulties related to the
    fact that the rotated images must be placed in a frame that has the same size
    and orientation as the original image. These kinds of problems are tackled in
    the next chapter. Some surprisingly effective results can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Image size alteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We reduce the size of a large image file (1.8 megabytes) down to 24.7 kilobytes.
    But the image gets distorted because the height-to-width ratio is not taken into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change the size of an image we need to specify the final dimensions as well
    as specify a filter type that provides rules for filling in any pixel gaps that
    result from the re-sizing process. Execute the program shown as before. The following
    image shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we changed the size of a picture to fit a 300x300 pixel rectangle. If the
    image is increased in size, extra pixels need to be added. If the image is reduced,
    then pixels have to be discarded. Which particular pixels are added, what color
    they will be has to be decided automatically by an algorithm in the re-sizing
    method. There are several ways provided in PIL to do this. These pixel-adding
    algorithms are made available as **filters**.
  prefs: []
  type: TYPE_NORMAL
- en: This is what filters are designed for and in the preceding example we have chosen
    to use the nearest filter. This is documented as using the value of the NEAREST
    neighboring pixel. The documentation is a bit ambiguous because it does not explain
    which nearest pixel will be selected. In a rectangular grid, the pixels to the
    north, south, east, and west are equally close. Other possible filters to use
    are BILINEAR (linear interpolation in a 2x2 environment), BICUBIC (cubic spline
    interpolation in a 4x4 environment), or ANTIALIAS (a high-quality down-sampling
    filter).
  prefs: []
  type: TYPE_NORMAL
- en: Reducing images also presents dilemmas. Picture elements (pixels) need to be
    discarded. What happens if there is a sharp edge in the image going from black
    to white? Do we throw away the last black pixel and replace it with a white one?
    Or replace it with one that is somewhere in between?
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The issue of which filters are best will vary from one type of image to another.
    Experience and experimentation are needed in this changing branch of image processing.
  prefs: []
  type: TYPE_NORMAL
- en: How do we preserve the correct height-to-width ratio of an image?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As shown in this example, unless we take steps to select the right target image
    size proportions, that photo of skinny aunt Milly will end up as wide Winifred
    and some members of the family will never be on good terms anymore if the pictures
    get shown around. Therefore, we demonstrate how to preserve proportion and decorum
    in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Correct proportion image resizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We make a reduced size image taking precautions to preserve the correct height-to-width,
    aspect ratio of the original image. The secret is to use the `Image.size()` function
    to get the exact image size beforehand and then make sure we maintain the same
    height-to-width ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Image.size()` function returns two integers, - the width, size[0], and
    height, size[1] of the opened image. We use the scaling multiplier `new_size`
    to scale both the width and the height by the same proportion.
  prefs: []
  type: TYPE_NORMAL
- en: Separating one color band in an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We isolate just the green portion or band of an image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did for the previous recipe, we need to place the `dusi_leo.png` image
    into the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Image.split()` function separates the three color bands of red, green,
    and blue in the original `JPG` image. The red band is `source[0]`, the green band
    is `source[1]`, and the blue band is `[2]. JPG` images do not have a transparency
    (alpha) band. `PNG` images can have an alpha band. If such a `PNG` image is `split()`,
    its transparency band would have been `source[3]`. The amount of color of a specific
    pixel in the image is recorded as a byte of data. You can alter this amount by
    a similar proportion for each pixel in the split band in the line `red_band =
    source[R].point(lambda i: i * proportion)`, where proportion is a number between
    `0.0` and `1.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we eliminate all red and blue by using the value `0.0` for the
    proportion amount.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next recipe, we mix the three colors in non-zero proportions.
  prefs: []
  type: TYPE_NORMAL
- en: Red, green, and blue color alteration in images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We go further in this example to make an image that re-mixes the colors of the
    original in different proportions. The same code layout is used as in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before place the `dusi_leo.png` image into the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, the `Image.split()` function separates the three color bands of red,
    green, and blue from the original `JPG` image. In this case, the amounts of each
    red, green, and blue are 200%, 20%, and 0% of blue respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Altering the proportion of colors in existing pictures is a complex and subtle
    art and as we did in the previous chapters, in the next example we provide a recipe
    that uses slide controls to allow the user to use trial and error to achieve a
    desirable color mix on a band-separated image.
  prefs: []
  type: TYPE_NORMAL
- en: Slider controlled color manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We construct a tool for the purpose of obtaining a desirable color mix on a
    band-separated image. The slide control, which we have used previously, is a convenient
    device for consciously adjusting the relative proportions of color in each primary
    color band.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `dusi_leo.png` image from the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using mouse-controlled slider positions, we adjust the amount of color intensity
    in each of the red, green, and blue channels. The scale of adjustment goes from
    zero to 200, but is scaled to a percentage value in the callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `source = im_1.split()`, the `split()` method separates the image into red,
    green, and blue bands. The `point(lambda i: i * intensity)` method multiplies
    the color value for each pixel in a band by an ''intensity'' value and the `merge(im_1.mode,
    new_source)` method re-combines the resultant bands into a new image.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example PIL and Tkinter are being used together.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `from Tkinter import *`, you seem to get namespace confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpreter says:'
  prefs: []
  type: TYPE_NORMAL
- en: '`" im_1 = Image.open("/a_constr/pics1/redcar.jpg")`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AttributeError: class Image has no attribute ''open'' "`,'
  prefs: []
  type: TYPE_NORMAL
- en: but if you just say `import Tkinter` it seems ok.
  prefs: []
  type: TYPE_NORMAL
- en: But of course now you have to prefix all Tkinter methods with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Combining images by blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effect of blending two images is like projecting two transparent slide images
    onto a projector screen from two separate projectors where the amount of light
    from each projector is controlled by proportion setting. The command is of the
    form `Image.blend(image_1, image_2, proportion-of-image_1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the two images `100_canary.png` and `100_cockcrow.png` from the folder `/constr/pics1`.
    The `100_` in the titles is a reminder that the images are 100 x 100 pixels in
    size and we will see the format, size, and type of each image printed onto the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the two identical size and mode images in place, execute the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From format information, we will see that the mode of the first image is `RGBA`
    while the second is `RGB`. Therefore, it is necessary to first convert the second
    image to `RGBA`.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, the proportion control was set to `0.5`. That is,
    the two images were blended together by equal amounts. If the proportion setting
    had been `0.2`, then `20%` of `im_1` would have been combined with `80%` of `im_2`.
  prefs: []
  type: TYPE_NORMAL
- en: More Info Section 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way of combining images would be to use a third image as a mask to control
    the positions where the mask determines both the shape and the proportion of each
    image in the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: Blending images by varying percentages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We blend two images with various amounts of transparency.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the two identical size and mode images in place, execute the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By changing the amount of alpha with which the images are blended, we can control
    the degree to which each image dominates in the result.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of process performed on each frame of a movie is the kind of effect
    often used to fade from one scene to another.
  prefs: []
  type: TYPE_NORMAL
- en: Make a composite image using a mask image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we control the combination of two images using the function `Image.composite(image_1,
    image_2, mask_image)`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the images `100_canary.png, 100_cockcrow.png`, and `100_sun_1.png` from
    the folder `/constr/pics1`. The `100_` in the titles is a reminder that the images
    are 100 x 100 pixels in size and we will see the format, size, and type of each
    image printed onto the console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the three identical size and mode images in place, execute the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From format information, we will see that the mode of the first image is `RGBA`
    while the second is `RGB`. Therefore, it is necessary to first convert the second
    image to `RGBA`.
  prefs: []
  type: TYPE_NORMAL
- en: The mask image has to be of the form `1, L`, or `RGBA` and of the same size.
    In this recipe, we have converted it to mode `L` which is a 256 value gray-scale
    image. The value of each pixel in the mask is used to multiply the source images.
    If the value of a particular pixel in a certain location was `56`, then `image_1`
    would be multiplied by `256 56 =200` and `image_2` would be multiplied by `56`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other effects like `Image.eval(function, Image)` where each pixel
    is multiplied by the function and we can convert the function to some complicated
    algebraic expression. If the image has multiple bands, then the function is applied
    to each band.
  prefs: []
  type: TYPE_NORMAL
- en: Another effect is the `Image.merge(mode, bandList)` which creates a multi-band
    image from multiple single-band images of equal size. We specify the desired mode
    of the new image. The **bandList specifier** is a sequence of single-band image
    components to be combined.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the image operations shown previously in combinations, there are an endless
    number of effects that can be achieved. We would be delving into the world of
    image and signal processing which can get extremely complex and sophisticated.
    Certain effects have become fairly standard and can be seen in the list of filtering
    options available in image-processing applications like `GIMP` and `Photoshop`.
  prefs: []
  type: TYPE_NORMAL
- en: Offset (roll) image horizontally and vertically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We see here how to roll an image. That is, to shift it to the right or left
    without losing anything - the image effectively rolls as if the edges were joined.
    The same process will work in the vertical direction.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the image `canary_a.jpg` from the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following program noting that we need to import a module belonging
    to PIL called `ImageChops`. The **Chops** stands for **channel operations**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The excellent guide *Python Imaging Library* by John Shipman written in mid
    2009 does not mention ImageChops.
  prefs: []
  type: TYPE_NORMAL
- en: Flip horizontally, vertically, and rotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we look at a set of quick and easy transformations that are typical of
    the operations we would need in a photo viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `image dusi_leo_1.jpg` from the folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the following program and see the results in `/constr/picsx`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding commands are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter effects: blur, sharpen, contrast, and so on'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PIL has an **ImageFilter** module that has a useful selection of filters for
    enhancing certain characteristics of images such as sharpening features that were
    blurred. Ten of these filters are demonstrated in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the images `russian_doll.png` from the folder `/constr/pics1`. Create a
    folder `/constr/picsx` for the resulting filtered images. Using a separate folder
    for the results helps prevent the folder `pics1` from becoming overcrowded with
    a heap of redundant images and work-in-progress. After each execution, we can
    delete the contents of `picsx` without the fear of losing source images for the
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the folder `/constr/picsx` on your screen before you execute the following
    code and watch as the images appear once the execution is complete. The source
    image was chosen to have a blurred Russian doll on an in-focus background because
    it allows the effects of the different filters to be readily distinguished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows that the best filtering results are highly dependent on both
    the feature of the image we wish to enhance or suppress, as well as some subtle
    characteristics of the individual image being worked on. In the particular example
    of the Russian doll used here, the `EDGE_ENHANCE` filter is particularly effective
    for counteracting the poor focus of the doll. It improves the color contrast in
    comparison to the `SHARPEN` filter. Re-size and paste for synthetic rotation
  prefs: []
  type: TYPE_NORMAL
- en: We want to create an animation that makes an image apparently rotate around
    a vertical axis in the middle of the picture. In this recipe, we see how the basic
    sequences of images for the animation are prepared.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make a sequence of images that are progressively narrower as if they
    were a poster on a board that was being gradually rotated. Then, we want to paste
    these narrow images in the middle of a standard-sized black background. If this
    sequence were displayed as a time-controlled series of frames, we would see the
    image apparently rotating around a central vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the image `100_canary.png` in a directory `/constr/pics1` and we place
    the results in `/constr/picsx` to avoid cluttering our source folder `/constr/pics1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again open the folder `/constr/picsx` on your screen before you execute the
    following code and watch as the images appear once the execution is complete.
    This is not necessary but it is interesting to watch the results materialize before
    your eyes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To mimic the effect of rotation, we reduce the width of each image to `cosine(new_angle)`
    where `new_angle` is increased by 5 degrees of rotation for each image. Then we
    take this narrowed image and paste it onto a blank black square. Finally we name
    each picture in the sequence in a systematic way such as `canary0.gif, canary1.gif`,
    and so on until the last image is named `canary36.gif`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example demonstrates the kind of task the Python Imaging Library is well-suited
    to - when you need to repeatedly perform a controlled transformation on an image
    or collection of images. The images could be the frames of a video film. Effects
    like fade-in and fade-out, zoom-out, color-shift, sharpen, and blur are the obvious
    ones that can be used but your programmer's imagination will be able to come up
    with many others.
  prefs: []
  type: TYPE_NORMAL
