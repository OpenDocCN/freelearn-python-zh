<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Test-Driven Development</h1></div></div></div><p>My first encounter with <strong>Test-Driven Development</strong> (<strong>TDD</strong>) was back in 2002. At that time, it wasn't as mainstream as it is today, and I remember watching two developers writing some tests first and then implementing the functionality later. I thought it to be quite a strange way to write a code, and I promptly forgot about it. It was not until 2004, when I was involved with a challenging project, that I remembered TDD again. We were faced with a messy code that was difficult to test and every change seemed to create a series of new bugs. I thought, why not give TDD a shot and see how it worked? Suffice to say, TDD changed my outlook on software development. We stopped writing messy spaghetti code, and started writing better designed, more maintainable code. Regression failures dropped drastically. I was hooked.</p><p>Perhaps, like me, you face some challenges in a project and want to see how TDD can help you. Or, maybe you've heard a lot of people in the industry sing the praises of TDD and you're wondering what all the fuss is about. Maybe you've been reading about how TDD will be an essential skill in the near future, and want to get up to speed on it. No matter what your motivation, I hope this book will help you reach your goal.</p><p>TDD is a<a id="id0" class="indexterm"/> lot more than just a library or an API; it is a different way of developing software. In this book, we'll discuss how to apply this process to writing Python software. We're in luck, because Python has fantastic support for TDD right out of the box. In fact, unit testing has been an integral part of the Python standard library from the Python 2.1 release back in April 2001. Numerous improvements have been added since then, and the latest version that ships with Python 3.4 has a ton of exciting features that we'll explore over the course of this book.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Prerequisites</h1></div></div></div><p>We will be<a id="id1" class="indexterm"/> using Python 3.4 in this book. Most of the techniques will work on Python 2.6+ as well, but some small changes may be required to the examples presented in this book in order to make them run. The <a class="link" href="apb.html" title="Appendix B. Working with Older Python Versions">Appendix B</a>, <em>Working with Older Python Versions</em> lists these changes.</p><p>This book assumes that the reader has an intermediate level of Python understanding. In this book, we will be using Python language features such as lambdas, decorators, generators, and properties, and we assume that the reader is familiar with them. While we will give a brief description of these features as we encounter them, this book will not go into a lot of details about how they work, choosing instead to focus on how to test such code.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Note that if you have only Python 2.x installed on your system, then go to <a class="ulink" href="http://python.org">http://python.org</a> and download the latest release in the Python 3.4 series. For Linux users, if Python 3.4 is not installed on your system, then check your distribution's package repository to get the latest version. If no package exists, or you are using a non-standard or older version of a distribution, then you might have to compile it from source. The instructions to do so are available at <a class="ulink" href="https://docs.python.org/devguide/setup.html">https://docs.python.org/devguide/setup.html</a>.</p></div></div><p>Since TDD is a hands-on coding activity, this book will use a lot of code snippets throughout. We recommend that you follow along by typing the code and running it yourself. It is much easier to understand the code and concepts when you can see it working (or not working) in front of you, rather than just reading through the code in this book.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Getting the code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>All the code in this book can be found online at <a class="ulink" href="https://github.com/siddhi/test_driven_python">https://github.com/siddhi/test_driven_python</a>. You can select a specific branch of the repository to get the code for the start of this chapter, and work through this chapter from that starting point. You can also select a tag on the branch to get the code for the endpoint of this chapter, if you would prefer to jump to the end of the code.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Understanding test-driven development</h1></div></div></div><p>After all<a id="id2" class="indexterm"/> the hype in the previous paragraphs, you might be wondering what exactly test-driven development is all about, and whether it is some complex procedure that requires a lot of skill to implement. Actually, test-driven development is very simple. The flowchart below shows the three steps in the process.</p><div><img src="img/7924OS_01_01.jpg" alt="Understanding test-driven development"/></div><p>Let's walk through the preceding flowchart<a id="id3" class="indexterm"/> in a little more detail.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Red</strong>: The<a id="id4" class="indexterm"/> first step is to write a small unit test case. As we have only written the test and haven't written the implementation yet, this test will naturally fail.</li><li class="listitem" style="list-style-type: disc"><strong>Green</strong>: Next, we<a id="id5" class="indexterm"/> write the code that implements the desired functionality. At this point, we aren't looking to create the best design or the most readable code. We just want something simple that will pass the test.</li><li class="listitem" style="list-style-type: disc"><strong>Refactor</strong>: Now<a id="id6" class="indexterm"/> that the test is passing, we go back and look at the code to see whether it can be improved. This may involve improving the design, or making it more readable or maintainable. We can use the tests written so far to ensure that we aren't breaking anything during the refactoring step.</li><li class="listitem" style="list-style-type: disc">The cycle repeats as we proceed to the next test and implement the next bit of functionality.</li></ul></div><p>Developers who are familiar with TDD usually go through this cycle many times an hour, implementing small steps of functionality each time.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>TDD versus unit testing versus integration testing</h2></div></div></div><p>Before we go<a id="id7" class="indexterm"/> further, let's take a short detour to define some terms and understand the differences between them. It is very easy to get confused between these terms, and they are often used with different meanings in different places.</p><p>In the broadest sense of the term, <strong>unit testing</strong> <a id="id8" class="indexterm"/>simply means testing a single unit of code, isolated from other code that it might be integrated with. Traditionally, unit testing was an activity that was primarily performed by test engineers. These engineers would take code given by the developers and run them through a suite of tests to verify that the code worked. Since this code was tested before integration, the process fits into the definition of a unit test. Traditional unit testing was typically a manual affair, with test engineers walking through the tests cases by hand, although some teams would go a step further and automate the tests.</p><p>An <strong>integration test</strong> is<a id="id9" class="indexterm"/> a test <a id="id10" class="indexterm"/>that involves exercising more than one unit of the system. The goal is to check whether these units have been integrated correctly. A typical integration test might be to go to a web page, fill in a form, and check whether the right message is displayed on the screen. In order for this test to pass, the UI must show the form correctly, the input must be captured correctly, and that input must be passed on to any logic processing. The steps might involve reading and writing from a database before a message is generated and the UI has to display it correctly. Only if all these interactions succeed will the integration test pass. If any one step should fail, the integration test will fail.</p><p>At this point, a valid question would be to ask why we need unit testing at all. Why not write only integration tests, where a single test could check so many parts of the application at once? The reason is that integration tests do not pinpoint the location of failure. A failing integration test could have an error in the UI, or in the logic, or somewhere in the way data is read or written. It will take a lot of investigation to see where the error is and fix it. By contrast, with well-written unit tests, a failing unit test will pinpoint exactly what is failing. Developers can go right to the point and fix the error.</p><p>Along the way, teams started moving to a process where developers themselves wrote tests for the code that they had implemented. These tests would be written after the developer had finished the implementation, and helped verify that the code worked as expected. These tests were usually automated. Such a process is generally called <strong>developer testing</strong><a id="id11" class="indexterm"/> or <a id="id12" class="indexterm"/>
<strong>developer unit testing</strong>.</p><p>TDD takes developer tests one step further, by writing the test before starting the implementation.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer tests</strong>: Any<a id="id13" class="indexterm"/> kind of automated unit tests written by the developer, either before or after functionality is implemented.</li><li class="listitem" style="list-style-type: disc"><strong>Unit testing</strong>: Any<a id="id14" class="indexterm"/> kind of testing of a particular unit of an application, either by a developer or a tester. These tests might be automated, or run manually.</li><li class="listitem" style="list-style-type: disc"><strong>Integration testing</strong>: Any <a id="id15" class="indexterm"/>kind of testing that involves two or more units working together. These tests are typically performed by a tester, but they could be done by a developer as well. These tests might be manual or automated.</li></ul></div><p>As we can see, unit testing is a general term, whereas developer testing is a specific subset of unit testing, and TDD is a specific form of developer testing.</p><p>On the surface, traditional unit testing, developer testing and TDD look similar. They all appear to be about writing tests for a single unit of code, with only minor variations based on who writes the test and whether the tests are written before the code or after.</p><p>However, dig deeper and differences appear. First, the intent is vastly different. Traditional unit testing and developer testing are all about writing tests to verify that the code works as it is supposed to. On the other hand, the main focus of TDD is not really about testing. The simple act of writing a test before the implementation changes the way we think when we implement the corresponding functionality. The resulting code is more testable, usually has a simple and elegant design, and is more maintainable and readable. This is because making a class easy to test also encourages good design practices, such as decoupling dependencies and writing small, modular classes.</p><p>Thus, one can say that TDD is all about writing better code, and it is just a happy side effect that we end up with a fully automated test suite as an outcome.</p><p>This difference in intent manifests itself in the type of tests. Developer testing usually results in large test cases, with a hefty part of the test code involved in test setup. By contrast, tests written using TDD are very small and numerous. Some people like to call them micro tests to differentiate them from other developer tests or traditional unit tests. TDD-style unit tests also try to be very fast to run because they are executed every few minutes during the development process.</p><p>Finally, the tests that are written in TDD are those that drive the development forward, and not necessarily those that cover all imaginable scenarios. For example, a function that is supposed to process a file might have tests to handle cases when the file exists or it doesn't exist, but probably won't have tests to see what happens if the file is 1 terabyte in size. The latter is something that a tester might conceivably test for, but would be an unusual test in TDD unless the function is clearly expected to work with such a file.</p><p>This really highlights the difference between TDD and other forms of unit testing.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>TDD is about writing better, cleaner, more maintainable code, and only incidentally about testing.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using TDD to build a stock alert application</h1></div></div></div><p>Over the <a id="id16" class="indexterm"/>course of this book, we are going to be using TDD to build a simple stock alert application. The application will listen to stock updates from a source. The source can be anything—a server on the Internet, or a file on the hard drive, or something else. We will be able to define rules, and when the rule is matched, the application sends us an email or text message.</p><p>For example, we <a id="id17" class="indexterm"/>could define a rule as "If AAPL crosses the $550 level then send me an email". Once defined, the application will monitor updates and send an e-mail when the rule is matched.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Writing our first test</h2></div></div></div><p>Enough talk. Let's<a id="id18" class="indexterm"/> get started with our application. What is a good place to start? From examining the application description mentioned earlier, it looks like we will need the following modules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some way to read stock price updates, either from the Internet or from a file</li><li class="listitem" style="list-style-type: disc">A way to manage the stock information so that we can process it</li><li class="listitem" style="list-style-type: disc">A way to define rules and match them against the current stock information</li><li class="listitem" style="list-style-type: disc">A way to send an email or text message when a rule is matched</li></ul></div><p>Based on these requirements, we will be using the following design:</p><div><img src="img/7924OS_01_02.jpg" alt="Writing our first test"/></div><p>Each term is<a id="id19" class="indexterm"/> discussed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Alert</strong>: This is the core of the application. An alert will take a <strong>Rule</strong> and map it to an <strong>Action</strong>. When the rule is matched, the action is executed.</li><li class="listitem" style="list-style-type: disc"><strong>Rule</strong>: A <strong>Rule</strong> contains the condition we want to check for. We should get alerted when the rule is matched.</li><li class="listitem" style="list-style-type: disc"><strong>Action</strong>: This is the action to be performed when the rule is matched. This could be as simple as printing a message on the screen, or, in more real-work scenarios, we might send an e-mail or a text message.</li><li class="listitem" style="list-style-type: disc"><strong>Stock</strong>: The <strong>Stock</strong> class keeps track of the current price and possibly a history of the prices for a stock. It sends an <strong>Event</strong> to the <strong>Alert</strong> when there is an update. The alert then checks if it's rule matched and whether any action needs to be executed.</li><li class="listitem" style="list-style-type: disc"><strong>Event</strong>: This class is used to send events to the <strong>Alert</strong> when a <strong>Stock</strong> is updated.</li><li class="listitem" style="list-style-type: disc"><strong>Processor</strong>: The processor takes stock updates from the <strong>Reader</strong> and updates the <strong>Stock</strong> with the latest data. Updating the stock causes the event to be fired, which, in turn, causes the alert to check for a rule match.</li><li class="listitem" style="list-style-type: disc"><strong>Reader</strong>: The <strong>Reader</strong> gets the stock alerts from some source. In this book, we are going to get updates from a simple list or a file, but you can build other readers to get updates from the Internet or elsewhere.</li></ul></div><p>Among all<a id="id20" class="indexterm"/> these classes, the way to manage stock information seems to be the simplest, so let's start there. What we are going to do is to create a <code class="literal">Stock</code> class. This class will hold information about the current stock. It will store the current price and possibly some recent price history. We can then use this class when we want to match rules later on.</p><p>To get started, create a directory called <code class="literal">src</code>. This directory is going to hold all our source code. In the rest of this book, we will refer to this directory as the project root. Inside the <code class="literal">src</code> directory, create a subdirectory called <code class="literal">stock_alerter</code>. This is the directory in which we are going to implement our stock alert module.</p><p>Okay, let's get started with implementing the class.</p><p>NO! Wait! Remember the TDD process that was described earlier? The first step is to write a test, before we code the implementation. By writing the test first, we now have the opportunity to think about what we want this class to do.</p><p>So what exactly do we want this class to do? Let's start with something simple:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">Stock</code> class should be instantiated with the ticker symbol</li><li class="listitem" style="list-style-type: disc">Once instantiated, and before any updates, the price should be <code class="literal">None</code></li></ul></div><p>Of course, there are many more things we will want this class to do, but we'll think about them later. Rather than coming up with a very comprehensive list of functionality, we're going to focus on tiny bits of functionality, one at a time. For now, the preceding expectation is good enough.</p><p>To convert the preceding expectation into code, create a file called <code class="literal">stock.py</code> in the project root, and put the following code in it:</p><div><pre class="programlisting">import unittest
class StockTest(unittest.TestCase):
    def test_price_of_a_new_stock_class_should_be_None(self):
        stock = Stock("GOOG")
        self.assertIsNone(stock.price)
if __name__ == "__main__":
    unittest.main()</pre></div><p>What does this code do?</p><div><ol class="orderedlist arabic"><li class="listitem">First, we import <code class="literal">unittest</code>. This is the library that has the test framework that we are going to use. Luckily for us, it is bundled into the Python standard library by default and is always available, so we don't need to install anything, we can just import the module directly.</li><li class="listitem">Second, we<a id="id21" class="indexterm"/> create a class <code class="literal">StockTest</code>. This class will hold all the test cases for the <code class="literal">Stock</code> class. This is just a convenient way of grouping related tests together. There is no rule that every class should have a corresponding test class. Sometimes, if we have a lot of tests for a class, then we may want to create separate test classes for each individual behavior, or group the tests some other way. However, in most cases, creating one test class for an actual class is the best way to go about it.</li><li class="listitem">Our <code class="literal">StockTest</code> class inherits from the <code class="literal">TestCase</code> class in the <code class="literal">unittest</code> module. All tests need to inherit from this class in order to be identified as a test class.</li><li class="listitem">Inside the class, we have one method. This method is a test case. The <code class="literal">unittest</code> framework will pick up any method that starts with <code class="literal">test</code>. The method has a name that describes what the test is checking for. This is just so that when we come back after a few months, we still remember what the test does.</li><li class="listitem">The test creates a <code class="literal">Stock</code> object and then checks if the price is <code class="literal">None</code>. <code class="literal">assertIsNone</code> is a method provided by the <code class="literal">TestCase</code> class that we are inheriting from. It checks that its parameter is <code class="literal">None</code>. If the parameter is not <code class="literal">None</code>, it raises an <code class="literal">AssertionError</code> and fails the test. Otherwise, execution continues to the next line. Since that is the last line of the method, the test completes and is marked as a pass.</li><li class="listitem">The last segment checks if the module was executed directly from the command line. In such a case, the <code class="literal">__name__</code> variable will have the value <code class="literal">__main__</code>, and the code will execute the <code class="literal">unittest.main()</code> function. This function will scan the current file for all tests and execute them. The reason we need to wrap this function call inside the conditional is because this part does not get executed if the module is imported into another file.</li></ol></div><p>Congratulations! You have your first failing test. Normally, a failing test would be a cause for worry, but in this case, a failing test means that we're done with the first step of the process and can move on to the next step.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Analyzing the test output</h2></div></div></div><p>Now that<a id="id22" class="indexterm"/> we've written our test, it is time to run it. To run the test, just execute the file. Assuming that the current directory is the <code class="literal">src</code> directory, the following is the command to execute the file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows:<div><pre class="programlisting"><strong>python.exe stock_alerter\stock.py</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">Linux/Mac:<div><pre class="programlisting"><strong>python3 stock_alerter/stock.py</strong>
</pre></div></li></ul></div><p>If the python executable is not on your path, then you will have to give the full path to the executable here. In some Linux distributions, the file may be called <code class="literal">python34</code> or <code class="literal">python3.4</code> instead of <code class="literal">python3</code>.</p><p>When we run the file, the output looks like the following:</p><div><pre class="programlisting"><strong>E</strong>
<strong>=====================================================================</strong>
<strong>ERROR: test_price_of_a_new_stock_class_should_be_None (__main__.StockTest)</strong>
<strong>---------------------------------------------------------------------</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "stock_alerter\stock.py", line 6, in test_price_of_a_new_stock_class_should_be_None</strong>
<strong>    stock = Stock("GOOG")</strong>
<strong>NameError: name 'Stock' is not defined</strong>
<strong>---------------------------------------------------------------------</strong>
<strong>Ran 1 test in 0.001s</strong>

<strong>FAILED (errors=1)</strong>
</pre></div><p>As expected, the test fails, because we haven't created the <code class="literal">Stock</code> class yet.</p><p>Let's look at that output in a little more detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">E</code> on the first line signifies that the test gave an error. If a test passed, then you would have a dot on that line. A failed test would be marked with <code class="literal">F</code>. Since we have only a single test, there is only one character there. When we have multiple tests, then the status of each test will be displayed on that line, one character per test.</li><li class="listitem" style="list-style-type: disc">After all the test statuses are displayed, we get a more detailed explanation of any test errors and failures. It tells us whether there was a failure or an error (in this case denoted by <code class="literal">ERROR</code>) followed by the name of the test and which class it belongs to. This is followed by a traceback, so we know where the failure occurred.</li><li class="listitem" style="list-style-type: disc">Finally, there is a summary that shows how many tests were executed, how many passed or failed, and how many gave errors.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Test errors versus test failures</h2></div></div></div><p>There are<a id="id23" class="indexterm"/> two reasons why a test might not pass: It might have failed or it might have caused an error. There is a small difference between these two. A <strong>failure</strong> indicates that we expected some outcome (usually via an assert), but got something else. For example, in our test, we are asserting that <code class="literal">stock.price</code> is <code class="literal">None</code>. Suppose <code class="literal">stock.price</code> has some other value apart from <code class="literal">None</code>, then the test will fail.</p><p>An error indicates that something unexpected happened, usually an unexpected exception was raised. In our previous example, we got an error because the <code class="literal">Stock</code> class has not yet been defined.</p><p>In both the cases, the test does not pass, but for different reasons, and these are reported separately as test failures and test errors.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Making the test pass</h2></div></div></div><p>Now that <a id="id24" class="indexterm"/>we have a failing test, let's make it pass. Add the following code to the <code class="literal">stock.py</code> file, after the <code class="literal">import unittest</code> line:</p><div><pre class="programlisting">class Stock:
    def __init__(self, symbol):
        self.symbol = symbol
        self.price = None</pre></div><p>What we have done here is to implement just enough code to pass the test. We've created the <code class="literal">Stock</code> class so the test shouldn't complain about it being missing, and we've initialized the <code class="literal">price</code> attribute to <code class="literal">None</code>.</p><p>What about the rest of the implementation for this class? This can wait. Our main focus right now is to pass the current expectation for this class. As we write more tests, we will end up implementing more of the class as well.</p><p>Run the file again, and this time the output should be like the following:</p><div><pre class="programlisting"><strong>.</strong>
<strong>---------------------------------------------------------------------</strong>
<strong>Ran 1 test in 0.000s</strong>

<strong>OK</strong>
</pre></div><p>We've got a dot in the first line, which signifies that the test is passing. The <code class="literal">OK</code> message at the end tells us that all tests have passed.</p><p>The<a id="id25" class="indexterm"/> final step is to refactor the code. With so little code, there is really nothing much to clean up. So, we can skip the refactoring step and start with the next test.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Reorganizing the test code</h1></div></div></div><p>We've <a id="id26" class="indexterm"/>added the test cases in the same file as the code. This is a good, simple way to add test cases to standalone scripts and applications that are not too complex. However, for larger applications, it is a good idea to keep test code separate from production code.</p><p>There are two common patterns for organizing test code this way.</p><p>The first pattern is to keep test code in a separate root directory, as shown in the following:</p><div><pre class="programlisting">root
|
+- package
|  |
|  +- file1
|  +- file2
|
+- test
   |
   +- test_file1
   +- test_file2</pre></div><p>The other pattern is to keep test code as a submodule of the main code, as shown in the following:</p><div><pre class="programlisting">root
|
+- package
   |
   +- file1
   +- file2
   +- test
      |
      +- test_file1
      +- test_file2</pre></div><p>The first pattern is commonly used for standalone modules as it allows us to distribute the code and tests together. Tests can generally be run without having to perform a lot of setup or configuration. The second pattern has an advantage when the application has to be packaged without the test code, for example when deploying to production servers, or distributing to customers (in the case of a commercial application). However, both the patterns are in popular use, and it is mainly a personal preference as to which method to use.</p><p>We are going<a id="id27" class="indexterm"/> to follow the first pattern in this book. To get started, create a directory called <code class="literal">tests</code> inside the <code class="literal">stock_alerter</code> directory. Next, create a file called <code class="literal">test_stock.py</code> in this directory. We will put all our test cases in one-to-one correspondence with the source file. This means, a file called <code class="literal">sample.py</code> will have its test cases in the <code class="literal">tests/test_sample.py</code> file. This is a simple naming convention that helps to quickly locate test cases.</p><p>Finally, we move our test cases into this file. We also need to import the <code class="literal">Stock</code> class to be able to use it in the test case. Our <code class="literal">test_stock.py</code> file now looks like the following:</p><div><pre class="programlisting">import unittest
from ..stock import Stock

class StockTest(unittest.TestCase):
    def test_price_of_a_new_stock_class_should_be_None(self):
        stock = Stock("GOOG")
        self.assertIsNone(stock.price)</pre></div><p>Remember to remove the <code class="literal">import unittest</code> line from <code class="literal">stock.py</code>, now that it no longer contains the test code. Previously we had just one standalone script, but we now have a <code class="literal">stock_alerter</code> module and a <code class="literal">stock_alerter.tests</code> submodule. Since we are now working with modules, we should also add in an empty <code class="literal">__init__.py</code> file in both the <code class="literal">stock_alerter</code> and <code class="literal">tests</code> directories.</p><p>Our file layout should now be like the following:</p><div><pre class="programlisting">src
|
+- stock_alerter
   |
   +- __init__.py
   +- stock.py
   +- tests
      +- __init__.py
      +- test_stock.py</pre></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Running the tests after the reorganization</h2></div></div></div><p>If you <a id="id28" class="indexterm"/>have noticed, we no longer have a call to <code class="literal">unittest.main()</code> in the test code. Including a call to <code class="literal">unittest.main()</code> works well with individual scripts since it allows us to run the tests by simply executing the file. However, it is not a very scalable solution. If we have hundreds of files, we would like to run all the tests at once, and not have to execute each file individually.</p><p>To address this, Python 3 comes with a very nice test discovery and execution capability from the command line. Simply go into the <code class="literal">src</code> directory and run the following command:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows:<div><pre class="programlisting"><strong>python.exe -m unittest</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">Linux/Mac:<div><pre class="programlisting"><strong>python3 -m unittest</strong>
</pre></div></li></ul></div><p>This command will go through the current directory and all subdirectories and run all the tests that are found. This is the default autodiscover mode of execution, where the command searches all the files and runs the tests. Autodiscovery can also be explicitly run with the following command:</p><div><pre class="programlisting"><strong>python3 -m unittest discover</strong>
</pre></div><p>Autodiscover can be customized to check in specific directories or files with the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-s start_directory</code>: Specify <a id="id29" class="indexterm"/>the start directory from where the discovery should start. This defaults to the current directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-t top_directory</code>: Specify<a id="id30" class="indexterm"/> the top-level directory. This is the directory from which imports are performed. This is important if the start directory is inside the package and you get errors due to incorrect imports. This defaults to the start directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-p file_pattern</code>: The<a id="id31" class="indexterm"/> file pattern that identifies test files. By default it checks for python files that start with <code class="literal">test</code>. If we name our test files something else (for example, <code class="literal">stock_test.py</code>), then we have to pass in this parameter so that the file is correctly identified as a test file.</li></ul></div><p>To illustrate the difference between the start and top directory, run the following command from the <code class="literal">src</code> directory:</p><div><pre class="programlisting"><strong>python3 -m unittest discover -s stock_alerter</strong>
</pre></div><p>The preceding command will fail with an import error. The reason is because when the start directory is set to <code class="literal">stock_alerter</code>, then the <code class="literal">tests</code> directory is imported as a top-level module, and the relative import fails. To get around this, we need to use the following command:</p><div><pre class="programlisting"><strong>python3 -m unittest discover -s stock_alerter -t .</strong>
</pre></div><p>This <a id="id32" class="indexterm"/>command will import all modules relative to the top directory, and so <code class="literal">stock_alerter</code> correctly becomes the main module.</p><p>You can also disable autodiscovery and specify only certain tests to be run:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Passing in a module name will only run the tests within that module. For example, <code class="literal">python3 -m unittest stock_alerter.tests.test_stock</code> will run the tests only in <code class="literal">test_stock.py</code>.</li><li class="listitem" style="list-style-type: disc">You can further refine to a specific class or method, such as <code class="literal">python3 -m unittest stock_alerter.tests.test_stock.StockTest</code>.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>Congratulations! You've completed one cycle of TDD. As you can see, each cycle is very quick. Some cycles, like the one we've just gone through, can be completed in a few seconds. Other cycles might involve a fair amount of cleanup and can take quite a long time. Each cycle will implement a small test, a small bit of functionality to pass the test, and then some cleanup to make the code of high quality.</p><p>In this chapter, we looked at what TDD is, how it is different from other forms of unit and integration testing, and wrote our first test.</p><p>At this point, our implementation is still very small and very simple. You might be wondering if it is worth all this hype just to write and implement four lines of very simple code. In the next few chapters, we'll progress further with the examples and go more in-depth into the process.</p></div></div>
</body></html>