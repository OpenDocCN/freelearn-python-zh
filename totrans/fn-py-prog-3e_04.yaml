- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Collections
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一起工作
- en: Python offers a number of functions that process whole collections. They can
    be applied to sequences (lists or tuples), sets, mappings, and iterable results
    of generator expressions. We’ll look at Python’s collection-processing features
    from a functional programming viewpoint.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一些处理整个集合的函数。它们可以应用于序列（列表或元组）、集合、映射以及生成器表达式的可迭代结果。我们将从函数式编程的角度探讨Python的集合处理功能。
- en: We’ll start out by looking at iterables and some simple functions that work
    with iterables. We’ll look at some design patterns to handle iterables and sequences
    with recursive functions as well as explicit `for` statements. We’ll look at how
    we can apply a scalar function to a collection of data with a generator expression.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看可迭代对象和一些与可迭代对象一起工作的简单函数。我们将探讨一些设计模式来处理可迭代对象和序列，包括递归函数以及显式的`for`语句。我们还将探讨如何使用生成器表达式将标量函数应用于数据集合。
- en: 'In this chapter, we’ll show you examples of how to use the following functions
    with collections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何使用以下函数与集合一起使用：
- en: '`any()` and `all()`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any()`和`all()`'
- en: '`len()`, `sum()`, and some higher-order statistical processing related to these
    functions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len()`、`sum()`以及与这些函数相关的一些高级统计处理'
- en: '`zip()` and some related techniques to structure and flatten lists of data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`zip()`和相关技术来结构化和展平数据列表
- en: '`sorted()` and `reversed()` to impose an ordering on a collection'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sorted()`和`reversed()`对集合施加排序
- en: '`enumerate()`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`'
- en: 'The first four functions can be called reductions: they reduce a collection
    to a single value. The other three functions, `zip()`, `reversed()`, and `enumerate()`,
    are mappings; they produce new collections from existing collections. In the next
    chapter, we’ll look at some more mapping and reduction functions that use an additional
    function as an argument to customize their processing.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个函数可以被称作归约函数：它们将一个集合归约为一个单一值。其他三个函数，`zip()`、`reversed()`和`enumerate()`，是映射函数；它们从现有的集合中产生新的集合。在下一章中，我们将探讨一些使用额外函数作为参数来自定义处理的更多映射和归约函数。
- en: In this chapter, we’ll start by looking at ways to process data using generator
    expressions. Then, we’ll apply different kinds of collection-level functions to
    show how they can simplify the syntax of iterative processing. We’ll also look
    at some different ways of restructuring data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨使用生成器表达式处理数据的方法。然后，我们将应用不同类型的集合级函数来展示它们如何简化迭代处理的语法。我们还将探讨一些不同的数据重构方式。
- en: In the next chapter, we’ll focus on using higher-order collection functions
    to do similar kinds of processing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用高阶集合函数来完成类似类型的处理。
- en: 4.1 An overview of function varieties
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 函数种类概述
- en: 'We need to distinguish between two broad species of functions, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分两种广泛的功能种类，如下所示：
- en: 'Scalar functions: These apply to individual values and compute an individual
    result. Functions such as `abs()`, `pow()`, and the entire `math` module are examples
    of scalar functions.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量函数：这些应用于单个值并计算一个单独的结果。例如`abs()`、`pow()`以及整个`math`模块都是标量函数的例子。
- en: 'Collection functions: These work with iterable collections.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合函数：这些与可迭代集合一起工作。
- en: 'We can further subdivide these collection functions into three subspecies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些集合函数进一步细分为三种亚种：
- en: 'Reduction: This uses a function to fold values in the collection together,
    resulting in a single final value. For example, if we fold + operations into a
    sequence of integers, this will compute the sum. This can be also be called an
    aggregate function, as it produces a single aggregate value for an input collection.
    Functions like `sum()` and `len()` are examples of reducing a collection to a
    single value.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归约：这使用一个函数将集合中的值折叠在一起，结果是一个单一最终值。例如，如果我们把加法操作折叠到一系列整数中，这将计算总和。这也可以被称为聚合函数，因为它为输入集合产生一个单一的聚合值。像`sum()`和`len()`这样的函数是归约集合到单一值的例子。
- en: 'Mapping: This applies a scalar function to each individual item of a collection;
    the result is a collection of the same size. The built-in `map()` function does
    this; a function like `enumerate()` can be seen as a mapping from items to pairs
    of values.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射：这将对集合中的每个单独项目应用一个标量函数；结果是同样大小的集合。内置的`map()`函数就是这样做的；像`enumerate()`这样的函数可以被看作是从项目到值对的映射。
- en: 'Filter: This applies a scalar function to all items of a collection to reject
    some items and pass others. The result is a subset of the input. The built-in
    `filter()` function does this.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器：这将对集合中的所有项目应用标量函数以拒绝某些项目并传递其他项目。结果是输入的子集。内置的`filter()`函数就是这样做的。
- en: Some functions, for example, `sorted()` and `reversed()`, don’t fit this framework
    in a simple, tidy way. Because these two ”reordering” functions don’t compute
    new values from existing values, it seems sensible to set them off to one side.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数，例如`sorted()`和`reversed()`，并不能简单地、整洁地适应这个框架。因为这两个“重新排序”函数并不是从现有值计算出新值，所以将它们放在一边似乎是有道理的。
- en: We’ll use this conceptual framework to characterize ways in which we use the
    built-in collection functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个概念框架来描述我们使用内置集合函数的方式。
- en: 4.2 Working with iterables
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 与可迭代对象一起工作
- en: As noted in the previous chapters, Python’s `for` statement works with iterables,
    including Python’s rich variety of collections. When working with materialized
    collections such as tuples, lists, maps, and sets, the `for` statement involves
    the explicit management of state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Python的`for`语句与可迭代对象一起工作，包括Python丰富的集合类型。当处理如元组、列表、映射和集合等具体化的集合时，`for`语句涉及显式地管理状态。
- en: While this strays from purely functional programming, it reflects a necessary
    optimization for Python. The state management is localized to an iterator object
    that’s created as a part of the `for` statement evaluation; we can leverage this
    feature without straying too far from pure, functional programming. If, for example,
    we use the `for` statement’s variable outside the indented body of the statement,
    we’ve strayed from purely functional programming by leveraging this state control
    variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这偏离了纯函数式编程，但它反映了Python必要的优化。状态管理被局部化到一个迭代器对象，该对象是作为`for`语句评估的一部分创建的；我们可以利用这个特性，而不会偏离纯函数式编程太远。例如，如果我们使用`for`语句的变量在语句缩进体之外，我们就通过利用这个状态控制变量偏离了纯函数式编程。
- en: We’ll return to this in [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006). It’s an important topic, and we’ll
    just scratch the surface in this section with a quick example of working with
    generators.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)中回到这个话题。这是一个重要的话题，我们将在本节中通过一个处理生成器的快速示例来略过表面。
- en: One common application of iterable processing with the `for` statement is the
    `unwrap(process(wrap(iterable)))` design pattern. A `wrap()` function will first
    transform each item of an iterable into a two-tuple with a derived sort key and
    the original item. We can then process these two-tuple items as a single, wrapped
    value. Finally, we’ll use an `unwrap()` function to discard the value used to
    wrap, which recovers the original item.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`语句进行可迭代处理的一个常见应用是`unwrap(process(wrap(iterable)))`设计模式。一个`wrap()`函数首先将可迭代中的每个项目转换为一个包含派生排序键和原始项目的二元组。然后我们可以将这些二元组项目作为一个单一、包装的值进行处理。最后，我们将使用一个`unwrap()`函数来丢弃用于包装的值，从而恢复原始项目。
- en: 'This happens so often in a functional context that two functions are used heavily
    for this; they are the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程的上下文中，这种情况经常发生，以至于有两个函数被大量用于此；它们如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two functions pick the first and second values from a two-tuple, and both
    are handy for the `process()` and `unwrap()` phases of the processing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数从二元组中选取第一个和第二个值，并且它们在`process()`和`unwrap()`处理阶段都很有用。
- en: Another common pattern is `wrap3(wrap2(wrap1()))`. In this case, we’re starting
    with simple tuples and then wrapping them with additional results to build up
    larger and more complex tuples. We looked at an example in [Chapter 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002), in the
    [Immutable data](Chapter_02.xhtml#x1-380002) section. A common variation on this
    theme builds new, more complex named tuple instances from source objects. We might
    call this the Accretion design pattern—an item that accretes derived values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的模式是`wrap3(wrap2(wrap1()))`。在这种情况下，我们从一个简单的元组开始，然后通过添加额外的结果来包装它们，从而构建更大、更复杂的元组。我们在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数式概念](Chapter_02.xhtml#x1-340002)，[不可变数据](Chapter_02.xhtml#x1-380002)部分中看到了一个例子。这个主题的一个常见变体是从源对象构建新的、更复杂的命名元组实例。我们可能称之为累积设计模式——一个累积派生值的项。
- en: As an example, consider using the Accretion pattern to work with a simple sequence
    of latitude and longitude values. The first step will convert the simple point
    represented as a `(lat,`` lon)` pair on a path into pairs of legs `(begin,`` end)`.
    Each pair in the result will be represented as `((lat,`` lon),`` (lat,`` lon))`.
    The value of `fst(item)` is the starting position; the value of `snd(item)` is
    the ending position for each value of each item in the collection. We’ll expose
    this design through a series of examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑使用累积模式来处理一系列纬度和经度值。第一步将路径上表示为`(lat, lon)`对的简单点转换为`(begin, end)`对的序列。结果中的每一对将表示为`((lat,
    lon), (lat, lon))`。`fst(item)`的值是起始位置；`snd(item)`的值是每个集合中每个项目的结束位置。我们将通过一系列示例来展示这种设计。
- en: 'In the next sections, we’ll show you how to create a generator function that
    will iterate over the content of a source file. This iterable will contain the
    raw input data that we will process. Once we have the raw data, later sections
    will show how to decorate each leg with the haversine distance along the leg.
    The final result of a `wrap(wrap(iterable()))` design will be a sequence of three
    tuples: `((lat,`` lon),`` (lat,`` lon),`` distance)`. We can then analyze the
    results for the longest and shortest distance, bounding rectangle, and other summaries.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将向您展示如何创建一个生成器函数，该函数将遍历源文件的内容。这个可迭代对象将包含我们将要处理的原始输入数据。一旦我们有了原始数据，后面的章节将展示如何在每个腿上装饰水平圆周距离。`wrap(wrap(iterable()))`设计的最终结果将是一个包含三个元组的序列：`((lat,
    lon), (lat, lon), distance)`。然后我们可以分析结果，以找到最长和最短距离、边界矩形和其他摘要。
- en: 'The haversine formula is long-ish, but computes the distance along the surface
    of a sphere between two points:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 水平圆周公式相对较长，但可以计算两个点在球面上之间的距离：
- en: '![ ∘ --------------------------------------------- (ϕ − ϕ ) ( λ − λ ) a = sin2
    --1---2 + cos(ϕ1)cos(ϕ2)sin2 -1----2 2 2 ](img/file34.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ --------------------------------------------- (ϕ − ϕ ) ( λ − λ ) a = sin2
    --1---2 + cos(ϕ1)cos(ϕ2)sin2 -1----2 2 2 ](img/file34.jpg)'
- en: '![d = R × 2 arcsin(a) ](img/file35.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![d = R × 2 arcsin(a) ](img/file35.jpg)'
- en: The first part, a, is the angle between the two points. The distance, d, is
    computed from the angle, using the radius of the sphere, R, in the desired units.
    For a distance in nautical miles, we can use R = ![360×60- 2×π](img/file36.jpg)
    ≈ 3437.7\. For a distance in kilometers, we can use R = 6371\.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，a，是两点之间的角度。距离d是通过角度计算的，使用球体的半径R，以所需的单位。对于海里距离，我们可以使用R = ![360×60- 2×π](img/file36.jpg)
    ≈ 3437.7。对于千米距离，我们可以使用R = 6371。
- en: 4.2.1 Parsing an XML file
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1 解析XML文件
- en: We’ll start by parsing an Extensible Markup Language (XML) file to get the raw
    latitude and longitude pairs. This will show you how we can encapsulate some not-quite-functional
    features of Python to create an iterable sequence of values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过解析可扩展标记语言（XML）文件来获取原始的纬度和经度对。这将展示我们如何封装Python的一些不太实用的功能来创建一个可迭代的值序列。
- en: We’ll make use of the `xml.etree` module. After parsing, the resulting `ElementTree`
    object has an `iterfind()` method that will iterate through the available values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`xml.etree`模块。在解析后，生成的`ElementTree`对象有一个`iterfind()`方法，它将遍历可用的值。
- en: 'We’ll be looking for constructs such as the following XML example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻找如下XML示例的结构：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The file will have a number of `<Placemark>` tags, each of which has a point
    and coordinate structure within it. The coordinate tag’s values are East-West
    longitude, North-South latitude, and altitude above mean sea level. This means
    there are two tiers of parsing: the XML tier, and then the details of each coordinate.
    This is typical of Keyhole Markup Language (KML) files that contain geographic
    information. (For more information, see [https://developers.google.com/kml/documentation](https://developers.google.com/kml/documentation).)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将包含多个`<Placemark>`标签，每个标签内部都有一个点和坐标结构。坐标标签的值是东西经度、南北纬度和平均海平面以上的高度。这意味着有两个解析级别：XML级别和每个坐标的详细信息。这是典型的包含地理信息的Keyhole
    Markup Language (KML)文件。（更多信息请参阅[https://developers.google.com/kml/documentation](https://developers.google.com/kml/documentation)。）
- en: 'Extracting data from an XML file can be approached at two levels of abstraction:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从XML文件中提取数据可以在两个抽象级别上进行：
- en: At the lower level, we need to locate the various tags, attribute values, and
    content within the XML file.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在较低级别，我们需要在XML文件中定位各种标签、属性值和内容。
- en: At a higher level, we want to make useful objects out of the text and attribute
    values.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在较高级别，我们希望从文本和属性值中创建有用的对象。
- en: 'The lower-level processing can be approached in the following way:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以下方式处理更底层的处理：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function requires text; generally this will come from a file opened via
    a `with` statement. The result of this function is a generator that creates list
    objects from the latitude/longitude pairs. As a part of the XML processing, this
    function uses a simple static `dict` object, `ns_map`, that provides the namespace
    mapping information for the XML tags being parsed. This dictionary will be used
    by the `ElementTree.iterfind()` method to locate only the `<coordinates>` tags
    in the XML source document.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要文本；通常这将从通过`with`语句打开的文件中获取。这个函数的结果是一个生成器，它从纬度/经度对创建列表对象。作为XML处理的一部分，这个函数使用一个简单的静态`dict`对象`ns_map`，它提供了正在解析的XML标签的命名空间映射信息。这个字典将由`ElementTree.iterfind()`方法使用，以在XML源文档中仅定位`<coordinates>`标签。
- en: The essence of the parsing is a generator function that uses the sequence of
    tags located by `doc.iterfind()`. This sequence of tags is then processed by a
    `comma_split()` function to tease the text value into its comma-separated components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的本质是一个生成器函数，它使用`doc.iterfind()`找到的标签序列。然后，这个标签序列通过`comma_split()`函数被处理，将文本值分解成逗号分隔的各个部分。
- en: The `path_to_points` object is a string that defines how to navigate through
    the XML structure. It describes the location of the `<coordinates>` tag within
    the other tags of the document. Using this path means the generator expression
    will avoid the values of other, irrelevant tags.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`path_to_points`对象是一个字符串，它定义了如何通过XML结构进行导航。它描述了文档中`<coordinates>`标签相对于其他标签的位置。使用这个路径意味着生成器表达式将避免其他无关标签的值。'
- en: The `if`` text`` is`` not`` None` clause reflects the definition of the `text`
    attribute of an element tree tag. If there’s no body in the tag, the text value
    will be `None`. While it is extremely unlikely to see an empty `<coordinates/>`
    tag, the type hints require we handle this case.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`if text is not None`子句反映了元素树标签的`text`属性的定义。如果没有标签体，文本值将是`None`。虽然看到空的`<coordinates/>`标签的可能性极低，但类型提示要求我们处理这种情况。'
- en: 'The `comma_split()` function has a more functional syntax than the the `split()`
    method of a string. This function is defined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`comma_split()`函数比字符串的`split()`方法有更函数式的语法。这个函数定义如下：'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve used a wrapper to emphasize a slightly more uniform syntax. We’ve also
    added explicit type hints to make it clear that a string is converted to a list
    of `str` values. Without the type hint, there are two potential definitions of
    `split()` that could be meant. It turns out, this method applies to `bytes` as
    well as `str`. We’ve used the `str` type name to narrow the domain of types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个包装器来强调稍微更统一的语法。我们还添加了显式的类型提示，以明确指出字符串被转换为`str`值的列表。没有类型提示，`split()`方法可能有两种潜在的用法。实际上，这种方法适用于`bytes`和`str`。我们使用了`str`类型名来缩小类型域。
- en: 'The result of the `row_iter_kml()` function is an iterable sequence of rows
    of data. Each row will be a list composed of three strings: latitude, longitude,
    and altitude of a waypoint along this path. This isn’t directly useful yet. We’ll
    need to do some more processing to get latitude and longitude as well as converting
    these two strings into useful floating-point values.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_iter_kml()`函数的结果是一个可迭代的行数据序列。每一行将是一个包含三个字符串的列表：路径上某个航点的纬度、经度和高度。这目前还没有直接用处。我们还需要进行一些额外的处理，以获取纬度和经度，并将这两个字符串转换为有用的浮点值。'
- en: This idea of an iterable sequence of tuples (or lists) allows us to process
    some kinds of data files in a simple and uniform way. In [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003), we looked
    at how Comma-Separated Values (CSV) files are easily handled as rows of tuples.
    In [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions and Reductions](Chapter_06.xhtml#x1-1260006),
    we’ll revisit the parsing idea to compare these various examples.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代的元组（或列表）序列的想法允许我们以简单统一的方式处理某些类型的数据文件。在[第3章](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)中，我们探讨了如何轻松地将逗号分隔值（CSV）文件作为元组的行处理。在[第6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)中，我们将重新审视解析思想，以比较这些不同的示例。
- en: 'The output from the `row_iter_kml()` function can be collected by the `list()`
    function. The following interactive example will read the file and extract the
    details. The `list()` function will create a single list from each `<coordinate>`
    tag. The accumulated result object looks like the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_iter_kml()`函数的输出可以通过`list()`函数收集。以下交互式示例将读取文件并提取详细信息。`list()`函数将创建一个列表，每个`<coordinate>`标签对应一个列表。累积的结果对象如下所示：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are all string values. To be more useful, it’s important to apply some
    additional functions to the output of this function that will create a usable
    subset of the data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是字符串值。为了更有用，对函数的输出应用一些额外的函数来创建数据的一个可用子集非常重要。
- en: 4.2.2 Parsing a file at a higher level
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2 在更高层次解析文件
- en: After parsing the low-level syntax to transform XML to Python, we can restructure
    the raw data into something usable in our Python program. This kind of structuring
    applies to XML, JavaScript Object Notation (JSON), CSV, YAML, TOML, and any of
    the wide variety of physical formats in which data is serialized.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在将低级语法解析为将XML转换为Python之后，我们可以将原始数据重新结构化为我们Python程序中可用的形式。这种结构化适用于XML、JavaScript对象表示法（JSON）、CSV、YAML、TOML以及数据序列化的各种物理格式。
- en: 'We’ll aim to write a small suite of generator functions that transforms the
    parsed data into a form our application can use. The generator functions include
    some simple transformations on the text that are found by the `row_iter_kml()`
    function, which are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一组小的生成器函数，将解析后的数据转换成我们应用程序可以使用的形式。生成器函数包括对由`row_iter_kml()`函数找到的文本进行的一些简单转换，具体如下：
- en: Discarding altitude, which can also be stated as keeping only latitude and longitude
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃海拔，也可以说成只保留纬度和经度
- en: Changing the order from `(longitude,`` latitude)` to `(latitude,`` longitude)`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顺序从`(longitude, latitude)`改为`(latitude, longitude)`
- en: 'We can make these two transformations have more syntactic uniformity by defining
    a utility function, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个实用函数来使这两个转换具有更多的语法一致性，如下所示：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve created a function to take three argument values and create a tuple from
    two of them. The type hints are more complex than the function itself. The conversion
    of source data to usable data often involves selecting a subset of fields, as
    well as conversion from strings to numbers. We’ve separated the two problems because
    these aspects often evolve separately.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数，接受三个参数值并从其中两个创建一个元组。类型提示比函数本身更复杂。将源数据转换为可用数据通常涉及选择字段子集以及从字符串到数字的转换。我们分离了这两个问题，因为这些方面通常独立发展。
- en: 'We can use this function as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数如下：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function will apply the `pick_lat_lon()` function to each row from a source
    iterator. We’ve used `*row` to assign each element of the row’s three-tuple to
    separate parameters of the `pick_lat_lon()` function. The function can then extract
    and reorder the two relevant values from each three-tuple.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将`pick_lat_lon()`函数应用于源迭代器中的每一行。我们使用了`*row`来将行的三个元组中的每个元素分配给`pick_lat_lon()`函数的单独参数。然后，该函数可以提取并重新排序每个三个元组中的两个相关值。
- en: 'To simplify the function definition, we’ve defined two type aliases: `Rows`
    and `LL_Text`. These type aliases can simplify a function definition. They can
    also be reused to ensure that several related functions are all working with the
    same types of objects. This kind of functional design allows us to freely replace
    any function with its equivalent, which makes refactoring less risky.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化函数定义，我们定义了两个类型别名：`Rows`和`LL_Text`。这些类型别名可以简化函数定义。它们也可以被重用来确保几个相关函数都在使用相同类型的对象。这种功能设计允许我们自由地替换任何函数及其等效函数，这使得重构风险降低。
- en: 'These functions can be combined to parse the file and build a structure we
    can use. Here’s an example of some code that could be used for this purpose:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以组合起来解析文件并构建我们可以使用的结构。以下是一些可用于此目的的代码示例：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script uses the `request.urlopen()` function to open a source. In this
    case, it’s a local file. However, we can also open a KML file on a remote server.
    Our objective in using this kind of file opening is to ensure that our processing
    is uniform no matter what the source of the data is.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用`request.urlopen()`函数打开一个源。在这种情况下，它是一个本地文件。然而，我们也可以在远程服务器上打开一个KML文件。我们使用这种文件打开方式的目标是确保无论数据源是什么，我们的处理都是统一的。
- en: The script is built around the two functions that do low-level parsing of the
    KML source. The `row_iter_kml(source)` expression produces a sequence of text
    columns. The `lat_lon_kml()` function will extract and reorder the latitude and
    longitude values. This creates an intermediate result that sets the stage for
    further processing. The subsequent processing can be designed to be independent
    of the original format.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本围绕两个低级解析KML源的功能构建。`row_iter_kml(source)`表达式生成一系列文本列。`lat_lon_kml()`函数将提取并重新排序纬度和经度值。这创建了一个中间结果，为后续处理奠定了基础。后续处理可以设计为独立于原始格式。
- en: The final function provides the latitude and longitude values from a complex
    XML file using an almost purely functional approach. As the result is iterable,
    we can continue to use functional programming techniques to process each point
    that we retrieve from the file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最终函数使用几乎完全函数化的方法从复杂的XML文件中提供纬度和经度值。由于结果是可迭代的，我们可以继续使用函数式编程技术来处理我们从文件中检索到的每个点。
- en: Purists will sometimes argue that using a `for` statement introduces a non-functional
    element. To be pure, the iteration should be defined recursively. Since a recursion
    isn’t a good use of Python language features, we’ll prefer to sacrifice some purity
    for a more Pythonic approach.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹主义者有时会争论说，使用`for`语句引入了一个非函数性元素。为了保持纯粹，迭代应该通过递归定义。由于递归并不是Python语言特性的良好使用，我们宁愿牺牲一些纯粹性，以更Python化的方法为代价。
- en: This design explicitly separates low-level XML parsing from higher-level reorganization
    of the data. The XML parsing produced a generic tuple of string structure. This
    is compatible with parsers for other file formats. As one example, the result
    value is compatible with the output from the CSV parser. When working with SQL
    databases, it can help to use a similar iterable of tuple structures. This permits
    a design for higher-level processing that can work with data from a variety of
    sources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计明确地将低级XML解析与高级数据重组分开。XML解析生成了一个通用的字符串结构元组。这与其他文件格式的解析器兼容。例如，结果值与CSV解析器的输出兼容。当与SQL数据库一起工作时，使用类似的元组结构迭代器可能会有所帮助。这允许设计一个可以处理来自各种数据源的高级处理方案。
- en: We’ll show you a series of transformations to re-arrange this data from a collection
    of strings to a collection of waypoints along a route. This will involve a number
    of transformations. We’ll need to restructure the data as well as convert from
    strings to floating-point values. We’ll also look at a few ways to simplify and
    clarify the subsequent processing steps. We’ll use this dataset in later chapters
    because it’s quite complex.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示一系列转换，以重新排列这些数据，从字符串集合到路线上的航点集合。这将涉及许多转换。我们需要重构数据，以及将字符串转换为浮点值。我们还将探讨几种简化并澄清后续处理步骤的方法。我们将在后续章节中使用这个数据集，因为它相当复杂。
- en: 4.2.3 Pairing up items from a sequence
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3 从序列中配对项目
- en: A common restructuring requirement is to make start-stop pairs out of points
    in a sequence. Given a sequence, S = {s[0],s[1],s[2],...,s[n]}, we would also
    want to create a paired sequence, S = {(s[0],s[1]),(s[1],s[2]),(s[2],s[3]),...,(s[n−1],s[n])}.
    The first and second items form a pair. The second and third items form the next
    pair. Note that the pairs overlap; each point (other than the first or last) will
    be the end of one pair and the start of the next pair.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的重构需求是将序列中的点转换为起始-结束对。给定一个序列，S = {s[0],s[1],s[2],...,s[n]}，我们还想创建一个配对序列，S
    = {(s[0],s[1]),(s[1],s[2]),(s[2],s[3]),...,(s[n−1],s[n])}。第一和第二项形成一个对。第二和第三项形成下一个对。请注意，这些对是重叠的；每个点（除了第一个或最后一个）将是其中一个对的结束和下一个对的开始。
- en: These overlapping pairs are used to compute distances from point to point using
    a trivial application of a haversine function. This technique is also used to
    convert a path of points into a series of line segments in a graphics application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重叠的对用于通过应用哈夫曼函数来计算点与点之间的距离。这种技术也用于将点的路径转换为图形应用程序中的一系列线段。
- en: 'Why pair up items? Why not insert a few additional lines of code into a function
    such as this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要配对项目？为什么不在这个函数中插入几行额外的代码：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code snippet will process each leg of the data as a `begin,`` end` pair.
    However, the processing function and the `for` statement to restructure the data
    are tightly bound, making reuse more complex than necessary. The algorithm for
    pairing is hard to test in isolation when it is one part of a more complex `compute_something()`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段将处理数据中的每一段作为`begin, end`配对。然而，处理函数和重构数据的`for`语句紧密绑定，使得复用比必要的更复杂。当它是更复杂`compute_something()`函数的一部分时，配对算法很难单独测试。
- en: Creating a combined function also limits our ability to reconfigure the application.
    There’s no easy way to inject an alternative implementation of the `compute_something()`
    function. Additionally, we’ve got a piece of an explicit state, the `begin` variable,
    which makes life potentially complex. If we try to add features to the body of
    the `for` statement, we can easily fail to set the `begin` variable correctly
    when an item in the `iterable` source is filtered out from processing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个组合函数也限制了我们的应用重构能力。没有简单的方法可以注入`compute_something()`函数的替代实现。此外，我们还有一个显式状态的部分，即`begin`变量，这可能会使生活变得复杂。如果我们尝试向`for`语句的主体添加功能，我们很容易在`iterable`源中的项被过滤出处理时未能正确设置`begin`变量。
- en: We achieve better reuse by separating this pairing function from other processing.
    Simplification, in the long run, is one of our goals. If we build up a library
    of helpful primitives such as this pairing function, we can tackle larger problems
    more quickly and confidently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个配对函数与其他处理分离，我们实现了更好的复用。从长远来看，简化是我们的目标之一。如果我们构建了一个包含此类配对函数在内的有用原语库，我们就可以更快、更有信心地解决更大的问题。
- en: Indeed, the `itertools` library (the subject of [Chapter 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008)) includes a `pairwise()` function
    we can also use to perform this pairing of values from a source iterator. While
    we can use this function, we’ll also look at how to design our own.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`itertools` 库（[第8章](Chapter_08.xhtml#x1-1700008)，[Itertools 模块](Chapter_08.xhtml#x1-1700008)的主题）中包含了一个`pairwise()`函数，我们也可以使用这个函数来从源迭代器中执行这种值的配对。虽然我们可以使用这个函数，但我们也会探讨如何设计我们自己的。
- en: 'There are many ways to pair up the points along the route to create start and
    stop information for each leg. We’ll look at a few here and then revisit this
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    and again in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008).
    Creating pairs can be done in a purely functional way using a recursion:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将路线上的点配对，为每一段创建起始和终止信息。我们在这里将探讨几种方法，然后在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)和再次在[第8章](Chapter_08.xhtml#x1-1700008)，[Itertools
    模块](Chapter_08.xhtml#x1-1700008)中回顾这个问题。创建配对可以通过递归的纯函数方式完成：
- en: '![ ( |{ [] if |l| ≤ 1 pairs(l) = |( [(l0,l1)]+ pairs(l[1:]) if |l| > 1 ](img/file37.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ [] if |l| ≤ 1 pairs(l) = |( [(l0,l1)]+ pairs(l[1:]) if |l| > 1 ](img/file37.jpg)'
- en: While the mathematical formalism seems simple, it doesn’t account for the way
    item l[1] is both part of the first pair and also the head of the remaining items
    in l[[1:]].
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数学形式似乎很简单，但它没有考虑到项l[1]既是第一个配对的一部分，也是l[[1:]]中剩余项的头部。
- en: The functional ideal is to avoid assigning this value to a variable. Variables—and
    the resulting stateful code—can turn into a problem when we try to make a ”small”
    change and misuse the variable’s value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数理想是避免将此值分配给变量。变量——以及由此产生的有状态代码——当我们试图进行“小”更改并误用变量的值时，可能会变成一个问题。
- en: An alternative is to somehow ”peek” at the upcoming item in the iterable source
    of data. This doesn’t work out well in Python. Once we’ve used `next()` to examine
    the value, it can’t be put back into the iterable. This makes a recursive, functional
    version of creating overlapping pairs a bit too complex to be of any real value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是 somehow “窥视”可迭代数据源中的下一个项。这在Python中效果不佳。一旦我们使用`next()`来检查值，它就不能再放回迭代器中。这使得创建重叠配对的递归、函数版本变得过于复杂，以至于没有实际价值。
- en: Our strategy for performing tail-call optimization is to replace the recursion
    in the mathematical formalism with a `for` statement. In some cases, we can further
    optimize this into a generator expression. Because this works with an explicit
    variable to track the state of the computation, it’s a better fit for Python,
    while being less purely functional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行尾调用优化的策略是将数学形式中的递归替换为`for`语句。在某些情况下，我们可以进一步将其优化为生成器表达式。因为它使用显式变量跟踪计算状态，所以它更适合Python，同时它的函数式程度较低。
- en: 'The following code is an optimized version of a function to pair up the points
    along a route:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个优化版本的函数，用于将沿路线的点配对：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The version is simpler, quite fast, and free from the stack limits of a recursive
    definition. It’s independent of any particular type of sequence, as it will pair
    up anything emitted by a sequence generator. As there’s no processing function
    inside the loop, we can reuse the `legs()` function as needed. We could also redesign
    this function slightly to accept a processing function as a parameter value, and
    apply the given function to each `(begin,`` end)` pair that’s created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更简单，相当快，并且不受递归定义的栈限制。它不依赖于任何特定的序列类型，因为它将配对序列生成器发出的任何内容。由于循环中没有处理函数，我们可以根据需要重复使用`legs()`函数。我们还可以稍微重新设计这个函数，使其接受一个处理函数作为参数值，并将给定的函数应用于创建的每个`(begin,
    end)`对。
- en: The type variable, `LL_Type`, is used to clarify precisely how the `legs()`
    function restructures the data. The hint says that the input type is preserved
    on output. The input type is an `Iterator` of some arbitrary type, `LL_Type`;
    the output will include tuples of the same type, `LL_Type`. No other conversion
    is implied by the function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量`LL_Type`用于明确说明`legs()`函数如何重构数据。提示说明输入类型在输出时被保留。输入类型是某种任意类型的`Iterator`，即`LL_Type`；输出将包括相同类型的元组，即`LL_Type`。该函数没有隐含其他转换。
- en: The `begin` and `end` variables maintain the state of the computation. The use
    of stateful variables doesn’t fit the ideal of using immutable objects for functional
    programming. The optimization, however, is important in Python. It’s also invisible
    to users of the function, making it a Pythonic-functional hybrid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`和`end`变量维护计算状态。使用有状态的变量不符合使用不可变对象进行函数式编程的理想。然而，这种优化在Python中很重要。它对函数的用户来说是不可见的，使其成为一种Pythonic-functional混合体。'
- en: Note that this function requires an iterable source of individual values. This
    can be an iterable collection or a generator.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数需要一个可迭代的单个值来源。这可以是一个可迭代的集合或一个生成器。
- en: 'We can think of this function as one that yields the following kind of sequence
    of pairs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数视为产生以下类型的对序列：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another view of this function using the built-in `zip()` function is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`zip()`函数查看这个函数的另一种方式如下：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While informative, this `zip()`-based example only works for sequence objects.
    The `pairs()` function shown earlier will work for any iterable, including sequence
    objects. The `legs()` function only works for an `Iterator` object as the source
    of data. The good news is we can make an iterator object from an iterable collection
    with the built-in `iter()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个基于`zip()`的示例很有信息量，但它仅适用于序列对象。前面展示的`pairs()`函数适用于任何可迭代对象，包括序列对象。`legs()`函数仅适用于`Iterator`对象作为数据源。好消息是，我们可以使用内置的`iter()`函数将可迭代集合转换为迭代器对象。
- en: 4.2.4 Using the iter() function explicitly
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4 显式使用iter()函数
- en: 'From a purely functional viewpoint, all of our iterables can be processed with
    recursive functions, where the state is managed by the recursive call stack. Pragmatically,
    processing iterables in Python will often involve evaluation of `for` statements.
    There are two common situations: collection objects and iterables. When working
    with a collection object, an `Iterator` object is created by the `for` statement.
    When working with a generator function, the generator function is an iterator
    and maintains its own internal state. Often, these are equivalent, from a Python
    programming perspective. In rare cases—generally those situations where we have
    to use the `next()` function explicitly—the two won’t be precisely equivalent.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的功能角度来看，我们所有的可迭代对象都可以通过递归函数进行处理，其中状态由递归调用堆栈管理。在实践中，在Python中处理可迭代对象通常涉及`for`语句的评估。有两种常见的情况：集合对象和可迭代对象。当与集合对象一起工作时，`for`语句创建一个`Iterator`对象。当与生成器函数一起工作时，生成器函数是一个迭代器，并保持其自己的内部状态。通常，从Python编程的角度来看，它们是等效的。在罕见的情况下——通常是我们必须显式使用`next()`函数的情况——这两个不会完全等效。
- en: The `legs()` function shown previously has an explicit `next()` evaluation to
    get the first value from the iterable. This works wonderfully well with generator
    functions, expressions, and other iterables. It doesn’t work with sequence objects
    such as tuples or lists.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的`legs()`函数有一个显式的`next()`评估，用于从可迭代对象中获取第一个值。这对于生成器函数、表达式和其他可迭代对象工作得非常好。它不适用于序列对象，如元组或列表。
- en: 'The following code contains three examples to clarify the use of the `next()`
    and `iter()` functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含三个示例，用于阐明`next()`和`iter()`函数的使用：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first case, we applied the `legs()` function to an iterable. In this
    case, the iterable was a generator expression. This is the expected behavior based
    on our previous examples in this chapter. The items are properly paired up to
    create two legs from three waypoints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将`legs()`函数应用于一个可迭代对象。在这种情况下，可迭代对象是一个生成器表达式。这是基于本章前面示例中我们期望的行为。项目被正确配对，从三个航点中创建出两条腿。
- en: In the second case, we tried to apply the `legs()` function to a sequence. This
    resulted in an error. While a list object and an iterable are equivalent when
    used in a `for` statement, they aren’t equivalent everywhere. A sequence isn’t
    an iterator; a sequence doesn’t implement the `__next__()` special method allowing
    it to be used by the `next()` function. The `for` statement handles this gracefully,
    however, by creating an iterator from a sequence automatically.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们尝试将`legs()`函数应用于一个序列。这导致了一个错误。虽然列表对象和可迭代对象在`for`语句中使用时是等价的，但它们并不在所有地方都等价。序列不是一个迭代器；序列没有实现允许它被`next()`函数使用的`__next__()`特殊方法。然而，`for`语句通过自动从序列创建迭代器来优雅地处理这种情况。
- en: To make the second case work, we need to explicitly create an iterator from
    a list object. This permits the `legs()` function to get the first item from the
    iterator over the list items. The `iter()` function will create an iterator from
    a list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使第二种情况工作，我们需要从列表对象中显式创建一个迭代器。这允许`legs()`函数从列表项的迭代器中获取第一个项。`iter()`函数将从列表创建一个迭代器。
- en: 4.2.5 Extending an iteration
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5 扩展迭代
- en: We have two kinds of extensions we could factor into a `for` statement that
    processes iterable data. We’ll look first at a filter extension. In this case,
    we may be rejecting values from further consideration. They may be data outliers,
    or perhaps source data that’s improperly formatted. Then, we’ll look at mapping
    source data by performing a simple transformation to create new objects from the
    original objects. In our case, we’ll be transforming strings to floating-point
    numbers. The idea of extending a simple `for` statement with a mapping, however,
    applies to many situations. We’ll look at refactoring the above `legs()` function.
    What if we need to adjust the sequence of points to discard a value? This will
    introduce a filter extension that rejects some data values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将两种类型的扩展因素化到一个`for`语句中，该语句处理可迭代数据。我们首先将查看一个过滤器扩展。在这种情况下，我们可能会拒绝进一步考虑的值。它们可能是数据异常值，或者可能是格式不正确的源数据。然后，我们将查看通过执行简单转换来创建新对象，从而将源数据映射到源数据。在我们的情况下，我们将把字符串转换为浮点数。然而，将映射扩展到简单`for`语句的想法适用于许多情况。我们将查看重构上述`legs()`函数。如果我们需要调整点序列以丢弃一个值怎么办？这将引入一个过滤器扩展，拒绝一些数据值。
- en: The iterative process we’re designing returns pairs without performing any additional
    application-related processing—the complexity is minimal. Simplicity means we’re
    somewhat less likely to confuse the processing state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设计的迭代过程返回成对的数据，而不执行任何额外的应用相关处理——复杂性最小。简单意味着我们不太可能混淆处理状态。
- en: 'Adding a filter extension to this design could look something like the following
    code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 向此设计添加一个过滤器扩展可能看起来像以下代码片段：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have plugged in a processing rule to reject certain values. As the `for`
    statement remains succinct and expressive, we are confident that the processing
    will be done properly. We have, on the other hand, cluttered up a relatively simple
    function with two separate collections of features. This kind of clutter is not
    an ideal approach to functional design.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经插入了一个处理规则来拒绝某些值。由于 `for` 语句保持简洁和表达性强，我们相信处理将会被正确执行。另一方面，我们用一个相对简单的函数和两个单独的特征集合搞乱了代码。这种混乱并不是功能设计的理想方法。
- en: We haven’t really provided much information about the `rejection_rule()` function.
    This needs to be a kind of condition that applies to a `Leg` tuple to reject the
    point from further consideration. For example, it may reject `begin`` ==`` end`
    to avoid zero-length legs. A handy default value for `rejection_rule` is `lambda`` s,`` e:`` False`.
    This will preserve all of the legs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '我们并没有提供很多关于 `rejection_rule()` 函数的信息。这需要是一种适用于 `Leg` 元组的条件，以拒绝进一步考虑的点。例如，它可能会拒绝
    `begin == end` 以避免零长度的腿。`rejection_rule` 的一个方便的默认值是 `lambda s, e: False`。这将保留所有的腿。'
- en: The next refactoring will introduce additional mapping to an iteration. Adding
    mappings is common when a design is evolving. In our case, we have a sequence
    of string values. We need to convert these to float values for later use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重构将引入额外的映射到迭代中。在设计演变时添加映射是常见的。在我们的例子中，我们有一系列字符串值。我们需要将这些转换为浮点值以供以后使用。
- en: 'The following is one way to handle this data mapping, through a generator expression
    that wraps a generator function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过一个包装生成器函数的生成器表达式来处理这种数据映射的一种方法：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve applied the `legs()` function to a generator expression that creates float
    values from the output of the `lat_lon_kml()` function. We can read this in an
    inside-out order as well. The `lat_lon_kml()` function’s output is transformed
    into a pair of float values, which is then transformed into a sequence of legs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `legs()` 函数应用于一个生成器表达式，该表达式从 `lat_lon_kml()` 函数的输出中创建浮点值。我们也可以按从内到外的顺序读取。`lat_lon_kml()`
    函数的输出被转换成一对浮点值，然后转换成一系列腿。
- en: 'This is starting to get complex. We’ve got a large number of nested functions
    here. We’re applying `float()`, `legs()`, and `list()` to a data generator. One
    common way of refactoring complex expressions is to separate the generator expression
    from any materialized collection. We can do the following to simplify the expression:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始变得复杂了。这里有很多嵌套的函数。我们正在将 `float()`、`legs()` 和 `list()` 应用于一个数据生成器。重构复杂表达式的常见方法是将生成器表达式与任何具体化的集合分离。我们可以这样做来简化表达式：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve assigned the generator function to a variable named `ll_iter`. This variable
    isn’t a collection object; it’s a generator of item two-tuples. We’re not using
    a list comprehension to create an object. We’ve merely assigned the generator
    expression to a variable name. We’ve then used the `ll_iter` variable in a subsequent
    expression.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将生成器函数分配给一个名为 `ll_iter` 的变量。这个变量不是一个集合对象；它是一个包含项两元组的生成器。我们没有使用列表推导来创建一个对象。我们只是将生成器表达式分配给一个变量名。然后我们在后续表达式中使用了
    `ll_iter` 变量。
- en: The evaluation of the `list()` function actually leads to a proper object being
    built so that we can print the output. The `ll_iter` variable’s items are created
    only as needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()` 函数的评估实际上导致了一个正确的对象被构建，这样我们就可以打印输出。`ll_iter` 变量的项仅按需创建。'
- en: There is yet another refactoring we might like to do. In general, the source
    of the data is something we often want to change. In our example, the `lat_lon_kml()`
    function is tightly bound in the rest of the expression. This makes reuse difficult
    when we have a different data source.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要进行另一种重构。一般来说，数据源是我们经常想要更改的东西。在我们的例子中，`lat_lon_kml()` 函数与其他表达式的绑定非常紧密。当我们有不同数据源时，这使重用变得困难。
- en: 'In the case where the `float()` operation is something we’d like to parameterize
    so that we can reuse it, we can define a function around the generator expression.
    We’ll extract some of the processing into a separate function merely to group
    the operations. In our case, the string-pair to float-pair is unique to particular
    source data. We can rewrite a complex float-from-string expression into a simpler
    function, such as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`float()`操作是我们希望参数化以便可以重用的情况下，我们可以在生成器表达式周围定义一个函数。我们将一些处理提取到一个单独的函数中，仅仅是为了分组操作。在我们的情况下，字符串对到浮点对的转换是特定源数据独有的。我们可以将复杂的从字符串到浮点数的表达式重写为一个更简单的函数，例如：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `floats_from_pair()` function applies the `float()` function to the first
    and second values of each item in the iterable, yielding a two-tuple of floats
    created from an input value. We’ve relied on Python’s `for` statement to decompose
    the two-tuple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`floats_from_pair()`函数将`float()`函数应用于可迭代中每个项目的第一个和第二个值，从而从输入值创建一个包含两个浮点数的元组。我们依赖于Python的`for`语句来分解这个元组。'
- en: The type hints detail the transformation from an iterable sequence of `tuple[str,`` str]`
    items to `tuple[float,`` float]` items. The `LL_Iter` type alias can then be used
    elsewhere in a complex set of function definitions to show how the float pairs
    are processed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示详细说明了从`tuple[str, str]`项的可迭代序列到`tuple[float, float]`项的转换。然后，`LL_Iter`类型别名可以在复杂函数定义的其它地方使用，以展示浮点对是如何处理的。
- en: 'We can use this function in the following context:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下上下文中使用此函数：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’re going to create legs that are built from float values that come from a
    KML file. It’s fairly easy to visualize the processing, as each stage in the process
    is a prefix function. Each function’s input is the output from the next function
    in the nested processing steps. This seems like a natural way to express a pipeline
    of processing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建由来自KML文件的浮点值构建的腿。可视化处理过程相当容易，因为过程中的每个阶段都是一个前缀函数。每个函数的输入是嵌套处理步骤中下一个函数的输出。这似乎是表达处理管道的自然方式。
- en: When parsing, we often have sequences of string values. For numeric applications,
    we’ll need to convert strings to float, int, or `Decimal` values. This often involves
    inserting a function such as the `floats_from_pair()` function into a sequence
    of expressions that clean up the source data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析时，我们经常有字符串值的序列。对于数值应用，我们需要将字符串转换为浮点数、整数或`Decimal`值。这通常涉及到将`floats_from_pair()`函数等函数插入到清理源数据的表达式序列中。
- en: 'Our previous output was all strings; it looked like the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的输出都是字符串；它看起来像以下代码片段：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll want data like the following code snippet, where we have floats:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望得到如下代码片段所示的数据，其中包含浮点数：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After building this processing pipeline, there are some simplifications available.
    We’ll look at some refactoring in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order
    Functions](Chapter_05.xhtml#x1-1000005). We will revisit this in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006), to see how to apply
    these simplifications to the file parsing problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了这个处理管道之后，有一些简化可用。我们将在[第5章](Chapter_05.xhtml#x1-1000005)和[高阶函数](Chapter_05.xhtml#x1-1000005)中查看一些重构。我们将在[第6章](Chapter_06.xhtml#x1-1260006)和[递归与归约](Chapter_06.xhtml#x1-1260006)中重新审视这个问题，看看如何将这些简化应用到文件解析问题中。
- en: 4.2.6 Applying generator expressions to scalar functions
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.6 将生成器表达式应用于标量函数
- en: We’ll look at a more complex kind of generator expression to map data values
    from one kind of data to another. In this case, we’ll apply a fairly complex function
    to individual data values created by a generator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一种更复杂的生成器表达式，用于将一种数据类型的值映射到另一种数据类型。在这种情况下，我们将对一个由生成器创建的单独数据值应用一个相当复杂的函数。
- en: We’ll call these non-generator functions scalar, as they work with simple atomic
    values. To work with collections of data, a scalar function will be embedded in
    a generator expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些非生成器函数称为标量，因为它们与简单的原子值一起工作。要处理数据集合，标量函数将嵌入到生成器表达式中。
- en: To continue the example started earlier, we’ll provide a haversine function
    to compute the distance between latitude and longitude values. Technically, these
    are angles, and some spherical trigonometry is required to convert angles to distances
    on the surface of the sphere. We can use a generator expression to apply a scalar
    `haversine()` function to a sequence of pairs from our KML file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续之前开始的例子，我们将提供一个 haversine 函数来计算纬度和经度值之间的距离。技术上，这些是角度，并且需要一些球面三角学来将角度转换为球面上的距离。我们可以使用生成器表达式将标量
    `haversine()` 函数应用于从我们的 KML 文件中提取的一对序列。
- en: The important part of the `haversine()` function is to compute a distance between
    two points following the proper spherical geometry of the earth. It can involve
    some tricky-looking math, but we’ve provided the whole definition here. We also
    mentioned this function at the beginning of the [Working with iterables](#x1-760002)
    section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`haversine()` 函数的重要部分是计算两个点之间的距离，遵循地球的正确球面几何。这可能涉及一些看起来很复杂的数学，但我们在这里提供了整个定义。我们还在
    [使用可迭代对象](#x1-760002) 部分的开头提到了这个函数。'
- en: 'The `haversine()` function is implemented by the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`haversine()` 函数通过以下代码实现：'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The start and end points, `p1` and `p2`, have type hints to show their structure.
    The return value is also provided with a hint. The explicit use of a type alias
    for `Point` makes it possible for the mypy tool to confirm that this function
    is used properly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 起点和终点 `p1` 和 `p2` 有类型提示以显示其结构。返回值也提供了提示。显式使用 `Point` 的类型别名使得 mypy 工具能够确认此函数被正确使用。
- en: 'For short distances covered by coastal sailors, the equirectangular distance
    computation is more useful:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于沿海水手覆盖的短距离，等距圆柱距离计算更有用：
- en: '![ Δ ϕ x = R × Δ λ × cos--- 2 ](img/file38.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![ Δ ϕ x = R × Δ λ × cos--- 2 ](img/file38.jpg)'
- en: '![y = R × Δϕ ](img/file39.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![y = R × Δϕ ](img/file39.jpg)'
- en: '![d = ∘x2-+-y2- ](img/file40.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![d = ∘x2-+-y2- ](img/file40.jpg)'
- en: Where R is the earth’s mean radius, R = ![360×60 --2π---](img/file41.jpg) nautical
    miles. The ϕ values are N-S latitude, and the λ values are E-W longitude. This
    means (ϕ[0],λ[0]) and (ϕ[1],λ[1]) are the two points we’re navigating between.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 R 是地球的平均半径，R = ![360×60 --2π---](img/file41.jpg) 海里。ϕ 值是南北纬度，λ 值是东西经度。这意味着
    (ϕ[0],λ[0]) 和 (ϕ[1],λ[1]) 是我们正在导航的两个点。
- en: See [https://edwilliams.org/avform147.htm](https://edwilliams.org/avform147.htm)
    for more information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅 [https://edwilliams.org/avform147.htm](https://edwilliams.org/avform147.htm)。
- en: 'The following code is how we could use our collection of functions to examine
    some KML data and produce a sequence of distances:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何使用我们的函数集合来检查一些 KML 数据并生成一系列距离：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The essence of the processing is the generator expression assigned to the `trip`
    variable. We’ve assembled three-tuples with a start, end, and the distance from
    start to end. The start and end pairs come from the `legs()` function. The `legs()`
    function works with floating-point data built from the latitude-longitude pairs
    extracted from a KML file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的本质是将生成器表达式分配给 `trip` 变量。我们已经组装了包含起点、终点和从起点到终点的距离的三元组。起点和终点对来自 `legs()` 函数。`legs()`
    函数与从 KML 文件中提取的纬度-经度对构建的浮点数据一起工作。
- en: 'The output looks like the following command snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像以下命令片段：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each individual processing step has been defined succinctly. The overview, similarly,
    can be expressed succinctly as a composition of functions and generator expressions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理步骤都已被简洁地定义。概览同样可以简洁地表达为函数和生成器表达式的组合。
- en: Clearly, there are several further processing steps we may like to apply to
    this data. The first, of course, is to use the `format()` method of a string to
    produce better-looking output.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可能希望对这个数据应用几个进一步的加工步骤。首先，当然是要使用字符串的 `format()` 方法来生成更美观的输出。
- en: More importantly, there are a number of aggregate values we’d like to extract
    from this data. We’ll call these values reductions of the available data. We’d
    like to reduce the data to get the maximum and minimum latitude, for example,
    to show the extreme north and south ends of this route. We’d like to reduce the
    data to get the maximum distance in one leg as well as the total distance for
    all legs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们希望从这个数据中提取一些聚合值。我们将这些值称为可用数据的缩减。我们希望将数据缩减到获取最大和最小纬度，例如，以显示这条路线的极端南北端。我们还想将数据缩减到获取单段的最大距离以及所有段的总距离。
- en: The problem we’ll have using Python is that the output generator in the `trip`
    variable can be used only once. We can’t easily perform several reductions of
    this detailed data. While we can use `itertools.tee()` to work with the iterable
    several times, it takes a fair amount of memory. It can be wasteful, also, to
    read and parse the KML file for each reduction. We can make our processing more
    efficient by materializing intermediate results as a list object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用 Python 时会遇到的问题是，`trip` 变量的输出生成器只能使用一次。我们无法轻松地对这些详细数据进行多次缩减。虽然我们可以使用 `itertools.tee()`
    函数多次处理可迭代对象，但它需要相当多的内存。每次缩减都读取和解析 KML 文件也可能造成浪费。我们可以通过将中间结果物化为列表对象来提高我们的处理效率。
- en: In the next section, we look at two specific kinds of reductions that compute
    a single boolean result from a collection of booleans.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨两种特定的缩减类型，它们从一组布尔值计算出一个单一的布尔结果。
- en: 4.3 Using any() and all() as reductions
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 使用 any() 和 all() 作为缩减
- en: 'The `any()` and `all()` functions provide boolean reduction capabilities. Both
    functions reduce a collection of values to a single `True` or `False`. The `all()`
    function ensures that all items have a true value; the `any()` function ensures
    that at least one item has a true value. In both cases, these functions rely on
    the Pythonic concept of ”truish”, or truthy: values for which the built-in `bool()`
    function returns `true`. Generally, ”falsish” values include `False` and `None`,
    as well as zero, an empty string, and empty collections. Non-false values are
    true.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()` 和 `all()` 函数提供了布尔缩减功能。这两个函数将一组值缩减为一个单一的 `True` 或 `False`。`all()` 函数确保所有项都具有真值；`any()`
    函数确保至少有一个项具有真值。在这两种情况下，这些函数依赖于 Python 的概念“truish”，或“truthy”：这些值在内置的 `bool()` 函数返回
    `true`。一般来说，“falsish”值包括 `False` 和 `None`，以及零、空字符串和空集合。非假值即为真值。'
- en: 'These functions are closely related to a universal quantifier and an existential
    quantifier used to express mathematical logic. We may, for example, want to assert
    that all elements in a given collection have a property. One formalism for this
    could look like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与用于表达数学逻辑的全称量词和存在量词密切相关。例如，我们可能想要断言给定集合中的所有元素都具有某个属性。这种形式之一可能如下所示：
- en: '![(∀x∈S)Prime (x ) ](img/file42.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![(∀x∈S)Prime (x ) ](img/file42.jpg)'
- en: We read this as for all x in S, the function, Prime(x), is true. We’ve used
    the universal quantifier, for all, ∀, in front of the logical expression.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样读它：对于 S 中的所有 x，Prime(x) 函数为真。我们在逻辑表达式前使用了全称量词“对于所有”，即 ∀。
- en: 'In Python we switch the order of the items slightly to transcribe the logic
    expression as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们稍微调整了项的顺序，将逻辑表达式转录如下：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `all()` function will evaluate the `isprime(x)` function for each distinct
    value of `x` and reduce the collection of values to a single `True` or `False`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 函数将评估 `isprime(x)` 函数对每个不同的 `x` 值，并将值集合缩减为一个单一的 `True` 或 `False`。'
- en: 'The `any()` function is related to the existential quantifier. If we want to
    assert that no value in a collection is prime, we could use one of these two equivalent
    expressions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()` 函数与存在量词相关。如果我们想要断言集合中没有值是素数，我们可以使用以下两个等价表达式之一：'
- en: '![¬ (∀ )Prime (x) ≡ (∃ )¬ Prime (x) x∈S x∈S ](img/file43.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![¬ (∀ )Prime (x) ≡ (∃ )¬ Prime (x) x∈S x∈S ](img/file43.jpg)'
- en: The left side states that it is not the case that all elements in S are prime.
    The right side asserts that there exists one element in S that is not prime. These
    two are equivalent; that is, if not all elements are prime, then one element must
    be non-prime.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 左边表述的是 S 中所有元素都不是素数的情况。右边断言 S 中存在一个不是素数的元素。这两个是等价的；也就是说，如果所有元素都不是素数，那么必须有一个元素是非素数。
- en: This rule of equivalence is called De Morgan’s Law. It can be stated generally
    as ∀xP(x) ≡ ¬∃x¬P(x). If some proposition, P(x), is true for all x, there is no
    x for which P(x) is false.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等价规则被称为德摩根定律。它可以一般地表述为 ∀xP(x) ≡ ¬∃x¬P(x)。如果某个命题 P(x) 对所有 x 都为真，那么不存在 x 使得
    P(x) 为假。
- en: 'In Python, we can switch the order of the terms and transcribe these to working
    code in either of these two forms:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以交换项的顺序，并将这些转换为以下两种形式中的任意一种有效代码：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As these two lines are equivalent, there are two common reasons for choosing
    one over the other: performance and clarity. The performance is nearly identical,
    so it boils down to clarity. Which of these states the condition the most clearly?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两行是等价的，选择其中一行而舍弃另一行的两个常见原因：性能和清晰度。性能几乎相同，所以归结为清晰度。哪个表述的条件最为清晰？
- en: The `all()` function can be described as an and reduction of a set of values.
    The result is similar to folding the `and` operator between the given sequence
    of values. The `any()` function, similarly, can be described as an or reduction.
    We’ll return to this kind of general-purpose reducing when we look at the `reduce()`
    function in [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010).
    There’s no best answer here; it’s a question of what seems most readable to the
    intended audience.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 函数可以被描述为一系列值的“与”归约。结果是类似于在给定的值序列之间折叠 `and` 操作符。类似地，`any()` 函数可以被描述为“或”归约。当我们查看第
    10 章 [The Functools Module](Chapter_10.xhtml#x1-21700010) 中的 `reduce()` 函数时，我们会回到这种通用归约。这里没有最佳答案；这是一个关于什么对目标读者来说最易读的问题。'
- en: We also need to look at the degenerate case of these functions. What if the
    sequence has no elements? What are the values of `all(())` or `all([])`?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑这些函数的退化情况。如果序列没有元素，`all(())` 或 `all([])` 的值是什么？
- en: 'Consider a list, `[1,`` 2,`` 3]`. The expression `[]`` +`` [1,`` 2,`` 3]`` ==`` [1,`` 2,`` 3]`
    is true because the empty list is the identity value for list concatenation. This
    also works for the `sum(())` function: `sum([])`` +`` sum([1,`` 2,`` 3])`` ==`` sum([1,`` 2,`` 3])`.
    The sum of an empty list must be the additive identity value for addition, zero.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个列表 `[1, 2, 3]`。表达式 `[] + [1, 2, 3] == [1, 2, 3]` 是正确的，因为空列表是列表连接的恒等值。这也适用于
    `sum(())` 函数：`sum([]) + sum([1, 2, 3]) == sum([1, 2, 3])`。空列表的总和必须是加法的恒等值，即零。
- en: 'The `and` identity value is `True`. This is because `True`` and`` whatever`` ==`` whatever`.
    Similarly, the `or` identity value is `False`. The following code demonstrates
    that Python follows these rules:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 的恒等值是 `True`。这是因为 `True` `and` `whatever` `==` `whatever`。同样，`or` 的恒等值是
    `False`。以下代码演示了 Python 遵循这些规则：'
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Python gives us some very nice tools to perform processing that involves logic.
    We have the built-in `and`, `or`, and `not` operators. However, we also have these
    collection-oriented `any()` and `all()` functions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们一些非常棒的工具来执行涉及逻辑的处理。我们有内置的 `and`、`or` 和 `not` 操作符。然而，我们还有这些集合导向的 `any()`
    和 `all()` 函数。
- en: 4.4 Using len() and sum() on collections
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 使用 len() 和 sum() 对集合进行操作
- en: The `len()` and `sum()` functions provide two simple reductions—a count of the
    elements and the sum of the elements in a sequence. These two functions are mathematically
    similar, but their Python implementation is quite different.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()` 和 `sum()` 函数提供了两种简单的归约——序列中元素的计数和元素的总和。这两个函数在数学上是相似的，但它们的 Python 实现却相当不同。'
- en: 'Mathematically, we can observe this cool parallelism:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上观察，我们可以看到这种酷炫的并行性：
- en: 'The `len()` function returns the sum of ones for each value in a collection,
    X: ∑ [x∈X]1 = ∑ [x∈X]x⁰.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len()` 函数返回集合中每个值的“1”的总和，X：∑ [x∈X]1 = ∑ [x∈X]x⁰。'
- en: 'The `sum()` function returns the sum of each value in a collection, X: ∑ [x∈X]x
    = ∑ [x∈X]x¹.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()` 函数返回集合中每个值的总和，X：∑ [x∈X]x = ∑ [x∈X]x¹。'
- en: The `sum()` function works for any iterable. The `len()` function doesn’t apply
    to iterables; it only applies to sequences. This little asymmetry in the implementation
    of these functions is a little awkward around the edges of statistical algorithms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()` 函数适用于任何可迭代对象。`len()` 函数不适用于可迭代对象；它只适用于序列。这些函数在实现上的这种微小不对称性在统计算法的边缘有点尴尬。'
- en: 'As noted above, for empty sequences, both of these functions return a proper
    additive identity value of zero:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于空序列，这两个函数都返回适当的加法恒等值零：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While `sum(())` returns an integer zero, this isn’t a problem when working with
    float values. When other numeric types are used, the integer zero can be used
    along with values of the types of the available data. Python’s numeric types generally
    have rules for performing operations with values of other numeric types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `sum(())` 返回整数零，但在处理浮点值时这不是问题。当使用其他数值类型时，可以与可用数据类型的值一起使用整数零。Python 的数值类型通常有与其他数值类型进行操作的规则。
- en: 4.4.1 Using sums and counts for statistics
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 使用总和和计数进行统计
- en: In this section, we’ll implement a number of functions useful for statistics.
    The point is show how functional programming can be applied to the kinds of processing
    that are common in statistical functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一些对统计有用的函数。目的是展示函数式编程如何应用于统计函数中常见的处理类型。
- en: Several common functions are described as ”measure of central tendency”. Functions
    like the arithmetic mean or the standard deviation provide a summary of a collection
    of values. A transformation called ”normalization” shifts and scales values around
    a population mean and standard deviation. We’ll also look at how to compute a
    coefficient of correlation to show to what extent two sets of data are related
    to each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几个常见的函数被描述为“集中趋势的度量”。像算术平均值或标准差这样的函数提供了一组值的总结。一种称为“归一化”的转换将值移动和缩放到总体平均值和标准差周围。我们还将探讨如何计算相关系数，以显示两组数据相互关联的程度。
- en: Readers might want to look at [https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df](https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df)
    for more information on descriptive statistics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能想查看[https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df](https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df)，以获取更多关于描述性统计的信息。
- en: 'The arithmetic mean seems to have an appealingly trivial definition based on
    `sum()` and `len()`. It looks like the following might work:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 算术平均值似乎基于`sum()`和`len()`有一个吸引人的简单定义。看起来以下可能可行：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simple-looking function doesn’t work for `Iterable` objects. This definition
    only works for collections that support the `len()` function. This is easy to
    discover when trying to write proper type annotations. The definition of `mean(items:`` Iterable[float])`` ->`` float`
    won’t work because more general `Iterable[float]` types don’t support `len()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '这个看起来简单的函数对`Iterable`对象不起作用。这个定义只适用于支持`len()`函数的集合。当尝试编写正确的类型注解时，这一点很容易发现。`mean(items:
    Iterable[float]) -> float`的定义将不起作用，因为更通用的`Iterable[float]`类型不支持`len()`。'
- en: Indeed, we have a hard time performing a computation like standard deviation
    based on iterables. In Python, we must either materialize a sequence object or
    resort to somewhat more complex processing that computes multiple sums on a single
    pass through the data. To use simpler functions means using a `list()` to create
    a concrete sequence that can be processed multiple times.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们很难根据可迭代对象执行像标准差这样的计算。在Python中，我们必须要么实例化一个序列对象，要么求助于相对复杂的处理，这种处理在单次遍历数据时计算多个总和。要使用更简单的函数，意味着使用`list()`创建一个具体的序列，该序列可以被多次处理。
- en: 'To pass muster with mypy, the definition needs to look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过mypy的审查，定义需要看起来像这样：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This includes the appropriate type hints to ensure that `sum()` and `len()`
    will both work for the expected types of data. The mypy tool is aware of the arithmetic
    type matching rules: any value that could be treated as a float would be considered
    valid. This means that `mean([1,`` 2,`` 3])` will be accepted by the mypy tool
    in spite of the values being all integers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括适当的类型提示，以确保`sum()`和`len()`都能为预期的数据类型工作。mypy工具了解算术类型匹配规则：任何可以被视为浮点数的值都将被视为有效。这意味着`mean([1,
    2, 3])`将由于值都是整数而被mypy工具接受。
- en: 'We have some alternative and elegant expressions for mean and standard deviation
    in the following definitions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下定义中，我们有关于平均值和标准差的替代和优雅的表达式：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These three sums, `s0`, `s1`, and `s2`, have a tidy, parallel structure. We
    can easily compute the mean from two of the sums. The standard deviation is a
    bit more complex, but it’s based on the three available sums.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个总和`s0`、`s1`和`s2`具有整洁的并行结构。我们可以轻松地从两个总和计算平均值。标准差稍微复杂一些，但它基于三个可用的总和。
- en: This kind of pleasant symmetry also works for more complex statistical functions,
    such as correlation and even least-squares linear regression.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种令人愉悦的对称性也适用于更复杂的统计函数，例如相关性和最小二乘线性回归。
- en: 'The moment of correlation between two sets of samples can be computed from
    their standardized value. The following is a function to compute the standardized
    value:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个样本集之间的相关矩可以从它们的标准化值计算得出。以下是一个计算标准化值的函数：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The calculation subtracts the mean, μ[x], from each sample, x, and divides it
    by the standard deviation, σ[x]. This gives us a value measured in units of sigma,
    σ. For normally-distributed data, a value ±1σ is expected about two-thirds of
    the time. More extreme values should be less common. A value outside ±3σ should
    happen less than one percent of the time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种计算从每个样本x中减去平均值μ[x]，然后除以标准差σ[x]。这给我们一个以sigma，σ为单位的值。对于正态分布的数据，大约三分之二的时间会期望一个±1σ的值。更极端的值应该更不常见。一个在±3σ之外的价值应该发生不到百分之一的时间。
- en: 'We can use this scalar function as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用这个标量函数：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’ve built a list that consists of normalized scores based on some raw data
    in the variable, `d`. We used a generator expression to apply the scalar function,
    `z()`, to the sequence object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个列表，其中包含基于变量 `d` 中一些原始数据的归一化分数。我们使用生成器表达式将标量函数 `z()` 应用到序列对象上。
- en: 'The `mean()` and `stdev()` functions are based on the examples shown previously:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean()` 和 `stdev()` 函数基于之前展示的示例：'
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The three sum functions, similarly, can be defined as shown in the following
    code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，三个求和函数可以定义为以下代码所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While this is very expressive and succinct, it’s a little frustrating because
    we can’t use an iterable here. When evaluating the `mean()` function, for example,
    both a sum of the iterable and a count of the iterable are required. For the standard
    deviation, two sums and a count of the iterable are all required. For this kind
    of statistical processing, we must materialize a sequence object (in other words,
    create a `list`) so that we can examine the data multiple times.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这非常简洁且表达力强，但有一点令人沮丧，因为我们不能在这里使用可迭代对象。例如，在评估 `mean()` 函数时，需要可迭代对象的和以及计数。对于标准差，需要两个和以及可迭代对象的计数。对于这种类型的统计处理，我们必须实际化一个序列对象（换句话说，创建一个
    `list`），这样我们才能多次检查数据。
- en: 'The following code shows how we can compute the correlation between two sets
    of samples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何计算两组样本之间的相关性：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This correlation function, `corr()`, gathers basic statistical summaries of
    the two sets of samples: the mean and standard deviation. Given these summaries,
    we define two generator functions that will create normalized values for each
    set of samples. We can then use the `zip()` function (see the next example) to
    pair up items from the two sequences of normalized values and compute the product
    of those two normalized values. The average of the product of the normalized scores
    is the correlation.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相关性函数 `corr()` 收集两组样本的基本统计摘要：平均值和标准差。有了这些摘要，我们定义了两个生成器函数，它们将为每组样本创建归一化值。然后我们可以使用
    `zip()` 函数（参见下一个示例）将两个归一化值序列中的项目配对，并计算这两个归一化值的乘积。归一化分数乘积的平均值就是相关性。
- en: 'The following code is an example of gathering the correlation between two sets
    of samples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是收集两组样本之间相关性的示例：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We’ve shown two sequences of data points, `xi` and `yi`. The correlation is
    over `0.99`, which shows a very strong relationship between the two sequences.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了两个数据点的序列，`xi` 和 `yi`。相关系数超过 `0.99`，这表明这两个序列之间存在非常强的关系。
- en: This shows one of the strengths of functional programming. We’ve created a handy
    statistical module using a half-dozen functions with definitions that are single
    expressions. Interestingly, the the `corr()` function can’t easily be reduced
    to a single expression. (It can be reduced to a single very long expression, but
    it would be terribly hard to read.) Each internal variable in this function’s
    implementation is used only once. This shows us that the `corr()` function has
    a functional design, even though it’s written out in six separate lines of Python.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了函数式编程的一个优势。我们使用六个定义单一表达式的函数创建了一个方便的统计模块。有趣的是，`corr()` 函数不能轻易地简化为一个单一的表达式。（它可以简化为一个非常长的单一表达式，但阅读起来会非常困难。）在这个函数实现中的每个内部变量只使用一次。这表明
    `corr()` 函数具有函数式设计，尽管它被写成六行独立的 Python 代码。
- en: 4.5 Using zip() to structure and flatten sequences
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 使用 zip() 结构化和展平序列
- en: The `zip()` function interleaves values from several iterators or sequences.
    It will create n tuples from the values in each of the n input iterables or sequences.
    We used it in the previous section to interleave data points from two sets of
    samples, creating two-tuples.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数将来自几个迭代器或序列的值交织在一起。它将从每个 n 个输入迭代器或序列中的值创建 n 个元组。我们在上一节中使用它来交织两组样本的数据点，创建成对的元组。'
- en: The `zip()` function is a generator. It does not materialize a resulting collection.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数是一个生成器。它不会实际生成一个结果集合。'
- en: 'The following is an example of code that shows what the `zip()` function does:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个展示 `zip()` 函数如何工作的代码示例：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are a number of edge cases for the `zip()` function. We must ask the
    following questions about its behavior:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 函数有一些边缘情况。我们必须询问以下关于其行为的问题：'
- en: What happens where then are no arguments at all?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有任何参数时会发生什么？
- en: What happens where there’s only one argument?
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当只有一个参数时会发生什么？
- en: What happens when the sequences are different lengths?
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当序列长度不同时会发生什么？
- en: As with other functions, such as `any()`, `all()`, `len()`, and `sum()`, we
    want an identity value as a result when applying the reduction to an empty sequence.
    For example, `sum(())` should be zero. This concept tells us what the identity
    value for `zip()` should be.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他函数一样，例如 `any()`、`all()`、`len()` 和 `sum()`，当我们对空序列应用归约时，我们希望得到一个身份值作为结果。例如，`sum(())`
    应该是零。这个概念告诉我们 `zip()` 的身份值应该是什么。
- en: 'Clearly, each of these edge cases must produce some kind of iterable output.
    Here are some examples of code that clarify the behaviors. First, the empty argument
    list:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些边缘情况必须产生某种可迭代输出。以下是一些澄清行为的代码示例。首先，空参数列表：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The production of an empty list fits with the idea of a list identity value
    of `[]`. Next, we’ll try a single iterable:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表的生产符合列表身份值 `[]` 的概念。接下来，我们将尝试一个单一的迭代器：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, the `zip()` function emitted one tuple from each input value.
    This, too, makes considerable sense.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`zip()` 函数从每个输入值中发出一个元组。这也很有道理。
- en: 'Finally, we’ll look at the different-length list approach used by the `zip()`
    function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨 `zip()` 函数使用的不同长度的列表方法：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This result is debatable. Why truncate the longer list? Why not pad the shorter
    list with `None` values? This alternate definition of the `zip()` function is
    available in the `itertools` module as the `zip_longest()` function. We’ll look
    at this in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是有争议的。为什么截断较长的列表？为什么不使用 `None` 值填充较短的列表？这个 `zip()` 函数的替代定义在 `itertools`
    模块中作为 `zip_longest()` 函数可用。我们将在第 8 章[《迭代工具模块》](Chapter_08.xhtml#x1-1700008)中探讨这个问题。
- en: 4.5.1 Unzipping a zipped sequence
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1 解包 zipped 序列
- en: We can use `zip()` to create a sequence of tuples. We also need to look at several
    ways to unzip a collection of tuples into separate collections.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `zip()` 函数来创建一系列元组。我们还需要查看几种将一系列元组解包到单独集合中的方法。
- en: We can’t fully unzip an iterable of tuples, since we might want to make multiple
    passes over the data. Depending on our needs, we may need to materialize the iterable
    to extract multiple values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能完全解包一个元组可迭代对象，因为我们可能想要多次遍历数据。根据我们的需求，我们可能需要将可迭代对象实体化以提取多个值。
- en: 'The first way to unzip tuples is something we’ve seen many times: we can use
    a generator function to unzip a sequence of tuples. For example, assume that the
    following pairs are a sequence object with two-tuples:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 解包元组的第一种方法是我们多次见过的：我们可以使用生成器函数来解包一系列元组。例如，假设以下对是一个包含两元组的序列对象：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This snippet created two sequences. The `p0` sequence has the first element
    of each two-tuple; the `p1` sequence has the second element of each two-tuple.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段创建了两个序列。`p0` 序列包含每个两元组的第一个元素；`p1` 序列包含每个两元组的第二个元素。
- en: 'Under some circumstances, we can use the multiple assignment of a `for` statement
    to decompose the tuples. The following is an example that computes the sum of
    the products:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用 `for` 语句的多重赋值来分解元组。以下是一个计算乘积之和的例子：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We used the `for` statement to decompose each two-tuple into `p0` and `p1`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `for` 语句来分解每个两元组到 `p0` 和 `p1`。
- en: 4.5.2 Flattening sequences
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2 展平序列
- en: 'Sometimes, we’ll have zipped data that needs to be flattened. That is, we need
    to turn a sequence of sub-sequences into a single list. For example, our input
    could be a file that has rows of columnar data. It looks like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要展平已经 zipped 的数据。也就是说，我们需要将子序列序列转换成一个单一的列表。例如，我们的输入可能是一个包含列数据的行文件的。它看起来像这样：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can use `(line.split()`` for`` line`` in`` file)` to create a sequence from
    the lines in the source file. Each item within that sequence will be a nested
    10-item tuple from the values on a single line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `(line.split() for line in file)` 来从源文件的行中创建一个序列。该序列中的每个项目都将是从单行上的值组成的嵌套
    10 项元组。
- en: 'This creates data in blocks of 10 values. It looks as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 10 个值的块中创建数据。它看起来如下：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is a start, but it isn’t complete. We want to get the numbers into a single,
    flat sequence. Each item in the input is a 10-tuple; we’d rather not deal with
    decomposing this one item at a time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开始，但并不完整。我们希望将数字放入一个单一的、扁平的序列中。输入中的每个项目都是一个 10 元组；我们宁愿一次也不分解这个项目。
- en: 'We can use a two-level generator expression, as shown in the following code
    snippet, for this kind of flattening:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两层生成器表达式，如以下代码片段所示，来进行这种展平：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first `for` clause assigns each item—a list of 10 values—from the blocked
    list to the line variable. The second `for` clause assigns each individual string
    from the line variable to the `x` variable. The final generator is this sequence
    of values assigned to the `x` variable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环将阻塞列表中的每个项目——一个包含10个值的列表——分配给`line`变量。第二个`for`循环将`line`变量中的每个单独的字符串分配给`x`变量。最后的生成器是这个分配给`x`变量的值序列。
- en: 'We can understand this via a rewrite as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下重写来理解这一点：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This transformation shows us how the generator expression works. The first `for`
    clause (`for`` line`` in`` data`) steps through each 10-tuple in the data. The
    second `for` clause (`for`` x`` in`` line`) steps through each item in the first
    `for` clause.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换显示了生成器表达式的工作原理。第一个`for`循环（`for line in data`）遍历数据中的每个10元组。第二个`for`循环（`for
    x in line`）遍历第一个`for`循环中的每个项目。
- en: This expression flattens a sequence-of-sequence structure into a single sequence.
    More generally, it flattens any iterable that contains iterables into a single,
    flat iterable. It will work for list-of-list as well as list-of-set or any other
    combination of nested iterables.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将序列序列结构扁平化为单个序列。更普遍地说，它将任何包含可迭代对象的可迭代对象扁平化为单个扁平可迭代对象。它适用于列表中的列表，以及列表中的集合或其他任何嵌套可迭代对象的组合。
- en: 4.5.3 Structuring flat sequences
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.3 结构化扁平序列
- en: Sometimes, we’ll have raw data that is a flat list of values that we’d like
    to bunch up into subgroups. In the [Pairing up items from a sequence](#x1-790003)
    section earlier in this chapter, we looked at overlapping pairs. In this section,
    we’re looking at non-overlapping pairs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有原始数据，它是一个我们希望将其组合成子组的扁平值列表。在本章前面的[从序列中配对项目](#x1-790003)部分，我们查看重叠对。在本节中，我们查看非重叠对。
- en: One approach is to use the `itertools` module’s `groupby()` function to implement
    this. This will have to wait until [Chapter 8](Chapter_08.xhtml#x1-1700008), [The
    Itertools Module](Chapter_08.xhtml#x1-1700008).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用`itertools`模块的`groupby()`函数来实现这一点。这需要等到[第8章](Chapter_08.xhtml#x1-1700008)，[迭代器模块](Chapter_08.xhtml#x1-1700008)。
- en: 'Let’s say we have a flat list, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个扁平列表，如下所示：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can write nested generator functions to build a sequence-of-sequence structure
    from flat data. To do this, we’ll need a single iterator that we can use multiple
    times. The expression looks like the following code snippet:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写嵌套生成器函数，从扁平数据构建序列序列结构。为此，我们需要一个可以多次使用的单个迭代器。表达式看起来像以下代码片段：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we create an iterator that exists outside either of the two loops that
    we’ll use to create our sequence-of-sequences. The generator expression uses `tuple``(``next``(``flat_iter``)``for`
    `i` `in` `range``(5)``)` to create five-item tuples from the iterable values in
    the `flat_iter` variable. This expression is nested inside another generator that
    repeats the inner loop the proper number of times to create the required sequence
    of values.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个迭代器，它存在于我们用来创建序列序列的两个循环之外的任何地方。生成器表达式使用`tuple(next(flat_iter) for i
    in range(5))`从`flat_iter`变量中的可迭代值创建五个元素的元组。这个表达式嵌套在另一个生成器中，该生成器重复内部循环适当的次数以创建所需的值序列。
- en: This works only when the flat list is divided evenly. If the last row has partial
    elements, we’ll need to process them separately.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在扁平列表均匀分割时才有效。如果最后一行有部分元素，我们需要单独处理它们。
- en: 'We can use this kind of function to group data into same-sized tuples, with
    an odd-sized tuple at the end, using the following definitions:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种类型的函数将数据分组为相同大小的元组，末尾有一个奇数大小的元组，使用以下定义：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Within the `group_by_seq()` function, an initial list is built and assigned
    to the variable `full_sized_items`. Each tuple in this list is of size `n`. If
    there are leftovers, the trailing items are used to build a tuple with a non-zero
    length that we can append to the list of full-sized items. If the `trailer` tuple
    is of the length zero, it can be safely ignored.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在`group_by_seq()`函数中，构建一个初始列表并分配给变量`full_sized_items`。这个列表中的每个元组大小为`n`。如果有剩余项，则使用尾随项构建一个非零长度的元组，并将其追加到完整大小的项目列表中。如果`trailer`元组长度为零，则可以安全忽略。
- en: The type hints include a generic definition of `ItemType` as a type variable.
    The intent of a type variable is to show that whatever type is an input to this
    function will be returned from the function. A sequence of strings or a sequence
    of floats would both work properly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示包括对 `ItemType` 的泛型定义，作为一个类型变量。类型变量的意图是表明无论什么类型的输入传递给这个函数，都会从这个函数返回。字符串序列或浮点数序列都可以正常工作。
- en: The input is summarized as a `Sequence` of items. The output is a `List` of
    tuples of items. The items are all of a common type, described with the `ItemType`
    type variable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输入被总结为一个包含项目的 `Sequence`。输出是一个包含项目元组的 `List`。所有项目都是同一种类型，用 `ItemType` 类型变量描述。
- en: This isn’t as delightfully simple and functional-looking as other algorithms
    we’ve looked at. We can rework this into a simpler generator function that yields
    an iterable instead of a list.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像我们之前看到的其他算法那样简单和功能性强。我们可以将其重构为一个更简单的生成器函数，该函数产生一个可迭代对象而不是列表。
- en: 'The following code uses a `while` statement as part of tail recursion optimization:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `while` 语句作为尾部递归优化的部分：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’ve created a row of the required length from the input iterable. At the end
    of the input iterable, the value of `tuple(next(iterable)`` for`` i`` in`` range(n))`
    will be a zero-length tuple. This can be the base case of a recursive definition.
    This was manually optimized into the terminating condition of the `while` statement.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从输入的可迭代对象中创建了一个所需长度的行。在输入可迭代对象的末尾，`tuple(next(iterable) for i in range(n))`
    的值将是一个空元组。这可以是递归定义的基本情况。这被手动优化为 `while` 语句的终止条件。
- en: The walrus operator, `:=`, is used to assign the result of the expression `tuple(group(n,`` iterable))`
    to a variable, `row`. If this is a non-empty tuple, it will be the output from
    the `yield` statement. If this is an empty tuple, the loop will terminate.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 狐狸操作符 `:=` 用于将 `tuple(group(n, iterable))` 表达式的结果赋值给变量 `row`。如果这是一个非空元组，它将是
    `yield` 语句的输出。如果这是一个空元组，循环将终止。
- en: 'The type hints have been modified to reflect the way this works with an iterator.
    These iteration processing techniques are not limited to sequences. Because the
    internal `group()` function uses `next()` explicitly, it has to be used like this:
    `group_by_iter(7,`` iter(flat))`. The `iter()` function must be used to create
    an iterator from a collection.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示已被修改以反映这种方式与迭代器的结合。这些迭代处理技术不仅限于序列。因为内部 `group()` 函数明确使用 `next()`，所以必须像这样使用：`group_by_iter(7,
    iter(flat))`。必须使用 `iter()` 函数从集合中创建迭代器。
- en: We can, as an alternative, use the `iter()` function inside the `group()` function.
    When presented with a collection, this will create a fresh, new iterator. When
    presented with an iterator, it will do nothing. This makes the function easier
    to use.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以作为一个替代方案，在 `group()` 函数内部使用 `iter()` 函数。当提供一个集合时，这将创建一个全新的迭代器。当提供一个迭代器时，它将不执行任何操作。这使得函数更容易使用。
- en: 4.5.4 Structuring flat sequences – an alternative approach
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.4 结构化扁平序列 - 一种替代方法
- en: 'Let’s say we have a simple, flat list and we want to create non-overlapping
    pairs from this list. The following is the data we have:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的扁平列表，并希望从这个列表中创建非重叠的成对。以下是我们的数据：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can create pairs using list slices, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表切片来创建成对，如下所示：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The slice `flat[0::2]` is all of the even positions. The slice `flat[1::2]`
    is all of the odd positions. If we zip these together, we get a two-tuple. The
    item at index `[0]` is the value from the first even position, and then the item
    at index `[1]` is the value from the first odd position. If the number of elements
    is even, this will produce pairs nicely. If the total number of items is odd,
    the final item will be dropped. This is a problem with a handy solution.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 切片 `flat[0::2]` 包含所有偶数位置。切片 `flat[1::2]` 包含所有奇数位置。如果我们将这些一起压缩，我们将得到一个二元组。索引
    `[0]` 的项目是第一个偶数位置的价值，然后索引 `[1]` 的项目是第一个奇数位置的价值。如果元素的数量是偶数，这将产生很好的成对。如果项目总数是奇数，最后一个项目将被丢弃。这是一个有便捷解决方案的问题。
- en: The `list(zip(...))` expression has the advantage of being quite short. We can
    follow the approach in the previous section and define our own functions to solve
    the same problem.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(zip(...))` 表达式具有相当简洁的优点。我们可以遵循上一节中的方法，并定义我们自己的函数来解决相同的问题。'
- en: 'We can also build a solution using Python’s built-in features. Specifically,
    the `*(args)` approach to generate a sequence-of-sequences that must be zipped
    together. It looks like the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用Python的内置功能构建一个解决方案。具体来说，是使用`*(args)`方法来生成必须一起zipped的序列-of-sequences。它看起来像以下这样：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will generate n slices: `flat[0::n],`` flat[1::n],`` flat[2::n]`, and
    so on, and `flat[n-1::n]`. This collection of slices becomes the arguments to
    `zip()`, which then interleaves values from each slice.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成n个切片：`flat[0::n], flat[1::n], flat[2::n]，以此类推，以及`flat[n-1::n]`。这个切片集合成为`zip()`函数的参数，然后它将每个切片中的值交错排列。
- en: Recall that `zip()` truncates the sequence at the shortest list. This means
    that if the list is not an even multiple of the grouping factor, `n`, items will
    be dropped. When the list’s length, `len(flat)`, isn’t a multiple of n, we’ll
    see `len(flat)`` %`` n` is not zero; this will be the size of the final slice.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`zip()`会在最短列表处截断序列。这意味着如果列表不是分组因子`n`的偶数倍，则将丢弃`n`个项。当列表的长度`len(flat)`不是`n`的倍数时，我们会看到`len(flat)
    % n`不为零；这将最终切片的大小。
- en: If we switch to using the `itertools.zip_longest()` function, then we’ll see
    that the final tuple will be padded with enough `None` values to make it have
    a length of `n`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到使用`itertools.zip_longest()`函数，那么我们会看到最终的元组将用足够的`None`值填充，使其长度为`n`。
- en: We have two approaches to structuring a list into groups. We need to select
    the approach based on what will be done if the length of the list is not a multiple
    of the group size. We can use `zip()` to truncate or `zip_longest()` to add a
    ”padding” constant to make the final group the expected size.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来将列表结构化为组。我们需要根据如果列表长度不是组大小的话将采取什么措施来选择方法。我们可以使用`zip()`来截断，或者使用`zip_longest()`来添加一个“填充”常数，使最终组达到期望的大小。
- en: The list slicing approach to grouping data is another way to approach the problem
    of structuring a flat sequence of data into blocks. As it is a general solution,
    it doesn’t seem to offer too many advantages over the functions in the previous
    section. As a solution specialized for making two-tuples from a flat list, it’s
    elegantly simple.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表切片方法用于分组数据是解决将扁平数据序列结构化成块的问题的另一种方法。由于它是一个通用解决方案，它似乎不提供太多比上一节中的函数更多的优势。作为一个专门用于从扁平列表中制作双元组的解决方案，它简单而优雅。
- en: 4.6 Using sorted() and reversed() to change the order
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6 使用sorted()和reversed()来改变顺序
- en: Python’s `sorted()` function produces a new list by rearranging the order of
    items in a list. This is similar to the way the `list.sort()` method changes the
    order of list.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`sorted()`函数通过重新排列列表中项的顺序来创建一个新的列表。这与`list.sort()`方法改变列表顺序的方式相似。
- en: 'Here’s the important distinction between `sorted(aList)` and `aList.sort()`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`sorted(aList)`和`aList.sort()`之间的重要区别：
- en: The `aList.sort()` method modifies the `aList` object. It can only be meaningfully
    applied to a `list` object.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aList.sort()`方法修改了`aList`对象。它只能有意义的应用于`list`对象。'
- en: The `sorted(aList)` function creates a new list from an existing collection
    of items. The source object is not changed. Further, a variety of collections
    can be sorted. A `set` or the keys of a `dict` can be put into order.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted(aList)`函数从一个现有的项目集合中创建一个新的列表。源对象不会被改变。此外，各种集合都可以排序。一个`set`或一个`dict`的键可以按顺序排列。'
- en: 'There are times when we need a sequence reversed. Python offers us two approaches
    to this: the `reversed()` function, and slices with reversed indices.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要一个反转的序列。Python为我们提供了两种方法来实现这一点：`reversed()`函数和带有反转索引的切片。
- en: 'For example, consider performing a base conversion to hexadecimal or binary.
    The following code is a simple conversion function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑执行基转换到十六进制或二进制。以下是一个简单的转换函数：
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This function uses a recursion to yield the digits from the least significant
    to the most significant. The value of `x`` %`` base` will be the least significant
    digits of `x` in the base `base`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用递归从最低有效位到最高有效位生成数字。`x % base`将是`x`在基`base`中的最低有效位。
- en: 'We can formalize it as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其形式化为以下内容：
- en: '![ (| {[] if x = 0 digits(x,b) = | x ([x mod b]+ digits(⌊b⌋,b) if x > 0 ](img/file44.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![ (| {[] if x = 0 digits(x,b) = | x ([x mod b]+ digits(⌊b⌋,b) if x > 0 ](img/file44.jpg)'
- en: In Python, we can use a long name like `base`. This is uncommon in conventional
    mathematics, so a single letter, b, is used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用像`base`这样的长名称。这在传统数学中是不常见的，所以通常使用单个字母，如b。
- en: 'In some cases, we’d prefer the digits to be yielded in the reverse order; most
    significant first. We can wrap this function with the `reversed()` function to
    swap the order of the digits:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望数字以相反的顺序产生；最重要的数字先产生。我们可以用 `reversed()` 函数包装这个函数来交换数字的顺序：
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `reversed()` function produces an iterable, but the argument value must
    be a collection object. The function then yields the items from that object in
    the reverse order. While a dictionary can be reversed, the operation is an iterator
    over the keys of the dictionary.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()` 函数产生一个可迭代对象，但参数值必须是一个集合对象。然后该函数以相反的顺序从这个对象中产生项目。虽然字典可以被反转，但这个操作是字典键的迭代器。'
- en: We can do a similar kind of thing with a slice, such as `tuple(digits(x,`` base))[::-1]`.
    The slice, however, is not an iterator. A slice is a materialized object built
    from another materialized object. In this case, for such small collections of
    values, the allocation of extra memory for the slice is minor. As the `reversed()`
    function uses less memory than creating slices, it can be advantageous for working
    with larger collections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方法使用切片，例如 `tuple(digits(x, base))[::-1]`。然而，切片不是一个迭代器。切片是由另一个已存在的对象构建的实体化对象。在这种情况下，对于如此小的值集合，为切片分配额外的内存是微不足道的。由于
    `reversed()` 函数使用的内存比创建切片少，因此在处理更大的集合时可能更有优势。
- en: The ”Martian Smiley”, `[:]`, is an edge case for slicing. The expression `some_list[:]`
    is a copy of the list made by taking a slice that includes all the items in order.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: “火星笑脸”，`[:]`，是切片的一个边缘情况。表达式 `some_list[:]` 是通过取一个包含所有项目的切片来制作的列表的副本。
- en: 4.7 Using enumerate() to include a sequence number
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7 使用 enumerate() 包含序列号
- en: Python offers the `enumerate()` function to apply index information to values
    in a sequence or iterable. It performs a specialized kind of wrap that can be
    used as part of an `unwrap(process(wrap(data)))` design pattern.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `enumerate()` 函数，可以将索引信息应用于序列或可迭代对象中的值。它执行一种特殊的包装，可以用作 `unwrap(process(wrap(data)))`
    设计模式的一部分。
- en: 'It looks like the following code snippet:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段看起来如下：
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `enumerate()` function transformed each input item into a pair with a sequence
    number and the original item. It’s similar to the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数将每个输入项转换成一个包含序列号和原始项的配对。它类似于以下内容：'
- en: '[PRE57]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: An important feature of `enumerate()` is that the result is an iterable and
    it works with any iterable input.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 的一个重要特性是结果是可迭代的，并且它与任何可迭代的输入一起工作。'
- en: When looking at statistical processing, for example, the `enumerate()` function
    comes in handy to transform a single sequence of values into a more proper time
    series by prefixing each sample with a number.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看统计处理时，例如，`enumerate()` 函数在将单个值序列转换为一个更合适的时间序列时很有用，通过在每个样本前加上一个数字。
- en: 4.8 Summary
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8 摘要
- en: In this chapter, we saw detailed ways to use a number of built-in reductions.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了使用许多内置归约的详细方法。
- en: We’ve used `any()` and `all()` to do essential logic processing. These are tidy
    examples of reductions using a simple operator, such as `or` or `and`. We’ve also
    looked at numeric reductions such as `len()` and `sum()`. We’ve applied these
    functions to create some higher-order statistical processing. We’ll return to
    these reductions in [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions and
    Reductions](Chapter_06.xhtml#x1-1260006).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `any()` 和 `all()` 来进行基本的逻辑处理。这些是使用简单运算符（如 `or` 或 `and`）进行归约的整洁示例。我们还查看了一些数值归约，如
    `len()` 和 `sum()`。我们将这些函数应用于创建一些高级统计处理。我们将在[第 6 章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)中回到这些归约。
- en: We’ve also looked at some of the built-in mappings. The `zip()` function merges
    multiple sequences. This leads us to look at using this in the context of structuring
    and flattening more complex data structures. As we’ll see in examples in later
    chapters, nested data is helpful in some situations and flat data is helpful in
    others. The `enumerate()` function maps an iterable to a sequence of two-tuples.
    Each two-tuple has the sequence number at index `[0]` and the original value at
    index `[1]`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一些内置映射。`zip()` 函数合并多个序列。这使我们开始考虑在结构化和展平更复杂的数据结构时使用它。正如我们将在后续章节的示例中看到的那样，嵌套数据在某些情况下很有帮助，而扁平数据在其他情况下很有帮助。`enumerate()`
    函数将可迭代对象映射到一系列二元组。每个二元组在索引 `[0]` 处有序列号，在索引 `[1]` 处有原始值。
- en: The `reversed()` function iterates over the items in a sequence object, with
    their original order reversed. Some algorithms are more efficient at producing
    results in one order, but we’d like to present these results in the opposite order.
    The `sorted()` function imposes an order either based on the direct comparisons
    of objects, or by using a key function to compare a derived value of each object.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数遍历序列对象中的项，并反转它们的原始顺序。某些算法在产生结果时更有效率，但我们希望以相反的顺序展示这些结果。`sorted()`函数基于对象的直接比较或使用键函数来比较每个对象的导出值来指定顺序。'
- en: In the next chapter, we’ll look at the mapping and reduction functions that
    use an additional function as an argument to customize their processing. Functions
    that accept a function as an argument are our first examples of higher-order functions.
    We’ll also touch on functions that return functions as a result.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用附加函数作为参数来自定义其处理的映射和归约函数。接受函数作为参数的函数是我们更高阶函数的第一个例子。我们还将简要介绍返回函数作为结果的函数。
- en: 4.9 Exercises
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包括一些练习的部分解决方案。这些作为提示，允许读者探索其他解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中提供的单元测试用例相同。读者应将书中的示例函数名替换为自己的解决方案以确认其有效性。
- en: 4.9.1 Palindromic numbers
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.1 回文数
- en: See Project Euler problem number 4, [https://projecteuler.net/problem=4](https://projecteuler.net/problem=4).
    The idea here is to locate a number that has a specific property. In this exercise,
    we want to look at the question of a number being (or not being) a palindrome.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Project Euler问题编号4，[https://projecteuler.net/problem=4](https://projecteuler.net/problem=4)。这里的想法是找到一个具有特定属性的数字。在这个练习中，我们想要探讨一个数字是否是（或不是）回文数。
- en: One way to handle this is to decompose a number into a sequence of decimal digits.
    We can then examine the sequence of decimal digits to see if it forms a proper
    palindrome.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是将数字分解为一系列十进制数字。然后我们可以检查这些十进制数字序列是否构成一个正确的回文。
- en: See the [Using sorted() and reversed() to change the order](#x1-910006) section
    for a snippet of code to extract digits in base 10 from a given number. Do we
    need the digits in the conventional order of most-significant digits first? Does
    it matter if the digits are generated in reverse order?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[使用sorted()和reversed()改变顺序](#x1-910006)部分，以获取从给定数字中提取十进制数字的代码片段。我们需要按照最显著数字在前的传统顺序来排列这些数字吗？如果生成的数字是反向顺序的，这有关系吗？
- en: 'We can leverage this function in two separate ways to check for a palindrome:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式利用这个函数来检查回文：
- en: Compare positions within a sequence of digits, `d[0]`` ==`` d[-1]`. We only
    need to compare the first half of the digits with the second half. Be sure your
    algorithm handles an odd number of digits correctly.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较数字序列中的位置，`d[0] == d[-1]`。我们只需要比较数字的前半部分与后半部分。确保你的算法正确处理奇数个数字。
- en: Use `reversed()` to create a second sequence of digits and compare the two sequences.
    This is waste of time and memory, but may be easier to understand.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reversed()`创建第二个数字序列并比较这两个序列。这会浪费时间和内存，但可能更容易理解。
- en: Implement both alternatives and compare the resulting code for clarity and expressiveness.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这两种替代方案，并比较产生的代码的清晰度和表达性。
- en: 4.9.2 Hands of cards
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.2 牌手的双手
- en: 'Given five cards, there are a number of ways the five cards form groups. The
    full set of hands for a game like poker is fairly complex. A simplified set of
    hands, however, provides a tool for establishing whether data is random or not.
    Here are the hand types we are interested in:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 给定五张牌，有几种方式可以将这五张牌分成组。像扑克这样的游戏的完整牌组相当复杂。然而，一个简化的牌组提供了一种判断数据是否随机的工具。以下是我们要关注的牌型：
- en: All five cards match.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有五张牌都匹配。
- en: Four of the five cards match.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 五张牌中有四张匹配。
- en: Three of the five cards match. Unlike poker, we’ll ignore whether or not the
    other two cards match.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 五张牌中有三张匹配。与扑克不同，我们将忽略其他两张牌是否匹配。
- en: There are two separate matching pairs.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个独立的匹配对。
- en: Two cards match, forming a single pair.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两张牌匹配，形成一个单一的对。
- en: No cards match.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有牌匹配。
- en: For truly random data, the probabilities can be computed with some clever math.
    A good random number generator allows us to build a simulation that provides expected
    values.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正随机的数据，可以使用一些巧妙的数学计算概率。一个好的随机数生成器允许我们构建一个提供期望值的模拟。
- en: To get started, we need a function to distinguish which flavor of hand is represented
    by five random values in the domain 1 to 13 (inclusive). The input is a list of
    five values. The output should be a numeric code for which of the six kinds of
    hands has been found.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一个函数来区分在 1 到 13（包含）的域中由五个随机值表示的手牌类型。输入是一个包含五个值的列表。输出应该是找到一个六种手牌中哪一种的数值代码。
- en: 'The broad outline of this function is the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的大致轮廓如下：
- en: '![Algorithm 4: Imperative iteration ](img/Algo_4.1.JPG)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![算法 4：命令式迭代](img/Algo_4.1.JPG)'
- en: 'Hint: For the more general poker-hand identification, it can help to sort the
    values into ascending order. For this simplified algorithm, it helps to convert
    the list into a `Counter` object and examine the frequencies of the various card
    ranks. The `Counter` class is defined in the `collections` module with many other
    useful collection classes.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：对于更通用的扑克手牌识别，将数值排序成升序可能会有所帮助。对于这个简化的算法，将列表转换为`Counter`对象并检查各种牌面的频率会有所帮助。`Counter`类在`collections`模块中定义，包含许多其他有用的集合类。
- en: 'Each of the hands can be recognized by a function of the form:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每种手牌都可以通过以下形式的函数来识别：
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This lets us write each individual hand-detection algorithm separately. We can
    then test them in isolation. This gives us confidence the overall hand classifier
    will work. It means you’ll need to write test cases on the individual classifiers
    to be sure they work properly.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以单独编写每个手牌检测算法。然后我们可以单独测试它们。这让我们有信心整体的手牌分类器将工作。这意味着你需要为单个分类器编写测试用例，以确保它们正常工作。
- en: 4.9.3 Replace legs() with pairwise()
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.3 用 pairwise() 替换 legs()
- en: In the [Pairing up items from a sequence](#x1-790003) section, we looked at
    the design for a `legs()` function to create pairs of legs from a sequence of
    waypoints.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在[从序列中配对项目](#x1-790003)部分，我们探讨了设计一个`legs()`函数，从一系列航点中创建腿对的方案。
- en: This function can be replaced with `itertools.pairwise()`. After making this
    change, determine which implementation is faster.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以用`itertools.pairwise()`替换。在做出这个更改后，确定哪种实现更快。
- en: 4.9.4 Expand legs() to include processing
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.4 将 legs() 扩展以包含处理
- en: In the [Pairing up items from a sequence](#x1-790003) section, we looked at
    the design for a `legs()` function to create pairs of legs from a sequence of
    waypoints.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在[从序列中配对项目](#x1-790003)部分，我们探讨了设计一个`legs()`函数，从一系列航点中创建腿对的方案。
- en: A design alternative is to incorporate a function into the processing of `legs()`
    to perform a computation on each pair that’s created.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一种设计替代方案是将一个函数纳入`legs()`的处理中，对创建的每个对进行计算。
- en: 'The function might look the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可能看起来如下：
- en: '[PRE59]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This changes the design of subsequent examples. Follow this design change through
    subsequent examples to see if this leads to simpler, easier-to-understand Python
    function definitions.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了后续示例的设计。通过后续示例中的设计变更，看看这是否会引导出更简单、更容易理解的 Python 函数定义。
- en: Join our community Discord space
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
