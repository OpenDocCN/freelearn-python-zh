- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with Collections
  prefs: []
  type: TYPE_NORMAL
- en: Python offers a number of functions that process whole collections. They can
    be applied to sequences (lists or tuples), sets, mappings, and iterable results
    of generator expressions. We’ll look at Python’s collection-processing features
    from a functional programming viewpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start out by looking at iterables and some simple functions that work
    with iterables. We’ll look at some design patterns to handle iterables and sequences
    with recursive functions as well as explicit `for` statements. We’ll look at how
    we can apply a scalar function to a collection of data with a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll show you examples of how to use the following functions
    with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any()` and `all()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len()`, `sum()`, and some higher-order statistical processing related to these
    functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip()` and some related techniques to structure and flatten lists of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted()` and `reversed()` to impose an ordering on a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first four functions can be called reductions: they reduce a collection
    to a single value. The other three functions, `zip()`, `reversed()`, and `enumerate()`,
    are mappings; they produce new collections from existing collections. In the next
    chapter, we’ll look at some more mapping and reduction functions that use an additional
    function as an argument to customize their processing.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll start by looking at ways to process data using generator
    expressions. Then, we’ll apply different kinds of collection-level functions to
    show how they can simplify the syntax of iterative processing. We’ll also look
    at some different ways of restructuring data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll focus on using higher-order collection functions
    to do similar kinds of processing.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 An overview of function varieties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to distinguish between two broad species of functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar functions: These apply to individual values and compute an individual
    result. Functions such as `abs()`, `pow()`, and the entire `math` module are examples
    of scalar functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collection functions: These work with iterable collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can further subdivide these collection functions into three subspecies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reduction: This uses a function to fold values in the collection together,
    resulting in a single final value. For example, if we fold + operations into a
    sequence of integers, this will compute the sum. This can be also be called an
    aggregate function, as it produces a single aggregate value for an input collection.
    Functions like `sum()` and `len()` are examples of reducing a collection to a
    single value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mapping: This applies a scalar function to each individual item of a collection;
    the result is a collection of the same size. The built-in `map()` function does
    this; a function like `enumerate()` can be seen as a mapping from items to pairs
    of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filter: This applies a scalar function to all items of a collection to reject
    some items and pass others. The result is a subset of the input. The built-in
    `filter()` function does this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some functions, for example, `sorted()` and `reversed()`, don’t fit this framework
    in a simple, tidy way. Because these two ”reordering” functions don’t compute
    new values from existing values, it seems sensible to set them off to one side.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this conceptual framework to characterize ways in which we use the
    built-in collection functions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Working with iterables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in the previous chapters, Python’s `for` statement works with iterables,
    including Python’s rich variety of collections. When working with materialized
    collections such as tuples, lists, maps, and sets, the `for` statement involves
    the explicit management of state.
  prefs: []
  type: TYPE_NORMAL
- en: While this strays from purely functional programming, it reflects a necessary
    optimization for Python. The state management is localized to an iterator object
    that’s created as a part of the `for` statement evaluation; we can leverage this
    feature without straying too far from pure, functional programming. If, for example,
    we use the `for` statement’s variable outside the indented body of the statement,
    we’ve strayed from purely functional programming by leveraging this state control
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to this in [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006). It’s an important topic, and we’ll
    just scratch the surface in this section with a quick example of working with
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: One common application of iterable processing with the `for` statement is the
    `unwrap(process(wrap(iterable)))` design pattern. A `wrap()` function will first
    transform each item of an iterable into a two-tuple with a derived sort key and
    the original item. We can then process these two-tuple items as a single, wrapped
    value. Finally, we’ll use an `unwrap()` function to discard the value used to
    wrap, which recovers the original item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens so often in a functional context that two functions are used heavily
    for this; they are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These two functions pick the first and second values from a two-tuple, and both
    are handy for the `process()` and `unwrap()` phases of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: Another common pattern is `wrap3(wrap2(wrap1()))`. In this case, we’re starting
    with simple tuples and then wrapping them with additional results to build up
    larger and more complex tuples. We looked at an example in [Chapter 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002), in the
    [Immutable data](Chapter_02.xhtml#x1-380002) section. A common variation on this
    theme builds new, more complex named tuple instances from source objects. We might
    call this the Accretion design pattern—an item that accretes derived values.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider using the Accretion pattern to work with a simple sequence
    of latitude and longitude values. The first step will convert the simple point
    represented as a `(lat,`` lon)` pair on a path into pairs of legs `(begin,`` end)`.
    Each pair in the result will be represented as `((lat,`` lon),`` (lat,`` lon))`.
    The value of `fst(item)` is the starting position; the value of `snd(item)` is
    the ending position for each value of each item in the collection. We’ll expose
    this design through a series of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections, we’ll show you how to create a generator function that
    will iterate over the content of a source file. This iterable will contain the
    raw input data that we will process. Once we have the raw data, later sections
    will show how to decorate each leg with the haversine distance along the leg.
    The final result of a `wrap(wrap(iterable()))` design will be a sequence of three
    tuples: `((lat,`` lon),`` (lat,`` lon),`` distance)`. We can then analyze the
    results for the longest and shortest distance, bounding rectangle, and other summaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The haversine formula is long-ish, but computes the distance along the surface
    of a sphere between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ --------------------------------------------- (ϕ − ϕ ) ( λ − λ ) a = sin2
    --1---2 + cos(ϕ1)cos(ϕ2)sin2 -1----2 2 2 ](img/file34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![d = R × 2 arcsin(a) ](img/file35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first part, a, is the angle between the two points. The distance, d, is
    computed from the angle, using the radius of the sphere, R, in the desired units.
    For a distance in nautical miles, we can use R = ![360×60- 2×π](img/file36.jpg)
    ≈ 3437.7\. For a distance in kilometers, we can use R = 6371\.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Parsing an XML file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by parsing an Extensible Markup Language (XML) file to get the raw
    latitude and longitude pairs. This will show you how we can encapsulate some not-quite-functional
    features of Python to create an iterable sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make use of the `xml.etree` module. After parsing, the resulting `ElementTree`
    object has an `iterfind()` method that will iterate through the available values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be looking for constructs such as the following XML example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The file will have a number of `<Placemark>` tags, each of which has a point
    and coordinate structure within it. The coordinate tag’s values are East-West
    longitude, North-South latitude, and altitude above mean sea level. This means
    there are two tiers of parsing: the XML tier, and then the details of each coordinate.
    This is typical of Keyhole Markup Language (KML) files that contain geographic
    information. (For more information, see [https://developers.google.com/kml/documentation](https://developers.google.com/kml/documentation).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting data from an XML file can be approached at two levels of abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: At the lower level, we need to locate the various tags, attribute values, and
    content within the XML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a higher level, we want to make useful objects out of the text and attribute
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lower-level processing can be approached in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function requires text; generally this will come from a file opened via
    a `with` statement. The result of this function is a generator that creates list
    objects from the latitude/longitude pairs. As a part of the XML processing, this
    function uses a simple static `dict` object, `ns_map`, that provides the namespace
    mapping information for the XML tags being parsed. This dictionary will be used
    by the `ElementTree.iterfind()` method to locate only the `<coordinates>` tags
    in the XML source document.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of the parsing is a generator function that uses the sequence of
    tags located by `doc.iterfind()`. This sequence of tags is then processed by a
    `comma_split()` function to tease the text value into its comma-separated components.
  prefs: []
  type: TYPE_NORMAL
- en: The `path_to_points` object is a string that defines how to navigate through
    the XML structure. It describes the location of the `<coordinates>` tag within
    the other tags of the document. Using this path means the generator expression
    will avoid the values of other, irrelevant tags.
  prefs: []
  type: TYPE_NORMAL
- en: The `if`` text`` is`` not`` None` clause reflects the definition of the `text`
    attribute of an element tree tag. If there’s no body in the tag, the text value
    will be `None`. While it is extremely unlikely to see an empty `<coordinates/>`
    tag, the type hints require we handle this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `comma_split()` function has a more functional syntax than the the `split()`
    method of a string. This function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a wrapper to emphasize a slightly more uniform syntax. We’ve also
    added explicit type hints to make it clear that a string is converted to a list
    of `str` values. Without the type hint, there are two potential definitions of
    `split()` that could be meant. It turns out, this method applies to `bytes` as
    well as `str`. We’ve used the `str` type name to narrow the domain of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the `row_iter_kml()` function is an iterable sequence of rows
    of data. Each row will be a list composed of three strings: latitude, longitude,
    and altitude of a waypoint along this path. This isn’t directly useful yet. We’ll
    need to do some more processing to get latitude and longitude as well as converting
    these two strings into useful floating-point values.'
  prefs: []
  type: TYPE_NORMAL
- en: This idea of an iterable sequence of tuples (or lists) allows us to process
    some kinds of data files in a simple and uniform way. In [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003), we looked
    at how Comma-Separated Values (CSV) files are easily handled as rows of tuples.
    In [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions and Reductions](Chapter_06.xhtml#x1-1260006),
    we’ll revisit the parsing idea to compare these various examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the `row_iter_kml()` function can be collected by the `list()`
    function. The following interactive example will read the file and extract the
    details. The `list()` function will create a single list from each `<coordinate>`
    tag. The accumulated result object looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These are all string values. To be more useful, it’s important to apply some
    additional functions to the output of this function that will create a usable
    subset of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 Parsing a file at a higher level
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After parsing the low-level syntax to transform XML to Python, we can restructure
    the raw data into something usable in our Python program. This kind of structuring
    applies to XML, JavaScript Object Notation (JSON), CSV, YAML, TOML, and any of
    the wide variety of physical formats in which data is serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll aim to write a small suite of generator functions that transforms the
    parsed data into a form our application can use. The generator functions include
    some simple transformations on the text that are found by the `row_iter_kml()`
    function, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Discarding altitude, which can also be stated as keeping only latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the order from `(longitude,`` latitude)` to `(latitude,`` longitude)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can make these two transformations have more syntactic uniformity by defining
    a utility function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a function to take three argument values and create a tuple from
    two of them. The type hints are more complex than the function itself. The conversion
    of source data to usable data often involves selecting a subset of fields, as
    well as conversion from strings to numbers. We’ve separated the two problems because
    these aspects often evolve separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function will apply the `pick_lat_lon()` function to each row from a source
    iterator. We’ve used `*row` to assign each element of the row’s three-tuple to
    separate parameters of the `pick_lat_lon()` function. The function can then extract
    and reorder the two relevant values from each three-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the function definition, we’ve defined two type aliases: `Rows`
    and `LL_Text`. These type aliases can simplify a function definition. They can
    also be reused to ensure that several related functions are all working with the
    same types of objects. This kind of functional design allows us to freely replace
    any function with its equivalent, which makes refactoring less risky.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions can be combined to parse the file and build a structure we
    can use. Here’s an example of some code that could be used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This script uses the `request.urlopen()` function to open a source. In this
    case, it’s a local file. However, we can also open a KML file on a remote server.
    Our objective in using this kind of file opening is to ensure that our processing
    is uniform no matter what the source of the data is.
  prefs: []
  type: TYPE_NORMAL
- en: The script is built around the two functions that do low-level parsing of the
    KML source. The `row_iter_kml(source)` expression produces a sequence of text
    columns. The `lat_lon_kml()` function will extract and reorder the latitude and
    longitude values. This creates an intermediate result that sets the stage for
    further processing. The subsequent processing can be designed to be independent
    of the original format.
  prefs: []
  type: TYPE_NORMAL
- en: The final function provides the latitude and longitude values from a complex
    XML file using an almost purely functional approach. As the result is iterable,
    we can continue to use functional programming techniques to process each point
    that we retrieve from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Purists will sometimes argue that using a `for` statement introduces a non-functional
    element. To be pure, the iteration should be defined recursively. Since a recursion
    isn’t a good use of Python language features, we’ll prefer to sacrifice some purity
    for a more Pythonic approach.
  prefs: []
  type: TYPE_NORMAL
- en: This design explicitly separates low-level XML parsing from higher-level reorganization
    of the data. The XML parsing produced a generic tuple of string structure. This
    is compatible with parsers for other file formats. As one example, the result
    value is compatible with the output from the CSV parser. When working with SQL
    databases, it can help to use a similar iterable of tuple structures. This permits
    a design for higher-level processing that can work with data from a variety of
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you a series of transformations to re-arrange this data from a collection
    of strings to a collection of waypoints along a route. This will involve a number
    of transformations. We’ll need to restructure the data as well as convert from
    strings to floating-point values. We’ll also look at a few ways to simplify and
    clarify the subsequent processing steps. We’ll use this dataset in later chapters
    because it’s quite complex.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 Pairing up items from a sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common restructuring requirement is to make start-stop pairs out of points
    in a sequence. Given a sequence, S = {s[0],s[1],s[2],...,s[n]}, we would also
    want to create a paired sequence, S = {(s[0],s[1]),(s[1],s[2]),(s[2],s[3]),...,(s[n−1],s[n])}.
    The first and second items form a pair. The second and third items form the next
    pair. Note that the pairs overlap; each point (other than the first or last) will
    be the end of one pair and the start of the next pair.
  prefs: []
  type: TYPE_NORMAL
- en: These overlapping pairs are used to compute distances from point to point using
    a trivial application of a haversine function. This technique is also used to
    convert a path of points into a series of line segments in a graphics application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why pair up items? Why not insert a few additional lines of code into a function
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet will process each leg of the data as a `begin,`` end` pair.
    However, the processing function and the `for` statement to restructure the data
    are tightly bound, making reuse more complex than necessary. The algorithm for
    pairing is hard to test in isolation when it is one part of a more complex `compute_something()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a combined function also limits our ability to reconfigure the application.
    There’s no easy way to inject an alternative implementation of the `compute_something()`
    function. Additionally, we’ve got a piece of an explicit state, the `begin` variable,
    which makes life potentially complex. If we try to add features to the body of
    the `for` statement, we can easily fail to set the `begin` variable correctly
    when an item in the `iterable` source is filtered out from processing.
  prefs: []
  type: TYPE_NORMAL
- en: We achieve better reuse by separating this pairing function from other processing.
    Simplification, in the long run, is one of our goals. If we build up a library
    of helpful primitives such as this pairing function, we can tackle larger problems
    more quickly and confidently.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the `itertools` library (the subject of [Chapter 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008)) includes a `pairwise()` function
    we can also use to perform this pairing of values from a source iterator. While
    we can use this function, we’ll also look at how to design our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to pair up the points along the route to create start and
    stop information for each leg. We’ll look at a few here and then revisit this
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    and again in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008).
    Creating pairs can be done in a purely functional way using a recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ [] if |l| ≤ 1 pairs(l) = |( [(l0,l1)]+ pairs(l[1:]) if |l| > 1 ](img/file37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the mathematical formalism seems simple, it doesn’t account for the way
    item l[1] is both part of the first pair and also the head of the remaining items
    in l[[1:]].
  prefs: []
  type: TYPE_NORMAL
- en: The functional ideal is to avoid assigning this value to a variable. Variables—and
    the resulting stateful code—can turn into a problem when we try to make a ”small”
    change and misuse the variable’s value.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to somehow ”peek” at the upcoming item in the iterable source
    of data. This doesn’t work out well in Python. Once we’ve used `next()` to examine
    the value, it can’t be put back into the iterable. This makes a recursive, functional
    version of creating overlapping pairs a bit too complex to be of any real value.
  prefs: []
  type: TYPE_NORMAL
- en: Our strategy for performing tail-call optimization is to replace the recursion
    in the mathematical formalism with a `for` statement. In some cases, we can further
    optimize this into a generator expression. Because this works with an explicit
    variable to track the state of the computation, it’s a better fit for Python,
    while being less purely functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an optimized version of a function to pair up the points
    along a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The version is simpler, quite fast, and free from the stack limits of a recursive
    definition. It’s independent of any particular type of sequence, as it will pair
    up anything emitted by a sequence generator. As there’s no processing function
    inside the loop, we can reuse the `legs()` function as needed. We could also redesign
    this function slightly to accept a processing function as a parameter value, and
    apply the given function to each `(begin,`` end)` pair that’s created.
  prefs: []
  type: TYPE_NORMAL
- en: The type variable, `LL_Type`, is used to clarify precisely how the `legs()`
    function restructures the data. The hint says that the input type is preserved
    on output. The input type is an `Iterator` of some arbitrary type, `LL_Type`;
    the output will include tuples of the same type, `LL_Type`. No other conversion
    is implied by the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `begin` and `end` variables maintain the state of the computation. The use
    of stateful variables doesn’t fit the ideal of using immutable objects for functional
    programming. The optimization, however, is important in Python. It’s also invisible
    to users of the function, making it a Pythonic-functional hybrid.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function requires an iterable source of individual values. This
    can be an iterable collection or a generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of this function as one that yields the following kind of sequence
    of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another view of this function using the built-in `zip()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While informative, this `zip()`-based example only works for sequence objects.
    The `pairs()` function shown earlier will work for any iterable, including sequence
    objects. The `legs()` function only works for an `Iterator` object as the source
    of data. The good news is we can make an iterator object from an iterable collection
    with the built-in `iter()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.4 Using the iter() function explicitly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From a purely functional viewpoint, all of our iterables can be processed with
    recursive functions, where the state is managed by the recursive call stack. Pragmatically,
    processing iterables in Python will often involve evaluation of `for` statements.
    There are two common situations: collection objects and iterables. When working
    with a collection object, an `Iterator` object is created by the `for` statement.
    When working with a generator function, the generator function is an iterator
    and maintains its own internal state. Often, these are equivalent, from a Python
    programming perspective. In rare cases—generally those situations where we have
    to use the `next()` function explicitly—the two won’t be precisely equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: The `legs()` function shown previously has an explicit `next()` evaluation to
    get the first value from the iterable. This works wonderfully well with generator
    functions, expressions, and other iterables. It doesn’t work with sequence objects
    such as tuples or lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code contains three examples to clarify the use of the `next()`
    and `iter()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we applied the `legs()` function to an iterable. In this
    case, the iterable was a generator expression. This is the expected behavior based
    on our previous examples in this chapter. The items are properly paired up to
    create two legs from three waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we tried to apply the `legs()` function to a sequence. This
    resulted in an error. While a list object and an iterable are equivalent when
    used in a `for` statement, they aren’t equivalent everywhere. A sequence isn’t
    an iterator; a sequence doesn’t implement the `__next__()` special method allowing
    it to be used by the `next()` function. The `for` statement handles this gracefully,
    however, by creating an iterator from a sequence automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To make the second case work, we need to explicitly create an iterator from
    a list object. This permits the `legs()` function to get the first item from the
    iterator over the list items. The `iter()` function will create an iterator from
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.5 Extending an iteration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have two kinds of extensions we could factor into a `for` statement that
    processes iterable data. We’ll look first at a filter extension. In this case,
    we may be rejecting values from further consideration. They may be data outliers,
    or perhaps source data that’s improperly formatted. Then, we’ll look at mapping
    source data by performing a simple transformation to create new objects from the
    original objects. In our case, we’ll be transforming strings to floating-point
    numbers. The idea of extending a simple `for` statement with a mapping, however,
    applies to many situations. We’ll look at refactoring the above `legs()` function.
    What if we need to adjust the sequence of points to discard a value? This will
    introduce a filter extension that rejects some data values.
  prefs: []
  type: TYPE_NORMAL
- en: The iterative process we’re designing returns pairs without performing any additional
    application-related processing—the complexity is minimal. Simplicity means we’re
    somewhat less likely to confuse the processing state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a filter extension to this design could look something like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have plugged in a processing rule to reject certain values. As the `for`
    statement remains succinct and expressive, we are confident that the processing
    will be done properly. We have, on the other hand, cluttered up a relatively simple
    function with two separate collections of features. This kind of clutter is not
    an ideal approach to functional design.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t really provided much information about the `rejection_rule()` function.
    This needs to be a kind of condition that applies to a `Leg` tuple to reject the
    point from further consideration. For example, it may reject `begin`` ==`` end`
    to avoid zero-length legs. A handy default value for `rejection_rule` is `lambda`` s,`` e:`` False`.
    This will preserve all of the legs.
  prefs: []
  type: TYPE_NORMAL
- en: The next refactoring will introduce additional mapping to an iteration. Adding
    mappings is common when a design is evolving. In our case, we have a sequence
    of string values. We need to convert these to float values for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one way to handle this data mapping, through a generator expression
    that wraps a generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ve applied the `legs()` function to a generator expression that creates float
    values from the output of the `lat_lon_kml()` function. We can read this in an
    inside-out order as well. The `lat_lon_kml()` function’s output is transformed
    into a pair of float values, which is then transformed into a sequence of legs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is starting to get complex. We’ve got a large number of nested functions
    here. We’re applying `float()`, `legs()`, and `list()` to a data generator. One
    common way of refactoring complex expressions is to separate the generator expression
    from any materialized collection. We can do the following to simplify the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ve assigned the generator function to a variable named `ll_iter`. This variable
    isn’t a collection object; it’s a generator of item two-tuples. We’re not using
    a list comprehension to create an object. We’ve merely assigned the generator
    expression to a variable name. We’ve then used the `ll_iter` variable in a subsequent
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluation of the `list()` function actually leads to a proper object being
    built so that we can print the output. The `ll_iter` variable’s items are created
    only as needed.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another refactoring we might like to do. In general, the source
    of the data is something we often want to change. In our example, the `lat_lon_kml()`
    function is tightly bound in the rest of the expression. This makes reuse difficult
    when we have a different data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where the `float()` operation is something we’d like to parameterize
    so that we can reuse it, we can define a function around the generator expression.
    We’ll extract some of the processing into a separate function merely to group
    the operations. In our case, the string-pair to float-pair is unique to particular
    source data. We can rewrite a complex float-from-string expression into a simpler
    function, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `floats_from_pair()` function applies the `float()` function to the first
    and second values of each item in the iterable, yielding a two-tuple of floats
    created from an input value. We’ve relied on Python’s `for` statement to decompose
    the two-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints detail the transformation from an iterable sequence of `tuple[str,`` str]`
    items to `tuple[float,`` float]` items. The `LL_Iter` type alias can then be used
    elsewhere in a complex set of function definitions to show how the float pairs
    are processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function in the following context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’re going to create legs that are built from float values that come from a
    KML file. It’s fairly easy to visualize the processing, as each stage in the process
    is a prefix function. Each function’s input is the output from the next function
    in the nested processing steps. This seems like a natural way to express a pipeline
    of processing.
  prefs: []
  type: TYPE_NORMAL
- en: When parsing, we often have sequences of string values. For numeric applications,
    we’ll need to convert strings to float, int, or `Decimal` values. This often involves
    inserting a function such as the `floats_from_pair()` function into a sequence
    of expressions that clean up the source data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous output was all strings; it looked like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll want data like the following code snippet, where we have floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After building this processing pipeline, there are some simplifications available.
    We’ll look at some refactoring in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order
    Functions](Chapter_05.xhtml#x1-1000005). We will revisit this in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006), to see how to apply
    these simplifications to the file parsing problem.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.6 Applying generator expressions to scalar functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll look at a more complex kind of generator expression to map data values
    from one kind of data to another. In this case, we’ll apply a fairly complex function
    to individual data values created by a generator.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll call these non-generator functions scalar, as they work with simple atomic
    values. To work with collections of data, a scalar function will be embedded in
    a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: To continue the example started earlier, we’ll provide a haversine function
    to compute the distance between latitude and longitude values. Technically, these
    are angles, and some spherical trigonometry is required to convert angles to distances
    on the surface of the sphere. We can use a generator expression to apply a scalar
    `haversine()` function to a sequence of pairs from our KML file.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of the `haversine()` function is to compute a distance between
    two points following the proper spherical geometry of the earth. It can involve
    some tricky-looking math, but we’ve provided the whole definition here. We also
    mentioned this function at the beginning of the [Working with iterables](#x1-760002)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `haversine()` function is implemented by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The start and end points, `p1` and `p2`, have type hints to show their structure.
    The return value is also provided with a hint. The explicit use of a type alias
    for `Point` makes it possible for the mypy tool to confirm that this function
    is used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For short distances covered by coastal sailors, the equirectangular distance
    computation is more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Δ ϕ x = R × Δ λ × cos--- 2 ](img/file38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![y = R × Δϕ ](img/file39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![d = ∘x2-+-y2- ](img/file40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where R is the earth’s mean radius, R = ![360×60 --2π---](img/file41.jpg) nautical
    miles. The ϕ values are N-S latitude, and the λ values are E-W longitude. This
    means (ϕ[0],λ[0]) and (ϕ[1],λ[1]) are the two points we’re navigating between.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://edwilliams.org/avform147.htm](https://edwilliams.org/avform147.htm)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is how we could use our collection of functions to examine
    some KML data and produce a sequence of distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The essence of the processing is the generator expression assigned to the `trip`
    variable. We’ve assembled three-tuples with a start, end, and the distance from
    start to end. The start and end pairs come from the `legs()` function. The `legs()`
    function works with floating-point data built from the latitude-longitude pairs
    extracted from a KML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following command snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each individual processing step has been defined succinctly. The overview, similarly,
    can be expressed succinctly as a composition of functions and generator expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there are several further processing steps we may like to apply to
    this data. The first, of course, is to use the `format()` method of a string to
    produce better-looking output.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, there are a number of aggregate values we’d like to extract
    from this data. We’ll call these values reductions of the available data. We’d
    like to reduce the data to get the maximum and minimum latitude, for example,
    to show the extreme north and south ends of this route. We’d like to reduce the
    data to get the maximum distance in one leg as well as the total distance for
    all legs.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we’ll have using Python is that the output generator in the `trip`
    variable can be used only once. We can’t easily perform several reductions of
    this detailed data. While we can use `itertools.tee()` to work with the iterable
    several times, it takes a fair amount of memory. It can be wasteful, also, to
    read and parse the KML file for each reduction. We can make our processing more
    efficient by materializing intermediate results as a list object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at two specific kinds of reductions that compute
    a single boolean result from a collection of booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Using any() and all() as reductions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `any()` and `all()` functions provide boolean reduction capabilities. Both
    functions reduce a collection of values to a single `True` or `False`. The `all()`
    function ensures that all items have a true value; the `any()` function ensures
    that at least one item has a true value. In both cases, these functions rely on
    the Pythonic concept of ”truish”, or truthy: values for which the built-in `bool()`
    function returns `true`. Generally, ”falsish” values include `False` and `None`,
    as well as zero, an empty string, and empty collections. Non-false values are
    true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are closely related to a universal quantifier and an existential
    quantifier used to express mathematical logic. We may, for example, want to assert
    that all elements in a given collection have a property. One formalism for this
    could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![(∀x∈S)Prime (x ) ](img/file42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We read this as for all x in S, the function, Prime(x), is true. We’ve used
    the universal quantifier, for all, ∀, in front of the logical expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python we switch the order of the items slightly to transcribe the logic
    expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `all()` function will evaluate the `isprime(x)` function for each distinct
    value of `x` and reduce the collection of values to a single `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `any()` function is related to the existential quantifier. If we want to
    assert that no value in a collection is prime, we could use one of these two equivalent
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![¬ (∀ )Prime (x) ≡ (∃ )¬ Prime (x) x∈S x∈S ](img/file43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left side states that it is not the case that all elements in S are prime.
    The right side asserts that there exists one element in S that is not prime. These
    two are equivalent; that is, if not all elements are prime, then one element must
    be non-prime.
  prefs: []
  type: TYPE_NORMAL
- en: This rule of equivalence is called De Morgan’s Law. It can be stated generally
    as ∀xP(x) ≡ ¬∃x¬P(x). If some proposition, P(x), is true for all x, there is no
    x for which P(x) is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can switch the order of the terms and transcribe these to working
    code in either of these two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As these two lines are equivalent, there are two common reasons for choosing
    one over the other: performance and clarity. The performance is nearly identical,
    so it boils down to clarity. Which of these states the condition the most clearly?'
  prefs: []
  type: TYPE_NORMAL
- en: The `all()` function can be described as an and reduction of a set of values.
    The result is similar to folding the `and` operator between the given sequence
    of values. The `any()` function, similarly, can be described as an or reduction.
    We’ll return to this kind of general-purpose reducing when we look at the `reduce()`
    function in [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010).
    There’s no best answer here; it’s a question of what seems most readable to the
    intended audience.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to look at the degenerate case of these functions. What if the
    sequence has no elements? What are the values of `all(())` or `all([])`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a list, `[1,`` 2,`` 3]`. The expression `[]`` +`` [1,`` 2,`` 3]`` ==`` [1,`` 2,`` 3]`
    is true because the empty list is the identity value for list concatenation. This
    also works for the `sum(())` function: `sum([])`` +`` sum([1,`` 2,`` 3])`` ==`` sum([1,`` 2,`` 3])`.
    The sum of an empty list must be the additive identity value for addition, zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `and` identity value is `True`. This is because `True`` and`` whatever`` ==`` whatever`.
    Similarly, the `or` identity value is `False`. The following code demonstrates
    that Python follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Python gives us some very nice tools to perform processing that involves logic.
    We have the built-in `and`, `or`, and `not` operators. However, we also have these
    collection-oriented `any()` and `all()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Using len() and sum() on collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `len()` and `sum()` functions provide two simple reductions—a count of the
    elements and the sum of the elements in a sequence. These two functions are mathematically
    similar, but their Python implementation is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, we can observe this cool parallelism:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `len()` function returns the sum of ones for each value in a collection,
    X: ∑ [x∈X]1 = ∑ [x∈X]x⁰.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sum()` function returns the sum of each value in a collection, X: ∑ [x∈X]x
    = ∑ [x∈X]x¹.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sum()` function works for any iterable. The `len()` function doesn’t apply
    to iterables; it only applies to sequences. This little asymmetry in the implementation
    of these functions is a little awkward around the edges of statistical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted above, for empty sequences, both of these functions return a proper
    additive identity value of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While `sum(())` returns an integer zero, this isn’t a problem when working with
    float values. When other numeric types are used, the integer zero can be used
    along with values of the types of the available data. Python’s numeric types generally
    have rules for performing operations with values of other numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Using sums and counts for statistics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll implement a number of functions useful for statistics.
    The point is show how functional programming can be applied to the kinds of processing
    that are common in statistical functions.
  prefs: []
  type: TYPE_NORMAL
- en: Several common functions are described as ”measure of central tendency”. Functions
    like the arithmetic mean or the standard deviation provide a summary of a collection
    of values. A transformation called ”normalization” shifts and scales values around
    a population mean and standard deviation. We’ll also look at how to compute a
    coefficient of correlation to show to what extent two sets of data are related
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Readers might want to look at [https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df](https://towardsdatascience.com/descriptive-statistics-f2beeaf7a8df)
    for more information on descriptive statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arithmetic mean seems to have an appealingly trivial definition based on
    `sum()` and `len()`. It looks like the following might work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This simple-looking function doesn’t work for `Iterable` objects. This definition
    only works for collections that support the `len()` function. This is easy to
    discover when trying to write proper type annotations. The definition of `mean(items:`` Iterable[float])`` ->`` float`
    won’t work because more general `Iterable[float]` types don’t support `len()`.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we have a hard time performing a computation like standard deviation
    based on iterables. In Python, we must either materialize a sequence object or
    resort to somewhat more complex processing that computes multiple sums on a single
    pass through the data. To use simpler functions means using a `list()` to create
    a concrete sequence that can be processed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass muster with mypy, the definition needs to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This includes the appropriate type hints to ensure that `sum()` and `len()`
    will both work for the expected types of data. The mypy tool is aware of the arithmetic
    type matching rules: any value that could be treated as a float would be considered
    valid. This means that `mean([1,`` 2,`` 3])` will be accepted by the mypy tool
    in spite of the values being all integers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some alternative and elegant expressions for mean and standard deviation
    in the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These three sums, `s0`, `s1`, and `s2`, have a tidy, parallel structure. We
    can easily compute the mean from two of the sums. The standard deviation is a
    bit more complex, but it’s based on the three available sums.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pleasant symmetry also works for more complex statistical functions,
    such as correlation and even least-squares linear regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moment of correlation between two sets of samples can be computed from
    their standardized value. The following is a function to compute the standardized
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The calculation subtracts the mean, μ[x], from each sample, x, and divides it
    by the standard deviation, σ[x]. This gives us a value measured in units of sigma,
    σ. For normally-distributed data, a value ±1σ is expected about two-thirds of
    the time. More extreme values should be less common. A value outside ±3σ should
    happen less than one percent of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this scalar function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We’ve built a list that consists of normalized scores based on some raw data
    in the variable, `d`. We used a generator expression to apply the scalar function,
    `z()`, to the sequence object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mean()` and `stdev()` functions are based on the examples shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The three sum functions, similarly, can be defined as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While this is very expressive and succinct, it’s a little frustrating because
    we can’t use an iterable here. When evaluating the `mean()` function, for example,
    both a sum of the iterable and a count of the iterable are required. For the standard
    deviation, two sums and a count of the iterable are all required. For this kind
    of statistical processing, we must materialize a sequence object (in other words,
    create a `list`) so that we can examine the data multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can compute the correlation between two sets
    of samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This correlation function, `corr()`, gathers basic statistical summaries of
    the two sets of samples: the mean and standard deviation. Given these summaries,
    we define two generator functions that will create normalized values for each
    set of samples. We can then use the `zip()` function (see the next example) to
    pair up items from the two sequences of normalized values and compute the product
    of those two normalized values. The average of the product of the normalized scores
    is the correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of gathering the correlation between two sets
    of samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We’ve shown two sequences of data points, `xi` and `yi`. The correlation is
    over `0.99`, which shows a very strong relationship between the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: This shows one of the strengths of functional programming. We’ve created a handy
    statistical module using a half-dozen functions with definitions that are single
    expressions. Interestingly, the the `corr()` function can’t easily be reduced
    to a single expression. (It can be reduced to a single very long expression, but
    it would be terribly hard to read.) Each internal variable in this function’s
    implementation is used only once. This shows us that the `corr()` function has
    a functional design, even though it’s written out in six separate lines of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Using zip() to structure and flatten sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `zip()` function interleaves values from several iterators or sequences.
    It will create n tuples from the values in each of the n input iterables or sequences.
    We used it in the previous section to interleave data points from two sets of
    samples, creating two-tuples.
  prefs: []
  type: TYPE_NORMAL
- en: The `zip()` function is a generator. It does not materialize a resulting collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of code that shows what the `zip()` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of edge cases for the `zip()` function. We must ask the
    following questions about its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens where then are no arguments at all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens where there’s only one argument?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the sequences are different lengths?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other functions, such as `any()`, `all()`, `len()`, and `sum()`, we
    want an identity value as a result when applying the reduction to an empty sequence.
    For example, `sum(())` should be zero. This concept tells us what the identity
    value for `zip()` should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, each of these edge cases must produce some kind of iterable output.
    Here are some examples of code that clarify the behaviors. First, the empty argument
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The production of an empty list fits with the idea of a list identity value
    of `[]`. Next, we’ll try a single iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `zip()` function emitted one tuple from each input value.
    This, too, makes considerable sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll look at the different-length list approach used by the `zip()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This result is debatable. Why truncate the longer list? Why not pad the shorter
    list with `None` values? This alternate definition of the `zip()` function is
    available in the `itertools` module as the `zip_longest()` function. We’ll look
    at this in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008).
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Unzipping a zipped sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use `zip()` to create a sequence of tuples. We also need to look at several
    ways to unzip a collection of tuples into separate collections.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t fully unzip an iterable of tuples, since we might want to make multiple
    passes over the data. Depending on our needs, we may need to materialize the iterable
    to extract multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to unzip tuples is something we’ve seen many times: we can use
    a generator function to unzip a sequence of tuples. For example, assume that the
    following pairs are a sequence object with two-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This snippet created two sequences. The `p0` sequence has the first element
    of each two-tuple; the `p1` sequence has the second element of each two-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under some circumstances, we can use the multiple assignment of a `for` statement
    to decompose the tuples. The following is an example that computes the sum of
    the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We used the `for` statement to decompose each two-tuple into `p0` and `p1`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Flattening sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, we’ll have zipped data that needs to be flattened. That is, we need
    to turn a sequence of sub-sequences into a single list. For example, our input
    could be a file that has rows of columnar data. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can use `(line.split()`` for`` line`` in`` file)` to create a sequence from
    the lines in the source file. Each item within that sequence will be a nested
    10-item tuple from the values on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates data in blocks of 10 values. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is a start, but it isn’t complete. We want to get the numbers into a single,
    flat sequence. Each item in the input is a 10-tuple; we’d rather not deal with
    decomposing this one item at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a two-level generator expression, as shown in the following code
    snippet, for this kind of flattening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first `for` clause assigns each item—a list of 10 values—from the blocked
    list to the line variable. The second `for` clause assigns each individual string
    from the line variable to the `x` variable. The final generator is this sequence
    of values assigned to the `x` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can understand this via a rewrite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This transformation shows us how the generator expression works. The first `for`
    clause (`for`` line`` in`` data`) steps through each 10-tuple in the data. The
    second `for` clause (`for`` x`` in`` line`) steps through each item in the first
    `for` clause.
  prefs: []
  type: TYPE_NORMAL
- en: This expression flattens a sequence-of-sequence structure into a single sequence.
    More generally, it flattens any iterable that contains iterables into a single,
    flat iterable. It will work for list-of-list as well as list-of-set or any other
    combination of nested iterables.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3 Structuring flat sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, we’ll have raw data that is a flat list of values that we’d like
    to bunch up into subgroups. In the [Pairing up items from a sequence](#x1-790003)
    section earlier in this chapter, we looked at overlapping pairs. In this section,
    we’re looking at non-overlapping pairs.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to use the `itertools` module’s `groupby()` function to implement
    this. This will have to wait until [Chapter 8](Chapter_08.xhtml#x1-1700008), [The
    Itertools Module](Chapter_08.xhtml#x1-1700008).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a flat list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write nested generator functions to build a sequence-of-sequence structure
    from flat data. To do this, we’ll need a single iterator that we can use multiple
    times. The expression looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an iterator that exists outside either of the two loops that
    we’ll use to create our sequence-of-sequences. The generator expression uses `tuple``(``next``(``flat_iter``)``for`
    `i` `in` `range``(5)``)` to create five-item tuples from the iterable values in
    the `flat_iter` variable. This expression is nested inside another generator that
    repeats the inner loop the proper number of times to create the required sequence
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: This works only when the flat list is divided evenly. If the last row has partial
    elements, we’ll need to process them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this kind of function to group data into same-sized tuples, with
    an odd-sized tuple at the end, using the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Within the `group_by_seq()` function, an initial list is built and assigned
    to the variable `full_sized_items`. Each tuple in this list is of size `n`. If
    there are leftovers, the trailing items are used to build a tuple with a non-zero
    length that we can append to the list of full-sized items. If the `trailer` tuple
    is of the length zero, it can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints include a generic definition of `ItemType` as a type variable.
    The intent of a type variable is to show that whatever type is an input to this
    function will be returned from the function. A sequence of strings or a sequence
    of floats would both work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The input is summarized as a `Sequence` of items. The output is a `List` of
    tuples of items. The items are all of a common type, described with the `ItemType`
    type variable.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t as delightfully simple and functional-looking as other algorithms
    we’ve looked at. We can rework this into a simpler generator function that yields
    an iterable instead of a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses a `while` statement as part of tail recursion optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a row of the required length from the input iterable. At the end
    of the input iterable, the value of `tuple(next(iterable)`` for`` i`` in`` range(n))`
    will be a zero-length tuple. This can be the base case of a recursive definition.
    This was manually optimized into the terminating condition of the `while` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The walrus operator, `:=`, is used to assign the result of the expression `tuple(group(n,`` iterable))`
    to a variable, `row`. If this is a non-empty tuple, it will be the output from
    the `yield` statement. If this is an empty tuple, the loop will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type hints have been modified to reflect the way this works with an iterator.
    These iteration processing techniques are not limited to sequences. Because the
    internal `group()` function uses `next()` explicitly, it has to be used like this:
    `group_by_iter(7,`` iter(flat))`. The `iter()` function must be used to create
    an iterator from a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: We can, as an alternative, use the `iter()` function inside the `group()` function.
    When presented with a collection, this will create a fresh, new iterator. When
    presented with an iterator, it will do nothing. This makes the function easier
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.4 Structuring flat sequences – an alternative approach
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say we have a simple, flat list and we want to create non-overlapping
    pairs from this list. The following is the data we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create pairs using list slices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The slice `flat[0::2]` is all of the even positions. The slice `flat[1::2]`
    is all of the odd positions. If we zip these together, we get a two-tuple. The
    item at index `[0]` is the value from the first even position, and then the item
    at index `[1]` is the value from the first odd position. If the number of elements
    is even, this will produce pairs nicely. If the total number of items is odd,
    the final item will be dropped. This is a problem with a handy solution.
  prefs: []
  type: TYPE_NORMAL
- en: The `list(zip(...))` expression has the advantage of being quite short. We can
    follow the approach in the previous section and define our own functions to solve
    the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also build a solution using Python’s built-in features. Specifically,
    the `*(args)` approach to generate a sequence-of-sequences that must be zipped
    together. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate n slices: `flat[0::n],`` flat[1::n],`` flat[2::n]`, and
    so on, and `flat[n-1::n]`. This collection of slices becomes the arguments to
    `zip()`, which then interleaves values from each slice.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `zip()` truncates the sequence at the shortest list. This means
    that if the list is not an even multiple of the grouping factor, `n`, items will
    be dropped. When the list’s length, `len(flat)`, isn’t a multiple of n, we’ll
    see `len(flat)`` %`` n` is not zero; this will be the size of the final slice.
  prefs: []
  type: TYPE_NORMAL
- en: If we switch to using the `itertools.zip_longest()` function, then we’ll see
    that the final tuple will be padded with enough `None` values to make it have
    a length of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: We have two approaches to structuring a list into groups. We need to select
    the approach based on what will be done if the length of the list is not a multiple
    of the group size. We can use `zip()` to truncate or `zip_longest()` to add a
    ”padding” constant to make the final group the expected size.
  prefs: []
  type: TYPE_NORMAL
- en: The list slicing approach to grouping data is another way to approach the problem
    of structuring a flat sequence of data into blocks. As it is a general solution,
    it doesn’t seem to offer too many advantages over the functions in the previous
    section. As a solution specialized for making two-tuples from a flat list, it’s
    elegantly simple.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Using sorted() and reversed() to change the order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `sorted()` function produces a new list by rearranging the order of
    items in a list. This is similar to the way the `list.sort()` method changes the
    order of list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the important distinction between `sorted(aList)` and `aList.sort()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `aList.sort()` method modifies the `aList` object. It can only be meaningfully
    applied to a `list` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sorted(aList)` function creates a new list from an existing collection
    of items. The source object is not changed. Further, a variety of collections
    can be sorted. A `set` or the keys of a `dict` can be put into order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are times when we need a sequence reversed. Python offers us two approaches
    to this: the `reversed()` function, and slices with reversed indices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider performing a base conversion to hexadecimal or binary.
    The following code is a simple conversion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This function uses a recursion to yield the digits from the least significant
    to the most significant. The value of `x`` %`` base` will be the least significant
    digits of `x` in the base `base`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formalize it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ (| {[] if x = 0 digits(x,b) = | x ([x mod b]+ digits(⌊b⌋,b) if x > 0 ](img/file44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Python, we can use a long name like `base`. This is uncommon in conventional
    mathematics, so a single letter, b, is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we’d prefer the digits to be yielded in the reverse order; most
    significant first. We can wrap this function with the `reversed()` function to
    swap the order of the digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `reversed()` function produces an iterable, but the argument value must
    be a collection object. The function then yields the items from that object in
    the reverse order. While a dictionary can be reversed, the operation is an iterator
    over the keys of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We can do a similar kind of thing with a slice, such as `tuple(digits(x,`` base))[::-1]`.
    The slice, however, is not an iterator. A slice is a materialized object built
    from another materialized object. In this case, for such small collections of
    values, the allocation of extra memory for the slice is minor. As the `reversed()`
    function uses less memory than creating slices, it can be advantageous for working
    with larger collections.
  prefs: []
  type: TYPE_NORMAL
- en: The ”Martian Smiley”, `[:]`, is an edge case for slicing. The expression `some_list[:]`
    is a copy of the list made by taking a slice that includes all the items in order.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Using enumerate() to include a sequence number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python offers the `enumerate()` function to apply index information to values
    in a sequence or iterable. It performs a specialized kind of wrap that can be
    used as part of an `unwrap(process(wrap(data)))` design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enumerate()` function transformed each input item into a pair with a sequence
    number and the original item. It’s similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: An important feature of `enumerate()` is that the result is an iterable and
    it works with any iterable input.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at statistical processing, for example, the `enumerate()` function
    comes in handy to transform a single sequence of values into a more proper time
    series by prefixing each sample with a number.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we saw detailed ways to use a number of built-in reductions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used `any()` and `all()` to do essential logic processing. These are tidy
    examples of reductions using a simple operator, such as `or` or `and`. We’ve also
    looked at numeric reductions such as `len()` and `sum()`. We’ve applied these
    functions to create some higher-order statistical processing. We’ll return to
    these reductions in [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions and
    Reductions](Chapter_06.xhtml#x1-1260006).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also looked at some of the built-in mappings. The `zip()` function merges
    multiple sequences. This leads us to look at using this in the context of structuring
    and flattening more complex data structures. As we’ll see in examples in later
    chapters, nested data is helpful in some situations and flat data is helpful in
    others. The `enumerate()` function maps an iterable to a sequence of two-tuples.
    Each two-tuple has the sequence number at index `[0]` and the original value at
    index `[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `reversed()` function iterates over the items in a sequence object, with
    their original order reversed. Some algorithms are more efficient at producing
    results in one order, but we’d like to present these results in the opposite order.
    The `sorted()` function imposes an order either based on the direct comparisons
    of objects, or by using a key function to compare a derived value of each object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the mapping and reduction functions that
    use an additional function as an argument to customize their processing. Functions
    that accept a function as an argument are our first examples of higher-order functions.
    We’ll also touch on functions that return functions as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Palindromic numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See Project Euler problem number 4, [https://projecteuler.net/problem=4](https://projecteuler.net/problem=4).
    The idea here is to locate a number that has a specific property. In this exercise,
    we want to look at the question of a number being (or not being) a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: One way to handle this is to decompose a number into a sequence of decimal digits.
    We can then examine the sequence of decimal digits to see if it forms a proper
    palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: See the [Using sorted() and reversed() to change the order](#x1-910006) section
    for a snippet of code to extract digits in base 10 from a given number. Do we
    need the digits in the conventional order of most-significant digits first? Does
    it matter if the digits are generated in reverse order?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage this function in two separate ways to check for a palindrome:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare positions within a sequence of digits, `d[0]`` ==`` d[-1]`. We only
    need to compare the first half of the digits with the second half. Be sure your
    algorithm handles an odd number of digits correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `reversed()` to create a second sequence of digits and compare the two sequences.
    This is waste of time and memory, but may be easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement both alternatives and compare the resulting code for clarity and expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.2 Hands of cards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given five cards, there are a number of ways the five cards form groups. The
    full set of hands for a game like poker is fairly complex. A simplified set of
    hands, however, provides a tool for establishing whether data is random or not.
    Here are the hand types we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: All five cards match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four of the five cards match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three of the five cards match. Unlike poker, we’ll ignore whether or not the
    other two cards match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two separate matching pairs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two cards match, forming a single pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No cards match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For truly random data, the probabilities can be computed with some clever math.
    A good random number generator allows us to build a simulation that provides expected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we need a function to distinguish which flavor of hand is represented
    by five random values in the domain 1 to 13 (inclusive). The input is a list of
    five values. The output should be a numeric code for which of the six kinds of
    hands has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The broad outline of this function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm 4: Imperative iteration ](img/Algo_4.1.JPG)'
  prefs: []
  type: TYPE_IMG
- en: 'Hint: For the more general poker-hand identification, it can help to sort the
    values into ascending order. For this simplified algorithm, it helps to convert
    the list into a `Counter` object and examine the frequencies of the various card
    ranks. The `Counter` class is defined in the `collections` module with many other
    useful collection classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the hands can be recognized by a function of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This lets us write each individual hand-detection algorithm separately. We can
    then test them in isolation. This gives us confidence the overall hand classifier
    will work. It means you’ll need to write test cases on the individual classifiers
    to be sure they work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.3 Replace legs() with pairwise()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the [Pairing up items from a sequence](#x1-790003) section, we looked at
    the design for a `legs()` function to create pairs of legs from a sequence of
    waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: This function can be replaced with `itertools.pairwise()`. After making this
    change, determine which implementation is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.4 Expand legs() to include processing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the [Pairing up items from a sequence](#x1-790003) section, we looked at
    the design for a `legs()` function to create pairs of legs from a sequence of
    waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: A design alternative is to incorporate a function into the processing of `legs()`
    to perform a computation on each pair that’s created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function might look the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This changes the design of subsequent examples. Follow this design change through
    subsequent examples to see if this leads to simpler, easier-to-understand Python
    function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
