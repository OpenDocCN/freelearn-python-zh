<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Integration and System Testing</h1></div></div></div><p>With all of the tools, techniques, and practices we've discussed so far, we've still only been been thinking about testing units: the smallest, meaningfully testable pieces of code. It's time to expand the focus, and start testing code that incorporates multiple units.</p><p>That means we need to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Think about what integration testing and system testing actually are</li><li class="listitem" style="list-style-type: disc">Learn how to identify testable multi-unit segments of a program</li><li class="listitem" style="list-style-type: disc">Use the tools we've learned in order to create tests for these segments</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Introduction to integration testing and system testing</h1></div></div></div><p>Integration <a id="id360" class="indexterm"/>testing is the process of checking whether the units of our program work together properly. At this stage, thanks to our unit tests, we can assume that each unit works as expected in isolation, and we're kicking the tests up to a new level of complexity. It's not practical to start the process with integration testing because, if the units don't work, the integration won't work either, and it will be harder to track down the <a id="id361" class="indexterm"/>problems. Once the units are solid, though, it's necessary to test that the things we build out of them also work. The interactions can be surprising.</p><p>While you're doing integration testing, you'll be putting the units together into bigger and bigger collections, and testing these collections. When your integration tests expand to cover the entirety of your program, they become system tests.</p><p>The trickiest part of integration testing is choosing which units to integrate into each test, so that you always have a solid base of code that you can believe in: a place to stand, while you pull in more code.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec69"/>Deciding on an integration order</h2></div></div></div><p>We're going to work <a id="id362" class="indexterm"/>through an exercise that will help you with the process of deciding where to put the boundaries of integration tests:</p><div><ol class="orderedlist arabic"><li class="listitem">Using a piece of paper or a graphics program, write down names or representations for each of the units in the time planner project from <a class="link" href="ch07.html" title="Chapter 7. Test-driven Development Walk-through">Chapter 7</a>, <em>Test-driven Development Walk-through</em>. Group the methods of each class together. Being part of the same class is an obvious relationship between units, and we'll take advantage of this. The <code class="literal">==</code> symbol here represents the Python <code class="literal">==</code> operator, which invokes the <code class="literal">__eq__</code> method on an object:<div><img src="img/3211OS_08_01.jpg" alt="Deciding on an integration order"/></div></li><li class="listitem">Now draw arrows between units that are supposed to directly interact with each other, from the caller to the callee. Laying everything out in an orderly fashion, as in step 1, can actually make this harder, so feel free to move the classes around to help the lines make sense:<div><img src="img/3211OS_08_02.jpg" alt="Deciding on an integration order"/></div></li><li class="listitem">Draw circles around each class and each pair of classes connected by at least one line:<div><img src="img/3211OS_08_03.jpg" alt="Deciding on an integration order"/></div></li><li class="listitem">Continue the process by drawing circles around overlapping pairs of circles, until there are only three circles left. Circle a pair of them, and then put one more big circle <a id="id363" class="indexterm"/>around the whole mess:<div><img src="img/3211OS_08_04.jpg" alt="Deciding on an integration order"/></div></li><li class="listitem">Now, to decide which integration tests to write first, we just have to look at the number of circles surrounding all parts of it. The more deeply nested the circle that contains every unit involved in an integration test is, the sooner we write that test.</li></ol></div><p>What we just did is a way to visualize and solidify the process of building integration tests. While it's not critical to actually draw the lines and circles, it's useful to follow the process in your head. For larger projects, a lot can be gained from actually drawing the diagrams. When you see <a id="id364" class="indexterm"/>the diagram, the next correct step tends to jump right out at you—especially if you use multiple colors to render the diagram—where it might otherwise be hidden behind the complexity of the program.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Automating integration tests and system tests</h1></div></div></div><p>The only real <a id="id365" class="indexterm"/>difference between an integration test and a unit test is that, in an integration test, you can break the code being tested into smaller meaningful <a id="id366" class="indexterm"/>chunks; in a unit test, however, if you divided the code any more, it wouldn't be meaningful. For this reason, the same tools that help you automate unit testing can be applied to integration testing. Since system testing is really the highest level of integration testing, the tools can be used for that as well.</p><p>The role of <code class="literal">doctest</code> in integration testing tends to be fairly limited: doctest's real strengths are in the early part of the development process. It's easy for a testable specification to stray into integration testing—as said before, that's fine as long as there are unit tests as well, but after that it's likely that you'll prefer <code class="literal">unittest</code> and Nose for writing your integration tests.</p><p>Integration tests need to be isolated from each other. Even though they contain multiple interacting units within themselves, you still benefit from knowing that nothing outside the test is affecting it. For this reason, <code class="literal">unittest</code> is a good choice for writing automated integration tests.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec70"/>Writing integration tests for the time planner</h2></div></div></div><p>The integration <a id="id367" class="indexterm"/>diagram only provides a partial ordering <a id="id368" class="indexterm"/>of the integration tests, and there are several tests that could be the first one we write. Looking at the diagram, we can see that the <code class="literal">Status</code> and <code class="literal">Activity</code> classes are at the end of a lot of arrows, but not at the beginning of any. This makes them particularly good places to start writing integration tests, because it means that they don't call on anything outside themselves to operate. Since there's nothing to distinguish one of them as a better place to start than the other, we can choose between them arbitrarily. Let's start with <code class="literal">Status</code>, and then do <code class="literal">Activity</code>. We're going to write tests that exercise the whole class. At this low level, the integration tests will look a lot like the unit tests for the same class, but we're not going to use mock objects to represent other instances of the same class. We will use real instances. We're testing whether the class correctly interacts with itself.</p><p>Here is the <a id="id369" class="indexterm"/>test code for <code class="literal">Status</code>:</p><div><pre class="programlisting">from unittest import TestCase
from planner.data import Status
from datetime import datetime

class statuses_integration_tests(TestCase):
    def setUp(self):
        self.A = Status('A',
                        datetime(year = 2012, month = 7, day = 15),
                        datetime(year = 2013, month = 5, day = 2))

    def test_repr(self):
        self.assertEqual(repr(self.A), '&lt;A 2012-07-15T00:00:00 2013-05-02T00:00:00&gt;')

    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, Status('B',
                          datetime(year = 2012, month = 7, day = 15),
                          datetime(year = 2013, month = 5, day = 2)))
        self.assertNotEqual(self.A, Status('A',
                          datetime(year = 2011, month = 7, day = 15),
                          datetime(year = 2013, month = 5, day = 2)))
        self.assertNotEqual(self.A, Status('A',
                          datetime(year = 2012, month = 7, day = 15),
                          datetime(year = 2014, month = 5, day = 2)))

    def test_overlap_begin(self):
        status = Status('status name',
                          datetime(year = 2011, month = 8, day = 11),
                          datetime(year = 2012, month = 11, day = 27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_end(self):
        status = Status('status name',
                          datetime(year = 2012, month = 1, day = 11),
                          datetime(year = 2014, month = 4, day = 16))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_inner(self):
        status = Status('status name',
                          datetime(year = 2011, month = 10, day = 11),
                          datetime(year = 2014, month = 1, day = 27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_outer(self):
        status = Status('status name',
                          datetime(year = 2012, month = 8, day = 12),
                          datetime(year = 2012, month = 9, day = 15))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_after(self):
        status = Status('status name',
                          datetime(year = 2015, month = 2, day = 6),
                          datetime(year = 2019, month = 4, day = 27))

        self.assertFalse(status.overlaps(self.A))</pre></div><p>Here is the <a id="id370" class="indexterm"/>test code for <code class="literal">Activity</code>:</p><div><pre class="programlisting">from unittest import TestCase
from planner.data import Activity, TaskError
from datetime import datetime

class activities_integration_tests(TestCase):
    def setUp(self):
        self.A = Activity('A',
                          datetime(year = 2012, month = 7, day = 15),
                          datetime(year = 2013, month = 5, day = 2))

    def test_repr(self):
        self.assertEqual(repr(self.A), '&lt;A 2012-07-15T00:00:00 2013-05-02T00:00:00&gt;')

    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, Activity('B',
                          datetime(year = 2012, month = 7, day = 15),
                          datetime(year = 2013, month = 5, day = 2)))
        self.assertNotEqual(self.A, Activity('A',
                          datetime(year = 2011, month = 7, day = 15),
                          datetime(year = 2013, month = 5, day = 2)))
        self.assertNotEqual(self.A, Activity('A',
                          datetime(year = 2012, month = 7, day = 15),
                          datetime(year = 2014, month = 5, day = 2)))

    def test_overlap_begin(self):
        activity = Activity('activity name',
                          datetime(year = 2011, month = 8, day = 11),
                          datetime(year = 2012, month = 11, day = 27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_end(self):
        activity = Activity('activity name',
                          datetime(year = 2012, month = 1, day = 11),
                          datetime(year = 2014, month = 4, day = 16))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_inner(self):
        activity = Activity('activity name',
                          datetime(year = 2011, month = 10, day = 11),
                          datetime(year = 2014, month = 1, day = 27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_outer(self):
        activity = Activity('activity name',
                          datetime(year = 2012, month = 8, day = 12),
                          datetime(year = 2012, month = 9, day = 15))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_after(self):
        activity = Activity('activity name',
                          datetime(year = 2015, month = 2, day = 6),
                          datetime(year = 2019, month = 4, day = 27))

        self.assertFalse(activity.overlaps(self.A))</pre></div><p>Looking at our diagram, we can see that the next level out from either <code class="literal">Status</code> or <code class="literal">Activity</code> represents the <a id="id371" class="indexterm"/>integration of these classes with <a id="id372" class="indexterm"/>the <code class="literal">Schedule</code> class. Before we write this integration, we ought to write any tests that involve the <code class="literal">Schedule</code> class interacting with itself, without using mock objects:</p><div><pre class="programlisting">from unittest import TestCase
from unittest.mock import Mock
from planner.data import Schedule
from datetime import datetime

class schedule_tests(TestCase):
    def test_equality(self):
        A = Mock(overlaps = Mock(return_value = False))
        B = Mock(overlaps = Mock(return_value = False))
        C = Mock(overlaps = Mock(return_value = False))

        sched1 = Schedule()
        sched2 = Schedule()

        self.assertEqual(sched1, sched2)

        sched1.add(A)
        sched1.add(B)

        sched2.add(A)
        sched2.add(B)
        sched2.add(C)

        self.assertNotEqual(sched1, sched2)

        sched1.add(C)

        self.assertEqual(sched1, sched2)</pre></div><p>Now that the interactions within the <code class="literal">Schedule</code> class have been tested, we can write tests that integrate <code class="literal">Schedule</code> <a id="id373" class="indexterm"/>with either <code class="literal">Status</code> or <code class="literal">Activity</code>. Let's <a id="id374" class="indexterm"/>start with <code class="literal">Status</code>, then do <code class="literal">Activity</code>.</p><p>Here are the tests for <code class="literal">Schedule</code> and <code class="literal">Status</code>:</p><div><pre class="programlisting">from planner.data import Schedule, Status
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_and_statuses(TestCase):
    def setUp(self):
        self.A = Status('A',
                        datetime.now(),
                        datetime.now() + timedelta(minutes = 7))
        self.B = Status('B',
                        datetime.now() - timedelta(hours = 1),
                        datetime.now() + timedelta(hours = 1))
        self.C = Status('C',
                        datetime.now() + timedelta(minutes = 10),
                        datetime.now() + timedelta(hours = 1))

    def test_usage_pattern(self):
        sched = Schedule()

        sched.add(self.A)
        sched.add(self.C)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        sched.add(self.B)

        self.assertTrue(self.B in sched)

        self.assertEqual(sched, sched)

        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.B)
        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div><p>Here are the tests for the interactions between real <code class="literal">Schedule</code> and <code class="literal">Activity</code> instances. Due to the similarity <a id="id375" class="indexterm"/>between <code class="literal">Activity</code> and <code class="literal">Status</code>, the <a id="id376" class="indexterm"/>tests are, not surprisingly, structured similarly:</p><div><pre class="programlisting">from planner.data import Schedule, Activity, ScheduleError
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_and_activities(TestCase):
    def setUp(self):
        self.A = Activity('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = Activity('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = Activity('C',
                          datetime.now() + timedelta(minutes = 10),
                          datetime.now() + timedelta(hours = 1))

    def test_usage_pattern(self):
        sched = Schedule()

        sched.add(self.A)
        sched.add(self.C)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        self.assertRaises(ScheduleError, sched.add, self.B)

        self.assertFalse(self.B in sched)

        self.assertEqual(sched, sched)

        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertFalse(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div><p>All right, it's finally time <a id="id377" class="indexterm"/>to put <code class="literal">Schedule</code>, <code class="literal">Status</code>, and <a id="id378" class="indexterm"/>
<code class="literal">Activity</code> together in the same test:</p><div><pre class="programlisting">from planner.data import Schedule, Status, Activity, ScheduleError
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_activities_and_statuses(TestCase):
    def setUp(self):
        self.A = Status('A',
                        datetime.now(),
                        datetime.now() + timedelta(minutes = 7))
        self.B = Status('B',
                        datetime.now() - timedelta(hours = 1),
                        datetime.now() + timedelta(hours = 1))
        self.C = Status('C',
                        datetime.now() + timedelta(minutes = 10),
                        datetime.now() + timedelta(hours = 1))

        self.D = Activity('D',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))

        self.E = Activity('E',
                          datetime.now() + timedelta(minutes = 30),
                          datetime.now() + timedelta(hours = 1))

        self.F = Activity('F',
                          datetime.now() - timedelta(minutes = 20),
                          datetime.now() + timedelta(minutes = 40))

    def test_usage_pattern(self):
        sched = Schedule()

        sched.add(self.A)
        sched.add(self.B)
        sched.add(self.C)

        sched.add(self.D)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)
        self.assertTrue(self.D in sched)

        self.assertRaises(ScheduleError, sched.add, self.F)
        self.assertFalse(self.F in sched)
        sched.add(self.E)
        sched.remove(self.D)

        self.assertTrue(self.E in sched)
        self.assertFalse(self.D in sched)

        self.assertRaises(ScheduleError, sched.add, self.F)

        self.assertFalse(self.F in sched)

        sched.remove(self.E)

        self.assertFalse(self.E in sched)

        sched.add(self.F)

        self.assertTrue(self.F in sched)</pre></div><p>The next thing we need to pull in is the <code class="literal">File</code> class but, before we integrate it with the rest of the system, we need to <a id="id379" class="indexterm"/>integrate it with itself and check its <a id="id380" class="indexterm"/>internal interactions without using mock objects:</p><div><pre class="programlisting">from unittest import TestCase
from planner.persistence import File
from os import unlink

class test_file(TestCase):
    def setUp(self):
        storage = File('file_test.sqlite')

        storage.store_object('tag1', 'A')
        storage.store_object('tag2', 'B')
        storage.store_object('tag1', 'C')
        storage.store_object('tag1', 'D')
        storage.store_object('tag3', 'E')
        storage.store_object('tag3', 'F')

    def tearDown(self):
        try:
            unlink('file_test.sqlite')
        except OSError:
            pass

    def test_other_instance(self):
        storage = File('file_test.sqlite')

        self.assertEqual(set(storage.load_objects('tag1')),
                         set(['A', 'C', 'D']))

        self.assertEqual(set(storage.load_objects('tag2')),
                         set(['B']))

        self.assertEqual(set(storage.load_objects('tag3')),
                         set(['E', 'F']))</pre></div><p>Now we can write <a id="id381" class="indexterm"/>tests that integrate <code class="literal">Schedules</code> and <code class="literal">File</code>. Notice that, for this step, we still aren't involving <code class="literal">Status</code> or <code class="literal">Activity</code>, because <a id="id382" class="indexterm"/>they're outside the oval. We'll use mock objects in place of them, for now:</p><div><pre class="programlisting">from unittest import TestCase
from unittest.mock import Mock
from planner.data import Schedule
from planner.persistence import File
from os import unlink

def unpickle_mocked_task(begins):
    return Mock(overlaps = Mock(return_value = False), begins = begins)

class test_schedules_and_file(TestCase):
    def setUp(self):
        A = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (5,))),
                 begins = 5)

        B = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (3,))),
                 begins = 3)

        C = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (7,))),
                 begins = 7)

        self.A = A
        self.B = B
        self.C = C

    def tearDown(self):
        try:
            unlink('test_schedules_and_file.sqlite')
        except OSError:
            pass

    def test_save_and_restore(self):
        sched1 = Schedule()

        sched1.add(self.A)
        sched1.add(self.B)
        sched1.add(self.C)

        store1 = File('test_schedules_and_file.sqlite')
        sched1.store(store1)

        del sched1
        del store1

        store2 = File('test_schedules_and_file.sqlite')
        sched2 = Schedule.load(store2)

        self.assertEqual(set([x.begins for x in sched2.tasks]),
                         set([3, 5, 7]))</pre></div><p>We've built our way up to the outermost circle now, which means it's time to write tests that involve the whole <a id="id383" class="indexterm"/>system with no mock <a id="id384" class="indexterm"/>objects anywhere:</p><div><pre class="programlisting">from planner.data import Schedule, Status, Activity, ScheduleError
from planner.persistence import File
from unittest import TestCase
from datetime import datetime, timedelta
from os import unlink

class test_system(TestCase):
    def setUp(self):
        self.A = Status('A',
                        datetime.now(),
                        datetime.now() + timedelta(minutes = 7))
        self.B = Status('B',
                        datetime.now() - timedelta(hours = 1),
                        datetime.now() + timedelta(hours = 1))
        self.C = Status('C',
                        datetime.now() + timedelta(minutes = 10),
                        datetime.now() + timedelta(hours = 1))

        self.D = Activity('D',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))

        self.E = Activity('E',
                          datetime.now() + timedelta(minutes = 30),
                          datetime.now() + timedelta(hours = 1))

        self.F = Activity('F',
                          datetime.now() - timedelta(minutes = 20),
                          datetime.now() + timedelta(minutes = 40))

    def tearDown(self):
        try:
            unlink('test_system.sqlite')
        except OSError:
            pass

    def test_usage_pattern(self):
        sched1 = Schedule()

        sched1.add(self.A)
        sched1.add(self.B)
        sched1.add(self.C)
        sched1.add(self.D)
        sched1.add(self.E)

        store1 = File('test_system.sqlite')
        sched1.store(store1)

        del store1

        store2 = File('test_system.sqlite')
        sched2 = Schedule.load(store2)

        self.assertEqual(sched1, sched2)

        sched2.remove(self.D)
        sched2.remove(self.E)

        self.assertNotEqual(sched1, sched2)

        sched2.add(self.F)

        self.assertTrue(self.F in sched2)
        self.assertFalse(self.F in sched1)

        self.assertRaises(ScheduleError, sched2.add, self.D)
        self.assertRaises(ScheduleError, sched2.add, self.E)

        self.assertTrue(self.A in sched1)
        self.assertTrue(self.B in sched1)
        self.assertTrue(self.C in sched1)
        self.assertTrue(self.D in sched1)
        self.assertTrue(self.E in sched1)
        self.assertFalse(self.F in sched1)

        self.assertTrue(self.A in sched2)
        self.assertTrue(self.B in sched2)
        self.assertTrue(self.C in sched2)
        self.assertFalse(self.D in sched2)
        self.assertFalse(self.E in sched2)
        self.assertTrue(self.F in sched2)</pre></div><p>We've just integrated our whole code base, progressively constructing larger tests until we had tests encompassing the whole system. The whole time, we were careful to test one thing at a time. Because we took care to go step-by-step, we always knew where the newly discovered bugs originated, and we were able to fix them easily.</p><p>Speaking of which, if you were to run the tests for yourself while building this code structure, you would notice that some of them fail. All three of the failures point to the same problem: there's <a id="id385" class="indexterm"/>something wrong with the persistence database. This error doesn't show up in the unit tests for the <code class="literal">File</code> class, because it's only visible on a larger scale, when the database is used to communicate information between units.</p><p>Here's the error reported <a id="id386" class="indexterm"/>by the <code class="literal">test_file.py</code> tests:</p><div><pre class="programlisting"><strong>Traceback (most recent call last):</strong>
<strong>  File "integration/integration_tests/test_file.py", line 26, in test_other_instance</strong>
<strong>    set(['A', 'C', 'D']))</strong>
<strong>AssertionError: Items in the second set but not the first:</strong>
<strong>'A'</strong>
<strong>'D'</strong>
<strong>'C'</strong></pre></div><p>The changes to the database aren't being committed to the file, and so they aren't visible outside the transaction where they were stored. Not testing the persistence code in separate transactions was not an oversight, but that's exactly the sort of mistake that we expect integration testing to catch.</p><p>We can fix the problem by altering the <code class="literal">store_object</code> method of the <code class="literal">File</code> class in <code class="literal">persistence.py</code> as follows:</p><div><pre class="programlisting">    def store_object(self, tag, object):
        self.connection.execute('insert into objects values (?, ?)',
                                (tag, dumps(object)))
        <strong>self.connection.commit()</strong></pre></div><p>Another point of interest is the interaction between <code class="literal">pickle</code> and mock objects. There are a lot of things that mock objects do well, but accepting pickling is not one of them. Fortunately, that's relatively easy to work around is demonstrated in test integrating <code class="literal">Schedule</code> and <code class="literal">File</code>:</p><div><pre class="programlisting">def unpickle_mocked_task(begins):
    return Mock(overlaps = Mock(return_value = False), begins = begins)

class test_schedules_and_file(TestCase):
    def setUp(self):
        A = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (5,))),
                 begins = 5)

        B = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (3,))),
                 begins = 3)

        C = Mock(overlaps = Mock(return_value = False),
                 __reduce__ = Mock(return_value = (unpickle_mocked_task, (7,))),
                 begins = 7)</pre></div><p>The trick here is not really very tricky. We've just told the mock objects what return value to use for calls to the <code class="literal">__reduce__</code> method. It so happens that the pickle dumping functions call <code class="literal">__reduce__</code> to find out whether an object needs special handling when being pickled and unpickled. We told it that it did, and that it should call the <code class="literal">unpickle_mocked_task</code> function to reconstitute the mock object during unpickling. Now, our mock objects can be pickled and unpickled as well as the real objects can.</p><p>Another point of <a id="id387" class="indexterm"/>interest in the tests for <code class="literal">Schedule</code> and <code class="literal">File</code> is the <code class="literal">tearDown</code> test fixture method. The <code class="literal">tearDown</code> method will delete a database file, if <a id="id388" class="indexterm"/>it exists, but won't complain if it doesn't. The database is expected to be created within the test itself, and we don't want to leave it lying around; however, if it's not there, it's not a test fixture error:</p><div><pre class="programlisting">    def tearDown(self):
        try:
            unlink('test_schedules_and_file.sqlite')
        except OSError:
            pass</pre></div><p>A lot of the test code in this chapter might seem redundant to you. That's because, in some sense, it is. Some things are repeatedly checked in different tests. Why bother?</p><p>The main reason for the redundancy is that each test is supposed to stand alone. We're not supposed to care what order they run in, or whether any other tests even exist. Each test is self-contained; thus, if it fails, we know exactly what needs to be fixed. Because each test is self-contained, some <a id="id389" class="indexterm"/>foundational things end up getting tested multiple times. In the case of this simple project, redundancy is even more pronounced than it would normally be.</p><p>Whether <a id="id390" class="indexterm"/>it's blatant or subtle, though, the redundancy isn't a problem. The so-called <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) principle doesn't particularly apply to tests. There's not much downside to having something tested multiple times. This is not to say that it's a good idea to copy and paste tests, because it's very much <a id="id391" class="indexterm"/>not. Don't be surprised or alarmed to see similarities between your tests, but don't use that as an excuse. Every test that checks a particular thing is a test that needs to be changed if you change that thing, so it's still best to minimize redundancy where you can.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Check yourself – writing integration tests</h1></div></div></div><p>Try answering the <a id="id392" class="indexterm"/>following questions to check about integration tests yourself:</p><div><ol class="orderedlist arabic"><li class="listitem">Which integration tests do you write first?<p>Answer: The ones in the smallest circles, especially if they don't have any lines pointing from themselves to other circles. Put another way, write the most independent tests first.</p></li><li class="listitem">What happens when you have a large chunk of integrated code, but the next section you need to pull in doesn't have any integration tests at all?<p>Answer: Start from the smallest circles involving that code, and build up step-by-step until you're ready to integrate it with your earlier code.</p></li><li class="listitem">What's the point of writing tests that check the integration of a chunk of code with itself?<p>Answer: When we were doing unit testing, even other instances of the same class were mocked, as were other methods of the same instance when it was reasonable to do so; we were concerned that this code did what it was supposed to, without involving anything else. Now that we're doing integration testing, we need to test the instances of the same class that interact correctly with each other, or with themselves when they're allowed to retain a state from one operation to the next. The two kinds of tests cover different things, so it makes sense that we would need both.</p></li><li class="listitem">What is a system test and how do system tests relate to integration tests?<p>Answer: A <a id="id393" class="indexterm"/>system test is the final stage of integration testing. It's a test that involves the whole code base.</p></li></ol></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we learned about the process of building from a foundation of unit tests into a set of tests that cover the whole system.</p><p>Specifically, we covered how to draw an integration diagram. We learned how to interpret an integration diagram to decide in what order to build the tests and also learned which tools to use and how to use them to write the integration tests.</p><p>Now that we've learned about integration testing, we're ready to introduce a number of other useful testing tools and strategies, which is the topic of the next chapter.</p></div></div>
</body></html>