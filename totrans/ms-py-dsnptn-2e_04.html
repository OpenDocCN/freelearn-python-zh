<html><head></head><body>
		<div><h1 id="_idParaDest-84" class="chapter-number"><a id="_idTextAnchor088"/>4</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor089"/>Structural Design Patterns</h1>
			<p>In the previous chapter, we covered creational patterns and object-oriented programming patterns that help us with object-creation procedures. The next category of pattern we want to present<a id="_idIndexMarker217"/> is <em class="italic">structural design patterns</em>. A structural design pattern proposes a way of composing objects to provide new functionality.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The adapter pattern</li>
				<li>The decorator pattern</li>
				<li>The bridge pattern</li>
				<li>The facade pattern</li>
				<li>The flyweight pattern</li>
				<li>The proxy pattern</li>
			</ul>
			<p>At the end of this chapter, you will be equipped with the skills to structure your code efficiently and elegantly using structural design patterns.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor090"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>The adapter pattern</h1>
			<p>The <strong class="bold">adapter</strong> pattern <a id="_idIndexMarker218"/>is a structural design pattern that helps us make two incompatible interfaces compatible. What does that really mean? If we have an old component and we want to use it <a id="_idIndexMarker219"/>in a new system, or a new component that we want to use in an old system, the two can rarely communicate without requiring any code changes. But changing the code is not always possible, either because we don’t have access to it, or because it is impractical. In such cases, we can write an extra layer that makes all the required modifications for enabling communication between the two interfaces. This layer is called <a id="_idIndexMarker220"/>an <strong class="bold">adapter</strong>.</p>
			<p>In general, if you <a id="_idIndexMarker221"/>want to use an interface that expects <code>function_a()</code>, but <a id="_idIndexMarker222"/>you only have <code>function_b()</code>, you can use an adapter to convert (adapt) <code>function_b()</code> to <code>function_a()</code>.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>Real-world examples</h2>
			<p>When you are traveling from most<a id="_idIndexMarker223"/> European countries to the UK or the USA, or the other way around, you need to use a plug adapter for charging your laptop. The same kind of adapter is needed for connecting some devices to your computer: the USB adapter.</p>
			<p>In the software <a id="_idIndexMarker224"/>category, the <code>zope.interface</code> package (<a href="https://pypi.org/project/zope.interface/">https://pypi.org/project/zope.interface/</a>), part of <a id="_idIndexMarker225"/>the <strong class="bold">Zope Toolkit</strong> (<strong class="bold">ZTK</strong>), provides tools that help define interfaces and perform interface adaptation. These tools are used in the core of several<a id="_idIndexMarker226"/> Python web framework projects (including Pyramid and Plone).</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>zope.interface</code> was the solution for working with interfaces in Python, proposed by the team (<a href="https://zope.dev/">https://zope.dev/</a>) behind the Zope application server and the ZTK before Python introduced built-in <a id="_idIndexMarker227"/>mechanisms, with <strong class="bold">abstract base classes</strong> (also called <strong class="bold">ABCs</strong>) first and protocols later.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Use cases for the adapter pattern</h2>
			<p>Usually, one of the two<a id="_idIndexMarker228"/> incompatible interfaces is either foreign or old/legacy. If the interface is foreign, it means that we have no access to the source code. If it is old, it is usually impractical to refactor it.</p>
			<p>Using an adapter to make things work after they have been implemented is a good approach because it does not require access to the source code of the foreign interface. It is also often a pragmatic solution if we have to reuse some legacy code. That being said, be aware that it can introduce side effects that are hard to debug. So, use it with caution.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Implementing the adapter pattern – adapt a legacy class</h2>
			<p>Let’s consider an<a id="_idIndexMarker229"/> example where we have a legacy <a id="_idIndexMarker230"/>payment system and a new payment gateway. The adapter<a id="_idIndexMarker231"/> pattern can make them work together without changing the existing code, as we are going to see.</p>
			<p>The legacy payment system is implemented using a class, with a <code>make_payment()</code> method doing the core of the payment job, as follows:</p>
			<pre class="source-code">
class OldPaymentSystem:
    def __init__(self, currency):
        self.currency = currency
    def make_payment(self, amount):
        print(
            f"[OLD] Pay {amount} {self.currency}"
        )</pre>			<p>The new payment system is implemented using the following class, providing an <code>execute_payment()</code> method:</p>
			<pre class="source-code">
class NewPaymentGateway:
    def __init__(self, currency):
        self.currency = currency
    def execute_payment(self, amount):
        print(
            f"Execute payment of {amount} {self.currency}"
        )</pre>			<p>Now, we<a id="_idIndexMarker232"/> are going to add a class that will provide the <code>make_payment()</code> method, where we call the <code>execute_payment()</code> method on the adaptee object to get the payment done. The code is as follows:</p>
			<pre class="source-code">
class PaymentAdapter:
    def __init__(self, system):
        self.system = system
    def make_payment(self, amount):
        self.system.execute_payment(amount)</pre>			<p>This is how the <code>PaymentAdapter</code> class adapts the interface of <code>NewPaymentGateway</code> to match that of <code>OldPaymentSystem</code>.</p>
			<p>Let’s see the result of this <a id="_idIndexMarker236"/>ada<a id="_idTextAnchor095"/>ptation by adding a <code>main()</code> function with testing code, as follows:</p>
			<pre class="source-code">
def main():
    old_system = OldPaymentSystem("euro")
    print(old_system)
    new_system = NewPaymentGateway("euro")
    print(new_system)
    adapter = PaymentAdapter(new_system)
    adapter.make_payment(100)</pre>			<p>Let’s recapitulate the complete code (see the <code>ch04</code><code>/adapter/adapt_legacy.py</code> file) of the implementation:</p>
			<ol>
				<li>We have some code for the legacy payment system, represented by the <code>OldPaymentSystem</code> class, providing a <code>make_payment()</code> method.</li>
				<li>We introduce the new payment system, with the <code>NewPaymentGateway</code> class, providing an <code>execute_payment()</code> method.</li>
				<li>We add a class for the adapter, <code>PaymentAdapter</code>, which has an attribute to store the payment system object and a <code>make_payment()</code> method; in that method, we call the <code>execute_payment()</code> method on the payment system object (via <code>self.system.execute_payment(amount)</code>).</li>
				<li>We add code for testing our interface adaptation design (and call it within the usual <code>if __name__ == "</code><code>__main__"</code> block).</li>
			</ol>
			<p>Executing the code, using <code>python ch04/adapter/adapt_legacy.py</code>, should give the following output:</p>
			<pre class="console">
&lt;__main__.OldPaymentSystem object at 0x10ee58fd0&gt;
&lt;__main__.NewPaymentGateway object at 0x10ee58f70&gt;
Execute payment of 100 euro</pre>			<p>You now <a id="_idIndexMarker237"/>get the idea. This adaptation technique allows us to use the <a id="_idIndexMarker238"/>new payment gateway with existing code that expects the old interface.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor096"/>Implementing the adapter pattern – adapt several classes into a unified interface</h2>
			<p>Let’s look at another <a id="_idIndexMarker239"/>application to illustrate adaptation: a<a id="_idIndexMarker240"/> club’s activities. Our club has two main activities:</p>
			<ul>
				<li>Hire talented artists to perform in the club</li>
				<li>Organize performances and events to entertain its clients</li>
			</ul>
			<p>At the core, we have a <code>Club</code> class that represents the club where hired artists perform some evenings. The <code>organize_performance()</code> method is the main action that the club can perform. The code is as follows:</p>
			<pre class="source-code">
class Club:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the club {self.name}"
    def organize_event(self):
        return "hires an artist to perform"</pre>			<p>Most of the time, our club hires a DJ to perform, but our application should make it possible to organize a diversity of performances: by a musician or music band, by a dancer, a one-man or one-woman show, and so on.</p>
			<p>Via our research to try and reuse existing code, we find an open source contributed library that brings us two interesting classes: <code>Musician</code> and <code>Dancer</code>. In the <code>Musician</code> class, the main action is performed by the <code>play()</code> method. In the <code>Dancer</code> class, it is performed by the <code>dance()</code> method.</p>
			<p>In our example, to <a id="_idIndexMarker241"/>indicate that these two classes are <a id="_idIndexMarker242"/>external, we place them in a separate<a id="_idIndexMarker243"/> module (in the <code>ch04/adapter/external.py</code> file). The code includes two classes, <code>Musician</code> and <code>Dancer</code>, as follows:</p>
			<pre class="source-code">
<strong class="bold">class Musician:</strong>
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the musician {self.name}"
    def play(self):
        return "plays music"
<strong class="bold">class Dancer:</strong>
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the dancer {self.name}"
    def dance(self):
        return "does a dance performance"</pre>			<p>The code we are <a id="_idIndexMarker244"/>writing, to use these two classes from the external library, only<a id="_idIndexMarker245"/> knows how to call the <code>organize_performance()</code> method (on the <code>Club</code> class); it has no idea about the <code>play()</code> or <code>dance()</code> methods (on the respective classes).</p>
			<p>How can we make the code work without changing the <code>Musician</code> and <code>Dancer</code> classes?</p>
			<p>Adapters to the rescue! We create a generic <code>Adapter</code> class that allows us to adapt a number of objects with different interfaces into one unified interface. The <code>obj</code> argument of the <code>__init__()</code> method is the object that we want to adapt, and <code>adapted_methods</code> is a dictionary<a id="_idIndexMarker246"/> containing key/value pairs matching the method the client calls and the method that should be called. The code for that class is as follows:</p>
			<pre class="source-code">
class Adapter:
    def __init__(self, obj, adapted_methods):
        self.obj = obj
        self.__dict__.update(adapted_methods)
    def __str__(self):
        return str(self.obj)</pre>			<p>When dealing with the instances of the different classes, we have two cases:</p>
			<ul>
				<li>The compatible object that belongs to the <code>Club</code> class needs no adaptation. We can treat it as is.</li>
				<li>The incompatible objects need to be adapted first, using the <code>Adapter</code> class.</li>
			</ul>
			<p>The result is that the <a id="_idIndexMarker247"/>client code can continue using the known <code>organize_performance()</code> method on all objects without the need to be <a id="_idIndexMarker248"/>aware of any interface differences. Consider the following <code>main()</code> function <a id="_idIndexMarker249"/>code to prove that the design works as expected:</p>
			<pre class="source-code">
def main():
    objects = [
        Club("Jazz Cafe"),
        Musician("Roy Ayers"),
        Dancer("Shane Sparks"),
    ]
    for obj in objects:
        if hasattr(obj, "play") or hasattr(
            obj, "dance"
        ):
            if hasattr(obj, "play"):
                adapted_methods = dict(
                    organize_event=obj.play
                )
            elif hasattr(obj, "dance"):
                adapted_methods = dict(
                    organize_event=obj.dance
                )
            obj = Adapter(obj, adapted_methods)
        print(f"{obj} {obj.organize_event()}")</pre>			<p>Let’s recapitulate the complete code of our adapter pattern implementation (in the <code>ch04/adapter/adapt_to_unified_interface.py</code> file):</p>
			<ol>
				<li>We import <a id="_idIndexMarker250"/>the <code>Musician</code> and <code>Dancer</code> classes from<a id="_idIndexMarker251"/> the <code>external</code> module.</li>
				<li>We have the <code>Club</code> class.</li>
				<li>We define the <code>Adapter</code> class.</li>
				<li>We add the <code>main()</code> function, which we call within the usual <code>if __name__ == "</code><code>__main__"</code> block.</li>
			</ol>
			<p>Here is the output when executing the <code>python </code><code>ch04/adapter/adapt_to_unified_interface.py</code> command:</p>
			<pre class="console">
the club Jazz Cafe hires an artist to perform
the musician Roy Ayers plays music
the dancer Shane Sparks does a dance performance</pre>			<p>As you can see, we managed <a id="_idIndexMarker252"/>to make the <code>Musician</code> and <code>Dancer</code> classes<a id="_idIndexMarker253"/> compatible with the interface expected by the client code without changing the source code of these external classes.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>The decorator pattern</h1>
			<p>A second interesting <a id="_idIndexMarker254"/>structural pattern to learn about is the <strong class="bold">decorator</strong> pattern, which allows <a id="_idIndexMarker255"/>a programmer to add responsibilities to an object dynamically, and in a transparent manner (without affecting other objects).</p>
			<p>There is another reason why this pattern is interesting to us, as you will see in a minute.</p>
			<p>As Python developers, we can write decorators in a <strong class="bold">Pythonic</strong> way (meaning using the language’s features), thanks to the built-in decorator feature.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A Python decorator<a id="_idIndexMarker256"/> is a callable (function, method, or class) that gets a <code>func_in</code> function object as input and returns another function object, <code>func_out</code>. It is a commonly used technique for extending the behavior of a function, method, or class.</p>
			<p class="callout">For more details on Python’s decorator feature, see the<a id="_idIndexMarker257"/> official documentation: <a href="https://docs.python.org/3/reference/compound_stmts.html#function">https://docs.python.org/3/reference/compound_stmts.html#function</a></p>
			<p>But this feature should not be completely new to you. We have already encountered commonly used decorators in previous chapters (<code>@abstractmethod</code>, <code>@property</code>) and there are several other useful built-in decorators in Python. Now, we are going to learn how to implement and use our own decorators.</p>
			<p>Note that there is no one-to-one relationship between the decorator pattern and Python’s decorator feature. Python decorators can actually do much more than the decorator pattern. One of the things they can be used for is to implement the decorator pattern.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Real-world examples</h2>
			<p>The decorator pattern is<a id="_idIndexMarker258"/> generally used for extending the functionality of an object. In everyday life, examples of such extensions are adding a silencer to a gun, using different camera lenses, and so on.</p>
			<p>In web frameworks such as Django, which uses decorators a lot, we have decorators that can be used for the following:</p>
			<ul>
				<li>Restricting access to views (or HTTP-request-handling functions) based on the request</li>
				<li>Controlling the caching behavior on specific views</li>
				<li>Controlling compression on a per-view basis</li>
				<li>Controlling caching based on specific HTTP request headers</li>
				<li>Registering a function as an event subscriber</li>
				<li>Protecting a function with a specific permission</li>
			</ul>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/>Use cases for the decorator pattern</h2>
			<p>The decorator pattern shines <a id="_idIndexMarker259"/>when used for implementing cross-cutting<a id="_idIndexMarker260"/> concerns, such as the following:</p>
			<ul>
				<li>Data validation</li>
				<li>Caching</li>
				<li>Logging</li>
				<li>Monitoring</li>
				<li>Debugging</li>
				<li>Business rules</li>
				<li>Encryption</li>
			</ul>
			<p>In general, all parts of an application that are generic and can be applied to many other parts of it are considered to be cross-cutting concerns.</p>
			<p>Another popular <a id="_idIndexMarker261"/>example <a id="_idIndexMarker262"/>of using the decorator pattern is in <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) toolkits. In a GUI toolkit, we want to be able to add features such as borders, shadows, colors, and scrolling to individual components/widgets.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/>Implementing the decorator pattern</h2>
			<p>Python decorators are<a id="_idIndexMarker263"/> generic and very powerful. In this section, we will see how we can <a id="_idIndexMarker264"/>implement a <code>number_sum()</code> function that returns the sum of the first <em class="italic">n</em> numbers. Note that this function is already available in the <code>math</code> module as <code>fsum()</code>, but let’s pretend it is not.</p>
			<p>First, let’s look at the <a id="_idIndexMarker265"/>naive implementation (in the <code>ch04/decorator/number_sum_naive.py</code> file):</p>
			<pre class="source-code">
def number_sum(n):
    if n == 0:
        return 0
    else:
        return n + number_sum(n - 1)
if __name__ == "__main__":
    from timeit import Timer
    t = Timer(
        "number_sum(50)",
        "from __main__ import number_sum",
    )
    print("Time: ", t.timeit())</pre>			<p>A sample <a id="_idIndexMarker266"/>execution of this example shows how slow this<a id="_idIndexMarker267"/> implementation is. On my computer, it takes more than <em class="italic">7</em> seconds to calculate the sum of the first 50 numbers. We get the following output when executing the <code>python </code><code>ch04/decorator/number_sum_naive.py</code> command:</p>
			<pre class="source-code">
<code>dict</code> for caching the already computed sums. We also change the parameter passed to the <code>number_sum()</code> function. We want to calculate the sum of the first 300 numbers instead of only the first 50.</p>
			<p>Here is the new version of the code (in the <code>ch04</code><code>/decorator/number_sum.py</code> file), using memoization:</p>
			<pre class="source-code">
sum_cache = {0: 0}
def number_sum(n):
    if n in sum_cache:
        return sum_cache[n]
    res = n + number_sum(n - 1)
    # Add the value to the cache
    sum_cache[n] = res
    return res
if __name__ == "__main__":
    from timeit import Timer
    t = Timer(
        "number_sum(300)",
        "from __main__ import number_sum",
    )
    print("Time: ", t.timeit())</pre>			<p>Executing the <a id="_idIndexMarker268"/>memoization-based code shows that performance <a id="_idIndexMarker269"/>improves dramatically, and is acceptable even for computing large values.</p>
			<p>A sample execution, using <code>python ch04/decorator/number_sum.py</code>, is as follows:</p>
			<pre class="source-code">
<strong class="bold">Time:  0.1288748119986849</strong></pre>			<p>But there are a few problems with this approach. First, while the performance is not an issue any longer, the code is not as clean as it is when not using memoization. And what happens if we decide to extend the code with more math functions and turn it into a module? We can think of several functions that would be useful for our module, for problems such as Pascal’s triangle or the Fibonacci numbers suite algorithm.</p>
			<p>So, if we wanted a function in the same module as <code>number_sum()</code> for the Fibonacci numbers suite, using the same memoization technique, we would add code as follows (see the version in the <code>ch04/decorator/number_sum_and_fibonacci.py</code> file):</p>
			<pre class="source-code">
fib_cache = {0: 0, 1: 1}
def fibonacci(n):
    if n in fib_cache:
        return fib_cache[n]
    res = fibonacci(n - 1) + fibonacci(n - 2)
    fib_cache[n] = res
    return res</pre>			<p>Do you notice the<a id="_idIndexMarker270"/> problem? We ended up with a new<a id="_idIndexMarker271"/> dictionary called <code>fib_cache</code> that acts as our cache for the <code>fibonacci()</code> function, and a function that is more complex than it would be without using memoization. Our module is becoming unnecessarily complex.</p>
			<p>Is it possible to write these functions while keeping them as simple as the naive versions, but achieving a performance similar to the performance of the functions that use memoization?</p>
			<p>Fortunately, it is, and the solution is to use the decorator pattern.</p>
			<p>First, we create a <code>memoize()</code> decorator as shown in the following example. Our decorator accepts the <code>func</code> function, which needs to be memoized, as an input. It uses <code>dict</code> named <code>cache</code> as the cached data container. The <code>functools.wraps()</code> function is used for convenience when creating decorators. It is not mandatory but it’s a good practice to use it, since it makes sure that the documentation and the signature of the function that is decorated are preserved. The <code>*args</code> argument list is required in this case because the functions that we want to decorate accept input arguments (such as the <code>n</code> argument for our two functions):</p>
			<pre class="source-code">
import functools
def memoize(func):
    cache = {}
    @functools.wraps(func)
    def memoizer(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return memoizer</pre>			<p>Now we can use<a id="_idIndexMarker272"/> our <code>memoize()</code> decorator with the naive<a id="_idIndexMarker273"/> version of our functions. This has the benefit of readable code without performance impact. We apply a decorator using what is known as <code>@name</code> syntax, where <code>name</code> is the name of the decorator that we want to use. It is nothing more than syntactic sugar for simplifying the usage of decorators. We can even bypass this syntax and execute our decorator manually, but that is left as an exercise for you.</p>
			<p>So, the <code>memoize()</code> decorator can be used with our recursive functions as follows:</p>
			<pre class="source-code">
@memoize
def number_sum(n):
    if n == 0:
        return 0
    else:
        return n + number_sum(n - 1)
@memoize
def fibonacci(n):
    if n in (0, 1):
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)</pre>			<p>In the last part of the code, via the <code>main()</code> function, we show how to use the decorated functions and measure their performance. The <code>to_execute</code> variable is used to hold a <a id="_idIndexMarker275"/>list of tuples containing the reference to each function and the corresponding <code>timeit.Timer()</code> call (to execute it while measuring the time spent), thus avoiding code repetition. Note how the <code>__name__</code> and <code>__doc__</code> method attributes show the proper function names and documentation <a id="_idIndexMarker276"/>values, respectively. Try <a id="_idIndexMarker277"/>removing the <code>@functools.wraps(func)</code> decoration from <code>memoize()</code> and see whether this is still the case.</p>
			<p>Here is the last part of the code:</p>
			<pre class="source-code">
def main():
    from timeit import Timer
    to_execute = [
        (
            number_sum,
            Timer(
                "number_sum(300)",
                "from __main__ import number_sum",
            ),
        ),
        (
            fibonacci,
            Timer(
                "fibonacci(100)",
                "from __main__ import fibonacci",
            ),
        ),
    ]
    for item in to_execute:
        func = item[0]
        print(
            f'Function "{func.__name__}": {func.__doc__}'
        )
        t = item[1]
        print(f"Time: {t.timeit()}")
        print()</pre>			<p>Let’s recapitulate how we<a id="_idIndexMarker278"/> write the complete code of our math <a id="_idIndexMarker279"/>module (the <code>ch04/decorator/decorate_math.py</code> file):</p>
			<ol>
				<li>After the import of Python’s <code>functools</code> module that we will be using, we define the <code>memoize()</code> decorator function.</li>
				<li>Then, we define the <code>number_sum()</code> function, decorated using <code>memoize()</code>.</li>
				<li>Next, we define the <code>fibonacci()</code> function, decorated the same way.</li>
				<li>Finally, we add the <code>main()</code> function, as shown earlier, and the usual trick to call it.</li>
			</ol>
			<p>Here is a sample output when executing the <code>python </code><code>ch04/decorator/decorate_math.py</code> command:</p>
			<pre class="source-code">
<strong class="bold">Function "number_sum": Returns the sum of the first n numbers</strong>
<strong class="bold">Time: 0.2148694</strong>
<strong class="bold">Function "fibonacci": Returns the suite of Fibonacci numbers</strong>
<strong class="bold">Time: 0.202763251</strong></pre>			<p class="callout-heading">Note</p>
			<p class="callout">The execution times might differ in your case. Also, regardless of the time spent, we can see that the decorator-based implementation is a win because the code is more maintainable.</p>
			<p>Nice! We ended up with<a id="_idIndexMarker280"/> readable code and acceptable <a id="_idIndexMarker281"/>performance. Now, you might argue that this is not the decorator pattern, since we don’t apply it at runtime. The truth is that a decorated function cannot be undecorated, but you can still decide at runtime whether the decorator will be executed or not. That’s an interesting exercise left for you. <em class="italic">Hint for the exercise:</em> use a decorator that acts as a wrapper, which decides whether or not the real decorator is executed based on some condition.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/>The bridge pattern</h1>
			<p>A third<a id="_idIndexMarker282"/> structural pattern to look at is <a id="_idIndexMarker283"/>the <strong class="bold">bridge</strong> pattern. We can actually compare the bridge and the adapter patterns, looking at the way both work. While the adapter pattern is used <em class="italic">later</em> to make unrelated classes work together, as we saw in the implementation example we discussed earlier in the section on <em class="italic">The adapter pattern</em>, the bridge pattern is designed <em class="italic">up-front</em> to decouple an implementation from its abstraction, as we are going to see.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/>Real-world examples</h2>
			<p>In our modern, everyday lives, an <a id="_idIndexMarker284"/>example of the bridge pattern I can think of is from the <em class="italic">digital economy</em>: information products. Nowadays, the information product or <em class="italic">infoproduct</em> is part of the resources one can find online for training, self-improvement, or one’s ideas and business development. The purpose of an information product that you find on certain marketplaces, or the website of the provider, is to deliver information on a given topic in such a way that it is easy to access and consume. The provided material can be a PDF document or ebook, an ebook series, a video, a video series, an online course, a subscription-based newsletter, or a combination of all those formats.</p>
			<p>In the software realm, we can find two examples:</p>
			<ul>
				<li><strong class="bold">Device drivers</strong>: Developers of an<a id="_idIndexMarker285"/> OS define the interface for device (such as printers) vendors to implement it</li>
				<li><strong class="bold">Payment gateways</strong>: Different payment gateways<a id="_idIndexMarker286"/> can have different <a id="_idIndexMarker287"/>implementations, but the checkout process remains consistent</li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/>Use cases for the bridge pattern</h2>
			<p>Using the bridge <a id="_idIndexMarker288"/>pattern is a <a id="_idIndexMarker289"/>good idea when you want to share an implementation among multiple objects. Basically, instead of implementing several specialized classes, and defining all that is required within each class, you can define the following special components:</p>
			<ul>
				<li>An abstraction that applies to all the classes</li>
				<li>A separate interface for the different objects involved</li>
			</ul>
			<p>An implementation example we are about to see will illustrate this approach.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/>Implementing the bridge pattern</h2>
			<p>Let’s assume we are building<a id="_idIndexMarker290"/> an application where the user is going to manage and deliver content after fetching it from diverse sources, which could be the following:</p>
			<ul>
				<li>A web page (based on its URL)</li>
				<li>A resource accessed on an FTP server</li>
				<li>A file on the local filesystem</li>
				<li>A database server</li>
			</ul>
			<p>So, here is the idea: instead of implementing several content classes, each holding the methods responsible for getting the content pieces, assembling them, and showing them inside the application, we can define an abstraction for the <em class="italic">Resource Content</em> and a separate interface for the objects that are responsible for fetching the content. Let’s try it!</p>
			<p>We begin with the interface for the implementation classes that help fetch content – that is, the <code>ResourceContentFetcher</code> class. This concept is<a id="_idIndexMarker291"/> called the <code>protocols</code> feature, as follows:</p>
			<pre class="source-code">
class ResourceContentFetcher(Protocol):
    def fetch(self, path: str) -&gt; str:
        ...</pre>			<p>Then, we define the class for our Resource Content abstraction, called <code>ResourceContent</code>. The first trick we use here is that, via an attribute (<code>_imp</code>) on the <code>ResourceContent</code> class, we maintain a reference to the object that represents the Implementor (fulfilling the <code>ResourceContentFetcher</code> interface). The code is as follows:</p>
			<pre class="source-code">
class ResourceContent:
    def __init__(self, imp: ResourceContentFetcher):
        self._imp = imp
    def get_content(self, path):
        return self._imp.fetch(path)</pre>			<p>Now we can<a id="_idIndexMarker293"/> add an <code>implementation</code> class to fetch content from a web page or resource:</p>
			<pre class="source-code">
class URLFetcher:
    def fetch(self, path):
        res = ""
        req = urllib.request.Request(path)
        with urllib.request.urlopen(
            req
        ) as response:
            if response.code == 200:
                res = response.read()
        return res</pre>			<p>We can also<a id="_idIndexMarker294"/> add an <code>implementation</code> class to fetch<a id="_idIndexMarker295"/> content from a file on the local filesystem:</p>
			<pre class="source-code">
class LocalFileFetcher:
    def fetch(self, path):
        with open(path) as f:
            res = f.read()
        return res</pre>			<p>Based on that, a <code>main</code> function with some testing code to show content using both <em class="italic">content fetchers</em> could look like the following:</p>
			<pre class="source-code">
def main():
    url_fetcher = URLFetcher()
    rc = ResourceContent(url_fetcher)
    res = rc.get_content("http://python.org")
    print(
        f"Fetched content with {len(res)} characters"
    )
    localfs_fetcher = LocalFileFetcher()
    rc = ResourceContent(localfs_fetcher)
    pathname = os.path.abspath(__file__)
    dir_path = os.path.split(pathname)[0]
    path = os.path.join(dir_path, "file.txt")
    res = rc.get_content(path)
    print(
        f"Fetched content with {len(res)} characters"
    )</pre>			<p>Let’s see a summary <a id="_idIndexMarker296"/>of the complete code of our <a id="_idIndexMarker297"/>example (the <code>ch04/bridge/bridge.py</code> file):</p>
			<ol>
				<li>We import the modules we need for the program (<code>os</code>, <code>urllib.request</code>, and <code>typing.Protocol</code>).</li>
				<li>We define the <code>ResourceContentFetcher</code> interface, using <em class="italic">protocols</em>, for the <em class="italic">Implementor</em>.</li>
				<li>We define the <code>ResourceContent</code> class for the interface of the abstraction.</li>
				<li>We define two implementation classes:<ul><li><code>URLFetcher</code> for fetching content from a URL</li><li><code>LocalFileFetcher</code> for fetching content from the local filesystem</li></ul></li>
				<li>Finally, we add the <code>main()</code> function, as shown earlier, and the usual trick to call it.</li>
			</ol>
			<p>Here is a sample output when executing the <code>python </code><code>ch04/bridge/bridge.py </code>command:</p>
			<pre class="console">
Fetched content with 51265 characters
Fetched content with 1327 characters</pre>			<p>This is a basic<a id="_idIndexMarker298"/> illustration of how using the bridge pattern in your<a id="_idIndexMarker299"/> design, you can extract content from different sources and integrate the results in the same data manipulation system or user interface.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor105"/>The facade pattern</h1>
			<p>As systems evolve, they <a id="_idIndexMarker300"/>can get very complex. It is not unusual to end up with a very <a id="_idIndexMarker301"/>large (and sometimes confusing) collection of classes and interactions. In many cases, we don’t want to expose this complexity to the client. This is where our next structural pattern comes to the rescue: <strong class="bold">facade</strong>.</p>
			<p>The facade design pattern helps us hide the internal complexity of our systems and expose only what is necessary to the client through a simplified interface. In essence, facade is an abstraction layer implemented over an existing complex system.</p>
			<p>Let’s take the example of the computer to illustrate things. A computer is a complex machine that depends on several parts to be fully functional. To keep things simple, the word “computer,” in this case, refers to an IBM derivative that uses a von Neumann architecture. Booting a computer is a particularly complex procedure. The CPU, main memory, and hard disk need to be up and running, the boot loader must be loaded from the hard disk to the main memory, the CPU must boot the operating system kernel, and so forth. Instead of exposing all this complexity to the client, we create a facade that encapsulates the whole procedure, making sure that all steps are executed in the right order.</p>
			<p>In terms of object design and programming, we should have several classes, but only the <code>Computer</code> class needs to be exposed to the client code. The client will only have to execute the <code>start()</code> method of the <code>Computer</code> class, for example, and all the other complex parts are taken care of by the facade <code>Computer</code> class.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/>Real-world examples</h2>
			<p>The facade pattern is quite common in<a id="_idIndexMarker302"/> life. When you call a bank or a company, you are usually first connected to the customer service department. The customer service employee acts as a facade between you and the actual department (billing, technical support, general assistance, and so on), where an employee will help you with your specific problem.</p>
			<p>As another <a id="_idIndexMarker303"/>example, a key used to turn on a car or motorcycle can also be considered a facade. It is a simple way of activating a system that is very complex internally. And, of course, the same is true for other complex electronic devices that we can activate with a single button, such as computers.</p>
			<p>In software, the <code>django-oscar-datacash</code> module is a Django third-party module that integrates with<a id="_idIndexMarker304"/> the <strong class="bold">DataCash</strong> payment gateway. The module has a gateway class that provides fine-grained access to the various DataCash APIs. On top of that, it also offers a facade class that provides a less granular API (for those who don’t want to mess with the details), and the ability to save transactions for auditing purposes.</p>
			<p>The <code>Requests</code> library is<a id="_idIndexMarker305"/> another great example of the facade pattern. It simplifies sending HTTP requests and handling responses, abstracting the complexities of the HTTP protocol. Developers can easily make HTTP requests without dealing with the intricacies of sockets or the underlying HTTP methods.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor107"/>Use cases for the facade pattern</h2>
			<p>The most usual reason<a id="_idIndexMarker306"/> to use the facade pattern is to provide a single, simple entry point to a complex system. By introducing facade, the client code can use a system by simply calling a single method/function. At the same time, the internal system does not lose any functionality, it just encapsulates it.</p>
			<p>Not exposing the internal functionality of a system to the client code gives us an extra benefit: we can introduce changes to the system, but the client code remains unaware of and unaffected by the changes. No modifications are required to the client code.</p>
			<p>Facade is also useful if you have more than one layer in your system. You can introduce one facade entry point per layer and let all layers communicate with each other through their facades. That promotes <strong class="bold">loose coupling</strong> and<a id="_idIndexMarker307"/> keeps the layers as independent as possible.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>Implementing the facade pattern</h2>
			<p>Assume<a id="_idIndexMarker308"/> that we want<a id="_idIndexMarker309"/> to create an operating system using a multi-server approach, similar to how it is done in MINIX 3 or GNU Hurd. A multi-server operating system has a minimal kernel, called<a id="_idIndexMarker310"/> the <strong class="bold">microkernel</strong>, which runs in privileged mode. All the other services of the system are following a server architecture (driver server, process server, file server, and so forth). Each server belongs to a different memory address space and runs on top of the microkernel in user mode. The pros of this approach are that the operating system can become more fault-tolerant, reliable, and secure. For example, since all drivers are running in user mode on a driver server, a bug in a driver cannot crash the whole system, nor can it affect the other servers. The cons of this approach are the performance overhead and the complexity of system programming, because the communication between a server and the microkernel, as well as between the independent servers, happens using message passing. Message passing is more complex than the shared memory model used in monolithic kernels such as Linux.</p>
			<p>We begin with a <code>Server</code> interface. Also, an <code>Enum</code> parameter describes the different possible states of a server. We use the <code>ABC</code> technique to forbid direct instantiation of the <code>Server</code> interface and make the fundamental <code>boot()</code> and <code>kill()</code> methods mandatory, assuming that different actions are needed to be taken for booting, killing, and restarting each server. Here is the code for these elements, the first important bits to support our implementation:</p>
			<pre class="source-code">
State = Enum(
    "State",
    "NEW RUNNING SLEEPING RESTART ZOMBIE",
)
# ...
class Server(ABC):
    @abstractmethod
    def __init__(self):
        pass
    def __str__(self):
        return self.name
    @abstractmethod
    def boot(self):
        pass
    @abstractmethod
    def kill(self, restart=True):
        pass</pre>			<p>A modular operating system can have a great number of interesting servers: a file server, a process server, an authentication server, a network server, a graphical/window server, and so forth. The<a id="_idIndexMarker311"/> following example includes two stub servers: <code>FileServer</code> and <code>ProcessServer</code>. Apart from the <code>boot()</code> and <code>kill()</code> methods<a id="_idIndexMarker312"/> all servers have, <code>FileServer</code> has a <code>create_file()</code> method for creating files, and <code>ProcessServer</code> has a <code>create_process()</code> method for creating processes.</p>
			<p>The <code>FileServer</code> class is as follows:</p>
			<pre class="source-code">
<strong class="bold">class FileServer(Server):</strong>
    def __init__(self):
        self.name = "FileServer"
        self.state = State.NEW
    def boot(self):
        print(f"booting the {self}")
        self.state = State.RUNNING
    def kill(self, restart=True):
        print(f"Killing {self}")
        self.state = (
            State.RESTART if restart else State.ZOMBIE
        )
    def create_file(self, user, name, perms):
        msg = (
            f"trying to create file '{name}' "
            f"for user '{user}' "
            f"with permissions {perms}"
        )
        print(msg)</pre>			<p>The <code>ProcessServer</code> class<a id="_idIndexMarker313"/> is as<a id="_idIndexMarker314"/> follows:</p>
			<pre class="source-code">
<strong class="bold">class ProcessServer(Server)</strong>:
    def __init__(self):
        self.name = "ProcessServer"
        self.state = State.NEW
    def boot(self):
        print(f"booting the {self}")
        self.state = State.RUNNING
    def kill(self, restart=True):
        print(f"Killing {self}")
        self.state = (
            State.RESTART if restart else State.ZOMBIE
        )
    def create_process(self, user, name):
        msg = (
            f"trying to create process '{name}' "
            f"for user '{user}'"
        )
        print(msg)</pre>			<p>The <code>OperatingSystem</code> class is a facade. In its <code>__init__()</code>, all the necessary server<a id="_idIndexMarker315"/> instances are created. The <code>start()</code> method, used by the client code, is the <a id="_idIndexMarker316"/>entry point to the system. More wrapper methods can be added, if necessary, as access points to the services of the servers, such as the wrappers, <code>create_file()</code> and <code>create_process()</code>. From the client’s point of view, all those services are provided by the <code>OperatingSystem</code> class. The client should not be confused by unnecessary details such as the existence of servers and the responsibility of each server.</p>
			<p>The code for the <code>OperatingSystem</code> class is as follows:</p>
			<pre class="source-code">
<strong class="bold">class OperatingSystem:</strong>
    """The Facade"""
    def __init__(self):
        self.fs = FileServer()
        self.ps = ProcessServer()
    def start(self):
        [i.boot() for i in (self.fs, self.ps)]
    def create_file(self, user, name, perms):
        return self.fs.create_file(user, name, perms)
    def create_process(self, user, name):
        return self.ps.create_process(user, name)</pre>			<p>As you <a id="_idIndexMarker317"/>are going to see in a minute, when we present a summary of the <a id="_idIndexMarker318"/>example, there are many dummy classes and servers. They are there to give you an idea about the required abstractions (<code>User</code>, <code>Process</code>, <code>File</code>, and so forth) and servers (<code>WindowServer</code>, <code>NetworkServer</code>, and so forth) for making the system functional.</p>
			<p>Finally, we add our main code for testing the design, as follows:</p>
			<pre class="source-code">
def main():
    os = OperatingSystem()
    os.start()
    os.create_file("foo", "hello.txt", "-rw-r-r")
    os.create_process("bar", "ls /tmp")</pre>			<p>We are going to recapitulate the details of our implementation example; the full code is in the <code>ch04/facade.py</code> file:</p>
			<ol>
				<li>We start with the imports we need.</li>
				<li>We define the <code>State</code> constant using <code>Enum</code>, as shown earlier.</li>
				<li>We then add the <code>User</code>, <code>Process</code>, and <code>File</code> classes, which do nothing in this minimal but functional example.</li>
				<li>We define the abstract <code>Server</code> class, as shown earlier.</li>
				<li>We then define the <code>FileServer</code> class and the <code>ProcessServer</code> class, which are both subclasses of <code>Server</code>.</li>
				<li>We add two other dummy classes, <code>WindowServer</code> and <code>NetworkServer</code>.</li>
				<li>Then we define our facade class, <code>OperatingSystem</code>, as shown earlier.</li>
				<li>Finally, we add the main part of the code, where we use the facade we have defined.</li>
			</ol>
			<p>As you can see, executing the <code>python ch04/facade.py</code> command shows the messages produced by our two stub servers:</p>
			<pre class="source-code">
<strong class="bold">booting the FileServer</strong>
<strong class="bold">booting the ProcessServer</strong>
<strong class="bold">trying to create file 'hello.txt' for user 'foo' with permissions -rw-r-r</strong>
<code>OperatingSystem</code> class does a good job. The client code can create files and processes without needing to know internal details about the operating <a id="_idIndexMarker320"/>system, such as the existence of multiple servers. To be precise, the client code can call the methods for creating files and processes, but they are currently dummy. As an interesting exercise, you can implement one of the two methods, or even both.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>The flyweight pattern</h1>
			<p>Whenever we create <a id="_idIndexMarker321"/>a new<a id="_idIndexMarker322"/> object, extra memory needs to be allocated. Although virtual memory provides us, theoretically, with unlimited memory, the reality is different. If all the physical memory of a system gets exhausted, it will start swapping pages with the secondary storage, usually <a id="_idIndexMarker323"/>a <strong class="bold">hard disk drive</strong> (<strong class="bold">HDD</strong>), which, in most cases, is unacceptable due to the performance differences between the main memory and HDD. <strong class="bold">Solid-state drives</strong> (<strong class="bold">SSDs</strong>) generally<a id="_idIndexMarker324"/> have better performance than HDDs, but not everybody is expected to use SSDs. So, SSDs are not going to totally replace HDDs anytime soon.</p>
			<p>Apart<a id="_idIndexMarker325"/> from memory usage, performance is also a consideration. Graphics <a id="_idIndexMarker326"/>software, including computer games, should be able to render 3-D information (for example, a forest with thousands of trees, a village full of soldiers, or an urban area with a lot of cars) extremely quickly. If each object in a 3-D terrain is created individually and no data sharing is used, the performance will be prohibitive.</p>
			<p>As software engineers, we should solve software problems by writing better software, instead of forcing the customer to buy extra or better hardware. The <strong class="bold">flyweight</strong> design pattern is a technique used to minimize memory usage and improve performance by introducing data sharing between similar objects. A flyweight is a shared object that contains state-independent, immutable (also known <a id="_idIndexMarker327"/>as <strong class="bold">intrinsic</strong>) data. The state-dependent, mutable (also known <a id="_idIndexMarker328"/>as <strong class="bold">extrinsic</strong>) data should not be part of flyweight because this is information that cannot be shared, since it differs per object. If flyweight needs extrinsic data, it should be provided explicitly by the client code.</p>
			<p>An example might help to clarify how the flyweight pattern can be used practically. Let’s assume that we are creating a performance-critical game – for example, a <strong class="bold">first-person shooter</strong> (<strong class="bold">FPS</strong>). In FPS <a id="_idIndexMarker329"/>games, the players (soldiers) share some states, such as representation and behavior. In <em class="italic">Counter-Strike</em>, for instance, all soldiers on the same team (counter-terrorists versus terrorists) look the same (representation). In the same game, all soldiers (on both teams) have some common actions, such as jump, duck, and so forth (behavior). This means that we can create a flyweight that will contain all of the common data. Of course, the soldiers also have a lot of data that is different per soldier and will not be a part of the flyweight, such as weapons, health, location, and so on.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Real-world examples</h2>
			<p>Flyweight is an optimization design<a id="_idIndexMarker330"/> pattern; therefore, it is not easy to find a good non-computing example of it. We can think of flyweight as caching in real life. For example, many bookstores have dedicated shelves with the newest and most popular publications. This is a cache. First, you can take a look at the dedicated shelves for the book you are looking for, and if you cannot find it, you can ask the bookseller to assist you.</p>
			<p>The<a id="_idIndexMarker331"/> Exaile music player uses flyweight to reuse objects (in this case, music tracks) that are identified by the same URL. There’s no point in creating a new object if it has the same URL as an existing object, so the same object is reused to save resources.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Use cases for the flyweight pattern</h2>
			<p>Flyweight<a id="_idIndexMarker332"/> is all about improving <a id="_idIndexMarker333"/>performance and memory usage. All embedded systems (phones, tablets, games consoles, microcontrollers, and so forth) and performance-critical applications (games, 3-D graphics processing, real-time systems, and so forth) can benefit from it.</p>
			<p>The <em class="italic">Gang of Four</em> (<em class="italic">GoF</em>) book lists the following requirements that need to be satisfied to effectively use the flyweight pattern:</p>
			<ul>
				<li>The application needs to use a large number of objects.</li>
				<li>There are so many objects that it’s too expensive to store/render them. Once the mutable state is removed (because if it is required, it should be passed explicitly to flyweight by the client code), many groups of distinct objects can be replaced by relatively few shared objects.</li>
				<li>Object identity is not important for the application. We cannot rely on object identity because object sharing causes identity comparisons to fail (objects that appear different to the <a id="_idIndexMarker334"/>client code end up having the same identity).</li>
			</ul>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor112"/>Implementing the flyweight pattern</h2>
			<p>Let’s see how we can implement<a id="_idIndexMarker335"/> an example featuring cars in an area. We will create a small car park to illustrate the idea, making sure that the whole output is readable in a single terminal page. However, no matter how large you make the car park, the memory allocation stays the same.</p>
			<p class="callout-heading">Memoization versus the flyweight pattern</p>
			<p class="callout">Memoization is an optimization technique that uses a cache to avoid recomputing results that were already computed in an earlier execution step. Memoization does not focus on a specific programming paradigm<a id="_idIndexMarker336"/> such as <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). In Python, memoization can be applied to both class methods and simple functions.</p>
			<p class="callout">Flyweight is an OOP-specific optimization design pattern that focuses on sharing object data.</p>
			<p>Let’s get <a id="_idIndexMarker337"/>started with<a id="_idIndexMarker338"/> the code for this example.</p>
			<p>First, we need an <code>Enum</code> parameter that describes the three different types of car that are in the car park:</p>
			<pre class="source-code">
CarType = Enum(
    "CarType", "SUBCOMPACT COMPACT SUV"
)</pre>			<p>Then, we will define the class at the core of our implementation: <code>Car</code>. The <code>pool</code> variable is the object pool (in other words, our cache). Notice that <code>pool</code> is a class attribute (a variable shared by all instances).</p>
			<p>Using the <code>__new__()</code> special method, which is called before <code>__init__()</code>, we are converting the <code>Car</code> class to a metaclass that supports self-references. This means that <code>cls</code> references the <code>Car</code> class. When the client code creates an instance of <code>Car</code>, they pass the type of the car as <code>car_type</code>. The type of the car is used to check whether a car of the same type has already been created. If that’s the case, the previously created object is returned; otherwise, the new car type is added to the pool and returned:</p>
			<pre class="source-code">
class Car:
    pool = dict()
    def __new__(cls, car_type):
        obj = cls.pool.get(car_type, None)
        if not obj:
            obj = object.__new__(cls)
            cls.pool[car_type] = obj
            obj.car_type = car_type
        return obj</pre>			<p>The <code>render()</code> method<a id="_idIndexMarker339"/> is what will be used to render a car on the screen. Notice<a id="_idIndexMarker340"/> how all the mutable information not known by flyweight needs to be explicitly passed by the client code. In this case, random <code>color</code> and the coordinates of a location (of form <code>x</code>, <code>y</code>) are used for each car.</p>
			<p>Also, note that to make <code>render()</code> more useful, it is necessary to ensure that no cars are rendered on top of each other. Consider this as an exercise. If you want to make rendering more fun, you can use a graphics toolkit such as Tkinter, Pygame, or Kivy.</p>
			<p>The <code>render()</code> method is defined as follows:</p>
			<pre class="source-code">
    def render(self, color, x, y):
        type = self.car_type
        msg = f"render a {color} {type.name} car at ({x}, {y})"
        print(msg)</pre>			<p>The <code>main()</code> function shows how we can use the flyweight pattern. The color of a car is a random value from a predefined list of colors. The coordinates use random values between 1 and 100. Although 18 cars are rendered, memory is allocated only for 3. The last line of the output proves that when using flyweight, we cannot rely on object identity. The <code>id()</code> function returns the memory address of an object. This is not the default behavior in Python because, by default, <code>id()</code> returns a unique ID (actually the memory address of an object as an integer) for each object. In our case, even if two objects appear to be different, they actually have the same identity if they belong to the same <code>car_type</code>). Of course, different identity comparisons can still be used for objects of different families, but that is possible only if the client knows the implementation details.</p>
			<p>Our example <code>main()</code> function’s code is as follows:</p>
			<pre class="source-code">
def main():
    rnd = random.Random()
    colors = [
        "white",
        "black",
        "silver",
        "gray",
        "red",
        "blue",
        "brown",
        "beige",
        "yellow",
        "green",
    ]
    min_point, max_point = 0, 100
    car_counter = 0
    for _ in range(10):
        c1 = Car(CarType.SUBCOMPACT)
        c1.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    for _ in range(3):
        c2 = Car(CarType.COMPACT)
        c2.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    for _ in range(5):
        c3 = Car(CarType.SUV)
        c3.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    print(f"cars rendered: {car_counter}")
    print(
        f"cars actually created: {len(Car.pool)}"
    )
    c4 = Car(CarType.SUBCOMPACT)
    c5 = Car(CarType.SUBCOMPACT)
    c6 = Car(CarType.SUV)
    print(
        f"{id(c4)} == {id(c5)}? {id(c4) == id(c5)}"
    )
    print(
        f"{id(c5)} == {id(c6)}? {id(c5) == id(c6)}"
    )</pre>			<p>Here is the<a id="_idIndexMarker341"/> recapitulation of <a id="_idIndexMarker342"/>the full code listing (the <code>ch04/flyweight.py</code> file) to show you how the flyweight pattern is implemented and used:</p>
			<ol>
				<li>We need a couple of imports: <code>random</code> and <code>Enum</code> (from the <code>enum</code> module).</li>
				<li>We define <code>Enum</code> for the types of cars.</li>
				<li>Then we have the <code>Car</code> class, with its <code>pool</code> attribute and the <code>__new__()</code> and <code>render()</code> methods.</li>
				<li>In the first part of the <code>main</code> function, we define some variables and render a set of subcompact cars.</li>
				<li>The second part of the <code>main</code> function.</li>
				<li>The third part of the <code>main</code> function.</li>
				<li>Finally, we add the fourth part of the <code>main</code> function.</li>
			</ol>
			<p>The execution of the <code>python ch04/flyweight.py</code> command shows the type, random color, and coordinates of the rendered objects, as well as the identity comparison results between flyweight objects of the same/different families:</p>
			<pre class="console">
render a gray SUBCOMPACT car at (25, 79)
render a black SUBCOMPACT car at (31, 99)
render a brown SUBCOMPACT car at (16, 74)
render a green SUBCOMPACT car at (10, 1)
render a gray SUBCOMPACT car at (55, 38)
render a red SUBCOMPACT car at (30, 45)
render a brown SUBCOMPACT car at (17, 78)
render a gray SUBCOMPACT car at (14, 21)
render a gray SUBCOMPACT car at (7, 28)
render a gray SUBCOMPACT car at (22, 50)
render a brown COMPACT car at (75, 26)
render a red COMPACT car at (22, 61)
render a white COMPACT car at (67, 87)
render a beige SUV car at (23, 93)
render a white SUV car at (37, 100)
render a red SUV car at (33, 98)
render a black SUV car at (77, 22)
render a green SUV car at (16, 51)
cars rendered: 18
cars actually created: 3
4493672400 == 4493672400? True
4493672400 == 4493457488? False</pre>			<p>Do not <a id="_idIndexMarker343"/>expect to see the same output since the colors and<a id="_idIndexMarker344"/> coordinates are random, and the object identities depend on the memory map.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/>The proxy pattern</h1>
			<p>The <strong class="bold">proxy</strong> design pattern<a id="_idIndexMarker345"/> gets its <a id="_idIndexMarker346"/>name from the <em class="italic">proxy</em> (also known <a id="_idIndexMarker347"/>as <strong class="bold">surrogate</strong>) object used to perform an important action before accessing the actual object. There are four well-known types of proxy. They are as follows:</p>
			<ol>
				<li>A <strong class="bold">virtual proxy</strong>, which<a id="_idIndexMarker348"/> uses <strong class="bold">lazy initialization</strong> to defer<a id="_idIndexMarker349"/> the creation of a computationally expensive object until the moment it is actually needed.</li>
				<li>A <strong class="bold">protection/protective proxy</strong>, which <a id="_idIndexMarker350"/>controls access to a sensitive object.</li>
				<li>A <strong class="bold">remote proxy</strong>, which <a id="_idIndexMarker351"/>acts as the local representation of an object that really exists in a different address space (for example, a network server).</li>
				<li>A <strong class="bold">smart (reference) proxy</strong>, which <a id="_idIndexMarker352"/>performs extra actions when an object is accessed. Examples of such actions are reference counting <a id="_idIndexMarker353"/>and thread-safety checks.</li>
			</ol>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor114"/>Real-world examples</h2>
			<p><strong class="bold">Chip</strong> cards<a id="_idIndexMarker354"/> offer a good <a id="_idIndexMarker355"/>example of how a protective proxy is used in real life. The debit/credit card contains a chip that first needs to be read by the ATM or card reader. After the chip is verified, a password (PIN) is required to complete the transaction. This means that you cannot make any transactions without physically presenting the card and knowing the PIN.</p>
			<p>A bank check that is used instead of cash to make purchases and deals is an example of a remote proxy. The check gives access to a bank account.</p>
			<p>In software, the <code>weakref</code> module of Python contains a <code>proxy()</code> method that accepts an input object and returns a smart proxy to it. Weak references are the recommended way to add reference-counting support to an object.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor115"/>Use cases for the proxy pattern</h2>
			<p>Since there are at least<a id="_idIndexMarker356"/> four common proxy types, the proxy design pattern has many use cases.</p>
			<p>This pattern is used when creating a distributed system using either a private network or the cloud. In a distributed system, some objects exist in the local memory and some objects exist in the memory of remote computers. If we don’t want the client code to be aware of such differences, we can create a remote proxy that hides/encapsulates them, making the distributed nature of the application transparent.</p>
			<p>The proxy pattern is also handy when our application is suffering from performance issues due to the early creation of expensive objects. Introducing lazy initialization using a virtual proxy to create the objects only when they are required can give us significant performance improvements.</p>
			<p>As a third case, this pattern<a id="_idIndexMarker357"/> is used to check whether a user has sufficient privileges to access a piece of information. If our application handles sensitive information (for example, medical data), we want to ensure that the user trying to access/modify it can do so. A protection/protective proxy can handle all security-related actions.</p>
			<p>This pattern is used when our application (or library, toolkit, framework, and so forth) uses multiple threads and we want to move the burden of thread safety from the client code to the application. In this case, we can create a smart proxy to hide the thread-safety complexities from the client.</p>
			<p>An <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) API<a id="_idIndexMarker358"/> is also an example of how to use a remote proxy. Many popular web frameworks (Django, Flask, FastAPI...) use an <a id="_idIndexMarker359"/>ORM to provide OOP-like access to a relational database. An ORM acts as a proxy to a relational database that can be located anywhere, either at a local or remote server.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor116"/>Implementing the proxy pattern – a virtual proxy</h2>
			<p>There are many ways to create a <a id="_idIndexMarker360"/>virtual proxy in Python, but I always like focusing<a id="_idIndexMarker361"/> on the idiomatic/Pythonic implementations. The code shown here is based on the great answer by Cyclone, a user of the <a href="http://stackoverflow.com">stackoverflow.com</a> site, to the question about "Python memoising/deferred lookup property decorator."</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this section, the terms <em class="italic">property</em>, <em class="italic">variable</em>, and <em class="italic">attribute</em> are used interchangeably.</p>
			<p>First, we create a <code>LazyProperty</code> class that can be used as a decorator. When it decorates a property, <code>LazyProperty</code> loads the property lazily (on the first use) instead of instantly. The <code>__init__()</code> method creates two variables that are used as aliases to the method that initializes a property: <code>method</code> is an alias to the actual method, and <code>method_name</code> is an alias to the method’s name. To get a better understanding of how the two aliases are used, print their value to the output (uncomment the two<a id="_idIndexMarker362"/> commented<a id="_idIndexMarker363"/> lines in that part of the code):</p>
			<pre class="source-code">
<strong class="bold">class LazyProperty:</strong>
    def __init__(self, method):
        self.method = method
        self.method_name = method.__name__
        # print(f"function overriden: {self.method}")
        # print(f"function's name: {self.method_name}")</pre>			<p>The <code>LazyProperty</code> class is actually a descriptor. Descriptors are the recommended mechanisms to use in Python to override the default behavior of its attribute access methods: <code>__get__()</code>, <code>__set__()</code>, and <code>__delete__()</code>. The <code>LazyProperty</code> class overrides only <code>__set__()</code> because that is the only access method it needs to override. In other words, we don’t have to override all access methods. The <code>__get__()</code> method accesses the value of the property the underlying method wants to assign, and uses <code>setattr()</code> to do the assignment manually. What <code>__get()__</code> actually does is very neat: it replaces the method with the value! This means that not only is the property lazily loaded, but<a id="_idIndexMarker364"/> it can also be set only once. We will see what this means in a moment.</p>
			<pre class="source-code">
    def __get__(self, obj, cls):
        if not obj:
            return None
        value = self.method(obj)
        # print(f'value {value}')
        setattr(obj, self.method_name, value)
        return value</pre>			<p>Again, uncomment the commented line in that part of the code to get some extra information.</p>
			<p>Then, the <code>Test</code> class shows how we can use the <code>LazyProperty</code> class. There are three attributes: <code>x</code>, <code>y</code>, and <code>_resource</code>. We want the <code>_resource</code> variable to be loaded lazily; thus, we initialize it to <code>None</code> as shown in the following code:</p>
			<pre class="source-code">
class Test:
    def __init__(self):
        self.x = "foo"
        self.y = "bar"
        self._resource = None</pre>			<p>The <code>resource()</code> method<a id="_idIndexMarker365"/> is decorated with the <code>LazyProperty</code> class. For demonstration purposes, the <code>LazyProperty</code> class initializes the <code>_resource</code> attribute <a id="_idIndexMarker366"/>as a tuple, as shown in the following code. Normally, this<a id="_idIndexMarker367"/> would be a slow/expensive initialization (database, graphics, and so on):</p>
			<pre class="source-code">
    @LazyProperty
    def resource(self):
        print("initializing self._resource...")
        print(f"... which is: {self._resource}")
        self._resource = tuple(range(5))
        return self._resource</pre>			<p>The <code>main()</code> function, as follows, shows how lazy initialization behaves:</p>
			<pre class="source-code">
def main():
    t = Test()
    print(t.x)
    print(t.y)
    # do more work...
    print(t.resource)
    print(t.resource)</pre>			<p>Notice how overriding the <code>__get()__</code> access method makes it possible to treat the <code>resource()</code> method as a simple attribute (we can use <code>t.resource</code> instead of <code>t.resource()</code>).</p>
			<p>Let’s recapitulate the <a id="_idIndexMarker368"/>example code (in <code>ch04/proxy/proxy_lazy.py</code>):</p>
			<ol>
				<li>We define the <code>LazyProperty</code> class.</li>
				<li>We define the <code>Test</code> class with a <code>resource()</code> method that we decorate using <code>LazyProperty</code>.</li>
				<li>We add the main<a id="_idIndexMarker369"/> function for testing our design <a id="_idIndexMarker370"/>example.</li>
			</ol>
			<p>If you can execute the example in its original version (where the added lines for better understanding are kept commented), using the <code>python ch04/proxy/proxy_lazy.py</code> command, you will get the following output:</p>
			<pre class="source-code">
<strong class="bold">foo</strong>
<strong class="bold">bar</strong>
<strong class="bold">initializing self._resource...</strong>
<strong class="bold">... which is: None</strong>
<strong class="bold">(0, 1, 2, 3, 4)</strong>
<strong class="bold">(0, 1, 2, 3, 4)</strong></pre>			<p>Based on this output, we can see the following:</p>
			<ul>
				<li>The <code>_resource</code> variable is indeed initialized not by the time the <code>t</code> instance is created, but the first time that we use <code>t.resource</code>.</li>
				<li>The second time <code>t.resource</code> is used, the variable is not initialized again. That’s why the initialization string initializing <code>self._resource</code> is shown only once.</li>
			</ul>
			<p class="callout-heading">Additional information</p>
			<p class="callout">There are two basic kinds of lazy initialization in OOP. They are as follows:</p>
			<p class="callout">- <strong class="bold">At the instance level</strong>: This means that an object’s property is initialized lazily, but the property has an object scope. Each instance (object) of the same class has its own (different) copy of the property.</p>
			<p class="callout">- <strong class="bold">At the class or module level</strong>: In this case, we do not want a different copy per instance, but all the instances share the same property, which is lazily initialized. This case is not covered in this chapter. If you find it interesting, consider it as an exercise.</p>
			<p>Since there are so <a id="_idIndexMarker371"/>many possible <a id="_idIndexMarker372"/>cases for using the proxy pattern, let’s see<a id="_idIndexMarker373"/> another example.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor117"/>Implementing the proxy pattern – a protection proxy</h2>
			<p>As a second example, let’s implement a simple <a id="_idIndexMarker374"/>protection proxy to view and add users. The service provides two options:</p>
			<ul>
				<li><strong class="bold">Viewing the list of users</strong>: This operation does not require special privileges</li>
				<li><strong class="bold">Adding a new user</strong>: This operation requires the client to provide a special secret message</li>
			</ul>
			<p>The <code>SensitiveInfo</code> class contains the information that we want to protect. The <code>users</code> variable is the list of existing users. The <code>read()</code> method prints the list of the users. The <code>add()</code> method adds a new user to the list. The code for that class is as follows:</p>
			<pre class="source-code">
<strong class="bold">class SensitiveInfo</strong>:
    def __init__(self):
        self.users = ["nick", "tom", "ben", "mike"]
    def read(self):
        nb = len(self.users)
        print(f"There are {nb} users: {' '.join(self.users)}")
    def add(self, user):
        self.users.append(user)
        print(f"Added user {user}")</pre>			<p>The <code>Info</code> class is a protection proxy of <code>SensitiveInfo</code>. The secret variable is the message required to be known/provided by the client code to add a new user.</p>
			<p>Note that this is just an example. In reality, you should never do the following:</p>
			<ul>
				<li>Store passwords in the source code</li>
				<li>Store passwords in clear-text form</li>
				<li>Use a weak (for example, MD5) or custom form of encryption</li>
			</ul>
			<p>In the <code>Info</code> class, as we<a id="_idIndexMarker375"/> can see next, the <code>read()</code> method is a <a id="_idIndexMarker376"/>wrapper to <code>SensitiveInfo.read()</code> and the <code>add()</code> method ensures that a new user can be added only if the client code knows<a id="_idIndexMarker377"/> the secret message:</p>
			<pre class="source-code">
<strong class="bold">class Info:</strong>
    def __init__(self):
        self.protected = SensitiveInfo()
        self.secret = "0xdeadbeef"
    def read(self):
        self.protected.read()
    def add(self, user):
        sec = input("what is the secret? ")
        if sec == self.secret:
            self.protected.add(user)
        else:
            print("That's wrong!")</pre>			<p>The <code>main()</code> function <a id="_idIndexMarker378"/>shows how the proxy pattern can be used by the <a id="_idIndexMarker379"/>client code. The client code creates an instance of<a id="_idIndexMarker380"/> the <code>Info</code> class and uses the displayed menu to read the list, add a new user, or exit the application. Let’s consider the following code:</p>
			<pre class="source-code">
def main():
    info = Info()
    while True:
        print("1. read list |==| 2. add user |==| 3. quit")
        key = input("choose option: ")
        if key == "1":
            info.read()
        elif key == "2":
            name = input("choose username: ")
            info.add(name)
        elif key == "3":
            exit()
        else:
            print(f"unknown option: {key}")</pre>			<p>Let’s recapitulate the full code (<code>ch04/proxy/proxy_protection.py</code>):</p>
			<ol>
				<li>First, we define the <code>SensitiveInfo</code> class.</li>
				<li>Then, we have the code for the <code>Info</code> class.</li>
				<li>Finally, we add the main function with our testing code.</li>
			</ol>
			<p>We can see in the following a sample output of the program when executing the <code>python </code><code>ch04/proxy/proxy_protection.py</code> command:</p>
			<pre class="source-code">
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 1</strong>
<strong class="bold">There are 4 users: nick tom ben mike</strong>
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 2</strong>
<strong class="bold">choose username: tom</strong>
<strong class="bold">what is the secret? 0xdeadbeef</strong>
<strong class="bold">Added user tom</strong>
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 3</strong></pre>			<p>Have you already spotted flaws or missing features that can be addressed to improve our protection proxy example? Here are a few suggestions:</p>
			<ul>
				<li>This example has a very <a id="_idIndexMarker381"/>big security flaw. Nothing <a id="_idIndexMarker382"/>prevents the client code from bypassing the<a id="_idIndexMarker383"/> security of the application by creating an instance of <code>SensitiveInfo</code> directly. Improve the example to prevent this situation. One way is to use the <code>abc</code> module to forbid direct instantiation of <code>SensitiveInfo</code>. What other code changes are required in this case?</li>
				<li>A basic security rule is that we should never store clear-text passwords. Storing a password safely is not very hard as long as we know which libraries to use. If you have an interest in security, try to implement a secure way to store the secret message externally (for example, in a file or database).</li>
				<li>The application <a id="_idIndexMarker384"/>only supports adding new users, but what<a id="_idIndexMarker385"/> about removing an existing user? Add a <code>remove()</code> method.</li>
			</ul>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor118"/>Implementing the proxy pattern – a remote proxy</h2>
			<p>Imagine we are building a <a id="_idIndexMarker386"/>file management system where<a id="_idIndexMarker387"/> clients can perform operations on files stored on a remote server. The operations might include reading a file, writing to a file, and deleting a file. The remote proxy hides the complexity of network requests from the client.</p>
			<p>We start by creating an interface that defines the operations that can be performed on the remote server, <code>RemoteServiceInterface</code>, and the class that implements it to provide the actual service, <code>RemoteService</code>.</p>
			<p>The interface is defined as follows:</p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class RemoteServiceInterface(ABC):
    @abstractmethod
    def read_file(self, file_name):
        pass
    @abstractmethod
    def write_file(self, file_name, contents):
        pass
    @abstractmethod
    def delete_file(self, file_name):
        pass</pre>			<p>The <code>RemoteService</code> class <a id="_idIndexMarker388"/>is defined as follows (the methods just return a string, for <a id="_idIndexMarker389"/>the sake of simplicity, but normally, you would have specific code for the file handling on the remote service):</p>
			<pre class="source-code">
class RemoteService(RemoteServiceInterface):
    def read_file(self, file_name):
        # Implementation for reading a file from the server
        return "Reading file from remote server"
    def write_file(self, file_name, contents):
        # Implementation for writing to a file on the server
        return "Writing to file on remote server"
    def delete_file(self, file_name):
        # Implementation for deleting a file from the server
        return "Deleting file from remote server"</pre>			<p>Then, we define <code>ProxyService</code> for the proxy. It implements the <code>RemoteServiceInterface</code> interface and acts as a surrogate for <code>RemoteService</code>, which handles <a id="_idIndexMarker390"/>communication with the latter:</p>
			<pre class="source-code">
class ProxyService(RemoteServiceInterface):
    def __init__(self):
        self.remote_service = RemoteService()
    def read_file(self, file_name):
        print("Proxy: Forwarding read request to RemoteService")
        return self.remote_service.read_file(file_name)
    def write_file(self, file_name, contents):
        print("Proxy: Forwarding write request to RemoteService")
        return self.remote_service.write_file(file_name, contents)
    def delete_file(self, file_name):
        print("Proxy: Forwarding delete request to RemoteService")
        return self.remote_service.delete_file(file_name)</pre>			<p>Clients interact with the <code>ProxyService</code> component as if it were the <code>RemoteService</code> one, unaware of the remote nature of the actual service. The proxy handles the communication with the remote service, potentially adding logging, access control, or caching. To test<a id="_idIndexMarker391"/> things, we<a id="_idIndexMarker392"/> can add<a id="_idIndexMarker393"/> the following code, based on creating an instance of <code>ProxyService</code>:</p>
			<pre class="source-code">
if __name__ == "__main__":
    proxy = ProxyService()
    print(proxy.read_file("example.txt"))</pre>			<p>Let’s recapitulate the implementation (the full code is in <code>ch04/proxy/proxy_remote.py</code>):</p>
			<ol>
				<li>We start by defining the interface, <code>RemoteServiceInterface</code>, and a class that implements it, <code>RemoteService</code>.</li>
				<li>Then, we define the <code>ProxyService</code> class, which also implements the <code>RemoteService</code><code> </code><code>Interface</code> interface.</li>
				<li>Finally, we add some code for testing the proxy object.</li>
			</ol>
			<p>Let’s see the result of the example by running <code>python ch04/proxy/proxy_remote.py</code>:</p>
			<pre class="source-code">
<strong class="bold">Proxy: Forwarding read request to RemoteService</strong>
<strong class="bold">Reading file from remote server</strong></pre>			<p>It worked. This <a id="_idIndexMarker394"/>lightweight example was effective in showing how to<a id="_idIndexMarker395"/> implement the remote proxy use case.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor119"/>Implementing the proxy pattern – a smart proxy</h2>
			<p>Let’s consider a scenario<a id="_idIndexMarker396"/> where you have a shared resource in your<a id="_idIndexMarker397"/> application, such as a database connection. Every time an object accesses this resource, you want to keep track of how many references to the resource exist. Once there are no more references, the resource can be safely released or closed. A smart proxy will help manage the reference counting for this database connection, ensuring it’s only closed once all references to it are released.</p>
			<p>As in the previous example, we will need an interface, <code>DBConnectionInterface</code>, defining operations for accessing the database, and a class that represents the actual database connection, <code>DBConnection</code>.</p>
			<p>For the interface, let’s use <code>Protocol</code> (to change from the <code>ABC</code> way):</p>
			<pre class="source-code">
from typing import Protocol
class DBConnectionInterface(Protocol):
    def exec_query(self, query):
        ...</pre>			<p>The class for the database connection is as follows:</p>
			<pre class="source-code">
class DBConnection:
    def __init__(self):
        print("DB connection created")
    def exec_query(self, query):
        return f"Executing query: {query}"
    def close(self):
        print("DB connection closed")</pre>			<p>Then, we define the <code>SmartProxy</code> class; it also implements the <code>DBConnectionInterface</code> interface (see the <code>exec_query()</code> method). We use this class to manage reference counting and access to the <code>DBConnection</code> object. It ensures that the <code>DBConnection</code> object is created on demand when the first query is executed and is only closed when there are <a id="_idIndexMarker398"/>no more<a id="_idIndexMarker399"/> references to it. The <a id="_idIndexMarker400"/>code is as follows:</p>
			<pre class="source-code">
class SmartProxy:
    def __init__(self):
        self.cnx = None
        self.ref_count = 0
    def access_resource(self):
        if self.cnx is None:
            self.cnx = DBConnection()
        self.ref_count += 1
        print(f"DB connection now has {self.ref_count} references.")
    def exec_query(self, query):
        if self.cnx is None:
            # Ensure the connection is created
            # if not already
            self.access_resource()
        result = self.cnx.exec_query(query)
        print(result)
        # Decrement reference count after
        # executing query
        self.release_resource()
        return result
    def release_resource(self):
        if self.ref_count &gt; 0:
            self.ref_count -= 1
            print("Reference released...")
            print(f"{self.ref_count} remaining refs.")
        if self.ref_count == 0 and self.cnx is not None:
            self.cnx.close()
            self.cnx = None</pre>			<p>Now, we can add some <a id="_idIndexMarker401"/>code to <a id="_idIndexMarker402"/>test the <a id="_idIndexMarker403"/>implementation:</p>
			<pre class="source-code">
if __name__ == "__main__":
    proxy = SmartProxy()
    proxy.exec_query("SELECT * FROM users")
    proxy.exec_query("UPDATE users SET name = 'John Doe' WHERE id = 1")</pre>			<p>Let’s recapitulate the implementation (the full code is in <code>ch04/proxy/proxy_smart.py</code>):</p>
			<ol>
				<li>We start by defining<a id="_idIndexMarker404"/> the interface, <code>DBConnectionInterface</code>, and a class that implements it and represents the database connection, <code>DBConnection</code>.</li>
				<li>Then, we define the <code>SmartProxy</code> class, which also implements <code>DBConnectionInterface</code>.</li>
				<li>Finally, we add some code for testing the proxy object.</li>
			</ol>
			<p>Let’s see the result of the example by running <code>python ch04/proxy/proxy_smart.py</code>:</p>
			<pre class="source-code">
<strong class="bold">DB connection created</strong>
<strong class="bold">DB connection now has 1 references.</strong>
<strong class="bold">Executing query: SELECT * FROM users</strong>
<strong class="bold">Reference released...</strong>
<strong class="bold">0 remaining refs.</strong>
<strong class="bold">DB connection closed</strong>
<strong class="bold">DB connection created</strong>
<strong class="bold">DB connection now has 1 references.</strong>
<strong class="bold">Executing query: UPDATE users SET name = 'John Doe' WHERE id = 1</strong>
<strong class="bold">Reference released...</strong>
<strong class="bold">0 remaining refs.</strong>
<strong class="bold">DB connection closed</strong></pre>			<p>This was another <a id="_idIndexMarker405"/>demonstration of the proxy pattern. Here, it <a id="_idIndexMarker406"/>helped us implement an improved solution for <a id="_idIndexMarker407"/>scenarios where database connections are shared across different parts of an application and need to be managed carefully to avoid exhausting database resources or leaking connections.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor120"/>Summary</h1>
			<p>Structural patterns are invaluable for creating clean, maintainable, and scalable code. They provide solutions for many of the challenges you’ll face in daily coding.</p>
			<p>First, the adapter pattern serves as a flexible solution for harmonizing mismatched interfaces. We can use this pattern to bridge the gap between outdated legacy systems and modern interfaces, thus promoting more cohesive and manageable software systems.</p>
			<p>Then, we discussed the decorator pattern that we use as a convenient way of extending the behavior of an object without using inheritance. Python, with its built-in decorator feature, extends the decorator concept even more by allowing us to extend the behavior of any callable without using inheritance or composition. The decorator pattern is a great solution for implementing cross-cutting concerns because they are generic and do not fit well into the OOP paradigm. We mentioned several categories of cross-cutting concerns in the <em class="italic">Use cases for the decorator pattern</em> section. We saw how decorators can help us to keep our functions clean without sacrificing performance.</p>
			<p>Sharing similarities with the adapter pattern, the bridge pattern is different from it in the sense that it is used up-front to define an abstraction and its implementation in a decoupled way so that both can vary independently. The bridge pattern is useful when writing software for problem domains such as operation systems and device drivers, GUIs, and website builders where we have multiple themes and we need to change the theme of a website based on certain properties. We discussed an example in the domain of content extraction and management, where we defined an interface for the abstraction, an interface for the implementor, and two implementations.</p>
			<p>The facade pattern is ideal for providing a simple interface to client code that wants to use a complex system but does not need to be aware of the system’s complexity. A computer is a facade, since all we need to do to use it is press a single button to turn it on. All the rest of the hardware complexity is handled transparently by the BIOS, the boot loader, and the other components of the system software. There are more real-life examples of facade, such as when we are connected to the customer service department of a bank or a company, and the keys that we use to turn a vehicle on. We covered an implementation of the interface used by a multi-server operating system.</p>
			<p>In general, we use the flyweight pattern when an application needs to create a large number of computationally expensive objects that share many properties. The important point is to separate the immutable (shared) properties from the mutable ones. We saw how to implement a car renderer that supports three different car families. By providing the mutable color and x, y properties explicitly to the <code>render()</code> method, we managed to create only 3 different objects instead of 18. Although that might not seem like a big win, imagine if the cars were 2,000 instead of 18.</p>
			<p>We ended with the proxy pattern. We discussed several use cases of the proxy pattern, including performance, security, and how to offer simple APIs to users. We saw an implementation example for each of the four types of proxy you generally need: virtual proxy, protective proxy, proxy to a remote service, and smart proxy.</p>
			<p>In the next chapter, we will explore behavioral design patterns, patterns that deal with object interconnection and algorithms.</p>
		</div>
	</body></html>