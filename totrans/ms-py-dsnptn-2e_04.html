<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-84" class="chapter-number"><a id="_idTextAnchor088"/>4</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor089"/>Structural Design Patterns</h1>
			<p>In the previous chapter, we covered creational patterns and object-oriented programming patterns that help us with object-creation procedures. The next category of pattern we want to present<a id="_idIndexMarker217"/> is <em class="italic">structural design patterns</em>. A structural design pattern proposes a way of composing objects to provide <span class="No-Break">new functionality.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The <span class="No-Break">adapter pattern</span></li>
				<li>The <span class="No-Break">decorator pattern</span></li>
				<li>The <span class="No-Break">bridge pattern</span></li>
				<li>The <span class="No-Break">facade pattern</span></li>
				<li>The <span class="No-Break">flyweight pattern</span></li>
				<li>The <span class="No-Break">proxy pattern</span></li>
			</ul>
			<p>At the end of this chapter, you will be equipped with the skills to structure your code efficiently and elegantly using structural <span class="No-Break">design patterns.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor090"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>The adapter pattern</h1>
			<p>The <strong class="bold">adapter</strong> pattern <a id="_idIndexMarker218"/>is a structural design pattern that helps us make two incompatible interfaces compatible. What does that really mean? If we have an old component and we want to use it <a id="_idIndexMarker219"/>in a new system, or a new component that we want to use in an old system, the two can rarely communicate without requiring any code changes. But changing the code is not always possible, either because we don’t have access to it, or because it is impractical. In such cases, we can write an extra layer that makes all the required modifications for enabling communication between the two interfaces. This layer is called <a id="_idIndexMarker220"/><span class="No-Break">an </span><span class="No-Break"><strong class="bold">adapter</strong></span><span class="No-Break">.</span></p>
			<p>In general, if you <a id="_idIndexMarker221"/>want to use an interface that expects <strong class="source-inline">function_a()</strong>, but <a id="_idIndexMarker222"/>you only have <strong class="source-inline">function_b()</strong>, you can use an adapter to convert (adapt) <strong class="source-inline">function_b()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">function_a()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>Real-world examples</h2>
			<p>When you are traveling from most<a id="_idIndexMarker223"/> European countries to the UK or the USA, or the other way around, you need to use a plug adapter for charging your laptop. The same kind of adapter is needed for connecting some devices to your computer: the <span class="No-Break">USB adapter.</span></p>
			<p>In the software <a id="_idIndexMarker224"/>category, the <strong class="source-inline">zope.interface</strong> package (<a href="https://pypi.org/project/zope.interface/">https://pypi.org/project/zope.interface/</a>), part of <a id="_idIndexMarker225"/>the <strong class="bold">Zope Toolkit</strong> (<strong class="bold">ZTK</strong>), provides tools that help define interfaces and perform interface adaptation. These tools are used in the core of several<a id="_idIndexMarker226"/> Python web framework projects (including Pyramid <span class="No-Break">and Plone).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">zope.interface</strong> was the solution for working with interfaces in Python, proposed by the team (<a href="https://zope.dev/">https://zope.dev/</a>) behind the Zope application server and the ZTK before Python introduced built-in <a id="_idIndexMarker227"/>mechanisms, with <strong class="bold">abstract base classes</strong> (also called <strong class="bold">ABCs</strong>) first and <span class="No-Break">protocols later.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Use cases for the adapter pattern</h2>
			<p>Usually, one of the two<a id="_idIndexMarker228"/> incompatible interfaces is either foreign or old/legacy. If the interface is foreign, it means that we have no access to the source code. If it is old, it is usually impractical to <span class="No-Break">refactor it.</span></p>
			<p>Using an adapter to make things work after they have been implemented is a good approach because it does not require access to the source code of the foreign interface. It is also often a pragmatic solution if we have to reuse some legacy code. That being said, be aware that it can introduce side effects that are hard to debug. So, use it <span class="No-Break">with caution.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Implementing the adapter pattern – adapt a legacy class</h2>
			<p>Let’s consider an<a id="_idIndexMarker229"/> example where we have a legacy <a id="_idIndexMarker230"/>payment system and a new payment gateway. The adapter<a id="_idIndexMarker231"/> pattern can make them work together without changing the existing code, as we are going <span class="No-Break">to see.</span></p>
			<p>The legacy payment system is implemented using a class, with a <strong class="source-inline">make_payment()</strong> method doing the core of the payment job, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class OldPaymentSystem:
    def __init__(self, currency):
        self.currency = currency
    def make_payment(self, amount):
        print(
            f"[OLD] Pay {amount} {self.currency}"
        )</pre>			<p>The new payment system is implemented using the following class, providing an <span class="No-Break"><strong class="source-inline">execute_payment()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
class NewPaymentGateway:
    def __init__(self, currency):
        self.currency = currency
    def execute_payment(self, amount):
        print(
            f"Execute payment of {amount} {self.currency}"
        )</pre>			<p>Now, we<a id="_idIndexMarker232"/> are going to add a class that will provide the <strong class="bold">adaptation</strong>. Our<a id="_idIndexMarker233"/> adapter class has an attribute <a id="_idIndexMarker234"/>system to store the object representing the payment system we need to adapt, which we call <a id="_idIndexMarker235"/>the <strong class="bold">adaptee</strong>. It also has a <strong class="source-inline">make_payment()</strong> method, where we call the <strong class="source-inline">execute_payment()</strong> method on the adaptee object to get the payment done. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class PaymentAdapter:
    def __init__(self, system):
        self.system = system
    def make_payment(self, amount):
        self.system.execute_payment(amount)</pre>			<p>This is how the <strong class="source-inline">PaymentAdapter</strong> class adapts the interface of <strong class="source-inline">NewPaymentGateway</strong> to match that <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">OldPaymentSystem</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see the result of this <a id="_idIndexMarker236"/>ada<a id="_idTextAnchor095"/>ptation by adding a <strong class="source-inline">main()</strong> function with testing code, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    old_system = OldPaymentSystem("euro")
    print(old_system)
    new_system = NewPaymentGateway("euro")
    print(new_system)
    adapter = PaymentAdapter(new_system)
    adapter.make_payment(100)</pre>			<p>Let’s recapitulate the complete code (see the <strong class="source-inline">ch04</strong><strong class="source-inline">/adapter/adapt_legacy.py</strong> file) of <span class="No-Break">the implementation:</span></p>
			<ol>
				<li>We have some code for the legacy payment system, represented by the <strong class="source-inline">OldPaymentSystem</strong> class, providing a <span class="No-Break"><strong class="source-inline">make_payment()</strong></span><span class="No-Break"> method.</span></li>
				<li>We introduce the new payment system, with the <strong class="source-inline">NewPaymentGateway</strong> class, providing an <span class="No-Break"><strong class="source-inline">execute_payment()</strong></span><span class="No-Break"> method.</span></li>
				<li>We add a class for the adapter, <strong class="source-inline">PaymentAdapter</strong>, which has an attribute to store the payment system object and a <strong class="source-inline">make_payment()</strong> method; in that method, we call the <strong class="source-inline">execute_payment()</strong> method on the payment system object (<span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">self.system.execute_payment(amount)</strong></span><span class="No-Break">).</span></li>
				<li>We add code for testing our interface adaptation design (and call it within the usual <strong class="source-inline">if __name__ == "</strong><span class="No-Break"><strong class="source-inline">__main__"</strong></span><span class="No-Break"> block).</span></li>
			</ol>
			<p>Executing the code, using <strong class="source-inline">python ch04/adapter/adapt_legacy.py</strong>, should give the <span class="No-Break">following output:</span></p>
			<pre class="console">
&lt;__main__.OldPaymentSystem object at 0x10ee58fd0&gt;
&lt;__main__.NewPaymentGateway object at 0x10ee58f70&gt;
Execute payment of 100 euro</pre>			<p>You now <a id="_idIndexMarker237"/>get the idea. This adaptation technique allows us to use the <a id="_idIndexMarker238"/>new payment gateway with existing code that expects the <span class="No-Break">old interface.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor096"/>Implementing the adapter pattern – adapt several classes into a unified interface</h2>
			<p>Let’s look at another <a id="_idIndexMarker239"/>application to illustrate adaptation: a<a id="_idIndexMarker240"/> club’s activities. Our club has two <span class="No-Break">main activities:</span></p>
			<ul>
				<li>Hire talented artists to perform in <span class="No-Break">the club</span></li>
				<li>Organize performances and events to entertain <span class="No-Break">its clients</span></li>
			</ul>
			<p>At the core, we have a <strong class="source-inline">Club</strong> class that represents the club where hired artists perform some evenings. The <strong class="source-inline">organize_performance()</strong> method is the main action that the club can perform. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Club:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the club {self.name}"
    def organize_event(self):
        return "hires an artist to perform"</pre>			<p>Most of the time, our club hires a DJ to perform, but our application should make it possible to organize a diversity of performances: by a musician or music band, by a dancer, a one-man or one-woman show, and <span class="No-Break">so on.</span></p>
			<p>Via our research to try and reuse existing code, we find an open source contributed library that brings us two interesting classes: <strong class="source-inline">Musician</strong> and <strong class="source-inline">Dancer</strong>. In the <strong class="source-inline">Musician</strong> class, the main action is performed by the <strong class="source-inline">play()</strong> method. In the <strong class="source-inline">Dancer</strong> class, it is performed by the <span class="No-Break"><strong class="source-inline">dance()</strong></span><span class="No-Break"> method.</span></p>
			<p>In our example, to <a id="_idIndexMarker241"/>indicate that these two classes are <a id="_idIndexMarker242"/>external, we place them in a separate<a id="_idIndexMarker243"/> module (in the <strong class="source-inline">ch04/adapter/external.py</strong> file). The code includes two classes, <strong class="source-inline">Musician</strong> and <strong class="source-inline">Dancer</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">class Musician:</strong>
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the musician {self.name}"
    def play(self):
        return "plays music"
<strong class="bold">class Dancer:</strong>
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"the dancer {self.name}"
    def dance(self):
        return "does a dance performance"</pre>			<p>The code we are <a id="_idIndexMarker244"/>writing, to use these two classes from the external library, only<a id="_idIndexMarker245"/> knows how to call the <strong class="source-inline">organize_performance()</strong> method (on the <strong class="source-inline">Club</strong> class); it has no idea about the <strong class="source-inline">play()</strong> or <strong class="source-inline">dance()</strong> methods (on the <span class="No-Break">respective classes).</span></p>
			<p>How can we make the code work without changing the <strong class="source-inline">Musician</strong> and <span class="No-Break"><strong class="source-inline">Dancer</strong></span><span class="No-Break"> classes?</span></p>
			<p>Adapters to the rescue! We create a generic <strong class="source-inline">Adapter</strong> class that allows us to adapt a number of objects with different interfaces into one unified interface. The <strong class="source-inline">obj</strong> argument of the <strong class="source-inline">__init__()</strong> method is the object that we want to adapt, and <strong class="source-inline">adapted_methods</strong> is a dictionary<a id="_idIndexMarker246"/> containing key/value pairs matching the method the client calls and the method that should be called. The code for that class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Adapter:
    def __init__(self, obj, adapted_methods):
        self.obj = obj
        self.__dict__.update(adapted_methods)
    def __str__(self):
        return str(self.obj)</pre>			<p>When dealing with the instances of the different classes, we have <span class="No-Break">two cases:</span></p>
			<ul>
				<li>The compatible object that belongs to the <strong class="source-inline">Club</strong> class needs no adaptation. We can treat it <span class="No-Break">as is.</span></li>
				<li>The incompatible objects need to be adapted first, using the <span class="No-Break"><strong class="source-inline">Adapter</strong></span><span class="No-Break"> class.</span></li>
			</ul>
			<p>The result is that the <a id="_idIndexMarker247"/>client code can continue using the known <strong class="source-inline">organize_performance()</strong> method on all objects without the need to be <a id="_idIndexMarker248"/>aware of any interface differences. Consider the following <strong class="source-inline">main()</strong> function <a id="_idIndexMarker249"/>code to prove that the design works <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
def main():
    objects = [
        Club("Jazz Cafe"),
        Musician("Roy Ayers"),
        Dancer("Shane Sparks"),
    ]
    for obj in objects:
        if hasattr(obj, "play") or hasattr(
            obj, "dance"
        ):
            if hasattr(obj, "play"):
                adapted_methods = dict(
                    organize_event=obj.play
                )
            elif hasattr(obj, "dance"):
                adapted_methods = dict(
                    organize_event=obj.dance
                )
            obj = Adapter(obj, adapted_methods)
        print(f"{obj} {obj.organize_event()}")</pre>			<p>Let’s recapitulate the complete code of our adapter pattern implementation (in the <span class="No-Break"><strong class="source-inline">ch04/adapter/adapt_to_unified_interface.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We import <a id="_idIndexMarker250"/>the <strong class="source-inline">Musician</strong> and <strong class="source-inline">Dancer</strong> classes from<a id="_idIndexMarker251"/> the <span class="No-Break"><strong class="source-inline">external</strong></span><span class="No-Break"> module.</span></li>
				<li>We have the <span class="No-Break"><strong class="source-inline">Club</strong></span><span class="No-Break"> class.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">Adapter</strong></span><span class="No-Break"> class.</span></li>
				<li>We add the <strong class="source-inline">main()</strong> function, which we call within the usual <strong class="source-inline">if __name__ == "</strong><span class="No-Break"><strong class="source-inline">__main__"</strong></span><span class="No-Break"> block.</span></li>
			</ol>
			<p>Here is the output when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch04/adapter/adapt_to_unified_interface.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
the club Jazz Cafe hires an artist to perform
the musician Roy Ayers plays music
the dancer Shane Sparks does a dance performance</pre>			<p>As you can see, we managed <a id="_idIndexMarker252"/>to make the <strong class="source-inline">Musician</strong> and <strong class="source-inline">Dancer</strong> classes<a id="_idIndexMarker253"/> compatible with the interface expected by the client code without changing the source code of these <span class="No-Break">external classes.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>The decorator pattern</h1>
			<p>A second interesting <a id="_idIndexMarker254"/>structural pattern to learn about is the <strong class="bold">decorator</strong> pattern, which allows <a id="_idIndexMarker255"/>a programmer to add responsibilities to an object dynamically, and in a transparent manner (without affecting <span class="No-Break">other objects).</span></p>
			<p>There is another reason why this pattern is interesting to us, as you will see in <span class="No-Break">a minute.</span></p>
			<p>As Python developers, we can write decorators in a <strong class="bold">Pythonic</strong> way (meaning using the language’s features), thanks to the built-in <span class="No-Break">decorator feature.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A Python decorator<a id="_idIndexMarker256"/> is a callable (function, method, or class) that gets a <strong class="source-inline">func_in</strong> function object as input and returns another function object, <strong class="source-inline">func_out</strong>. It is a commonly used technique for extending the behavior of a function, method, <span class="No-Break">or class.</span></p>
			<p class="callout">For more details on Python’s decorator feature, see the<a id="_idIndexMarker257"/> official <span class="No-Break">documentation: </span><a href="https://docs.python.org/3/reference/compound_stmts.html#function"><span class="No-Break">https://docs.python.org/3/reference/compound_stmts.html#function</span></a></p>
			<p>But this feature should not be completely new to you. We have already encountered commonly used decorators in previous chapters (<strong class="source-inline">@abstractmethod</strong>, <strong class="source-inline">@property</strong>) and there are several other useful built-in decorators in Python. Now, we are going to learn how to implement and use our <span class="No-Break">own decorators.</span></p>
			<p>Note that there is no one-to-one relationship between the decorator pattern and Python’s decorator feature. Python decorators can actually do much more than the decorator pattern. One of the things they can be used for is to implement the <span class="No-Break">decorator pattern.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Real-world examples</h2>
			<p>The decorator pattern is<a id="_idIndexMarker258"/> generally used for extending the functionality of an object. In everyday life, examples of such extensions are adding a silencer to a gun, using different camera lenses, and <span class="No-Break">so on.</span></p>
			<p>In web frameworks such as Django, which uses decorators a lot, we have decorators that can be used for <span class="No-Break">the following:</span></p>
			<ul>
				<li>Restricting access to views (or HTTP-request-handling functions) based on <span class="No-Break">the request</span></li>
				<li>Controlling the caching behavior on <span class="No-Break">specific views</span></li>
				<li>Controlling compression on a <span class="No-Break">per-view basis</span></li>
				<li>Controlling caching based on specific HTTP <span class="No-Break">request headers</span></li>
				<li>Registering a function as an <span class="No-Break">event subscriber</span></li>
				<li>Protecting a function with a <span class="No-Break">specific permission</span></li>
			</ul>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/>Use cases for the decorator pattern</h2>
			<p>The decorator pattern shines <a id="_idIndexMarker259"/>when used for implementing cross-cutting<a id="_idIndexMarker260"/> concerns, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Data validation</span></li>
				<li><span class="No-Break">Caching</span></li>
				<li><span class="No-Break">Logging</span></li>
				<li><span class="No-Break">Monitoring</span></li>
				<li><span class="No-Break">Debugging</span></li>
				<li><span class="No-Break">Business rules</span></li>
				<li><span class="No-Break">Encryption</span></li>
			</ul>
			<p>In general, all parts of an application that are generic and can be applied to many other parts of it are considered to be <span class="No-Break">cross-cutting concerns.</span></p>
			<p>Another popular <a id="_idIndexMarker261"/>example <a id="_idIndexMarker262"/>of using the decorator pattern is in <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) toolkits. In a GUI toolkit, we want to be able to add features such as borders, shadows, colors, and scrolling to <span class="No-Break">individual components/widgets.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/>Implementing the decorator pattern</h2>
			<p>Python decorators are<a id="_idIndexMarker263"/> generic and very powerful. In this section, we will see how we can <a id="_idIndexMarker264"/>implement a <strong class="bold">memoization</strong> decorator. All recursive functions can benefit from memoization, so let’s try a <strong class="source-inline">number_sum()</strong> function that returns the sum of the first <em class="italic">n</em> numbers. Note that this function is already available in the <strong class="source-inline">math</strong> module as <strong class="source-inline">fsum()</strong>, but let’s pretend it <span class="No-Break">is not.</span></p>
			<p>First, let’s look at the <a id="_idIndexMarker265"/>naive implementation (in the <span class="No-Break"><strong class="source-inline">ch04/decorator/number_sum_naive.py</strong></span><span class="No-Break"> file):</span></p>
			<pre class="source-code">
def number_sum(n):
    if n == 0:
        return 0
    else:
        return n + number_sum(n - 1)
if __name__ == "__main__":
    from timeit import Timer
    t = Timer(
        "number_sum(50)",
        "from __main__ import number_sum",
    )
    print("Time: ", t.timeit())</pre>			<p>A sample <a id="_idIndexMarker266"/>execution of this example shows how slow this<a id="_idIndexMarker267"/> implementation is. On my computer, it takes more than <em class="italic">7</em> seconds to calculate the sum of the first 50 numbers. We get the following output when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch04/decorator/number_sum_naive.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">Time:  7.286800935980864</strong></pre>			<p>Let’s see whether using memoization can help us improve the performance number. In the following code, we use <strong class="source-inline">dict</strong> for caching the already computed sums. We also change the parameter passed to the <strong class="source-inline">number_sum()</strong> function. We want to calculate the sum of the first 300 numbers instead of only the <span class="No-Break">first 50.</span></p>
			<p>Here is the new version of the code (in the <strong class="source-inline">ch04</strong><strong class="source-inline">/decorator/number_sum.py</strong> file), <span class="No-Break">using memoization:</span></p>
			<pre class="source-code">
sum_cache = {0: 0}
def number_sum(n):
    if n in sum_cache:
        return sum_cache[n]
    res = n + number_sum(n - 1)
    # Add the value to the cache
    sum_cache[n] = res
    return res
if __name__ == "__main__":
    from timeit import Timer
    t = Timer(
        "number_sum(300)",
        "from __main__ import number_sum",
    )
    print("Time: ", t.timeit())</pre>			<p>Executing the <a id="_idIndexMarker268"/>memoization-based code shows that performance <a id="_idIndexMarker269"/>improves dramatically, and is acceptable even for computing <span class="No-Break">large values.</span></p>
			<p>A sample execution, using <strong class="source-inline">python ch04/decorator/number_sum.py</strong>, is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">Time:  0.1288748119986849</strong></pre>			<p>But there are a few problems with this approach. First, while the performance is not an issue any longer, the code is not as clean as it is when not using memoization. And what happens if we decide to extend the code with more math functions and turn it into a module? We can think of several functions that would be useful for our module, for problems such as Pascal’s triangle or the Fibonacci numbers <span class="No-Break">suite algorithm.</span></p>
			<p>So, if we wanted a function in the same module as <strong class="source-inline">number_sum()</strong> for the Fibonacci numbers suite, using the same memoization technique, we would add code as follows (see the version in the <span class="No-Break"><strong class="source-inline">ch04/decorator/number_sum_and_fibonacci.py</strong></span><span class="No-Break"> file):</span></p>
			<pre class="source-code">
fib_cache = {0: 0, 1: 1}
def fibonacci(n):
    if n in fib_cache:
        return fib_cache[n]
    res = fibonacci(n - 1) + fibonacci(n - 2)
    fib_cache[n] = res
    return res</pre>			<p>Do you notice the<a id="_idIndexMarker270"/> problem? We ended up with a new<a id="_idIndexMarker271"/> dictionary called <strong class="source-inline">fib_cache</strong> that acts as our cache for the <strong class="source-inline">fibonacci()</strong> function, and a function that is more complex than it would be without using memoization. Our module is becoming <span class="No-Break">unnecessarily complex.</span></p>
			<p>Is it possible to write these functions while keeping them as simple as the naive versions, but achieving a performance similar to the performance of the functions that <span class="No-Break">use memoization?</span></p>
			<p>Fortunately, it is, and the solution is to use the <span class="No-Break">decorator pattern.</span></p>
			<p>First, we create a <strong class="source-inline">memoize()</strong> decorator as shown in the following example. Our decorator accepts the <strong class="source-inline">func</strong> function, which needs to be memoized, as an input. It uses <strong class="source-inline">dict</strong> named <strong class="source-inline">cache</strong> as the cached data container. The <strong class="source-inline">functools.wraps()</strong> function is used for convenience when creating decorators. It is not mandatory but it’s a good practice to use it, since it makes sure that the documentation and the signature of the function that is decorated are preserved. The <strong class="source-inline">*args</strong> argument list is required in this case because the functions that we want to decorate accept input arguments (such as the <strong class="source-inline">n</strong> argument for our <span class="No-Break">two functions):</span></p>
			<pre class="source-code">
import functools
def memoize(func):
    cache = {}
    @functools.wraps(func)
    def memoizer(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return memoizer</pre>			<p>Now we can use<a id="_idIndexMarker272"/> our <strong class="source-inline">memoize()</strong> decorator with the naive<a id="_idIndexMarker273"/> version of our functions. This has the benefit of readable code without performance impact. We apply a decorator using what is known as <strong class="bold">decoration</strong> (or a <strong class="bold">decoration line</strong>). A decoration<a id="_idIndexMarker274"/> uses the <strong class="source-inline">@name</strong> syntax, where <strong class="source-inline">name</strong> is the name of the decorator that we want to use. It is nothing more than syntactic sugar for simplifying the usage of decorators. We can even bypass this syntax and execute our decorator manually, but that is left as an exercise <span class="No-Break">for you.</span></p>
			<p>So, the <strong class="source-inline">memoize()</strong> decorator can be used with our recursive functions <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@memoize
def number_sum(n):
    if n == 0:
        return 0
    else:
        return n + number_sum(n - 1)
@memoize
def fibonacci(n):
    if n in (0, 1):
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)</pre>			<p>In the last part of the code, via the <strong class="source-inline">main()</strong> function, we show how to use the decorated functions and measure their performance. The <strong class="source-inline">to_execute</strong> variable is used to hold a <a id="_idIndexMarker275"/>list of tuples containing the reference to each function and the corresponding <strong class="source-inline">timeit.Timer()</strong> call (to execute it while measuring the time spent), thus avoiding code repetition. Note how the <strong class="source-inline">__name__</strong> and <strong class="source-inline">__doc__</strong> method attributes show the proper function names and documentation <a id="_idIndexMarker276"/>values, respectively. Try <a id="_idIndexMarker277"/>removing the <strong class="source-inline">@functools.wraps(func)</strong> decoration from <strong class="source-inline">memoize()</strong> and see whether this is still <span class="No-Break">the case.</span></p>
			<p>Here is the last part of <span class="No-Break">the code:</span></p>
			<pre class="source-code">
def main():
    from timeit import Timer
    to_execute = [
        (
            number_sum,
            Timer(
                "number_sum(300)",
                "from __main__ import number_sum",
            ),
        ),
        (
            fibonacci,
            Timer(
                "fibonacci(100)",
                "from __main__ import fibonacci",
            ),
        ),
    ]
    for item in to_execute:
        func = item[0]
        print(
            f'Function "{func.__name__}": {func.__doc__}'
        )
        t = item[1]
        print(f"Time: {t.timeit()}")
        print()</pre>			<p>Let’s recapitulate how we<a id="_idIndexMarker278"/> write the complete code of our math <a id="_idIndexMarker279"/>module (the <span class="No-Break"><strong class="source-inline">ch04/decorator/decorate_math.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>After the import of Python’s <strong class="source-inline">functools</strong> module that we will be using, we define the <strong class="source-inline">memoize()</strong> <span class="No-Break">decorator function.</span></li>
				<li>Then, we define the <strong class="source-inline">number_sum()</strong> function, decorated <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">memoize()</strong></span><span class="No-Break">.</span></li>
				<li>Next, we define the <strong class="source-inline">fibonacci()</strong> function, decorated the <span class="No-Break">same way.</span></li>
				<li>Finally, we add the <strong class="source-inline">main()</strong> function, as shown earlier, and the usual trick to <span class="No-Break">call it.</span></li>
			</ol>
			<p>Here is a sample output when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch04/decorator/decorate_math.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">Function "number_sum": Returns the sum of the first n numbers</strong>
<strong class="bold">Time: 0.2148694</strong>
<strong class="bold">Function "fibonacci": Returns the suite of Fibonacci numbers</strong>
<strong class="bold">Time: 0.202763251</strong></pre>			<p class="callout-heading">Note</p>
			<p class="callout">The execution times might differ in your case. Also, regardless of the time spent, we can see that the decorator-based implementation is a win because the code is <span class="No-Break">more maintainable.</span></p>
			<p>Nice! We ended up with<a id="_idIndexMarker280"/> readable code and acceptable <a id="_idIndexMarker281"/>performance. Now, you might argue that this is not the decorator pattern, since we don’t apply it at runtime. The truth is that a decorated function cannot be undecorated, but you can still decide at runtime whether the decorator will be executed or not. That’s an interesting exercise left for you. <em class="italic">Hint for the exercise:</em> use a decorator that acts as a wrapper, which decides whether or not the real decorator is executed based on <span class="No-Break">some condition.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/>The bridge pattern</h1>
			<p>A third<a id="_idIndexMarker282"/> structural pattern to look at is <a id="_idIndexMarker283"/>the <strong class="bold">bridge</strong> pattern. We can actually compare the bridge and the adapter patterns, looking at the way both work. While the adapter pattern is used <em class="italic">later</em> to make unrelated classes work together, as we saw in the implementation example we discussed earlier in the section on <em class="italic">The adapter pattern</em>, the bridge pattern is designed <em class="italic">up-front</em> to decouple an implementation from its abstraction, as we are going <span class="No-Break">to see.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/>Real-world examples</h2>
			<p>In our modern, everyday lives, an <a id="_idIndexMarker284"/>example of the bridge pattern I can think of is from the <em class="italic">digital economy</em>: information products. Nowadays, the information product or <em class="italic">infoproduct</em> is part of the resources one can find online for training, self-improvement, or one’s ideas and business development. The purpose of an information product that you find on certain marketplaces, or the website of the provider, is to deliver information on a given topic in such a way that it is easy to access and consume. The provided material can be a PDF document or ebook, an ebook series, a video, a video series, an online course, a subscription-based newsletter, or a combination of all <span class="No-Break">those formats.</span></p>
			<p>In the software realm, we can find <span class="No-Break">two examples:</span></p>
			<ul>
				<li><strong class="bold">Device drivers</strong>: Developers of an<a id="_idIndexMarker285"/> OS define the interface for device (such as printers) vendors to <span class="No-Break">implement it</span></li>
				<li><strong class="bold">Payment gateways</strong>: Different payment gateways<a id="_idIndexMarker286"/> can have different <a id="_idIndexMarker287"/>implementations, but the checkout process <span class="No-Break">remains consistent</span></li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/>Use cases for the bridge pattern</h2>
			<p>Using the bridge <a id="_idIndexMarker288"/>pattern is a <a id="_idIndexMarker289"/>good idea when you want to share an implementation among multiple objects. Basically, instead of implementing several specialized classes, and defining all that is required within each class, you can define the following <span class="No-Break">special components:</span></p>
			<ul>
				<li>An abstraction that applies to all <span class="No-Break">the classes</span></li>
				<li>A separate interface for the different <span class="No-Break">objects involved</span></li>
			</ul>
			<p>An implementation example we are about to see will illustrate <span class="No-Break">this approach.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/>Implementing the bridge pattern</h2>
			<p>Let’s assume we are building<a id="_idIndexMarker290"/> an application where the user is going to manage and deliver content after fetching it from diverse sources, which could be <span class="No-Break">the following:</span></p>
			<ul>
				<li>A web page (based on <span class="No-Break">its URL)</span></li>
				<li>A resource accessed on an <span class="No-Break">FTP server</span></li>
				<li>A file on the <span class="No-Break">local filesystem</span></li>
				<li>A <span class="No-Break">database server</span></li>
			</ul>
			<p>So, here is the idea: instead of implementing several content classes, each holding the methods responsible for getting the content pieces, assembling them, and showing them inside the application, we can define an abstraction for the <em class="italic">Resource Content</em> and a separate interface for the objects that are responsible for fetching the content. Let’s <span class="No-Break">try it!</span></p>
			<p>We begin with the interface for the implementation classes that help fetch content – that is, the <strong class="source-inline">ResourceContentFetcher</strong> class. This concept is<a id="_idIndexMarker291"/> called the <strong class="bold">Implementor</strong>. Let’s use <a id="_idIndexMarker292"/>Python’s <strong class="source-inline">protocols</strong> feature, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class ResourceContentFetcher(Protocol):
    def fetch(self, path: str) -&gt; str:
        ...</pre>			<p>Then, we define the class for our Resource Content abstraction, called <strong class="source-inline">ResourceContent</strong>. The first trick we use here is that, via an attribute (<strong class="source-inline">_imp</strong>) on the <strong class="source-inline">ResourceContent</strong> class, we maintain a reference to the object that represents the Implementor (fulfilling the <strong class="source-inline">ResourceContentFetcher</strong> interface). The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class ResourceContent:
    def __init__(self, imp: ResourceContentFetcher):
        self._imp = imp
    def get_content(self, path):
        return self._imp.fetch(path)</pre>			<p>Now we can<a id="_idIndexMarker293"/> add an <strong class="source-inline">implementation</strong> class to fetch content from a web page <span class="No-Break">or resource:</span></p>
			<pre class="source-code">
class URLFetcher:
    def fetch(self, path):
        res = ""
        req = urllib.request.Request(path)
        with urllib.request.urlopen(
            req
        ) as response:
            if response.code == 200:
                res = response.read()
        return res</pre>			<p>We can also<a id="_idIndexMarker294"/> add an <strong class="source-inline">implementation</strong> class to fetch<a id="_idIndexMarker295"/> content from a file on the <span class="No-Break">local filesystem:</span></p>
			<pre class="source-code">
class LocalFileFetcher:
    def fetch(self, path):
        with open(path) as f:
            res = f.read()
        return res</pre>			<p>Based on that, a <strong class="source-inline">main</strong> function with some testing code to show content using both <em class="italic">content fetchers</em> could look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
def main():
    url_fetcher = URLFetcher()
    rc = ResourceContent(url_fetcher)
    res = rc.get_content("http://python.org")
    print(
        f"Fetched content with {len(res)} characters"
    )
    localfs_fetcher = LocalFileFetcher()
    rc = ResourceContent(localfs_fetcher)
    pathname = os.path.abspath(__file__)
    dir_path = os.path.split(pathname)[0]
    path = os.path.join(dir_path, "file.txt")
    res = rc.get_content(path)
    print(
        f"Fetched content with {len(res)} characters"
    )</pre>			<p>Let’s see a summary <a id="_idIndexMarker296"/>of the complete code of our <a id="_idIndexMarker297"/>example (the <span class="No-Break"><strong class="source-inline">ch04/bridge/bridge.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We import the modules we need for the program (<strong class="source-inline">os</strong>, <strong class="source-inline">urllib.request</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">typing.Protocol</strong></span><span class="No-Break">).</span></li>
				<li>We define the <strong class="source-inline">ResourceContentFetcher</strong> interface, using <em class="italic">protocols</em>, for <span class="No-Break">the </span><span class="No-Break"><em class="italic">Implementor</em></span><span class="No-Break">.</span></li>
				<li>We define the <strong class="source-inline">ResourceContent</strong> class for the interface of <span class="No-Break">the abstraction.</span></li>
				<li>We define two <span class="No-Break">implementation classes:</span><ul><li><strong class="source-inline">URLFetcher</strong> for fetching content from <span class="No-Break">a URL</span></li><li><strong class="source-inline">LocalFileFetcher</strong> for fetching content from the <span class="No-Break">local filesystem</span></li></ul></li>
				<li>Finally, we add the <strong class="source-inline">main()</strong> function, as shown earlier, and the usual trick to <span class="No-Break">call it.</span></li>
			</ol>
			<p>Here is a sample output when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch04/bridge/bridge.py </strong></span><span class="No-Break">command:</span></p>
			<pre class="console">
Fetched content with 51265 characters
Fetched content with 1327 characters</pre>			<p>This is a basic<a id="_idIndexMarker298"/> illustration of how using the bridge pattern in your<a id="_idIndexMarker299"/> design, you can extract content from different sources and integrate the results in the same data manipulation system or <span class="No-Break">user interface.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor105"/>The facade pattern</h1>
			<p>As systems evolve, they <a id="_idIndexMarker300"/>can get very complex. It is not unusual to end up with a very <a id="_idIndexMarker301"/>large (and sometimes confusing) collection of classes and interactions. In many cases, we don’t want to expose this complexity to the client. This is where our next structural pattern comes to the <span class="No-Break">rescue: </span><span class="No-Break"><strong class="bold">facade</strong></span><span class="No-Break">.</span></p>
			<p>The facade design pattern helps us hide the internal complexity of our systems and expose only what is necessary to the client through a simplified interface. In essence, facade is an abstraction layer implemented over an existing <span class="No-Break">complex system.</span></p>
			<p>Let’s take the example of the computer to illustrate things. A computer is a complex machine that depends on several parts to be fully functional. To keep things simple, the word “computer,” in this case, refers to an IBM derivative that uses a von Neumann architecture. Booting a computer is a particularly complex procedure. The CPU, main memory, and hard disk need to be up and running, the boot loader must be loaded from the hard disk to the main memory, the CPU must boot the operating system kernel, and so forth. Instead of exposing all this complexity to the client, we create a facade that encapsulates the whole procedure, making sure that all steps are executed in the <span class="No-Break">right order.</span></p>
			<p>In terms of object design and programming, we should have several classes, but only the <strong class="source-inline">Computer</strong> class needs to be exposed to the client code. The client will only have to execute the <strong class="source-inline">start()</strong> method of the <strong class="source-inline">Computer</strong> class, for example, and all the other complex parts are taken care of by the facade <span class="No-Break"><strong class="source-inline">Computer</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/>Real-world examples</h2>
			<p>The facade pattern is quite common in<a id="_idIndexMarker302"/> life. When you call a bank or a company, you are usually first connected to the customer service department. The customer service employee acts as a facade between you and the actual department (billing, technical support, general assistance, and so on), where an employee will help you with your <span class="No-Break">specific problem.</span></p>
			<p>As another <a id="_idIndexMarker303"/>example, a key used to turn on a car or motorcycle can also be considered a facade. It is a simple way of activating a system that is very complex internally. And, of course, the same is true for other complex electronic devices that we can activate with a single button, such <span class="No-Break">as computers.</span></p>
			<p>In software, the <strong class="source-inline">django-oscar-datacash</strong> module is a Django third-party module that integrates with<a id="_idIndexMarker304"/> the <strong class="bold">DataCash</strong> payment gateway. The module has a gateway class that provides fine-grained access to the various DataCash APIs. On top of that, it also offers a facade class that provides a less granular API (for those who don’t want to mess with the details), and the ability to save transactions for <span class="No-Break">auditing purposes.</span></p>
			<p>The <strong class="source-inline">Requests</strong> library is<a id="_idIndexMarker305"/> another great example of the facade pattern. It simplifies sending HTTP requests and handling responses, abstracting the complexities of the HTTP protocol. Developers can easily make HTTP requests without dealing with the intricacies of sockets or the underlying <span class="No-Break">HTTP methods.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor107"/>Use cases for the facade pattern</h2>
			<p>The most usual reason<a id="_idIndexMarker306"/> to use the facade pattern is to provide a single, simple entry point to a complex system. By introducing facade, the client code can use a system by simply calling a single method/function. At the same time, the internal system does not lose any functionality, it just <span class="No-Break">encapsulates it.</span></p>
			<p>Not exposing the internal functionality of a system to the client code gives us an extra benefit: we can introduce changes to the system, but the client code remains unaware of and unaffected by the changes. No modifications are required to the <span class="No-Break">client code.</span></p>
			<p>Facade is also useful if you have more than one layer in your system. You can introduce one facade entry point per layer and let all layers communicate with each other through their facades. That promotes <strong class="bold">loose coupling</strong> and<a id="_idIndexMarker307"/> keeps the layers as independent <span class="No-Break">as possible.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>Implementing the facade pattern</h2>
			<p>Assume<a id="_idIndexMarker308"/> that we want<a id="_idIndexMarker309"/> to create an operating system using a multi-server approach, similar to how it is done in MINIX 3 or GNU Hurd. A multi-server operating system has a minimal kernel, called<a id="_idIndexMarker310"/> the <strong class="bold">microkernel</strong>, which runs in privileged mode. All the other services of the system are following a server architecture (driver server, process server, file server, and so forth). Each server belongs to a different memory address space and runs on top of the microkernel in user mode. The pros of this approach are that the operating system can become more fault-tolerant, reliable, and secure. For example, since all drivers are running in user mode on a driver server, a bug in a driver cannot crash the whole system, nor can it affect the other servers. The cons of this approach are the performance overhead and the complexity of system programming, because the communication between a server and the microkernel, as well as between the independent servers, happens using message passing. Message passing is more complex than the shared memory model used in monolithic kernels such <span class="No-Break">as Linux.</span></p>
			<p>We begin with a <strong class="source-inline">Server</strong> interface. Also, an <strong class="source-inline">Enum</strong> parameter describes the different possible states of a server. We use the <strong class="source-inline">ABC</strong> technique to forbid direct instantiation of the <strong class="source-inline">Server</strong> interface and make the fundamental <strong class="source-inline">boot()</strong> and <strong class="source-inline">kill()</strong> methods mandatory, assuming that different actions are needed to be taken for booting, killing, and restarting each server. Here is the code for these elements, the first important bits to support <span class="No-Break">our implementation:</span></p>
			<pre class="source-code">
State = Enum(
    "State",
    "NEW RUNNING SLEEPING RESTART ZOMBIE",
)
# ...
class Server(ABC):
    @abstractmethod
    def __init__(self):
        pass
    def __str__(self):
        return self.name
    @abstractmethod
    def boot(self):
        pass
    @abstractmethod
    def kill(self, restart=True):
        pass</pre>			<p>A modular operating system can have a great number of interesting servers: a file server, a process server, an authentication server, a network server, a graphical/window server, and so forth. The<a id="_idIndexMarker311"/> following example includes two stub servers: <strong class="source-inline">FileServer</strong> and <strong class="source-inline">ProcessServer</strong>. Apart from the <strong class="source-inline">boot()</strong> and <strong class="source-inline">kill()</strong> methods<a id="_idIndexMarker312"/> all servers have, <strong class="source-inline">FileServer</strong> has a <strong class="source-inline">create_file()</strong> method for creating files, and <strong class="source-inline">ProcessServer</strong> has a <strong class="source-inline">create_process()</strong> method for <span class="No-Break">creating processes.</span></p>
			<p>The <strong class="source-inline">FileServer</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">class FileServer(Server):</strong>
    def __init__(self):
        self.name = "FileServer"
        self.state = State.NEW
    def boot(self):
        print(f"booting the {self}")
        self.state = State.RUNNING
    def kill(self, restart=True):
        print(f"Killing {self}")
        self.state = (
            State.RESTART if restart else State.ZOMBIE
        )
    def create_file(self, user, name, perms):
        msg = (
            f"trying to create file '{name}' "
            f"for user '{user}' "
            f"with permissions {perms}"
        )
        print(msg)</pre>			<p>The <strong class="source-inline">ProcessServer</strong> class<a id="_idIndexMarker313"/> is <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker314"/></span><span class="No-Break"> follows:</span></p>
			<pre class="source-code">
<strong class="bold">class ProcessServer(Server)</strong>:
    def __init__(self):
        self.name = "ProcessServer"
        self.state = State.NEW
    def boot(self):
        print(f"booting the {self}")
        self.state = State.RUNNING
    def kill(self, restart=True):
        print(f"Killing {self}")
        self.state = (
            State.RESTART if restart else State.ZOMBIE
        )
    def create_process(self, user, name):
        msg = (
            f"trying to create process '{name}' "
            f"for user '{user}'"
        )
        print(msg)</pre>			<p>The <strong class="source-inline">OperatingSystem</strong> class is a facade. In its <strong class="source-inline">__init__()</strong>, all the necessary server<a id="_idIndexMarker315"/> instances are created. The <strong class="source-inline">start()</strong> method, used by the client code, is the <a id="_idIndexMarker316"/>entry point to the system. More wrapper methods can be added, if necessary, as access points to the services of the servers, such as the wrappers, <strong class="source-inline">create_file()</strong> and <strong class="source-inline">create_process()</strong>. From the client’s point of view, all those services are provided by the <strong class="source-inline">OperatingSystem</strong> class. The client should not be confused by unnecessary details such as the existence of servers and the responsibility of <span class="No-Break">each server.</span></p>
			<p>The code for the <strong class="source-inline">OperatingSystem</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">class OperatingSystem:</strong>
    """The Facade"""
    def __init__(self):
        self.fs = FileServer()
        self.ps = ProcessServer()
    def start(self):
        [i.boot() for i in (self.fs, self.ps)]
    def create_file(self, user, name, perms):
        return self.fs.create_file(user, name, perms)
    def create_process(self, user, name):
        return self.ps.create_process(user, name)</pre>			<p>As you <a id="_idIndexMarker317"/>are going to see in a minute, when we present a summary of the <a id="_idIndexMarker318"/>example, there are many dummy classes and servers. They are there to give you an idea about the required abstractions (<strong class="source-inline">User</strong>, <strong class="source-inline">Process</strong>, <strong class="source-inline">File</strong>, and so forth) and servers (<strong class="source-inline">WindowServer</strong>, <strong class="source-inline">NetworkServer</strong>, and so forth) for making the <span class="No-Break">system functional.</span></p>
			<p>Finally, we add our main code for testing the design, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    os = OperatingSystem()
    os.start()
    os.create_file("foo", "hello.txt", "-rw-r-r")
    os.create_process("bar", "ls /tmp")</pre>			<p>We are going to recapitulate the details of our implementation example; the full code is in the <span class="No-Break"><strong class="source-inline">ch04/facade.py</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li>We start with the imports <span class="No-Break">we need.</span></li>
				<li>We define the <strong class="source-inline">State</strong> constant using <strong class="source-inline">Enum</strong>, as <span class="No-Break">shown earlier.</span></li>
				<li>We then add the <strong class="source-inline">User</strong>, <strong class="source-inline">Process</strong>, and <strong class="source-inline">File</strong> classes, which do nothing in this minimal but <span class="No-Break">functional example.</span></li>
				<li>We define the abstract <strong class="source-inline">Server</strong> class, as <span class="No-Break">shown earlier.</span></li>
				<li>We then define the <strong class="source-inline">FileServer</strong> class and the <strong class="source-inline">ProcessServer</strong> class, which are both subclasses <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Server</strong></span><span class="No-Break">.</span></li>
				<li>We add two other dummy classes, <strong class="source-inline">WindowServer</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">NetworkServer</strong></span><span class="No-Break">.</span></li>
				<li>Then we define our facade class, <strong class="source-inline">OperatingSystem</strong>, as <span class="No-Break">shown earlier.</span></li>
				<li>Finally, we add the main part of the code, where we use the facade we <span class="No-Break">have defined.</span></li>
			</ol>
			<p>As you can see, executing the <strong class="source-inline">python ch04/facade.py</strong> command shows the messages produced by our two <span class="No-Break">stub servers:</span></p>
			<pre class="source-code">
<strong class="bold">booting the FileServer</strong>
<strong class="bold">booting the ProcessServer</strong>
<strong class="bold">trying to create file 'hello.txt' for user 'foo' with permissions -rw-r-r</strong>
<strong class="bold">trying to create process 'ls /tmp' for user 'bar'</strong></pre>			<p>The <a id="_idIndexMarker319"/>facade <strong class="source-inline">OperatingSystem</strong> class does a good job. The client code can create files and processes without needing to know internal details about the operating <a id="_idIndexMarker320"/>system, such as the existence of multiple servers. To be precise, the client code can call the methods for creating files and processes, but they are currently dummy. As an interesting exercise, you can implement one of the two methods, or <span class="No-Break">even both.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>The flyweight pattern</h1>
			<p>Whenever we create <a id="_idIndexMarker321"/>a new<a id="_idIndexMarker322"/> object, extra memory needs to be allocated. Although virtual memory provides us, theoretically, with unlimited memory, the reality is different. If all the physical memory of a system gets exhausted, it will start swapping pages with the secondary storage, usually <a id="_idIndexMarker323"/>a <strong class="bold">hard disk drive</strong> (<strong class="bold">HDD</strong>), which, in most cases, is unacceptable due to the performance differences between the main memory and HDD. <strong class="bold">Solid-state drives</strong> (<strong class="bold">SSDs</strong>) generally<a id="_idIndexMarker324"/> have better performance than HDDs, but not everybody is expected to use SSDs. So, SSDs are not going to totally replace HDDs <span class="No-Break">anytime soon.</span></p>
			<p>Apart<a id="_idIndexMarker325"/> from memory usage, performance is also a consideration. Graphics <a id="_idIndexMarker326"/>software, including computer games, should be able to render 3-D information (for example, a forest with thousands of trees, a village full of soldiers, or an urban area with a lot of cars) extremely quickly. If each object in a 3-D terrain is created individually and no data sharing is used, the performance will <span class="No-Break">be prohibitive.</span></p>
			<p>As software engineers, we should solve software problems by writing better software, instead of forcing the customer to buy extra or better hardware. The <strong class="bold">flyweight</strong> design pattern is a technique used to minimize memory usage and improve performance by introducing data sharing between similar objects. A flyweight is a shared object that contains state-independent, immutable (also known <a id="_idIndexMarker327"/>as <strong class="bold">intrinsic</strong>) data. The state-dependent, mutable (also known <a id="_idIndexMarker328"/>as <strong class="bold">extrinsic</strong>) data should not be part of flyweight because this is information that cannot be shared, since it differs per object. If flyweight needs extrinsic data, it should be provided explicitly by the <span class="No-Break">client code.</span></p>
			<p>An example might help to clarify how the flyweight pattern can be used practically. Let’s assume that we are creating a performance-critical game – for example, a <strong class="bold">first-person shooter</strong> (<strong class="bold">FPS</strong>). In FPS <a id="_idIndexMarker329"/>games, the players (soldiers) share some states, such as representation and behavior. In <em class="italic">Counter-Strike</em>, for instance, all soldiers on the same team (counter-terrorists versus terrorists) look the same (representation). In the same game, all soldiers (on both teams) have some common actions, such as jump, duck, and so forth (behavior). This means that we can create a flyweight that will contain all of the common data. Of course, the soldiers also have a lot of data that is different per soldier and will not be a part of the flyweight, such as weapons, health, location, and <span class="No-Break">so on.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Real-world examples</h2>
			<p>Flyweight is an optimization design<a id="_idIndexMarker330"/> pattern; therefore, it is not easy to find a good non-computing example of it. We can think of flyweight as caching in real life. For example, many bookstores have dedicated shelves with the newest and most popular publications. This is a cache. First, you can take a look at the dedicated shelves for the book you are looking for, and if you cannot find it, you can ask the bookseller to <span class="No-Break">assist you.</span></p>
			<p>The<a id="_idIndexMarker331"/> Exaile music player uses flyweight to reuse objects (in this case, music tracks) that are identified by the same URL. There’s no point in creating a new object if it has the same URL as an existing object, so the same object is reused to <span class="No-Break">save resources.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Use cases for the flyweight pattern</h2>
			<p>Flyweight<a id="_idIndexMarker332"/> is all about improving <a id="_idIndexMarker333"/>performance and memory usage. All embedded systems (phones, tablets, games consoles, microcontrollers, and so forth) and performance-critical applications (games, 3-D graphics processing, real-time systems, and so forth) can benefit <span class="No-Break">from it.</span></p>
			<p>The <em class="italic">Gang of Four</em> (<em class="italic">GoF</em>) book lists the following requirements that need to be satisfied to effectively use the <span class="No-Break">flyweight pattern:</span></p>
			<ul>
				<li>The application needs to use a large number <span class="No-Break">of objects.</span></li>
				<li>There are so many objects that it’s too expensive to store/render them. Once the mutable state is removed (because if it is required, it should be passed explicitly to flyweight by the client code), many groups of distinct objects can be replaced by relatively few <span class="No-Break">shared objects.</span></li>
				<li>Object identity is not important for the application. We cannot rely on object identity because object sharing causes identity comparisons to fail (objects that appear different to the <a id="_idIndexMarker334"/>client code end up having the <span class="No-Break">same identity).</span></li>
			</ul>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor112"/>Implementing the flyweight pattern</h2>
			<p>Let’s see how we can implement<a id="_idIndexMarker335"/> an example featuring cars in an area. We will create a small car park to illustrate the idea, making sure that the whole output is readable in a single terminal page. However, no matter how large you make the car park, the memory allocation stays <span class="No-Break">the same.</span></p>
			<p class="callout-heading">Memoization versus the flyweight pattern</p>
			<p class="callout">Memoization is an optimization technique that uses a cache to avoid recomputing results that were already computed in an earlier execution step. Memoization does not focus on a specific programming paradigm<a id="_idIndexMarker336"/> such as <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). In Python, memoization can be applied to both class methods and <span class="No-Break">simple functions.</span></p>
			<p class="callout">Flyweight is an OOP-specific optimization design pattern that focuses on sharing <span class="No-Break">object data.</span></p>
			<p>Let’s get <a id="_idIndexMarker337"/>started with<a id="_idIndexMarker338"/> the code for <span class="No-Break">this example.</span></p>
			<p>First, we need an <strong class="source-inline">Enum</strong> parameter that describes the three different types of car that are in the <span class="No-Break">car park:</span></p>
			<pre class="source-code">
CarType = Enum(
    "CarType", "SUBCOMPACT COMPACT SUV"
)</pre>			<p>Then, we will define the class at the core of our implementation: <strong class="source-inline">Car</strong>. The <strong class="source-inline">pool</strong> variable is the object pool (in other words, our cache). Notice that <strong class="source-inline">pool</strong> is a class attribute (a variable shared by <span class="No-Break">all instances).</span></p>
			<p>Using the <strong class="source-inline">__new__()</strong> special method, which is called before <strong class="source-inline">__init__()</strong>, we are converting the <strong class="source-inline">Car</strong> class to a metaclass that supports self-references. This means that <strong class="source-inline">cls</strong> references the <strong class="source-inline">Car</strong> class. When the client code creates an instance of <strong class="source-inline">Car</strong>, they pass the type of the car as <strong class="source-inline">car_type</strong>. The type of the car is used to check whether a car of the same type has already been created. If that’s the case, the previously created object is returned; otherwise, the new car type is added to the pool <span class="No-Break">and returned:</span></p>
			<pre class="source-code">
class Car:
    pool = dict()
    def __new__(cls, car_type):
        obj = cls.pool.get(car_type, None)
        if not obj:
            obj = object.__new__(cls)
            cls.pool[car_type] = obj
            obj.car_type = car_type
        return obj</pre>			<p>The <strong class="source-inline">render()</strong> method<a id="_idIndexMarker339"/> is what will be used to render a car on the screen. Notice<a id="_idIndexMarker340"/> how all the mutable information not known by flyweight needs to be explicitly passed by the client code. In this case, random <strong class="source-inline">color</strong> and the coordinates of a location (of form <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>) are used for <span class="No-Break">each car.</span></p>
			<p>Also, note that to make <strong class="source-inline">render()</strong> more useful, it is necessary to ensure that no cars are rendered on top of each other. Consider this as an exercise. If you want to make rendering more fun, you can use a graphics toolkit such as Tkinter, Pygame, <span class="No-Break">or Kivy.</span></p>
			<p>The <strong class="source-inline">render()</strong> method is defined <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    def render(self, color, x, y):
        type = self.car_type
        msg = f"render a {color} {type.name} car at ({x}, {y})"
        print(msg)</pre>			<p>The <strong class="source-inline">main()</strong> function shows how we can use the flyweight pattern. The color of a car is a random value from a predefined list of colors. The coordinates use random values between 1 and 100. Although 18 cars are rendered, memory is allocated only for 3. The last line of the output proves that when using flyweight, we cannot rely on object identity. The <strong class="source-inline">id()</strong> function returns the memory address of an object. This is not the default behavior in Python because, by default, <strong class="source-inline">id()</strong> returns a unique ID (actually the memory address of an object as an integer) for each object. In our case, even if two objects appear to be different, they actually have the same identity if they belong to the same <strong class="bold">flyweight family</strong> (in this case, the family is defined by <strong class="source-inline">car_type</strong>). Of course, different identity comparisons can still be used for objects of different families, but that is possible only if the client knows the <span class="No-Break">implementation details.</span></p>
			<p>Our example <strong class="source-inline">main()</strong> function’s code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    rnd = random.Random()
    colors = [
        "white",
        "black",
        "silver",
        "gray",
        "red",
        "blue",
        "brown",
        "beige",
        "yellow",
        "green",
    ]
    min_point, max_point = 0, 100
    car_counter = 0
    for _ in range(10):
        c1 = Car(CarType.SUBCOMPACT)
        c1.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    for _ in range(3):
        c2 = Car(CarType.COMPACT)
        c2.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    for _ in range(5):
        c3 = Car(CarType.SUV)
        c3.render(
            random.choice(colors),
            rnd.randint(min_point, max_point),
            rnd.randint(min_point, max_point),
        )
        car_counter += 1
    print(f"cars rendered: {car_counter}")
    print(
        f"cars actually created: {len(Car.pool)}"
    )
    c4 = Car(CarType.SUBCOMPACT)
    c5 = Car(CarType.SUBCOMPACT)
    c6 = Car(CarType.SUV)
    print(
        f"{id(c4)} == {id(c5)}? {id(c4) == id(c5)}"
    )
    print(
        f"{id(c5)} == {id(c6)}? {id(c5) == id(c6)}"
    )</pre>			<p>Here is the<a id="_idIndexMarker341"/> recapitulation of <a id="_idIndexMarker342"/>the full code listing (the <strong class="source-inline">ch04/flyweight.py</strong> file) to show you how the flyweight pattern is implemented <span class="No-Break">and used:</span></p>
			<ol>
				<li>We need a couple of imports: <strong class="source-inline">random</strong> and <strong class="source-inline">Enum</strong> (from the <span class="No-Break"><strong class="source-inline">enum</strong></span><span class="No-Break"> module).</span></li>
				<li>We define <strong class="source-inline">Enum</strong> for the types <span class="No-Break">of cars.</span></li>
				<li>Then we have the <strong class="source-inline">Car</strong> class, with its <strong class="source-inline">pool</strong> attribute and the <strong class="source-inline">__new__()</strong> and <span class="No-Break"><strong class="source-inline">render()</strong></span><span class="No-Break"> methods.</span></li>
				<li>In the first part of the <strong class="source-inline">main</strong> function, we define some variables and render a set of <span class="No-Break">subcompact cars.</span></li>
				<li>The second part of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></li>
				<li>The third part of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></li>
				<li>Finally, we add the fourth part of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></li>
			</ol>
			<p>The execution of the <strong class="source-inline">python ch04/flyweight.py</strong> command shows the type, random color, and coordinates of the rendered objects, as well as the identity comparison results between flyweight objects of the <span class="No-Break">same/different families:</span></p>
			<pre class="console">
render a gray SUBCOMPACT car at (25, 79)
render a black SUBCOMPACT car at (31, 99)
render a brown SUBCOMPACT car at (16, 74)
render a green SUBCOMPACT car at (10, 1)
render a gray SUBCOMPACT car at (55, 38)
render a red SUBCOMPACT car at (30, 45)
render a brown SUBCOMPACT car at (17, 78)
render a gray SUBCOMPACT car at (14, 21)
render a gray SUBCOMPACT car at (7, 28)
render a gray SUBCOMPACT car at (22, 50)
render a brown COMPACT car at (75, 26)
render a red COMPACT car at (22, 61)
render a white COMPACT car at (67, 87)
render a beige SUV car at (23, 93)
render a white SUV car at (37, 100)
render a red SUV car at (33, 98)
render a black SUV car at (77, 22)
render a green SUV car at (16, 51)
cars rendered: 18
cars actually created: 3
4493672400 == 4493672400? True
4493672400 == 4493457488? False</pre>			<p>Do not <a id="_idIndexMarker343"/>expect to see the same output since the colors and<a id="_idIndexMarker344"/> coordinates are random, and the object identities depend on the <span class="No-Break">memory map.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/>The proxy pattern</h1>
			<p>The <strong class="bold">proxy</strong> design pattern<a id="_idIndexMarker345"/> gets its <a id="_idIndexMarker346"/>name from the <em class="italic">proxy</em> (also known <a id="_idIndexMarker347"/>as <strong class="bold">surrogate</strong>) object used to perform an important action before accessing the actual object. There are four well-known types of proxy. They are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>A <strong class="bold">virtual proxy</strong>, which<a id="_idIndexMarker348"/> uses <strong class="bold">lazy initialization</strong> to defer<a id="_idIndexMarker349"/> the creation of a computationally expensive object until the moment it is <span class="No-Break">actually needed.</span></li>
				<li>A <strong class="bold">protection/protective proxy</strong>, which <a id="_idIndexMarker350"/>controls access to a <span class="No-Break">sensitive object.</span></li>
				<li>A <strong class="bold">remote proxy</strong>, which <a id="_idIndexMarker351"/>acts as the local representation of an object that really exists in a different address space (for example, a <span class="No-Break">network server).</span></li>
				<li>A <strong class="bold">smart (reference) proxy</strong>, which <a id="_idIndexMarker352"/>performs extra actions when an object is accessed. Examples of such actions are reference counting <a id="_idIndexMarker353"/>and <span class="No-Break">thread-safety checks.</span></li>
			</ol>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor114"/>Real-world examples</h2>
			<p><strong class="bold">Chip</strong> cards<a id="_idIndexMarker354"/> offer a good <a id="_idIndexMarker355"/>example of how a protective proxy is used in real life. The debit/credit card contains a chip that first needs to be read by the ATM or card reader. After the chip is verified, a password (PIN) is required to complete the transaction. This means that you cannot make any transactions without physically presenting the card and knowing <span class="No-Break">the PIN.</span></p>
			<p>A bank check that is used instead of cash to make purchases and deals is an example of a remote proxy. The check gives access to a <span class="No-Break">bank account.</span></p>
			<p>In software, the <strong class="source-inline">weakref</strong> module of Python contains a <strong class="source-inline">proxy()</strong> method that accepts an input object and returns a smart proxy to it. Weak references are the recommended way to add reference-counting support to <span class="No-Break">an object.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor115"/>Use cases for the proxy pattern</h2>
			<p>Since there are at least<a id="_idIndexMarker356"/> four common proxy types, the proxy design pattern has many <span class="No-Break">use cases.</span></p>
			<p>This pattern is used when creating a distributed system using either a private network or the cloud. In a distributed system, some objects exist in the local memory and some objects exist in the memory of remote computers. If we don’t want the client code to be aware of such differences, we can create a remote proxy that hides/encapsulates them, making the distributed nature of the <span class="No-Break">application transparent.</span></p>
			<p>The proxy pattern is also handy when our application is suffering from performance issues due to the early creation of expensive objects. Introducing lazy initialization using a virtual proxy to create the objects only when they are required can give us significant <span class="No-Break">performance improvements.</span></p>
			<p>As a third case, this pattern<a id="_idIndexMarker357"/> is used to check whether a user has sufficient privileges to access a piece of information. If our application handles sensitive information (for example, medical data), we want to ensure that the user trying to access/modify it can do so. A protection/protective proxy can handle all <span class="No-Break">security-related actions.</span></p>
			<p>This pattern is used when our application (or library, toolkit, framework, and so forth) uses multiple threads and we want to move the burden of thread safety from the client code to the application. In this case, we can create a smart proxy to hide the thread-safety complexities from <span class="No-Break">the client.</span></p>
			<p>An <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) API<a id="_idIndexMarker358"/> is also an example of how to use a remote proxy. Many popular web frameworks (Django, Flask, FastAPI...) use an <a id="_idIndexMarker359"/>ORM to provide OOP-like access to a relational database. An ORM acts as a proxy to a relational database that can be located anywhere, either at a local or <span class="No-Break">remote server.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor116"/>Implementing the proxy pattern – a virtual proxy</h2>
			<p>There are many ways to create a <a id="_idIndexMarker360"/>virtual proxy in Python, but I always like focusing<a id="_idIndexMarker361"/> on the idiomatic/Pythonic implementations. The code shown here is based on the great answer by Cyclone, a user of the <a href="http://stackoverflow.com">stackoverflow.com</a> site, to the question about "Python memoising/deferred lookup <span class="No-Break">property decorator."</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this section, the terms <em class="italic">property</em>, <em class="italic">variable</em>, and <em class="italic">attribute</em> are <span class="No-Break">used interchangeably.</span></p>
			<p>First, we create a <strong class="source-inline">LazyProperty</strong> class that can be used as a decorator. When it decorates a property, <strong class="source-inline">LazyProperty</strong> loads the property lazily (on the first use) instead of instantly. The <strong class="source-inline">__init__()</strong> method creates two variables that are used as aliases to the method that initializes a property: <strong class="source-inline">method</strong> is an alias to the actual method, and <strong class="source-inline">method_name</strong> is an alias to the method’s name. To get a better understanding of how the two aliases are used, print their value to the output (uncomment the two<a id="_idIndexMarker362"/> commented<a id="_idIndexMarker363"/> lines in that part of <span class="No-Break">the code):</span></p>
			<pre class="source-code">
<strong class="bold">class LazyProperty:</strong>
    def __init__(self, method):
        self.method = method
        self.method_name = method.__name__
        # print(f"function overriden: {self.method}")
        # print(f"function's name: {self.method_name}")</pre>			<p>The <strong class="source-inline">LazyProperty</strong> class is actually a descriptor. Descriptors are the recommended mechanisms to use in Python to override the default behavior of its attribute access methods: <strong class="source-inline">__get__()</strong>, <strong class="source-inline">__set__()</strong>, and <strong class="source-inline">__delete__()</strong>. The <strong class="source-inline">LazyProperty</strong> class overrides only <strong class="source-inline">__set__()</strong> because that is the only access method it needs to override. In other words, we don’t have to override all access methods. The <strong class="source-inline">__get__()</strong> method accesses the value of the property the underlying method wants to assign, and uses <strong class="source-inline">setattr()</strong> to do the assignment manually. What <strong class="source-inline">__get()__</strong> actually does is very neat: it replaces the method with the value! This means that not only is the property lazily loaded, but<a id="_idIndexMarker364"/> it can also be set only once. We will see what this means in <span class="No-Break">a moment.</span></p>
			<pre class="source-code">
    def __get__(self, obj, cls):
        if not obj:
            return None
        value = self.method(obj)
        # print(f'value {value}')
        setattr(obj, self.method_name, value)
        return value</pre>			<p>Again, uncomment the commented line in that part of the code to get some <span class="No-Break">extra information.</span></p>
			<p>Then, the <strong class="source-inline">Test</strong> class shows how we can use the <strong class="source-inline">LazyProperty</strong> class. There are three attributes: <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">_resource</strong>. We want the <strong class="source-inline">_resource</strong> variable to be loaded lazily; thus, we initialize it to <strong class="source-inline">None</strong> as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class Test:
    def __init__(self):
        self.x = "foo"
        self.y = "bar"
        self._resource = None</pre>			<p>The <strong class="source-inline">resource()</strong> method<a id="_idIndexMarker365"/> is decorated with the <strong class="source-inline">LazyProperty</strong> class. For demonstration purposes, the <strong class="source-inline">LazyProperty</strong> class initializes the <strong class="source-inline">_resource</strong> attribute <a id="_idIndexMarker366"/>as a tuple, as shown in the following code. Normally, this<a id="_idIndexMarker367"/> would be a slow/expensive initialization (database, graphics, and <span class="No-Break">so on):</span></p>
			<pre class="source-code">
    @LazyProperty
    def resource(self):
        print("initializing self._resource...")
        print(f"... which is: {self._resource}")
        self._resource = tuple(range(5))
        return self._resource</pre>			<p>The <strong class="source-inline">main()</strong> function, as follows, shows how lazy <span class="No-Break">initialization behaves:</span></p>
			<pre class="source-code">
def main():
    t = Test()
    print(t.x)
    print(t.y)
    # do more work...
    print(t.resource)
    print(t.resource)</pre>			<p>Notice how overriding the <strong class="source-inline">__get()__</strong> access method makes it possible to treat the <strong class="source-inline">resource()</strong> method as a simple attribute (we can use <strong class="source-inline">t.resource</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">t.resource()</strong></span><span class="No-Break">).</span></p>
			<p>Let’s recapitulate the <a id="_idIndexMarker368"/>example code (<span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ch04/proxy/proxy_lazy.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We define the <span class="No-Break"><strong class="source-inline">LazyProperty</strong></span><span class="No-Break"> class.</span></li>
				<li>We define the <strong class="source-inline">Test</strong> class with a <strong class="source-inline">resource()</strong> method that we decorate <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">LazyProperty</strong></span><span class="No-Break">.</span></li>
				<li>We add the main<a id="_idIndexMarker369"/> function for testing our <span class="No-Break">design </span><span class="No-Break"><a id="_idIndexMarker370"/></span><span class="No-Break">example.</span></li>
			</ol>
			<p>If you can execute the example in its original version (where the added lines for better understanding are kept commented), using the <strong class="source-inline">python ch04/proxy/proxy_lazy.py</strong> command, you will get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">foo</strong>
<strong class="bold">bar</strong>
<strong class="bold">initializing self._resource...</strong>
<strong class="bold">... which is: None</strong>
<strong class="bold">(0, 1, 2, 3, 4)</strong>
<strong class="bold">(0, 1, 2, 3, 4)</strong></pre>			<p>Based on this output, we can see <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <strong class="source-inline">_resource</strong> variable is indeed initialized not by the time the <strong class="source-inline">t</strong> instance is created, but the first time that we <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">t.resource</strong></span><span class="No-Break">.</span></li>
				<li>The second time <strong class="source-inline">t.resource</strong> is used, the variable is not initialized again. That’s why the initialization string initializing <strong class="source-inline">self._resource</strong> is shown <span class="No-Break">only once.</span></li>
			</ul>
			<p class="callout-heading">Additional information</p>
			<p class="callout">There are two basic kinds of lazy initialization in OOP. They are <span class="No-Break">as follows:</span></p>
			<p class="callout">- <strong class="bold">At the instance level</strong>: This means that an object’s property is initialized lazily, but the property has an object scope. Each instance (object) of the same class has its own (different) copy of <span class="No-Break">the property.</span></p>
			<p class="callout">- <strong class="bold">At the class or module level</strong>: In this case, we do not want a different copy per instance, but all the instances share the same property, which is lazily initialized. This case is not covered in this chapter. If you find it interesting, consider it as <span class="No-Break">an exercise.</span></p>
			<p>Since there are so <a id="_idIndexMarker371"/>many possible <a id="_idIndexMarker372"/>cases for using the proxy pattern, let’s see<a id="_idIndexMarker373"/> <span class="No-Break">another example.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor117"/>Implementing the proxy pattern – a protection proxy</h2>
			<p>As a second example, let’s implement a simple <a id="_idIndexMarker374"/>protection proxy to view and add users. The service provides <span class="No-Break">two options:</span></p>
			<ul>
				<li><strong class="bold">Viewing the list of users</strong>: This operation does not require <span class="No-Break">special privileges</span></li>
				<li><strong class="bold">Adding a new user</strong>: This operation requires the client to provide a special <span class="No-Break">secret message</span></li>
			</ul>
			<p>The <strong class="source-inline">SensitiveInfo</strong> class contains the information that we want to protect. The <strong class="source-inline">users</strong> variable is the list of existing users. The <strong class="source-inline">read()</strong> method prints the list of the users. The <strong class="source-inline">add()</strong> method adds a new user to the list. The code for that class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">class SensitiveInfo</strong>:
    def __init__(self):
        self.users = ["nick", "tom", "ben", "mike"]
    def read(self):
        nb = len(self.users)
        print(f"There are {nb} users: {' '.join(self.users)}")
    def add(self, user):
        self.users.append(user)
        print(f"Added user {user}")</pre>			<p>The <strong class="source-inline">Info</strong> class is a protection proxy of <strong class="source-inline">SensitiveInfo</strong>. The secret variable is the message required to be known/provided by the client code to add a <span class="No-Break">new user.</span></p>
			<p>Note that this is just an example. In reality, you should never do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Store passwords in the <span class="No-Break">source code</span></li>
				<li>Store passwords in <span class="No-Break">clear-text form</span></li>
				<li>Use a weak (for example, MD5) or custom form <span class="No-Break">of encryption</span></li>
			</ul>
			<p>In the <strong class="source-inline">Info</strong> class, as we<a id="_idIndexMarker375"/> can see next, the <strong class="source-inline">read()</strong> method is a <a id="_idIndexMarker376"/>wrapper to <strong class="source-inline">SensitiveInfo.read()</strong> and the <strong class="source-inline">add()</strong> method ensures that a new user can be added only if the client code knows<a id="_idIndexMarker377"/> the <span class="No-Break">secret message:</span></p>
			<pre class="source-code">
<strong class="bold">class Info:</strong>
    def __init__(self):
        self.protected = SensitiveInfo()
        self.secret = "0xdeadbeef"
    def read(self):
        self.protected.read()
    def add(self, user):
        sec = input("what is the secret? ")
        if sec == self.secret:
            self.protected.add(user)
        else:
            print("That's wrong!")</pre>			<p>The <strong class="source-inline">main()</strong> function <a id="_idIndexMarker378"/>shows how the proxy pattern can be used by the <a id="_idIndexMarker379"/>client code. The client code creates an instance of<a id="_idIndexMarker380"/> the <strong class="source-inline">Info</strong> class and uses the displayed menu to read the list, add a new user, or exit the application. Let’s consider the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
def main():
    info = Info()
    while True:
        print("1. read list |==| 2. add user |==| 3. quit")
        key = input("choose option: ")
        if key == "1":
            info.read()
        elif key == "2":
            name = input("choose username: ")
            info.add(name)
        elif key == "3":
            exit()
        else:
            print(f"unknown option: {key}")</pre>			<p>Let’s recapitulate the full <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ch04/proxy/proxy_protection.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>First, we define the <span class="No-Break"><strong class="source-inline">SensitiveInfo</strong></span><span class="No-Break"> class.</span></li>
				<li>Then, we have the code for the <span class="No-Break"><strong class="source-inline">Info</strong></span><span class="No-Break"> class.</span></li>
				<li>Finally, we add the main function with our <span class="No-Break">testing code.</span></li>
			</ol>
			<p>We can see in the following a sample output of the program when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch04/proxy/proxy_protection.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 1</strong>
<strong class="bold">There are 4 users: nick tom ben mike</strong>
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 2</strong>
<strong class="bold">choose username: tom</strong>
<strong class="bold">what is the secret? 0xdeadbeef</strong>
<strong class="bold">Added user tom</strong>
<strong class="bold">1. read list |==| 2. add user |==| 3. quit</strong>
<strong class="bold">choose option: 3</strong></pre>			<p>Have you already spotted flaws or missing features that can be addressed to improve our protection proxy example? Here are a <span class="No-Break">few suggestions:</span></p>
			<ul>
				<li>This example has a very <a id="_idIndexMarker381"/>big security flaw. Nothing <a id="_idIndexMarker382"/>prevents the client code from bypassing the<a id="_idIndexMarker383"/> security of the application by creating an instance of <strong class="source-inline">SensitiveInfo</strong> directly. Improve the example to prevent this situation. One way is to use the <strong class="source-inline">abc</strong> module to forbid direct instantiation of <strong class="source-inline">SensitiveInfo</strong>. What other code changes are required in <span class="No-Break">this case?</span></li>
				<li>A basic security rule is that we should never store clear-text passwords. Storing a password safely is not very hard as long as we know which libraries to use. If you have an interest in security, try to implement a secure way to store the secret message externally (for example, in a file <span class="No-Break">or database).</span></li>
				<li>The application <a id="_idIndexMarker384"/>only supports adding new users, but what<a id="_idIndexMarker385"/> about removing an existing user? Add a <span class="No-Break"><strong class="source-inline">remove()</strong></span><span class="No-Break"> method.</span></li>
			</ul>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor118"/>Implementing the proxy pattern – a remote proxy</h2>
			<p>Imagine we are building a <a id="_idIndexMarker386"/>file management system where<a id="_idIndexMarker387"/> clients can perform operations on files stored on a remote server. The operations might include reading a file, writing to a file, and deleting a file. The remote proxy hides the complexity of network requests from <span class="No-Break">the client.</span></p>
			<p>We start by creating an interface that defines the operations that can be performed on the remote server, <strong class="source-inline">RemoteServiceInterface</strong>, and the class that implements it to provide the actual <span class="No-Break">service, </span><span class="No-Break"><strong class="source-inline">RemoteService</strong></span><span class="No-Break">.</span></p>
			<p>The interface is defined <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class RemoteServiceInterface(ABC):
    @abstractmethod
    def read_file(self, file_name):
        pass
    @abstractmethod
    def write_file(self, file_name, contents):
        pass
    @abstractmethod
    def delete_file(self, file_name):
        pass</pre>			<p>The <strong class="source-inline">RemoteService</strong> class <a id="_idIndexMarker388"/>is defined as follows (the methods just return a string, for <a id="_idIndexMarker389"/>the sake of simplicity, but normally, you would have specific code for the file handling on the <span class="No-Break">remote service):</span></p>
			<pre class="source-code">
class RemoteService(RemoteServiceInterface):
    def read_file(self, file_name):
        # Implementation for reading a file from the server
        return "Reading file from remote server"
    def write_file(self, file_name, contents):
        # Implementation for writing to a file on the server
        return "Writing to file on remote server"
    def delete_file(self, file_name):
        # Implementation for deleting a file from the server
        return "Deleting file from remote server"</pre>			<p>Then, we define <strong class="source-inline">ProxyService</strong> for the proxy. It implements the <strong class="source-inline">RemoteServiceInterface</strong> interface and acts as a surrogate for <strong class="source-inline">RemoteService</strong>, which handles <a id="_idIndexMarker390"/>communication with <span class="No-Break">the latter:</span></p>
			<pre class="source-code">
class ProxyService(RemoteServiceInterface):
    def __init__(self):
        self.remote_service = RemoteService()
    def read_file(self, file_name):
        print("Proxy: Forwarding read request to RemoteService")
        return self.remote_service.read_file(file_name)
    def write_file(self, file_name, contents):
        print("Proxy: Forwarding write request to RemoteService")
        return self.remote_service.write_file(file_name, contents)
    def delete_file(self, file_name):
        print("Proxy: Forwarding delete request to RemoteService")
        return self.remote_service.delete_file(file_name)</pre>			<p>Clients interact with the <strong class="source-inline">ProxyService</strong> component as if it were the <strong class="source-inline">RemoteService</strong> one, unaware of the remote nature of the actual service. The proxy handles the communication with the remote service, potentially adding logging, access control, or caching. To test<a id="_idIndexMarker391"/> things, we<a id="_idIndexMarker392"/> can add<a id="_idIndexMarker393"/> the following code, based on creating an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ProxyService</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    proxy = ProxyService()
    print(proxy.read_file("example.txt"))</pre>			<p>Let’s recapitulate the implementation (the full code is <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ch04/proxy/proxy_remote.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We start by defining the interface, <strong class="source-inline">RemoteServiceInterface</strong>, and a class that implements <span class="No-Break">it, </span><span class="No-Break"><strong class="source-inline">RemoteService</strong></span><span class="No-Break">.</span></li>
				<li>Then, we define the <strong class="source-inline">ProxyService</strong> class, which also implements <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">RemoteService</strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">Interface</strong></span><span class="No-Break"> interface.</span></li>
				<li>Finally, we add some code for testing the <span class="No-Break">proxy object.</span></li>
			</ol>
			<p>Let’s see the result of the example by running <span class="No-Break"><strong class="source-inline">python ch04/proxy/proxy_remote.py</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">Proxy: Forwarding read request to RemoteService</strong>
<strong class="bold">Reading file from remote server</strong></pre>			<p>It worked. This <a id="_idIndexMarker394"/>lightweight example was effective in showing how to<a id="_idIndexMarker395"/> implement the remote proxy <span class="No-Break">use case.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor119"/>Implementing the proxy pattern – a smart proxy</h2>
			<p>Let’s consider a scenario<a id="_idIndexMarker396"/> where you have a shared resource in your<a id="_idIndexMarker397"/> application, such as a database connection. Every time an object accesses this resource, you want to keep track of how many references to the resource exist. Once there are no more references, the resource can be safely released or closed. A smart proxy will help manage the reference counting for this database connection, ensuring it’s only closed once all references to it <span class="No-Break">are released.</span></p>
			<p>As in the previous example, we will need an interface, <strong class="source-inline">DBConnectionInterface</strong>, defining operations for accessing the database, and a class that represents the actual database <span class="No-Break">connection, </span><span class="No-Break"><strong class="source-inline">DBConnection</strong></span><span class="No-Break">.</span></p>
			<p>For the interface, let’s use <strong class="source-inline">Protocol</strong> (to change from the <span class="No-Break"><strong class="source-inline">ABC</strong></span><span class="No-Break"> way):</span></p>
			<pre class="source-code">
from typing import Protocol
class DBConnectionInterface(Protocol):
    def exec_query(self, query):
        ...</pre>			<p>The class for the database connection is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class DBConnection:
    def __init__(self):
        print("DB connection created")
    def exec_query(self, query):
        return f"Executing query: {query}"
    def close(self):
        print("DB connection closed")</pre>			<p>Then, we define the <strong class="source-inline">SmartProxy</strong> class; it also implements the <strong class="source-inline">DBConnectionInterface</strong> interface (see the <strong class="source-inline">exec_query()</strong> method). We use this class to manage reference counting and access to the <strong class="source-inline">DBConnection</strong> object. It ensures that the <strong class="source-inline">DBConnection</strong> object is created on demand when the first query is executed and is only closed when there are <a id="_idIndexMarker398"/>no more<a id="_idIndexMarker399"/> references to it. The <a id="_idIndexMarker400"/>code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class SmartProxy:
    def __init__(self):
        self.cnx = None
        self.ref_count = 0
    def access_resource(self):
        if self.cnx is None:
            self.cnx = DBConnection()
        self.ref_count += 1
        print(f"DB connection now has {self.ref_count} references.")
    def exec_query(self, query):
        if self.cnx is None:
            # Ensure the connection is created
            # if not already
            self.access_resource()
        result = self.cnx.exec_query(query)
        print(result)
        # Decrement reference count after
        # executing query
        self.release_resource()
        return result
    def release_resource(self):
        if self.ref_count &gt; 0:
            self.ref_count -= 1
            print("Reference released...")
            print(f"{self.ref_count} remaining refs.")
        if self.ref_count == 0 and self.cnx is not None:
            self.cnx.close()
            self.cnx = None</pre>			<p>Now, we can add some <a id="_idIndexMarker401"/>code to <a id="_idIndexMarker402"/>test <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker403"/></span><span class="No-Break">implementation:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    proxy = SmartProxy()
    proxy.exec_query("SELECT * FROM users")
    proxy.exec_query("UPDATE users SET name = 'John Doe' WHERE id = 1")</pre>			<p>Let’s recapitulate the implementation (the full code is <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ch04/proxy/proxy_smart.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We start by defining<a id="_idIndexMarker404"/> the interface, <strong class="source-inline">DBConnectionInterface</strong>, and a class that implements it and represents the database <span class="No-Break">connection, </span><span class="No-Break"><strong class="source-inline">DBConnection</strong></span><span class="No-Break">.</span></li>
				<li>Then, we define the <strong class="source-inline">SmartProxy</strong> class, which also <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">DBConnectionInterface</strong></span><span class="No-Break">.</span></li>
				<li>Finally, we add some code for testing the <span class="No-Break">proxy object.</span></li>
			</ol>
			<p>Let’s see the result of the example by running <span class="No-Break"><strong class="source-inline">python ch04/proxy/proxy_smart.py</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">DB connection created</strong>
<strong class="bold">DB connection now has 1 references.</strong>
<strong class="bold">Executing query: SELECT * FROM users</strong>
<strong class="bold">Reference released...</strong>
<strong class="bold">0 remaining refs.</strong>
<strong class="bold">DB connection closed</strong>
<strong class="bold">DB connection created</strong>
<strong class="bold">DB connection now has 1 references.</strong>
<strong class="bold">Executing query: UPDATE users SET name = 'John Doe' WHERE id = 1</strong>
<strong class="bold">Reference released...</strong>
<strong class="bold">0 remaining refs.</strong>
<strong class="bold">DB connection closed</strong></pre>			<p>This was another <a id="_idIndexMarker405"/>demonstration of the proxy pattern. Here, it <a id="_idIndexMarker406"/>helped us implement an improved solution for <a id="_idIndexMarker407"/>scenarios where database connections are shared across different parts of an application and need to be managed carefully to avoid exhausting database resources or <span class="No-Break">leaking connections.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor120"/>Summary</h1>
			<p>Structural patterns are invaluable for creating clean, maintainable, and scalable code. They provide solutions for many of the challenges you’ll face in <span class="No-Break">daily coding.</span></p>
			<p>First, the adapter pattern serves as a flexible solution for harmonizing mismatched interfaces. We can use this pattern to bridge the gap between outdated legacy systems and modern interfaces, thus promoting more cohesive and manageable <span class="No-Break">software systems.</span></p>
			<p>Then, we discussed the decorator pattern that we use as a convenient way of extending the behavior of an object without using inheritance. Python, with its built-in decorator feature, extends the decorator concept even more by allowing us to extend the behavior of any callable without using inheritance or composition. The decorator pattern is a great solution for implementing cross-cutting concerns because they are generic and do not fit well into the OOP paradigm. We mentioned several categories of cross-cutting concerns in the <em class="italic">Use cases for the decorator pattern</em> section. We saw how decorators can help us to keep our functions clean without <span class="No-Break">sacrificing performance.</span></p>
			<p>Sharing similarities with the adapter pattern, the bridge pattern is different from it in the sense that it is used up-front to define an abstraction and its implementation in a decoupled way so that both can vary independently. The bridge pattern is useful when writing software for problem domains such as operation systems and device drivers, GUIs, and website builders where we have multiple themes and we need to change the theme of a website based on certain properties. We discussed an example in the domain of content extraction and management, where we defined an interface for the abstraction, an interface for the implementor, and <span class="No-Break">two implementations.</span></p>
			<p>The facade pattern is ideal for providing a simple interface to client code that wants to use a complex system but does not need to be aware of the system’s complexity. A computer is a facade, since all we need to do to use it is press a single button to turn it on. All the rest of the hardware complexity is handled transparently by the BIOS, the boot loader, and the other components of the system software. There are more real-life examples of facade, such as when we are connected to the customer service department of a bank or a company, and the keys that we use to turn a vehicle on. We covered an implementation of the interface used by a multi-server <span class="No-Break">operating system.</span></p>
			<p>In general, we use the flyweight pattern when an application needs to create a large number of computationally expensive objects that share many properties. The important point is to separate the immutable (shared) properties from the mutable ones. We saw how to implement a car renderer that supports three different car families. By providing the mutable color and x, y properties explicitly to the <strong class="source-inline">render()</strong> method, we managed to create only 3 different objects instead of 18. Although that might not seem like a big win, imagine if the cars were 2,000 instead <span class="No-Break">of 18.</span></p>
			<p>We ended with the proxy pattern. We discussed several use cases of the proxy pattern, including performance, security, and how to offer simple APIs to users. We saw an implementation example for each of the four types of proxy you generally need: virtual proxy, protective proxy, proxy to a remote service, and <span class="No-Break">smart proxy.</span></p>
			<p>In the next chapter, we will explore behavioral design patterns, patterns that deal with object interconnection <span class="No-Break">and algorithms.</span></p>
		</div>
	</body></html>