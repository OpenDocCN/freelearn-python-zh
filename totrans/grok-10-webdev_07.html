<html><head></head><body>
  <div id="sbo-rt-content"><div class="section" title="Indexing different kinds of objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec05"/>Indexing different kinds of objects</h1></div></div></div><p>So far, we can search the title and description fields of the<code class="literal"> Project</code> class and nothing more. Both lists and items have a description field as well, so it would be nice if the simple search query we are using could also look inside lists and their items.<a id="id186" class="indexterm"/>
</p><p>Right now, we are using<code class="literal"> IProject</code> as the context for the search. The<code class="literal"> context</code> class annotation does not accept more than one parameter, so we can't just pass<code class="literal"> ITodoList</code> and<code class="literal"> ITodoItem</code> and be done. Here is where the concept of interfaces can shine. We can define a general search interface and make all of our objects implement it. They don't even need to provide every attribute:</p><div class="informalexample"><pre class="programlisting">class ISearchable(interface.Interface):
title = interface.Attribute('title')
kind = interface.Attribute('kind')
description = interface.Attribute('description')
creator = interface.Attribute('creator')
creation_date = interface.Attribute('creation date')
modification_date = interface.Attribute('modification date')
checked = interface.Attribute('checked')
def searchableText():
"""return concatenated string with all text fields to search"""
</pre></div><p>Notice how instead of using a schema for the attribute definition, we simply use the<code class="literal"> Attribute</code> class from the<code class="literal"> interface</code> package. We are not going to generate forms from this interface and it is easy to just describe its attributes without worrying about field properties.</p><p>Once we define this interface and include all of the attributes that we want to be indexed in the catalog, we just declare that every model implements it. For example:</p><div class="informalexample"><pre class="programlisting">class Project(grok.Container):
grok.implements(IProject, IMetadata, ISearchable)
</pre></div><p>Then, we replace the<code class="literal"> context</code> annotation argument to use it as well. This is very powerful, and means that any of the objects that declare themselves to be searchable via the<code class="literal"> grok.implements(ISearchable)</code> class annotation will be automatically indexed by Grok, or the call to<code class="literal"> catalog.searchResults</code> will take them into account.<a id="id187" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class ProjectIndexes(grok.Indexes):
grok.site(ITodo)
grok.context(ISearchable)
title = grok.index.Text()
description = grok.index.Text()
searchableText = grok.index.Text()
creator = grok.index.Field()
modification_date = grok.index.Field()
creation_date = grok.index.Field()
checked = grok.index.Field()
</pre></div><p>Notice how we use<code class="literal"> ISearchable</code> as context now and also create all of the remaining indexes that we could use. As these indexes will contain references to different kinds of models, we add a<code class="literal"> content_type</code> attribute to each model to hold the kind of model it represents. As an example, here is the improved<code class="literal"> TodoList</code> class definition. We add<code class="literal"> ISearchable</code> to the<code class="literal"> grok.implements</code> declaration, and that's enough to make our search view work with todo items as well as projects.</p><div class="informalexample"><pre class="programlisting">class TodoList(grok.Container):
grok.implements(ITodoList, IMetadata, ISearchable)
next_id = 0
description = u''
content_type = 'list'
def __init__(self,title,description,creator):
super(TodoList, self).__init__()
self.title = title
self.description = description
self.next_id = 0
self.creator = creator
self.creation_date = datetime.datetime.now()
self.modification_date = datetime.datetime.now()
def searchableText(self):
return self.title+self.description
</pre></div><p>Again, we are implementing<code class="literal"> ISearchable,</code> which marks the<code class="literal"> TodoList</code> model indexable. Then we define<code class="literal"> content_type</code> with the value<code class="literal"> list</code>, so that when a search result has multiple types of objects, we can find out if one of them is a list just by looking at this attribute. Notice how the rest of the metadata attributes are now assigned some value at creation time, via the<code class="literal"> __init__</code> method, so that the result display is complete.</p><p>Finally, the<code class="literal"> searchableText</code> method for full text searches is defined. In this case, the code is the same as for the method of the same name in the<code class="literal"> Project</code> class, but it could be different, as indeed it is in the<code class="literal"> TodoItem</code> class, which is not shown here.<a id="id188" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="The catalog admin UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec06"/>The catalog admin UI</h1></div></div></div><p>When your catalog begins to grow, it can be useful to find out how many objects it has and how populated each index is. Grok includes a package for performing simple introspection into the catalog, which allows us to take a look inside.<a id="id189" class="indexterm"/>
</p><p>The catalog UI is not integrated into the Grok admin UI. However, we can still access the catalog from the Zope side by using a direct URL. Let's do that. Create some projects and lists in the<code class="literal"> todo</code> application and then point your browser to:<code class="literal"> http://localhost:8080/todo/++etc++site/Catalog/@@advanced.html</code>. The list of project indexes will appear in the browser, along with some statistics, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/7481_06_03.jpg" alt="The catalog admin UI"/></div><p>This is the statistics screen of the catalog UI, so we can't do much more here than take a look at the numbers, but it does give us a good sense of how our application data is stored in the catalog.</p><p>There are other tabs, the most important of which is the<span class="strong"><strong> Contents</strong></span> tab, from where we can visit the information screens for each of the indexes.<a id="id190" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Types of indexes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec07"/>Types of indexes</h1></div></div></div><p>As we can see from the code of the<code class="literal"> ProjectIndexes</code> class, there is more than one kind of index. So far, we have worked with a<code class="literal"> text</code> index, which allows us to make full-text searches. However, not all searches are equal; text searches allow us to look for words or even fragments of words inside a field value, but there are cases where we would need to match a field value exactly or return no match at all.</p><p>Grok offers three ready-to-use index classes, which are summarized in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Index</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Field</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Matches against an entire field. Used for indexing orderable values and querying for a range. Supports sorting and limiting the number of results.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Text</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Supports full-text searches of a field. Queries can include the 'and' and 'or' Boolean operators. It's also possible to search for fragments of strings by using an asterisk (globbing).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Set</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Supports keyword searches of a field. The index allows searches for documents that contain any one set of values; all of a set of values; or between a set of values.</p>
</td></tr></tbody></table></div><p>We are not going to add search options for using the other indexes in our application right now, but here are a few examples of how to use them. For the sake of completeness, let's start with the<code class="literal"> Text</code> field:<a id="id191" class="indexterm"/>
</p><p>Finding objects containing the word 'caveman' in the title:</p><div class="informalexample"><pre class="programlisting">results = catalog.searchResults(title='caveman')
</pre></div><p>Finding all objects with either 'spear' or 'club' in their description:</p><div class="informalexample"><pre class="programlisting">results = catalog.searchResults(description='spear or club')
</pre></div><p>Finding objects containing any word starting with 'cave' in their title (caveman, caved, caveat, and so on):</p><div class="informalexample"><pre class="programlisting">results = catalog.searchResults(title='cave*')
</pre></div><p>The<code class="literal"> Field</code> index works differently. It's necessary to always use a tuple for the query, even if we are only interested in a single value. If we want all of the objects created by the user 'Manager':<a id="id192" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">results = catalog.searchResults(creator=(u'Manager', u'Manager'))
</pre></div><p>All objects created between March 31, 2009 and today:</p><div class="informalexample"><pre class="programlisting">from datetime import datetime
results = catalog.searchResults(creation_date=(datetime(2009,3,31), datetime.now())
</pre></div><p>The<code class="literal"> Set</code> index allows us to find matches in lists of values, which is useful for finding objects that share some keywords or tags, but do not necessarily have the same list of keywords or tags applied to them.<a id="id193" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec08"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use a catalog for searching and categorizing content. We are now able to add indexes and custom search queries to our applications. In the next chapter, we will turn our attention to security.</p></div></div>
</body></html>