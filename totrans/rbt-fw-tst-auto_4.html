<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Extending the Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Extending the Framework</h1></div></div></div><p>This chapter is a bit different from all the previous chapters because it focuses on external libraries that provide interaction between the Robot Framework and the other software over which Robot Framework runs. This is important as the integration with other leading software is the cornerstone of this framework. Therefore, we need to be aware of the various libraries that are present as well as know how to create a custom library for the framework if there is not any.</p><p>Until now, all the examples have only used the <code class="literal">log</code> function present in the built-in library as this was the easiest way to demonstrate output on running the framework. While this was easy to understand, it didn't explain how acceptance testing is supposed to work in real world scenarios.</p><p>In this chapter, various third-party libraries are covered, which extend the Robot Framework in myriad ways. Briefly put, the following would be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Web application testing through Selenium</li><li class="listitem" style="list-style-type: disc">Debugging Selenium-based Robot Framework code through the REPL shell</li><li class="listitem" style="list-style-type: disc">Testing Java-based desktop applications through the Swing library</li><li class="listitem" style="list-style-type: disc">Introduction to image-based automation through Sikuli</li><li class="listitem" style="list-style-type: disc">Creation of a custom Robot Framework library for Sikuli</li><li class="listitem" style="list-style-type: disc">Overview of other libraries that assist in writing acceptance tests</li></ul></div><p>To demonstrate the integration with a third-party library, we will finally proceed with using the Sikuli tool to capture and replay the mouse and keyboard actions, and using image-based computer vision to create a fully-fledged acceptance testing solution.</p><div class="section" title="Testing the web applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Testing the web applications</h1></div></div></div><p>Today, most of the<a id="id132" class="indexterm"/> commonly used software in use are present on the <a id="id133" class="indexterm"/>Web as it has become the common medium to interact with huge amount of users worldwide. Creation of a web-based solution is not only getting easier by the day (as new technologies are coming up and the old ones are getting matured, optimized, and obsolete), but the connectivity, ease of use, and sophistication for web application clients are also increasing. Thus, the web applications which interact with the world today have almost negligible lead time between their development <a id="id134" class="indexterm"/>and end user interaction. Acceptance testing<a id="id135" class="indexterm"/> thus becomes essential as changes in the software must be validated quickly to ensure basic correctness and existence of basic functionality before they go live into the production.</p><div class="section" title="Selenium"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Selenium</h2></div></div></div><p>Selenium is a web browser automation tool that provides recording and playback facilities. It can be <a id="id136" class="indexterm"/>used to create simple scripts that can automate actions on browser and web pages by using various objects present in the browser. As it <a id="id137" class="indexterm"/>is a leading web browsing automation tool, there are various resources available for it. As a browser runner, various browsers have Selenium as a plugin/extension and can be installed within the browser itself. However, while running the custom examples, a Selenium-based server is required, which is present in an embedded JAR file that can be called directly. Originally, it came with a remote controller, which required a Selenium remote control server that managed browsers' web requests from the browsers. However, owing to the popular requests to simplify the development requirements, Selenium2 was created that used WebDriver to manage the browsers directly and perform operations, such as file upload and popup management directly from the browser. Through the use of WebDriver, the Selenium tests can be made more flexible and made to work in browsers that were not possible to be used by Selenium before.</p></div><div class="section" title="The Robot Framework Selenium library"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>The Robot Framework Selenium library</h2></div></div></div><p>This library provides a bridge between the Robot Framework and the Selenium WebDriver engine. <a id="id138" class="indexterm"/>Through this, various Selenium commands can be issued directly from the Robot Framework test files. There exist separate libraries for Selenium1 as well as Selenium2 and depending upon the Selenium version, one can choose an appropriate library. There is no need to despair though, as Selenium2 library is largely built upon the contents of the Selenium library. One thing to be noted is that if Selenium is running with a separate server (an embedded Jetty server), then remote control driver is needed, otherwise the WebDriver can easily be chosen.</p><p>To install this library, <code class="literal">pip</code> can be used and depending upon the set up, sudo/admin privileges may be required:</p><div class="informalexample"><pre class="programlisting">pip install robotframework-selenium2library</pre></div><p>The detailed documentation is present at <a class="ulink" href="http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html">http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html</a>, which can be quite handy while developing these <a id="id139" class="indexterm"/>applications.</p></div></div></div>
<div class="section" title="Running web-based tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Running web-based tests</h1></div></div></div><p>In the example, a small website has been created using flask, which is a Python-based micro framework to <a id="id140" class="indexterm"/>create dynamic websites. To run the example, flask would be required at the local Python setup, which can be installed as:</p><div class="informalexample"><pre class="programlisting">pip install flask</pre></div><p>After installing flask, traverse to the <code class="literal">flaskApp</code> directory via command line and run the demo website by running its main controller file:</p><div class="informalexample"><pre class="programlisting">python hello.py</pre></div><p>This starts up the flask on <code class="literal">localhost:5000</code>, and displays the following window:</p><div class="mediaobject"><img src="graphics/3033OS_04_01.jpg" alt="Running web-based tests"/></div><p>On entering wrong username/password an error is displayed on the same page. Here, the contents of the form are not persisted and only the presence of an error message indicates that a wrong username/password combination has been tried previously. </p><p>The following screenshot shows the error when a wrong username/password combination is tried:</p><div class="mediaobject"><img src="graphics/3033OS_04_02.jpg" alt="Running web-based tests"/></div><p>The <a id="id141" class="indexterm"/>application redirects to the respective page if the login is successful, which also provides a confirmation text mentioning the successful login as well as provides a URL for logging again, if there is any need to do that again, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3033OS_04_03.jpg" alt="Running web-based tests"/></div><div class="section" title="Using the Selenium2Library"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Using the Selenium2Library</h2></div></div></div><p>To perform the same<a id="id142" class="indexterm"/> task through the Robot Framework,<a id="id143" class="indexterm"/> following test can be written with the help of <code class="literal">robotframework-selenium2 library</code>, which was discussed previously:</p><div class="informalexample"><pre class="programlisting">| Perform correct credentials | go to | ${LOGIN URL}
|  | Title Should Be | My Application
|  | Page Should Contain TextField | username
|  | Input Text | username | ${VALID USER} 
|  | Input Password | password | ${VALID PASSWD}
|  | Click Button | Login 
|  | Location Should be | ${SUCCESS URL}</pre></div><p>This test assumes that the Selenium browser is already set up. There are a few variables in use that are quite obvious by their names. The test code is explained as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On start<a id="id144" class="indexterm"/> of the test case, go to the specified URL.</li><li class="listitem">Assert that the title of the page is <code class="literal">My Application.</code></li><li class="listitem">Assert that the page contains the desired elements.</li><li class="listitem">Enter the valid user in the <span class="strong"><strong>Name</strong></span> text field.</li><li class="listitem">Enter the valid password in the <span class="strong"><strong>Password</strong></span> text field.</li><li class="listitem">Instruct Selenium to click on the <span class="strong"><strong>Submit</strong></span> button, the browser then issues the form action.</li><li class="listitem">As a result, the browser is redirected to another page, the URL of which is checked.</li></ol></div><p>To see and run this full test, you are encouraged to check out the test code as well as view the Selenium library. Similarly, you can also assert contents in various pages for some specific text as a form of testing by using the <code class="literal">page should contain</code> keyword.</p></div><div class="section" title="Debugging through the REPL shell"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Debugging through the REPL shell</h2></div></div></div><p>If you are starting with the<a id="id145" class="indexterm"/> Selenium library, you will face problems in setting up the entire Selenium setup. Thankfully, there is a<a id="id146" class="indexterm"/> tool that helps you run the test operations one at a time. This is known as the debug-library and is an REPL shell. <span class="strong"><strong>REPL</strong></span> (<span class="strong"><strong>Read Evaluate Print Loop</strong></span>) like any other console, only accepts a single line and presents its output before requiring the next line. This is quite similar to shells present in various other languages. Its source code is present at:</p><p>
<a class="ulink" href="https://github.com/xyb/robotframework-debuglibrary">https://github.com/xyb/robotframework-debuglibrary</a>
</p><p>To install this on a machine running Python with its packaging manager, use the following:</p><div class="informalexample"><pre class="programlisting">pip install robotframework-debuglibrary</pre></div><p>or:</p><div class="informalexample"><pre class="programlisting">easy_install robotframework-debuglibrary</pre></div><p>After installing this, a command, <code class="literal">rfshell</code> is available. You can use it to perform basic operations and Selenium-specific tasks. The following screenshot shows an example:</p><div class="mediaobject"><img src="graphics/3033OS_04_04.jpg" alt="Debugging through the REPL shell"/></div><p>As soon as <code class="literal">exit</code> is entered in the shell, it exits and a report HTML file is generated at the <code class="literal">home</code> folder of the<a id="id147" class="indexterm"/> user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Note that there is no log or XML file generated anywhere for this.</p></div></div></div></div>
<div class="section" title="Testing desktop applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Testing desktop applications</h1></div></div></div><p>Acceptance testing can<a id="id148" class="indexterm"/> also be implemented in desktop-based applications, making the Robot Framework tests far more applicable rather than just catering to the needs of some specific problem or a framework alone.</p><div class="section" title="Testing through objects – Java Swing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Testing through objects – Java Swing</h2></div></div></div><p>Swing library is a fully featured library that can be used to test Java Swing-based applications. As this<a id="id149" class="indexterm"/> works on Java platform, this needs Jython runtime. To run an acceptance test over a swing application, two things are required in the <code class="literal">classpath</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Swing library JAR</li><li class="listitem" style="list-style-type: disc">The actual swing application bundled as a JAR</li></ul></div><p>On having the necessary files, the test can be used. The classpath can be set prior to the Jython command, or prefixed with the command itself like the following example:</p><div class="informalexample"><pre class="programlisting">CLASSPATH=swinglibrary-1.6.0.jar:myApp.jar jybot testsuites</pre></div><p>Here, the <code class="literal">swinglibrary</code> is version 1.6.0 and the system under test is bundled as <code class="literal">myApp.jar</code>, and the Robot Framework files are present in the <code class="literal">testsuites</code> folder. The application is then visible to the Robot Framework test file and can be accessed through its fully packaged Java Swing <a id="id150" class="indexterm"/>name. The settings table of the test scripts will require the <code class="literal">swinglibrary</code> to be loaded in order to provide all the Swing library specific keywords.</p></div><div class="section" title="A Swing test"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>A Swing test</h2></div></div></div><p>Given the following<a id="id151" class="indexterm"/> application, the test will cover adding and deleting items to and from the given <span class="strong"><strong>Todo List</strong></span>:</p><div class="mediaobject"><img src="graphics/3033OS_04_05.jpg" alt="A Swing test"/></div><p>Just by looking at this Swing application, it is not distinguishable which text field, table, or any other UI element is talked about, so black box testing will not be successful in this case and we need some internals, such as various component names to interact with them. This might feel similar to Selenium as both the libraries provide object-based testing that requires knowledge of the internals of the system under test by the tests themselves.</p><p>Following is the test required to cover various use cases this UI has to offer:</p><div class="informalexample"><pre class="programlisting">| Start test | Start Application | fully qualified name of theapplication
|  | Select Window | Todo List
|  | Button Should Be Enabled | Add Todo item
|  | Type Into Text Field | description | Get this swingapplication tested.
|  | Push Button | Add Todo item
|  | ${itemCount}= | Get List Item Count | todolist
|  | Should Be Equal As Integers | 1 | ${itemCount}</pre></div><p>This can be explained briefly as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Run the Java application through the <code class="literal">Start Application</code> keyword using the fully qualified name of the Java application (that is, the package and the class name) <a id="id152" class="indexterm"/>which is needed to run the application from the JAR file</li><li class="listitem" style="list-style-type: disc">Select the correct window, which also ascertains that the application has the desired window</li><li class="listitem" style="list-style-type: disc">Check for other basic assumptions, such as the state of various elements</li><li class="listitem" style="list-style-type: disc">Perform various UI operations through intuitively named keywords for the same</li><li class="listitem" style="list-style-type: disc">After typing text and clicking on the <span class="strong"><strong>Add Todo</strong></span> button, the <code class="literal">todolist</code> size should increase</li></ul></div><p>Similarly, other operations for the UI can be performed. Like other external libraries, it is helpful to have its library documentation by the side while writing tests in this library.</p></div></div>
<div class="section" title="Testing through images"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Testing through images</h1></div></div></div><p>This section covers image-based testing, which is different from what has been covered so far. In image-based<a id="id153" class="indexterm"/> testing, the user interface is treated as a black box and no object internals of the applications are exposed.</p><div class="section" title="Sikuli"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Sikuli</h2></div></div></div><p>Sikuli is a leading tool that performs automation through computer vision, that is, recognition <a id="id154" class="indexterm"/>of images on the screen. <a id="id155" class="indexterm"/>As a human being, we can distinguish an object's properties by looking at it, but this is not straightforward in case of computers as computers can only match binary or textual information. Thus, there is a need for computer vision or knowing if a given image is present on a larger screen or not. In simple sense, Sikuli uses the user-supplied screenshot images to perform action over various items and displays the generated script visually in the Sikuli IDE. Following is one such script to do a search:</p><div class="mediaobject"><img src="graphics/3033OS_04_06.jpg" alt="Sikuli"/></div><p>As is evident from<a id="id156" class="indexterm"/> the image, the script does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check if the Chrome browser icon exists on the screen</li><li class="listitem" style="list-style-type: disc">Click on the Chrome browser to open it</li><li class="listitem" style="list-style-type: disc">Wait for<a id="id157" class="indexterm"/> the browser window to open up and display the URL</li><li class="listitem" style="list-style-type: disc">Go to <a class="ulink" href="http://google.com">google.com</a> in the URL bar, which will open up the Google home page</li><li class="listitem" style="list-style-type: disc">Wait for the Google search buttons to show up</li><li class="listitem" style="list-style-type: disc">Perform the desired query in the appropriate text field</li><li class="listitem" style="list-style-type: disc">Verify the results obtained</li><li class="listitem" style="list-style-type: disc">The Sikuli page should appear on the first page of results</li></ul></div><p>However, behind the scenes, the following Python script is generated in the folder where this Sikuli script is saved:</p><div class="informalexample"><pre class="programlisting">exists("1377428833316.png")
click("1377428844996.png")
wait("1377428859228.png")
type("1377428922965.png", 'google.com')
wait("1377428949234.png")
type("1377429289183.png", 'sikuli test automation')
exists("1377429031446.png")</pre></div><p>Apart from this Python script (or its HTML equivalent), there exist various images that are referenced in the test. The important thing is that at runtime, Sikuli runs computer vision software at its core that determines whether it gets a match for the image in the screen and acts accordingly. There is absolutely no need for having any knowledge of internals of the software under test. <a id="id158" class="indexterm"/>While this might seem counterintuitive at first, the lack of control over components and objects is compensated through image-based testing that liberates the test from the system under test, and the tests can thus operate over a wide variety of software platforms, from different desktop applications, mobile emulators, mainframe terminals, web-based, and remote applications using only the contents displayed on the screen as a basis for its input and decision<a id="id159" class="indexterm"/> making ability, just like a human being which is performing manual automated acceptance testing.</p></div><div class="section" title="Creating a custom Sikuli library"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Creating a custom Sikuli library</h2></div></div></div><p>Out of the box, the Robot Framework seems like a complex framework and creation of an external user library looks<a id="id160" class="indexterm"/> like a tedious task. <a id="id161" class="indexterm"/>However, there are times when requirements dictate the need of acceptance test solutions for this. Fortunately, open source solutions like Sikuli have an extensible application platform that is also very well documented. The custom integration of Sikuli with Robot Framework is created and demonstrated by <span class="emphasis"><em>Mykhailo Moroz</em></span> (<a class="ulink" href="http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html">http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html</a>). The approach used in this method is discussed in the following section.</p><p>In order to use the Sikuli as a test validation engine, its API (<a class="ulink" href="http://doc.sikuli.org/javadoc">http://doc.sikuli.org/javadoc</a>) has to be exposed first, which can be done via a clever hack that uses the Python classes used internally in Sikuli. Since this will work in Jython environment, there is a need to have <code class="literal">sikuli-script.jar</code> in the classpath and create a wrapper around the Sikuli API in order to use various methods. The Sikuli API contains a <code class="literal">Screen</code> class that has various methods.</p><p>To make these methods present in the <code class="literal">Screen</code> class global, these methods are manually pushed into the internal global directory and are overridden by customized individual methods:</p><div class="informalexample"><pre class="programlisting">def sikuli_method(name, *args, **kwargs):

    return sys.modules['sikuli.Sikuli'].__dict__[name](*args,**kwargs)</pre></div><p>This lookup is then used to pass the values from the customized methods into the native code that is present internally in the Sikuli engine. For instance, the <code class="literal">click</code> method<a id="id162" class="indexterm"/> can be implemented as follows:</p><div class="informalexample"><pre class="programlisting">def click(target, modifiers=0):

    try:

        return sikuli_method('click', target, modifiers)

    except FindFailed, e:

        raise e</pre></div><p>This wrapper allows the creation of simple Python scripts that can run in Jython environment without requiring the Sikuli X test runner. As there is already <code class="literal">sikuli-script.jar</code> in<a id="id163" class="indexterm"/> the classpath, the tests so created can run without the Sikuli IDE, or in the headless mode.</p><p>As these scripts can run independently in the Jython environment, these can be run through Jybot that can employ various Robot Framework scripts that can call these script functions. This creates a solution to drive a collection of multiple Sikuli scripts as test cases in such an order that performs a large task through the collection of different small scripts.</p><p>To run this example, we need to have the following prerequisites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Robot Framework installed correctly with the Jython runtime</li><li class="listitem" style="list-style-type: disc">Sikuli is installed properly and <code class="literal">sikuli-home</code> environment variable points to its root folder</li></ul></div><p>The following commands in the batch file runs the application by setting up the environment needed for all the softwares involved:</p><div class="informalexample"><pre class="programlisting">set sikuli_jar=%sikuli_home%sikuli-script.jar
set CLASSPATH=%sikuli_jar%
set JYTHONPATH=%sikuli_jar%/Lib
call jybot --pythonpath=TestLib ^
      --outputdir=results ^
      --loglevel=TRACE ^
      --output "%~d0%~p0results\output.xml" ^
      --log "%~d0%~p0results\log.html" ^
      --report "%~d0%~p0results\report.html" ^
      testsuite</pre></div><p>Since, we are using different Sikuli scripts as different test cases, we will import these as custom tests in our Robot Framework test files, which are kept in the <code class="literal">testlib</code> folder in order to keep things simple in this example:</p><div class="informalexample"><pre class="programlisting">***Settings***
Library  TestAction1.XTest  WITH NAME  TestAction1
Library  2ndcase1staction.XTest  WITH NAME  2ndcase1staction
Library  anotheraction.XTest  WITH NAME  anotheraction
***Test Cases***
Test Case 1
  TestAction1.Execute
Test Case 2
  2ndcase1staction.Execute
  anotheraction.Execute</pre></div><p>The <code class="literal">library</code> file is actually a customized Sikuli script written in Python that calls the Sikuli API to work <a id="id164" class="indexterm"/>as a headless Sikuli instance:</p><div class="informalexample"><pre class="programlisting">from __future__ import with_statement
from sikuliwrapper import *
addImagePath(common.cfgImageLibrary) #uses the values supplied by the robot framework.
Settings.MinSimilarity = 0.9  # Image present on the screen should match 90% or more than the provided image.

class XTest(BaseLogger):
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'
    
    def __init__(self):
        None
    def Execute(self, *args):
        type("this is a reference test example")
        wait(0.485)
        ...</pre></div><p>To make these tests image-based, you can call functions such as <code class="literal">click</code>, <code class="literal">validate</code>, <code class="literal">type</code>, and so on, with the path to the sample image file used as its input argument.</p><p>Apart from the <code class="literal">test</code> and <code class="literal">library</code> files, there is a <code class="literal">sikuliwrapper.py</code> file, which provides Sikuli methods into these library file invocations:</p><div class="informalexample"><pre class="programlisting">from logger import *
from sikuli.Sikuli import Region as SikuliRegion
from sikuli.Sikuli import Screen as SikuliScreen
log = RobotLogger()
class VerifyException(RuntimeError):
    ROBOT_CONTINUE_ON_FAILURE = True
# function for calling native sikuli methods
def sikuli_method(name, *args, **kwargs):
    return sys.modules['sikuli.Sikuli'].__dict__[name](*args, **kwargs)

# overwritten Screen.exists method
def exists(target, timeout=0):
    addFoundImage(getFilename(target))
    return sikuli_method('exists', target, float(timeout))
…</pre></div><p>Similarly, other Sikuli API calls can also be wrapped to provide an easy interface to the library file, which in<a id="id165" class="indexterm"/> turn is called by the Robot Framework test.</p><p>However, in case of image-based testing, failures should be descriptive. To do this, screenshot can be taken at the instance when something fails or succeeds, which requires you to create a custom logger:</p><div class="informalexample"><pre class="programlisting">import logging
import datetime
import shutil
from sikuli.Sikuli import *

# Properly set the logging mechanism
logging.addLevelName(logging.WARNING, 'WARN')
HTML = logging.INFO + 5
logging.addLevelName(HTML, 'HTML')

class RobotLogger(logging.Logger):
    def __init__(self, name='robot', level=logging.INFO):
        level = logging.DEBUG
        logging.Logger.__init__(self, name, level)
        self.addHandler(RobotHandler())

    def _get_unique_name(self, prefix="", suffix=""):
        now = datetime.datetime.now()
        return prefix + now.strftime('%Y-%m-%d_%H-%M-%S') + suffix

    def screenshot(self, msg='', folder='results/screenshots/', region=(0,0,1440,900)):
        name = self._get_unique_name(suffix=".png")
        img_src = capture(*region)    # Actual call to capture the entire screen
        shutil.copy(img_src, folder + name)
        self.html_img(msg, folder + name)

    def passed(self, msg, *args, **kwargs):
        self.info('PASS: ' + msg, *args, **kwargs)

    def failed(self, msg, *args, **kwargs):
        if self.isEnabledFor(logging.DEBUG):
            if len(getLastFoundImages()) != 0:
                self.html_img("Source Image",  'images/' + getLastFoundImage())
            self.screenshot()
        raise common.VerificationFailed(msg)

    def html(self, msg, *args, **kwargs):
        self.log(HTML, msg, *args, **kwargs)

    def html_img(self, msg, image):
        self.html('%s &lt;img src="../%s" /&gt;' % (msg, image))
…</pre></div><p>These are the essential files required to properly run and log the Sikuli-based applications easily with the Robot Framework. The output can be viewed in the following example by opening notepad<a id="id166" class="indexterm"/> and running the application:</p><div class="mediaobject"><img src="graphics/3033OS_04_07.jpg" alt="Creating a custom Sikuli library"/></div></div></div>
<div class="section" title="Other noteworthy libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Other noteworthy libraries</h1></div></div></div><p>There are various other libraries that extend the capabilities of the Robot Framework in areas that are not normally seen as candidates for acceptance tests, but will benefit from test automation, if done in the right way. Some of these libraries are as follows.</p><div class="section" title="Testing network protocols"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Testing network protocols</h2></div></div></div><p>Rambock is a test <a id="id167" class="indexterm"/>library that provides an easy way to test various network packets, protocols, and message templates:</p><p>
<a class="ulink" href="https://github.com/robotframework/Rammbock">https://github.com/robotframework/Rammbock</a>
</p><p>It allows you to specify the custom protocol, its client and servers; messages, and both the traditional as well as custom protocols can be tested.</p></div><div class="section" title="Testing the web services"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Testing the web services</h2></div></div></div><p>Suds<a id="id168" class="indexterm"/> is a lightweight. but <a id="id169" class="indexterm"/>dynamic SOAP Python client for consuming web services:</p><p>
<a class="ulink" href="https://github.com/ombre42/robotframework-sudslibrary">https://github.com/ombre42/robotframework-sudslibrary</a>
</p></div><div class="section" title="Testing the database"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Testing the database</h2></div></div></div><p>The database persistence and contents can be tested through the <code class="literal">robotframework-databaselibrary</code>. Here<a id="id170" class="indexterm"/> the database is queried to find out its state and perform things, such as running the SQL scripts:</p><p>
<a class="ulink" href="http://franz-see.github.io/Robotframework-Database-Library">http://franz-see.github.io/Robotframework-Database-Library</a>
</p><p>A similar library exists for interacting through JDBC, which is handy especially for databases that otherwise are not supported for testing:</p><p>
<a class="ulink" href="https://github.com/ThomasJaspers/robotframework-dblibrary">https://github.com/ThomasJaspers/robotframework-dblibrary</a>
</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, a lot of external tools and libraries were discussed that extend the capabilities of the Robot Framework. First the web application testing was demonstrated through Selenium and its REPL shell that is handy to debug applications. Next, Java-based desktop application testing through the use of object-based testing was demonstrated. The Sikuli application and image-based testing was explained along with an in-depth case study which further explored the extensibility of its API to create a Robot Framework-friendly solution. Finally, some of the other popular libraries were listed.</p><p>In the next chapter, we will look into test reporting operations to understand what the different outputs generated and how can we perform various desired operations with generated reports and customize test outputs.</p></div></body></html>