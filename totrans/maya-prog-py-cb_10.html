<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Advanced Topics"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Advanced Topics</h1></div></div></div><p>In this chapter, we'll look at the following few advanced topics that can be used to take your scripts farther:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wrapping Python functionality in MEL</li><li class="listitem" style="list-style-type: disc">Creating custom tools using contexts</li><li class="listitem" style="list-style-type: disc">Using script jobs to trigger custom functionality</li><li class="listitem" style="list-style-type: disc">Using script nodes to embed code in scenes</li><li class="listitem" style="list-style-type: disc">Combining script jobs and script nodes</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Introduction</h1></div></div></div><p>In this chapter, we'll look at a few advanced topics that can be used to give your scripts extra polish and make them easier to use for your teammates. We'll see how to make your scripts work like Maya's built-in tools using contexts, trigger custom functionality in response to events using script jobs, and embed code into a scene using script nodes.</p><p>Finally, we'll look at a tool that can be used to embed custom functionality in a scene and trigger it when a specific object is selected (very useful for invoking complex UIs for character rigs, for example).</p></div></div>
<div class="section" title="Wrapping Python functionality in MEL"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Wrapping Python functionality in MEL</h1></div></div></div><p>Although <a id="id354" class="indexterm"/>Python is definitely the preferred way to go <a id="id355" class="indexterm"/>about scripting for Maya, there are some features that still require you to use MEL. We'll be seeing several of those features in this chapter, but first we'll need to look at how to call Python code from MEL.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec200"/>Getting ready</h2></div></div></div><p>First off, we'll <a id="id356" class="indexterm"/>need a Python script to call. You can either use something you've already written or make something new. For the sake of this example, I'll use a new script that simply creates a NURBS sphere at the origin, as follows:</p><div class="informalexample"><pre class="programlisting"># listing of pythonFromMel.py
import maya.cmds as cmds

def makeSphere():
    cmds.sphere()</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec201"/>How to do it...</h2></div></div></div><p>In this example, we'll create an MEL script that will in turn call our Python script. Create a new file and add the following code, being sure to save it with a <code class="literal">.mel</code> extension. In this case, we'll create a file named <code class="literal">melToPython.mel</code>:</p><div class="informalexample"><pre class="programlisting">global proc melToPython()
{
    python "import pythonFromMel";
    python "pythonFromMel.makeSphere()";
}</pre></div><p>Note that the function defined in the file has the same name as the file itself; this is a standard practice when creating MEL scripts, and it is used to indicate the entry point for the script. You can certainly have multiple functions within the script, but there should generally always be one with the same name as the file, and that function should be the starting point for your script.</p><p>Be sure to save the script to one of Maya's default script locations. On a Mac system, that means:</p><div class="informalexample"><pre class="programlisting">/Users/Shared/Autodesk/Maya/(Version)/scripts</pre></div><p>And on a PC, it means:</p><div class="informalexample"><pre class="programlisting">\Documents and Settings\&lt;username&gt;\My Documents\maya</pre></div><p>Once you've done this, you'll need to make sure that Maya is aware of the new script, which means calling the rehash MEL command from within Maya. Switch your command line to MEL by clicking to the left of the text field, where it says <span class="strong"><strong>Python</strong></span>. Alternatively, switch to the <span class="strong"><strong>MEL</strong></span> tab in the script editor and enter your code there.</p><p>The rehash command forces Maya to re-examine its list of known script locations and take note of any new MEL scripts that have been added. This happens automatically every time Maya starts up, but if you make a new script with Maya open and attempt to run it without first calling rehash, Maya will give you an error.</p><p>Once you've run rehash, you can run our new MEL script by entering the name of the script into either the command line or the script editor. Doing so should result in a new NURBS sphere appearing at the origin.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec202"/>How it works...</h2></div></div></div><p>The MEL script<a id="id357" class="indexterm"/> is pretty straightforward. Note that functions are defined in a slightly different manner, with a few minor differences. The <code class="literal">proc</code> keyword (short for <span class="emphasis"><em>procedure</em></span>) serves the same purpose as <code class="literal">def</code> in Python, indicating a named block of code. Also, instead of having a colon after the parentheses, curly brackets are used to enclose the actual code.</p><p>The <code class="literal">global</code> keyword indicates that this particular function is meant to be called from outside the script. It is very common practice when writing MEL to have a global procedure with the same name as the file, which serves as the entry point for the script.</p><p>We're mainly interested in getting this script to invoke some Python functionality, though. To do that, we rely on the <code class="literal">python</code> MEL command. The <code class="literal">python</code> command takes a string as an argument and will attempt to run that string as a line of Python.</p><p>For example, if we wanted to invoke Python's <code class="literal">print</code> command from MEL, we could do the following:</p><div class="informalexample"><pre class="programlisting">python "print('hello from Python')"</pre></div><p>Note that MEL differs from Python in that arguments to built-in functions are <span class="emphasis"><em>not</em></span> enclosed in parentheses. So, in the previous example, the <code class="literal">python</code> command receives a string as its single argument. That string is passed to the Python interpreter and, in this case, results in some text being printed.</p><p>To actually run a Python script from MEL, we'll need to do two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the import statement to load the script</li><li class="listitem" style="list-style-type: disc">Invoke a function from within the script</li></ul></div><p>That means that we need to call MEL's <code class="literal">python</code> command twice. Importing is fairly simple:</p><div class="informalexample"><pre class="programlisting">python "import pythonFromMel";</pre></div><p>The second line requires a bit of explanation. When we use the <code class="literal">import</code> command to load a script, the script is loaded as a module. Each of the functions defined in the script are attributes of the module. So, to invoke a function defined the script, we'll want to use the following syntax:</p><div class="informalexample"><pre class="programlisting">moduleName.functionName()</pre></div><p>Wrapping that in a string and passing it to MEL gives us the following for the <code class="literal">makeSphere()</code> function defined in the <code class="literal">pythonFromMel</code> script:</p><div class="informalexample"><pre class="programlisting">python "pythonFromMel.makeSphere()";</pre></div><p>We could optionally combine both the <code class="literal">import</code> statement and the call to <code class="literal">makeSphere</code> into a single line. To do that, we'll need to separate out the two statements with a semicolon. While Python<a id="id358" class="indexterm"/> doesn't <span class="emphasis"><em>require</em></span> semicolons at the end of statements, it does allow them. In most cases, that's not necessary, but if you need to have multiple statements on a single line, it can be useful.</p><p>If we did that, we would end up with the following:</p><div class="informalexample"><pre class="programlisting">python "import pythonFromMel; pythonFromMel.makeSphere()";</pre></div><p>This will prove useful later, when we need to pass in MEL commands to invoke Python functionality as a single line.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec203"/>There's more...</h2></div></div></div><p>It should be mentioned that Maya provides a built-in utility for creating MEL scripts from a given Python script, in the <code class="literal">createMelWrapper</code> command, defined as part of the <code class="literal">maya.mel</code> library.</p><p>If we wanted to invoke that on the <code class="literal">makeSphere</code> function that we used in this example, we could do that by running the following code in the <span class="strong"><strong>Python</strong></span> tab of the script editor:</p><div class="informalexample"><pre class="programlisting">import maya.mel as mel

maya.mel.createMelWrapper(pythonFromMel.makeSphere)</pre></div><p>That would prompt you for a place to save the created MEL script. If you open the created script, you'll see something like the following:</p><div class="informalexample"><pre class="programlisting">global proc makeSphere () {
    python("from pythonFromMel import makeSphere");

    python("makeSphere()"); }</pre></div><p>Differences in formatting aside, the generated script is almost identical to what we wrote. The only real difference is that it explicitly imports just the <code class="literal">makeSphere</code> command, rather than the entire <code class="literal">pythonFromMel</code> module.</p></div></div>
<div class="section" title="Creating custom tools using contexts"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Creating custom tools using contexts</h1></div></div></div><p>Many of Maya's tools<a id="id359" class="indexterm"/> are used in an interactive manner, with the user specifying inputs as needed, and actions taking place either when the necessary number of inputs have been provided, or the user hits the <span class="emphasis"><em>Enter</em></span> key.</p><p>So far, none of our scripts have worked this way—it has been necessary to have the user explicitly run the script, or press a button. That works fine for many things, but providing interactive input can add a lot of polish to a script. In this example, we'll be doing exactly that.</p><p>We'll create a<a id="id360" class="indexterm"/> script that, once invoked, prompts the user to select two or more objects. When they press the <span class="emphasis"><em>Enter</em></span> key, we'll create a locator at the average position of all of the objects. To do that, we'll need to create a custom context to implement our very own tool.</p><div class="mediaobject"><img src="graphics/4657_10_01.jpg" alt="Creating custom tools using contexts"/><div class="caption"><p>Our custom tool in action. Left image is the tool while it's being used (notice the custom "AVG" icon on the left), and right image shows the result—a new locator at the average position of the selected objects</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec204"/>Getting ready</h2></div></div></div><p>The script as presented makes use of a custom icon. While it's not required, it's a nice bit of polish. If you want to do that as well, create a 32 by 32 pixel transparent PNG, and save it to the icons folder. On a mac, that would be:</p><div class="informalexample"><pre class="programlisting">/Users/Shared/Autodesk/Maya/icons/</pre></div><p>...and on a PC, it means:</p><div class="informalexample"><pre class="programlisting">\Documents and Settings\&lt;username&gt;\My Documents\maya\icons\</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec205"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code. Be sure to name it <code class="literal">customCtx.py</code>.</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def startCtx():
    print("starting context")

def finalizeCtx():
    objs = cmds.ls(selection=True)

    numObjs = len(objs)
    xpos = 0
    ypos = 0
    zpos = 0

    for o in objs:
        # print(o)
        pos = cmds.xform(o, query=True, worldSpace=True, translation=True)
        # print(pos)
        xpos += pos[0]
        ypos += pos[1]
        zpos += pos[2]

    xpos /= numObjs
    ypos /= numObjs
    zpos /= numObjs

    newLoc = cmds.spaceLocator()
    cmds.move(xpos, ypos, zpos, newLoc)

def createContext():
    toolStartStr = 'python("customCtx .startCtx()");'
    toolFinishStr = 'python("customCtx .finalizeCtx()");'

    newCtx = cmds.scriptCtx(i1='myTool.png', title='MyTool', setNoSelectionPrompt='Select at least two objects',toolStart=toolStartStr, finalCommandScript=toolFinishStr, totalSelectionSets=1, setSelectionCount=2, setAllowExcessCount=True, setAutoComplete=False, toolCursorType="create")

    cmds.setToolTo(newCtx)

createContext()</pre></div><p>If you run <a id="id361" class="indexterm"/>the script, you'll see that Maya activates your new icon in the left UI, just like is the case with any of the other tools. <span class="emphasis"><em>Shift</em></span>-select at least two objects, and press the <span class="emphasis"><em>Enter</em></span> key. You'll see a new locator appear at the averaged position of the selected objects.</p><p>As an additional feature, you'll find that the <span class="emphasis"><em>Y</em></span> hotkey, which can be used to re-invoke the most recently used tool, will also start your script over again.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec206"/>How it works...</h2></div></div></div><p>First off, we<a id="id362" class="indexterm"/> create a couple of functions that will be used by the new context, one that gets called when it starts, and another that gets called when it ends. The <code class="literal">start</code> script is very simple (just prints some text) and is just included for demonstration purposes.</p><div class="informalexample"><pre class="programlisting">def startCtx():
    print("starting context")</pre></div><p>The function that gets called at the end is a bit more involved, but still nothing too complex. We start by grabbing the currently-selected objects, and setting up a few variables—one to hold the number of objects, and one each for the x, y, and z position that we'll create the locator at.</p><div class="informalexample"><pre class="programlisting">def finalizeCtx():
    objs = cmds.ls(selection=True)

    numObjs = len(objs)
    xpos = 0
    ypos = 0
    zpos = 0</pre></div><p>Next, we run through all of the objects and grab their position using the <code class="literal">xform</code> command in query mode. We add each of the x, y, and z positions to our variables to create a running tally of positions.</p><div class="informalexample"><pre class="programlisting">    for o in objs:
        # print(o)
        pos = cmds.xform(o, query=True, worldSpace=True, translation=True)
        xpos += pos[0]
        ypos += pos[1]
        zpos += pos[2]</pre></div><p>We then divide each of the position variables by the number of objects to average the positions, create a new locator, and move it to the averaged position.</p><div class="informalexample"><pre class="programlisting">    xpos /= numObjs
    ypos /= numObjs
    zpos /= numObjs

    newLoc = cmds.spaceLocator()
    cmds.move(xpos, ypos, zpos, newLoc)</pre></div><p>Now for the fun part—actually setting up a custom context. We start by creating MEL strings that can be used to invoke our two functions. In both cases, they simply call one of the functions defined as part of our script.</p><div class="informalexample"><pre class="programlisting">def createContext():
    toolStartStr = 'python("customCtx .startCtx()");'
    toolFinishStr = 'python("customCtx .finalizeCtx()");'</pre></div><p>Note that <a id="id363" class="indexterm"/>we're not explicitly importing <code class="literal">customCtx</code> before invoking the functions (as we did in the previous example). That's because we're using functionality defined within the same script, so if this code is executing at all, the <code class="literal">customCtx</code> script must have already been imported.</p><p>Now we're ready for the main event- creating a new context using the <code class="literal">scriptCtx</code> command.</p><div class="informalexample"><pre class="programlisting">newCtx = cmds.scriptCtx(i1='myTool.png', title='MyTool', setNoSelectionPrompt='Select at least two objects',toolStart=toolStartStr, finalCommandScript=toolFinishStr, totalSelectionSets=1, setSelectionCount=2, setAllowExcessCount=True, setAutoComplete=False, toolCursorType="create")</pre></div><p>As you can see, this is a pretty big command, so let's go through the arguments. First off, we use the <code class="literal">i1</code> flag to specify the icon to use for the tool. You can leave this out, but if you do, Maya will highlight a blank spot in the UI while your tool is active. Be sure to make the icon 32x32 pixels, and to put it in the icons folder (see <span class="emphasis"><em>Getting ready</em></span>, above).</p><p>Next, we set the title. This is also optional, but will make the text that appears a bit more useful for the user. Similarly, we could leave out the <code class="literal">setNoSelectionPrompt</code> flag, but it's best to leave it in. Setting both the title and <code class="literal">setNoSelectionPrompt</code> flag will cause helpful text to show up in bottom of Maya's interface.</p><p>Now we get to the meat of the command, with the <code class="literal">toolStart</code> and <code class="literal">finalCommandScript</code> flags. Both have to be passed a single string that corresponds to a MEL command that should be run either at the start of the script, or when <span class="emphasis"><em>Enter</em></span> is pressed. We pass in the MEL strings that we created for each, which will in turn invoke Python functionality.</p><p>The next set of flags all have to do with the specifics of the selection. First off, we set the number of selection sets to <code class="literal">1</code>, meaning that we want a single collection of items. After that, we use the <code class="literal">setSelectionCount</code> flag to specify that there should be at least two items selected for the tool to function. In this case, we also want to allow for the user to select more than two objects, so we set the <code class="literal">setAllowExcessCount</code> flag to <code class="literal">true</code>. Since we want to allow the user to specify a variable number of objects, and not finish the command until they press <span class="emphasis"><em>Enter</em></span>, we need to set <code class="literal">setAutoComplete</code> to <code class="literal">false</code>. Setting it to <code class="literal">true</code> would cause the final command script to be run as soon as the user had selected objects equal to the <code class="literal">setSelectionCount</code> number. That's certainly useful in some cases, but isn't what we want here.</p><p>Finally, we <a id="id364" class="indexterm"/>set the <code class="literal">toolCursorType</code> flag to <code class="literal">create</code>. That will set the cursor that gets used during the tool. Maya offers a number of different options, and choosing the best one for your purposes can be a great way to add a professional touch to your tool (as well as give the user some quality feedback). For the list of options, be sure to check the documentation for the <code class="literal">scriptCtx</code> command.</p><p>Whew—that was a lot of flags, but we're done, and ready to wrap things up. At this point in the script, we've created the new context, but it is not yet active. To actually invoke the tool, we need to use the <code class="literal">setToolTo</code> command, and pass in the output of the call to <code class="literal">scriptCtx</code>.</p><div class="informalexample"><pre class="programlisting">cmds.setToolTo(newCtx)</pre></div><p>And with that, we've added a brand-new tool to Maya.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec207"/>There's more...</h2></div></div></div><p>In this example, we created our own, custom tool. You can also invoke Maya's built-in tools by using the appropriate command to create a context of that type, and then switching to it using <code class="literal">setToolTo</code>.</p><p>For example, you might be creating a script to allow users to create character rigs in a semi-automated way. You might, as a part of that, want to have the user create some bones that are then manipulated further by your system. You could have that process begin with the user creating some bones using the joint tool. To drop them straight into bone creation after invoking your script, you could use the following:</p><div class="informalexample"><pre class="programlisting">makeBoneCtx = cmds.jointCtx()
cmds.setToolTo(makeBoneCtx)</pre></div><p>There are a large number of contexts that you can create—consult the Maya documentation for the full list.</p><p>Something else you might find useful is the ability to reset the current context, which will discard any input so far and reset the current tool. You can do that with either your own custom tools or with those built into Maya. Either way, reset the current tool with the following:</p><div class="informalexample"><pre class="programlisting">cmds.ctxAbort()</pre></div><p>Contexts are a great way to add polish to your scripts, but should only really be used when it makes sense to have the user add input in an interactive way, or if you expect the user to want to use your tool more than once in rapid succession. If you have a script that you only expect the user to use once, with a limited (and fixed) number of inputs, it's likely easier to just provide a button. However, if your script needs to work with a variable number of inputs and or be called again on a new set without re-invoking the script, you may <a id="id365" class="indexterm"/>want to consider creating a context. Another way to look at it is that you should only use contexts when they would offer a net <span class="emphasis"><em>reduction</em></span> in work (as measured in number of clicks) for the user.</p></div></div>
<div class="section" title="Using script jobs to trigger custom functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Using script jobs to trigger custom functionality</h1></div></div></div><p>Script jobs<a id="id366" class="indexterm"/> offer another alternative to explicitly calling scripts, or pressing buttons, to invoke your functionality. By using <a id="id367" class="indexterm"/>script jobs, it is possible to trigger custom functionality based on either a specific condition or a specific event.</p><p>In this example, we'll create a script job that will respond to the selection changed event by printing the name and type of the selected object to the console.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec208"/>Getting ready</h2></div></div></div><p>One of the things that makes script jobs so useful is the fact that they persist (as opposed to just running once). However, that can make developing scripts that use them a bit difficult, since if you change your code and re-run your script, you'll end up with multiple script jobs in your scene. For that reason, it's good to give yourself a way to easily clear out all existing script jobs. The following script will do just that:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def killAll():
    cmds.scriptJob(killAll=True, force=True)
    print('KILLED ALL JOBS')

killAll()</pre></div><p>Running the <code class="literal">scriptJob</code> command with the <code class="literal">killAll</code> flag will clear out all normal script jobs in the scene. However, script jobs can also be created as either <code class="literal">protected</code> or <code class="literal">permanent</code>. Adding the force flag will also clear out protected script jobs as well, but be careful with that, as Maya uses <code class="literal">scriptJobs</code> to implement some of its UI functionality. To be totally safe, leave off the <code class="literal">force=True</code> flag and make sure that the <code class="literal">scriptJobs</code> you create are not protected.</p><p>Permanent script jobs will persist until you create a new scene, but that shouldn't come up in development. Even if you really do want a permanent script job, it's best to develop it with default priority and upgrade it to permanent only once you're certain that you're getting the functionality you want.</p><p>Be sure to have the above script (or similar) available before you start working with script jobs, as it will definitely make your life a lot easier.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec209"/>How to do it...</h2></div></div></div><p>Create a new script and<a id="id368" class="indexterm"/> add the following code. Be sure to name the file <code class="literal">selectionOutput.py</code>:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import sys

def selectionChanged():
    objs = cmds.ls(selection=True)

    if len(objs) &lt; 1:
        sys.stdout.write('NOTHING SELECTED')
    else:
        shapeNodes = cmds.listRelatives(objs[0], shapes=True)
        msg = objs[0]
        if (len(shapeNodes) &gt; 0):
            msg += ": " + cmds.nodeType(shapeNodes[0])

        sys.stdout.write(msg)

def makeEventScriptJob():
    cmds.scriptJob(event=["SelectionChanged", selectionChanged], killWithScene=True)

makeEventScriptJob()</pre></div><p>Run the <a id="id369" class="indexterm"/>above script, and you should see text appear in the bottom of Maya's UI every time you select (or deselect) an object.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec210"/>How it works...</h2></div></div></div><p>First off, note that we're importing the sys (or system) library in addition to our standard <code class="literal">maya.cmds</code>. That's to allow us to print text to the command line, so that it will be visible to the user even if they don't have the script editor open. More on that in a bit.</p><p>Before we create the <code class="literal">scriptJob</code>, we'll want to create the code we want it to call. In this case, we'll be triggering code every time the selection changes, and we want that code to examine the currently-selected object(s). We start, as we have in other examples, by using ls to grab the selection:</p><div class="informalexample"><pre class="programlisting">def selectionChanged():
    objs = cmds.ls(selection=True)</pre></div><p>Then, if we find that there is nothing selected, we output some text to the command line.</p><div class="informalexample"><pre class="programlisting">    if len(objs) &lt; 1:
        sys.stdout.write('NOTHING SELECTED')</pre></div><p>And here's <a id="id370" class="indexterm"/>where that <code class="literal">sys</code> library comes in—by using <code class="literal">sys.stdout.write</code>, we are able to output text directly to the command line. That can be a good way to provide feedback to the users of your scripts, since you shouldn't expect them to have the script editor open. Note that we <span class="emphasis"><em>could</em></span> have used either the error or warning commands as well, but since this text is simply output, and neither an error nor a warning, it is better to use <code class="literal">stdout.write</code>.</p><p>The rest of<a id="id371" class="indexterm"/> the <code class="literal">selectionChanged</code> function is pretty straightforward. The only slightly tricky thing is that if we look at the node type for the selected nodes themselves, we're guaranteed to get nothing but transforms. To avoid that, we first check to see if there are any shape nodes connected to the node in question. If there are, we append the node type for the shape to the name of the object, and output that to the command line.</p><div class="informalexample"><pre class="programlisting">    else:
        shapeNodes = cmds.listRelatives(objs[0], shapes=True)
        msg = objs[0]
        if (len(shapeNodes) &gt; 0):
            msg += ": " + cmds.nodeType(shapeNodes[0])

        sys.stdout.write(msg)</pre></div><p>Now we're ready for the fun part—actually making <code class="literal">scriptJob</code>. All <code class="literal">scriptJobs</code> require that we specify either an event or a condition, along with some code to execute when the event is triggered, or when the condition assumes a given value (true, false, or when it changes).</p><p>It's important to note that the events and conditions must correspond to those that are built into Maya. In this case, we'll be using the <code class="literal">SelectionChanged</code> event as our trigger. This will fire every time the selection changes for any reason, and no matter how many objects are selected (including zero).</p><p>To actually create the <code class="literal">scriptJob</code>, we use the <code class="literal">scriptJob</code> command.</p><div class="informalexample"><pre class="programlisting">cmds.scriptJob(event=["SelectionChanged", selectionChanged], killWithScene=True)</pre></div><p>In this case, we use the event flag to tell Maya that this <code class="literal">scriptJob</code> should be event-based (as opposed to being based on a condition). The value that we pass into the flag needs to be an array, with the first element being a string that corresponds to the event we want to watch for, and the second being a function to call in response.</p><p>In this case, we want to call our <code class="literal">selectionChanged</code> function in response to the <code class="literal">SelectionChanged</code> event. We also include the <code class="literal">killWithScene</code> flag, which will cause <code class="literal">scriptJob</code> to be destroyed when we leave the current scene, which is generally a good idea. There are certainly valid reasons to have <code class="literal">scriptJob</code> persist from scene to scene, but unless you're <a id="id372" class="indexterm"/>sure that that's what you want, it's usually a good idea to prevent that from happening.</p><p>And that's it! We will now have our custom function called each time the selection changes.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec211"/>There's more...</h2></div></div></div><p>In the <span class="emphasis"><em>Getting ready</em></span> section, we covered a simple script to delete <span class="emphasis"><em>all</em></span> <code class="literal">scriptJobs</code>. That's fine during testing, but can be a bit heavy-handed sometimes. There are many situations where you<a id="id373" class="indexterm"/> might want to delete only a specific <code class="literal">scriptJob</code>—possibly because the functionality it is being used to implement is no longer necessary. That's easily done, but requires you specify which <code class="literal">scriptJob</code> you want to delete.</p><p>When creating a new script job, the <code class="literal">scriptJob</code> command will return an integer that can be used as the ID of the created script job. Later, you can use that number to delete that specific script job while leaving any other script jobs in the scene intact. If you want to delete a script job later, make sure to save the output to a variable as in:</p><div class="informalexample"><pre class="programlisting">jobID = cmds.scriptJob(event=["SelectionChanged", selectionChanged], killWithScene=True)</pre></div><p>Then, to delete the script job, call the <code class="literal">scriptJob</code> command again, but with the kill flag, and passing in the ID, as in:</p><div class="informalexample"><pre class="programlisting">cmds.scriptJob(kill=jobID)</pre></div><p>If the script job you're trying to delete is protected, you'll need to also set the <code class="literal">force</code> flag to <code class="literal">true</code>, as in:</p><div class="informalexample"><pre class="programlisting">cmds.scriptJob(kill=jobID, force=True)</pre></div><p>You can also use the <code class="literal">scriptJob</code> command to get a list of all of the script jobs currently active. To do that, run it with the <code class="literal">listJobs</code> flag set to <code class="literal">True</code>. For example:</p><div class="informalexample"><pre class="programlisting">jobs = cmds.scriptJob(listJobs=True)

for j in jobs:
        print(j)</pre></div><p>...which would result in something like the following:</p><div class="informalexample"><pre class="programlisting">0:  "-permanent" "-event" "PostSceneRead" "generateUvTilePreviewsPostSceneReadCB"
1:  "-permanent" "-parent" "MayaWindow" "-event" "ToolChanged" "changeToolIcon"</pre></div><p>...as well as a long list of other script jobs used by Maya, as well as any that you have added. The number on the left is the ID of the job, and can be used to delete it (as long as it isn't <span class="emphasis"><em>permanent</em></span>).</p><p>As an alternative to<a id="id374" class="indexterm"/> deleting all jobs, or deleting individual jobs by ID, you can also have Maya delete a script job when a given piece of UI is deleted. For example, if we wanted to have a script job that would only exist as long as a given window was open, we could do something like the following:</p><div class="informalexample"><pre class="programlisting">def scriptJobUI():
    win = cmds.window(title="SJ", widthHeight=(300, 200))

    cmds.scriptJob(parent=win, event=["SelectionChanged", respondToSelection])

    cmds.showWindow(win)</pre></div><p>Notice the<a id="id375" class="indexterm"/> addition of the <code class="literal">parent</code> flag in the call to <code class="literal">cmds.scriptJob</code>. You can include that flag to tie the script job to a specific piece of UI. In this case, we tie the script job to the window.</p></div></div>
<div class="section" title="Using script nodes to embed code in scenes"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Using script nodes to embed code in scenes</h1></div></div></div><p>All of <a id="id376" class="indexterm"/>the examples we've seen so far exist as scripts, separate from the actual scene that they are run in. That's fine for tools, but means that if you create a script that is tightly tied to a particular scene (such as a custom control UI for a character rig), you have to be careful to make sure that the script file is always distributed along with the Maya file.</p><p>For such <a id="id377" class="indexterm"/>situations, Maya offers a better way. Script nodes can be used to bake scripts directly into a scene, allowing them to be run without any external dependencies. Furthermore, script nodes can be created with code.</p><p>In this example, we'll create a script that will prompt the user for a Python file, and will then create a script node with the contents of the file, and set it up so that the script will be executed each time the file is opened.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec212"/>Getting ready</h2></div></div></div><p>To use the script we'll be creating, we'll need to have a script ready to embed. For the sake of the example, I'll be using a simple script that shows a window containing a single button to create <a id="id378" class="indexterm"/>a NURBS sphere.</p><p>The full script is as follows:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def testUI():
    win = cmds.window(title="Script Node", widthHeight=(300,200))
    cmds.columnLayout()
    cmds.button(label="Make Sphere", command="cmds.sphere()")
    cmds.showWindow(win)

testUI()</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How to do it...</h2></div></div></div><p>Create a new <a id="id379" class="indexterm"/>script and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def createScriptNode():
    filePath = cmds.fileDialog2(fileMode=1, fileFilter="Python files (*.py)")

    if (filePath == None):
        return

    f = open(filePath[0], "r")

    scriptStr = ""

    line = f.readline()
    while (line):
        scriptStr += line
        line = f.readline()

    f.close()

    cmds.scriptNode(sourceType="python", scriptType=2, beforeScript=scriptStr)

createScriptNode()</pre></div><p>Run the script, and point the resulting file browser at the script that you want to embed. Save your file, and re-open it. You should see your embedded script run automatically.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec214"/>How it works...</h2></div></div></div><p>The first thing that<a id="id380" class="indexterm"/> we do is to invoke the <code class="literal">fileDialog2</code> command to prompt the user to provide a Python file.</p><div class="informalexample"><pre class="programlisting">def createScriptNode():
    filePath = cmds.fileDialog2(fileMode=1, fileFilter="Python files (*.py)")</pre></div><p>If the user cancels out of the dialog without specifying a file, <code class="literal">filePath</code> will be empty. We check for that and end the script early if it is.</p><div class="informalexample"><pre class="programlisting">    if (filePath == None):
        return</pre></div><p>If we <span class="emphasis"><em>do</em></span> have a file, we open it for reading, in text mode.</p><div class="informalexample"><pre class="programlisting">f = open(filePath[0], "r")</pre></div><p>At this <a id="id381" class="indexterm"/>point, we're ready to prep the script for embedding. The <code class="literal">scriptNode</code> command will be expecting a single string for the code that makes up the script node, so we'll need to create such a string. To do that, we'll start out with a blank string, and add each line of the python file specified by the user.</p><div class="informalexample"><pre class="programlisting">    scriptStr = ""

    line = f.readline()
    while (line):
        scriptStr += line
        line = f.readline()</pre></div><p>At this point, the <code class="literal">scriptStr</code> variable holds the entire contents of the specified script. Since we're done with the file, we close it.</p><div class="informalexample"><pre class="programlisting">f.close()</pre></div><p>Now we're ready to actually create the script node. Creating a script node requires that we specify a few different things. First off, we need to specify whether the script is MEL or Python, which we do with the <code class="literal">sourceType</code> flag.</p><p>We also need to specify the conditions under which the code in the script node will be run, which requires that we specify both a condition and whether the code should be executed either before or after it. In this case, we'll be using what is probably the most standard option, in that we'll have the script run once when the scene is first loaded.</p><p>To do that, we want to use the <span class="strong"><strong>Execute on file load</strong></span> option, and set our code using the <code class="literal">beforeScript</code> flag. Putting it all together gives us the following:</p><div class="informalexample"><pre class="programlisting">cmds.scriptNode(sourceType="python", scriptType=2, beforeScript=scriptStr)</pre></div><p>The <code class="literal">scriptType</code> flag specifies the condition, and needs to be an integer between <code class="literal">0</code> and <code class="literal">7</code>. Using a value of <code class="literal">2</code> will tie the node to the opening of the scene when not in batch mode. If you <a id="id382" class="indexterm"/>wanted to have the script run on opening even in batch mode, use <code class="literal">1</code> instead. Using a value of <code class="literal">0</code> will only run the code when it is explicitly invoked—more on that in a bit. The other options are less commonly used—see the documentation for details.</p><p>Note that there is also an <code class="literal">afterScript</code> flag which can be used to tie code execution to after the given event. If you use that with either of the file load options (1 or 2), it will cause the code to be executed when the file is closed. You can specify scripts for both the <code class="literal">beforeScript</code> and <code class="literal">afterScript</code> flags if you want.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec215"/>There's more...</h2></div></div></div><p>You can <a id="id383" class="indexterm"/>also use <code class="literal">scriptNodes</code> to embed functionality that doesn't execute on its own, but is triggered directly. To do that, specify a value of 0 for the <code class="literal">scriptType</code> (corresponding to the <span class="strong"><strong>Execute on demand</strong></span> option). Then, when you want to invoke the code, call it in the following way:</p><div class="informalexample"><pre class="programlisting">cmds.scriptNode("scriptNodeName", executeBefore=True)</pre></div><p>… to run the "before" script, or..</p><div class="informalexample"><pre class="programlisting">cmds.scriptNode("scriptNodeName", executeAfter=True)</pre></div><p>...to run the "after" script.</p><p>As you work with script nodes, it can be helpful to verify that they have been created without directly triggering them. To do that, go to <span class="strong"><strong>Windows</strong></span> | <span class="strong"><strong>Animation Editors</strong></span> | <span class="strong"><strong>Expression Editor</strong></span>. From the expression editor, go to <span class="strong"><strong>Select Filte</strong></span>r | <span class="strong"><strong>By Script Node Name</strong></span>. You'll see the interface change, and a list of the script nodes in your scene appear. Clicking on any of them will allow you to alter its properties and view or edit the corresponding code.</p><div class="mediaobject"><img src="graphics/4657_10_02.jpg" alt="There's more..."/></div><p>You can <a id="id384" class="indexterm"/>also delete script nodes from this window, if you need to.</p></div></div>
<div class="section" title="Combining script jobs and script nodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Combining script jobs and script nodes</h1></div></div></div><p>One <a id="id385" class="indexterm"/>of the great things about script jobs, and script nodes, is that you can use script nodes to ensure that a given script job travels along with your scene. For example, you might want to use a script job to trigger a custom character rig UI any time the user selects a certain object in the scene.</p><p>In this example, we'll create a script that will make it really easy to set such things up. Our script will perform the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It will ask the user to point it at a Python file with one or more functions to create UI</li><li class="listitem" style="list-style-type: disc">It will present the user with a list of all functions defined in the file in a scroll list</li><li class="listitem" style="list-style-type: disc">It will allow the user to select an object in the scene and a named function from the file</li><li class="listitem" style="list-style-type: disc">It will embed the contents of the function into the scene as a script node, along with a script job that will run the function every time the specified object is selected</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec216"/>Getting ready</h2></div></div></div><p>To use the<a id="id386" class="indexterm"/> script we'll be writing, you'll need to have a script with at least one top-level function definition. Note that the current form of the script cannot parse functionality that is part of a class, and will only deal with a single function at a time, so make sure that all of your functionality is self-contained in a single function. For best results, make sure your input file looks something like this:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def testUI():
    win = cmds.window(title="Script Node", widthHeight=(300,200))
    # add some features here
    cmds.showWindow(win)

def otherUI():
    win = cmds.window(title="Other UI", widthHeight=(300,200))
    # add some features here
    cmds.showWindow(win)</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec217"/>How to do it...</h2></div></div></div><p>Create a new script and add the following:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class EmbedUI():

    def __init__(self):
        self.win = cmds.window(title="Embed UI", widthHeight=(300,400))
        self.commandList = {}

        cmds.columnLayout()

        self.loadButton = cmds.button(label="Load Script", width=300, command=self.loadScript)
        self.makeNodeBtn = cmds.button(label="Tie Script to Current Object", width=300, command=self.makeNode)

        self.functionList = cmds.textScrollList(width=300, numberOfRows=10, selectCommand=self.showCommand)

        cmds.showWindow(self.win)

    def loadScript(self, args):

        self.commandList = {}

        filePath = cmds.fileDialog2(fileMode=1, fileFilter="Python files (*.py)")

        if (filePath == None):
            return

        f = open(filePath[0], "r")

        functionName = ""
        functionStr = ""

        line = f.readline()

        while (line):
            parts = line.split()

            if (line.startswith("import")):
                pass

            elif (line.startswith("def")):
                if (functionName != "" and functionStr != ""):
                    self.commandList[functionName] = functionStr

                functionName = parts[1].replace("():", "")
                functionStr += line

            elif (line.strip() == ""):
                # possibly blank line, check for tab
                if (line.startswith("\t") == False):
                    # blank line, see if we have a function
                    if (functionName != "" and functionStr != ""):
                        self.commandList[functionName] = functionStr
                        functionName = ""
                        functionStr = ""
            else:
                functionStr += line

            line = f.readline()

        f.close()
        self.updateList()

    def updateList(self):
        cmds.textScrollList(self.functionList, edit=True, removeAll=True)

        for function in self.commandList:
            cmds.textScrollList(self.functionList, edit=True, append=function)

    def showCommand(self):
        command = cmds.textScrollList(self.functionList, query=True, selectItem=True)[0]

    def makeNode(self, args):
        command = cmds.textScrollList(self.functionList, query=True, selectItem=True)[0]

        objectName = ""
        objs = cmds.ls(selection=True)

        if (len(objs) &gt; 0):
            objectName = objs[0]

        if (command != "" and objectName != ""):
            print("Tying " + command + " to " + objectName)

            nodeStr = "import maya.cmds as cmds\n\n"

            nodeStr += self.commandList[command] + "\n\n"

            nodeStr += 'def testSelection():\n'
            nodeStr += '\tobjs = cmds.ls(selection=True)\n'
            nodeStr += '\tif (len(objs) &gt; 0):\n'
            nodeStr += '\t\tif (objs[0] == "' + objectName + '"):\n'
            nodeStr += '\t\t\t' + command + '()\n\n'

            nodeStr += 'cmds.scriptJob(killWithScene=True, event=["SelectionChanged", testSelection])'

            cmds.scriptNode(sourceType="python", scriptType=2, beforeScript=nodeStr)

        else:
            cmds.error("Please select a script and an object")

EmbedUI()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec218"/>How it works...</h2></div></div></div><p>First off, we <a id="id387" class="indexterm"/>create a class for our UI, in order to make it easier to pass data around.</p><p>In the <code class="literal">__init__</code> function, we add three items:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A button to load and parse a source file</li><li class="listitem" style="list-style-type: disc">A button to tie a specific function to the selection of a specific object</li><li class="listitem" style="list-style-type: disc">A <code class="literal">textScrollList</code> command to hold the function names and allow the user to select them</li></ul></div><p>We also give ourselves a <code class="literal">commandList</code> variable, which is a dictionary that we'll be using to hold the commands found in the file. The index of each element will be the name of the function, and the value will be the entire source code for that function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Dictionaries are one of Python's built-in data structures, and are equivalent to what are sometimes called <span class="strong"><strong>associative arrays</strong></span> in other languages. The big difference between dictionaries and lists is that, in lists, you specify entries by a numerical index, while with dictionaries you specify entries by name.</p><p>For example, you can create a simple dictionary with <code class="literal">myDict = {'foo':1, 'bar':2}</code>.</p><p>…which would create a dictionary with two entries—one for <code class="literal">foo</code> and another for <code class="literal">bar</code>. Accessing those values looks a lot like indexing into a list, just with the name instead of a number, as in <code class="literal">print(myDict['foo'] # would print 1</code>.</p></div></div><p>Putting that all together gives us the following:</p><div class="informalexample"><pre class="programlisting">class EmbedUI():

    def __init__(self):
        self.win = cmds.window(title="Embed UI", widthHeight=(300,400))
        self.commandList = {}

        cmds.columnLayout()

        self.loadButton = cmds.button(label="Load Script", width=300, command=self.loadScript)
        self.makeNodeBtn = cmds.button(label="Tie Script to Current Object", width=300, command=self.makeNode)

        self.functionList = cmds.textScrollList(width=300, numberOfRows=10, selectCommand=self.showCommand)

        cmds.showWindow(self.win)</pre></div><p>Next up, we <a id="id388" class="indexterm"/>implement the <code class="literal">loadScript</code> function. We start by clearing out our <code class="literal">commandList</code> variable, in case the user is specifying a new file, then ask them to point us at a Python source file to load.</p><div class="informalexample"><pre class="programlisting">    def loadScript(self, args):
        self.commandList = {}
        filePath = cmds.fileDialog2(fileMode=1, fileFilter="Python files (*.py)")</pre></div><p>If we find a file, we open in in read mode.</p><div class="informalexample"><pre class="programlisting">    if (filePath == None):
        return

    f = open(filePath[0], "r")</pre></div><p>Now we're ready to actually read the file. We start by creating two variables—one to hold the human-friendly function name, which we'll display in the <code class="literal">textScrollList</code> command, and another to hold the actual source code.</p><div class="informalexample"><pre class="programlisting">functionName = ""
functionStr = ""</pre></div><p>Once we've done that, we start parsing the file. We loop through the file in the same way that we've done in previous examples, reading each line in turn—the only difference is how we parse the contents. Setting aside the handling of the file contents for a moment, the outer part of our parsing should look familiar:</p><div class="informalexample"><pre class="programlisting">    line = f.readline()
    while (line):
        # code to handle contents
        line = f.readline()</pre></div><p>Onto the parsing—what we want to do is to capture all of the text for each function. That means we want everything from the line that defines the function to the function's end. Finding the end of the function requires some thought, however. What we're looking for is not only a blank line but, more specifically, a blank line that does <span class="emphasis"><em>not</em></span> have a tab character.</p><p>We start by ignoring the import statement. We test to see if the current line starts with <code class="literal">import</code> and if so, we use the pass statement to skip doing anything.</p><div class="informalexample"><pre class="programlisting">        while (line):
            if (line.startswith("import")):
                pass</pre></div><p>Note that <a id="id389" class="indexterm"/>we could use the <code class="literal">continue</code> statement to skip the rest of the loop, but that would also skip the line responsible for reading in the next line of the file, leaving us with an infinite loop.</p><p>Next, we check to see if the line starts with <code class="literal">def</code>, indicating that it represents a new function definition.</p><div class="informalexample"><pre class="programlisting">elif (line.startswith("def")):</pre></div><p>If it does, we want to start collecting the code for the new function, but first we want to save the function that we were previously stepping through, if one exists. To do that, we check to see if our <code class="literal">functionName</code> and <code class="literal">functionStr</code> variables are blank. If they both have contents, it is because we were previously saving another function, which we insert into our function list as follows:</p><div class="informalexample"><pre class="programlisting">if (functionName != "" and functionStr != ""):
    self.commandList[functionName] = functionStr</pre></div><p>This would happen if the file that we're parsing had a new function definition on the line directly below a previous function, with no blank lines in between.</p><p>Now that we've dealt with the previous function (if there was one), we're ready to start storing our new function. We'll start by getting a more human-friendly form of the function name by discarding the <code class="literal">def</code> keyword, as well as the parentheses and colon.</p><p>To do that, we first use the split function to break the line up into an array by spaces, giving us <code class="literal">def</code> in the first index and something like <code class="literal">myFunction():</code> in the second. We then use replace to remove the <code class="literal">():</code>. That gives us:</p><div class="informalexample"><pre class="programlisting">parts = line.split()
functionName = parts[1].replace("():", "")</pre></div><p>Finally, we set our <code class="literal">functionStr</code> variable to the entire line. As we continue to parse the file, we'll add additional lines to this variable. When we encounter either a new <code class="literal">def</code> statement, or truly empty (no tab character) lines, we'll store the entire <code class="literal">functionStr</code> into our list of commands.</p><div class="informalexample"><pre class="programlisting">functionStr = line</pre></div><p>Speaking of blank lines, that's the next thing that we check for. If the line contains nothing but whitespace characters, running it through the <code class="literal">strip()</code> function will give us an empty string. If we do find an empty string, we might be at the end of the current function, but we'll want to make sure by testing to see if the current line starts with a tab.</p><div class="informalexample"><pre class="programlisting">elif (line.strip() == ""):
    # possibly blank line, check for tab
    if (line.startswith("\t") == False):</pre></div><p>If we do have <a id="id390" class="indexterm"/>a truly blank line (no tabs), and we've been building up a function, now's the time to store it to our list. Once again, we check to make sure that both our <code class="literal">functionName</code> and <code class="literal">functionStr</code> variables have contents, and if they do, we store the function code into our <code class="literal">commandList</code>.</p><div class="informalexample"><pre class="programlisting">    if (functionName != "" and functionStr != ""):
        self.commandList[functionName] = functionStr
        functionName = ""
        functionStr = ""</pre></div><p>In order to prevent the script from storing the same function more than once (in the event of multiple blank lines), we also reset both our <code class="literal">functionName</code> and <code class="literal">functionStr</code> variables to be blank.</p><p>If none of the above code has been triggered, we know that we have a non-blank line that starts with neither <code class="literal">import</code> or <code class="literal">def</code>. We'll assume that any such line is a valid line of code, and is part of the current function. As such, we simply add it on to our <code class="literal">functionStr</code> variable.</p><div class="informalexample"><pre class="programlisting">else:
    functionStr += line</pre></div><p>And with that, we're done parsing our file, and we close it. At this point, our <code class="literal">commandList</code> dictionary will have an entry for each function in the file. We'll want to show those functions to the user by adding them to our scroll list, which we do in our <code class="literal">updateList</code> function.</p><div class="informalexample"><pre class="programlisting">        f.close()
        self.updateList()</pre></div><p>In the <code class="literal">updateList</code> function, we want to first clear out the contents of <code class="literal">scrollList</code>, and then add an entry for each of the functions we found. Both are easily done by calling the <code class="literal">textScrollList</code> command in edit mode. First, we clear it out:</p><div class="informalexample"><pre class="programlisting">    def updateList(self):
        cmds.textScrollList(self.functionList, edit=True, removeAll=True)</pre></div><p>Then we run through our list of commands and add the name of each to the list with the <code class="literal">append</code> flag:</p><div class="informalexample"><pre class="programlisting">        for function in self.commandList:
            cmds.textScrollList(self.functionList, edit=True, append=function)</pre></div><p>Now all that's<a id="id391" class="indexterm"/> left is to implement the function that will actually create the script node. First, we want to make sure that the user has selected both a command from the scroll list and an object in the scene. To get the currently selected item in the scroll list, we use the <code class="literal">textScrollList</code> command once again, but this time in query mode.</p><div class="informalexample"><pre class="programlisting">command = cmds.textScrollList(self.functionList, query=True, selectItem=True)[0]</pre></div><p>Note that we have a <code class="literal">[0]</code> at the end of the <code class="literal">textScrollList</code> command. That's necessary, since <code class="literal">textScrollList</code> widgets can allow for multiple item selection. As a result, the output of querying <code class="literal">selectItem</code> may have multiple values, and is returned as an array. Adding the <code class="literal">[0]</code> gives us the first element (if there is one).</p><p>Our code for grabbing the selected object is simple, and should look very familiar indeed:</p><div class="informalexample"><pre class="programlisting">        objectName = ""
        objs = cmds.ls(selection=True)

        if (len(objs) &gt; 0):
            objectName = objs[0]</pre></div><p>If we have <span class="emphasis"><em>both</em></span> an object and a command, we're ready to dive into the script node creation. If we don't, we display an error message to the user.</p><p>For our script node, what we want is code that will perform the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Run on the start of the scene.</li><li class="listitem" style="list-style-type: disc">Include the definition of the selected function.</li><li class="listitem" style="list-style-type: disc">Include the definition of a function that can be run every time the selection changes. That function will need to compare the currently selected object to the target object and, if there's a match, invoke the trigger function</li><li class="listitem" style="list-style-type: disc">Create a script job tied to the <code class="literal">SelectionChanged</code> event.</li></ul></div><div class="mediaobject"><img src="graphics/4657_10_03.jpg" alt="How it works..."/><div class="caption"><p>Left: the UI displaying a list of functions in the input file. Right: the result- selecting the specified sphere triggers a custom UI.</p></div></div><p>That's a <a id="id392" class="indexterm"/>number of steps, but ultimately it all amounts to constructing a big string that has all of the features listed above. We start off by setting our string to the <code class="literal">import maya.cmds as cmds</code> line that we've been using in all of our scripts.</p><div class="informalexample"><pre class="programlisting">    if (command != "" and objectName != ""):
        print("Tying " + command + " to " + objectName)
        nodeStr = "import maya.cmds as cmds\n\n"</pre></div><p>Note that there are two newline characters at the end of the line. That will make things more readable, and make it easier to check the results in the expression editor in case there are problems.</p><p>Next, we add the code for the command we want to trigger. This is really easy, since we have all of the code stored in our <code class="literal">commandList</code> dictionary. All we need to do is to index into it using the command name that the user selected.</p><div class="informalexample"><pre class="programlisting">        nodeStr += self.commandList[command] + "\n\n"</pre></div><p>Now we need to create the code for the function responsible for checking the current selection against the target object and running the target script. To do that, we'll need to string together some boilerplate code and the specific names (of the object and function) that we happen to have.</p><p>In situations like this, it's generally helpful to write out what the result should look like given a specific input first. Let's say that we wanted to trigger a function named <code class="literal">myFunction</code> if an object named <code class="literal">triggerObject</code> was selected. To do that, we could use the following function:</p><div class="informalexample"><pre class="programlisting">def testSelection():
    objs = cmds.ls(selection=True)
    if (len(objs) &gt; 0):
        if (objs[0] == "triggerObject"):
            myFunction()</pre></div><p>Easy <a id="id393" class="indexterm"/>enough, right? All we need to do is to add the above text to our <code class="literal">nodeStr</code> variable, making sure that we replace the object and function name, and that we add proper tabs (<code class="literal">\t</code>) and newline characters (<code class="literal">\n</code>) so that we follow proper Python whitespace rules.</p><p>That ends up giving us the following:</p><div class="informalexample"><pre class="programlisting">    nodeStr += 'def testSelection():\n'
    nodeStr += '\tobjs = cmds.ls(selection=True)\n'
    nodeStr += '\tif (len(objs) &gt; 0):\n'
    nodeStr += '\t\tif (objs[0] == "' + objectName + '"):\n'
    nodeStr += '\t\t\t' + command + '()\n\n'</pre></div><p>All that's left is to add the code that will create a script job to properly tie our <code class="literal">testSelection</code> method to the <code class="literal">SelectionChanged</code> event. We add one final line to our <code class="literal">nodeStr</code> variable to do just that, as follows:</p><div class="informalexample"><pre class="programlisting">nodeStr += 'cmds.scriptJob(killWithScene=True, event=["SelectionChanged", testSelection])'</pre></div><p>We're very close to done, but what we have is still just a big chunk of text. To actually make it into a script node, we'll need to pass it into the <code class="literal">scriptNode</code> command as the <code class="literal">beforeScript</code> value, with <code class="literal">scriptType=2</code> in order to have it run at scene startup.</p><div class="informalexample"><pre class="programlisting">cmds.scriptNode(sourceType="python", scriptType=2, beforeScript=nodeStr)</pre></div><p>And that's it! We now have a way to embed arbitrary UI code into a scene and have it trigger when a given object is selected.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec219"/>There's more...</h2></div></div></div><p>As it stands, this example is more of a proof of concept than a proper tool. In the interest of brevity, I was forced to leave out several things that one would want, but the script could easily be extended to include all of them.</p><p>First off, the script only deals with single functions. For a proper character rig UI, it would be likely that we would want to include a collection of functions, possibly bundled together into one or more classes. In order to support that, the script would need to be changed to either copy the entire contents of a source file to the script node, or to have more sophisticated parsing of the file contents to include multiple functions.</p><p>Also, the script as written would not work as desired if it was used more than once in the same scene, since every pairing of function and object uses the same name (<code class="literal">testSelection</code>) for the function tied to the script job.</p><p>To fix that, we <a id="id394" class="indexterm"/>would want to ensure that each script job gets its own uniquely-named function to test the selection. One way to do that would be to append the name of the function that we ultimately want to trigger to the <code class="literal">testSelection</code> function name, as in:</p><div class="informalexample"><pre class="programlisting">selectionFunctionName = "testFor" + command

nodeStr += 'def ' + selectionFunctionName + '():\n'
nodeStr += '\tobjs = cmds.ls(selection=True)\n'
nodeStr += '\tif (len(objs) &gt; 0):\n'
nodeStr += '\t\tif (objs[0] == "' + objectName + '"):\n'
nodeStr += '\t\t\t' + command + '()\n\n'

nodeStr += 'cmds.scriptJob(killWithScene=True, event=["SelectionChanged", ' + selectionFunctionName + '])'</pre></div></div></div></body></html>