<html><head></head><body>
        

                            
                    <h1 class="header-title">Building Your Own Extension</h1>
                
            
            
                
<p>From the first chapter of this book, we have been adding Flask extensions to our app in order to add new features and to save us from spending lots of time reinventing the wheel. Up to this point, it has been unknown how these Flask extensions worked.</p>
<p class="mce-root"/>
<p>In this chapter, we'll learn about the following topics:</p>
<ul>
<li>How to create two simple Flask extensions in order to better understand Flask internals and allow you to extend Flask with your own functionality</li>
<li>How to extend Jinja</li>
<li>How to create a Python package, ready to be published to PyPI</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a YouTube Flask extension</h1>
                
            
            
                
<p>To begin, the first extension we are going to create is a simple extension that allows the embedding of YouTube videos in Jinja templates using the following tag:</p>
<pre>{{ youtube(video_id) }} </pre>
<p>The <kbd>video_id</kbd> object is the code after <kbd>v</kbd> in any YouTube URL. For example, in the URL <kbd>https://www.youtube.com/watch?v=_OBlgSz8sSM</kbd>, the <kbd>video_id</kbd> object is <kbd>_OBlgSz8sSM</kbd>.</p>
<p>For now, the code for this extension resides in <kbd>__init__.py</kbd>. However, this is only for development and debugging purposes. When the code is ready to be shared, it is moved into its own project directory.</p>
<p class="mce-root"/>
<p>The first thing that any Flask extension needs is the object that will be initialized on the app. This object will handle adding its <kbd>Blueprint</kbd> object to the app and registering the <kbd>youtube</kbd> function on Jinja:</p>
<pre>from flask import Blueprint<br/><br/>class Youtube(object):<br/>    def __init__(self, app=None, **kwargs):<br/>        if app:<br/>            self.init_app(app)<br/><br/>    def init_app(self, app):<br/>        self.register_blueprint(app)<br/>        <strong>app.add_template_global(youtube)</strong><br/><br/>    def register_blueprint(self, app):<br/>        module = Blueprint(<br/>            "youtube",<br/>            __name__,<br/>            url_prefix='youtube',<br/>            template_folder="templates"<br/>        )<br/>        app.register_blueprint(module)<br/>        return module</pre>
<p>So far, the only thing this code does is initialize an empty blueprint on the <kbd>app</kbd> object.</p>
<p>Notice the code marked with bold. In the <kbd>YouTube</kbd> class, we have to register the function to Jinja in the <kbd>init_app</kbd> method. We can now use the <kbd>youtube</kbd> Jinja function on our templates.</p>
<p>The next piece of code needed is a representation of a video. The following is a class that handles the parameters from the Jinja function and renders HTML to display in the template:</p>
<pre>from flask import render_template, Blueprint, Markup 

class Video(object): 
    def __init__(self, video_id, cls="youtube"): 
      self.video_id = video_id 
      self.cls = cls<br/><br/>    @property 
    def html(self): 
      return Markup(render_template('youtube/video.html', video=self)) </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>This object is created from the <kbd>youtube</kbd> function in the template, and any arguments passed in the template are given to this object to render the HTML. There is also a new object in this code, <kbd>Markup</kbd>, which was not used before. The <kbd>Markup</kbd> class is Flask's way of automatically escaping HTML, or marking it as safe to include in the template. If we just returned HTML, Jinja would auto escape it because it does not know whether it is safe or not. This is Flask's way of protecting your site from <strong>cross-site scripting attacks</strong>.</p>
<p>The next step is to create the function that will be registered in Jinja:</p>
<pre>def youtube(*args, **kwargs): 
  video = Video(*args, **kwargs) 
  return video.html </pre>
<p>Finally, we have to create the HTML that will add the video to the page. In a new folder named <kbd>youtube</kbd> in the <kbd>templates</kbd> directory, create a new HTML file named <kbd>video.html</kbd> and add the following code to it:</p>
<pre>&lt;iframe 
  class="{{ video.cls }}" 
  width="560" 
  height="315" 
  src="img/{{ video.video_id }}" 
  frameborder="0" 
  allowfullscreen&gt; 
&lt;/iframe&gt; </pre>
<p>This is all the code that's needed to embed YouTube videos in your templates. Let's test this out now. In <kbd>__init__.py</kbd>, initialize the <kbd>Youtube</kbd> class below the <kbd>Youtube</kbd> class definition:</p>
<pre>youtube = Youtube()</pre>
<p>In <kbd>__init__.py</kbd>, use the <kbd>youtube_ext</kbd> variable, which contains the initialized class, and use the <kbd>init_app</kbd> method we created to register it on the app:</p>
<pre>def create_app(object_name): 
    ... 
    youtube.init_app(app) </pre>
<p>Now, as a simple example, add the <kbd>youtube</kbd> function to the top of the blog home page on <kbd>templates/blog/home.html</kbd>:</p>
<pre>{% extends "base.html" %}<br/>{% import 'macros.html' as macros %}<br/>{% block title %}Home{% endblock %}<br/>{% block leftbody %}<br/><br/><strong>{{ youtube("_OBlgSz8sSM") }}</strong><br/><br/>{{ macros.render_posts(posts) }}<br/>{{ macros.render_pagination(posts, 'blog.home') }}<br/>{% endblock %}</pre>
<p>This will have the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-639 image-border" src="img/92fe397f-1ed7-4802-b4bd-300759ec0d67.png" style="width:162.50em;height:83.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Python package</h1>
                
            
            
                
<p>In order to make our new Flask extension available to others, we have to create an installable Python package from the code we have written so far. To begin, we need a new project directory outside of our current application directory. We will need two things: a <kbd>setup.py</kbd> file, which we will fill in later, and a folder named <kbd>flask_youtube</kbd>. In the <kbd>flask_youtube</kbd> directory, we will have an <kbd>__init__.py</kbd> file, which contains all the code that we wrote for our extension. This includes the <kbd>Youtube</kbd> and the <kbd>Video</kbd> Python classes.</p>
<p>Also, inside the <kbd>flask_youtube</kbd> directory, we will need a <kbd>templates</kbd> directory, which holds the <kbd>youtube</kbd> directory that we put in our app's <kbd>templates</kbd> directory.</p>
<p>In order to turn this code into a Python package, we use the library named <kbd>setuptools</kbd>. Now, <kbd>setuptools</kbd> is a Python package that allows developers to easily create installable packages for their code. <kbd>setuptools</kbd> bundles code so that <kbd>pip</kbd> and <kbd>easy_install</kbd> can automatically install them, and will even upload your package to the <strong>Python Package Index</strong> (<strong>PyPI</strong>).</p>
<p>All the packages that we have been installed from <kbd>pip</kbd> have come from PyPI. To see all the available packages, go to <a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>.</p>
<p>All you need to do to get this functionality is fill out the <kbd>setup.py</kbd> file:</p>
<pre>from setuptools import setup, find_packages<br/><br/>setup(<br/>    name='Flask-YouTube',<br/>    version='0.4',<br/>    license='MIT',<br/>    description='Flask extension to allow easy <br/>    embedding of YouTube videos',<br/>    author='Jack Stouffer',<br/>    author_email='example@gmail.com',<br/>    platforms='any',<br/>    install_requires=['Flask'],<br/>    packages=find_packages(),<br/>    include_package_data=True,<br/>    package_data = {<br/>        'templates': ['*']<br/>    },<br/>    zip_safe=False,<br/>    classifiers=[<br/>        'Development Status :: 5 - Production/Stable',<br/>        'Environment :: Web Environment',<br/>        'Intended Audience :: Developers',<br/>        'License :: OSI Approved :: BSD License',<br/>        'Operating System :: OS Independent',<br/>        'Programming Language :: Python',<br/>        'Topic :: Software Development :: Libraries :: Python Modules'<br/>    ]<br/>)</pre>
<p>This code uses the <kbd>setup</kbd> function from <kbd>setuptools</kbd> to find your source code and make sure that the machine that is installing your code has the required packages. Most of the attributes are rather self-explanatory, except the package attribute, which uses the <kbd>find_packages</kbd> function from <kbd>setuptools</kbd>.</p>
<p>The <kbd>package</kbd> attribute finds which parts of the source code are part of the package to be released. We use the <kbd>find_packages</kbd> method to automatically find which parts of the code to include. This is based on some sane defaults, such as looking for directories with <kbd>__init__.py</kbd> files and excluding common file extensions.</p>
<p>We must also declare a manifest file that the <kbd>setuptools</kbd> will use to know how to create our package. This includes rules for cleaning up files, and what folders that are not Python modules to include:</p>
<p><kbd>MANIFEST.in</kbd></p>
<pre>prune *.pyc<br/>recursive-include flask_youtube/templates *</pre>
<p>Although it is not mandatory, this setup also contains metadata about the author and the license, which would be included on the PyPI page if we were to upload this there. There is a lot more customization available in the <kbd>setup</kbd> function, so I encourage you to read the documentation at <a href="http://pythonhosted.org/setuptools/">http://pythonhosted.org/setuptools/</a>.</p>
<p>You can now install this package on your machine by running the following commands:</p>
<pre><strong>$ python setup.py build</strong>
<strong>$ python setup.py install</strong></pre>
<p>This installs your code into your Python <kbd>packages</kbd> directory, or if you're using <kbd>virtualenv</kbd>, it installs it to the local <kbd>packages</kbd> directory. Then, you can import your place on package via the following code:</p>
<pre>from flask_youtube import Youtube</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating blog posts with videos</h1>
                
            
            
                
<p>We are now going to extend our blog so that users can include videos on their posts. This is a nice feature and is useful for showing how to create a new feature that includes database schema change and migration, as well as giving a review on Jinja2 and WTForms.</p>
<p>First, we need to add a new column named <kbd>youtube_id</kbd> (on the following highlighted code) to our <kbd>Post</kbd> SQLAlchemy model on the <kbd>blog/models.py</kbd> file:</p>
<pre>...<br/><strong>class </strong><strong>Post(db.Model):</strong><br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    title = db.Column(db.String(255), nullable=False)<br/>    text = db.Column(db.Text(), nullable=False)<br/>    publish_date = db.Column(db.DateTime(),  <br/>    default=datetime.datetime.now)<br/>    user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))<br/>    <strong>youtube_id = db.Column(db.String(20))</strong><br/>    comments = db.relationship('Comment', backref='post', <br/>    lazy='dynamic')<br/>    tags = db.relationship('Tag', secondary=tags, <br/>    backref=db.backref('posts', lazy='dynamic'))<br/>...</pre>
<p>Now we are able to store our user's YouTube ID to go along with their posts. Next we need to include our new field on the <kbd>Post</kbd> form. So, in the <kbd>blog/forms.py</kbd> file, we add the following:</p>
<pre>class PostForm(Form):<br/>    title = StringField('Title', [DataRequired(),Length(max=255)])<br/>    <strong>youtube_id = StringField('Youtube video id', [Length(max=255)])</strong><br/>    text = TextAreaField('Content', [DataRequired()])</pre>
<p>Now we need to change the <kbd>edit</kbd> and <kbd>new_post</kbd> controllers:</p>
<p><kbd>blog/controllers.py</kbd>:</p>
<pre>...<br/>def new_post():<br/>    form = PostForm()<br/>    if form.validate_on_submit():<br/>        new_post = Post()<br/>        ...<br/>        <strong>new_post.youtube_id = form.youtube_id.data</strong><br/>        ...<br/>        db.session.add(new_post)<br/>...</pre>
<p>We are setting the <kbd>Post.youtube_id</kbd> SQLAlchemy model attribute to the form <kbd>youtube_id</kbd> field, and for the <kbd>edit</kbd> method, we have the same thing when the forms have been submitted (POST HTTP method), and it's the other way around when the form is shown:</p>
<p class="mce-root"><kbd>blog/controllers.py</kbd>:</p>
<pre>...<br/>def edit_post(id):<br/>    post = Post.query.get_or_404(id)<br/>    # We want admins to be able to edit any post<br/>    if current_user.id == post.user.id:<br/>        form = PostForm()<br/>        if form.validate_on_submit():<br/>            ...<br/>            <strong>post.youtube_id = form.youtube_id.data</strong><br/>            ...<br/>            db.session.add(post)<br/>            db.session.commit()<br/>            return redirect(url_for('.post', post_id=post.id))<br/>        form.title.data = post.title<br/>        <strong>form.youtube_id.data = post.youtube_id</strong><br/>        form.text.data = post.text<br/>        return render_template('edit.html', form=form, post=post)<br/>    abort(403)<br/>...</pre>
<p class="mce-root">Finally, we just have to include this new field on our Jinja2 templates. On our <kbd>templates/blog/post.html</kbd>, we render this field if it exists on the database:</p>
<pre>{% if post.youtube_id %}<br/>&lt;div class="row"&gt;<br/>    &lt;div class="col"&gt;<br/>        {{ youtube(post.youtube_id) | safe }}<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>{% endif %}</pre>
<p>To finish, we change our new post and edit the post templates. Just look for the change in the provided code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the response with Flask extensions</h1>
                
            
            
                
<p>So, we have created an extension that adds new functionality to our templates. But how would we create an extension that modifies the behavior of our app at the request level? To demonstrate this, let's create an extension that modifies all the responses from Flask by compressing the contents of the response. This is a common practice in web development in order to speed up page load times, as compressing objects with a method such as <kbd>gzip</kbd> is very fast and relatively cheap, CPU-wise. Normally, this would be handled at the server level. So, unless you wish to host your app with only Python code, which is possible and will be covered in <a href="380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml">Chapter 13</a>, <em>Deploying Flask Apps</em>, this extension really doesn't have much use in the real world.</p>
<p class="mce-root"/>
<p>To achieve this, we will use the <kbd>gzip</kbd> module in the Python standard library to compress the contents after each request is processed. We will also have to add special HTTP headers into the response in order for the browser to know that the content is compressed. We will also need to check in the HTTP request headers whether the browser can accept gzipped content.</p>
<p>Just as before, our content will initially reside in the <kbd>__init__.py</kbd> file:</p>
<pre>from flask import request 
from gzip import GzipFile 
from io import BytesIO 
... 
class GZip(object): 
  def __init__(self, app=None): 
    self.app = app 
    if app is not None: 
      self.init_app(app) 
  def init_app(self, app): 
    app.after_request(self.after_request) 
  def after_request(self, response): 
    encoding = request.headers.get('Accept-Encoding', '') 
    if 'gzip' not in encoding or  
      not response.status_code in (200, 201): 
      return response 
    response.direct_passthrough = False 
    contents = BytesIO() 
    with GzipFile( 
      mode='wb', 
      compresslevel=5, 
      fileobj=contents) as gzip_file: 
      gzip_file.write(response.get_data()) 
    response.set_data(bytes(contents.getvalue())) 
    response.headers['Content-Encoding'] = 'gzip' 
    response.headers['Content-Length'] = response.content_length 
    return response 
flask_gzip = GZip() </pre>
<p>Just as with the previous extension, our initializer for the compressed object accommodates both the normal Flask setup and the application factory setup. In the <kbd>after_request</kbd> method, instead of registering a blueprint, we register a new function on the <kbd>after-request</kbd> event so that our extension can compress the results.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>after_request</kbd> method is where the real logic of the extension comes into play. First, it checks whether the browser accepts gzip encoding by looking at the <kbd>Accept-Encoding</kbd> value in the request header. If the browser does not accept gzip, or the browser did not return a successful response, the function just returns the content and makes no modifications to the content. However, if the browser does except our content and the response was successful, then the content will be compressed. We use another standard library class named <kbd>BytesIO</kbd>, which allows file streams to be written and stored in memory, rather than being stored in an intermediate file. This is necessary because the <kbd>GzipFile</kbd> object expects to write to a file object.</p>
<p>After the data is compressed, we set the response object data to the results of the compression and set the necessary HTTP header values in the response as well. Finally, the gzip content is returned to the browser, and the browser then decompresses the content, significantly speeding up the page load times.</p>
<p>In order to test the functionality in your browser, you have to disable Flask Debug Toolbar because, at the time of writing, there is a bug in its code where it expects all responses to be encoded in UTF-8.</p>
<p>If you reload the page, nothing should look different. However, if you use the developer tools in the browser of your choice and inspect the responses, you will see that they are compressed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Now that we have looked at two different examples of different types of Flask extensions, you should have a very clear understanding of how most of the Flask extensions that we used work. Using the knowledge that you have now, you should be able to add any extra functionality to Flask that you need for your specific application.</p>
<p>In the next chapter, we are going to look at how to add testing to our application to take out the guesswork of whether the changes we made to the code have broken any of the functionality of our application.</p>


            

            
        
    </body></html>