- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Dockerizing the Django Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Django 项目 Docker 化
- en: In the previous chapter, we learned more about software deployment, and we deployed
    the Django application on an AWS server. However, we came across issues such as
    poor preparation of the project for deployment, violation of some security issues,
    and deployment and development configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了更多关于软件部署的知识，并在 AWS 服务器上部署了 Django 应用程序。然而，我们遇到了一些问题，比如项目部署准备不足、违反了一些安全问题和部署及开发配置。
- en: 'In this chapter, we will learn how to use Docker on the Django backend and
    configure environment variables. We will also configure the database on a web
    server called **NGINX** using **Docker**. Here are the big sections of the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在 Django 后端使用 Docker 并配置环境变量。我们还将使用 **Docker** 在名为 **NGINX** 的 Web
    服务器上配置数据库。以下是本章的主要部分：
- en: What is Docker?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: Dockerizing the Django application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Django 应用程序 Docker 化
- en: Using Docker Compose for multiple containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 对多个容器进行操作
- en: Configuring environment variables in Django
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Django 中配置环境变量
- en: Writing NGINX configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 NGINX 配置
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have Docker and Docker Compose installed
    on your machine. The Docker official documentation has a well-documented process
    for the installation on any OS platform. You can check it out at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要在您的机器上安装 Docker 和 Docker Compose。Docker 官方文档对任何操作系统平台的安装过程都有详细的说明。您可以在[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)查看。
- en: The code written in this chapter can also be found at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中编写的代码也可以在[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13)找到。
- en: What is Docker?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: Before defining what **Docker** is, we must understand what a container is and
    its importance in today’s tech ecosystem. To make it simple, a container is a
    standard unit of software that packages up the software and all of its required
    dependencies so that the software or the application can run quickly and reliably
    from one machine to another, whether the environment or the OS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 **Docker** 之前，我们必须了解容器是什么以及它在当今技术生态系统中的重要性。为了简单起见，容器是一个标准的软件单元，它将软件及其所有必需的依赖项打包起来，以便软件或应用程序可以从一台机器快速且可靠地运行到另一台机器，无论环境或操作系统如何。
- en: 'An interesting definition from Solomon Hykes at the 2013 *PyCon* talk is: containers
    are “*self-contained units of software you can deliver from a server over there
    to a server over there, from your laptop to EC2 to a bare-metal giant server,
    and it will run in the same way because it is isolated at the process level and
    has its own* *file system*.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 2013 年 *PyCon* 谈话的所罗门·海克斯的一个有趣的定义是：容器是“*你可以从服务器那里发送到服务器那里的自包含的软件单元，从你的笔记本电脑到
    EC2 到裸机巨型服务器，它将以相同的方式运行，因为它在进程级别上是隔离的，并且拥有自己的* *文件系统*。”
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Containerization is different from virtualization. Virtualization enables teams
    to run multiple operating systems on the same hardware, while containerization
    allows teams to deploy multiple applications using the same operating system on
    single hardware with their own images and dependencies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化与虚拟化不同。虚拟化使团队能够在同一硬件上运行多个操作系统，而容器化允许团队在单个硬件上使用自己的镜像和依赖项，在相同的操作系统上部署多个应用程序。
- en: 'Great, right? Remember at the beginning of this book when we had to make configurations
    and installations depending on the OS mostly for the Python executable, the Postgres
    server, and different commands to create and activate a virtual environment? Using
    Docker, we can have a single configuration for a container, and this configuration
    can run the same on any machine. Docker ensures that your application can be executed
    in any environment. Then, we can say that Docker is a software platform for building,
    developing, and developing applications inside containers. It has the following
    advantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，对吧？记得这本书的开头，我们不得不根据操作系统进行配置和安装，主要是针对 Python 可执行文件、Postgres 服务器以及创建和激活虚拟环境的各种命令吗？使用
    Docker，我们可以为容器设置一个单一的配置，并且这个配置可以在任何机器上运行。Docker 确保您的应用程序可以在任何环境中执行。然后，我们可以说 Docker
    是一个用于在容器内构建、开发和部署应用程序的软件平台。它有以下优点：
- en: '**Minimalistic and portable**: Compared to **virtual machines** (**VMs**) that
    require complete copies of an OS, the application, and the dependencies, which
    can take a lot of space, a Docker container requires less storage because the
    image used comes with **megabytes** (**MB**) in size. This makes them fast to
    boot and easily portable even on small devices such as Raspberry Pi-embedded computers.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简约且便携**：与需要完整操作系统、应用程序和依赖项副本的虚拟机（VMs）相比，这些可以占用大量空间，而 Docker 容器由于使用的镜像大小仅为
    **兆字节（MB**），因此所需的存储空间更少。这使得它们启动速度快，易于在小型设备（如树莓派嵌入式计算机）上便携。'
- en: '**Docker containers are scalable**: Because they are lightweight, developers
    or DevOps can launch a lot of services based on containers and easily control
    the scaling using tools such as Kubernetes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 容器可扩展**：因为它们轻量级，开发人员或 DevOps 可以基于容器启动大量服务，并使用 Kubernetes 等工具轻松控制扩展。'
- en: '**Docker containers are secure**: Applications inside Docker containers are
    running isolated from each other. Thus, a container can’t check the processes
    running in another container.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 容器安全**：Docker 容器中的应用程序是相互隔离运行的。因此，一个容器无法检查另一个容器中正在运行的过程。'
- en: With a better understanding of what Docker is, we can now move on to integrate
    Docker into the Django application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在更好地理解了 Docker 是什么之后，我们现在可以继续将 Docker 集成到 Django 应用程序中。
- en: Dockerizing the Django application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Django 应用程序 Docker 化
- en: In the precedent section, we defined Docker and its advantages. In this section,
    we will configure Docker with the Django application. This will help you understand
    better how Docker works under the hood.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们定义了 Docker 及其优势。在本节中，我们将配置 Docker 以与 Django 应用程序一起使用。这将帮助你更好地理解 Docker
    在底层是如何工作的。
- en: Adding a Docker image
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Docker 镜像
- en: A characteristic of projects that use Docker is the presence of files called
    **Dockerfiles** in the project. A Dockerfile is a text document that contains
    all the commands necessary to assemble a Docker image. A Docker image is a read-only
    template with instructions to create a Docker container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 的项目的一个特点是项目中存在名为 **Dockerfile** 的文件。Dockerfile 是一个包含构建 Docker 镜像所需所有命令的文本文件。Docker
    镜像是一个只读模板，包含创建 Docker 容器的指令。
- en: 'Creating an image with a Dockerfile is the most popular way to go as you only
    need to enter the instructions you will require to set up an environment, install
    the package, make migrations, and a lot more. This is what makes Docker very portable.
    For example, in the case of our Django application, we will write the Dockerfile
    based on an existing image for Python `3.10` based on the popular Alpine Linux
    project ([https://alpinelinux.org/](https://alpinelinux.org/)). This image has
    been chosen because of its small size, equal to 5 MB. Inside the Dockerfile, we
    will also add commands to install Python and Postgres dependencies, and we will
    further add commands to install packages. Let’s get started with the steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 创建镜像是最流行的方法，因为你只需输入设置环境、安装包、执行迁移等所需的指令。这就是 Docker 非常便携的原因。例如，在我们的
    Django 应用程序的情况下，我们将基于基于 Python `3.10` 的现有镜像编写 Dockerfile，该镜像基于流行的 Alpine Linux
    项目 ([https://alpinelinux.org/](https://alpinelinux.org/))。选择这个镜像是因为它的大小很小，仅等于
    5 MB。在 Dockerfile 中，我们还将添加安装 Python 和 Postgres 依赖项的命令，并进一步添加安装包的命令。让我们从以下步骤开始：
- en: 'Start by creating a new file at the root of the Django project called `Dockerfile`
    and adding the first line:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Django 项目的根目录下创建一个名为 `Dockerfile` 的新文件，并添加第一行：
- en: Dockerfile
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of your `Dockerfile` will start with this line. Here, we are telling Docker
    which image to use to build our image. The `python:3.10-alpine` image is stored
    in what is called a Docker registry. This is a storage and distribution system
    for Docker images, and you can find the most popular one online, called Docker
    Hub, at [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `Dockerfile` 都以这一行开始。在这里，我们告诉 Docker 使用哪个镜像来构建我们的镜像。`python:3.10-alpine`
    镜像存储在称为 Docker 仓库的地方。这是一个 Docker 镜像的存储和分发系统，你可以在网上找到最受欢迎的一个，称为 Docker Hub，网址为
    [https://hub.docker.com/](https://hub.docker.com/)。
- en: 'Next, let’s set the working directory. This directory will contain the code
    of the running Django project:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置工作目录。这个目录将包含运行中的 Django 项目的代码：
- en: Dockerfile
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As the Django application uses Postgres as a database, add the required dependencies
    for Postgres and Pillow to our Docker image:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Django 应用程序使用 Postgres 作为数据库，我们将 Postgres 和 Pillow 的所需依赖项添加到我们的 Docker 镜像中：
- en: Dockerfile
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, install the Python dependencies after making a copy of the `requirements.txt`
    file in the `/app` working directory:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `/app` 工作目录中复制 `requirements.txt` 文件后，安装 Python 依赖项：
- en: Dockerfile
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, copy over the whole project itself:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，复制整个项目：
- en: Dockerfile
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, expose port `8000` of the container for access to the other applications
    or the machine, run the migrations, and start the Django server:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将容器的 `8000` 端口暴露出来，以便其他应用程序或机器可以访问，运行迁移，并启动 Django 服务器：
- en: Dockerfile
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Dockerfile` file will have the following final code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 文件将包含以下最终代码：'
- en: Dockerfile
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have just written the steps to build an image for the Django application.
    Let’s build the image with the following command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写下了构建 Django 应用程序镜像的步骤。让我们使用以下命令构建镜像。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command uses the `Dockerfile` to build a new container image—that’s
    why we have a dot (`.`) at the end of the command. It tells Docker to look for
    the `Dockerfile` in the current directory. The `-t` flag is used to tag the container
    image. Then, we are building an image with the `django-backend` tag using the
    `Dockerfile` we have written. Once the image is built, we can now run the application
    in the container by running the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用 `Dockerfile` 构建一个新的容器镜像——这就是为什么命令末尾有一个点（`.`）的原因。它告诉 Docker 在当前目录中查找
    `Dockerfile`。`-t` 标志用于标记容器镜像。然后，我们使用我们编写的 `Dockerfile` 构建了一个带有 `django-backend`
    标签的镜像。一旦镜像构建完成，我们现在可以通过运行以下命令在容器中运行应用程序：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s describe the preceding command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下前面的命令：
- en: '`--name` will set the name of the Docker container'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 将设置 Docker 容器的名称'
- en: '`-d` makes the image run in detached mode, meaning that it can run in the background'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 使镜像以分离模式运行，这意味着它可以在后台运行'
- en: '`django-postagram` specifies the name of the image to use'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-postagram` 指定了要使用的镜像名称'
- en: 'After typing the preceding command, you can check the running container with
    the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入前面的命令后，你可以使用以下命令检查正在运行的容器：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will have a similar output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到类似的输出：
- en: '![Figure 13.1 – Listing Docker containers on the machine](img/Figure_13.1_B18821.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 列出机器上的 Docker 容器](img/Figure_13.1_B18821.jpg)'
- en: Figure 13.1 – Listing Docker containers on the machine
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 列出机器上的 Docker 容器
- en: 'The container is created, but it looks like it’s not working well. In your
    browser, go to `http://localhost:8000`, and you will notice that the browser returns
    a page with an error. Let’s check the logs for the `django-postagram` container:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已创建，但看起来它运行得不太好。在你的浏览器中，访问 `http://localhost:8000`，你会注意到浏览器返回了一个错误页面。让我们检查
    `django-postagram` 容器的日志：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The command will output in the terminal what is happening inside the container.
    You will have a similar output to this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将在终端中输出容器内部正在发生的事情。你将得到类似的输出：
- en: '![Figure 13.2 – Logs for django-postagram container](img/Figure_13.2_B18821.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – django-postagram 容器的日志](img/Figure_13.2_B18821.jpg)'
- en: Figure 13.2 – Logs for the django-postagram container
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – django-postagram 容器的日志
- en: Well, that’s quite normal. The container is running on its own network and doesn’t
    have direct access to the host machine network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是很正常的。容器正在自己的网络上运行，并且无法直接访问主机机器的网络。
- en: 'In the previous chapter, we added services for NGINX and Postgres and made
    the configurations. We need to also do the same with `Dockerfiles` for NGINX and
    Postgres. And let’s be honest: it starts to become a little bit much. Imagine
    adding a Flask service, a Celery service, or even another database. Depending
    on the *number n* of components of your system, you will need `n Dockerfiles`.
    This is not interesting, but thankfully, Docker provides a simple solution for
    that called Docker Compose. Let’s explore it more.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为 NGINX 和 Postgres 添加了服务并进行了配置。我们还需要为 NGINX 和 Postgres 的 `Dockerfile`
    做同样的事情。坦白说：这开始变得有点多了。想象一下添加一个 Flask 服务、一个 Celery 服务，甚至是另一个数据库。根据你系统组件的**数量 n**，你需要
    `n` 个 Dockerfile。这并不有趣，但幸运的是，Docker 提供了一个简单的解决方案，称为 Docker Compose。让我们更深入地了解一下。
- en: Using Docker Compose for multiple containers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行多个容器
- en: Docker Compose is a tool developed and created by the Docker team to help define
    configurations for multi-container applications. Using Docker Compose, we just
    need to create a YAML file to define the services and the command to start each
    service. It also supports configurations such as container name, environment setting,
    volume, and a lot more, and once the YAML file is written, you just need a command
    to build the images and spin all the services.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 是 Docker 团队开发和创建的工具，用于帮助定义多容器应用程序的配置。使用 Docker Compose，我们只需创建一个
    YAML 文件来定义服务和启动每个服务的命令。它还支持容器名称、环境设置、卷等配置，一旦编写了 YAML 文件，您只需一个命令来构建镜像并启动所有服务。
- en: 'Let’s understand the key difference between a Dockerfile and Docker Compose:
    a Dockerfile describes how to build the image and run the container, while Docker
    Compose is used to run Docker containers. At the end of the day, Docker Compose
    still uses Docker under the hood, and you will—most of the time—need at least
    a Dockerfile. Let’s integrate Docker Compose into our workflow.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 Dockerfile 和 Docker Compose 之间的关键区别：Dockerfile 描述了如何构建镜像和运行容器，而 Docker
    Compose 用于运行 Docker 容器。最终，Docker Compose 仍然在底层使用 Docker，您通常至少需要一个 Dockerfile。让我们将
    Docker Compose 集成到我们的工作流程中。
- en: Writing the docker-compose.yaml file
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 docker-compose.yaml 文件
- en: 'Before writing the YAML file, we will have to make some changes to the `Dockerfile`.
    As we will be launching the Django server from the `docker-compose` file, we can
    remove the lines where we expose the port, run the migrations, and start the server.
    Inside the `Dockerfile`, remove the following lines of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 YAML 文件之前，我们不得不对 `Dockerfile` 进行一些修改。由于我们将从 `docker-compose` 文件中启动 Django
    服务器，我们可以删除暴露端口、运行迁移和启动服务的那几行代码。在 `Dockerfile` 中删除以下代码行：
- en: Dockerfile
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once it’s done, create a new file called `docker-compose.yaml` at the root
    of the project. Make sure that the `docker-compose.yaml` file and the `Dockerfile`
    are in the same directory. The `docker-compose.yaml` file will describe the services
    of the backend application. We will need to write three services:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，请在项目的根目录下创建一个名为 `docker-compose.yaml` 的新文件。确保 `docker-compose.yaml` 文件和
    `Dockerfile` 在同一目录下。`docker-compose.yaml` 文件将描述后端应用程序的服务。我们需要编写三个服务：
- en: '**NGINX**: We are using NGINX as the web server. Thankfully, there is an official
    image available we can use to write quick configurations.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NGINX**: 我们正在使用 NGINX 作为 Web 服务器。幸运的是，有一个官方镜像可供我们使用，以便快速编写配置。'
- en: '**Postgres**: There is also an official image available for Postgres. We will
    just need to add environment variables for the database user.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postgres**: 对于 Postgres，也有一个官方镜像可用。我们只需添加数据库用户的环境变量即可。'
- en: '`django-backend`: This is the backend application we have created. We will
    use the `Dockerfile` so that Docker Compose will build the image for this service.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-backend`: 这是我们所创建的后端应用程序。我们将使用 `Dockerfile`，这样 Docker Compose 就会为这个服务构建镜像。'
- en: 'Let’s start writing the `docker-compose.yaml` file by adding the NGINX service
    first:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加 NGINX 服务开始编写 `docker-compose.yaml` 文件：
- en: docker-compose.yaml
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yaml
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s see what is going on in the preceding code because the other services
    will follow a similar configuration. The first line sets the file format we are
    using, so it is not related to Docker Compose, just to YAML.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的代码中发生了什么，因为其他服务将遵循类似的配置。第一行设置了我们使用的文件格式，因此它与 Docker Compose 无关，只是与 YAML
    相关。
- en: 'After that, we are adding a service called `nginx`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加一个名为 `nginx` 的服务：
- en: '`container_name` represents, well, the name of the container.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container_name` 表示，嗯，容器的名称。'
- en: '`restart` defines the container restart policy. In this case, the container
    is always restarted if it fails.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart` 定义了容器重启策略。在这种情况下，如果容器失败，则始终重启。'
- en: 'Concerning the restart policies for a container, you can also have:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于容器的重启策略，您还可以有：
- en: '`no`: Containers will not restart automatically'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no`: 容器不会自动重启'
- en: '`on-failure[:max-retries]`: Restart the container if it exits with a nonzero
    exit code and provides a maximum number of attempts for the Docker daemon to restart
    the container'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on-failure[:max-retries]`: 如果容器以非零退出代码退出，则重启容器，并为 Docker 守护进程重启容器提供最大尝试次数'
- en: '`unless-stopped`: Always restart the container unless it was stopped arbitrarily
    or by the Docker daemon'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless-stopped`: 如果容器不是被任意停止或由 Docker 守护进程停止，则始终重启容器'
- en: '`image`: This tells Docker Compose to use the latest NGINX image available
    on Docker Hub.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`: 这告诉 Docker Compose 使用 Docker Hub 上可用的最新 NGINX 镜像。'
- en: '`volumes` are a way of persisting data generated and used by Docker containers.
    If a Docker container is deleted or removed, all its content will vanish forever.
    This is not ideal if you have files such as logs, images, video, or anything you
    want to persist somewhere because every time you remove a container, this data
    will vanish. Here is the syntax: `/host/path:/container/path`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes` 是一种持久化 Docker 容器生成和使用的数据的手段。如果删除或移除 Docker 容器，其所有内容将永远消失。如果你有日志、图像、视频或任何希望持久化到某处的文件，这并不是一个好的选择，因为每次你移除一个容器，这些数据都会消失。以下是语法：`/host/path:/container/path`。'
- en: '`ports`: Connection requests coming from the host port `80` are redirected
    to the container port `80`. Here is the syntax: `host_port:container_port`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 来自主机端口 `80` 的连接请求被重定向到容器端口 `80`。以下是语法：`host_port:container_port`。'
- en: '`depends_on`: This tells Docker Compose to wait for some services to start
    before starting the service. In our case, we are waiting for the Django API to
    start before starting the NGINX server.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`: 这告诉 Docker Compose 在启动服务之前等待某些服务启动。在我们的例子中，我们正在等待 Django API
    启动后再启动 NGINX 服务器。'
- en: 'Great! Next, let’s add the service configuration for the Postgres service:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！接下来，让我们添加 Postgres 服务的服务配置：
- en: docker-compose.yaml
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yaml
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have new parameters here called `env_file` which specifies the path to the
    environment file that will be used to create the database and the user, and set
    the password. Let’s finally add the Django API service:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一些新的参数，称为 `env_file`，它指定了用于创建数据库和用户以及设置密码的环境文件的路径。让我们最后添加 Django API 服务：
- en: docker-compose.yaml
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yaml
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The build parameter in the Docker Compose file tells Docker Compose where to
    look for the `Dockerfile`. In our case, the `Dockerfile` is in the current directory.
    Docker Compose allows you to have a `command` parameter. Here, we are running
    migrations and starting the Django server using Gunicorn, which is new. `gunicorn`
    is a Python `gunicorn`? Most web applications run with an Apache server, so `gunicorn`
    is basically designed to run web applications built with Python.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 文件中的构建参数告诉 Docker Compose 在哪里查找 `Dockerfile`。在我们的例子中，`Dockerfile`
    在当前目录中。Docker Compose 允许你有一个 `command` 参数。在这里，我们正在运行迁移并使用 Gunicorn 启动 Django 服务器，这是新的。`gunicorn`
    是一个 Python `gunicorn`？大多数网络应用程序都使用 Apache 服务器，所以 `gunicorn` 主要是为了运行用 Python 构建的
    Web 应用程序。
- en: 'You can install the package in your current Python environment by running the
    following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令在你的当前 Python 环境中安装包：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But you will need to put the dependency in the `requirements.txt` file so that
    it can be preset in the Docker image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你需要将依赖项放入 `requirements.txt` 文件中，以便在 Docker 镜像中预先设置：
- en: requirements.txt
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: requirements.txt
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to declare at the end of the file the volumes used:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在文件末尾声明使用的卷：
- en: docker-compose.yaml
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yaml
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And we have just written a `docker-compose.yaml` file. As we are going to use
    environment variables in the project, let’s update some variables in the `settings.py`
    file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了一个 `docker-compose.yaml` 文件。由于我们将在项目中使用环境变量，让我们在 `settings.py` 文件中更新一些变量。
- en: Configuring environment variables in Django
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Django 中配置环境变量
- en: It is a bad habit to have sensitive information about your application available
    in the code. This is the case for the `SECRET_KEY` setting and the database settings
    in the `settings.py` file of the project. It is quite bad because we have pushed
    the code to GitHub. Let’s correct this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中保留关于你的应用程序的敏感信息是一个坏习惯。对于项目中的 `settings.py` 文件中的 `SECRET_KEY` 设置和数据库设置来说，情况就是这样。这相当糟糕，因为我们已经把代码推送到
    GitHub 上了。让我们纠正这个错误。
- en: 'An environment variable is a variable whose value is set outside the running
    code of the program. With Python, you can read files from a `.env` file. We will
    use the `os` library to write the configurations. So, first, create a `.env` file
    at the root of the Django project and add the following content:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是一个其值在程序运行代码之外设置的变量。使用 Python，你可以从 `.env` 文件中读取文件。我们将使用 `os` 库来编写配置。所以，首先，在
    Django 项目的根目录下创建一个 `.env` 文件，并添加以下内容：
- en: .env
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: .env
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`SECRET_KEY` is an important variable for your Django project, so you need
    to ensure that you have a long and complicated chain of characters as the value.
    You can visit [https://djecrety.ir/](https://djecrety.ir/) to generate a new chain
    of characters.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`SECRET_KEY` 是你的 Django 项目中的一个重要变量，所以你需要确保你有一个长且复杂的字符链作为其值。你可以访问 [https://djecrety.ir/](https://djecrety.ir/)
    生成一个新的字符链。'
- en: 'The next step is to install a package to help you manage environment variables.
    The package is called `python-dotenv`, and it helps Python developers read environment
    variables from `.env` files and set them as environment variables. If you are
    going to run the project again on your machine, then add the package to your actual
    Python environment with the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装一个用于帮助您管理环境变量的包。这个包叫做 `python-dotenv`，它可以帮助 Python 开发者从 `.env` 文件中读取环境变量并将它们设置为环境变量。如果您打算在您的机器上再次运行项目，那么请使用以下命令将该包添加到您的实际
    Python 环境中：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And finally, add the package to the `requirements.txt` file so that it can
    be installed in the Docker image. Here’s a look at the `requirements.txt` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将包添加到 `requirements.txt` 文件中，以便它可以在 Docker 镜像中安装。下面是 `requirements.txt` 文件的内容：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the installation of the `python-dotenv` package is done, we need to write
    some code in the `CoreRoot/settings.py` file. In this file, we will import the
    `python-dotenv` package and modify the syntax of some settings so that it can
    support environment variables’ reading:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `python-dotenv` 包，我们就需要在 `CoreRoot/settings.py` 文件中编写一些代码。在这个文件中，我们将导入
    `python-dotenv` 包并修改一些设置的语法，以便它能够支持读取环境变量：
- en: CoreRoot/settings.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s rewrite the values of variables such as `SECRET_KEY`, `DEBUG`, `ALLOWED_HOSTS`,
    and `ENV`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写 `SECRET_KEY`、`DEBUG`、`ALLOWED_HOSTS` 和 `ENV` 等变量的值：
- en: CoreRoot/settings.py
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `os` package provides an object to retrieve environment variables from
    the user machine. After `python-dotenv` has forced the loading of the environment
    variables, we use `os.environ` to read the values from the `.env` file. Let’s
    finally add the configuration for the `DATABASES` setting:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 包提供了一个对象来从用户机器检索环境变量。在 `python-dotenv` 强制加载环境变量之后，我们使用 `os.environ` 从
    `.env` 文件中读取值。最后，让我们添加 `DATABASES` 设置的配置：'
- en: CoreRoot/settings.py
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Great! We are done configuring the environment variables in the `settings.py`
    file. We can now move on to write the configurations for NGINX.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们在 `settings.py` 文件中配置环境变量已经完成。现在我们可以继续编写 NGINX 的配置。
- en: Writing NGINX configuration
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 NGINX 配置
- en: NGINX requires some configuration from our side. If there is a request on the
    HTTP port of the machine (by default `80`), it should redirect the requests to
    port `8000` of the running Django application. Put simply, we will write a reverse
    proxy. A proxy is an intermediary process that takes an HTTP request from a client,
    passes the request to one or many other servers, waits for a response from those
    servers, and sends back a response to the client.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 需要我们从侧面提供一些配置。如果机器的 HTTP 端口（默认为 `80`）上有请求，它应该将请求重定向到正在运行的 Django 应用的端口
    `8000`。简单来说，我们将编写一个反向代理。代理是一个中介过程，它从客户端接收 HTTP 请求，将请求传递给一个或多个其他服务器，等待这些服务器的响应，然后将响应发送回客户端。
- en: By using this process, we can forward a request on the HTTP port `80` to port
    `8000` of the Django server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此过程，我们可以将 HTTP 端口 `80` 上的请求转发到 Django 服务器的端口 `8000`。
- en: 'At the root of the project, create a new file called `nginx.conf`. Then, let’s
    define the upstream server where HTTP requests will be redirected to:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为 `nginx.conf` 的新文件。然后，让我们定义 HTTP 请求将被重定向到的上游服务器：
- en: nginx.conf
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: nginx.conf
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code follows the simple syntax shown next:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遵循以下简单语法：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Docker allows you to refer to the container’s host with the `defined` container
    name. In the NGINX file, we are using `postagram_api` instead of the IP address
    of the container, which can change, and for the database, we are using `postagram_db`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 允许您使用 `defined` 的容器名称来引用容器的宿主机。在 NGINX 文件中，我们使用 `postagram_api` 而不是容器的
    IP 地址（它可能会变化），对于数据库，我们使用 `postagram_db`。
- en: 'The next step is to declare the configuration for the HTTP server:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是声明 HTTP 服务器的配置：
- en: nginx.conf
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: nginx.conf
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the server configuration, we first set the port of the server. In the preceding
    code, we are using port `80`. Next, we are defining locations. A location in NGINX
    is a block that tells NGINX how to process the request from a certain URL:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器配置中，我们首先设置服务器的端口。在前面的代码中，我们使用端口 `80`。接下来，我们定义位置。在 NGINX 中，位置是一个块，它告诉 NGINX
    如何处理来自特定 URL 的请求：
- en: A request on the `/` URL is redirected to the web app upstream
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` URL 上的请求被重定向到 web 应用上游'
- en: A request on the `/media/` URL is redirected to the `uploads` folder to serve
    files
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media/` URL 上的请求被重定向到 `uploads` 文件夹以提供文件'
- en: With the NGINX configuration ready, we can now launch the containers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NGINX 配置就绪后，我们现在可以启动容器了。
- en: Launching the Docker containers
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Docker 容器
- en: 'Let’s launch the Docker containers. As we are now using Docker Compose to orchestrate
    containers, let’s use the following command to build and start the containers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 Docker 容器。由于我们现在使用 Docker Compose 来编排容器，所以让我们使用以下命令来构建和启动容器：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command will spin up all the containers defined in the `docker-compose.yaml`
    file. Let’s describe the command options:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将启动 `docker-compose.yaml` 文件中定义的所有容器。让我们描述一下命令选项：
- en: '`up`: This builds, recreates, and starts containers'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`：此选项构建、重新创建并启动容器'
- en: '`-d`: This is used to detach, meaning that we are running the containers in
    the background'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：此选项用于分离，意味着我们在后台运行容器'
- en: '`—build`: This flag tells Docker Compose to build the images before starting
    the containers'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`—build`：此标志告诉 Docker Compose 在启动容器之前构建镜像'
- en: 'After the build is done, open your browser at `http://localhost`, and you should
    see the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，打开您的浏览器到 `http://localhost`，您应该看到以下内容：
- en: '![Figure 13.3 – Dockerized Django application](img/Figure_13.3_B18821.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – Docker 化的 Django 应用程序](img/Figure_13.3_B18821.jpg)'
- en: Figure 13.3 – Dockerized Django application
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Docker 化的 Django 应用程序
- en: 'We have successfully containerized the Django application using Docker. It
    is also possible to execute commands inside containers, and right now, we can
    start by running a test suite inside the `postagram_api` container:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功使用 Docker 容器化了 Django 应用程序。在容器内执行命令也是可能的，目前我们可以从在 `postagram_api` 容器中运行测试套件开始：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The syntax to execute a command in a Docker container is to first call the `exec`
    command followed by the `–T` parameter to disable `pseudo-tty` allocation. This
    means that the command being run inside the container will not be attached to
    a terminal. Finally, you can add the container service name, followed by the command
    you want to execute in the container.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 容器中执行命令的语法是首先调用 `exec` 命令，然后跟 `–T` 参数以禁用 `pseudo-tty` 分配。这意味着在容器内运行的命令将不会连接到终端。最后，您可以添加容器服务名称，然后跟在容器中要执行的命令。
- en: We are one step closer to the deployment of AWS using **Docker**, but we need
    to automate it. In the next chapter, we will configure the project with GitHub
    Actions to automate deployment on the AWS server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离使用 **Docker** 在 AWS 上部署又近了一步，但我们需要自动化它。在下一章中，我们将配置项目以使用 GitHub Actions 自动化
    AWS 服务器上的部署。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to dockerize a Django application. We started
    by looking into Docker and its use in the development of modern applications.
    We also learned how to build a Docker image and run a container using this image—this
    introduced us to some limitations of Dockerization using Dockerfiles. This led
    us to learn more about Docker Compose and how it can help us manage multiple containers
    with just one configuration file. This in turn directed us to configure a database
    and an NGINX web server with Docker to launch the Postagram API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将 Django 应用程序 Docker 化。我们首先了解了 Docker 以及其在现代应用程序开发中的应用。我们还学习了如何构建
    Docker 镜像并使用此镜像运行容器——这使我们了解了使用 Dockerfile 进行 Docker 化的一些限制。这使我们进一步学习了 Docker Compose
    以及它如何帮助我们通过一个配置文件管理多个容器。这反过来又引导我们使用 Docker 配置数据库和 NGINX 网络服务器以启动 Postagram API。
- en: In the next chapter, we will configure the project for automatic deployment
    on AWS but also carry out regression checks using the tests we have written.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为项目配置自动部署到 AWS，并使用我们编写的测试执行回归检查。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Docker?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker？
- en: What is Docker Compose?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker Compose？
- en: What is the difference between Docker and Docker Compose?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Docker 和 Docker Compose 之间的区别？
- en: What is the difference between containerization and virtualization?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器化和虚拟化之间的区别是什么？
- en: What is an environment variable?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是环境变量？
