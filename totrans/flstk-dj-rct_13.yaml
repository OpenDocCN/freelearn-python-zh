- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerizing the Django Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned more about software deployment, and we deployed
    the Django application on an AWS server. However, we came across issues such as
    poor preparation of the project for deployment, violation of some security issues,
    and deployment and development configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to use Docker on the Django backend and
    configure environment variables. We will also configure the database on a web
    server called **NGINX** using **Docker**. Here are the big sections of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerizing the Django application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose for multiple containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring environment variables in Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing NGINX configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have Docker and Docker Compose installed
    on your machine. The Docker official documentation has a well-documented process
    for the installation on any OS platform. You can check it out at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  prefs: []
  type: TYPE_NORMAL
- en: The code written in this chapter can also be found at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap13).
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before defining what **Docker** is, we must understand what a container is and
    its importance in today’s tech ecosystem. To make it simple, a container is a
    standard unit of software that packages up the software and all of its required
    dependencies so that the software or the application can run quickly and reliably
    from one machine to another, whether the environment or the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting definition from Solomon Hykes at the 2013 *PyCon* talk is: containers
    are “*self-contained units of software you can deliver from a server over there
    to a server over there, from your laptop to EC2 to a bare-metal giant server,
    and it will run in the same way because it is isolated at the process level and
    has its own* *file system*.”'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Containerization is different from virtualization. Virtualization enables teams
    to run multiple operating systems on the same hardware, while containerization
    allows teams to deploy multiple applications using the same operating system on
    single hardware with their own images and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, right? Remember at the beginning of this book when we had to make configurations
    and installations depending on the OS mostly for the Python executable, the Postgres
    server, and different commands to create and activate a virtual environment? Using
    Docker, we can have a single configuration for a container, and this configuration
    can run the same on any machine. Docker ensures that your application can be executed
    in any environment. Then, we can say that Docker is a software platform for building,
    developing, and developing applications inside containers. It has the following
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimalistic and portable**: Compared to **virtual machines** (**VMs**) that
    require complete copies of an OS, the application, and the dependencies, which
    can take a lot of space, a Docker container requires less storage because the
    image used comes with **megabytes** (**MB**) in size. This makes them fast to
    boot and easily portable even on small devices such as Raspberry Pi-embedded computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker containers are scalable**: Because they are lightweight, developers
    or DevOps can launch a lot of services based on containers and easily control
    the scaling using tools such as Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker containers are secure**: Applications inside Docker containers are
    running isolated from each other. Thus, a container can’t check the processes
    running in another container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a better understanding of what Docker is, we can now move on to integrate
    Docker into the Django application.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing the Django application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the precedent section, we defined Docker and its advantages. In this section,
    we will configure Docker with the Django application. This will help you understand
    better how Docker works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A characteristic of projects that use Docker is the presence of files called
    **Dockerfiles** in the project. A Dockerfile is a text document that contains
    all the commands necessary to assemble a Docker image. A Docker image is a read-only
    template with instructions to create a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an image with a Dockerfile is the most popular way to go as you only
    need to enter the instructions you will require to set up an environment, install
    the package, make migrations, and a lot more. This is what makes Docker very portable.
    For example, in the case of our Django application, we will write the Dockerfile
    based on an existing image for Python `3.10` based on the popular Alpine Linux
    project ([https://alpinelinux.org/](https://alpinelinux.org/)). This image has
    been chosen because of its small size, equal to 5 MB. Inside the Dockerfile, we
    will also add commands to install Python and Postgres dependencies, and we will
    further add commands to install packages. Let’s get started with the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file at the root of the Django project called `Dockerfile`
    and adding the first line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of your `Dockerfile` will start with this line. Here, we are telling Docker
    which image to use to build our image. The `python:3.10-alpine` image is stored
    in what is called a Docker registry. This is a storage and distribution system
    for Docker images, and you can find the most popular one online, called Docker
    Hub, at [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s set the working directory. This directory will contain the code
    of the running Django project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Django application uses Postgres as a database, add the required dependencies
    for Postgres and Pillow to our Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the Python dependencies after making a copy of the `requirements.txt`
    file in the `/app` working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, copy over the whole project itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, expose port `8000` of the container for access to the other applications
    or the machine, run the migrations, and start the Django server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dockerfile` file will have the following final code:'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have just written the steps to build an image for the Django application.
    Let’s build the image with the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command uses the `Dockerfile` to build a new container image—that’s
    why we have a dot (`.`) at the end of the command. It tells Docker to look for
    the `Dockerfile` in the current directory. The `-t` flag is used to tag the container
    image. Then, we are building an image with the `django-backend` tag using the
    `Dockerfile` we have written. Once the image is built, we can now run the application
    in the container by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s describe the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--name` will set the name of the Docker container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d` makes the image run in detached mode, meaning that it can run in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-postagram` specifies the name of the image to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After typing the preceding command, you can check the running container with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Listing Docker containers on the machine](img/Figure_13.1_B18821.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Listing Docker containers on the machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The container is created, but it looks like it’s not working well. In your
    browser, go to `http://localhost:8000`, and you will notice that the browser returns
    a page with an error. Let’s check the logs for the `django-postagram` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will output in the terminal what is happening inside the container.
    You will have a similar output to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Logs for django-postagram container](img/Figure_13.2_B18821.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Logs for the django-postagram container
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s quite normal. The container is running on its own network and doesn’t
    have direct access to the host machine network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we added services for NGINX and Postgres and made
    the configurations. We need to also do the same with `Dockerfiles` for NGINX and
    Postgres. And let’s be honest: it starts to become a little bit much. Imagine
    adding a Flask service, a Celery service, or even another database. Depending
    on the *number n* of components of your system, you will need `n Dockerfiles`.
    This is not interesting, but thankfully, Docker provides a simple solution for
    that called Docker Compose. Let’s explore it more.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose for multiple containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose is a tool developed and created by the Docker team to help define
    configurations for multi-container applications. Using Docker Compose, we just
    need to create a YAML file to define the services and the command to start each
    service. It also supports configurations such as container name, environment setting,
    volume, and a lot more, and once the YAML file is written, you just need a command
    to build the images and spin all the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the key difference between a Dockerfile and Docker Compose:
    a Dockerfile describes how to build the image and run the container, while Docker
    Compose is used to run Docker containers. At the end of the day, Docker Compose
    still uses Docker under the hood, and you will—most of the time—need at least
    a Dockerfile. Let’s integrate Docker Compose into our workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the docker-compose.yaml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing the YAML file, we will have to make some changes to the `Dockerfile`.
    As we will be launching the Django server from the `docker-compose` file, we can
    remove the lines where we expose the port, run the migrations, and start the server.
    Inside the `Dockerfile`, remove the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, create a new file called `docker-compose.yaml` at the root
    of the project. Make sure that the `docker-compose.yaml` file and the `Dockerfile`
    are in the same directory. The `docker-compose.yaml` file will describe the services
    of the backend application. We will need to write three services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NGINX**: We are using NGINX as the web server. Thankfully, there is an official
    image available we can use to write quick configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postgres**: There is also an official image available for Postgres. We will
    just need to add environment variables for the database user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-backend`: This is the backend application we have created. We will
    use the `Dockerfile` so that Docker Compose will build the image for this service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start writing the `docker-compose.yaml` file by adding the NGINX service
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what is going on in the preceding code because the other services
    will follow a similar configuration. The first line sets the file format we are
    using, so it is not related to Docker Compose, just to YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we are adding a service called `nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container_name` represents, well, the name of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart` defines the container restart policy. In this case, the container
    is always restarted if it fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concerning the restart policies for a container, you can also have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no`: Containers will not restart automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure[:max-retries]`: Restart the container if it exits with a nonzero
    exit code and provides a maximum number of attempts for the Docker daemon to restart
    the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped`: Always restart the container unless it was stopped arbitrarily
    or by the Docker daemon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: This tells Docker Compose to use the latest NGINX image available
    on Docker Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes` are a way of persisting data generated and used by Docker containers.
    If a Docker container is deleted or removed, all its content will vanish forever.
    This is not ideal if you have files such as logs, images, video, or anything you
    want to persist somewhere because every time you remove a container, this data
    will vanish. Here is the syntax: `/host/path:/container/path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Connection requests coming from the host port `80` are redirected
    to the container port `80`. Here is the syntax: `host_port:container_port`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`: This tells Docker Compose to wait for some services to start
    before starting the service. In our case, we are waiting for the Django API to
    start before starting the NGINX server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great! Next, let’s add the service configuration for the Postgres service:'
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have new parameters here called `env_file` which specifies the path to the
    environment file that will be used to create the database and the user, and set
    the password. Let’s finally add the Django API service:'
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The build parameter in the Docker Compose file tells Docker Compose where to
    look for the `Dockerfile`. In our case, the `Dockerfile` is in the current directory.
    Docker Compose allows you to have a `command` parameter. Here, we are running
    migrations and starting the Django server using Gunicorn, which is new. `gunicorn`
    is a Python `gunicorn`? Most web applications run with an Apache server, so `gunicorn`
    is basically designed to run web applications built with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the package in your current Python environment by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But you will need to put the dependency in the `requirements.txt` file so that
    it can be preset in the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: requirements.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to declare at the end of the file the volumes used:'
  prefs: []
  type: TYPE_NORMAL
- en: docker-compose.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And we have just written a `docker-compose.yaml` file. As we are going to use
    environment variables in the project, let’s update some variables in the `settings.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring environment variables in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a bad habit to have sensitive information about your application available
    in the code. This is the case for the `SECRET_KEY` setting and the database settings
    in the `settings.py` file of the project. It is quite bad because we have pushed
    the code to GitHub. Let’s correct this.
  prefs: []
  type: TYPE_NORMAL
- en: 'An environment variable is a variable whose value is set outside the running
    code of the program. With Python, you can read files from a `.env` file. We will
    use the `os` library to write the configurations. So, first, create a `.env` file
    at the root of the Django project and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: .env
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`SECRET_KEY` is an important variable for your Django project, so you need
    to ensure that you have a long and complicated chain of characters as the value.
    You can visit [https://djecrety.ir/](https://djecrety.ir/) to generate a new chain
    of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to install a package to help you manage environment variables.
    The package is called `python-dotenv`, and it helps Python developers read environment
    variables from `.env` files and set them as environment variables. If you are
    going to run the project again on your machine, then add the package to your actual
    Python environment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, add the package to the `requirements.txt` file so that it can
    be installed in the Docker image. Here’s a look at the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation of the `python-dotenv` package is done, we need to write
    some code in the `CoreRoot/settings.py` file. In this file, we will import the
    `python-dotenv` package and modify the syntax of some settings so that it can
    support environment variables’ reading:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s rewrite the values of variables such as `SECRET_KEY`, `DEBUG`, `ALLOWED_HOSTS`,
    and `ENV`:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os` package provides an object to retrieve environment variables from
    the user machine. After `python-dotenv` has forced the loading of the environment
    variables, we use `os.environ` to read the values from the `.env` file. Let’s
    finally add the configuration for the `DATABASES` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Great! We are done configuring the environment variables in the `settings.py`
    file. We can now move on to write the configurations for NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: Writing NGINX configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NGINX requires some configuration from our side. If there is a request on the
    HTTP port of the machine (by default `80`), it should redirect the requests to
    port `8000` of the running Django application. Put simply, we will write a reverse
    proxy. A proxy is an intermediary process that takes an HTTP request from a client,
    passes the request to one or many other servers, waits for a response from those
    servers, and sends back a response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: By using this process, we can forward a request on the HTTP port `80` to port
    `8000` of the Django server.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root of the project, create a new file called `nginx.conf`. Then, let’s
    define the upstream server where HTTP requests will be redirected to:'
  prefs: []
  type: TYPE_NORMAL
- en: nginx.conf
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code follows the simple syntax shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Docker allows you to refer to the container’s host with the `defined` container
    name. In the NGINX file, we are using `postagram_api` instead of the IP address
    of the container, which can change, and for the database, we are using `postagram_db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to declare the configuration for the HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: nginx.conf
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server configuration, we first set the port of the server. In the preceding
    code, we are using port `80`. Next, we are defining locations. A location in NGINX
    is a block that tells NGINX how to process the request from a certain URL:'
  prefs: []
  type: TYPE_NORMAL
- en: A request on the `/` URL is redirected to the web app upstream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request on the `/media/` URL is redirected to the `uploads` folder to serve
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the NGINX configuration ready, we can now launch the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Docker containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s launch the Docker containers. As we are now using Docker Compose to orchestrate
    containers, let’s use the following command to build and start the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will spin up all the containers defined in the `docker-compose.yaml`
    file. Let’s describe the command options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`up`: This builds, recreates, and starts containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: This is used to detach, meaning that we are running the containers in
    the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`—build`: This flag tells Docker Compose to build the images before starting
    the containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the build is done, open your browser at `http://localhost`, and you should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Dockerized Django application](img/Figure_13.3_B18821.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Dockerized Django application
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully containerized the Django application using Docker. It
    is also possible to execute commands inside containers, and right now, we can
    start by running a test suite inside the `postagram_api` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The syntax to execute a command in a Docker container is to first call the `exec`
    command followed by the `–T` parameter to disable `pseudo-tty` allocation. This
    means that the command being run inside the container will not be attached to
    a terminal. Finally, you can add the container service name, followed by the command
    you want to execute in the container.
  prefs: []
  type: TYPE_NORMAL
- en: We are one step closer to the deployment of AWS using **Docker**, but we need
    to automate it. In the next chapter, we will configure the project with GitHub
    Actions to automate deployment on the AWS server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to dockerize a Django application. We started
    by looking into Docker and its use in the development of modern applications.
    We also learned how to build a Docker image and run a container using this image—this
    introduced us to some limitations of Dockerization using Dockerfiles. This led
    us to learn more about Docker Compose and how it can help us manage multiple containers
    with just one configuration file. This in turn directed us to configure a database
    and an NGINX web server with Docker to launch the Postagram API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will configure the project for automatic deployment
    on AWS but also carry out regression checks using the tests we have written.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Docker and Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between containerization and virtualization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an environment variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
