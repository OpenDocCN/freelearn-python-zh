- en: Chapter 7. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands, our to-do list manager application can be accessed by anyone.
    Whoever can get to the 8080 port on the Grok server will be able to create, update,
    and delete projects and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about what we want the application to do, it would be nice if only
    authenticated users are able to access it in the first place. For example, it
    should be possible to install the application inside a company and have only a
    single department there as the application's users. Users with the correct permissions
    could create projects and assign tasks to team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grok includes the necessary tools to accomplish this, as we will see in this
    chapter. Here are the key concepts that we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principals, permissions, and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the default security policy is and how it is defined in the `site.zcml`
    configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up authentication using `site.zcml` declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a custom security policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and managing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When speaking about web application security, there are two important concepts
    to get right before beginning: **authentication** and **authorization**.'
  prefs: []
  type: TYPE_NORMAL
- en: In a given application, we might have a number of users who are allowed to log
    in. To do so, they usually would provide a username and a password. If the username
    and the password match, the user has been authenticated, so the system assumes
    he is who he says he is. In this chapter, we will learn how to perform authentication
    in Grok by using plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user is logged in, he may want to perform a number of actions, from just
    viewing the application to managing it. The user is authorized to perform some
    or all of the available actions by giving him specific permissions to carry them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Principals, permissions, and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Grok, users are known by the term 'principals'. A **principal** represents
    any entity that interacts with the application, be it a user or any kind of agent,
    such as a remote client program. A **group** is a special kind of principal that
    can contain other principals. In the rest of the chapter, we will mostly use the
    more familiar term 'user' when talking about principals.
  prefs: []
  type: TYPE_NORMAL
- en: Views in Grok can be protected by permissions, so that only users with the correct
    permission can access each view. By default, however, Grok allows everybody including
    authenticated users, to have unrestricted access to all of the views.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of assigning and keeping track of permissions to individual users, it's
    more efficient to group related permissions together and assign this group to
    a user. That's what roles do in Grok. For example, the admin user that we have
    been using for accessing the Grok administration UI has the role `zope.Manager`
    that grants all existing permissions to this user.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about permissions and roles after we introduce security policies
    in the *Setting up a custom security policy* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Security policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Grok application will thus have a number of principals, permissions, and roles.
    The collection of these is called a **security policy** and represents the global
    security decisions for a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, Grok applications have a default security policy that
    gives view permission to everybody. It also defines authenticated and unauthenticated
    user groups.
  prefs: []
  type: TYPE_NORMAL
- en: Default Grok security policy definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The security policy that Grok uses by default is defined in the `site.zcml`
    file, which is inside the `etc` directory. There are several declarations in this
    file which we will discuss individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement is the user representation for unauthenticated users
    in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All of the users who visit the application without authenticating will share
    this same ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unauthenticated group is assigned to unauthenticated principals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to have this defined for group operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a dynamic group that includes all of the authenticated users,
    irrespective of their permissions or roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a group that includes all users, authenticated or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now come to the part where users are defined. In this case, there is only
    one user, the "site manager", with the login "admin":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the password is assigned to this manager using plain text. You
    may recall that the title defined here is what we show in the creator column when
    listing the projects in the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The next two declarations grant the permissions for viewing to the `zope`. Anybody
    user that represents the unauthenticated principal defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this case there is no separate definition for permission, because
    a permission is just a name. These declarations allow all unauthenticated users
    to view, so by default, an application is wide open for viewing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the role definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A "site manager" role is defined for managing the site. Then, a "site member"
    role is defined for regular site users, although this role is unused in the default
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all of the permissions are granted to the `zope.Manager` role by using
    `grantAll`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means that users with the manager role will get all defined permissions.
    The role is then assigned to the user we defined earlier in the *Principals, permissions,
    and roles* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, a security policy consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A number of users who can log into the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups of users, which can contain any number of users. A user can also belong
    to several groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific permissions for allowing these users to work with parts of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles that can be assigned multiple permissions, so that a user or group can
    be assigned a role that includes all related permissions for a task. This greatly
    simplifies permission administration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the security policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been accessing the application by using the "manager" user that
    is defined in the *Default Grok security policy definition* section. Now, close
    all of the browser windows, reopen the browser, and go to the `todo` application
    URL directly, without logging in. You are unauthenticated, yet no login window
    will be shown. Add a project or make some other change and see how the application
    does it obediently.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the security policy](img/7481_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wait a minute, didn't we say that only the view permission was assigned to the
    unauthenticated user? Why did Grok allow us to make changes to the projects then?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the thing is, views need to be specifically protected with permissions,
    if we want to protect them. Until we do so it doesn't matter whether the user
    is authenticated or not, much less, if he holds the required permissions. Again,
    all of this is intended by the very open default security policy for Grok applications.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the default view permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s change the default security policy a bit to see how it works. In the
    specific case of the to-do list manager, we would like to keep unauthenticated
    users away, so let''s begin by changing the `grant permission` declarations to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of granting view permissions to everybody, we grant them to the `zope.Authenticated`
    group that we defined earlier, so that only authenticated users are allowed to
    access the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test these declarations, we need to add another user to the site, because
    the "manager" user will get the view permission anyway. Add the following lines
    to `site.zcml`, after the manager definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We now have a `todo.user` with "user" as the username and password. Save the
    file and restart Grok. It is necessary to delete and create the application again,
    as security policies are applied at the moment of application creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it should be possible to log in as `todo.user`. Try it: Go to the root
    of the site to get the login window, and then enter the new user''s login and
    password. You will see an error message because the new user does not have permission
    to manage Grok applications. Ignore the error and go to the application URL. The
    project dashboard will appear in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our new user can create and delete projects and tasks, as the views
    are not protected. Not only that, but unauthenticated users can still view and
    edit everything.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting a view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s time to protect a view and keep unauthenticated users away from it, as
    intended. Just change the dashboard view to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To protect a view with a permission, we use the `grok.require` class annotation.
    Notice how we passed the permission name to it as defined in the `site.zcml` configuration
    file. Restart the application (no need to re-create it this time), and then close
    and open the browser to lose the current authentication information. Try to access
    the application URL without logging in and you should get the login window. Unauthenticated
    users can't view the dashboard anymore. Enter the `todo.user` credentials, and
    the dashboard will appear again.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom security policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how the security machinery works, we are ready to add
    our own security policy to the application. Let's begin by creating some permissions,
    and attaching them to our views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grok offers a very easy mechanism for defining permissions and restricting access.
    A permission can be defined simply by subclassing from the `grok.Permission` class
    and adding a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, let''s define only four permissions for our application
    a general permission to view, and specific permissions for adding projects and
    lists or modifying list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Permissions are applied to views by using the `grok.require` directive, so
    to protect each of our views we need to go through our application code and add
    an appropriate `grok.require` statement to each view. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We protect the dashboard with our view permission, which means no anonymous
    users will be able to access it. The `TodoAddList` view will require `addlists`
    permission, and to delete a project, the `addprojects` permission is necessary.
    In this way, we can protect all of our views with the permissions that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The views are protected with permissions, but assigning the permissions to actual
    users is best done by using roles. Let's define three simple roles for the application.
    *Project members* will be able to view and change list items only. *Project managers*
    can do all that and also create lists. *Application managers* are the only ones
    who can create projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grok.Role` class is useful for defining these roles, as shown by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created four separate roles for different user levels in our application.
    Each role is assigned a name and one or more permissions by using the `grok.name`
    and `grok.permissions` declarations respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a **role** is simply a collection of permissions with a name.
    The benefit of using such a collection instead of assigning each permission individually
    is that once a role is assigned to a user, it's possible to add or remove permissions
    from the role without having to grant or remove them from each user individually.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have all of our views protected, but so far there are no users, so nobody
    can be assigned the roles that we created. We need to add a mechanism for creating
    and managing users, as well as a way to authenticate them and assign roles to
    them, so that they can use the different views.
  prefs: []
  type: TYPE_NORMAL
- en: The Pluggable Authentication Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Pluggable Authentication Utility** (**PAU**) is a framework for authenticating
    users. It is a part of the Zope Toolkit and currently Grok offers no built-in
    mechanisms to work with it, but we'll see that it is not too complex.
  prefs: []
  type: TYPE_NORMAL
- en: PAU uses plugins to do its work, so that it's possible to have plugins for different
    authentication sources, and easily substitute one for another, or even have them
    work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of plugins for PAU: "credentials" plugins extract credentials
    from a request (user and password, for example) and "authenticator" plugins check
    that these credentials are valid and generate a user for the application to work
    with, if they are.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering PAU with our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to use PAU in our application, we first need to register it as a
    local utility. A **utility** is simply a service that an application can provide.
    Being local means that it can store information and configuration specific to
    each instance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Here's how we can register PAU in our main `todo` application definition. First,
    we import `PluggableAuthentication`, which is a factory that will create the actual
    PAU object. We also import `IAuthentication`, which is the interface that our
    PAU utility must provide in order to integrate with the authentication machinery.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we register a PAU utility, we need to configure it to use the appropriate
    plugins, which is the purpose of the `setup_authentication import` statement in
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we register the utility by using the `grok.local_utility` directive and
    passing to the directive the `PluggableAuthentication` factory, the interface
    that it''s going to provide, and the `setup` function. Keep in mind that this
    directive is in no way exclusive to PAU­ any kind of service can be registered
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all we need to do for now in the main `app.py` file. Let''s add the
    `setup_authentication` method, and all of the other security classes and views,
    in another module. Create the `auth.py` file and add the following lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple method that just assigns a plugin named `credentials`
    to the `credentialsPlugins` of our PAU, and assigns another plugin named `users`
    to the `authenticatorPlugins`. The first will take care of extracting the user's
    credentials from the browser request and making them available to the application.
    The `users` plugin will be used for authentication. Of course, these plugins do
    not exist yet; we need to create them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a credentials plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the credential extraction service, we are going to use a plugin called `SessionCredentialsPlugin`,
    which comes with the Zope Toolkit. As its name implies, this plugin stores the
    credentials extracted by requesting the session, so that the application can easily
    use this information. As we don't need to store any application-specific information
    inside the plugin, let's use a global utility this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A **global utility** is simply a service that is not stored in the application
    data, but resides in a registry that's available to all application instances
    in Grok. We will explain utilities in more detail in Chapter 11.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we inherit from both `grok.GlobalUtility` and the `SessionCredentialsPlugin`
    that we mentioned earlier. The `grok.name` directive is very important here because
    it assigns a name to the plugin that we configured earlier in the `setup_authentication`
    method for our PAU.
  prefs: []
  type: TYPE_NORMAL
- en: After that comes a few class variables that are used to configure how the plugin
    works. `loginpagename` is the name of the view that will be shown whenever a user
    attempts to access a protected page. Typically, this points to a login form. `loginfield`
    and `passwordfield` are the names of the fields within this form that will contain
    the credentials of the user. They will be used by the authenticator plugin to
    authenticate the user with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The login form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have configured the credentials plugin, to look for the login form
    when a user wants to access a protected view, we might as well create the form
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a form schema by using an interface. The `login` and `password`
    fields should have the exact same names that we configured in the credentials
    plugin. We added a `camefrom` parameter that will be used to redirect the user
    to the page he wanted to view before he logged in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `SessionCredentialsPlugin` automatically adds this variable to the request
    when it redirects the user to the login form, so the name has to be the same.
    That's why we assign an empty string to the form field `prefix` in the following
    code to keep the name intact.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the `grok.require` declaration to assign the permission `zope.Public`
    to the view. This permission is defined in the Zope Toolkit that powers Grok and
    is assigned to the views that everyone can see. We use this permission to make
    it explicit that every visitor to our application can get to the login form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need a `setUpWidgets` method inside this class, so that we can make sure
    that the `camefrom` field is not displayed on the form, which uses the custom
    template we created back in Chapter 5\. This is done so that it looks integrated
    with the design that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `handle_login` action redirects the user to the `camefrom` URL,
    or to the site root if `camefrom` is not available. If the user enters invalid
    credentials, the login form will be displayed again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Look at the form in action, in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The login form](img/7481_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The logout view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a login mechanism, so we need a way to finish a session and maybe log
    in as a different user. We will add a logout view to take care of this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to determine if the current user is logged in, which we do by
    getting this information from the request by using `self.request.principal` and
    checking to see if it provides the `IUnauthenticatedPrincipal` interface. If it
    does, then we'll know that this user is not authenticated. If it turns out that
    he is authenticated, we look for our PAU by using `component.getUtility` and calling
    the `logout` method.
  prefs: []
  type: TYPE_NORMAL
- en: This view needs a template, which we will keep pretty simple for now. Take a
    look at the next screenshot to see this view in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![The logout view](img/7481_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UserAuthenticator plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the authentication part, we are going to need another local utility because
    we need to store user information in there. We register the utility in a similar
    way to the PAU utility, by using the `grok.local_utility` directive. In fact,
    this code goes just below the PAU declaration in our main application file, `app.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that we pass a `name` parameter that has to correspond
    to the name that we used for the plugin in the `setup_authentication` method.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a Grok container in order to store the user accounts
    there, so our plugin will know how to create a new user, and to decide if a login
    attempt has valid credentials for an existing one. Let's look at the authenticator
    plugin code step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make some imports, and then comes the plugin definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we inherit from `grok.LocalUtility` and implement the `IAuthenticatorPlugin`
    interface. When the utility is initialized (the `__init__` method), we create
    a user folder and store it there. The user folder is a simple Grok container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we come to the methods of the plugin itself. The `authenticateCredentials`
    method is called whenever a login attempt is made. It receives the credentials
    that the credentials plugin extracted from the request, and then uses the `getAccount`
    method to try to get a valid account. Next, it calls the account's `checkPassword`
    method to verify the password against the one from the user's credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `authenticateCredentials` method returns a `PrincipalInfo` object
    that contains the account name, the title or display name, and the description
    for the user. This object implements the `IPrincipalInfo` interface that was imported
    at the top of the code, which means that you can expect to find similar behavior
    in other authenticator plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the `PrincipalInfo` class code that is used in this plugin. In addition
    to the principal information, it holds the credentials and authenticator plugins
    used to authorize the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IAuthenticatorPlugin` interface that we are implementing in this plugin
    needs to have a `principalInfo` method, which should return the `PrincipalInfo`
    object that we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The plugin's most important method is `getAccount`, which tries to find a given
    user account inside the `user_folder`, and returns that, or `None`, if the user
    is not found. Right now we are using the Grok ZODB to store the users, but we
    could easily access a relational database, or an external authentication system
    instead, by modifying this method.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is fairly straightforward. We use a Boolean expression to
    check if the login that was passed into the method is in our `user` folder and
    if so, return the user object that's inside. Otherwise, we return `None:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Adding users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other important method of our authenticator plugin is `addUser`. This creates
    an account object with a given username, and then uses this name to assign a role
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After creating a user account inside our `user` folder, the most important bit
    in this method is the part where we take the role that is passed from the `addUser`
    form and assign the appropriate role to the new user accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe how we first get the `RoleManager` for the site, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we know what role to apply, we use its `assignRoleToPrincipal` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the account class that we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Account objects need to include the `checkPassword` and `setPassword` methods,
    which are used together with a password manager utility. The utility does all
    of the heavy work, as the `checkPassword` method simply gets the account password
    and passes it, together with the password that the user entered, to the `checkPassword`
    method of the `passwordManager`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setPassword` method uses the `encodePassword` method of the `passwordManager`
    utility to set the password. You may recall that we saw a 'plain-text' password
    manager when we worked with the `site.zcml` declarations at the beginning of this
    chapter. In this case, we use a `SHAI` password manager, to be able to store encrypted
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Basic user management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we need a way to add users to our application. The `addUser` method
    of the `UserAuthenticator` is exclusively called by a form that we define using
    the interface and schema mechanism for automatic form presentation that were discussed
    in Chapter 5\. First, we define an interface for the form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the actual `AddUser` form, which uses the fields from the previously
    defined interface to construct the form. The `handle_add` method uses the Grok
    `action` decorator to add a button to the form that will call the `addUser` method
    from the authenticator plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we add a role field that allows the manager to assign one of our
    defined roles to each user. It''s very important to note that this user management
    view is protected with the `zope.ManageApplication` permission, which is assigned
    to Zope managers only. If we used one of our own permissions, we would never be
    able to create a user in the first place. The finished form can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic user management](img/7481_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple user list view completes the user interface for our user management
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new here. We just get the list of users from the `UserAuthenticator`
    plugin and pass it on to the view template, which simply lists the users in a
    table. You should now be familiar with some of this code. First, we insert our
    stylesheet definition using the static view, to correctly show the URL in the
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the main body of the template, we have the site search form that is a part
    of the header, and contains the application's title. Then we have a link to add
    a new user, which points to the form that we just defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The user listing is shown only if there are any users, and consists of a table
    that iterates through the user listing defined in the `UserList` view (view/users).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We can now have multiple users with different profiles in our application,
    as shown in the next screenshot. Create some users and test the permissions and
    roles to see how it works together.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic user management](img/7481_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Grok's security features, and added authentication
    and authorization to our application.
  prefs: []
  type: TYPE_NORMAL
