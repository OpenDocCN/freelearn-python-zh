- en: Chapter 5. Advanced Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we have exclusively been mixing C and Python together.
    In this chapter, we will delve into C++ and Cython. With every release of Cython
    C++, the support has improved. This is not to say that it''s not ready for use
    yet. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Make native C++ classes callable from Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping C++ namespaces and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How exceptions can be propagated to and from C++ and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ new and del keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython gil and nogil keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will wrap up this chapter by embedding a web server into a toy C++ messaging
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Cython and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython, above all binding generators, works with C++ the most seamlessly. C++
    has some complexity when writing bindings for it, such as calling conventions,
    templates, and classes. I find this exception handling to be a shining feature
    of Cython, and we will look at the examples of each.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I am introducing namespaces first because Cython uses namespaces as a way to
    reference C++ code within your module. Consider this C++ header with the following
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will wrap this with the `cdef extern` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now address it in Cython as you normally would do for a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It really feels like a Python module simply by using a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I would take a guess that most of your C++ code revolves around using classes.
    Being an object-oriented language, Cython handles this seamlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Cython''s `cppclass` keyword. This special keyword allows you to
    declare C++ classes and work with them directly, so you don''t need to write the
    wrapper code, which can be very tedious and error prone in big projects. Using
    the previous namespace example, we will wrap the namespace and then the class
    within the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty simple just as C types were. Though now, you have a native C++ object,
    which can be very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Cython will only care about the `public` attributes. Since these
    are the only attributes a callee can access due to the encapsulation of private
    and protected methods. It is not possible to extend the C++ class. Now, you can
    work with these as if they were just `cdef` structs. Just use the '`.`' operator
    as before to access all the necessary attributes.
  prefs: []
  type: TYPE_NORMAL
- en: C++ new and del keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cython understands the `new` keyword from C++; so, consider that you have a
    C++ class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is defined in Cython as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we do not declare the `~Car` destructor because we never call this
    directly. It''s not an explicitly callable public member; this is why we never
    call it directly but delete will and the compiler will ensure this is called when
    it will go out of scope on the stack. To instantiate the raw C++ class in Cython
    code on the heap, we can simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then go and use `del` to delete the object at any time using Python''s
    `del` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the destructor is called as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare a stack-allocated object, but it must only have a default
    constructor such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no way to pass arguments with this syntax in Cython. But, note that
    you cannot use `del` on this instance, else you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With C++ exception handling, you can get a sense of how seamless Cython can
    feel within the C++ code. If any exceptions are thrown, such as memory allocations,
    Cython will handle these and translate them into more useful errors, and you still
    get the valid C++ exceptions objects. Python will also understand if these are
    caught or not and whether they are handled as required. This table gives you an
    idea of what Python exceptions will map to within C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_alloc` | `MemoryError` |'
  prefs: []
  type: TYPE_TB
- en: '| `bad_cast` | `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| `domain_error` | `ValueError` |'
  prefs: []
  type: TYPE_TB
- en: '| `invalid_argument` | `ValueError` |'
  prefs: []
  type: TYPE_TB
- en: '| `ios_base::failure` | `IOError` |'
  prefs: []
  type: TYPE_TB
- en: '| `out_of_range` | `IndexError` |'
  prefs: []
  type: TYPE_TB
- en: '| `overflow_error` | `OverflowError` |'
  prefs: []
  type: TYPE_TB
- en: '| `range_error` | `ArithmeticError` |'
  prefs: []
  type: TYPE_TB
- en: '| `underflow_error` | `ArithmeticError` |'
  prefs: []
  type: TYPE_TB
- en: '| All other exceptions | `RuntimeError` |'
  prefs: []
  type: TYPE_TB
- en: 'For instance, take this C++ code. It will simply throw an exception when the
    `myFunc` function is called. First, we define an exception with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we write the function to throw the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this in Cython with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the function, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to catch the C++ exception in your Python code, you can simply
    use it as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we told Cython to cast any exceptions to `RuntimeError`. This is
    important to make sure you understand where and which interfaces can throw an
    exception. Unhanded exceptions look really ugly and can be harder to debug. Cython
    cannot assume much about the state at this point since compilers won''t throw
    errors on potentially unhandled exceptions in C++ at the code level. If this happens,
    you will get the following as the no exception handler is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Bool type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in the previous chapter, to use the native `bool` type from C++, you
    need to firstly import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `bool` as a normal `cdef`. If you want to use the pure PyObject
    `bool` type, you need to import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can then assign them with the normal `true` or `false` values.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Python supports overloading to wrap C++ overload, just list the members
    as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Cython understands that we are in C++ mode and can handle all the type conversion
    as normal. It''s interesting that it can also handle an operator overload easily
    since it is just another hook! For example, let''s take the `Car` class again
    and perform some operator overriding such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add these operator-overloading class members to your Cythonized
    class; otherwise, your Cython will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cython declaration of the operator overload looks as you expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will then give us the following output on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Everything is handled as you would expect. This, for me, demonstrates the principle
    that inspired Guido to design Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are supported in Cython. Though, for the sake of completeness, template
    meta-programming patterns don't wrap up correctly or fail to compile. This keeps
    getting better with every release, so take this comment with a pinch of salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ class templates work very well; we can implement a template called `LinkedList`
    as the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can access the template type with the declaration called `T`. You can
    follow the rest of this code in `chapter5/cpptemplates`.
  prefs: []
  type: TYPE_NORMAL
- en: Static class member attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, in classes, it''s useful to have a static attribute such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In Cython, there is no support for this via a `static` keyword, but what you
    can do is tie this function to a namespace so that it becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, you simply call this method as a global method in Cython.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C++ functions – Caveat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you write a code to call in a C++ function from C, you need to wrap the
    prototypes in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to call C++ prototypes because C won't understand a C++ class.
    With Cython, if you are telling your C output to call in C++ functions, you need
    to be careful about which compiler you are using or you need to write a new header
    to implement the minimal wrapper functions required to make the C++ calls.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces – Caveat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cython seems to generally require a namespace to keep things nested, which you
    are already probably doing in your C++ code. Making PXD on non-namespaced code
    seems to make new declarations, meaning that you will get linking errors due to
    multiple symbols. The C++ support looks really good from these templates, and
    more metaprogramming idioms can be difficult to express in Cython. When polymorphism
    comes into play, it can be difficult to track down compilation errors. I would
    stress that you should keep your interfaces as simple as possible to perform debugging
    and to be more dynamic!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, when using Cython to generate C++, you need to specify `–cplus`, so
    it will default the `cythonfile.cpp` output. Pay attention to the extensions;
    I prefer to use `.cc` for my C++ code, so just be careful with your build system.
  prefs: []
  type: TYPE_NORMAL
- en: Python distutils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we can also use Python `distutils`, but you will need to specify
    the language so that the auxiliary C++ code required will be compiled by the correct
    compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can compile your C++ code to your Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Python threading and GIL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GIL** stands for **Global Interpreter Lock**. What this means is when you
    link your program against `libpython.so` and use it, you really have the entire
    Python interpreter in your code. The reason this exists is to make concurrent
    applications really easy. In Python you can have two threads reading/writing to
    the same location and Python automatically handles all of this for you; unlike
    say in Java, where you need to specify that everything is under the GIL in Python.
    There are two things to consider when talking about the GIL and what it does—instruction
    atomicity and read/write lock.'
  prefs: []
  type: TYPE_NORMAL
- en: Atomic instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that Cython necessarily generates the C code to make it look similar
    to any Python module that you can import. So, what's happening under the hood
    is that it will generate all the code to acquire lock on the GIL so that it can
    manipulate Python objects at runtime. Let's consider two types of execution. Firstly,
    you have the C stack where it executes atomically as you would expect; it doesn't
    care about synchronization between threads—this is left up to the programmer.
    The other is Python where it's doing all of this synchronization for us. When
    you embed Python into your application manually using `Py_Initilize`, this is
    under the C execution. When it comes to calling something, such as `import sys`
    and `sys.uname`, in the Cython code that is called from C, the Python GIL schedules,
    and blocks multiple threads from calling this at the same time to be safe. This
    makes writing multithreaded Python code extremely safe. Any errors from writing
    to the same location at the same time can happen and be handled correctly instead
    of having to use **mutex's** on critical sections in C.
  prefs: []
  type: TYPE_NORMAL
- en: Read/write lock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The read/write lock is great because it is pretty rare for you in Python to
    need to care about semaphores or mutex's on data unless you want to synchronize
    different thread's access to a resource`.` The worst that can happen is for you
    to get into an inconsistent state in your program, but you won't crash in contrast
    to C/C++. Any read/write operation to the global dictionary is handled the way
    you would expect in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Cython keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so how does this affect you and, more importantly, your code? It is important
    to know what way your code should and/or will execute in a concurrent manner.
    Without an understanding of this, your debugging will be confusing. There are
    times when the GIL gets in the way and can cause issues by blocking the execution
    of your C code from Python or vice versa. Cython allows us to control the GIL
    with the `gil` and `nogil` keywords, which is much simpler by wrapping this state
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cython | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| With gil | `PyGILState_Ensure ()` |'
  prefs: []
  type: TYPE_TB
- en: '| With nogil | `PyGILState_Release (state)` |'
  prefs: []
  type: TYPE_TB
- en: I find that it's easier to think of multithreading in Python in terms of blocking
    and nonblocking the execution. In the next example, we will examine the steps
    needed to embed a web server into a toy messaging server.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The messaging server is an example of something that would be highly concurrent;
    let's say we want to embed a web server into this to show the list of clients
    that are connected to the server. If you look at the flask, you can see how easily
    you can have a full web container in about eight lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The messaging server is asynchronous; therefore, it is callback based in C code.
    These callbacks can then call into Python roster object via Cython. Then, we can
    iterate over the roster dictionary to get online clients and simply return some
    JSON as a web service very easily reusing Python code and no need to write anything
    in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note when embedding web servers is that they start a lot
    of threads. Calling the start web server function will block until it will exit,
    meaning if we start the web server first, we won''t have the messaging server
    running concurrently. Also, due to the web-server function blocking, if we start
    it on a separate thread, it will never exit. Therefore, we are forced to run the
    messaging server on a background thread, and we can do this from the Python threading
    module. Again, this is where the GIL state becomes important. If we were to run
    the messaging server with the GIL and when the callbacks start, they will crash
    or block when they callback into Python. We can wrap the messaging server into
    the toy class called `MessageServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as you would expect, we can start the thread by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I specified `with nogil`. Our C code doesn''t need the GIL since
    we are only using pure C types and not touching any Python runtime until the callbacks.
    Once the `libevent` socket server is running asynchronously, we can then move
    onto starting our flask web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask is fantastic for writing RESTful Web Services. It''s clean, simple, and
    most importantly, easy to use and read. This service returns the JSON representation
    of the client roster. Since I have encapsulated the roster object, I am using
    a simple global so that all the flask routes can query the correct context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The web server now blocks until the kill signal is given. Then, it will return
    and we can then kill `MessageServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we listen onto the specified port in `server.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This roster object holds a list of clients and handles each callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then connect clients using a simple telnet session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can type in messages, see it handled in the server log, and press *Q* to
    quit. We can then query the web service for the list of clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Caveat on GIL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a caveat to remember when using `gil`. In our callbacks, we need to
    acquire the GIL on each callback before we call any Python code; otherwise, we
    will segfault and get really confused. So, if you look into each of the `libevent`
    callbacks when calling the Cython functions, you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this is also called on the other two callbacks—firstly on the `discb`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the connect callback, we must be a little safer and call it this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have to do this since we executed this with `nogil` from Cython. We need
    to acquire `gil` before we go back into the Python land. You really need to look
    at something like this with your creativity cap on and imagine what you could
    do with this. For example, you can use this as a way to capture data and use the
    Twisted Web server to implement an embedded RESTful server. Maybe, you can even
    use Python JSON to wrap data into nice objects. But, it demonstrates how you can
    really extend a fairly complicated piece of C software with something nice and
    of a high-level nature using Python libraries. This keeps everything very simple
    and maintainable instead of trying to do everything from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing the native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another use of Cython is unit testing the core functionality of shared C libraries.
    If you maintain a `.pxd` file (this is all you need really), you can write your
    own wrapper classes and do scalability testing of data structures with the expressiveness
    of Python. For example, we can write unit tests for something such as `std::map`
    and `std::vector` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write a test for `map` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if we compile them into separate modules, we can simply write a test
    executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is really trivial code, but it demonstrates the idea. If you put error
    handling with plenty of asserts and cause a fatal error, you can have some really
    nice unit testing against your C/C++ code. We can go further and implement this
    using Python's native unit testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing subclassing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you create an extension type in Cython, something you never want to be subclassed,
    it is a `cpp` class wrapped in a Python class. To prevent this, you can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation will give an error when someone tries to subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that these annotations only work on the `cdef` or `cpdef` functions and
    not on normal Python `def` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing large amounts of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to try and prove how powerful and natively compiled C types are to programmers
    by showing the difference in parsing large amounts of XML. We can take the geographic
    data from the government as the test data for this experiment ([http://www.epa.gov/enviro/geospatial-data-download-service](http://www.epa.gov/enviro/geospatial-data-download-service)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the size of this XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s huge! Before we write programs, we need to understand a little bit about
    the structure of this data to see what we want to do with it. It contains facility
    site locations with addresses. This seems to be the bulk of the data in here,
    so let''s try and parse it all out with a pure Python XML parser using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The code uses `etree` to parse the XML file via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we look up the header and facilities via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we output them into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We then time the execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite long, but let''s compare it using a different XML implementation—Python
    `lxml`. It''s a different library implemented using Cython, but it implements
    the same library as the previous pure Python XML parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply drop the replacement import into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The code stays the same, but the execution time is dramatically reduced (compile
    the Cython version by running `make` and the `cpyparse` binary is created from
    the same code with just a different import):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can really see the power of using native code when you make just a little
    effort. And to be finally assured that the code is the same, let''s `MD5` sum
    `xmlout.dat` that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see that the outputs are exactly the same just so we know that no
    funny business is going on. It's scary how much faster this can make your XML
    parsing; and if we calculate the speed increase rate, it is approximately 17.75
    times faster; but don't take my word for it; try running it yourself. My MacBook
    has a solid state disk and has a 4 GB RAM with a 2 GHz Core 2 Duo.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you will have seen the core of what's possible with Cython. In this
    chapter, we covered calling into C++ classes from Cython. You learned to wrap
    templates and even look at a more complex application demonstrating the usage
    of `gil` and `nogil`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Further Reading"), *Further Reading* is the
    final chapter and will review some final caveats and usages with Cython. I will
    show how you can use Cython with Python 3\. Finally, we will look at related projects
    and my opinions on their usages.'
  prefs: []
  type: TYPE_NORMAL
