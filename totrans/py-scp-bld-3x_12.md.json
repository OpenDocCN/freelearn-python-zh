["```py\nbl_info = {\n    \"name\": \"Textament\",\n    \"author\": \"Packt Man\",\n    \"version\": (1, 0),\n    \"blender\": (3, 00, 0),\n    \"description\": \"Load and connect node textures\",\n    \"location\": \"Node-Graph header\",\n    \"category\": \"Learning\"\n}\n```", "```py\nimport os\nimport bpy\nfrom bpy_extras.io_utils import ImportHelper\n```", "```py\nClass AddTextures(bpy.types.Operator, ImportHelper):\n    \"\"\"Load and connect material textures\"\"\"\n    bl_idname = \"texture.textament_load\"\n    bl_label = \"Load and connect textures\"\n    bl_description = \"Load and connect material textures\"\n```", "```py\n    directory: bpy.props.StringProperty()\n    files: bpy.props.CollectionProperty(\n                    name=\"File Path\",\n                    type=bpy.types.OperatorFileListElement,\n                   )\n```", "```py\n    filter_glob: bpy.props.StringProperty(\n                                    default=\"*.png; *.jpg\",\n                                    options={\"HIDDEN\"})\n```", "```py\n    @classmethod\n    def poll(cls, context):\n        ob = context.object\n        if not ob:\n            return False\n        mat = ob.active_material\n        if not ob:\n            return False\n        tree = mat.node_tree\n        if not tree:\n            return False\n        return tree.nodes.active\n```", "```py\n    def execute(self, context):\n        mat = context.object.active_material\n        target_node = mat.node_tree.nodes.active\n```", "```py\n>>> \"Base Color\".lower().replace(\" \", \"\")\n'basecolor'\n>>> \"baseColor\".lower().replace(\" \", \"\")\n'basecolor'\n```", "```py\n        match_rule = lambda x : x.lower().replace(\" \", \"\")\n```", "```py\nlambda arguments : expression\n```", "```py\ndef match_rule(x):\n    return x.lower().replace(\" \", \"\")\n```", "```py\n        input_names = target_node.inputs.keys()\n```", "```py\n        matching_names = {}\n        for f in self.files:\n            for inp in input_names:\n                if match_rule(inp) in match_rule(f.name):\n                    matching_names[inp] = f.name\n                    break\n```", "```py\n        for inp, fname in matching_names.items():\n            img_path = os.path.join(self.directory, fname)\n            img = bpy.data.images.load(img_path,\n                                       check_existing=True)\n```", "```py\n            if target_node.inputs[inp].type != \"RGBA\":\n                img.colorspace_settings.name = \"Non-Color\"\n```", "```py\n            tree = mat.node_tree\n            tex_img = tree.nodes.new(\"ShaderNodeTexImage\")\n            tex_img.image = img\n```", "```py\n            if inp != \"Normal\":\n                tree.links.new(tex_img.outputs[\"Color\"],\n                               target_node.inputs[inp])\n                continue\n            # normal map code follows\n```", "```py\n            normal_map = tree.nodes.new(\n                                      \"ShaderNodeNormalMap\"\n                                     )\n```", "```py\n            tree.links.new(normal_map.outputs[\"Normal\"],\n                           target_node.inputs[inp])\n```", "```py\n            tree.links.new(tex_img.outputs[\"Color\"],\n                           normal_map.inputs[\"Color\"])\n```", "```py\n        return {'FINISHED'}\n```", "```py\ndef shader_header_button(self, context):\n    self.layout.operator(AddTextures.bl_idname,\n                         icon=\"NODE_TEXTURE\",\n                         text=\"Load Textures\")\n```", "```py\n>>> [c for c in dir(bpy.types) if\n     \"header\" in c]\n['CLIP_HT_header', 'CONSOLE_HT_header', 'DOPESHEET_HT_header', 'FILEBROWSER_HT_header', 'GRAPH_HT_header', 'IMAGE_HT_header', 'IMAGE_HT_tool_header', 'INFO_HT_header', 'NLA_HT_header', 'NODE_HT_header', 'OUTLINER_HT_header', 'PROPERTIES_HT_header', 'SEQUENCER_HT_header', 'SEQUENCER_HT_tool_header', 'SPREADSHEET_HT_header', 'STATUSBAR_HT_header', 'TEXT_HT_header', 'USERPREF_HT_header', 'VIEW3D_HT_header', 'VIEW3D_HT_tool_header']\n```", "```py\ndef register():\n    bpy.utils.register_class(AddTextures)\n    bpy.types.NODE_HT_header.append(shader_header_button)\n```", "```py\ndef unregister():\n    bpy.types.NODE_HT_header.remove(shader_header_button)\n    bpy.utils.unregiser_class(AddTextures)\n```", "```py\n>>> node_tree = C.object.active_material.node_tree\n>>> node_tree.nodes['Image Texture'].dimensions\nVector((360.0, 410.0))\n```", "```py\n>>> node_tree = C.object.active_material.node_tree\n>>> node_tree.nodes['Image Texture'].width\n240.0\n```", "```py\nclass AddTextures(bpy.types.Operator, ImportHelper):\n    \"\"\"Load and connect material textures\"\"\"\n    bl_idname = \"texture.textament_load\"\n    bl_label = \"Load and connect textures\"\n    bl_description = \"Load and connect material textures\"\n    _spacing = 340.0\n```", "```py\n        sorted_inputs = [\n              i for i in input_names if i in matching_names\n             ]\n```", "```py\n        for i, inp in enumerate(sorted_inputs):\n            img_path = os.path.join(self.directory,\n                                    matching_names[inp])\n            img = bpy.data.images.load(img_path,\n                                       check_existing=True)\n            if target_node.inputs[inp].type != 'RGBA':\n                img.colorspace_settings.name = 'Non-Color'\n            img_node = mat.node_tree.nodes.new(\n                                      \"ShaderNodeTexImage\")\n            img_node.image = img\n```", "```py\n            img_node.location = target_node.location\n            img_node.location.x -= self._spacing\n```", "```py\n            img_node.location.y -= i * self._spacing\n```", "```py\n            normal_map = mat.node_tree.nodes.new(\n                                      \"ShaderNodeNormalMap\"\n                                     )\n            normal_map.location = img_node.location\n            img_node.location.x -= self._spacing / 2\n            normal_map.location.x += self._spacing / 2\n```", "```py\n            if inp == \"Base Color\":\n                mix = mat.node_tree.nodes.new(\n                                        \"ShaderNodeMixRGB\")\n```", "```py\n                mix.location = img_node.location\n                img_node.location.x -= self._spacing / 2\n                mix.location.x += self._spacing / 2\n```", "```py\n                mat.node_tree.links.new(\n                                 img_node.outputs[\"Color\"],\n                                 mix.inputs[\"Color1\"])\n```", "```py\n                img_node = mix\n            if inp != \"Normal\":\n                tree.links.new(tex_img.outputs[\"Color\"],\n                               target_node.inputs[inp])\n                continue\n```"]