["```py\nglobal_adjustment: float \n\ndef some_function(a: float, b: float, t: float) -> float: \n    return a+b*t+global_adjustment\n```", "```py\nfrom pathlib import Path \n\ndef write_file(some_path: Path) -> None: \n    result = \"Hello, world!\" \n    with some_path.open(’w’) as output_file: \n        output_file.write(result + \"\\n\")\n```", "```py\nfrom typing import TextIO \nifile: TextIO \nofile: TextIO \n\ndef open_files(iname: str, oname: str) -> None: \n    \"\"\"A bad idea...\"\"\" \n    global ifile, ofile \n    ifile = open(iname, \"r\") \n    ofile = open(oname, \"w\")\n```", "```py\ndef next_line_with(prefix: str) -> str | None: \n    \"\"\"Also a bad idea...\"\"\" \n    line = ifile.readline() \n    while (line is not None and not line.startswith(prefix)): \n        line = ifile.readline() \n    return line\n```", "```py\nfrom collections.abc import Callable \n\nclass Mersenne1: \n\n    def __init__( \n            self, \n            algorithm : Callable[[int], int] \n    ) -> None: \n        self.pow2 = algorithm \n\n    def __call__(self, arg: int) -> int: \n        return self.pow2(arg) - 1\n```", "```py\ndef shifty(b: int) -> int: \n    return 1 << b \n\ndef multy(b: int) -> int: \n    if b == 0: return 1 \n    return 2 * multy(b - 1) \n\ndef faster(b: int) -> int: \n    if b == 0: return 1 \n    if b % 2 == 1: return 2 * faster(b-1) \n    t = faster(b // 2) \n    return t * t\n```", "```py\nm1s = Mersenne1(shifty) \n\nm1m = Mersenne1(multy) \n\nm1f = Mersenne1(faster)\n```", "```py\n>>> m1s(17) \n131071 \n>>> m1f(89) \n618970019642690137449562111\n```", "```py\nfrom decimal import Decimal \n\ndef clean_decimal(text: str | None) -> Decimal | None: \n    if text is None: return None \n    return Decimal( \n        text.replace(\"$\", \"\").replace(\",\", \"\") \n    )\n```", "```py\ndef replace(text: str, a: str, b: str) -> str: \n    return text.replace(a, b)\n```", "```py\ndef remove(str: str, chars: str) -> str: \n    if chars: \n        return remove( \n            str.replace(chars[0], \"\"), \n            chars[1:] \n        ) \n    return str\n```", "```py\nfrom collections.abc import Callable \nfrom typing import TypeAlias \n\nExtractor: TypeAlias = Callable[[tuple[int, int, int, str]], int] \n\nred: Extractor = lambda color: color[0] \n\ngreen: Extractor = lambda color: color[1] \n\nblue: Extractor = lambda color: color[2]\n```", "```py\nfrom collections.abc import Callable \nfrom typing import TypeAlias \n\nRGB: TypeAlias = tuple[int, int, int, str] \n\nredt: Callable[[RGB], int] = lambda color: color[0]\n```", "```py\nfrom typing import NamedTuple \nclass Color(NamedTuple): \n    \"\"\"An RGB color.\"\"\" \n    red: int \n    green: int \n    blue: int \n    name: str\n```", "```py\n>>> list(x**2 for x in range(10)) == [x**2 for x in range(10)] \nTrue\n```", "```py\nfrom collections.abc import Iterator \n\ndef candidates() -> Iterator[int]: \n    for i in range(2, 1024): \n        yield m1f(i)\n```", "```py\n>>> c = candidates() \n>>> next(c) \n3 \n>>> next(c) \n7 \n>>> next(c) \n15 \n>>> next(c) \n31\n```", "```py\nfrom collections.abc import Iterator \n\ndef bunch_of_numbers() -> Iterator[int]: \n    for i in range(5): \n        yield from range(i)\n```", "```py\n>>> list(bunch_of_numbers()) \n[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]\n```", "```py\nfrom collections.abc import Iterator \nimport math \n\ndef pfactorsl(x: int) -> Iterator[int]: \n    if x % 2 == 0: \n        yield 2 \n        if x // 2 > 1: \n            yield from pfactorsl(x // 2) \n        return \n    for i in range(3, int(math.sqrt(x) + .5) + 1, 2): \n        if x % i == 0: \n            yield i \n            if x // i > 1: \n                yield from pfactorsl(x // i) \n            return \n    yield x\n```", "```py\n    for result in recursive_iter(args): \n        yield result\n    ```", "```py\n    yield from recursive_iter(args)\n    ```", "```py\n>>> pfactorsl(1560) \n<generator object pfactorsl at ...> \n\n>>> list(pfactorsl(1560)) \n[2, 2, 2, 3, 5, 13] \n\n>>> len(pfactorsl(1560)) \nTraceback (most recent call last): \n    File \"<stdin>\", line 1, in <module> \nTypeError: object of type ’generator’ has no len()\n```", "```py\n>>> result = pfactorsl(1560) \n>>> sum(result) \n27 \n\n>>> sum(result) \n0\n```", "```py\nimport itertools \nfrom typing import Any \nfrom collections.abc import Iterable \n\ndef limits(iterable: Iterable[Any]) -> Any: \n    max_tee, min_tee = itertools.tee(iterable, 2) \n    return max(max_tee), min(min_tee)\n```", "```py\ng_f_x = (g(f(x)) for x in some_iterable)\n```", "```py\ng_f_x = (g(y) for y in (f(x) for x in some_iterable))\n```", "```py\nf_x = (f(x) for x in some_iterable) \ng_f_x = (g(y) for y in f_x)\n```", "```py\nAnscombe’s quartet \nI II III IV \nx y x y x y x y \n10.0 8.04 10.0 9.14 10.0 7.46 8.0 6.58 \n8.0 6.95 8.0 8.14 8.0 6.77 8.0 5.76 \n13.0 7.58 13.0 8.74 13.0 12.74 8.0 7.71\n```", "```py\nimport csv \nfrom typing import TextIO \nfrom collections.abc import Iterator, Iterable \n\ndef row_iter(source: TextIO) -> Iterator[list[str]]: \n    return csv.reader(source, delimiter=\"\\t\")\n```", "```py\n>>> from pathlib import Path \n>>> source_path = Path(\"Anscombe.txt\") \n>>> with source_path.open() as source: \n...     print(list(row_iter(source)))\n```", "```py\n[[\"Anscombe’s quartet\"], \n [’I’, ’II’, ’III’, ’IV’], \n [’x’, ’y’, ’x’, ’y’, ’x’, ’y’, ’x’, ’y’],\n```", "```py\nfrom collections.abc import Iterator \n\ndef head_split_fixed( \n        row_iter: Iterator[list[str]] \n) -> Iterator[list[str]]: \n    title = next(row_iter) \n    assert (len(title) == 1 \n        and title[0] == \"Anscombe’s quartet\") \n    heading = next(row_iter) \n    assert (len(heading) == 4 \n        and heading == [’I’, ’II’, ’III’, ’IV’]) \n\n    columns = next(row_iter) \n    assert (len(columns) == 8 \n        and columns == [’x’,’y’, ’x’,’y’, ’x’,’y’, ’x’,’y’]) \n    return row_iter\n```", "```py\nfrom pathlib import Path \nfrom collections.abc import Iterator \n\ndef get_rows(path: Path) -> Iterator[list[str]]: \n    with path.open() as source: \n        yield from head_split_fixed(row_iter(source))\n```", "```py\n>>> range(10) \nrange(0, 10) \n\n>>> [range(10)] \n[range(0, 10)] \n\n>>> [x for x in range(10)] \n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \n\n>>> list(range(10)) \n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```", "```py\n>>> data = list(get_rows(Path(\"Anscombe.txt\"))) \n>>> data[0] \n[’10.0’, ’8.04’, ’10.0’, ’9.14’, ’10.0’, ’7.46’, ’8.0’, ’6.58’] \n>>> data[1] \n[’8.0’, ’6.95’, ’8.0’, ’8.14’, ’8.0’, ’6.77’, ’8.0’, ’5.76’] \n>>> data[-1] \n[’5.0’, ’5.68’, ’5.0’, ’4.74’, ’5.0’, ’5.73’, ’8.0’, ’6.89’]\n```", "```py\nfrom typing import cast, TypeVar \nfrom collections.abc import Iterator, Iterable \n\nSrcT = TypeVar(\"SrcT\") \n\ndef series( \n        n: int, \n        row_iter: Iterable[list[SrcT]] \n) -> Iterator[tuple[SrcT, SrcT]]: \n    for row in row_iter: \n        yield cast(tuple[SrcT, SrcT], tuple(row[n * 2: n * 2 + 2]))\n```", "```py\n>>> from pathlib import Path \n>>> source_path = Path(\"Anscombe.txt\") \n>>> with source_path.open() as source: \n...     data = tuple(head_split_fixed(row_iter(source))) \n>>> series_I = tuple(series(0, data)) \n>>> series_II = tuple(series(1, data)) \n>>> series_III = tuple(series(2, data)) \n>>> series_IV = tuple(series(3, data))\n```", "```py\n>>> series_I \n((’10.0’, ’8.04’), (’8.0’, ’6.95’), ... (’5.0’, ’5.68’))\n```", "```py\nGIMP Palette \nName: Small \nColumns: 3 \n# \n0 0 0 Black \n255 255 255 White \n238 32 77 Red \n28 172 120 Green \n31 117 254 Blue\n```", "```py\nfrom typing import NamedTuple \n\nclass Color(NamedTuple): \n    red: int \n    green: int \n    blue: int \n    name: str\n```", "```py\n>>> palette = [ \n...     Color(red=239, green=222, blue=205, name=’Almond’), \n...     Color(red=205, green=149, blue=117, name=’Antique Brass’), \n...     Color(red=253, green=217, blue=181, name=’Apricot’), \n...     Color(red=197, green=227, blue=132, name=’Yellow Green’), \n...     Color(red=255, green=174, blue=66, name=’Yellow Orange’) \n... ]\n```", "```py\n>>> name_map = dict((c.name, c) for c in palette)\n```", "```py\n>>> name_map[’Antique Brass’] \nColor(red=205, green=149, blue=117, name=’Antique Brass’) \n>>> name_map[’Yellow Orange’] \nColor(red=255, green=174, blue=66, name=’Yellow Orange’)\n```", "```py\nimport bisect \nfrom collections.abc import Mapping, Iterable \nfrom typing import Any \n\nclass StaticMapping(Mapping[str, Color]): \n    def __init__(self, \n            iterable: Iterable[tuple[str, Color]] \n    ) -> None: \n        self._data: tuple[tuple[str, Color], ...] = tuple(iterable) \n        self._keys: tuple[str, ...] = tuple(sorted(key for key, _ in self._data)) \n\n    def __getitem__(self, key: str) -> Color: \n        ix = bisect.bisect_left(self._keys, key) \n        if (ix != len(self._keys) and self._keys[ix] == key): \n            return self._data[ix][1] \n        raise ValueError(f\"{key!r} not found\") \n\n    def __iter__(self) -> Iterator[str]: \n        return iter(self._keys) \n\n    def __len__(self) -> int: \n        return len(self._keys)\n```", "```py\ndef some_function ... \n\ndef main(): \n    \"\"\" \n    >>> main() \n    some_function(2, 3, 5)=30 \n    some_function(2, 3, 5)=34 \n    \"\"\" \n    global global_adjustment \n    global_adjustment = 13 \n    print(f\"{some_function(2, 3, 5)=}\") \n    global_adjustment = 17 \n    print(f\"{some_function(2, 3, 5)=}\") \n\n    if __name__ == \"__main__\": \n        main()\n```", "```py\n\n>>> class ShiftyMersenne(Mersenne2): \n...     pow2 = staticmethod(shifty) \n\n>>> m2s = ShiftyMersenne() \n>>> m2s(17) \n131071\n```"]