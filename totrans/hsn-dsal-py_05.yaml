- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Stacks and Queues
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和队列
- en: 'In this chapter, we will discuss two very important data structures: stacks
    and queues. Stacks and queues have many important applications, such as form operating
    system architecture, arithmetic expression evaluation, load balancing, managing
    printing jobs, and traversing data. In stack and queue data structures, the data
    is stored sequentially, like arrays and linked lists, but unlike arrays and linked
    lists, the data is handled in a specific order with certain constraints, which
    we will be discussing in detail in this chapter. Moreover, we will also examine
    how we can implement stacks and queues using linked lists and arrays.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两个非常重要的数据结构：栈和队列。栈和队列有许多重要的应用，例如在操作系统架构、算术表达式评估、负载均衡、管理打印作业和遍历数据等方面。在栈和队列数据结构中，数据是按顺序存储的，就像数组和链表一样，但与数组和链表不同的是，数据是按照特定的顺序和某些约束来处理的，我们将在本章中详细讨论这些内容。此外，我们还将探讨如何使用链表和数组来实现栈和队列。
- en: In this chapter, we will discuss constraints and methods to handle the data
    in stacks and queues. We will also implement these data structures and learn how
    to apply different operations to these data structures in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论处理栈和队列中数据的约束和方法。我们还将实现这些数据结构，并学习如何在Python中应用不同的操作到这些数据结构中。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: How to implement stacks and queues using various methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用各种方法实现栈和队列
- en: Some real-life example applications of stacks and queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列的一些实际应用示例
- en: Stacks
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is a data structure that stores data, similar to a stack of plates in
    a kitchen. You can put a plate on the top of the stack, and when you need a plate,
    you take it from the top of the stack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种存储数据的数据结构，类似于厨房中盘子堆叠。你可以在栈顶放一个盘子，当你需要盘子时，就从栈顶取出来。
- en: 'The last plate that was added to the stack will be the first to be picked up
    from the stack:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后添加到栈中的盘子将是第一个从栈中取出的：
- en: '![](img/B17217_05_01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_01.png)'
- en: 'Figure 5.1: Example of a stack'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：栈的示例
- en: The preceding diagram depicts a stack of plates. Adding a plate to the pile
    is only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示描述了一个盘子堆。向盘子堆中添加盘子只能通过将盘子放在堆顶来实现。从盘子堆中移除盘子意味着移除堆顶的盘子。
- en: 'A stack is a data structure that stores the data in a specific order similar
    to arrays and linked lists, with several constraints:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种数据结构，它以类似于数组和链表的方式存储数据，但有一些约束：
- en: Data elements in a stack can only be inserted at the end (`push` operation)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈中的数据元素只能从末尾插入（`push`操作）
- en: Data elements in a stack can only be deleted from the end (`pop` operation)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈中的数据元素只能从末尾删除（`pop`操作）
- en: Only the last data element can be read from the stack (`peek` operation)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能从栈中读取最后一个数据元素（`peek`操作）
- en: A stack data structure allows us to store and read data from one end, and the
    element which is added last is picked up first. Thus, a stack is a **last in first
    out** (**LIFO)** structure, or **last in last out** (**LILO**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 栈数据结构允许我们从一端存储和读取数据，最后添加的元素先被取出。因此，栈是一种**后进先出**（**LIFO**）结构，或者**后进后出**（**LILO**）。
- en: 'There are two primary operations performed on stacks – `push` and `pop`. When
    an element is added to the top of the stack, it is called a `push` operation,
    and when an element is to be picked up (that is, removed) from the top of the
    stack, it is called a `pop` operation. Another operation is `peek`, in which the
    top element of the stack can be viewed without removing it from the stack. All
    the operations in the stack are performed through a pointer, which is generally
    named `top`. All these operations are shown in *Figure 5.2*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上有两种主要操作——`push`（入栈）和`pop`（出栈）。当一个元素被添加到栈顶时，这被称为`push`操作，而当需要从栈顶取出（即移除）一个元素时，这被称为`pop`操作。另一个操作是`peek`，在这个操作中，可以查看栈顶的元素而不从栈中移除它。栈上的所有操作都是通过一个指针来完成的，这个指针通常被称为`top`。所有这些操作都在*图5.2*中展示：
- en: '![](img/B17217_05_02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_02.png)'
- en: 'Figure 5.2: Demonstration of push and pop operations in a stack'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：栈中push和pop操作的演示
- en: 'The following table demonstrates the use of two important stack operations
    (`push` and `pop`) in the stack:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了在栈中使用两个重要的栈操作（`push`和`pop`）的示例：
- en: '| **Stack operation** | **Size** | **Contents** | **Operation results** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **栈操作** | **大小** | **内容** | **操作结果** |'
- en: '| `stack()` | 0 | `[]` | Stack object created, which is empty. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `stack()` | 0 | `[]` | 创建了一个空的栈对象。|'
- en: '| `push "egg"` | 1 | `[''egg'']` | One item `egg` is added to the stack. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `push "egg"` | 1 | `[''egg'']` | 向栈中添加了一个项`egg`。|'
- en: '| `push "ham"` | 2 | `[''egg'', ''ham'']` | One more item, `ham`, is added
    to the stack. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `push "ham"` | 2 | `[''egg'', ''ham'']` | 向栈中添加了一个额外的项`ham`。|'
- en: '| `peek()` | 2 | `[''egg'', ''ham'']` | The top element, `ham`, is returned.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `peek()` | 2 | `[''egg'', ''ham'']` | 返回了栈顶元素`ham`。|'
- en: '| `pop()` | 1 | `[''egg'']` | The `ham` item is popped off and returned. (This
    item was added last, so it is removed first.) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 1 | `[''egg'']` | 弹出了`ham`项并返回。（这个项是最后添加的，所以它首先被移除。）|'
- en: '| `pop()` | 0 | `[]` | The `egg` item is popped off and returned. (This is
    the first item added, so it is returned last.) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 0 | `[]` | 弹出了`egg`项并返回。（这是第一个添加的项，所以它最后被返回。）|'
- en: 'Table 5.1: Illustration of different operations in a stack with examples'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：不同操作在栈中的示例
- en: 'Stacks are used for a number of things. One common usage for stacks is to keep
    track of the return address during function calls. Let’s imagine that we have
    the following program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 栈被用于许多事情。栈的一个常见用途是在函数调用期间跟踪返回地址。让我们想象我们有一个以下程序：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the program execution gets to the call to `a()`, a sequence of events
    will be followed in order to complete the execution of this program. A visualization
    of all these steps is shown in *Figure 5.3*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行到达对`a()`的调用时，将按照顺序执行一系列事件以完成此程序的执行。所有这些步骤的可视化显示在*图 5.3*中：
- en: '![](img/B17217_05_03.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_03.png)'
- en: 'Figure 5.3: Steps for a sequence of events during function calls in our sample
    program'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：在示例程序中函数调用期间的事件序列步骤
- en: 'The sequence of events is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列如下：
- en: First, the address of the current instruction is pushed onto the stack, and
    then execution jumps to the definition of `a`
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，当前指令的地址被推入栈中，然后执行跳转到`a`的定义。
- en: Inside function `a()`, function `b()` is called
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数`a()`内部，调用了函数`b()`
- en: The return address of function `b()` is pushed onto the stack. Once the execution
    of the instructions and functions in `b()` are complete, the return address is
    popped off the stack, which takes us back to function `a()`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`b()`的返回地址被推入栈中。一旦`b()`中的指令和函数的执行完成，返回地址就会被从栈中弹出，这会带我们回到函数`a()`。
- en: When all the instructions in function `a()` are completed, the return address
    is again popped off the stack, which takes us back to the main program and the
    `print` statement
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数`a()`中的所有指令都完成后，返回地址再次从栈中弹出，这会带我们回到主程序和`print`语句。
- en: 'The output of the above program is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序输出如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have now discussed the concept of the stack data structure. Now, let us understand
    its implementation in Python using array and linked list data structures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了栈数据结构的概念。现在，让我们了解其在 Python 中使用数组和链表数据结构的实现。
- en: Stack implementation using arrays
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组实现的栈
- en: Stacks store data in sequential order like arrays and linked lists, with a specific
    constraint that the data can only be stored and read from one end of the stack
    following the **last in first out** (**LIFO**) principle. In general, stacks can
    be implemented using arrays and linked lists. Array-based implementations will
    have fixed lengths for the stack, whereas linked list-based implementations can
    have stacks of variable lengths.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 栈像数组和链表一样按顺序存储数据，但有一个特定的约束，即数据只能按照**后进先出**（**LIFO**）原则从栈的一端存储和读取。通常，栈可以使用数组和链表实现。基于数组的实现将具有固定长度的栈，而基于链表的实现可以具有可变长度的栈。
- en: In the case of the array-based implementation of a stack (where the stack has
    a fixed size), it is important to check whether the stack is full or not, since
    trying to push an element into a full stack will generate an error, called an
    overflow. Likewise, trying to apply a `pop` operation to an empty stack causes
    an error known as an underflow.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的栈实现中（其中栈具有固定大小），检查栈是否已满非常重要，因为尝试将元素推入一个满栈将生成一个错误，称为溢出。同样，尝试对一个空栈应用`pop`操作会导致一个称为下溢的错误。
- en: 'Let us understand the implementation of a stack using an array with an example
    in which we wish to push three data elements, “egg”, “ham”, and “spam”, into the
    stack. Firstly, to insert new elements into a stack using the `push` operation,
    we check the overflow condition, which is when the `top` pointer is pointing to
    the end index of the array. The `top` pointer is the index position of the top
    element in the stack. If the top element is equal to the overflow condition, the
    new element cannot be added. This is a stack overflow condition. If there is free
    space in the array to insert new elements, new data is pushed into the stack.
    An overview of the `push` operation on a stack using an array is shown in *Figure
    5.4*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解使用数组实现的栈的实现，我们希望将三个数据元素“egg”、“ham”和“spam”推入栈中。首先，为了使用 `push` 操作将新元素插入到栈中，我们检查溢出条件，即当
    `top` 指针指向数组的末尾索引时。`top` 指针是栈中顶部元素的索引位置。如果顶部元素等于溢出条件，则无法添加新元素。这是栈溢出条件。如果数组中有空间插入新元素，则新数据被推入栈中。使用数组在栈上执行
    `push` 操作的概述如图 *5.4* 所示：
- en: '![](img/B17217_05_04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_04.png)'
- en: 'Figure 5.4: Sequence of push operations in a stack implementation using an
    array'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：使用数组实现的栈的 push 操作序列
- en: 'The Python code for the `push` operation is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 操作的 Python 代码如下：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the above code, we initialize the stack with a fixed size (say, 3 in this
    example), and also the `top` pointer to –1, which indicates that the stack is
    empty. Further, in the push method, the `top` pointer is compared with the size
    of the stack to check the overflow condition and, if the stack is full, the stack
    overflow message is printed. If the stack is not full, the top pointer is incremented
    by 1, and the new data element is added to the top of the stack. The following
    code is used to insert data elements into the stack:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用固定大小（例如，在这个例子中为 3）初始化栈，并将 `top` 指针设置为 –1，这表示栈为空。进一步地，在 `push` 方法中，将
    `top` 指针与栈的大小进行比较以检查溢出条件，如果栈已满，则打印出栈溢出消息。如果没有满，则将 `top` 指针增加 1，并将新数据元素添加到栈顶。以下代码用于将数据元素插入到栈中：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above code, when we try to insert the first three elements, they are
    added since there was enough space, but when we try to add the data elements `new`
    and `new2`, the stack is already full, hence these two elements cannot be added
    to the stack. The output of this code is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当我们尝试插入前三个元素时，由于有足够的空间，它们被添加进去了，但是当我们尝试添加数据元素 `new` 和 `new2` 时，栈已经满了，因此这两个元素不能添加到栈中。此代码的输出如下：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, the `pop` operation returns the value of the top element of the stack
    and removes it from the stack. Firstly, we check if the stack is empty or not.
    If the stack is already empty, a stack underflow message is printed. Otherwise,
    the top is removed from the stack. An overview of the `pop` operation is shown
    in *Figure 5.5*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`pop` 操作返回栈顶部元素的值并将其从栈中移除。首先，我们检查栈是否为空。如果栈已经为空，则打印出栈下溢消息。否则，从栈中移除 `top`。`pop`
    操作的概述如图 *5.5* 所示：
- en: '![](img/B17217_05_05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_05.png)'
- en: 'Figure 5.5: Sequence of the pop operation in a stack implementation using an
    array'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：使用数组实现的栈的 pop 操作序列
- en: 'The Python code for the `pop` operation is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 操作的 Python 代码如下：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above code, we first check the underflow condition by checking whether
    the stack is empty or not. If the `top` pointer has a value of –1, it means the
    stack is empty. Otherwise, the data elements in the stack are removed by decrementing
    the `top` pointer by 1, and the top data element is returned to the main function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先通过检查栈是否为空来检查下溢条件。如果 `top` 指针的值为 –1，则表示栈为空。否则，通过将 `top` 指针减 1 来移除栈中的数据元素，并将顶部数据元素返回到主函数。
- en: 'Let’s assume we already added three data elements to the stack, and then we
    call the `pop` function four times. Since there are only three elements in the
    stack, the initial three data elements are removed, and when we try to call the
    `pop` operation a fourth time, the stack underflow message is printed. This is
    shown in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已将三个数据元素添加到栈中，然后我们调用 `pop` 函数四次。由于栈中只有三个元素，最初的数据元素被移除，当我们尝试第四次调用 `pop` 操作时，会打印出栈下溢消息。这如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the above code is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let us see an implementation of the `peek` operation in which we return
    the value of the top element of the stack. The Python code for this is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`peek`操作的实现，其中我们返回栈顶元素的价值。此Python代码如下：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the above code, firstly, we check the position of the `top` pointer in the
    stack. If the value of the `top` pointer is –1, it means that the stack is empty,
    otherwise, we print the value of the top element of the stack.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先，我们检查栈中`top`指针的位置。如果`top`指针的值为-1，则表示栈为空，否则，我们打印栈顶元素的价值。
- en: We have discussed the Python implementation of a stack using an array, so next
    let us discuss stack implementation using linked lists.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用数组实现的Python栈，接下来让我们讨论使用链表实现的栈。
- en: Stack implementation using linked lists
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表实现的栈
- en: 'In order to implement the stacks using linked lists, we will write the `Stack`
    class in which all the methods will be declared; however, we will also use the
    `node` class similar to what we discussed in the previous chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用链表实现栈，我们将编写一个`Stack`类，其中将声明所有方法；然而，我们还将使用与上一章中讨论的类似的`node`类：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we know, a `node` in a linked list holds data and a reference to the next
    item in the linked list. Implementing the stack data structure using a linked
    list can be treated as a standard linked list with some constraints, including
    that elements can be added or removed from the end of the list (`push` and `pop`
    operations) through the `top` pointer. This is shown in *Figure 5.6*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，链表中的一个`node`包含数据和指向链表中下一个元素的引用。使用链表实现栈数据结构可以被视为具有一些约束的标准链表，包括可以通过`top`指针从列表的末尾添加或删除元素（`push`和`pop`操作）。这如图*5.6*所示：
- en: '![](img/B17217_05_06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_06.png)'
- en: 'Figure 5.6: Representation of the stack using a linked list'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：使用链表表示的栈
- en: 'Now let us look at the `stack` class. Its implementation is quite similar to
    a singly linked list. In addition, we need two things to implement a stack:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`stack`类。它的实现与单链表非常相似。此外，为了实现栈，我们还需要两样东西：
- en: We first need to know which node is at the top of the stack so that we can apply
    the `push` and `pop` operations through this node
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要知道哪个节点位于栈顶，这样我们就可以通过此节点应用`push`和`pop`操作
- en: We would also like to keep track of the number of nodes in the stack, so we
    add a `size` variable to the `Stack` class
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望跟踪栈中节点的数量，因此我们在`Stack`类中添加一个`size`变量
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the above code, we have declared the `top` and `size` variables, which are
    initialized to `None` and `0`. Once we have initialized the `Stack` class, next,
    we will implement different operations in the `Stack` class. First, let us start
    with a discussion of the `push` operation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已声明`top`和`size`变量，它们被初始化为`None`和`0`。一旦初始化了`Stack`类，接下来，我们将在`Stack`类中实现不同的操作。首先，让我们从讨论`push`操作开始。
- en: Push operation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推入操作
- en: The `push` operation is an important operation on a stack; it is used to add
    an element at the top of the stack. In order to add a new node to the stack, firstly,
    we check if the stack already has some items in it or if it is empty. We are not
    required here to check the overflow condition because we are not required to fix
    the length of the stack, unlike the stack implementation using arrays.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`操作是栈上的一个重要操作；它用于在栈顶添加一个元素。在此处，我们不需要检查溢出条件，因为我们不需要固定栈的长度，这与使用数组实现的栈不同。'
- en: 'If the stack already has some elements, then we have to do two things:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈已经有一些元素，那么我们必须做两件事：
- en: The new node must have its next pointer pointing to the node that was at the
    top earlier
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新节点必须将其下一个指针指向之前位于顶部的节点
- en: We put this new node at the top of the stack by pointing `self.top` to the newly
    added node
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将`self.top`指向新添加的节点，将这个新节点放在栈顶
- en: 'See the two instructions in the following *Figure 5.7*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下*图5.7*中的两个说明：
- en: '![](img/B17217_05_07.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_07.png)'
- en: 'Figure 5.7: Workings of the push operation on the stack'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：栈上推入操作的工作原理
- en: 'If the existing stack is empty, and the new node to be added is the first element,
    we need to make this node the top node of the element. Thus, `self.top` will point
    to this new node. See the following *Figure 5.8*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的栈为空，并且要添加的新节点是第一个元素，我们需要将此节点作为元素的顶部节点。因此，`self.top`将指向这个新节点。请参阅以下*图5.8*：
- en: '![](img/B17217_05_08.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_08.png)'
- en: 'Figure 5.8: Insertion of the data element “egg” into an empty stack'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：将数据元素“鸡蛋”插入空栈
- en: 'The following is the complete implementation of the `push` operation, which
    should be defined in the `Stack` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Stack`类中定义的`push`操作的完整实现：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above code, we create a new node and store the data in that. Then we
    check the position of the `top` pointer. If it is not null, that means the stack
    is not empty, and we add the new node, updating two pointers as shown in *Figure
    5.7*. In the `else` part, we make the `top` pointer point to the new node. Finally,
    we increase the size of the stack by incrementing the `self.size` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个新的节点并将数据存储在其中。然后我们检查`top`指针的位置。如果它不是null，这意味着栈不为空，我们可以添加新的节点，并更新两个指针，如图*图5.7*所示。在`else`部分，我们将`top`指针指向新的节点。最后，我们通过增加`self.size`变量的值来增加栈的大小。
- en: 'To create a stack of three data elements, we use the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含三个数据元素的栈，我们使用以下代码：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the above code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the above code, we created a stack of three elements – egg, ham, and spam.
    Next, we will discuss the `pop` operation in stack data structures.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个包含三个元素（鸡蛋、火腿和香肠）的栈。接下来，我们将讨论栈数据结构中的`pop`操作。
- en: Pop operation
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出操作
- en: Another important operation that is applied to the stack is the `pop` operation.
    In this operation, the topmost element of the stack is read, and then removed
    from the stack. The `pop` method returns the topmost element of the stack and
    returns `None` if the stack is empty.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到栈上的另一个重要操作是`pop`操作。在这个操作中，读取栈顶元素，然后从栈中移除。`pop`方法返回栈顶元素，如果栈为空则返回`None`。
- en: 'To implement the `pop` operation on a stack, we do following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在栈上实现`pop`操作，我们执行以下操作：
- en: First, check if the stack is empty. The `pop` operation is not allowed on an
    empty stack.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查栈是否为空。在空栈上不允许执行`pop`操作。
- en: 'If the stack is not empty, check whether the top node has its next attribute
    pointing to some other node. If so, it means the stack contains elements, and
    the topmost node is pointing to the next node in the stack. To apply the `pop`
    operation, we have to change the top pointer. The next node should be at the top.
    We do this by pointing `self.top` to `self.top.next`. See the following *Figure
    5.9* to understand this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈不为空，检查栈顶节点是否有其`next`属性指向其他节点。如果是这样，这意味着栈包含元素，栈顶节点指向栈中的下一个节点。要应用`pop`操作，我们必须更改栈顶指针。下一个节点应该位于栈顶。我们通过将`self.top`指向`self.top.next`来实现这一点。请参阅以下*图5.9*以了解这一点：
- en: '![](img/B17217_05_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_09.png)'
- en: 'Figure 5.9: Workings of the pop operation on the stack'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：栈上弹出操作的工作原理
- en: 'When there is only one node in the stack, the stack will be empty after the
    `pop` operation. We have to change the top pointer to `None`. See the following
    *Figure 5.10*:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当栈中只有一个节点时，`pop`操作后栈将为空。我们必须将栈顶指针更改为`None`。请参阅以下*图5.10*：
- en: '![Diagram, engineering drawing  Description automatically generated](img/B17217_05_10.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图，工程图纸，自动生成描述](img/B17217_05_10.png)'
- en: 'Figure 5.10: The pop operation on a stack with one element'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：只有一个元素的栈的弹出操作
- en: Removing this node results in `self.top` pointing to `None`, as shown in *Figure
    5.10*.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除此节点会导致`self.top`指向`None`，如图*图5.10*所示。
- en: We also decrement the size of the stack by `1` if the stack is not empty.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈不为空，我们也将栈的大小减少`1`。
- en: 'Here is the code for the `pop` operation for the stack in Python, which should
    be defined in the `Stack` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Python中栈的`pop`操作的代码，应该在`Stack`类中定义：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the above code, firstly, we check the position of the `top` pointer. If it
    is not null, it means the stack is not empty, and we can apply the `pop` operation
    such that if there is more than one data element in the stack, we move the `top`
    pointer to point to the next node (see *Figure 5.9*), and if that is the last
    node, we make the `top` pointer point to `None` (see *Figure 5.10*). We also decrease
    the size of the stack by decrementing the `self.size` variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先我们检查`top`指针的位置。如果它不是null，这意味着栈不为空，我们可以应用`pop`操作，如果栈中有多个数据元素，我们将`top`指针移动到指向下一个节点（参见*图5.9*），如果是最后一个节点，我们将`top`指针指向`None`（参见*图5.10*）。我们还通过减少`self.size`变量的值来减少栈的大小。
- en: 'Let’s say we have three data elements in a stack. We can use the following
    code to apply the `pop` operation to the stack:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在栈中有三个数据元素。我们可以使用以下代码对栈应用`pop`操作：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the above code is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the above code, we popped off the top element from the stack of three elements
    – `egg`, `ham`, `spam`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们从包含三个元素的栈中弹出顶部元素——`egg`、`ham`、`spam`。
- en: Next, we will discuss the `peek` operation used on stack data structures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在栈数据结构上使用的 `peek` 操作。
- en: Peek operation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看操作
- en: There is another important operation that can be applied to stacks—the `peek`
    method. This method returns the top element from the stack without deleting it
    from the stack. The only difference between `peek` and `pop` is that the `peek`
    method just returns the topmost element; however, in the case of a `pop` method,
    the topmost element is returned, and that element is also deleted from the stack.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 栈还有一个重要的操作可以应用——`peek` 方法。此方法返回栈顶元素，而不从栈中删除它。`peek` 和 `pop` 之间的唯一区别是 `peek`
    方法仅返回最顶层的元素；然而，在 `pop` 方法的情况下，返回最顶层的元素，并且该元素也被从栈中删除。
- en: 'The `peek` operation allows us to look at the top element without changing
    the stack. This operation is very straightforward. If there is a top element,
    return its data; otherwise, return `None` (thus, the behavior of `peek` matches
    that of `pop`). The implementation of the `peek` method is as follows (this should
    be defined in the `Stack` class):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek` 操作允许我们查看栈顶元素而不改变栈。这个操作非常简单。如果有栈顶元素，则返回其数据；否则，返回 `None`（因此，`peek` 的行为与
    `pop` 相匹配）。`peek` 方法的实现如下（这应该在 `Stack` 类中定义）：'
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the above code, we first check the position of the `top` pointer using `self.top`.
    If it is not null, this means the stack is not empty, and we return the data value
    of the topmost node, otherwise, we print the message that the stack is empty.
    We can use the `peek` method to get the top element of the stack through the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先使用 `self.top` 检查 `top` 指针的位置。如果它不是 `null`，这意味着栈不为空，我们返回最顶层节点的数据值；否则，我们打印出栈为空的消息。我们可以使用
    `peek` 方法通过以下代码获取栈的顶部元素：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the above code is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As per our original example of the three data elements being added to the stack,
    if we use the `peek` method, we get the top element, `spam`, as an output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们最初将三个数据元素添加到栈的示例，如果我们使用 `peek` 方法，我们将得到输出顶部元素，即 `spam`。
- en: 'Stacks are an important data structure with several real-world applications.
    To better understand the concept of the stack, we will discuss one of these applications:
    bracket matching utilizing stacks.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个重要的数据结构，具有多个实际应用。为了更好地理解栈的概念，我们将讨论这些应用之一：使用栈进行括号匹配。
- en: Applications of stacks
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈的应用
- en: As we know, array and linked list data structures can do whatever the stack
    or queue data structures (that we will discuss shortly) can do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，数组和链表数据结构可以执行栈或队列数据结构（我们将在稍后讨论）所能执行的所有操作。
- en: Despite this, these data structures are important because of their many applications.
    For example, in any application, it may be required to add or delete any element
    in a particular order. stack and queues can be used for this to avoid any potential
    bug in the program, perhaps accessing/deleting an element from the middle of the
    list (which can happen in the cases of arrays and linked lists).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些数据结构因其许多应用而变得重要。例如，在任何应用程序中，可能需要以特定顺序添加或删除任何元素。栈和队列可用于此，以避免程序中可能出现的任何潜在错误，例如从列表中间访问/删除元素（这可能在数组和链表的情况下发生）。
- en: Now let us look at an example bracket-matching application and see how we can
    use our stack to implement it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个示例括号匹配应用，并看看我们如何使用我们的栈来实现它。
- en: Let us write a function `check_brackets` that will verify whether a given expression
    containing brackets—`( )`, `[ ]`, or `{ }`— is balanced or not, that is, whether
    the number of closing brackets matches the number of opening brackets. Stacks
    can be used for traversing a list of items in reverse order since they follow
    the **LILO** rule, which makes them a good choice for this problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `check_brackets` 的函数，该函数将验证一个包含括号的给定表达式（即 `( )`、`[ ]` 或 `{ }`）是否平衡，也就是说，关闭括号的数量是否与打开括号的数量匹配。由于栈遵循
    **LILO** 规则，即后进先出，因此它们可以用来以相反的顺序遍历项目列表，这使得它们成为此问题的良好选择。
- en: 'The following code is for a separate `check_brackets` method defined outside
    the `Stack` class. This method will use the `Stack` class that we discussed in
    the previous section. The method takes an expression consisting of alphabetical
    characters and brackets as input and produces `True` or `False` as output for
    whether the given expression is valid or not, respectively. The code for the `check_brackets`
    method is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是为在`Stack`类外部定义的单独的`check_brackets`方法。此方法将使用我们在上一节中讨论的`Stack`类。该方法接受一个由字母字符和括号组成的表达式作为输入，并输出`True`或`False`，分别表示给定的表达式是否有效。`check_brackets`方法的代码如下：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The above function parses each character in the expression passed to it. If
    it gets an open bracket, it pushes it onto the stack. If it gets a closing bracket,
    it pops the top element off the stack and compares the two brackets to make sure
    their types match-`(` should match `)`, `[` should match `]`, and `{` should match
    `}`. If they don’t, we return `False`; otherwise, we continue parsing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数解析传递给它的表达式中的每个字符。如果它得到一个开括号，它将其推入栈中。如果它得到一个闭括号，它从栈中弹出顶部元素，并比较两个括号以确保它们的类型匹配——`(`应该匹配`)`，`[`应该匹配`]`，`{`应该匹配`}`。如果它们不匹配，我们返回`False`；否则，我们继续解析。
- en: Once we reach the end of the expression, we need to do one last check. If the
    stack is empty, then it is fine and we can return `True`. But if the stack is
    not empty, then we have an opening bracket that does not have a matching closing
    bracket and we will return `False`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达表达式的末尾，我们需要进行最后一次检查。如果栈为空，那么就没有问题，我们可以返回`True`。但如果栈不为空，那么我们有一个没有匹配闭括号的开括号，我们将返回`False`。
- en: 'We can test the bracket-matcher with the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码测试括号匹配器：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Only the first of the three statements should match. When we run the code,
    we get the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个语句中的第一个应该匹配。当我们运行代码时，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the above sample three expressions, we can see that the first expression
    is valid, while the other two are not valid expressions. Hence, the output of
    the preceding code is `True`, `False`, and `False`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述三个示例表达式中，我们可以看到第一个表达式是有效的，而其他两个不是有效的表达式。因此，前面代码的输出是`True`、`False`和`False`。
- en: In summary, the `push`, `pop`, and `peek` operations of the stack data structure
    have a time complexity of `O(1)` since the addition and deletion operations can
    be directly performed in constant time through the `top` pointer. The stack data
    structure is simple; however, it is used to implement many functionalities in
    real-world applications. For example, the back and forward buttons in web browsers
    are implemented using stacks. Stacks are also used to implement the undo and redo
    functionalities in word processors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，栈数据结构的`push`、`pop`和`peek`操作的时间复杂度为`O(1)`，因为通过`top`指针可以直接在常数时间内执行添加和删除操作。栈数据结构很简单；然而，它在现实世界的应用中用于实现许多功能。例如，网络浏览器的后退和前进按钮就是使用栈实现的。栈也被用于在文字处理器中实现撤销和重做功能。
- en: We have discussed the stack data structure and its implementations using arrays
    and linked lists. In the next section, we will discuss the queue data structure
    and the different operations that can be applied to queues.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了栈数据结构及其使用数组和链表实现的实现。在下一节中，我们将讨论队列数据结构以及可以应用于队列的不同操作。
- en: Queues
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Another important data structure is the queue, which is used to store data similarly
    to stacks and linked lists, with some constraints and in a specific order. The
    queue data structure is very similar to the regular queue you are accustomed to
    in real life. It is just like a line of people waiting to be served in sequential
    order at a shop. Queues are a fundamentally important concept to grasp since many
    other data structures are built on them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的数据结构是队列，它以类似于栈和链表的方式存储数据，但有一些约束和特定的顺序。队列数据结构非常类似于你在现实生活中习惯的常规队列。它就像在商店里按顺序排队等待服务的人群。队列是一个基本的重要概念，需要掌握，因为许多其他数据结构都是基于它们构建的。
- en: 'A queue works as follows. The first person to join the queue usually gets served
    first, and everyone will be served in the order in which they joined the queue.
    The acronym **FIFO** best explains the concept of a queue. **FIFO** stands for
    **first in, first out**. When people are standing in a queue waiting for their
    turn to be served, service is only rendered at the front of the queue. Therefore,
    people are dequeued from the front of the queue and enqueued from the back where
    they wait their turn. The only time people exit the queue is when they have been
    served, which only occurs at the very front of the queue. Refer to the following
    diagram, where people are standing in the queue, and the person at the front will
    be served first:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的工作原理如下。第一个加入队列的人通常会首先被服务，每个人都会按照他们加入队列的顺序被服务。缩写**FIFO**最能解释队列的概念。**FIFO**代表**先进先出**。当人们排队等待轮到他们被服务时，服务只在前端进行。因此，人们从队列的前端出队，从后端入队等待他们的轮次。人们退出队列的唯一时间是当他们被服务时，这只会发生在队列的最前端。请参考以下图表，其中人们正在排队，排在前面的人将首先被服务：
- en: '![](img/B17217_05_11.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_05_11.png)'
- en: 'Figure 5.11: Illustration of a queue'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：队列的示意图
- en: To join the queue, participants must stand behind the last person in the queue.
    This is the only legal or permitted way the queue accepts new entrants. The length
    of the queue does not matter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入队列，参与者必须站在队列中最后一个人的后面。这是队列接受新成员的唯一合法或允许的方式。队列的长度无关紧要。
- en: 'A queue is a list of elements stored in sequence with the following constraints:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一系列按顺序存储的数据元素，具有以下约束：
- en: Data elements can only be inserted from one end, the rear end/tail of the queue.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据元素只能从队列的一端，即队列的尾部/末尾插入。
- en: Data elements can only be deleted from the other end, the front/head of the
    queue.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据元素只能从队列的另一端，即队列的前端/头部删除。
- en: Only data elements from the front of the queue can be read.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只能从队列的前端读取数据元素。
- en: The operation to add an element to the queue is known as `enqueue`. Deleting
    an element from the queue uses the `dequeue` operation. Whenever an element is
    enqueued, the length or size of the queue increments by 1, and dequeuing an item
    reduces the number of elements in the queue by 1\.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '向队列中添加元素的操作称为`enqueue`。从队列中删除元素使用`dequeue`操作。每当一个元素被入队时，队列的长度或大小增加1，出队一个项目会减少队列中的元素数量1。 '
- en: 'We can see this concept in the doubly linked list shown in *Figure 5.12*, in
    which we can add new elements to the tail/rear end and elements can only be deleted
    from the head/front end of the queue:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图5.12*中看到这个概念，其中我们可以向尾部/末尾添加新元素，而元素只能从队列的头部/前端删除：
- en: '![](img/B17217_05_12.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_05_12.png)'
- en: 'Figure 5.12: Queue implementation using the stack data structure'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：使用栈数据结构实现的队列
- en: 'The reader is advised to not confuse the notation: the `enqueue` operation
    will be performed only at the **tail/rear** end and the `dequeue` operation will
    be performed from the **head/front** end. It should be fixed that one end will
    be used for `enqueue` operations and the other end will be used for `dequeue`
    operations; however, either end can be used for each of these operations. It is
    good in general practice to fix that we perform `enqueue` operations from the
    **rear** end and `dequeue` operations from the **front** end. To demonstrate these
    two operations, the following table shows the effects of adding and removing elements
    from a queue:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 读者请注意不要混淆符号：`enqueue`操作只会在**尾部/末尾**执行，而`dequeue`操作会从**头部/前端**执行。应该固定一个端点用于`enqueue`操作，另一个端点用于`dequeue`操作；然而，每个操作都可以使用任一端点。通常来说，固定我们从**尾部**执行`enqueue`操作，从**前端**执行`dequeue`操作是好的。为了演示这两个操作，以下表格显示了向队列中添加和删除元素的效果：
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **队列操作** | **大小** | **内容** | **操作结果** |'
- en: '| `queue()` | 0 | `[]` | Queue object created, which is empty. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `queue()` | 0 | `[]` | 创建了一个空的队列对象。 |'
- en: '| `enqueue- "packt"` | 1 | `[''packt'']` | One item, `packt`, is added to the
    queue. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `enqueue "packt"` | 1 | `[ ''packt'']` | 向队列中添加了一个项目，`packt`。 |'
- en: '| `enqueue "publishing"` | 2 | `[ ''packt'', ''publishing'']` | One more item,
    `publishing`, is added to the queue. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `enqueue "publishing"` | 2 | `[ ''packt'', ''publishing'']` | 向队列中添加了另一个项目，`publishing`。
    |'
- en: '| `Size()` | 2 | `[ ''packt'', ''publishing'']` | Return the number of items
    in the queue, which is 2 in this example. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `Size()` | 2 | `[ ''packt'', ''publishing'']` | 返回队列中的项目数量，在这个例子中是2。 |'
- en: '| `dequeue()` | 1 | `[''publishing'']` | The `packt` item is dequeued and returned.
    (This item was added first, so it is removed first.) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `dequeue()` | 1 | `[''publishing'']` | `packt`项目被出队并返回。（这个项目是首先添加的，因此它首先被移除。）|'
- en: '| `dequeue()` | 0 | `[]` | The `publishing` item is dequeued and returned.
    (This is the last item added, so it is returned last.) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `dequeue()` | 0 | `[]` | `publishing`项目被出队并返回。（这是最后添加的项目，因此最后返回。）|'
- en: 'Table 5.2: Illustration of different operations on an example queue'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：示例队列的不同操作的说明
- en: Queue data structures in Python have a built-in implementation, `queue.Queue`,
    and can also be implemented using the `deque` class from the `collections` module.
    Queue data structures can be implemented using various methods in Python, namely,
    (1) Python’s built-in list, (2) stacks, and (3) node-based linked lists. We will
    discuss them one by one in detail.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的队列数据结构有内置的实现，即`queue.Queue`，也可以使用`collections`模块中的`deque`类来实现。队列数据结构可以使用Python中的各种方法实现，即（1）Python的内置列表，（2）栈，以及（3）基于节点的链表。我们将逐一详细讨论它们。
- en: Python’s list-based queues
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的基于列表的队列
- en: 'Firstly, in order to implement a queue based on Python’s `list` data structure,
    we create a `ListQueue` class, in which we declare and define the different functionalities
    of queue. In this method, we store the actual data in Python’s `list` data structure.
    The `ListQueue` class is defined as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在Python的`list`数据结构上实现队列，我们创建一个`ListQueue`类，在其中声明和定义队列的不同功能。在这个方法中，我们使用Python的`list`数据结构存储实际数据。`ListQueue`类的定义如下：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `__init__` initialization method, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `4` (as an example in this code), which is the maximum capacity for
    the number of elements that can be stored in the queue. Moreover, the initial
    position of the rear and front indices are also set to `0`. `enqueue` and `dequeue`
    are important methods in queues, and we will discuss them next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`初始化方法中，`items`实例变量被设置为`[]`，这意味着创建队列时队列为空。队列的大小也被设置为`4`（作为此代码中的示例），这是队列中可以存储的元素数量的最大容量。此外，尾部和头部索引的初始位置也被设置为`0`。"enqueue"和"dequeue"是队列中的重要方法，我们将在下面讨论。
- en: The enqueue operation
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队操作
- en: The `enqueue` operation adds an item at the end of the queue. Consider the example
    of adding elements to the queue to understand the concept shown in *Figure 5.13*.
    We start with an empty list. Initially, we add an item `3` at index `0`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作在队列的末尾添加一个项目。考虑将元素添加到队列的示例，以理解*图5.13*中展示的概念。我们从一个空列表开始。最初，我们在索引`0`处添加一个项目`3`。
- en: 'Next, we add an item `11` at index `1`, and move the rear pointer every time
    we add an element:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在索引`1`处添加一个项目`11`，并且每次添加一个元素时都移动尾部指针：
- en: '![](img/B17217_05_13.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_13.png)'
- en: 'Figure 5.13: Example of an enqueue operation on the queue'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：队列上入队操作的示例
- en: 'In order to implement the enqueue operation, we use the `append` method of
    the `List` class to append items (or data) to the end of the queue. See the following
    code for the implementation of the `enqueue` method. This should be defined in
    the `ListQueue` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现入队操作，我们使用`List`类的`append`方法将项目（或数据）追加到队列的末尾。以下代码展示了`enqueue`方法的实现。这应该在`ListQueue`类中定义：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we first check whether the queue is full by comparing the maximum capacity
    of the queue with the position of the `rear` index. Further, if there is space
    in the queue, we use the `append` method of the `List` class to add the data at
    the end of the queue and increase the rear pointer by `1`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过比较队列的最大容量与`rear`索引的位置来检查队列是否已满。进一步地，如果有空间在队列中，我们使用`List`类的`append`方法将数据添加到队列的末尾，并将尾部指针增加`1`。
- en: 'To create a queue using the `ListQueue` class, we use the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ListQueue`类创建队列，我们使用以下代码：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the above code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the above code, we add can a maximum of three data elements since we have
    set the maximum capacity of the queue to be `3`. After adding three elements,
    when we try to add another new element, we get a message that the queue is full.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，由于我们将队列的最大容量设置为`3`，因此我们最多可以添加三个数据元素。当我们尝试添加另一个新元素时，我们得到一个消息，表明队列已满。
- en: The dequeue operation
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The `dequeue` operation is used to read and delete items from the queue. This
    method returns the front item from the queue and deletes it. Consider the example
    of dequeuing elements from the queue shown in *Figure 5.14*. Here, we have a queue
    containing elements `{3, 11, 7, 1, 4, 2}`. In order to dequeue any element from
    this queue, the element inserted first will be removed first, so the item `3`
    is removed. When we dequeue any element from the queue, we also decrease the `rear`
    pointer by 1:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作用于从队列中读取和删除项目。此方法从队列中返回并删除前一个项目。考虑图5.14中展示的从队列中删除元素示例。这里，我们有一个包含元素
    `{3, 11, 7, 1, 4, 2}` 的队列。为了从这个队列中删除任何元素，首先插入的元素将被移除，因此项目 `3` 被移除。当我们从队列中删除任何元素时，我们也会将`rear`指针减1：'
- en: '![](img/B17217_05_14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_05_14.png)'
- en: Figure 5.14\. Example of a dequeue operation on a queue
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14\. 队列上dequeue操作的示例
- en: 'The following is the implementation of the `dequeue` method, which should be
    defined in the `ListQueue` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`dequeue`方法的实现，该方法应在`ListQueue`类中定义：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the above code, we firstly check whether the queue is already empty by comparing
    the front and rear pointers. If both rear and front pointers are same, it means
    the queue is empty. If there are some elements in the queue, we use the `pop`
    method to dequeue an element. The Python `List` class has a method called `pop()`.
    The `pop` method does the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先通过比较`front`和`rear`指针来检查队列是否已经为空。如果`rear`和`front`指针相同，则表示队列为空。如果队列中有一些元素，我们使用`pop`方法来删除元素。Python的`List`类有一个名为`pop()`的方法。`pop`方法执行以下操作：
- en: Deletes the last item from the list
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中删除最后一个项目
- en: Returns the deleted item from the list back to the user or code that called
    it
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从列表中删除的项目返回给调用它的用户或代码
- en: The item at the first position pointed to by the front variable is popped and
    saved in the `data` variable. We also decrease the rear variable by `1`, since
    one data item has been deleted from the queue. Finally, in the last line of the
    method, the data is returned.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由`front`变量指向的第一个位置的项目被弹出并保存在`data`变量中。我们也将`rear`变量减`1`，因为队列中已经删除了一个数据项。最后，在方法的最后一行，返回数据。
- en: 'To dequeue any element from an existing queue (say items `{20, 30, 40}`), we
    use the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要从现有队列（例如项目 `{20, 30, 40}`）中删除任何元素，我们使用以下代码：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the above code is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the above code, when we dequeue an element from the queue, we get the element
    20, which was the first added.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当我们从队列中删除一个元素时，我们得到元素20，这是第一个添加的。
- en: The limitation of this approach to queue implementation is that the length of
    the queue is fixed, which may be not desirable for an efficient implementation
    of a queue. Now, let’s discuss the linked list-based implementation of queues.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在队列实现中的局限性是队列的长度是固定的，这可能不适合高效实现队列。现在，让我们讨论基于链表的队列实现。
- en: Linked list based queues
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于链表的队列
- en: A queue data structure can also be implemented using any linked list, such as
    singly-linked or doubly-linked lists. We already discussed the implementation
    of singly or doubly linked lists in the previous *Chapter 4*, *Linked Lists*.
    We implement queues using linked lists that follow the **FIFO** property of the
    queue data structure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构也可以使用任何链表实现，例如单链表或双链表。我们已经在上一章*第4章*，*链表*中讨论了单链表或双链表的实现。我们使用遵循队列数据结构**FIFO**属性的链表实现队列。
- en: 'Let us discuss the implementation of a queue using a doubly-linked list. For
    this, we start with the implementation of the `node` class the same as the `node`
    we defined when we discussed doubly-linked lists in the previous *Chapter 4*,
    *Linked Lists*. Moreover, the `Queue` class is very similar to that of the doubly-linked
    list class. Here, we have `head` and `tail` pointers, where `tail` points to the
    end of the queue (the rear end) that will be used for adding new elements, and
    the `head` pointer points to the start of the queue (the front end) that will
    be used for dequeuing the elements from the queue. The implementation of the `Queue`
    class is shown in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用双链表实现队列的实现。为此，我们首先实现`node`类，与我们在上一章*第4章*，*链表*中讨论双链表时定义的`node`类相同。此外，`Queue`类与双链表类非常相似。在这里，我们有`head`和`tail`指针，其中`tail`指向队列的末尾（后端），将用于添加新元素，而`head`指针指向队列的起始位置（前端），将用于从队列中删除元素。`Queue`类的实现如下所示：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Initially, the `self.head` and `self.tail` pointers are set to `None` upon creation
    of an instance of the `Queue` class. To keep a count of the number of nodes in
    `Queue`, the `count` instance variable is also maintained here and initially set
    to `0`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Queue` 类的实例时，`self.head` 和 `self.tail` 指针被设置为 `None`。为了保持 `Queue` 中节点数量的计数，这里还维护了一个
    `count` 实例变量，并初始设置为 `0`。
- en: The enqueue operation
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队操作
- en: Elements are added to a `Queue` object via the `enqueue` method. The data elements
    are added through nodes. The `enqueue` method code is very similar to the `append`
    operation of the doubly-linked list that we discussed in *Chapter 4,* *Linked
    Lists*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 元素通过 `enqueue` 方法添加到 `Queue` 对象中。数据元素通过节点添加。`enqueue` 方法的代码与我们讨论过的双向链表的 `append`
    操作非常相似，即在 *第 4 章*，*链表* 中讨论的。
- en: The enqueue operation creates a node from the data passed to it and appends
    it to the `tail` of the queue.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作从传递给它的数据创建一个节点并将其追加到队列的 `tail`。
- en: 'Firstly, we check if the new node to be enqueued is the first node, and whether
    the queue is empty or not. If it is empty, the new node becomes the first node
    of the queue, as shown in *Figure 5.15*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查要入队的新节点是否是第一个节点，以及队列是否为空。如果队列为空，新节点将成为队列的第一个节点，如图 *图 5.15* 所示：
- en: '![](img/B17217_05_15.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_15.png)'
- en: 'Figure 5.15: Illustration of enqueuing a new node in an empty queue'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：在空队列中入队新节点的示意图
- en: 'If the queue is not empty, the new node is appended to the rear end of the
    queue. In order to do this and enqueue an element to an existing queue, we append
    the node by updating three links: (1) the previous pointer of the new node should
    point to the tail of the queue, (2) the next pointer of the tail node should point
    to the new node, and (3) the tail pointer should be updated to the new node. All
    these links are shown in *Figure 5.16*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列不为空，新节点将被追加到队列的末尾。为了做到这一点并将元素入队到现有的队列中，我们通过更新三个链接来追加节点：（1）新节点的上一个指针应指向队列的尾部，（2）尾部节点的下一个指针应指向新节点，（3）尾部指针应更新为新节点。所有这些链接都在
    *图 5.16* 中显示：
- en: '![](img/B17217_05_16.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_16.png)'
- en: 'Figure 5.16: Illustration of links to be updated for an enqueue operation in
    a queue'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：队列中入队操作要更新的链接示意图
- en: 'The `enqueue` operation is implemented in the `Queue` class, as shown in the
    following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 操作在 `Queue` 类中实现，如下面的代码所示：'
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the above code, we first check whether the queue is empty or not. If `head`
    points to `None`, this means the queue is empty. If it is empty, the new node
    is made the first node of the queue, and we make both `self.head` and `self.tail`
    point to the newly created node. If the queue is not empty, we append the new
    node to the rear of the queue by updating the three links shown in *Figure 5.16*.
    Finally, the total count of elements in the queue is increased by the line `self.count
    += 1`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先检查队列是否为空。如果 `head` 指向 `None`，这意味着队列为空。如果为空，新节点将成为队列的第一个节点，我们将 `self.head`
    和 `self.tail` 都指向新创建的节点。如果队列不为空，我们通过更新 *图 5.16* 中显示的三个链接将新节点追加到队列的末尾。最后，通过 `self.count
    += 1` 行增加队列中元素的总数。
- en: The worst-case time complexity of an `enqueue` operation on the queue is `O(1)`,
    since any item can be appended directly through the `tail` pointer in constant
    time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 队列上 `enqueue` 操作的最坏情况时间复杂度是 `O(1)`，因为任何项目都可以通过 `tail` 指针在常数时间内直接追加。
- en: The dequeue operation
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The other operation that makes a doubly-linked list behave like a queue is
    the `dequeue` method. This method removes the node at the front of the queue,
    as shown in *Figure 5.17*. Here, we first check whether the dequeuing element
    is the last node in the queue, and if so, we will make the queue empty after the
    `dequeue` operation. If this is not the case, we dequeue the first element by
    updating the front/head pointer to the next node and the previous pointer of the
    new head to `None`, as shown in *Figure 5.17*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使双向链表表现得像队列的另一个操作是 `dequeue` 方法。此方法移除队列前面的节点，如图 *图 5.17* 所示。在这里，我们首先检查要出队的元素是否是队列中的最后一个节点，如果是，则在
    `dequeue` 操作后使队列变为空。如果不是这种情况，我们通过更新前/头指针到下一个节点和新头节点的上一个指针到 `None` 来出队第一个元素，如图
    *图 5.17* 所示：
- en: '![](img/B17217_05_17.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_17.png)'
- en: 'Figure 5.17: Illustration of the dequeue operation on a queue'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：队列上出队操作的示意图
- en: 'The implementation of the `dequeue` operation on a queue is very similar to
    deleting the first element from the given doubly-linked list, as the following
    code for the `dequeue` operation shows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列上实现`dequeue`操作与从给定的双向链表中删除第一个元素非常相似，如下面的`dequeue`操作代码所示：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In order to dequeue any element from the queue, we firstly check the number
    of items in the queue using the `self.count` variable. If the `self.count` variable
    is equal to `1`, it means the dequeuing element is the last element, and we update
    the head and tail pointers to `None`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从队列中出队任何元素，我们首先使用`self.count`变量检查队列中的项目数量。如果`self.count`变量等于`1`，则表示出队元素是最后一个元素，我们将头和尾指针更新为`None`。
- en: If the queue has many nodes, then the head pointer is shifted to point to the
    next node after `self.head` by updating the two links shown in *Figure 5.17*.
    We also check whether there is an item left in the queue, and if not, then a message
    is printed that the queue is empty. Finally, the `self.count` variable is decremented
    by `1`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列有很多节点，那么头指针将移动到指向`self.head`之后的下一个节点，通过更新图5.17中显示的两个链接来实现。我们还检查队列中是否还有项目，如果没有，则打印出队列已空的消息。最后，将`self.count`变量减`1`。
- en: The worst-case time complexity of a dequeue operation in the queue is `O(1)`,
    since any item can be directly removed via the `head` pointer in constant time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中`dequeue`操作的最坏情况时间复杂度是`O(1)`，因为任何项目都可以通过`head`指针在常数时间内直接移除。
- en: Stack-based queues
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于栈的队列
- en: 'A queue is a linear data structure in which enqueue operations are performed
    from one end and deletion (dequeue) operations are performed from the other end
    following the **FIFO** principle. There are two methods to implement queues using
    stacks:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种线性数据结构，其中入队操作在一端执行，而从另一端执行删除（出队）操作，遵循**FIFO**原则。使用栈实现队列有两种方法：
- en: When the dequeue operation is costly
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`dequeue`操作成本较高时
- en: When the enqueue operation is costly
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当入队操作成本较高时
- en: 'Approach 1: When the dequeue operation is costly'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法1：当`dequeue`操作成本较高时
- en: We use two stacks for the implementation of the queue. In this approach, the
    enqueue operation is straightforward. A new element can be enqueued in the queue
    using the push operation on the first of the two stacks (in other words, Stack-1)
    used for the implementation of the queue.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个栈来实现队列。在这个方法中，入队操作很简单。可以使用用于队列实现的两个栈中的第一个栈（换句话说，Stack-1）上的推操作将新元素入队。
- en: 'The enqueue operation is depicted in *Figure 5.18*, showing an example of enqueuing
    elements `{23, 13, 11}` to the queue:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作在图5.18中展示，展示了将元素`{23, 13, 11}`入队到队列中的示例：
- en: '![](img/B17217_05_18.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_18.png)'
- en: 'Figure 5.18: Illustration of an enqueue operation in the queue using approach
    1'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18：使用方法1在队列中执行入队操作的示意图
- en: 'Further more, the dequeue operation can be implemented with two stacks (Stack-1
    and Stack-2) using the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用两个栈（Stack-1和Stack-2）通过以下步骤实现`dequeue`操作：
- en: Firstly, the elements are removed (popped off) from Stack-1, and then one by
    one all the elements are added (pushed) to Stack-2.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从Stack-1中移除元素（弹出），然后逐个将这些元素添加（推入）到Stack-2。
- en: The topmost data element will be popped off Stack-2 and will be returned as
    the desired element.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最顶部的数据元素将从Stack-2弹出，并作为所需元素返回。
- en: Finally, the remaining elements are popped off Stack-2 one by one and then pushed
    again to Stack-1.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，剩余的元素逐个从Stack-2弹出，然后再次推入Stack-1。
- en: 'Let’s look at an example to help understand this concept. Let’s say we have
    three elements stored in the queue `{23, 13, 11}`, and now we want to dequeue
    an element from this queue. The complete process is shown in *Figure 5.19* following
    the above three steps. As you might notice, this implementation follows the **FIFO**
    property of queues and hence 23 is returned, as it was added first:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来帮助理解这个概念。假设我们在队列中存储了三个元素`{23, 13, 11}`，现在我们想要从这个队列中出队一个元素。整个过程如上图5.19所示，按照上述三个步骤进行。如您所注意到的，这个实现遵循队列的**FIFO**属性，因此返回了23，因为它是最先添加的：
- en: '![](img/B17217_05_19.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_19.png)'
- en: 'Figure 5.19: Illustration of a dequeue operation in the queue using approach
    1'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19：使用方法1在队列中执行`dequeue`操作的示意图
- en: The worst-case time complexity of enqueue operations is `O(1)`, since any element
    can be added directly to the first stack, and the time complexity of the dequeue
    operation is `O(n)`, since all elements are accessed and transferred from Stack-1
    to Stack-2.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作的 worst-case 时间复杂度是 `O(1)`，因为任何元素都可以直接添加到第一个栈中，而出队操作的时间复杂度是 `O(n)`，因为需要访问并从
    Stack-1 转移所有元素到 Stack-2。
- en: 'Approach 2: When the enqueue operation is costly'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法 2：当入队操作成本较高时
- en: In this method, the enqueue operation is quite similar to the dequeue operation
    of the previous approach we just discussed, and the dequeue operation is likewise
    similar to the previous enqueue operation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，入队操作与之前讨论的出队操作非常相似，而出队操作也与之前的入队操作类似。
- en: 'In order to implement the enqueue operation, we follow the steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现入队操作，我们遵循以下步骤：
- en: Move all the elements from Stack-1 to Stack-2.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有元素从 Stack-1 移动到 Stack-2。
- en: Push the element we want to enqueue to Stack-2.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们想要入队的元素推入 Stack-2。
- en: Move all the elements from Stack-2 to Stack-1 one by one. Pop the elements from
    Stack-2 and push them to Stack-1.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个将所有元素从 Stack-2 移动到 Stack-1。从 Stack-2 弹出元素并将它们推入 Stack-1。
- en: 'Let’s take an example to understand this concept. Let’s say we want to enqueue
    three elements `{23, 13, 11}` in the queue one by one. We do this by following
    the above three steps, as shown in *Figure 5.20*, *Figure 5.21*, and *Figure 5.22*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。假设我们想要依次将三个元素 `{23, 13, 11}` 入队到队列中。我们通过遵循上述三个步骤来完成此操作，如图 *5.20*、*5.21*
    和 *5.22* 所示：
- en: '![](img/B17217_05_20.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_20.png)'
- en: 'Figure 5.20: Enqueueing element 23 to an empty queue using approach 2'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：使用方法 2 将元素 23 入队到空队列中
- en: '![](img/B17217_05_21.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_21.png)'
- en: 'Figure 5.21: Enqueueing element 13 to the existing queue using approach 2'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：使用方法 2 将元素 13 入队到现有队列中
- en: '![](img/B17217_05_22.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_22.png)'
- en: 'Figure 5.22: Enqueueing element 11 to the queue using approach 2'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：使用方法 2 将元素 11 入队到队列中
- en: 'The dequeue operation can be directly implemented by applying a pop operation
    to Stack-1\. Let’s take an example to understand this. Assuming we have already
    enqueued three elements, and we want to apply the dequeue operation, we can simply
    pop the top element off the stack, as shown in *Figure 5.23*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 出队操作可以通过对 Stack-1 应用 pop 操作直接实现。让我们通过一个例子来理解这一点。假设我们已入队了三个元素，并想要执行出队操作，我们可以简单地从栈中弹出顶部元素，如图
    *5.23* 所示：
- en: '![](img/B17217_05_23.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_23.png)'
- en: 'Figure 5.23: Illustration of a dequeue operation on a queue using approach
    2'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：使用方法 2 在队列上执行出队操作的示意图
- en: In this second approach, the time complexity for the enqueue operation is `O(n)`,
    and for the dequeue operation, it is `O(1)`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二种方法中，入队操作的时间复杂度是 `O(n)`，而出队操作的时间复杂度是 `O(1)`。
- en: 'Next, we discuss the implementation of a queue using two stacks using approach-1,
    in which the dequeue operation is costly. In order to implement queues using two
    stacks, we initially set two stack instance variables to create an empty queue
    upon initialization. The stacks, in this case, are simply Python lists that allow
    us to call the `push` and `pop` methods on them, which allow us to get the functionality
    of the `enqueue` and `dequeue` operations. Here is the `Queue` class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论使用方法-1 实现使用两个栈的队列的实现，其中出队操作成本较高。为了使用两个栈实现队列，我们最初设置两个栈实例变量以在初始化时创建一个空队列。在这种情况下，栈只是允许我们调用其上的
    `push` 和 `pop` 方法的 Python 列表，这使我们能够获得 `enqueue` 和 `dequeue` 操作的功能。以下是一个 `Queue`
    类的实现：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Stack1` is only used to store elements that are added to the queue. No other
    operation can be performed on this stack.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack1` 仅用于存储添加到队列中的元素。在此栈上不能执行其他操作。'
- en: Enqueue operation
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` method is used to add items to the queue. This method only receives
    the `data` that is to be appended to the queue. This data is then passed to the
    `append` method of `Stack1` in the `Queue` class. Further, the `append` method
    is used to mimic the `push` operation, which pushes elements to the top of the
    stack. The following code is the implementation of `enqueue` using the stack in
    Python, which should be defined in the `Queue` class:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue` 方法用于向队列中添加项目。此方法仅接收要附加到队列的 `data`。然后，该数据被传递到 `Queue` 类中 `Stack1`
    的 `append` 方法。此外，`append` 方法用于模拟 `push` 操作，将元素推到栈顶。以下是在 Python 中使用栈实现 `enqueue`
    的代码，应在 `Queue` 类中定义：'
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To enqueue data onto `Stack1`, the following code does the job:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据入队到 `Stack1`，以下代码可以完成这项工作：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of `Stack1` on the queue is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中`Stack1`的输出如下：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we will examine the implementation of the `dequeue` operation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`dequeue`操作的实现。
- en: Dequeue operation
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出队操作
- en: The `dequeue` operation is used to delete the elements from the queue in the
    same order in which the items were added, according to the **FIFO** principle.
    New elements are added to the queue in `Stack1`. Further, we use another stack,
    that is, `Stack2`, to delete the elements from the queue. The delete (dequeue)
    operation will only be performed through `Stack2`. To better understand how `Stack2`
    can be used to delete the items from the queue, let us consider the following
    example.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作用于根据**FIFO**原则以添加元素的相同顺序从队列中删除元素。新元素添加到`Stack1`中。此外，我们使用另一个栈，即`Stack2`，从队列中删除元素。删除（出队）操作将通过`Stack2`执行。为了更好地理解如何使用`Stack2`从队列中删除项目，让我们考虑以下示例。'
- en: 'Initially, assume that `Stack2` was filled with the elements **5**, **6**,
    and **7**, as shown in *Figure 5.24*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最初`Stack2`被填充了元素**5**、**6**和**7**，如图*图5.24*所示：
- en: '![](img/B17217_05_24.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_24.png)'
- en: Figure 5.24\. Example of Stack1 in a queue
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24\. 队列中Stack1的示例
- en: 'Next, we check if the `Stack2` is empty or not. As it is empty at the start,
    we move all the elements delete from `Stack1` to `Stack2` using the `pop` operation
    on `Stack1` for all the element and then push them to `Stack2`. Now, `Stack1`
    becomes empty and `Stack2` has all the elements. We show this in *Figure 5.25*
    for more clarity:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`Stack2`是否为空。由于它一开始是空的，我们使用`Stack1`上的`pop`操作将所有元素从`Stack1`删除并推送到`Stack2`。现在，`Stack1`为空，而`Stack2`包含所有元素。我们通过*图5.25*展示这一点以获得更清晰的了解：
- en: '![](img/B17217_05_25.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_05_25.png)'
- en: Figure 5.25\. Demonstration of Stack1 and Stack2 in a queue
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25\. 队列中Stack1和Stack2的演示
- en: Now, if the `Stack` is not empty, in order to pop an element from this queue,
    we apply the `pop` operation to `Stack2`, and we get the element `5`, which is
    correct as it was added first and should be the first element to be popped off
    from the queue.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`Stack`不为空，为了从这个队列中弹出元素，我们对`Stack2`应用`pop`操作，并得到元素`5`，这是正确的，因为它是最先添加的，应该是第一个从队列中弹出的元素。
- en: 'Here is the implementation of the `dequeue` method for the queue, which should
    be defined in the `Queue` class:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是队列的`dequeue`方法的实现，它应该在`Queue`类中定义：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `if` statement first checks whether `Stack2` is empty. If it is not empty,
    we proceed to remove the element at the front of the queue using the `pop` method,
    as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句首先检查`Stack2`是否为空。如果不为空，我们继续使用`pop`方法移除队列前端的元素，如下所示：'
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If `Stack2` is empty, all the elements of `Stack1` are moved to `Stack2`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Stack2`为空，则将`Stack1`的所有元素移动到`Stack2`：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `while` loop will continue to be executed as long as there are elements
    in `Stack1`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环将继续执行，直到`Stack1`中有元素为止。'
- en: The `self.Stack1.pop()` statement will remove the last element added to `Stack1`
    and immediately pass the popped data to the `self.Stack2.append()` method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.Stack1.pop()`语句将移除添加到`Stack1`中的最后一个元素，并将其立即传递给`self.Stack2.append()`方法。'
- en: 'Let us consider some example code to understand the operations on the queue.
    We firstly use the `Queue` implementation to add three items to the queue, that
    is, `5`, `6`, and `7`. Next, we apply `dequeue` operations to remove items from
    the queue using the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些示例代码来理解队列上的操作。我们首先使用`Queue`实现将三个项目添加到队列中，即`5`、`6`和`7`。然后，我们应用`dequeue`操作来使用以下代码从队列中删除项目：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The enqueue and dequeue operations on the queue data structure using a stack
    with approach 1 have time complexities of `O(1)`, and `O(n)` respectively. The
    reason for this is that the enqueue operation is straightforward as a new element
    can be appended directly, whereas in the dequeue operation, all the n elements
    need to be accessed and moved to the other stack.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方法1的栈对队列数据结构进行入队和出队操作时，时间复杂度分别为`O(1)`和`O(n)`。这是因为入队操作很简单，因为可以直接添加新元素，而在出队操作中，需要访问并移动所有n个元素到另一个栈中。
- en: Overall, the linked list-based implementation is the most efficient since both
    the enqueue and dequeue operations can be performed in `O(1)` time and there is
    no constraint on the size of the queue. In the stack-based implementation of queues,
    one of the operations is costly, be it enqueue or dequeue.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，基于链表的实现是最有效的，因为入队和出队操作都可以在`O(1)`时间内完成，并且对队列的大小没有限制。在基于栈的队列实现中，无论是入队还是出队操作，其中一项操作都是昂贵的。
- en: Applications of queues
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列的应用
- en: Queues can be used to implement a variety of functionalities in many real computer-based
    applications. For instance, instead of providing each computer on a network with
    its own printer, a network of computers can be made to share one printer by queuing
    what each computer wants to print. When the printer is ready to print, it will
    pick one of the items (usually called jobs) in the queue to print out. It will
    print the command from the computer that has given the command first and will
    choose the following jobs in the order in which they were submitted by the different
    computers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以在许多基于计算机的实际应用中实现各种功能。例如，而不是为网络上的每一台计算机提供其自己的打印机，可以通过排队每台计算机想要打印的内容，使计算机网络共享一台打印机。当打印机准备好打印时，它将从队列中选择一个项目（通常称为作业）进行打印。它将首先打印发出命令的计算机的命令，并按照不同计算机提交的顺序选择后续作业。
- en: Operating systems also queue processes to be executed by the CPU. Let’s create
    an application that makes use of a queue to create a bare-bones media player.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统也会将进程排队以供CPU执行。让我们创建一个利用队列创建基本媒体播放器的应用程序。
- en: Most music player software allows users to add songs to a playlist. Upon hitting
    the play button, all the songs in the main playlist are played one after the other.
    Sequential playing of the songs can be implemented with queues because the first
    song to be queued is the first song that is to be played. This aligns with the
    **FIFO** acronym. We will implement our own playlist queue to play songs in the
    **FIFO** manner.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音乐播放器软件允许用户将歌曲添加到播放列表中。按下播放按钮后，主播放列表中的所有歌曲将依次播放。由于第一个入队的歌曲是第一个要播放的歌曲，因此顺序播放歌曲可以通过队列实现，这与**FIFO**（先进先出）的缩写一致。我们将实现自己的播放列表队列以**FIFO**方式播放歌曲。
- en: Our media player queue will only allow for the addition of tracks and a way
    to play all the tracks in the queue. In a full-blown music player, threads would
    be used to improve how the queue is interacted with, while the music player continues
    to be used to select the next song to be played, paused, or even stopped.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器队列只允许添加曲目以及播放队列中所有曲目的方式。在一个完整的音乐播放器中，会使用线程来改善队列的交互方式，同时音乐播放器继续用于选择下一首将要播放、暂停或甚至停止的歌曲。
- en: 'The `track` class will simulate a musical track:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`track`类将模拟音乐曲目：'
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length of the song is a random number between `5` and `10`. The
    `random` module in Python provides the `randint` function to enable us to generate
    random numbers. The class represents any MP3 track or file that contains music.
    The random length of a track is used to simulate the number of seconds it takes
    to play a track.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 每个曲目都包含歌曲标题的引用以及歌曲的长度。歌曲的长度是在`5`和`10`之间的随机数字。Python中的`random`模块提供了`randint`函数，使我们能够生成随机数。该类代表任何包含音乐的MP3曲目或文件。曲目的随机长度用于模拟播放曲目所需的时间（以秒为单位）。
- en: 'To create a few tracks and print out their lengths, we do the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一些曲目并打印它们的长度，我们执行以下操作：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Your output may be different depending on the random length generated for the
    two tracks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能因为两个曲目生成的随机长度而不同。
- en: 'Now, let’s create our queue using inheritance. We simply inherit from the `Queue`
    class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过继承创建我们的队列。我们简单地从`Queue`类继承：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To add tracks to the queue, an `add_track` method is created in the `MediaPlayerQueue`
    class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要将曲目添加到队列中，在`MediaPlayerQueue`类中创建了一个`add_track`方法：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The method passes a `track` object to the `enqueue` method of the queue `super`
    class. This will, in effect, create a `Node` using the `track` object (as the
    node’s data) and point either the tail if the queue is not empty, or both the
    head and tail if the queue is empty, to this new node.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将一个`track`对象传递给队列的`super`类的`enqueue`方法。这将实际上使用`track`对象（作为节点数据）创建一个`Node`，并将队列的尾指针（如果队列不为空）或头尾指针（如果队列为空）指向这个新节点。
- en: 'Assuming the tracks in the queue are played sequentially, from the first track
    added to the last (**FIFO**), then the `play` function has to loop through the
    elements in the queue:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设队列中的曲目是按顺序播放的，从最先添加的曲目到最后一个（**FIFO**），那么`play`函数必须遍历队列中的元素：
- en: '[PRE48]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`self.count` keeps count of when a track is added to our queue and when tracks
    have been dequeued. If the queue is not empty, a call to the `dequeue` method
    will return the node (which houses the `track` object) at the front of the queue.
    The `print` statement then accesses the title of the track through the `data`
    attribute of the node. To further simulate the playing of a track, the `time.sleep()`
    method halts program execution till the number of seconds for the track has elapsed:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.count`记录了曲目添加到我们的队列和曲目被出队的时间。如果队列不为空，对`dequeue`方法的调用将返回队列前端的节点（其中包含`track`对象）。然后`print`语句通过节点的`data`属性访问曲目的标题。为了进一步模拟播放曲目的过程，`time.sleep()`方法使程序执行暂停，直到曲目的秒数过去：'
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node’s `track` object through the data
    property of the node returned by the call to `dequeue`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放器队列由节点组成。当曲目被添加到队列中时，曲目被隐藏在一个新创建的节点中，并关联到节点的数据属性。这就解释了为什么我们通过调用`dequeue`返回的节点的`data`属性来访问节点的`track`对象。
- en: You can see that, instead of our `node` object just storing any data, it stores
    tracks in this case.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，与我们的`node`对象只存储任何数据不同，在这种情况下它存储的是曲目。
- en: 'Let’s take our music player for a spin:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试我们的音乐播放器：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We create five track objects with random words as titles, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了五个曲目对象，标题为随机单词，如下所示：
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output may be different from what you get on your machine due to the random
    length.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机长度，输出可能与你在机器上得到的不同。
- en: 'Next, an instance of the `MediaPlayerQueue` class is created using the following
    code snippet:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码片段创建`MediaPlayerQueue`类的实例：
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The tracks will be added, and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 曲目将被添加，`play`函数的输出应该按我们排队时的顺序打印出正在播放的曲目：
- en: '[PRE54]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing each track, the system also
    pauses for the number of seconds equal to the length of the track.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行后，可以看到曲目是按照它们排队时的顺序播放的。在播放每个曲目时，系统也会暂停与曲目长度相等的秒数。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed two important data structures, namely, stacks
    and queues. We have seen how these data structures closely mimic stacks and queues
    in the real world. Concrete implementations, together with their varying types,
    were explored. We later applied the concepts of stacks and queues to write real-life
    programs.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了两种重要的数据结构，即栈和队列。我们看到了这些数据结构如何紧密地模拟现实世界中的栈和队列。我们探讨了它们的具体实现及其不同类型。后来，我们将栈和队列的概念应用于编写实际程序。
- en: We will consider trees in the next chapter. The major operations on trees will
    be discussed, along with the different spheres of application of this data structure.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑树。我们将讨论树的主要操作，以及这种数据结构的各种应用领域。
- en: Exercises
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Which of the following options is a true queue implementation using linked lists?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项是使用链表实现的真正队列？
- en: If, in the enqueue operation, new data elements are added at the start of the
    list, then the dequeue operation must be performed from the end.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在入队操作中，新的数据元素被添加到列表的起始位置，那么必须从队列的末尾执行出队操作。
- en: If, in the enqueue operation, new data elements are added to the end of the
    list, then the enqueue operation must be performed from the start of the list.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在入队操作中，新的数据元素被添加到列表的末尾，那么必须从列表的起始位置执行入队操作。
- en: Both of the above.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上两者都是。
- en: None of the above.
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: Assume a queue is implemented using a singly-linked list that has head and tail
    pointers. The enqueue operation is implemented at the head, and the dequeue operation
    is implemented at the tail of the queue. What will be the time complexity of the
    enqueue and dequeue operations?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设队列使用具有头指针和尾指针的单链表实现。入队操作在队列头部实现，出队操作在队列尾部实现。入队和出队操作的时间复杂度是多少？
- en: What is the minimum number of stacks required to implement a queue?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现队列所需的最小栈数是多少？
- en: The enqueue and dequeue operations in a queue are implemented efficiently using
    an array. What will be the time complexity for both of these operations?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列中的入队（enqueue）和出队（dequeue）操作使用数组高效实现。这两个操作的时间复杂度是多少？
- en: How can we print the data elements of a queue data structure in reverse order?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何以逆序打印队列数据结构的数据元素？
- en: Join our community on Discord
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
