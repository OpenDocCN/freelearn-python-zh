- en: Chapter 7. What's in Your Backpack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Data – Lists and Dictionaries"),
    *Working with Data – Lists and Dictionaries*, we explored how to store, retrieve,
    and change data using lists and dictionaries in Python. In this chapter, we will
    build a two player game called **What's in Your Backpack?** This game will require
    us to review all of the skills we have learned since the beginning of this book.
    We use our skills to make loops, ask for information from the user with the `raw_input()`
    function, and then store this information in lists or dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to also learn some new skills that might seem complicated. We will
    try something called **nesting** or putting one thing inside another. With nesting
    lists and dictionaries, we have more flexible data storage. Using this new nesting
    skill with the other skills we have learned, we will create a game that can be
    played by two users or adjusted to be played by many users.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our coding environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will have the largest amount of code that we have written. Since
    we are going to do a lot of coding, it is important to have our tools ready so
    that we can test run our code frequently and save often.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing and saving the code as you go along allows you to try new things and
    correct any mistakes!
  prefs: []
  type: TYPE_NORMAL
- en: To work on this game, it is recommended that you have your Python shell open
    so that you can test out small lines of code before putting them into your text
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will need to open your text editor (JEdit in Mac/Linux or Notepad++
    in Windows), and make a new file called `backpack.py`. Finally, you will need
    to open your command prompt so that you can run the `backpack.py` program to test
    it out while you are writing the game. Hopefully, you are feeling more at ease
    with the different tools that are used to create a computer program. If you do
    not recall how to open the Python shell or command prompt, refer to [Chapter 1](ch01.html
    "Chapter 1. Welcome! Let's Get Started"), *Welcome! Let's Get Started*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have questions or want to know more about the Python shell, command prompt,
    or text editor that you are using on your computer, perform an Internet search
    and learn more about the tools.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn about the tools, documentation, and the advanced techniques used in
    this book, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jedit.org/](http://www.jedit.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://notepad-plus-plus.org/](https://notepad-plus-plus.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.5/library/idle.html](https://docs.python.org/3.5/library/idle.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.macworld.co.uk/feature/mac-software/get-more-out-of-os-x-terminal-3608274/](http://www.macworld.co.uk/feature/mac-software/get-more-out-of-os-x-terminal-3608274/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://windows.microsoft.com/en-US/windows-vista/Open-a-Command-Prompt-window](http://windows.microsoft.com/en-US/windows-vista/Open-a-Command-Prompt-window)'
  prefs: []
  type: TYPE_NORMAL
- en: Planning to program your game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive right into programming, we need to think critically about what
    we are building and plan a bit ahead of time; this helps us figure out what programming
    skills we need to use in order to make our program work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s imagine this game with each player having their own virtual backpack:'
  prefs: []
  type: TYPE_NORMAL
- en: Each player enters their name, and then places four items in their backpack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, each player gets a chance to guess what is in the other player's backpack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player guesses correctly, a message is printed, and one point is added
    to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player guesses incorrectly, a different message is printed, and no points
    are added to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a message asks the players whether they would like to play the game
    again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they type `yes`, the whole process takes place again. If they type `no`,
    then the scores of each player are printed and the entire game stops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Already, we have many things to do. Each of the points mentioned is a task that
    needs to be solved using our coding skills. Before reading the code sample ahead,
    ask yourself how you would try to solve each problem. Maybe make some drawings,
    or type an outline of each thing that the program needs to do to succeed. Then,
    save those ideas as you go through this chapter and write your backpack game.
    You might try some of your ideas, and check whether your ideas work! If so, that
    is great. You will discover that there is not one *proper* way to program. Some
    ways are better than others, but it is never wrong to try something out.
  prefs: []
  type: TYPE_NORMAL
- en: Skills needed to make a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will review our list of elements needed to make a successful game, and
    we will brainstorm the solutions to program each element. Taking time now to figure
    out how we want to solve the problem helps us create a program that works well
    once the pieces are put together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each player enters their name, and then places four items in their backpack.
    In order to get the player names into the computer, we will need to make a variable
    to hold the name of each player. We will use `raw_input()` to get the items and
    store the items in the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skills needed to make a program](img/B04681_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each player gets a chance to guess what is in the other player's backpack.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our game Higher or Lower? This function will be like higher and lower.
    We will compare the first player's guesses to the items in the second player's
    backpack. We will need to use `raw_input` to do prompt the guesses. Then, we will
    need some `if`/`elif`/`else` logic to compare the guesses and give the user output.
    The output will be printed to the screen using `print`.
  prefs: []
  type: TYPE_NORMAL
- en: If the player guesses correctly, a message is printed, and one point is added
    to the score.
  prefs: []
  type: TYPE_NORMAL
- en: If the player guesses incorrectly, a different message is printed, and no points
    are added to the score.
  prefs: []
  type: TYPE_NORMAL
- en: Score, play again, or quit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a player wins or uses up all of their guesses, we will use the `if`/`elif`/`else`
    logic to output a message that asks the players whether they would like to play
    the game again.
  prefs: []
  type: TYPE_NORMAL
- en: If player types `yes`, the game runs again.
  prefs: []
  type: TYPE_NORMAL
- en: If a player types `no`, then the scores of each player are printed and the game
    stops running.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and storing player information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first task is to figure out how we are going to get and store information
    from those who play our game. There are a few steps we need to take, including
    asking the player for their name, and then storing the player's name. We will
    also perform some code in the background to store information about the player
    that we have not yet asked for. This is a sneaky bit of coding that is quite fun
    and will let you expand your game if you want to. Let's walk through each step.
  prefs: []
  type: TYPE_NORMAL
- en: Making a players list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that we will do is make an empty list to store information
    about each player. We are going to name the list `players`, but we are not going
    to put anything in our list yet. Why not? Well, our players might be different
    in each game, and they will have different information too, so we need to allow
    our game to store this information as our players enter it into the computer.
    Here is what the `players` list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have made this list, we can add players to this list. Recall that
    we will also make a profile to store information about the players. In fact, the
    profile will be stored in some tiny dictionaries that we make inside the lists!
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a players list](img/B04681_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New skill! Putting one item inside another item. This is called **nesting**.
    Next, we will learn how to nest a dictionary inside of a list.
  prefs: []
  type: TYPE_NORMAL
- en: Player profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next step, we are going to make a dictionary for each player. The dictionary
    that we make will have placeholders for the player name, the player''s backpack
    items, and the player''s score:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles](img/B04681_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Imagine that all of the information in the dictionary is a `player` profile.
    The `player` profile will be filled in by information that we get from the player''s
    interactions with our game. The code in the following screenshot is what the completed
    code for our players will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles](img/B04681_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before you write any code, let''s read and break down the code. The first two
    lines are comments to remind us of what we are doing, and line 5 is where we make
    an empty list. The code in line 7, which is the first line of code that the computer
    cares about, allows us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the number of players with the `range()` function: Since counting in Python
    starts at zero, and the `range()` function does not include the last number, we
    are creating profiles for `player 0` and `player 1` (refer to [Chapter 6](ch06.html
    "Chapter 6. Working with Data – Lists and Dictionaries"), *Working with Data –
    Lists and Dictionaries*, where we spent time printing and counting lists, to refresh
    your memory about how lists items are counted).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `for` loop to make profile for each player: For `player 0` and `player
    1`, we will make a player profile with information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `player.append()` function: This adds an information type to each player
    profile. In this case, name is `string`, score is `int`, and backpack is an `empty`
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `backpack` dictionary key is special because it is a list that will store
    all of the backpack items inside of the profile. It allows the user to have many
    items stored in the same place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles](img/B04681_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Player profiles – how do they work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s think about all the information in a player profile. We have a
    list called `players`. Inside the `players` list, we have a dictionary for each
    player. The dictionary is where the player profile information is stored. Inside
    the dictionary for each player, we have made room for an item list. The item list
    is called `backpack`, and its job is to remember all the list items in the player
    profile. Try to imagine the profile like a tree that has more leaves as it breaks
    away from the trunk and branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles – how do they work?](img/B04681_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The name for what we have done is called **nesting**. Nesting is when we put
    one thing inside something else. Here, we have nested one datatype (a dictionary)
    inside another datatype (`players` list).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save your code if you have not done so already!
  prefs: []
  type: TYPE_NORMAL
- en: Add players to profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we have set up a data structure, called the **player** profile, as a way
    to store the information about each player. Now, we need to write the code that
    will prompt the players to enter their information into our program. We will use
    the `raw_input()` function to get information from the players and store this
    information in the user profile. Our request for user information will continue
    inside the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, read through the code from lines 15-20 in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add players to profile](img/B04681_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In line 15 of this code, you will notice our `raw_input()` command, which asks
    the player to enter their name. Did you notice that the `name` dictionary key
    is used? Did you notice that before the `name` key, `players[i]` is used? This
    means that the answer to the `Enter your name` prompt will be stored in the dictionary
    under the `name` key. A player profile will be created, and it will be waiting
    for information about the backpack items and the game score.
  prefs: []
  type: TYPE_NORMAL
- en: The player number is being set by `i`. The lowercase `i` represents one player.
    So, line 15 asks us for the name of player `i`. How does it know what number to
    choose? Where is `i` getting that information? If you go back up to the `for`
    loop, you will notice `for i in range(2)`. This means *for the first player of
    two players*, do all the things in the loop. When line 15 runs the `for` loop
    the first time, it asks for input from `player 1`; when the `for` loop runs the
    second time, it asks for input from `player 2`. A `for` loop with a `range(2)`
    only runs twice, so after getting and storing input from `player 2`, the `for`
    loop stops looping.
  prefs: []
  type: TYPE_NORMAL
- en: Adding items to the virtual backpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have added the player's name, we want to add four items to the player's
    virtual backpack. The virtual backpack is really a list inside the dictionary.
    We will store the list of each player's items in their virtual backpack, which
    is inside each player's profile. Asking a player to answer the same question multiple
    times presents a new programming challenge. How will we limit our program to ask
    for only four items? How will we add each item to the backpack of the correct
    player?
  prefs: []
  type: TYPE_NORMAL
- en: Limiting items in a virtual backpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure that we only add four items to each virtual backpack, we are using
    another `for` loop (inside our first `for` loop). The inside loop says `for item
    in range(4)`. This means *for each item out of four items*, do all the things
    in the loop. In our backpack loop, this means that we will enter items 0, 1, 2,
    and 3 into the backpack using the `raw_input()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `players[i]backpack` dictionary, we append (add) items to the list inside
    of the backpack by using `append(backpack_item)`. Because we want four items,
    our `for` loop runs four times after asking for the name and items of the player.
    When this `backpack_item` code finishes running, the entire player loop will begin
    again, asking for the name and items for the second player. In this process, we
    get the information we need to fill out the player profiles that are stored in
    the dictionaries of `player 1` and `player 2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Limiting items in a virtual backpack](img/B04681_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To review, when you run your code, you should expect to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a name and profile of `player 1`—`Enter name for player 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask `player 1` to put items in their backpack—`Enter 4 items to put into your
    backpack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Player enters four items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a name and profile `of player 2`—`Enter name for player 2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask `player 2` to put items in their backpack—`Enter 4 items to put into your
    backpack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing your code so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now written all of the data storage elements of the game. Save your
    code again if you have not done so already, and test what you have written.
  prefs: []
  type: TYPE_NORMAL
- en: First, do a visual test of your `backpack.py` code file. Make sure that your
    code is indented properly. Look for syntax errors such as misplaced quotes, periods,
    square brackets, curly braces, and parentheses. Make sure that everything is spelled
    correctly. Save after each mistake that you fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use your command prompt (Windows) or terminal (Mac/Linux) to test your
    code by running your program. When you run your program, you should expect to
    be asked to enter the name of player 1, enter four items, enter the name of player
    2, and enter four more items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your code so far](img/B04681_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to make sure that the backpack items you enter are being properly
    stored, you can use the test code from line 20 in the screenshot. Just uncomment
    (erase the hashtag in front of) the code in line 20, and then run the code again.
    Use the print statement from line 20 to check what the computer is storing. Sometimes,
    the computer reads things differently than we think it will, so it is good to
    have a print statement to double-check your work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your code so far](img/B04681_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have a mistake, you will get an error message. Usually, the error message
    will have a message that tells you where the problem is in the code. Look at your
    error messages if you do something incorrectly, and use these messages to figure
    out what is going wrong. When you correct an error, you can make a note or even
    make a comment in your code so that you recall how you fixed the problem.
  prefs: []
  type: TYPE_NORMAL
- en: A game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have planned and coded how to get information from players. Now, we need
    to code a **game loop**. What is a game loop? The game loop keeps the game running
    by starting the game using user actions to update the state of the game, if necessary,
    and continuing to operate until the game is ended, stopping the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Our game loop lets us start the game, use stored information from the players
    to make changes to the game state, and print outputs so that we know whether the
    guess was correct or incorrect or what the score is at the end of the game. Our
    game loop also shuts off if conditions change to stop the game. We have already
    used a game loop in our Higher or Lower game, and this game loop will be similar.
    Using the game loop, we can write the code to complete our game.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing back the while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, you may remember using the `while` loop back in [Chapters 4](ch04.html
    "Chapter 4. Making Decisions – Python Control Flows"), *Making Decisions: Python
    Control Flows*, and [Chapter 5](ch05.html "Chapter 5. Loops and Logic"), *Loops
    and Logic*. We will be using the `while` loop again to set up the game loop. There
    is quite a lot happening in the game loop (the `while` loop), so let''s take a
    look at it step by step. First, look at this screenshot of all of the code inside
    the game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing back the while loop](img/B04681_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing that you see is the comment telling anybody who reads the code
    what the code is doing. Comments are not required, but sometimes they can be helpful
    when you are writing a program. This comment simply tells us that the next section
    is the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop starts with the `game_on` variable. The `game_loop` variable is
    set to equal `True` (remember, `True` is a Boolean). The next line says `while
    game_on:`; this means that *since the* `while` *loop is* `True`*, keep running
    the* `while` *loop until something happens to make it* `False` *(untrue)*. Since
    `while game_on:` is `True`, the game will keep running using the information that
    we gathered when the game started. The game will end only when `game_on = False`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our game loop is another `for` loop. When one loop is inside another
    loop, they are nested. You might notice that this `for` loop is almost the same
    as the `for` loop in line 7\. This code runs `for i in range(2)`, which means
    that *for each player in the two players*, do all the things in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `for` loop, from line 26 to line 36, the main part of the game takes
    place. The things in this `for` loop include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the first player to guess an item from the second player's backpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print if the first player is correct or incorrect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add points to the first player's score if correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch to the second player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask the second player to guess an item from first player's backpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print if the second player is correct or incorrect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add points to the second player's score if correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask the players if they want to play again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *YES* to play again, restart the loop and redo all actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list has all of the events that take place inside of the `for`
    loop, which starts in line 25 of the code. We will break down the code that makes
    this happen in the next section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing guesses with backpack items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the math chapter, we learned about something called **modulo**. Now, it is
    coming back. In the backpack game, we compare the items in one player's backpack
    to the guess of another player. Then, the players switch places! How will the
    computer keep track of which backpack to look at and what player should be chosen?
    We can use modulo to help us always choose the correct player in the two-player
    version of this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the line of code that uses modulo (line 27):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code uses modulo to identify the opposite player by looking for
    the player in the `players` list we made in line 5\. Here is the basic idea:'
  prefs: []
  type: TYPE_NORMAL
- en: Erin (player 1) = 0 and Tanvir (player 2) = 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whoever is playing needs to compare their answer to the backpack of the other
    player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the backpack of the other player, we tell the computer *Hey, we need
    the backpack of the player who is NOT guessing right now.* We do this with math.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erin needs to use Tanvir's backpack to make guesses. Remember that Tanvir =
    1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (0 + 1) % 2 = 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This formula says (Erin + 1) modulo 2 = Tanvir's backpack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this math formula is equal to 1, so it is asking for Tanvir's
    backpack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Erin *WANTS* to guess what is in Tanvir's backpack, so this is correct.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tanvir needs to guess what is in Erin's backpack. Remember, Erin = 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (1 + 1) % 2 = 0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This formula says (Tanvir + 1) modulo 2 = Erin's backpack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this formula is equal to 0, so it is asking for Erin's backpack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tanvir *WANTS* to guess what is in Erin's backpack, so this is correct.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the formula, we choose the player profile from the `players` list. You
    know we are using a list because we use the name `players`, which we defined in
    line 5 of the program, and we use square brackets, `[ ]`, to say which list item
    we want to use. Inside the square brackets, we put a math formula that is equal
    to one of the items in our list.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep score in the game, the following line of code is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will notice a new symbol, `+=`. The `+=` symbol is a shortcut that lets
    us take a value (`score`), add an amount to this value (we are adding 1 point),
    and then make the value of `score` equal to the new value.
  prefs: []
  type: TYPE_NORMAL
- en: This line of code says that if the first player makes a match to an item in
    the second player backpack, then the new score for the first player is `score
    += 1`. You will remember that in the beginning of the game, we set each player
    to have a score of zero in the dictionary. Now, we are updating that score to
    be `score += 1`. Each time the first player scores, `score` will be updated by
    `1`, and the computer will remember the new score.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are tired of playing the game, we can answer the question *Do you want
    to play again? Type YES or NO: with* `NO`. Once we do this, you will notice that
    `game_on = False appears` in the code to stop the `while` loop. As soon as the
    loop stops, the last line of code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game](img/B04681_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This line of code prints out the scores of each player only *AFTER* the game
    loop is completed. This line of code is outside of the `for` loop and the game
    loop. If you only ran the game once, the highest score could only be one. However,
    if you ran the game five or ten times, then your high scores could be as high
    as five or ten, depending on how many items each player guessed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the moment of truth! First, look at each line of code. Check for indentation
    errors and syntax errors. Once you have proofread your code, save your work. When
    you are ready, run your code and play the game against yourself to see whether
    your code works. Run your code using your command prompt (Windows) or your terminal
    (Mac/Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected behavior is that each player will get one chance to guess the
    contents of the other player''s backpack. Then, you will be asked whether you
    would like to continue. If you press yes, the guessing will start again. If you
    press no, then the scores will print and the game will stop:'
  prefs: []
  type: TYPE_NORMAL
- en: If your game is working the way you expect it to, you can show it to someone
    else and see how it works for them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out different messages for correct or incorrect guesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an ending message, such as *Thanks for playing*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of many ways that you can change the game. By playing with
    the code, you can learn more about how it behaves, and gain a greater understanding
    of why and how things work. You are encouraged to play the game many times, by
    yourself and with others, to get ideas about how you might change your code to
    alter the game as well as understand each line of code thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: A quick task for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. What is nesting?
  prefs: []
  type: TYPE_NORMAL
- en: When birds build a home
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When one item is inside another item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a game loop is used
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a dictionary is used
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What does the list called `players` organize in this game?
  prefs: []
  type: TYPE_NORMAL
- en: It organizes a scores
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes player names
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes all the items belonging to each player
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes a backpack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What kind of item is inside the `players` list?
  prefs: []
  type: TYPE_NORMAL
- en: Any item that the player wants
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An integer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dictionary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. What is a game loop?
  prefs: []
  type: TYPE_NORMAL
- en: A loop that keeps going forever
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loop that holds the logic of the game
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loop that keeps the game running
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 and 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has been a lot of work. We reviewed almost every skill that we
    learned so far! We used logic in our `if`/`else` statements. We used Booleans,
    such as `True` and `False`, to change our game state. We ran `for` loops to control
    how many times certain events too place, and we ran a `while` loop as our game
    loop. Finally, we used *lists* and *dictionaries* to store customized information
    and to allow for information, such as the player score, to be changed during the
    game. We learned a new skill in this chapter: *nesting*. Our backpack game used
    nested lists and dictionaries. We also used nested loops, such as our `while`
    loop, with the `for` loop inside.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter used one of many ways to make this game. Our purpose was to use
    all of the tools we have in our Python toolbox. There are many different ways
    to make a **backpack** game. Some might be simpler, others might be more complicated.
    Something to explore before you go on is to try and make a variation of this game
    before you go on. You can use this code as a starting point, and use Internet
    searches and other books by Packt Publishing to help sharpen your Python skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to learn about making graphics using Python.
    We will learn some features of the graphics library that we can apply to develop
    our final game. Some of the features that we will learn include how to make a
    game screen, draw shapes, and move things around. We will even learn how to make
    one object bounce off another (hint: it''s an illusion!). The next chapter will
    also require some software installation, which may require you to have password
    access to your computer.'
  prefs: []
  type: TYPE_NORMAL
