- en: Chapter 7. What's in Your Backpack?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Data – Lists and Dictionaries"),
    *Working with Data – Lists and Dictionaries*, we explored how to store, retrieve,
    and change data using lists and dictionaries in Python. In this chapter, we will
    build a two player game called **What's in Your Backpack?** This game will require
    us to review all of the skills we have learned since the beginning of this book.
    We use our skills to make loops, ask for information from the user with the `raw_input()`
    function, and then store this information in lists or dictionaries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to also learn some new skills that might seem complicated. We will
    try something called **nesting** or putting one thing inside another. With nesting
    lists and dictionaries, we have more flexible data storage. Using this new nesting
    skill with the other skills we have learned, we will create a game that can be
    played by two users or adjusted to be played by many users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our coding environment
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will have the largest amount of code that we have written. Since
    we are going to do a lot of coding, it is important to have our tools ready so
    that we can test run our code frequently and save often.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing and saving the code as you go along allows you to try new things and
    correct any mistakes!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: To work on this game, it is recommended that you have your Python shell open
    so that you can test out small lines of code before putting them into your text
    editor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will need to open your text editor (JEdit in Mac/Linux or Notepad++
    in Windows), and make a new file called `backpack.py`. Finally, you will need
    to open your command prompt so that you can run the `backpack.py` program to test
    it out while you are writing the game. Hopefully, you are feeling more at ease
    with the different tools that are used to create a computer program. If you do
    not recall how to open the Python shell or command prompt, refer to [Chapter 1](ch01.html
    "Chapter 1. Welcome! Let's Get Started"), *Welcome! Let's Get Started*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: If you have questions or want to know more about the Python shell, command prompt,
    or text editor that you are using on your computer, perform an Internet search
    and learn more about the tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn about the tools, documentation, and the advanced techniques used in
    this book, you can refer to the following links:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jedit.org/](http://www.jedit.org/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[https://notepad-plus-plus.org/](https://notepad-plus-plus.org/)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.5/library/idle.html](https://docs.python.org/3.5/library/idle.html)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.macworld.co.uk/feature/mac-software/get-more-out-of-os-x-terminal-3608274/](http://www.macworld.co.uk/feature/mac-software/get-more-out-of-os-x-terminal-3608274/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[http://windows.microsoft.com/en-US/windows-vista/Open-a-Command-Prompt-window](http://windows.microsoft.com/en-US/windows-vista/Open-a-Command-Prompt-window)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Planning to program your game
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive right into programming, we need to think critically about what
    we are building and plan a bit ahead of time; this helps us figure out what programming
    skills we need to use in order to make our program work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入编程之前，我们需要批判性地思考我们正在构建的内容，并提前做一些规划；这有助于我们确定我们需要使用哪些编程技能来使我们的程序工作。
- en: 'So, let''s imagine this game with each player having their own virtual backpack:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们想象这个游戏，每位玩家都有自己的虚拟背包：
- en: Each player enters their name, and then places four items in their backpack.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每位玩家输入他们的名字，然后在他们背包中放置四个物品。
- en: Then, each player gets a chance to guess what is in the other player's backpack.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，每位玩家都有机会猜测另一位玩家背包中的物品。
- en: If the player guesses correctly, a message is printed, and one point is added
    to the score.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家猜对了，将打印一条信息，并将一分加到分数上。
- en: If the player guesses incorrectly, a different message is printed, and no points
    are added to the score.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家猜错了，将打印不同的信息，并且不会增加分数。
- en: Finally, a message asks the players whether they would like to play the game
    again.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个信息询问玩家是否想要再次玩游戏。
- en: If they type `yes`, the whole process takes place again. If they type `no`,
    then the scores of each player are printed and the entire game stops.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们输入“yes”，整个过程将再次进行。如果他们输入“no”，则打印每位玩家的分数，整个游戏停止。
- en: Already, we have many things to do. Each of the points mentioned is a task that
    needs to be solved using our coding skills. Before reading the code sample ahead,
    ask yourself how you would try to solve each problem. Maybe make some drawings,
    or type an outline of each thing that the program needs to do to succeed. Then,
    save those ideas as you go through this chapter and write your backpack game.
    You might try some of your ideas, and check whether your ideas work! If so, that
    is great. You will discover that there is not one *proper* way to program. Some
    ways are better than others, but it is never wrong to try something out.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多事情要做。提到的每个点都是一个需要使用我们的编码技能解决的问题。在阅读下面的代码示例之前，问问自己你会如何尝试解决每个问题。也许可以画一些图，或者为程序成功执行所需做的每一件事编写一个大纲。然后，随着你通过本章并编写你的背包游戏，保存这些想法。你可能尝试一些你的想法，并检查它们是否可行！如果可行，那就太好了。你会发现并没有一种“正确”的编程方式。有些方法比其他方法更好，但尝试任何东西从不是错的。
- en: Skills needed to make a program
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作程序所需的技能
- en: Now, we will review our list of elements needed to make a successful game, and
    we will brainstorm the solutions to program each element. Taking time now to figure
    out how we want to solve the problem helps us create a program that works well
    once the pieces are put together.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回顾制作成功游戏所需的元素列表，并头脑风暴每个元素的解决方案。现在花时间弄清楚我们想要如何解决问题，有助于我们创建一个一旦组件组合在一起就能良好工作的程序。
- en: 'Each player enters their name, and then places four items in their backpack.
    In order to get the player names into the computer, we will need to make a variable
    to hold the name of each player. We will use `raw_input()` to get the items and
    store the items in the computer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每位玩家输入他们的名字，然后在他们背包中放置四个物品。为了将玩家名字输入到电脑中，我们需要创建一个变量来保存每位玩家的名字。我们将使用`raw_input()`获取物品并将物品存储在电脑中：
- en: '![Skills needed to make a program](img/B04681_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![制作程序所需的技能](img/B04681_07_01.jpg)'
- en: Each player gets a chance to guess what is in the other player's backpack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每位玩家都有机会猜测另一位玩家背包中的物品。
- en: Remember our game Higher or Lower? This function will be like higher and lower.
    We will compare the first player's guesses to the items in the second player's
    backpack. We will need to use `raw_input` to do prompt the guesses. Then, we will
    need some `if`/`elif`/`else` logic to compare the guesses and give the user output.
    The output will be printed to the screen using `print`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的“高或低”游戏吗？这个功能将类似于高或低。我们将比较第一位玩家的猜测与第二位玩家背包中的物品。我们需要使用`raw_input`来提示猜测。然后，我们需要一些`if`/`elif`/`else`逻辑来比较猜测并给出用户输出。输出将通过`print`打印到屏幕上。
- en: If the player guesses correctly, a message is printed, and one point is added
    to the score.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家猜对了，将打印一条信息，并将一分加到分数上。
- en: If the player guesses incorrectly, a different message is printed, and no points
    are added to the score.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家猜错了，将打印不同的信息，并且不会增加分数。
- en: Score, play again, or quit?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分、再玩还是退出？
- en: When a player wins or uses up all of their guesses, we will use the `if`/`elif`/`else`
    logic to output a message that asks the players whether they would like to play
    the game again.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家获胜或用完所有的猜测时，我们将使用`if`/`elif`/`else`逻辑输出一个消息，询问玩家是否想要再次玩游戏。
- en: If player types `yes`, the game runs again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入`yes`，游戏将再次运行。
- en: If a player types `no`, then the scores of each player are printed and the game
    stops running.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输入`no`，那么每个玩家的分数将被打印出来，游戏将停止运行。
- en: Getting and storing player information
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和存储玩家信息
- en: Our first task is to figure out how we are going to get and store information
    from those who play our game. There are a few steps we need to take, including
    asking the player for their name, and then storing the player's name. We will
    also perform some code in the background to store information about the player
    that we have not yet asked for. This is a sneaky bit of coding that is quite fun
    and will let you expand your game if you want to. Let's walk through each step.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是弄清楚我们将如何从玩游戏的人那里获取和存储信息。我们需要采取几个步骤，包括询问玩家的名字，然后存储玩家的名字。我们还会在后台执行一些代码来存储我们尚未询问的玩家信息。这是一段相当有趣且巧妙的编码，如果你愿意，这将让你能够扩展你的游戏。让我们一步步来。
- en: Making a players list
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作玩家列表
- en: 'The first thing that we will do is make an empty list to store information
    about each player. We are going to name the list `players`, but we are not going
    to put anything in our list yet. Why not? Well, our players might be different
    in each game, and they will have different information too, so we need to allow
    our game to store this information as our players enter it into the computer.
    Here is what the `players` list looks like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个空列表来存储每个玩家的信息。我们将把这个列表命名为`players`，但我们目前不会在列表中放入任何内容。为什么？因为每个游戏中的玩家可能都不同，他们也会有不同的信息，所以我们需要允许我们的游戏在玩家将信息输入电脑时存储这些信息。下面是`players`列表的样子：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have made this list, we can add players to this list. Recall that
    we will also make a profile to store information about the players. In fact, the
    profile will be stored in some tiny dictionaries that we make inside the lists!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了列表，我们可以向这个列表中添加玩家。回想一下，我们还将创建一个档案来存储关于玩家的信息。实际上，这个档案将存储在我们列表内部创建的一些小字典中！
- en: '![Making a players list](img/B04681_07_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![制作玩家列表](img/B04681_07_02.jpg)'
- en: New skill! Putting one item inside another item. This is called **nesting**.
    Next, we will learn how to nest a dictionary inside of a list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 新技能！将一个物品放入另一个物品中。这被称为**嵌套**。接下来，我们将学习如何在列表中嵌套字典。
- en: Player profiles
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家档案
- en: 'In this next step, we are going to make a dictionary for each player. The dictionary
    that we make will have placeholders for the player name, the player''s backpack
    items, and the player''s score:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将为每个玩家创建一个字典。我们创建的字典将包含玩家名字、玩家的背包物品和玩家的分数的占位符：
- en: '![Player profiles](img/B04681_07_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![玩家档案](img/B04681_07_03.jpg)'
- en: 'Imagine that all of the information in the dictionary is a `player` profile.
    The `player` profile will be filled in by information that we get from the player''s
    interactions with our game. The code in the following screenshot is what the completed
    code for our players will look like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，字典中的所有信息都是一个`player`档案。`player`档案将由我们从玩家与我们的游戏互动中获得的信息填写。下面截图中的代码是我们玩家完成的代码：
- en: '![Player profiles](img/B04681_07_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![玩家档案](img/B04681_07_04.jpg)'
- en: 'Before you write any code, let''s read and break down the code. The first two
    lines are comments to remind us of what we are doing, and line 5 is where we make
    an empty list. The code in line 7, which is the first line of code that the computer
    cares about, allows us to do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写任何代码之前，让我们阅读并分解代码。前两行是注释，提醒我们我们在做什么，第5行是我们创建空列表的地方。第7行的代码，这是计算机关心的第一条代码，允许我们执行以下操作：
- en: 'Set the number of players with the `range()` function: Since counting in Python
    starts at zero, and the `range()` function does not include the last number, we
    are creating profiles for `player 0` and `player 1` (refer to [Chapter 6](ch06.html
    "Chapter 6. Working with Data – Lists and Dictionaries"), *Working with Data –
    Lists and Dictionaries*, where we spent time printing and counting lists, to refresh
    your memory about how lists items are counted).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `for` loop to make profile for each player: For `player 0` and `player
    1`, we will make a player profile with information.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `player.append()` function: This adds an information type to each player
    profile. In this case, name is `string`, score is `int`, and backpack is an `empty`
    list.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `backpack` dictionary key is special because it is a list that will store
    all of the backpack items inside of the profile. It allows the user to have many
    items stored in the same place:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles](img/B04681_07_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Player profiles – how do they work?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s think about all the information in a player profile. We have a
    list called `players`. Inside the `players` list, we have a dictionary for each
    player. The dictionary is where the player profile information is stored. Inside
    the dictionary for each player, we have made room for an item list. The item list
    is called `backpack`, and its job is to remember all the list items in the player
    profile. Try to imagine the profile like a tree that has more leaves as it breaks
    away from the trunk and branch:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Player profiles – how do they work?](img/B04681_07_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: The name for what we have done is called **nesting**. Nesting is when we put
    one thing inside something else. Here, we have nested one datatype (a dictionary)
    inside another datatype (`players` list).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save your code if you have not done so already!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Add players to profile
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we have set up a data structure, called the **player** profile, as a way
    to store the information about each player. Now, we need to write the code that
    will prompt the players to enter their information into our program. We will use
    the `raw_input()` function to get information from the players and store this
    information in the user profile. Our request for user information will continue
    inside the `for` loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'First, read through the code from lines 15-20 in this screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Add players to profile](img/B04681_07_11.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: In line 15 of this code, you will notice our `raw_input()` command, which asks
    the player to enter their name. Did you notice that the `name` dictionary key
    is used? Did you notice that before the `name` key, `players[i]` is used? This
    means that the answer to the `Enter your name` prompt will be stored in the dictionary
    under the `name` key. A player profile will be created, and it will be waiting
    for information about the backpack items and the game score.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The player number is being set by `i`. The lowercase `i` represents one player.
    So, line 15 asks us for the name of player `i`. How does it know what number to
    choose? Where is `i` getting that information? If you go back up to the `for`
    loop, you will notice `for i in range(2)`. This means *for the first player of
    two players*, do all the things in the loop. When line 15 runs the `for` loop
    the first time, it asks for input from `player 1`; when the `for` loop runs the
    second time, it asks for input from `player 2`. A `for` loop with a `range(2)`
    only runs twice, so after getting and storing input from `player 2`, the `for`
    loop stops looping.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家编号由`i`设置。小写的`i`代表一个玩家。所以，第15行要求我们输入玩家`i`的名字。它是如何知道选择哪个数字的？`i`从哪里得到这个信息？如果你回到`for`循环，你会注意到`for
    i in range(2)`。这意味着`对于两个玩家中的第一个玩家`，执行循环中的所有操作。当第15行第一次运行`for`循环时，它会从`player 1`那里获取输入；当`for`循环第二次运行时，它会从`player
    2`那里获取输入。一个`range(2)`的`for`循环只运行两次，所以获取并存储`player 2`的输入后，`for`循环停止循环。
- en: Adding items to the virtual backpack
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向虚拟背包中添加物品。
- en: Now that we have added the player's name, we want to add four items to the player's
    virtual backpack. The virtual backpack is really a list inside the dictionary.
    We will store the list of each player's items in their virtual backpack, which
    is inside each player's profile. Asking a player to answer the same question multiple
    times presents a new programming challenge. How will we limit our program to ask
    for only four items? How will we add each item to the backpack of the correct
    player?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了玩家的名字，我们想要为玩家添加四个物品到他们的虚拟背包中。虚拟背包实际上是在字典中的一个列表。我们将存储每个玩家虚拟背包中的物品列表，它位于每个玩家的档案中。让玩家多次回答相同的问题提出了一个新的编程挑战。我们将如何限制我们的程序只请求四个物品？我们将如何将每个物品添加到正确玩家的背包中？
- en: Limiting items in a virtual backpack
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制虚拟背包中的物品。
- en: To make sure that we only add four items to each virtual backpack, we are using
    another `for` loop (inside our first `for` loop). The inside loop says `for item
    in range(4)`. This means *for each item out of four items*, do all the things
    in the loop. In our backpack loop, this means that we will enter items 0, 1, 2,
    and 3 into the backpack using the `raw_input()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们只向每个虚拟背包中添加四个物品，我们正在使用另一个`for`循环（在我们的第一个`for`循环内部）。内部循环说`for item in range(4)`。这意味着`对于四个物品中的每一个`，执行循环中的所有操作。在我们的背包循环中，这意味着我们将使用`raw_input()`函数将物品0、1、2和3输入到背包中。
- en: 'In the `players[i]backpack` dictionary, we append (add) items to the list inside
    of the backpack by using `append(backpack_item)`. Because we want four items,
    our `for` loop runs four times after asking for the name and items of the player.
    When this `backpack_item` code finishes running, the entire player loop will begin
    again, asking for the name and items for the second player. In this process, we
    get the information we need to fill out the player profiles that are stored in
    the dictionaries of `player 1` and `player 2`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`players[i]backpack`字典中，我们通过使用`append(backpack_item)`将物品添加到背包内部的列表中。因为我们想要四个物品，所以我们的`for`循环在询问玩家的名字和物品后运行四次。当这个`backpack_item`代码运行完成后，整个玩家循环将再次开始，询问第二个玩家的名字和物品。在这个过程中，我们得到了填写存储在`player
    1`和`player 2`字典中的玩家档案所需的信息：
- en: '![Limiting items in a virtual backpack](img/B04681_07_12.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![限制虚拟背包中的物品](img/B04681_07_12.jpg)'
- en: 'To review, when you run your code, you should expect to see the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，当你运行你的代码时，你应该期望看到以下内容：
- en: Create a name and profile of `player 1`—`Enter name for player 1`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`玩家1`创建一个名字和档案—`输入玩家1的名字`。
- en: Ask `player 1` to put items in their backpack—`Enter 4 items to put into your
    backpack`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请`玩家1`将物品放入他们的背包中—`输入4个物品放入你的背包中`。
- en: Player enters four items.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家输入四个物品。
- en: Create a name and profile `of player 2`—`Enter name for player 2`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`玩家2`创建一个名字和档案—`输入玩家2的名字`。
- en: Ask `player 2` to put items in their backpack—`Enter 4 items to put into your
    backpack`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请让`玩家2`将物品放入背包中—`输入4个物品放入你的背包中`。
- en: Testing your code so far
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你到目前为止的代码。
- en: You have now written all of the data storage elements of the game. Save your
    code again if you have not done so already, and test what you have written.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经编写了游戏的所有数据存储元素。如果你还没有这样做，请再次保存你的代码，并测试你所编写的代码。
- en: First, do a visual test of your `backpack.py` code file. Make sure that your
    code is indented properly. Look for syntax errors such as misplaced quotes, periods,
    square brackets, curly braces, and parentheses. Make sure that everything is spelled
    correctly. Save after each mistake that you fix.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对你的`backpack.py`代码文件进行视觉测试。确保你的代码缩进正确。寻找语法错误，如错位的引号、句号、方括号、花括号和括号。确保一切拼写正确。每次修复错误后都保存。
- en: 'Next, use your command prompt (Windows) or terminal (Mac/Linux) to test your
    code by running your program. When you run your program, you should expect to
    be asked to enter the name of player 1, enter four items, enter the name of player
    2, and enter four more items:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用你的命令提示符（Windows）或终端（Mac/Linux）通过运行你的程序来测试你的代码。当你运行程序时，你应该会被要求输入玩家1的名字，输入四个物品，输入玩家2的名字，并输入另外四个物品：
- en: '![Testing your code so far](img/B04681_07_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![测试你目前的代码](img/B04681_07_07.jpg)'
- en: 'If you want to make sure that the backpack items you enter are being properly
    stored, you can use the test code from line 20 in the screenshot. Just uncomment
    (erase the hashtag in front of) the code in line 20, and then run the code again.
    Use the print statement from line 20 to check what the computer is storing. Sometimes,
    the computer reads things differently than we think it will, so it is good to
    have a print statement to double-check your work:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保你输入的背包物品被正确存储，你可以使用截图中的第20行的测试代码。只需取消注释（删除第20行前的井号），然后再次运行代码。使用第20行的print语句来检查计算机存储的内容。有时，计算机的读取方式可能与我们预期的不同，所以有一个print语句来双重检查你的工作是很好的：
- en: '![Testing your code so far](img/B04681_07_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![测试你目前的代码](img/B04681_07_08.jpg)'
- en: If you have a mistake, you will get an error message. Usually, the error message
    will have a message that tells you where the problem is in the code. Look at your
    error messages if you do something incorrectly, and use these messages to figure
    out what is going wrong. When you correct an error, you can make a note or even
    make a comment in your code so that you recall how you fixed the problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯了错误，你会得到一个错误信息。通常，错误信息会告诉你代码中问题的位置。如果你做错了什么，看看你的错误信息，并使用这些信息来找出出了什么问题。当你纠正错误时，你可以在代码中做一个笔记或者甚至添加一个注释，以便你回忆起你是如何解决问题的。
- en: A game loop
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个游戏循环
- en: We have planned and coded how to get information from players. Now, we need
    to code a **game loop**. What is a game loop? The game loop keeps the game running
    by starting the game using user actions to update the state of the game, if necessary,
    and continuing to operate until the game is ended, stopping the loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计划和编写了如何从玩家那里获取信息的方法。现在，我们需要编写一个**游戏循环**。什么是游戏循环？游戏循环通过使用用户操作来启动游戏并更新游戏状态（如果需要），然后继续操作直到游戏结束，停止循环。
- en: Our game loop lets us start the game, use stored information from the players
    to make changes to the game state, and print outputs so that we know whether the
    guess was correct or incorrect or what the score is at the end of the game. Our
    game loop also shuts off if conditions change to stop the game. We have already
    used a game loop in our Higher or Lower game, and this game loop will be similar.
    Using the game loop, we can write the code to complete our game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环让我们能够开始游戏，使用玩家存储的信息来改变游戏状态，并打印输出，以便我们知道猜测是正确还是错误，或者游戏结束时得分是多少。我们的游戏循环也会在条件改变时关闭，以停止游戏。我们已经在我们的Higher
    or Lower游戏中使用了一个游戏循环，这个游戏循环将是相似的。使用游戏循环，我们可以编写代码来完成我们的游戏。
- en: Bringing back the while loop
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复while循环
- en: 'So, you may remember using the `while` loop back in [Chapters 4](ch04.html
    "Chapter 4. Making Decisions – Python Control Flows"), *Making Decisions: Python
    Control Flows*, and [Chapter 5](ch05.html "Chapter 5. Loops and Logic"), *Loops
    and Logic*. We will be using the `while` loop again to set up the game loop. There
    is quite a lot happening in the game loop (the `while` loop), so let''s take a
    look at it step by step. First, look at this screenshot of all of the code inside
    the game loop:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能记得在[第4章](ch04.html "第4章。做出决策 - Python控制流")“做出决策：Python控制流”和[第5章](ch05.html
    "第5章。循环和逻辑")“循环和逻辑”中使用了`while`循环。我们将再次使用`while`循环来设置游戏循环。游戏循环（`while`循环）中发生了很多事情，所以让我们一步一步地看看。首先，看看这个游戏循环中所有代码的截图：
- en: '![Bringing back the while loop](img/B04681_07_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![恢复while循环](img/B04681_07_09.jpg)'
- en: The first thing that you see is the comment telling anybody who reads the code
    what the code is doing. Comments are not required, but sometimes they can be helpful
    when you are writing a program. This comment simply tells us that the next section
    is the game loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The game loop starts with the `game_on` variable. The `game_loop` variable is
    set to equal `True` (remember, `True` is a Boolean). The next line says `while
    game_on:`; this means that *since the* `while` *loop is* `True`*, keep running
    the* `while` *loop until something happens to make it* `False` *(untrue)*. Since
    `while game_on:` is `True`, the game will keep running using the information that
    we gathered when the game started. The game will end only when `game_on = False`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Inside our game loop is another `for` loop. When one loop is inside another
    loop, they are nested. You might notice that this `for` loop is almost the same
    as the `for` loop in line 7\. This code runs `for i in range(2)`, which means
    that *for each player in the two players*, do all the things in the loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `for` loop, from line 26 to line 36, the main part of the game takes
    place. The things in this `for` loop include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Ask the first player to guess an item from the second player's backpack
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print if the first player is correct or incorrect
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add points to the first player's score if correct
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch to the second player
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask the second player to guess an item from first player's backpack
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print if the second player is correct or incorrect
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add points to the second player's score if correct
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask the players if they want to play again
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *YES* to play again, restart the loop and redo all actions
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list has all of the events that take place inside of the `for`
    loop, which starts in line 25 of the code. We will break down the code that makes
    this happen in the next section of the chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Comparing guesses with backpack items
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the math chapter, we learned about something called **modulo**. Now, it is
    coming back. In the backpack game, we compare the items in one player's backpack
    to the guess of another player. Then, the players switch places! How will the
    computer keep track of which backpack to look at and what player should be chosen?
    We can use modulo to help us always choose the correct player in the two-player
    version of this game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the line of code that uses modulo (line 27):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This line of code uses modulo to identify the opposite player by looking for
    the player in the `players` list we made in line 5\. Here is the basic idea:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Erin (player 1) = 0 and Tanvir (player 2) = 1.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whoever is playing needs to compare their answer to the backpack of the other
    player.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the backpack of the other player, we tell the computer *Hey, we need
    the backpack of the player who is NOT guessing right now.* We do this with math.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erin needs to use Tanvir's backpack to make guesses. Remember that Tanvir =
    1.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (0 + 1) % 2 = 1.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This formula says (Erin + 1) modulo 2 = Tanvir's backpack.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this math formula is equal to 1, so it is asking for Tanvir's
    backpack.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，这个数学公式等于1，所以它在询问坦维尔的背包。
- en: Erin *WANTS* to guess what is in Tanvir's backpack, so this is correct.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾琳*想要*猜出坦维尔背包里的东西，所以这是正确的。
- en: Tanvir needs to guess what is in Erin's backpack. Remember, Erin = 0.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坦维尔需要猜出艾琳背包里的东西。记住，艾琳 = 0。
- en: (1 + 1) % 2 = 0.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: (1 + 1) % 2 = 0。
- en: This formula says (Tanvir + 1) modulo 2 = Erin's backpack.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个公式表示（坦维尔 + 1）模2等于艾琳的背包。
- en: As you can see, this formula is equal to 0, so it is asking for Erin's backpack.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，这个公式等于0，所以它在询问艾琳的背包。
- en: Tanvir *WANTS* to guess what is in Erin's backpack, so this is correct.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坦维尔*想要*猜出艾琳背包里的东西，所以这是正确的。
- en: Using the formula, we choose the player profile from the `players` list. You
    know we are using a list because we use the name `players`, which we defined in
    line 5 of the program, and we use square brackets, `[ ]`, to say which list item
    we want to use. Inside the square brackets, we put a math formula that is equal
    to one of the items in our list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式，我们从`players`列表中选择玩家配置文件。您知道我们使用列表，因为我们使用了名为`players`的名称，我们在程序的第五行定义了它，我们使用方括号`[
    ]`来说明我们想要使用哪个列表项。在方括号内，我们放入一个等于我们列表中某个项的数学公式。
- en: Keeping score
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记分
- en: 'To keep score in the game, the following line of code is used:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏中计分，使用了以下代码行：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will notice a new symbol, `+=`. The `+=` symbol is a shortcut that lets
    us take a value (`score`), add an amount to this value (we are adding 1 point),
    and then make the value of `score` equal to the new value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到一个新的符号，`+=`。`+=`符号是一个快捷方式，它允许我们取一个值（`score`），向这个值添加一个数量（我们添加1分），然后使`score`的值等于新值。
- en: This line of code says that if the first player makes a match to an item in
    the second player backpack, then the new score for the first player is `score
    += 1`. You will remember that in the beginning of the game, we set each player
    to have a score of zero in the dictionary. Now, we are updating that score to
    be `score += 1`. Each time the first player scores, `score` will be updated by
    `1`, and the computer will remember the new score.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码表示，如果第一个玩家匹配到第二个玩家背包中的物品，那么第一个玩家的新分数将是`score += 1`。您会记得，在游戏开始时，我们在字典中为每个玩家设置了分数为零。现在，我们正在更新这个分数为`score
    += 1`。每当第一个玩家得分时，`score`将增加`1`，电脑会记住新的分数。
- en: Ending the game
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: 'Once we are tired of playing the game, we can answer the question *Do you want
    to play again? Type YES or NO: with* `NO`. Once we do this, you will notice that
    `game_on = False appears` in the code to stop the `while` loop. As soon as the
    loop stops, the last line of code is executed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们玩腻了游戏，我们可以回答问题“你想再玩一次吗？输入YES或NO：”，使用`NO`。一旦我们这样做，您会注意到代码中出现了`game_on = False`来停止`while`循环。一旦循环停止，最后一行代码将被执行：
- en: '![Ending the game](img/B04681_07_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![结束游戏](img/B04681_07_10.jpg)'
- en: This line of code prints out the scores of each player only *AFTER* the game
    loop is completed. This line of code is outside of the `for` loop and the game
    loop. If you only ran the game once, the highest score could only be one. However,
    if you ran the game five or ten times, then your high scores could be as high
    as five or ten, depending on how many items each player guessed correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码仅在游戏循环完成后打印出每个玩家的分数。这行代码位于`for`循环和游戏循环之外。如果您只玩了一次游戏，最高分只能是一。然而，如果您玩了五次或十次，那么您的最高分可能高达五或十，具体取决于每个玩家猜对了多少项。
- en: Testing your game
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的游戏
- en: Now, the moment of truth! First, look at each line of code. Check for indentation
    errors and syntax errors. Once you have proofread your code, save your work. When
    you are ready, run your code and play the game against yourself to see whether
    your code works. Run your code using your command prompt (Windows) or your terminal
    (Mac/Linux).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是真相大白的时候了！首先，查看每一行代码。检查缩进错误和语法错误。一旦您校对完代码，保存您的作品。准备好后，运行您的代码，自己玩游戏以查看代码是否工作。使用您的命令提示符（Windows）或终端（Mac/Linux）运行您的代码。
- en: 'The expected behavior is that each player will get one chance to guess the
    contents of the other player''s backpack. Then, you will be asked whether you
    would like to continue. If you press yes, the guessing will start again. If you
    press no, then the scores will print and the game will stop:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为是每个玩家将有一次机会猜测对方背包的内容。然后，您将被询问是否想继续。如果您按yes，猜测将再次开始。如果您按no，则将打印分数，游戏将停止：
- en: If your game is working the way you expect it to, you can show it to someone
    else and see how it works for them
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out different messages for correct or incorrect guesses
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an ending message, such as *Thanks for playing*
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of many ways that you can change the game. By playing with
    the code, you can learn more about how it behaves, and gain a greater understanding
    of why and how things work. You are encouraged to play the game many times, by
    yourself and with others, to get ideas about how you might change your code to
    alter the game as well as understand each line of code thoroughly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: A quick task for you
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. What is nesting?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When birds build a home
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When one item is inside another item
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a game loop is used
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a dictionary is used
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What does the list called `players` organize in this game?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: It organizes a scores
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes player names
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes all the items belonging to each player
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It organizes a backpack
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What kind of item is inside the `players` list?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Any item that the player wants
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A string
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An integer
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dictionary
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. What is a game loop?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: A loop that keeps going forever
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loop that holds the logic of the game
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loop that keeps the game running
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 and 3
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has been a lot of work. We reviewed almost every skill that we
    learned so far! We used logic in our `if`/`else` statements. We used Booleans,
    such as `True` and `False`, to change our game state. We ran `for` loops to control
    how many times certain events too place, and we ran a `while` loop as our game
    loop. Finally, we used *lists* and *dictionaries* to store customized information
    and to allow for information, such as the player score, to be changed during the
    game. We learned a new skill in this chapter: *nesting*. Our backpack game used
    nested lists and dictionaries. We also used nested loops, such as our `while`
    loop, with the `for` loop inside.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: This chapter used one of many ways to make this game. Our purpose was to use
    all of the tools we have in our Python toolbox. There are many different ways
    to make a **backpack** game. Some might be simpler, others might be more complicated.
    Something to explore before you go on is to try and make a variation of this game
    before you go on. You can use this code as a starting point, and use Internet
    searches and other books by Packt Publishing to help sharpen your Python skills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to learn about making graphics using Python.
    We will learn some features of the graphics library that we can apply to develop
    our final game. Some of the features that we will learn include how to make a
    game screen, draw shapes, and move things around. We will even learn how to make
    one object bounce off another (hint: it''s an illusion!). The next chapter will
    also require some software installation, which may require you to have password
    access to your computer.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
