- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important operation for all data structures is searching for elements from
    a collection of data. There are various methods to search for an element in data
    structures; in this chapter, we shall explore the different strategies that can
    be used to find elements in a collection of items.
  prefs: []
  type: TYPE_NORMAL
- en: Data elements can be stored in any kind of data structure, such as an array,
    link list, tree, or graph; the search operation is very important for many applications,
    mostly whenever we want to know if a particular data element is present in an
    existing list of data items. In order to retrieve the information efficiently,
    we require an efficient search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Various search algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start with an introduction to searching and a definition and then look
    at the linear search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A search operation is carried out to find the location of the desired data item
    from a collection of data items. The search algorithm returns the location of
    the searched value where it is present in the list of items and if the data item
    is not present, it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient searching is important to efficiently retrieve the location of the
    desired data item from a list of stored data items. For example, we have a long
    list of data values, such as `{1, 45, 65, 23, 65, 75, 23}`, and we want to see
    if `75` is present in the list or not. It becomes important to have an efficient
    search algorithm when the list of data items becomes large.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different ways in which data can be organized, which can affect
    how a search algorithm works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the search algorithm is applied to a list of items that is already sorted;
    that is, it is applied to an ordered set of items. For example, `[1, 3, 5, 7,
    9, 11, 13, 15, 17]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search algorithm is applied to an unordered set of items, which is not sorted.
    For example, `[11, 3, 45, 76, 99, 11, 13, 35, 37]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first take a look at linear searching.
  prefs: []
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The search operation is used to find out the index position of a given data
    item in a list of data items. If the searched item is available in the given list
    of data items, then the search algorithm returns the index position where it is
    located; otherwise, it returns that the item is not found. Here, the index position
    is the location of the desired item in the given list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest approach to search for an item in a list is to search linearly,
    in which we look for items one by one in the whole list. Let’s take an example
    of six list items `{60, 1, 88, 10, 11, 100}` to understand the linear search algorithm,
    as shown in *Figure 10.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: An example of linear search'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list has elements that can be accessed through the index. To find
    an element in the list, we can search for the given element linearly one by one.
    This technique traverses the list of elements by using the index to move from
    the beginning of the list to the end. Each element is checked, and if it does
    not match the search item, the next item is examined. By hopping from one item
    to the next, the list is traversed sequentially. We use list items with integer
    values in this chapter to help you understand the concept, since integers can
    be compared easily; however, a list item can hold any other data type as well.
  prefs: []
  type: TYPE_NORMAL
- en: The linear search approach depends on how the list items are stored in memory—whether
    they are already sorted in order or they are not sorted. Let’s first see how the
    linear search algorithm works if the given list of items is not sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered linear search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unordered linear search is a linear search algorithm in which the given
    list of date items is not sorted. We linearly match the desired data item with
    the data items of the list one by one till the end of the list or until the desired
    data item is found. Consider an example list that contains the elements `60`,
    `1`, `88`, `10`, and `100`—an unordered list. To perform a `search` operation
    on such a list, one proceeds with the first item and compares that with the search
    item. If the search item is not matched, then the next element in the list is
    checked. This continues till we reach the last element in the list or until a
    match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an unordered list of items, the search for the term `10` starts from the
    first element and moves to the next element in the list. Thus, firstly `60` is
    compared with `10`, and since it is not equal, we compare `66` with the next element
    `1`, then `88`, and so on till we find the search term in the list. Once the item
    is found, we return the index position of where we have found the desired item.
    This process is shown in *Figure 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Unordered linear search'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation in Python for the linear search on an unordered
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `search` function takes two parameters; the first is the list that holds
    the data, and the second parameter is the item that we are looking for, called
    the **search term**. On every pass of the `for` loop, we check if the search term
    is equal to the indexed item. If this is true, then there is a match, and there
    is no need to proceed further with the search. We return the index position where
    the searched item is found in the list. If the loops run to the end of the list
    with no match found, then `None` is returned to signify that there is no such
    item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following code snippet to check if a desired data element is
    present in the given list of data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the output of the above code, firstly, the index position `3` is returned
    when we search for data element `10` in `list1`. And secondly, index position
    `2` is returned when data item `'data'` is searched for in `list2`. We can use
    the same algorithm for searching a non-numeric data item from a list of non-numeric
    data items in Python, since string elements can also be compared similarly to
    numeric data in Python.
  prefs: []
  type: TYPE_NORMAL
- en: When searching for any element from an unordered list of items, in the worst
    case the desired item may be in the last position or may not be present in the
    list. In this situation we will have to compare the search item with all the elements
    of the list, i.e. `n` times if the total number of data items in the list is `n`.
    Thus, the unordered linear search has a worst-case running time of `O(n)`. All
    the elements may need to be visited before finding the search term. The worst-case
    scenario will be when the search term is located at the last position of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss how the linear search algorithm works if the given list of
    data items is already sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered linear search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the data elements are already arranged in a sorted order, then the linear
    search algorithm can be improved. The linear search algorithm in a sorted list
    of elements has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move through the list sequentially
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of a search item is greater than the object or item currently under
    inspection in the loop, then quit and return `None`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the process of iterating through the list, if the value of the search term
    is less than the current item in the list, then there is no need to continue with
    the search. Let’s consider an example to see how this works. Let’s say we have
    a list of items `{2, 3, 4, 6, 7}` as shown in *Figure 10.3*, and we want to search
    for term `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Example of ordered linear search'
  prefs: []
  type: TYPE_NORMAL
- en: We start the `search` operation by comparing the desired search element `5`
    with the first element; no match is found. We continue on to compare the search
    element with the next element, i.e. `3`, in the list. Since it also does not match,
    we move on to examine the next element, i.e. `4`, and since it also does not match,
    we continue searching in the list, and we compare the search element with the
    fourth element, i.e. `6`. This also does not match the search term. Since the
    given list is already sorted in ascending order and the value of the search item
    is less than the fourth element, the search item cannot be found in any later
    position in the list. In other words, if the current item in the list is greater
    than the search term, then it means there is no need to further search the list,
    and we stop searching for the element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the linear search when the list is already sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `if` statement now caters to checking if the search
    item is found in the list or not. Then, `elif` tests the condition where `ordered_list[i]
    > term`. We stop searching if the comparison evaluates to `True`, which means
    the current item in the list is greater than the search element. The last line
    in the method returns `None` because the loop may go through the list and still
    the search item is not matched in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following code snippet to use the search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the output of the above code, firstly, the search item `5` is not matched
    in the given list. And for the second list of non-numeric data elements, the string
    structure is matched at index position `3`. Hence, we can use the same linear
    search algorithm for searching a non-numeric data item from an ordered list of
    data items, so the given list of data items should be sorted similarly to a contact
    list on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case scenario, the desired search item will be present in the last
    position of the list or will not be present at all. In this situation, we will
    have to trace the complete list (say `n` elements). Thus, the worst-case time
    complexity of an ordered linear search is `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the jump search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Jump search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **jump search** algorithm is an improvement over linear search for searching
    for a given element from an ordered (or sorted) list of elements. This uses the
    divide-and-conquer strategy in order to search for the required element. In linear
    search, we compare the search value with each element of the list, whereas in
    jump search, we compare the search value at different intervals in the list, which
    reduces the number of comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this algorithm, firstly, we divide the sorted list of data into subsets
    of data elements called blocks. Within each block, the highest value will lie
    within the last element, as the array is sorted. Next, in this algorithm, we start
    comparing the search value with the last element of each block. There can be three
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the search value is less than the last element of the block, we compare it
    with the next block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value is greater than the last element of the block, it means
    the desired search value must be present in the current block. So, we apply linear
    search in this block and return the index position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value is the same as the compared element of the block, we return
    the index position of the element and we return the candidate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, the size of the block is taken as ![](img/B17217_10_001.png), since
    it gives the best performance for a given array of length `n`.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case situation, we will have to make *n/m* number of jumps (here,
    `n` is the total number of elements, and *m* is the block size) if the last element
    of the last block is greater than the item to be searched, and we will need *m*
    - 1 comparisons for linear search in the last block. Therefore, the total number
    of comparisons will be ((*n/m*) + *m* - 1), which will minimize when *m* = *√n*
    . So the size of the block is taken as *√n* since it gives the best performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example list `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}` to search
    for a given element (say `10`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Illustration of the jump search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, we find the desired element `10` in `5` comparisons. Firstly,
    we compare the first value of the array with the desired item `A[0] <= item`;
    if it is true, then we increase the index by the block size (this is shown in
    *step 1* in *Figure 10.4*). Next, we compare the desired item with the last element
    of each block. If it is greater, then we move to the next block, such as from
    block 1 to block 3 (this is shown in *steps 2*, *3*, and *4* in *Figure 10.4*).
  prefs: []
  type: TYPE_NORMAL
- en: Further, when the desired search element becomes smaller than the last element
    of a block, we stop incrementing the index position and then we do the linear
    search in the current block. Now, let us discuss the implementation of the jump
    searching algorithms. Firstly, we implement the linear search algorithm, which
    is similar to what we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is given again here for the sake of completeness as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, given an ordered list of elements, it returns the index
    of the location where a given data element is found in the list. It returns `–1`
    if the desired element is not found in the list. Next, we implement the `jump_search()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly we assign the length of the list to the variable
    `n`, and then we compute the block size as ![](img/B17217_10_003.png). Next, we
    start with the first element, index 0, and then continue searching until we reach
    the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the starting index `i = 0` with a block of size *m*, and we continue
    incrementing until the window reaches the end of the list. We compare whether
    `ordered_list [I + block_size -1] == item`. If they match, it returns the index
    position `(i+ block_size -1)`. The code snippet for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If `ordered_list [i+ block_size -1] > item`, we proceed to carry out the linear
    search algorithm inside the current block `block_array = ordered_list [i : i+
    block_size-1]`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we use the linear search algorithm in the subarray. It returns
    `–1` if the desired element is not found in the list; otherwise, the index position
    of `(i + j)` is returned. Here, `i` is the index position until the previous block
    where we may find the desired element and `j` is the position of the data element
    within the block where the desired element is matched. This process is also depicted
    in *Figure 10.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we can see that `i` is in index position 5, and then `j` is
    the number of elements within the final block where we find the desired element,
    i.e. `2`, so the final returned index will be `5 + 2 = 7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Demonstration of index position i and j for the search value 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we need to check for the length of the last block since it may have
    a number of elements less than the block size. For example, if the total number
    of elements is 11, then in the last block we will have 2 elements. So, we check
    if the desired search element is present in the last block, and if so we should
    update the starting and ending index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we search for the desired element using the linear search
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if `ordered_list[i+m-1] < item`, then we move to the next iteration,
    and update the index by adding the block size to the index as `i += block_size`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code snippet is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above output, we can see the steps for how we searched for element `10`
    in the given list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, jump search performs linear search on a block, so first it finds the block
    in which the element is present and then applies linear search within that block.
    The size of the block depends on the size of the array. If the size of the array
    is `n`, then the block size may be ![](img/B17217_10_003.png). If it does not
    find the element in that block, it moves to the next block. The jump search first
    finds out in which block the desired element may be present. For a list of `n`
    elements, and a block size of *m*, the total number of jumps possible will be
    *n/m* jumps. Let’s say the size of the block is ![](img/B17217_10_003.png); thus,
    the worst-case time complexity will be ![](img/B17217_10_006.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the binary search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **binary search** algorithm finds a given item from the given sorted list
    of items. It is a fast and efficient algorithm to search for an element; however,
    one drawback of this algorithm is that we need a sorted list. The worst-case running
    time complexity of a binary search algorithm is `O(logn)` whereas for linear search
    it is `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm works as follows. It starts searching for the item
    by dividing the given list in half. If the search item is smaller than the middle
    value then it will look for the searched item only in the first half of the list,
    and if the search item is greater than the middle value it will only look at the
    second half of the list. We repeat the same process every time until we find the
    search item, or we have checked the whole list. In the case of a non-numeric list
    of data items, for example, if we have string data items, then we should sort
    the data items in alphabetical order (similar to how a contact list is stored
    on a phone).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the binary search algorithm with an example. Suppose we have
    a book with 1,000 pages, and we want to reach page number 250\. We know that every
    book has its pages numbered sequentially from `1` upward. So, according to the
    binary search analogy, we first check forsearch item 250, which is less than the
    midpoint, which is 500\. Thus, we search for the required page only in the first
    half of the book.
  prefs: []
  type: TYPE_NORMAL
- en: We again find the midpoint of the first half of the book, using page 500 as
    a reference we find the midpoint, 250\. That brings us closer to finding the 250^(th)
    page. Then we find the required page in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example to understand the workings of binary search. We
    want to search for item `43` from a list of 12 items, as shown in *Figure 10.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Working of binary search'
  prefs: []
  type: TYPE_NORMAL
- en: We start searching for the item by comparing it to the middle item of the list,
    which is `37` in the example. If the value of the search item is less than the
    middle value, we only look at the first half of the list; otherwise, we will look
    at the other half. So, we only need to search for the item in the second half.
    We follow the same procedure until we find search item `43` in the list. This
    process is shown in the *Figure 10.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the binary search algorithm on an ordered
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll explain the above code using a list of sorted elements `{10, 30, 100,
    120, 500}`. Now let’s assume we have to find the position where item `10` is located
    in the list shown in *Figure 10.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Sample list of five items'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we declare two variables, i.e. `index_of_first_element` and `index_of_last_element`,
    which denote the starting and ending index positions in the given list. Next,
    the algorithm uses a `while` loop to iteratively adjust the limits in the list
    within which we have to find a search item. The terminating condition to stop
    the `while` loop is that the difference between the starting index, `index_of_first_element`,
    and the `index_of_last_element` index should be positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm first finds the midpoint of the list by adding the index of the
    first element (i.e. `0` in this case) to the index of the last element (which
    is `4` in this example) and dividing it by `2`. We get the middle index, `mid_point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the index of the midpoint is `2`, and the data item stored at
    this position is `100`. We compare the midpoint element with the search item `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these do not match, and the search item `10` is less than the midpoint,
    the desired search item should lie in the first half of the list, thus, we adjust
    the index range of `index_of_first_element` to `mid_point-1`, which means the
    new search range becomes `0` to `1`, as shown in *Figure 10.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Index of first and last elements for the first half of the list'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we had been searching for `120`, as `120` would have been greater
    than the middle value (`100`), we would have searched for the item in the second
    half of the list, and as a result, we would have needed to change the list index
    range to be `mid_point +1` to `index_of_last_element`. In that case the new range
    would have been `(3, 4)`.
  prefs: []
  type: TYPE_NORMAL
- en: So, with the new indexes of the first and last elements, i.e. `index_of_first_element`
    and `index_of_last_element`, now being `0` and `1` respectively, we compute the
    midpoint `(0 + 1)/2`, which equals `0`. The new midpoint is `0`, so we find the
    middle item and compare it with the search item, which yields the value `10`.
    Now, our search item is found, and the index position is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check if `index_of_first_element` is less than `index_of_last_element`
    or not. If this condition fails, it means that the search term is not in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the below code snippet to search for a term/item in the given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly we check the search term `10` in the list, and we
    get the correct location, i.e. index position `0`. Further, we check the index
    position of the string structure in the given sorted list of data items, and we
    get the index position `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation that we have discussed is based on an iterative process.
    However, we can also implement it using the recursive method, in which we recursively
    shift the pointers that point to the beginning (or starting) and end of the search
    list. See the following code for an example of a recursive implementation of the
    binary search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this recursive implementation of the binary search algorithm and
    its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the only distinction between the recursive binary search and the iterative
    binary search is the function definition and also the way in which `mid_point`
    is calculated. The calculation for `mid_point` after the `((last_element_index
    - first_element_index)//2)` operation must add its result to `first_element_index`.
    That way, we define the portion of the list to attempt the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'In binary search, we repeatedly divide the search space (i.e. the list in which
    the desired item may lie) in half. We start with the complete list, and in each
    iteration, we compute the middle point; we only consider half the list to search
    for the item and the other half of the list is ignored. We repeatedly check until
    the value is found, or the interval is empty. Therefore, at each iteration, the
    size of the array reduces by half; for example, at iteration 1, the size of the
    list is `n`, in iteration 2, the size of the list becomes n/2, in iteration 3
    the size of the list becomes n/2², and after *k* iterations the size of the list
    becomes n/2^k. At that time the size of the list will be equal to `1`. That means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the `log` function on both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hence, the binary search algorithm has the worst-case time complexity of `O(log
    n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the interpolation search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary search algorithm is an efficient algorithm for searching. It always
    reduces the search space by half by discarding one half of the search space depending
    on the value of the search item. If the search item is smaller than the value
    in the middle of the list, the second half of the list is discarded from the search
    space. In the case of binary search, we always reduce the search space by a fixed
    value of half, whereas the interpolation search algorithm is an improved version
    of the binary search algorithm in which we use a more efficient method that reduces
    the search space by more than half after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The interpolation search algorithm works efficiently when there are uniformly
    distributed elements in the sorted list. In a binary search, we always start searching
    from the middle of the list, whereas in the interpolation search we compute the
    starting search position depending on the item to be searched. In the interpolation
    search algorithm, the starting search position is most likely to be close to the
    start or end of the list; if the search item is near the first element in the
    list, then the starting search position is likely to be near the start of the
    list and if the search item is near the end of the list, then the starting search
    position is likely to be near the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite similar to how humans perform a search on any list of items. It
    is based on trying to make a good guess of the index position where a search item
    is likely to be found in a sorted list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works in a similar way to the binary search algorithm except for the method
    to determine the splitting criteria to divide the data in order to reduce the
    number of comparisons. In the case of a binary search, we divide the data into
    equal halves and in the case of an interpolation search, we divide the data using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_007.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding formula, `low_index` is the lower-bound index of the list,
    which is the index of the smallest value, and `upper_index` denotes the index
    position of the highest value in the list. The `list[low_index]` and `list[upper_index]`
    are the lowest and highest values respectively in the list. The `search_value`
    variable contains the value of the item that is to be searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example to understand how the interpolation search algorithm
    works using the following list of seven items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Example of interpolation search'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the list of seven items, `44`, `60`, `75`, `100`, `120`, `230`, and `250`,
    the `mid` point can be computed using the above mentioned formula with the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting the values of all the variables in the formula, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `mid` index is `5`, in the case of an interpolation search, so the algorithm
    starts searching from the index position `5`. So, this is how we compute the midpoint
    from which we start searching for the given element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpolation search algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We start searching for the given search value from the midpoint (we have just
    seen how to compute it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value matches the value stored at the index of the midpoint, we
    return this index position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value does not match the value stored at the midpoint, we divide
    the list into two sublists, i.e. a higher sublist and lower sublist. The higher
    sublist has all the elements with higher index values than the midpoint, and the
    lower sublist has all the elements with lower index values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value is greater than the value of the midpoint, we search the
    given search value in the higher sublist and ignore the lower sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search value is lower than the value of the midpoint, we search the given
    search value in the lower sublist and ignore the higher sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat the process until the size of the sublists is reduced to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us understand the implementation of the interpolation search algorithm.
    Firstly, we define the `nearest_mid()` method, which computes the midpoint as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `nearest_mid` function takes, as arguments, the lists on which to perform
    the search. The `low_index` and `upper_index` parameters represent the bounds
    in the list within which we are hoping to find the search term. Furthermore, `search_value`
    represents the value being searched for.
  prefs: []
  type: TYPE_NORMAL
- en: In an interpolation search, the midpoint is generally more to the left or right.
    This is caused by the effect of the multiplier being used when dividing to obtain
    the midpoint. The implementation of the interpolation algorithm remains the same
    as that of the binary search except for the way we compute the midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we provide the implementation of the interpolation search
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we initialize the `low_index` and `upper_index` variables
    for the given sorted list. We firstly compute the midpoint using the `nearest_mid()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The computed midpoint using the `nearest_mid` function may produce values that
    are greater than `upper_bound_index` or lower than `lower_bound_index`. When this
    occurs, it means the search term, `term`, is not in the list. `None` is, therefore,
    returned to represent this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we match the search value with the value stored at the midpoint, i.e.
    `ordered_list[mid_point]`. If that matches, the index of the midpoint is returned;
    if it does not match, then we divide the lists into higher and lower sublists,
    and we readjust `low_index` and `upper_index` so that the algorithm will focus
    on the sublist that is likely to contain the search term similar to what we did
    in the binary search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we check if the search value is greater than the value stored
    at `ordered_list[mid_point]`, then we only adjust the `low_index` variable to
    point to the `mid_point + 1` index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this adjustment occurs. Suppose we want to search for `190` in
    the given list in *Figure 10.10*, then the midpoint will be `4` as per the above
    formula. Then we compare the search value (i.e. `190`) with the value stored at
    the midpoint (i.e. `120`). Since the search value is greater, we search for the
    element in the higher sublist, and readjust the `low_index` value. This is shown
    in *Figure 10.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Readjustment of the low_index when the value of the search item
    is greater than the value at the midpoint'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the value of the search term is less than the value stored
    at `ordered_list[mid_point]`, then we only adjust the `upper_index` variable to
    point to the index `mid_point - 1`. For example, if we have the list shown in
    *Figure 10.11*, and we want to search for `185`, then the midpoint will be `4`
    as per the formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compare the search value (i.e. `185`) with the value stored at the
    midpoint (i.e. `190`). Since the search value is less as compared to `ordered_list[mid_point]`,
    we search for the element in the lower sublist, and readjust the `upper_index`
    value. This is shown in *Figure 10.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Readjustment of the upper_index when the search item is less
    than the value at the midpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s use a more practical example to understand the inner workings of both
    the binary search and interpolation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider for example the following list of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At index 0, the value `2` is stored, and at index `7`, the value `77` is stored.
    Now, assume that we want to find element `2` in the list. How will the two different
    algorithms go about it?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass this list to the `interpolation search` function, then the `nearest_mid`
    function will return a value equal to `0` using the formula of `mid_point` computation,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we get the `mid_point` value `0`, we start the interpolation search with
    the value at index `0`. Just with one comparison, we have found the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the binary search algorithm needs three comparisons to arrive
    at the search term, as illustrated in *Figure 10.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Three comparisons are required to search for the item using the
    binary search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: The first `mid_point` value calculated is `3`. The second `mid_point` value
    is `1` and the last `mid_point` value where the search term is found is `0`. So,
    we reach the desired search item in three comparisons whereas in interpolation
    search we find the desired item on the first attempt.
  prefs: []
  type: TYPE_NORMAL
- en: The interpolation search algorithm works well when the data set is sorted, and
    uniformly distributed. In this case, the average case time complexity is `O(log(log
    n))` in which `n` is the length of the array. Moreover, if the dataset is randomized,
    in that case, the worst-case time complexity of the interpolation search algorithm
    will be `O(n)`. So, interpolation search may work better than binary search if
    the given data is uniformly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exponential search is another search algorithm that is mostly used when we
    have large numbers of elements in a list. Exponential search is also known as
    galloping search and doubling search. The exponential search algorithm works in
    the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a sorted array of `n` data elements, we first determine the subrange in
    the original list where the desired search item may be present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the binary search algorithm to find out the search value within
    the subrange of data elements identified in *step 1*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firstly, in order to find out the subrange of data elements, we start searching
    for the desired item in the given sorted array by jumping 2^i elements every iteration.
    Here, `i` is the value of the index of the array. After each jump, we check if
    the search item is present between the last jump and the current jump. If the
    search item is present then we use the binary search algorithm within this subarray,
    and if it is not present, we move the index to the next location. Therefore, we
    first find the first occurrence of an exponent `i` such that the value at index
    2^i is greater than the search value. Then, the 2^i becomes the lower bound and
    2^i-1 becomes the upper bound for this range of data elements in which the search
    value will be present. The exponential search algorithm is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check the first element `A[0]` with the search element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the index position `i=1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We check two conditions: (1) if it is the end of the array or not (i.e. 2^i
    `<` len(A)), and (2) if `A[i]` `<=` `search_value`). In the first condition, we
    check if we have searched the complete list, and we stop if we have reached the
    end of the list. In the second condition, we stop searching when we reach an element
    whose value is greater than the search value, because it means the desired element
    will be present before this index position (since the list is sorted).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either of the above two conditions is true, we move to the next index position
    by incrementing `i` in powers of `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We stop when either of the two conditions of *step 3* is satisfied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We apply the binary search algorithm on the range 2^i//2 to min (2^i, len(A)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take an example of a sorted array of elements `A = {3, 5, 8, 10, 15, 26,
    35, 45, 56, 80, 120, 125, 138}` in which we want to search for the element `125`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with comparing the first element at index i = 0, i.e. A[0] with the
    search element. Since A[0] < `search_value`, we jump to the next location 2^i
    with i = 0, since A[2⁰] < `search_value`, the condition is true, hence we jump
    to the next location with i = 1 i.e. A`[`22¹`]` < `search_value`. We again jump
    to the next location 2^i with i = 2, since A[2²] < `search_value`, the condition
    is true. We iteratively jump to the next location until we complete searching
    the list or the search value is greater than the value at that location, i.e.
    A[2^i] < len(A) or A[2^i] <= `search_value`. Then we apply the binary search algorithm
    on the range of the subarray. The complete process for searching a given element
    in the sorted array using the exponential search algorithm is depicted in *Figure
    10.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Illustration of the exponential search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us discuss the implementation of the exponential search algorithm.
    Firstly, we implement the binary search algorithm, which we have already discussed
    in the previous section, but for the completeness of this algorithm it is given
    again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, given the ordered list of elements, it returns the index
    of the location where the given data element is found in the list. It returns
    `None` if the desired element is not found in the list. Next, we implement the
    `exponential_search()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, we compare the first element `A[0]` with the search
    value. If it matches then the index position `0` is returned. If that does not
    match, we increase the index position to 2⁰, i.e. 1\. We check `A[1] < search_value`.
    Since the condition is true, we jump to the next location 2¹, i.e. we compare
    `A[2] < search_value`. Since the condition is true, we move to the next location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We iteratively increase the index position in the power of 2 until the stop
    condition is satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when the stopping criteria are met, we use the binary search algorithm
    to search for the desired search value within the subrange as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `exponential_search()` method returns the index position if the
    search value is found in the given array; otherwise, `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code snippet is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the above output, we get index position `12` for the search item `34` in
    the given array.
  prefs: []
  type: TYPE_NORMAL
- en: The exponential search is useful for very large-sized arrays. This is better
    than binary search because instead of performing a binary search on the complete
    array, we find a subarray in which the element may be present and then apply binary
    search, so it reduces the number of comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case time complexity of exponential search is O(log[2]i), where `i`
    is the index where the element to be searched is present. The exponential search
    algorithm can outperform binary search when the desired search element is present
    at the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use exponential search to search in bounded arrays. It can even
    out-perform binary search when the target is near the beginning of the array,
    since exponential search takes `O(log(i))` time whereas the binary search takes
    `O(logn)` time, where `n` is the total number of elements. The best-case complexity
    of exponential search is `O(1)`, when the element is present at the first location
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us discuss how to decide which search algorithm we should choose for
    a given situation.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered the different types of search algorithms, we can look
    into which ones work better and in what situations. The binary search and interpolation
    search algorithms are better in performance compared to both ordered and unordered
    linear search functions. The linear search algorithm is slower because of the
    sequential probing of elements in the list to find the search term.
  prefs: []
  type: TYPE_NORMAL
- en: Linear search has a time complexity of `O(n)`. The linear search algorithm does
    not perform well when the given list of data elements is large.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search operation, on the other hand, slices the list in two anytime
    a search is attempted. On each iteration, we approach the search term much faster
    than in a linear strategy. The time complexity yields `O(logn)`. The binary search
    algorithm performs well but the drawback of it is that it requires a sorted list
    of elements. So, if the given data elements are short and unsorted then it is
    better to use the linear search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation search discards more than half of the list of items from the search
    space, and this gives it the ability to get to the portion of the list that holds
    a search term more efficiently. In the interpolation search algorithm, the midpoint
    is computed in such a way that it gives a higher probability of obtaining the
    search term faster. The average-case time complexity of interpolation search is
    `O(log(logn))`, whereas the worst-case time complexity of the interpolation search
    algorithm is `O(n)`. This shows that interpolation search is better than binary
    search and provides faster searching in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if the list is short and unsorted, then the linear search algorithm
    is suitable, and if the list is sorted and not very big then the binary search
    algorithm can be used. Further, the interpolation search algorithm is good to
    use if the data elements in the list are uniformly distributed. If the list is
    very large, then the exponential search algorithm and jump search algorithm can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the concept of searching for a given element from
    a list of data elements. We discussed several important search algorithms, such
    as linear search, binary search, jump search, interpolation search, and exponential
    search. The implementations of these algorithms were discussed using Python in
    detail. We will be discussing sorting algorithms in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On average, how many comparisons are required in a linear search of `n` elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume there are eight elements in a sorted array. What is the average number
    of comparisons that will be required if all the searches are successful and if
    the binary search algorithm is used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the worst-case time complexity of the binary search algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should the interpolation search algorithm perform better than the binary
    search algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
