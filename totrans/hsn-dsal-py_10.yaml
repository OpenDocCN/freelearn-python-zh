- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Searching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: An important operation for all data structures is searching for elements from
    a collection of data. There are various methods to search for an element in data
    structures; in this chapter, we shall explore the different strategies that can
    be used to find elements in a collection of items.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有数据结构来说，从数据集合中搜索元素是一项重要操作。有各种方法可以在数据结构中搜索元素；在本章中，我们将探讨可以用于在项集合中查找元素的不同策略。
- en: Data elements can be stored in any kind of data structure, such as an array,
    link list, tree, or graph; the search operation is very important for many applications,
    mostly whenever we want to know if a particular data element is present in an
    existing list of data items. In order to retrieve the information efficiently,
    we require an efficient search algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据元素可以存储在任何类型的数据结构中，如数组、链表、树或图；搜索操作对于许多应用非常重要，尤其是在我们想知道特定数据元素是否存在于现有数据项列表中时。为了有效地检索信息，我们需要一个高效的搜索算法。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Various search algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种搜索算法
- en: Linear search algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索算法
- en: Jump search algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃搜索算法
- en: Binary search algorithm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索算法
- en: Interpolation search algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值搜索算法
- en: Exponential search algorithm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数搜索算法
- en: Let us start with an introduction to searching and a definition and then look
    at the linear search algorithm.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从搜索的简介和定义开始，然后查看线性搜索算法。
- en: Introduction to searching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索简介
- en: A search operation is carried out to find the location of the desired data item
    from a collection of data items. The search algorithm returns the location of
    the searched value where it is present in the list of items and if the data item
    is not present, it returns `None`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 执行搜索操作以从数据项集合中查找所需数据项的位置。搜索算法返回搜索值的列表位置，如果数据项不在列表中，则返回 `None`。
- en: Efficient searching is important to efficiently retrieve the location of the
    desired data item from a list of stored data items. For example, we have a long
    list of data values, such as `{1, 45, 65, 23, 65, 75, 23}`, and we want to see
    if `75` is present in the list or not. It becomes important to have an efficient
    search algorithm when the list of data items becomes large.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 高效搜索对于从存储数据项的列表中高效检索所需数据项的位置至关重要。例如，我们有一个包含数据值的长列表，例如 `{1, 45, 65, 23, 65, 75,
    23}`，我们想知道 `75` 是否在列表中。当数据项列表变得很大时，拥有一个高效的搜索算法变得非常重要。
- en: 'There are two different ways in which data can be organized, which can affect
    how a search algorithm works:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以两种不同的方式组织，这可能会影响搜索算法的工作方式：
- en: First, the search algorithm is applied to a list of items that is already sorted;
    that is, it is applied to an ordered set of items. For example, `[1, 3, 5, 7,
    9, 11, 13, 15, 17]`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，搜索算法应用于已经排序的项列表；也就是说，它应用于有序的项集。例如，`[1, 3, 5, 7, 9, 11, 13, 15, 17]`。
- en: The search algorithm is applied to an unordered set of items, which is not sorted.
    For example, `[11, 3, 45, 76, 99, 11, 13, 35, 37]`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索算法应用于未排序的项集，即未排序的列表。例如，`[11, 3, 45, 76, 99, 11, 13, 35, 37]`。
- en: We will first take a look at linear searching.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨线性搜索。
- en: Linear search
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: The search operation is used to find out the index position of a given data
    item in a list of data items. If the searched item is available in the given list
    of data items, then the search algorithm returns the index position where it is
    located; otherwise, it returns that the item is not found. Here, the index position
    is the location of the desired item in the given list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索操作用于在数据项列表中查找给定数据项的索引位置。如果搜索项在给定的数据项列表中可用，则搜索算法返回其所在位置的索引位置；否则，返回该项未找到。在这里，索引位置是所需项在给定列表中的位置。
- en: 'The simplest approach to search for an item in a list is to search linearly,
    in which we look for items one by one in the whole list. Let’s take an example
    of six list items `{60, 1, 88, 10, 11, 100}` to understand the linear search algorithm,
    as shown in *Figure 10.1*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中搜索项的最简单方法是线性搜索，其中我们逐个在整个列表中查找项。让我们以六个列表项 `{60, 1, 88, 10, 11, 100}` 的例子来了解线性搜索算法，如图
    *图10.1* 所示：
- en: '![](img/B17217_10_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_01.png)'
- en: 'Figure 10.1: An example of linear search'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：线性搜索的例子
- en: The preceding list has elements that can be accessed through the index. To find
    an element in the list, we can search for the given element linearly one by one.
    This technique traverses the list of elements by using the index to move from
    the beginning of the list to the end. Each element is checked, and if it does
    not match the search item, the next item is examined. By hopping from one item
    to the next, the list is traversed sequentially. We use list items with integer
    values in this chapter to help you understand the concept, since integers can
    be compared easily; however, a list item can hold any other data type as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中的元素可以通过索引访问。要找到列表中的元素，我们可以逐个线性地搜索给定的元素。这种技术通过使用索引从列表的开始移动到末尾来遍历元素列表。每个元素都会进行检查，如果它与搜索项不匹配，则检查下一个项目。通过从一个项目跳到下一个项目，列表被顺序遍历。在本章中，我们使用具有整数值的列表项来帮助您理解这个概念，因为整数可以很容易地进行比较；然而，列表项也可以持有任何其他数据类型。
- en: The linear search approach depends on how the list items are stored in memory—whether
    they are already sorted in order or they are not sorted. Let’s first see how the
    linear search algorithm works if the given list of items is not sorted.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索方法依赖于列表项在内存中的存储方式——它们是否已经按顺序排序，或者它们是否未排序。让我们首先看看如果给定的项目列表未排序，线性搜索算法是如何工作的。
- en: Unordered linear search
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无序线性搜索
- en: The unordered linear search is a linear search algorithm in which the given
    list of date items is not sorted. We linearly match the desired data item with
    the data items of the list one by one till the end of the list or until the desired
    data item is found. Consider an example list that contains the elements `60`,
    `1`, `88`, `10`, and `100`—an unordered list. To perform a `search` operation
    on such a list, one proceeds with the first item and compares that with the search
    item. If the search item is not matched, then the next element in the list is
    checked. This continues till we reach the last element in the list or until a
    match is found.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无序线性搜索是一种线性搜索算法，其中给定的日期项目列表未排序。我们逐个将所需数据项与列表中的数据项进行线性匹配，直到列表末尾或找到所需数据项为止。考虑一个包含元素
    `60`、`1`、`88`、`10` 和 `100` 的示例列表——一个无序列表。要对这样的列表执行 `搜索` 操作，从第一个项目开始，将其与搜索项进行比较。如果搜索项不匹配，则检查列表中的下一个元素。这个过程一直持续到我们到达列表的最后一个元素或找到匹配项。
- en: 'In an unordered list of items, the search for the term `10` starts from the
    first element and moves to the next element in the list. Thus, firstly `60` is
    compared with `10`, and since it is not equal, we compare `66` with the next element
    `1`, then `88`, and so on till we find the search term in the list. Once the item
    is found, we return the index position of where we have found the desired item.
    This process is shown in *Figure 10.2*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个无序的项目列表中，对 `10` 的搜索从第一个元素开始，并移动到列表中的下一个元素。因此，首先将 `60` 与 `10` 进行比较，由于它们不相等，我们将
    `66` 与下一个元素 `1` 进行比较，然后是 `88`，依此类推，直到我们在列表中找到搜索项。一旦找到项目，我们就返回找到所需项目的索引位置。这个过程在
    *图10.2* 中显示：
- en: '![](img/B17217_10_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_02.png)'
- en: 'Figure 10.2: Unordered linear search'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：无序线性搜索
- en: 'Here is the implementation in Python for the linear search on an unordered
    list of items:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是线性搜索在无序项目列表中的Python实现：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `search` function takes two parameters; the first is the list that holds
    the data, and the second parameter is the item that we are looking for, called
    the **search term**. On every pass of the `for` loop, we check if the search term
    is equal to the indexed item. If this is true, then there is a match, and there
    is no need to proceed further with the search. We return the index position where
    the searched item is found in the list. If the loops run to the end of the list
    with no match found, then `None` is returned to signify that there is no such
    item in the list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`搜索` 函数接受两个参数；第一个是包含数据的列表，第二个参数是我们正在寻找的项目，称为 **搜索项**。在 `for` 循环的每次迭代中，我们检查搜索项是否等于索引项。如果是这样，则存在匹配项，无需进一步进行搜索。我们返回在列表中找到搜索项的索引位置。如果循环运行到列表末尾而没有找到匹配项，则返回
    `None` 以表示列表中没有这样的项。'
- en: 'We can use the following code snippet to check if a desired data element is
    present in the given list of data items:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段来检查所需数据元素是否存在于给定的数据项列表中：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the above code is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the output of the above code, firstly, the index position `3` is returned
    when we search for data element `10` in `list1`. And secondly, index position
    `2` is returned when data item `'data'` is searched for in `list2`. We can use
    the same algorithm for searching a non-numeric data item from a list of non-numeric
    data items in Python, since string elements can also be compared similarly to
    numeric data in Python.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的输出中，首先，当我们搜索`list1`中的数据元素`10`时，返回索引位置`3`。其次，当我们搜索`list2`中的数据项`'data'`时，返回索引位置`2`。由于Python中的字符串元素也可以与数值数据类似进行比较，因此我们可以使用相同的算法在Python中从非数值数据列表中搜索非数值数据项。
- en: When searching for any element from an unordered list of items, in the worst
    case the desired item may be in the last position or may not be present in the
    list. In this situation we will have to compare the search item with all the elements
    of the list, i.e. `n` times if the total number of data items in the list is `n`.
    Thus, the unordered linear search has a worst-case running time of `O(n)`. All
    the elements may need to be visited before finding the search term. The worst-case
    scenario will be when the search term is located at the last position of the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当从无序项目列表中搜索任何元素时，在最坏的情况下，所需的项目可能在列表的最后一个位置，或者可能不在列表中。在这种情况下，我们必须将搜索项与列表中的所有元素进行比较，即如果列表中的数据项总数是`n`，则需要比较`n`次。因此，无序线性搜索的最坏情况运行时间为`O(n)`。在找到搜索项之前可能需要访问所有元素。最坏的情况是搜索项位于列表的最后一个位置。
- en: Next, we discuss how the linear search algorithm works if the given list of
    data items is already sorted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论如果给定的数据项列表已经排序，线性搜索算法是如何工作的。
- en: Ordered linear search
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有序线性搜索
- en: 'If the data elements are already arranged in a sorted order, then the linear
    search algorithm can be improved. The linear search algorithm in a sorted list
    of elements has the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据元素已经按排序顺序排列，则可以改进线性搜索算法。在排序元素列表中的线性搜索算法有以下步骤：
- en: Move through the list sequentially
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顺序遍历列表
- en: If the value of a search item is greater than the object or item currently under
    inspection in the loop, then quit and return `None`
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索项的值大于循环中当前检查的对象或项，则退出并返回`None`
- en: 'In the process of iterating through the list, if the value of the search term
    is less than the current item in the list, then there is no need to continue with
    the search. Let’s consider an example to see how this works. Let’s say we have
    a list of items `{2, 3, 4, 6, 7}` as shown in *Figure 10.3*, and we want to search
    for term `5`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历列表的过程中，如果搜索项的值小于列表中的当前项，则无需继续搜索。让我们通过一个例子来看看这是如何工作的。假设我们有一个项目列表`{2, 3, 4,
    6, 7}`，如*图10.3*所示，我们想要搜索项`5`：
- en: '![](img/B17217_10_03.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_03.png)'
- en: 'Figure 10.3: Example of ordered linear search'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：有序线性搜索的示例
- en: We start the `search` operation by comparing the desired search element `5`
    with the first element; no match is found. We continue on to compare the search
    element with the next element, i.e. `3`, in the list. Since it also does not match,
    we move on to examine the next element, i.e. `4`, and since it also does not match,
    we continue searching in the list, and we compare the search element with the
    fourth element, i.e. `6`. This also does not match the search term. Since the
    given list is already sorted in ascending order and the value of the search item
    is less than the fourth element, the search item cannot be found in any later
    position in the list. In other words, if the current item in the list is greater
    than the search term, then it means there is no need to further search the list,
    and we stop searching for the element in the list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过比较所需的搜索元素`5`与列表中的第一个元素开始`search`操作；没有找到匹配项。我们继续将搜索元素与列表中的下一个元素，即`3`进行比较。由于它也不匹配，我们继续检查下一个元素，即`4`，由于它也不匹配，我们继续在列表中搜索，并将搜索元素与第四个元素，即`6`进行比较。这也不匹配搜索项。由于给定的列表已经按升序排序，且搜索项的值小于第四个元素，因此搜索项不可能在列表的任何后续位置找到。换句话说，如果列表中的当前项大于搜索项，那么这意味着无需进一步搜索列表，我们停止在列表中搜索该元素。
- en: 'Here is the implementation of the linear search when the list is already sorted:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当列表已经排序时线性搜索的实现：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the `if` statement now caters to checking if the search
    item is found in the list or not. Then, `elif` tests the condition where `ordered_list[i]
    > term`. We stop searching if the comparison evaluates to `True`, which means
    the current item in the list is greater than the search element. The last line
    in the method returns `None` because the loop may go through the list and still
    the search item is not matched in the list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，现在的`if`语句用于检查搜索项是否在列表中找到。然后，`elif`测试`ordered_list[i] > term`的条件。如果比较结果为`True`，则停止搜索，这意味着列表中的当前项大于搜索元素。该方法中的最后一行返回`None`，因为循环可能遍历整个列表，但搜索项仍然在列表中找不到。
- en: 'We use the following code snippet to use the search algorithm:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码片段来使用搜索算法：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the above code is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the output of the above code, firstly, the search item `5` is not matched
    in the given list. And for the second list of non-numeric data elements, the string
    structure is matched at index position `3`. Hence, we can use the same linear
    search algorithm for searching a non-numeric data item from an ordered list of
    data items, so the given list of data items should be sorted similarly to a contact
    list on a phone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的输出中，首先，搜索项`5`在给定的列表中不匹配。对于第二个非数值数据元素的列表，字符串结构在索引位置`3`处匹配。因此，我们可以使用相同的线性搜索算法从有序数据项列表中搜索非数值数据项，所以给定的数据项列表应该与电话簿上的联系人列表类似地排序。
- en: In the worst-case scenario, the desired search item will be present in the last
    position of the list or will not be present at all. In this situation, we will
    have to trace the complete list (say `n` elements). Thus, the worst-case time
    complexity of an ordered linear search is `O(n)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，所需的搜索项将位于列表的最后一个位置或根本不存在。在这种情况下，我们必须遍历整个列表（例如`n`个元素）。因此，有序线性搜索的最坏情况时间复杂度为`O(n)`。
- en: Next, we will discuss the jump search algorithm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论跳跃搜索算法。
- en: Jump search
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃搜索
- en: The **jump search** algorithm is an improvement over linear search for searching
    for a given element from an ordered (or sorted) list of elements. This uses the
    divide-and-conquer strategy in order to search for the required element. In linear
    search, we compare the search value with each element of the list, whereas in
    jump search, we compare the search value at different intervals in the list, which
    reduces the number of comparisons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳跃搜索**算法是在有序（或排序）元素列表中搜索给定元素时对线性搜索的改进。它使用分而治之的策略来搜索所需元素。在线性搜索中，我们比较搜索值与列表中的每个元素，而在跳跃搜索中，我们在列表的不同间隔处比较搜索值，这减少了比较的次数。'
- en: 'In this algorithm, firstly, we divide the sorted list of data into subsets
    of data elements called blocks. Within each block, the highest value will lie
    within the last element, as the array is sorted. Next, in this algorithm, we start
    comparing the search value with the last element of each block. There can be three
    conditions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此算法中，首先，我们将排序后的数据列表划分为数据元素子集，称为块。在每一个块中，最高值将位于最后一个元素，因为数组是有序的。接下来，在此算法中，我们开始将搜索值与每个块的最后一个元素进行比较。可能有三种情况：
- en: If the search value is less than the last element of the block, we compare it
    with the next block.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值小于块的最后一个元素，我们将其与下一个块进行比较。
- en: If the search value is greater than the last element of the block, it means
    the desired search value must be present in the current block. So, we apply linear
    search in this block and return the index position.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值大于块的最后一个元素，这意味着所需的搜索值必须存在于当前块中。因此，我们在该块中应用线性搜索并返回索引位置。
- en: If the search value is the same as the compared element of the block, we return
    the index position of the element and we return the candidate.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值与块的比较元素相同，我们返回元素的索引位置并返回候选者。
- en: Generally, the size of the block is taken as ![](img/B17217_10_001.png), since
    it gives the best performance for a given array of length `n`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，块的大小取为![](img/B17217_10_001.png)，因为它为给定长度为`n`的数组提供了最佳性能。
- en: In the worst-case situation, we will have to make *n/m* number of jumps (here,
    `n` is the total number of elements, and *m* is the block size) if the last element
    of the last block is greater than the item to be searched, and we will need *m*
    - 1 comparisons for linear search in the last block. Therefore, the total number
    of comparisons will be ((*n/m*) + *m* - 1), which will minimize when *m* = *√n*
    . So the size of the block is taken as *√n* since it gives the best performance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，如果最后一个块的最后一个元素大于要搜索的项，我们将需要执行*n/m*次跳跃（这里，`n`是元素总数，*m*是块大小），并且我们需要在最后一个块中进行*m*
    - 1次线性搜索比较。因此，总的比较次数将是((*n/m*) + *m* - 1)，当*m* = *√n*时将最小化。所以块的大小被取为*√n*，因为它提供了最佳性能。
- en: 'Let’s take an example list `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}` to search
    for a given element (say `10`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个示例列表`{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}`为例来搜索一个给定的元素（比如说`10`）：
- en: '![](img/B17217_10_04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_04.png)'
- en: 'Figure 10.4: Illustration of the jump search algorithm'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：跳转搜索算法的示意图
- en: In the above example, we find the desired element `10` in `5` comparisons. Firstly,
    we compare the first value of the array with the desired item `A[0] <= item`;
    if it is true, then we increase the index by the block size (this is shown in
    *step 1* in *Figure 10.4*). Next, we compare the desired item with the last element
    of each block. If it is greater, then we move to the next block, such as from
    block 1 to block 3 (this is shown in *steps 2*, *3*, and *4* in *Figure 10.4*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们在`5`次比较中找到了所需的元素`10`。首先，我们将数组的第一个值与所需的项`A[0] <= item`进行比较；如果是真的，那么我们增加索引以块大小（这在*图10.4*中的*步骤1*中显示）。接下来，我们将所需的项与每个块的最后一个元素进行比较。如果它更大，那么我们就移动到下一个块，例如从块1到块3（这在*图10.4*中的*步骤2*、*步骤3*和*步骤4*中显示）。
- en: Further, when the desired search element becomes smaller than the last element
    of a block, we stop incrementing the index position and then we do the linear
    search in the current block. Now, let us discuss the implementation of the jump
    searching algorithms. Firstly, we implement the linear search algorithm, which
    is similar to what we discussed in the previous section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当所需的搜索元素小于一个块的最后一个元素时，我们停止增加索引位置，然后在当前块中进行线性搜索。现在，让我们讨论跳转搜索算法的实现。首先，我们实现线性搜索算法，这与我们在上一节中讨论的类似。
- en: 'It is given again here for the sake of completeness as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，再次给出如下：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the above code, given an ordered list of elements, it returns the index
    of the location where a given data element is found in the list. It returns `–1`
    if the desired element is not found in the list. Next, we implement the `jump_search()`
    method as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，给定一个有序元素列表，它返回给定数据元素在列表中找到的位置的索引。如果所需的元素在列表中未找到，则返回`–1`。接下来，我们按照以下方式实现`jump_search()`方法：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the above code, firstly we assign the length of the list to the variable
    `n`, and then we compute the block size as ![](img/B17217_10_003.png). Next, we
    start with the first element, index 0, and then continue searching until we reach
    the end of the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，首先我们将列表的长度赋值给变量`n`，然后我们计算块大小如![](img/B17217_10_003.png)。接下来，我们从第一个元素，索引0开始，然后继续搜索直到我们到达列表的末尾。
- en: 'We start with the starting index `i = 0` with a block of size *m*, and we continue
    incrementing until the window reaches the end of the list. We compare whether
    `ordered_list [I + block_size -1] == item`. If they match, it returns the index
    position `(i+ block_size -1)`. The code snippet for this is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从起始索引`i = 0`和一个大小为*m*的块开始，我们继续增加直到窗口达到列表的末尾。我们比较`ordered_list [I + block_size
    -1] == item`。如果它们匹配，它返回索引位置`(i+ block_size -1)`。这个代码片段如下：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If `ordered_list [i+ block_size -1] > item`, we proceed to carry out the linear
    search algorithm inside the current block `block_array = ordered_list [i : i+
    block_size-1]`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`ordered_list [i+ block_size -1] > item`，我们就在当前块`block_array = ordered_list
    [i : i+ block_size-1]`内部执行线性搜索算法，如下所示：'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the above code, we use the linear search algorithm in the subarray. It returns
    `–1` if the desired element is not found in the list; otherwise, the index position
    of `(i + j)` is returned. Here, `i` is the index position until the previous block
    where we may find the desired element and `j` is the position of the data element
    within the block where the desired element is matched. This process is also depicted
    in *Figure 10.5*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在子数组中使用线性搜索算法。如果列表中找不到所需元素，则返回`-1`；否则，返回`(i + j)`的索引位置。在这里，`i`是可能找到所需元素的上一块的索引位置，而`j`是匹配所需元素的数据元素在块中的位置。这个过程也如图*10.5*所示。
- en: 'In this figure, we can see that `i` is in index position 5, and then `j` is
    the number of elements within the final block where we find the desired element,
    i.e. `2`, so the final returned index will be `5 + 2 = 7`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，我们可以看到`i`位于索引位置5，然后`j`是最终块中我们找到所需元素的数据元素数量，即`2`，因此最终返回的索引将是`5 + 2 = 7`：
- en: '![](img/B17217_10_05.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17217_10_05.png](img/B17217_10_05.png)'
- en: 'Figure 10.5: Demonstration of index position i and j for the search value 8'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：演示搜索值8的索引位置i和j
- en: 'Further, we need to check for the length of the last block since it may have
    a number of elements less than the block size. For example, if the total number
    of elements is 11, then in the last block we will have 2 elements. So, we check
    if the desired search element is present in the last block, and if so we should
    update the starting and ending index as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要检查最后一个块的长度，因为它可能包含的元素数量少于块大小。例如，如果元素总数是11，那么在最后一个块中我们将有2个元素。因此，我们检查所需搜索元素是否在最后一个块中，如果是，则应更新起始和结束索引如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above code, we search for the desired element using the linear search
    algorithm.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用线性搜索算法来查找所需元素。
- en: Finally, if `ordered_list[i+m-1] < item`, then we move to the next iteration,
    and update the index by adding the block size to the index as `i += block_size`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`ordered_list[i+m-1] < item`，则我们移动到下一次迭代，并将块大小加到索引上作为`i += block_size`。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the above code snippet is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出是：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above output, we can see the steps for how we searched for element `10`
    in the given list of elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到我们如何在给定的元素列表中搜索元素`10`的步骤。
- en: Thus, jump search performs linear search on a block, so first it finds the block
    in which the element is present and then applies linear search within that block.
    The size of the block depends on the size of the array. If the size of the array
    is `n`, then the block size may be ![](img/B17217_10_003.png). If it does not
    find the element in that block, it moves to the next block. The jump search first
    finds out in which block the desired element may be present. For a list of `n`
    elements, and a block size of *m*, the total number of jumps possible will be
    *n/m* jumps. Let’s say the size of the block is ![](img/B17217_10_003.png); thus,
    the worst-case time complexity will be ![](img/B17217_10_006.png).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，跳跃搜索在块上执行线性搜索，所以首先它找到包含该元素的块，然后在该块内应用线性搜索。块的大小取决于数组的大小。如果数组的大小是`n`，那么块的大小可能是![img/B17217_10_003.png](img/B17217_10_003.png)。如果在该块中找不到元素，它将移动到下一个块。跳跃搜索首先找出所需元素可能存在的块。对于`n`个元素的列表和一个块大小为`m`，可能的跳跃总数将是`n/m`次跳跃。假设块的大小是![img/B17217_10_003.png](img/B17217_10_003.png)；因此，最坏情况下的时间复杂度将是![img/B17217_10_006.png](img/B17217_10_006.png)。
- en: Next, we will discuss the binary search algorithm.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论二分搜索算法。
- en: Binary search
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: The **binary search** algorithm finds a given item from the given sorted list
    of items. It is a fast and efficient algorithm to search for an element; however,
    one drawback of this algorithm is that we need a sorted list. The worst-case running
    time complexity of a binary search algorithm is `O(logn)` whereas for linear search
    it is `O(n)`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**二分搜索**算法从给定的排序元素列表中查找给定项。这是一个快速且高效的搜索元素算法；然而，该算法的一个缺点是我们需要一个排序的列表。二分搜索算法的最坏情况运行时间复杂度是`O(logn)`，而线性搜索是`O(n)`。'
- en: The binary search algorithm works as follows. It starts searching for the item
    by dividing the given list in half. If the search item is smaller than the middle
    value then it will look for the searched item only in the first half of the list,
    and if the search item is greater than the middle value it will only look at the
    second half of the list. We repeat the same process every time until we find the
    search item, or we have checked the whole list. In the case of a non-numeric list
    of data items, for example, if we have string data items, then we should sort
    the data items in alphabetical order (similar to how a contact list is stored
    on a phone).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找算法的工作原理如下。它通过将给定的列表分成两半来开始搜索项。如果搜索项小于中间值，它将只在列表的前半部分查找搜索项，如果搜索项大于中间值，它将只查看列表的后半部分。我们重复这个过程，直到找到搜索项，或者我们检查了整个列表。在非数值数据项的列表中，例如，如果我们有字符串数据项，我们应该按字母顺序对数据项进行排序（类似于手机上存储的联系人列表）。
- en: Let’s understand the binary search algorithm with an example. Suppose we have
    a book with 1,000 pages, and we want to reach page number 250\. We know that every
    book has its pages numbered sequentially from `1` upward. So, according to the
    binary search analogy, we first check forsearch item 250, which is less than the
    midpoint, which is 500\. Thus, we search for the required page only in the first
    half of the book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解二分查找算法。假设我们有一本有1,000页的书，我们想要找到第250页。我们知道每本书的页码都是从`1`开始顺序编号的。所以，根据二分查找的类比，我们首先查找编号为250的页面，这个编号小于中点，即500。因此，我们只需在书的前半部分查找所需的页面。
- en: We again find the midpoint of the first half of the book, using page 500 as
    a reference we find the midpoint, 250\. That brings us closer to finding the 250^(th)
    page. Then we find the required page in the book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次找到书前半部分的中点，以页面500为参考，我们找到中点，即250。这使我们更接近找到第250页。然后我们在书中找到所需的页面。
- en: 'Let’s take another example to understand the workings of binary search. We
    want to search for item `43` from a list of 12 items, as shown in *Figure 10.6*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子来理解二分查找的工作原理。我们想要在*图10.6*所示的12个项目列表中搜索项目`43`：
- en: '![](img/B17217_10_06.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_06.png)'
- en: 'Figure 10.6: Working of binary search'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：二分查找的工作原理
- en: We start searching for the item by comparing it to the middle item of the list,
    which is `37` in the example. If the value of the search item is less than the
    middle value, we only look at the first half of the list; otherwise, we will look
    at the other half. So, we only need to search for the item in the second half.
    We follow the same procedure until we find search item `43` in the list. This
    process is shown in the *Figure 10.6*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将搜索项与列表的中间项进行比较来开始搜索，例如，在例子中是`37`。如果搜索项的值小于中间值，我们只查看列表的前半部分；否则，我们将查看另一半。所以，我们只需在第二半部分搜索该项。我们遵循相同的程序，直到我们在列表中找到搜索项`43`。这个过程在*图10.6*中显示。
- en: 'The following is an implementation of the binary search algorithm on an ordered
    list of items:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是二分查找算法在有序列表上的实现：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll explain the above code using a list of sorted elements `{10, 30, 100,
    120, 500}`. Now let’s assume we have to find the position where item `10` is located
    in the list shown in *Figure 10.7*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用排序元素列表`{10, 30, 100, 120, 500}`来解释上面的代码。现在假设我们必须要找到*图10.7*中显示的列表中项目`10`的位置：
- en: '![](img/B17217_10_07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_07.png)'
- en: 'Figure 10.7: Sample list of five items'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：五个项目的示例列表
- en: Firstly, we declare two variables, i.e. `index_of_first_element` and `index_of_last_element`,
    which denote the starting and ending index positions in the given list. Next,
    the algorithm uses a `while` loop to iteratively adjust the limits in the list
    within which we have to find a search item. The terminating condition to stop
    the `while` loop is that the difference between the starting index, `index_of_first_element`,
    and the `index_of_last_element` index should be positive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个变量，即`index_of_first_element`和`index_of_last_element`，它们表示给定列表中的起始和结束索引位置。接下来，算法使用`while`循环来迭代调整列表中的限制，在列表中查找搜索项。停止`while`循环的条件是起始索引`index_of_first_element`和`index_of_last_element`索引之间的差值应该是正数。
- en: 'The algorithm first finds the midpoint of the list by adding the index of the
    first element (i.e. `0` in this case) to the index of the last element (which
    is `4` in this example) and dividing it by `2`. We get the middle index, `mid_point`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先通过将第一个元素的索引（即本例中的`0`）与最后一个元素的索引（在本例中为`4`）相加并除以`2`来找到列表的中间点。我们得到中间索引`mid_point`：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the index of the midpoint is `2`, and the data item stored at
    this position is `100`. We compare the midpoint element with the search item `10`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，中间点的索引是`2`，存储在此位置的的数据项是`100`。我们将中间元素与搜索项`10`进行比较。
- en: 'Since these do not match, and the search item `10` is less than the midpoint,
    the desired search item should lie in the first half of the list, thus, we adjust
    the index range of `index_of_first_element` to `mid_point-1`, which means the
    new search range becomes `0` to `1`, as shown in *Figure 10.8*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些不匹配，并且搜索项`10`小于中点，因此所需的搜索项应该位于列表的前半部分，因此，我们将`index_of_first_element`的索引范围调整为`mid_point-1`，这意味着新的搜索范围变为`0`到`1`，如图*10.8*所示：
- en: '![](img/B17217_10_08.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_10_08.png)'
- en: 'Figure 10.8: Index of first and last elements for the first half of the list'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：列表前半部分的第一个和最后一个元素的索引
- en: However, if we had been searching for `120`, as `120` would have been greater
    than the middle value (`100`), we would have searched for the item in the second
    half of the list, and as a result, we would have needed to change the list index
    range to be `mid_point +1` to `index_of_last_element`. In that case the new range
    would have been `(3, 4)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们正在搜索`120`，因为`120`将大于中间值（`100`），我们将在列表的后半部分搜索该项，因此，我们需要将列表索引范围更改为`mid_point
    +1`到`index_of_last_element`。在这种情况下，新的范围将是`(3, 4)`。
- en: So, with the new indexes of the first and last elements, i.e. `index_of_first_element`
    and `index_of_last_element`, now being `0` and `1` respectively, we compute the
    midpoint `(0 + 1)/2`, which equals `0`. The new midpoint is `0`, so we find the
    middle item and compare it with the search item, which yields the value `10`.
    Now, our search item is found, and the index position is returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着新的第一个和最后一个元素的索引，即`index_of_first_element`和`index_of_last_element`，现在分别是`0`和`1`，我们计算中点`(0
    + 1)/2`，等于`0`。新的中点是`0`，因此我们找到中间项并将其与搜索项进行比较，得到值`10`。现在，我们的搜索项已找到，并返回索引位置。
- en: Finally, we check if `index_of_first_element` is less than `index_of_last_element`
    or not. If this condition fails, it means that the search term is not in the list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查`index_of_first_element`是否小于`index_of_last_element`。如果这个条件不成立，这意味着搜索项不在列表中。
- en: 'We can use the below code snippet to search for a term/item in the given list:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段在给定列表中搜索一个术语/项：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the above code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above code, firstly we check the search term `10` in the list, and we
    get the correct location, i.e. index position `0`. Further, we check the index
    position of the string structure in the given sorted list of data items, and we
    get the index position `3`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先我们在列表中检查搜索项`10`，并得到正确的位置，即索引位置`0`。进一步，我们检查给定排序数据项列表中字符串结构的索引位置，并得到索引位置`3`。
- en: 'The implementation that we have discussed is based on an iterative process.
    However, we can also implement it using the recursive method, in which we recursively
    shift the pointers that point to the beginning (or starting) and end of the search
    list. See the following code for an example of a recursive implementation of the
    binary search algorithm:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的实现是基于一个迭代过程。然而，我们也可以使用递归方法来实现它，在这种方法中，我们递归地移动指向搜索列表开始（或起始）和结束的指针。以下代码展示了二分搜索算法递归实现的示例：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A call to this recursive implementation of the binary search algorithm and
    its output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对此递归实现的二分搜索算法及其输出的调用如下：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the above code is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the only distinction between the recursive binary search and the iterative
    binary search is the function definition and also the way in which `mid_point`
    is calculated. The calculation for `mid_point` after the `((last_element_index
    - first_element_index)//2)` operation must add its result to `first_element_index`.
    That way, we define the portion of the list to attempt the search.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，递归二分搜索和迭代二分搜索之间的唯一区别是函数定义以及`mid_point`的计算方式。在`((last_element_index - first_element_index)//2)`操作之后的`mid_point`计算必须将结果加到`first_element_index`上。这样，我们定义了尝试搜索的列表部分。
- en: 'In binary search, we repeatedly divide the search space (i.e. the list in which
    the desired item may lie) in half. We start with the complete list, and in each
    iteration, we compute the middle point; we only consider half the list to search
    for the item and the other half of the list is ignored. We repeatedly check until
    the value is found, or the interval is empty. Therefore, at each iteration, the
    size of the array reduces by half; for example, at iteration 1, the size of the
    list is `n`, in iteration 2, the size of the list becomes n/2, in iteration 3
    the size of the list becomes n/2², and after *k* iterations the size of the list
    becomes n/2^k. At that time the size of the list will be equal to `1`. That means:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在二分搜索中，我们反复将搜索空间（即可能包含所需项目的列表）分成两半。我们从一个完整的列表开始，并在每次迭代中计算中间点；我们只考虑列表的一半来搜索项目，而忽略列表的另一半。我们反复检查，直到找到值或区间为空。因此，在每次迭代中，数组的大小减半；例如，在第1次迭代中，列表的大小是
    `n`，在第2次迭代中，列表的大小变为 n/2，在第3次迭代中，列表的大小变为 n/2²，经过 *k* 次迭代后，列表的大小变为 n/2^k。那时列表的大小将等于
    `1`。这意味着：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Applying the `log` function on both sides:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对两边应用 `log` 函数：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hence, the binary search algorithm has the worst-case time complexity of `O(log
    n)`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，二分搜索算法的最坏情况时间复杂度为 `O(log n)`。
- en: Next, we will discuss the interpolation search algorithm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论插值搜索算法。
- en: Interpolation search
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值搜索
- en: The binary search algorithm is an efficient algorithm for searching. It always
    reduces the search space by half by discarding one half of the search space depending
    on the value of the search item. If the search item is smaller than the value
    in the middle of the list, the second half of the list is discarded from the search
    space. In the case of binary search, we always reduce the search space by a fixed
    value of half, whereas the interpolation search algorithm is an improved version
    of the binary search algorithm in which we use a more efficient method that reduces
    the search space by more than half after each iteration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法是一种高效的搜索算法。它总是通过丢弃搜索空间的一半来减少搜索空间，具体取决于搜索项的值。如果搜索项小于列表中间的值，则从搜索空间中丢弃列表的后半部分。在二分搜索的情况下，我们总是通过一个固定的值来减半搜索空间，而插值搜索算法是二分搜索算法的改进版本，其中我们使用一种更有效的方法，在每次迭代后减少超过一半的搜索空间。
- en: The interpolation search algorithm works efficiently when there are uniformly
    distributed elements in the sorted list. In a binary search, we always start searching
    from the middle of the list, whereas in the interpolation search we compute the
    starting search position depending on the item to be searched. In the interpolation
    search algorithm, the starting search position is most likely to be close to the
    start or end of the list; if the search item is near the first element in the
    list, then the starting search position is likely to be near the start of the
    list and if the search item is near the end of the list, then the starting search
    position is likely to be near the end of the list.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当排序列表中有均匀分布的元素时，插值搜索算法工作得非常有效。在二分搜索中，我们总是从列表的中间开始搜索，而在插值搜索中，我们根据要搜索的项目计算起始搜索位置。在插值搜索算法中，起始搜索位置最有可能接近列表的开始或结束；如果搜索项接近列表的第一个元素，那么起始搜索位置可能接近列表的开始，如果搜索项接近列表的末尾，那么起始搜索位置可能接近列表的末尾。
- en: It is quite similar to how humans perform a search on any list of items. It
    is based on trying to make a good guess of the index position where a search item
    is likely to be found in a sorted list of items.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它与人类在任意项目列表中进行搜索的方式非常相似。它基于尝试对搜索项可能在排序项目列表中找到的索引位置进行良好的猜测。
- en: 'It works in a similar way to the binary search algorithm except for the method
    to determine the splitting criteria to divide the data in order to reduce the
    number of comparisons. In the case of a binary search, we divide the data into
    equal halves and in the case of an interpolation search, we divide the data using
    the following formula:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与二分搜索算法类似，只是在确定分割标准以减少比较次数的方法上有所不同。在二分搜索的情况下，我们将数据分成相等的两半，而在插值搜索的情况下，我们使用以下公式来分割数据：
- en: '![](img/B17217_10_007.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_007.png)'
- en: In the preceding formula, `low_index` is the lower-bound index of the list,
    which is the index of the smallest value, and `upper_index` denotes the index
    position of the highest value in the list. The `list[low_index]` and `list[upper_index]`
    are the lowest and highest values respectively in the list. The `search_value`
    variable contains the value of the item that is to be searched.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，`low_index`是列表的下界索引，即最小值的索引，而`upper_index`表示列表中最高值的索引位置。`list[low_index]`和`list[upper_index]`分别是列表中的最低值和最高值。`search_value`变量包含要搜索的项的值。
- en: 'Let’s consider an example to understand how the interpolation search algorithm
    works using the following list of seven items:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下七个元素的列表来了解插值搜索算法的工作原理：
- en: '![](img/B17217_10_09.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_10_09.png)'
- en: 'Figure 10.9: Example of interpolation search'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：插值搜索示例
- en: 'Given the list of seven items, `44`, `60`, `75`, `100`, `120`, `230`, and `250`,
    the `mid` point can be computed using the above mentioned formula with the following
    values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 给定包含七个元素的列表，`44`、`60`、`75`、`100`、`120`、`230`和`250`，可以使用上述公式计算`mid`点，以下是一些值：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Putting the values of all the variables in the formula, we get:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有变量的值代入公式中，我们得到：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `mid` index is `5`, in the case of an interpolation search, so the algorithm
    starts searching from the index position `5`. So, this is how we compute the midpoint
    from which we start searching for the given element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`mid`索引为`5`，在插值搜索的情况下，因此算法从索引位置`5`开始搜索。所以，这就是我们从哪个中点开始搜索给定元素的计算方式。'
- en: 'The interpolation search algorithm works as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 插值搜索算法的工作原理如下：
- en: We start searching for the given search value from the midpoint (we have just
    seen how to compute it).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从中点开始搜索给定的搜索值（我们刚刚看到了如何计算它）。
- en: If the search value matches the value stored at the index of the midpoint, we
    return this index position.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值与中点索引处存储的值匹配，我们返回此索引位置。
- en: If the search value does not match the value stored at the midpoint, we divide
    the list into two sublists, i.e. a higher sublist and lower sublist. The higher
    sublist has all the elements with higher index values than the midpoint, and the
    lower sublist has all the elements with lower index values.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值与中点处的值不匹配，我们将列表分为两个子列表，即较高的子列表和较低的子列表。较高的子列表包含所有索引值高于中点的元素，而较低的子列表包含所有索引值低于中点的元素。
- en: If the search value is greater than the value of the midpoint, we search the
    given search value in the higher sublist and ignore the lower sublist.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值大于中点值，我们将在较高的子列表中搜索给定的搜索值，并忽略较低的子列表。
- en: If the search value is lower than the value of the midpoint, we search the given
    search value in the lower sublist and ignore the higher sublist.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索值低于中点值，我们将在较低的子列表中搜索给定的搜索值，并忽略较高的子列表。
- en: We repeat the process until the size of the sublists is reduced to zero.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复此过程，直到子列表的大小减少到零。
- en: 'Let us understand the implementation of the interpolation search algorithm.
    Firstly, we define the `nearest_mid()` method, which computes the midpoint as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解插值搜索算法的实现。首先，我们定义`nearest_mid()`方法，其计算中点的方式如下：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `nearest_mid` function takes, as arguments, the lists on which to perform
    the search. The `low_index` and `upper_index` parameters represent the bounds
    in the list within which we are hoping to find the search term. Furthermore, `search_value`
    represents the value being searched for.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest_mid`函数接受要执行搜索的列表作为参数。`low_index`和`upper_index`参数代表列表中我们希望找到搜索项的界限。此外，`search_value`代表要搜索的值。'
- en: In an interpolation search, the midpoint is generally more to the left or right.
    This is caused by the effect of the multiplier being used when dividing to obtain
    the midpoint. The implementation of the interpolation algorithm remains the same
    as that of the binary search except for the way we compute the midpoint.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在插值搜索中，中点通常更偏向左侧或右侧。这是由于在分割以获取中点时使用的乘数效应造成的。插值算法的实现与二分搜索相同，只是在计算中点的方式上有所不同。
- en: 'In the following code, we provide the implementation of the interpolation search
    algorithm:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们提供了插值搜索算法的实现：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above code, we initialize the `low_index` and `upper_index` variables
    for the given sorted list. We firstly compute the midpoint using the `nearest_mid()`
    method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们初始化给定排序列表的`low_index`和`upper_index`变量。我们首先使用`nearest_mid()`方法计算中点。
- en: The computed midpoint using the `nearest_mid` function may produce values that
    are greater than `upper_bound_index` or lower than `lower_bound_index`. When this
    occurs, it means the search term, `term`, is not in the list. `None` is, therefore,
    returned to represent this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nearest_mid`函数计算出的中点值可能大于`upper_bound_index`或小于`lower_bound_index`。当这种情况发生时，意味着搜索项`term`不在列表中。因此，返回`None`来表示这种情况。
- en: 'Next, we match the search value with the value stored at the midpoint, i.e.
    `ordered_list[mid_point]`. If that matches, the index of the midpoint is returned;
    if it does not match, then we divide the lists into higher and lower sublists,
    and we readjust `low_index` and `upper_index` so that the algorithm will focus
    on the sublist that is likely to contain the search term similar to what we did
    in the binary search:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将搜索值与中点存储的值进行匹配，即`ordered_list[mid_point]`。如果匹配，则返回中点的索引；如果不匹配，则将列表分为更高和更低的子列表，并重新调整`low_index`和`upper_index`，以便算法将重点放在可能包含搜索项的子列表上，这与我们在二分搜索中所做的一样：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the above code, we check if the search value is greater than the value stored
    at `ordered_list[mid_point]`, then we only adjust the `low_index` variable to
    point to the `mid_point + 1` index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们检查搜索值是否大于`ordered_list[mid_point]`存储的值，然后只调整`low_index`变量以指向`mid_point
    + 1`索引。
- en: 'Let’s see how this adjustment occurs. Suppose we want to search for `190` in
    the given list in *Figure 10.10*, then the midpoint will be `4` as per the above
    formula. Then we compare the search value (i.e. `190`) with the value stored at
    the midpoint (i.e. `120`). Since the search value is greater, we search for the
    element in the higher sublist, and readjust the `low_index` value. This is shown
    in *Figure 10.10*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种调整是如何发生的。假设我们想在*图10.10*中给出的列表中搜索`190`，那么根据上述公式，中点将是`4`。然后我们将搜索值（即`190`）与中点存储的值（即`120`）进行比较。由于搜索值更大，我们在较高的子列表中搜索元素，并重新调整`low_index`值。这如图*10.10*所示：
- en: '![](img/B17217_10_10.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_10.png)'
- en: 'Figure 10.10: Readjustment of the low_index when the value of the search item
    is greater than the value at the midpoint'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：当搜索项的值大于中点处的值时，调整`low_index`
- en: On the other hand, if the value of the search term is less than the value stored
    at `ordered_list[mid_point]`, then we only adjust the `upper_index` variable to
    point to the index `mid_point - 1`. For example, if we have the list shown in
    *Figure 10.11*, and we want to search for `185`, then the midpoint will be `4`
    as per the formula.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果搜索项的值小于`ordered_list[mid_point]`存储的值，那么我们只调整`upper_index`变量以指向索引`mid_point
    - 1`。例如，如果我们有*图10.11*中显示的列表，并且我们想要搜索`185`，那么根据公式，中点将是`4`。
- en: 'Next, we compare the search value (i.e. `185`) with the value stored at the
    midpoint (i.e. `190`). Since the search value is less as compared to `ordered_list[mid_point]`,
    we search for the element in the lower sublist, and readjust the `upper_index`
    value. This is shown in *Figure 10.11*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将搜索值（即`185`）与中点存储的值（即`190`）进行比较。由于搜索值小于`ordered_list[mid_point]`，我们在较低的子列表中搜索元素，并重新调整`upper_index`值。这如图*10.11*所示：
- en: '![](img/B17217_10_11.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_11.png)'
- en: 'Figure 10.11: Readjustment of the upper_index when the search item is less
    than the value at the midpoint'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：当搜索项小于中点处的值时，调整`upper_index`
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the above code is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s use a more practical example to understand the inner workings of both
    the binary search and interpolation algorithms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更实际的例子来理解二分搜索和插值算法的内部工作原理。
- en: 'Consider for example the following list of elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下元素列表：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At index 0, the value `2` is stored, and at index `7`, the value `77` is stored.
    Now, assume that we want to find element `2` in the list. How will the two different
    algorithms go about it?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引0处存储的值是`2`，在索引`7`处存储的值是`77`。现在，假设我们想在列表中找到元素`2`。两种不同的算法将如何进行？
- en: 'If we pass this list to the `interpolation search` function, then the `nearest_mid`
    function will return a value equal to `0` using the formula of `mid_point` computation,
    which is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此列表传递给`interpolation search`函数，那么`nearest_mid`函数将使用以下`mid_point`计算公式返回一个等于`0`的值：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we get the `mid_point` value `0`, we start the interpolation search with
    the value at index `0`. Just with one comparison, we have found the search term.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到`mid_point`值`0`时，我们开始使用索引`0`处的值进行插值搜索。仅通过一次比较，我们就找到了搜索项。
- en: 'On the other hand, the binary search algorithm needs three comparisons to arrive
    at the search term, as illustrated in *Figure 10.12*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，二分查找算法需要三次比较才能到达搜索项，如图*图10.12*所示：
- en: '![](img/B17217_10_12.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_12.png)'
- en: 'Figure 10.12: Three comparisons are required to search for the item using the
    binary search algorithm'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：使用二分查找算法搜索项目需要三次比较
- en: The first `mid_point` value calculated is `3`. The second `mid_point` value
    is `1` and the last `mid_point` value where the search term is found is `0`. So,
    we reach the desired search item in three comparisons whereas in interpolation
    search we find the desired item on the first attempt.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的第一个`mid_point`值是`3`。第二个`mid_point`值是`1`，最后一个找到搜索项的`mid_point`值是`0`。因此，我们通过三次比较就找到了所需的搜索项，而在插值搜索中，我们第一次尝试就找到了所需的项。
- en: The interpolation search algorithm works well when the data set is sorted, and
    uniformly distributed. In this case, the average case time complexity is `O(log(log
    n))` in which `n` is the length of the array. Moreover, if the dataset is randomized,
    in that case, the worst-case time complexity of the interpolation search algorithm
    will be `O(n)`. So, interpolation search may work better than binary search if
    the given data is uniformly distributed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集是有序且均匀分布时，插值搜索算法效果良好。在这种情况下，平均情况的时间复杂度是`O(log(log n))`，其中`n`是数组的长度。此外，如果数据集是随机化的，那么插值搜索算法的最坏情况时间复杂度将是`O(n)`。因此，如果给定数据是均匀分布的，插值搜索可能比二分搜索更有效。
- en: Exponential search
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数搜索
- en: 'Exponential search is another search algorithm that is mostly used when we
    have large numbers of elements in a list. Exponential search is also known as
    galloping search and doubling search. The exponential search algorithm works in
    the following two steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 指数搜索是另一种搜索算法，通常在列表中有大量元素时使用。指数搜索也称为跳跃搜索和加倍搜索。指数搜索算法分为以下两个步骤：
- en: Given a sorted array of `n` data elements, we first determine the subrange in
    the original list where the desired search item may be present
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个包含`n`个数据元素的有序数组，我们首先确定原始列表中可能包含所需搜索项的子范围。
- en: Next, we use the binary search algorithm to find out the search value within
    the subrange of data elements identified in *step 1*
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用二分查找算法在第一步中确定的数据元素子范围内查找搜索值。
- en: 'Firstly, in order to find out the subrange of data elements, we start searching
    for the desired item in the given sorted array by jumping 2^i elements every iteration.
    Here, `i` is the value of the index of the array. After each jump, we check if
    the search item is present between the last jump and the current jump. If the
    search item is present then we use the binary search algorithm within this subarray,
    and if it is not present, we move the index to the next location. Therefore, we
    first find the first occurrence of an exponent `i` such that the value at index
    2^i is greater than the search value. Then, the 2^i becomes the lower bound and
    2^i-1 becomes the upper bound for this range of data elements in which the search
    value will be present. The exponential search algorithm is defined as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了找到数据元素的子范围，我们通过每次迭代跳过2^i个元素，在给定的有序数组中开始搜索所需的项目。在这里，`i`是数组索引的值。每次跳跃后，我们检查搜索项是否在最后一次跳跃和当前跳跃之间。如果搜索项存在，则在此子数组中使用二分查找算法，如果不存在，则将索引移动到下一个位置。因此，我们首先找到第一个指数`i`，使得索引2^i处的值大于搜索值。然后，2^i成为这个数据元素范围的下界，2^i-1成为这个范围的上界，其中搜索值将存在。指数搜索算法定义如下：
- en: First, we check the first element `A[0]` with the search element.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将搜索元素与第一个元素`A[0]`进行比较。
- en: Initialize the index position `i=1`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化索引位置`i=1`。
- en: 'We check two conditions: (1) if it is the end of the array or not (i.e. 2^i
    `<` len(A)), and (2) if `A[i]` `<=` `search_value`). In the first condition, we
    check if we have searched the complete list, and we stop if we have reached the
    end of the list. In the second condition, we stop searching when we reach an element
    whose value is greater than the search value, because it means the desired element
    will be present before this index position (since the list is sorted).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查两个条件：（1）是否是数组的末尾（即2^i `<` len(A)），以及（2）`A[i]` `<=` `search_value`）。在第一个条件下，我们检查是否已搜索完整列表，如果已到达列表末尾，则停止搜索。在第二个条件下，当我们遇到一个值大于搜索值的元素时停止搜索，因为这表示所需的元素将位于此索引位置之前（因为列表是有序的）。
- en: If either of the above two conditions is true, we move to the next index position
    by incrementing `i` in powers of `2`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果上述两个条件中的任何一个为真，我们就通过将`i`的值增加2的幂来移动到下一个索引位置。
- en: We stop when either of the two conditions of *step 3* is satisfied.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当满足*步骤3*的两个条件之一时，我们停止。
- en: We apply the binary search algorithm on the range 2^i//2 to min (2^i, len(A)).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在范围2^i//2到min(2^i, len(A))上应用二分搜索算法。
- en: Let’s take an example of a sorted array of elements `A = {3, 5, 8, 10, 15, 26,
    35, 45, 56, 80, 120, 125, 138}` in which we want to search for the element `125`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个排序数组元素`A = {3, 5, 8, 10, 15, 26, 35, 45, 56, 80, 120, 125, 138}`的例子为例，其中我们想要搜索元素`125`。
- en: 'We start with comparing the first element at index i = 0, i.e. A[0] with the
    search element. Since A[0] < `search_value`, we jump to the next location 2^i
    with i = 0, since A[2⁰] < `search_value`, the condition is true, hence we jump
    to the next location with i = 1 i.e. A`[`22¹`]` < `search_value`. We again jump
    to the next location 2^i with i = 2, since A[2²] < `search_value`, the condition
    is true. We iteratively jump to the next location until we complete searching
    the list or the search value is greater than the value at that location, i.e.
    A[2^i] < len(A) or A[2^i] <= `search_value`. Then we apply the binary search algorithm
    on the range of the subarray. The complete process for searching a given element
    in the sorted array using the exponential search algorithm is depicted in *Figure
    10.13*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从比较索引位置i = 0处的第一个元素开始，即A[0]与搜索元素进行比较。由于A[0] < `search_value`，我们跳到下一个位置2^i，i
    = 0，因为A[2⁰] < `search_value`，条件为真，所以我们跳到下一个位置，i = 1，即A`[`22¹`]` < `search_value`。我们再次跳到下一个位置2^i，i
    = 2，因为A[2²] < `search_value`，条件为真。我们迭代地跳到下一个位置，直到我们完成列表的搜索或搜索值大于该位置的值，即A[2^i]
    < len(A)或A[2^i] <= `search_value`。然后我们在子数组的范围内应用二分搜索算法。使用指数搜索算法在排序数组中搜索给定元素的完整过程如图*10.13*所示：
- en: '![](img/B17217_10_13.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_10_13.png)'
- en: 'Figure 10.13: Illustration of the exponential search algorithm'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：指数搜索算法的说明
- en: 'Now, let us discuss the implementation of the exponential search algorithm.
    Firstly, we implement the binary search algorithm, which we have already discussed
    in the previous section, but for the completeness of this algorithm it is given
    again as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论指数搜索算法的实现。首先，我们实现二分搜索算法，我们已经在上一节中讨论过，但为了完整起见，它再次给出如下：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the above code, given the ordered list of elements, it returns the index
    of the location where the given data element is found in the list. It returns
    `None` if the desired element is not found in the list. Next, we implement the
    `exponential_search()` method as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，给定元素的有序列表，它返回给定数据元素在列表中找到的位置的索引。如果所需的元素在列表中未找到，则返回`None`。接下来，我们按照以下方式实现`exponential_search()`方法：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the above code, firstly, we compare the first element `A[0]` with the search
    value. If it matches then the index position `0` is returned. If that does not
    match, we increase the index position to 2⁰, i.e. 1\. We check `A[1] < search_value`.
    Since the condition is true, we jump to the next location 2¹, i.e. we compare
    `A[2] < search_value`. Since the condition is true, we move to the next location.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先，我们将第一个元素`A[0]`与搜索值进行比较。如果匹配，则返回索引位置`0`。如果不匹配，则将索引位置增加到2⁰，即1。我们检查`A[1]
    < search_value`。由于条件为真，我们跳到下一个位置2¹，即我们比较`A[2] < search_value`。由于条件为真，我们移动到下一个位置。
- en: 'We iteratively increase the index position in the power of 2 until the stop
    condition is satisfied:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迭代地以2的幂增加索引位置，直到满足停止条件：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, when the stopping criteria are met, we use the binary search algorithm
    to search for the desired search value within the subrange as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当满足停止条件时，我们使用二分搜索算法在子范围内搜索所需的搜索值，如下所示：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, the `exponential_search()` method returns the index position if the
    search value is found in the given array; otherwise, `None` is returned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果搜索值在给定数组中找到，`exponential_search()`方法返回索引位置；否则，返回`None`。
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the above code snippet is:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的输出是：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the above output, we get index position `12` for the search item `34` in
    the given array.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们得到搜索项`34`在给定数组中的索引位置`12`。
- en: The exponential search is useful for very large-sized arrays. This is better
    than binary search because instead of performing a binary search on the complete
    array, we find a subarray in which the element may be present and then apply binary
    search, so it reduces the number of comparisons.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 指数搜索对于非常大的数组非常有用。这比二分搜索更好，因为我们不是在完整的数组上执行二分搜索，而是找到一个可能包含元素的子数组，然后在该子数组上应用二分搜索，从而减少了比较的次数。
- en: The worst-case time complexity of exponential search is O(log[2]i), where `i`
    is the index where the element to be searched is present. The exponential search
    algorithm can outperform binary search when the desired search element is present
    at the beginning of the array.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 指数搜索的最坏情况时间复杂度为 O(log[2]i)，其中 `i` 是要搜索的元素所在的索引。当所需的搜索元素位于数组的开头时，指数搜索算法可以优于二分搜索。
- en: We can also use exponential search to search in bounded arrays. It can even
    out-perform binary search when the target is near the beginning of the array,
    since exponential search takes `O(log(i))` time whereas the binary search takes
    `O(logn)` time, where `n` is the total number of elements. The best-case complexity
    of exponential search is `O(1)`, when the element is present at the first location
    of the array.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用指数搜索在有界数组中进行搜索。当目标接近数组的开头时，它甚至可以优于二分搜索，因为指数搜索的时间复杂度为 `O(log(i))`，而二分搜索的时间复杂度为
    `O(logn)`，其中 `n` 是元素的总数。指数搜索的最佳情况复杂度为 `O(1)`，当元素位于数组的第一个位置时。
- en: Next, let us discuss how to decide which search algorithm we should choose for
    a given situation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何决定在特定情况下应该选择哪种搜索算法。
- en: Choosing a search algorithm
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择搜索算法
- en: Now that we’ve covered the different types of search algorithms, we can look
    into which ones work better and in what situations. The binary search and interpolation
    search algorithms are better in performance compared to both ordered and unordered
    linear search functions. The linear search algorithm is slower because of the
    sequential probing of elements in the list to find the search term.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了不同类型的搜索算法，我们可以探讨哪些算法表现更好，以及在什么情况下使用。与有序和无序的线性搜索函数相比，二分搜索和插值搜索算法在性能上更优。线性搜索算法较慢，因为它需要在列表中顺序探测元素以找到搜索项。
- en: Linear search has a time complexity of `O(n)`. The linear search algorithm does
    not perform well when the given list of data elements is large.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索的时间复杂度为 `O(n)`。当给定的数据元素列表很大时，线性搜索算法表现不佳。
- en: The binary search operation, on the other hand, slices the list in two anytime
    a search is attempted. On each iteration, we approach the search term much faster
    than in a linear strategy. The time complexity yields `O(logn)`. The binary search
    algorithm performs well but the drawback of it is that it requires a sorted list
    of elements. So, if the given data elements are short and unsorted then it is
    better to use the linear search algorithm.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，二分搜索操作在每次搜索尝试时都会将列表分成两部分。在每次迭代中，我们比线性策略更快地接近搜索项。时间复杂度为 `O(logn)`。二分搜索算法表现良好，但其缺点是它需要一个排序的元素列表。因此，如果给定的数据元素较短且未排序，则最好使用线性搜索算法。
- en: Interpolation search discards more than half of the list of items from the search
    space, and this gives it the ability to get to the portion of the list that holds
    a search term more efficiently. In the interpolation search algorithm, the midpoint
    is computed in such a way that it gives a higher probability of obtaining the
    search term faster. The average-case time complexity of interpolation search is
    `O(log(logn))`, whereas the worst-case time complexity of the interpolation search
    algorithm is `O(n)`. This shows that interpolation search is better than binary
    search and provides faster searching in most cases.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 插值搜索会丢弃搜索空间中超过一半的项目，这使得它能够更有效地到达包含搜索项的部分。在插值搜索算法中，中点的计算方式使得更快地获得搜索项的概率更高。插值搜索的平均情况时间复杂度为
    `O(log(logn))`，而插值搜索算法的最坏情况时间复杂度为 `O(n)`。这表明插值搜索优于二分搜索，并且在大多数情况下提供更快的搜索速度。
- en: Therefore, if the list is short and unsorted, then the linear search algorithm
    is suitable, and if the list is sorted and not very big then the binary search
    algorithm can be used. Further, the interpolation search algorithm is good to
    use if the data elements in the list are uniformly distributed. If the list is
    very large, then the exponential search algorithm and jump search algorithm can
    be used.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果列表较短且未排序，则线性搜索算法是合适的，如果列表已排序且不是很大，则可以使用二分搜索算法。此外，如果列表中的数据元素均匀分布，则插值搜索算法是很好的选择。如果列表非常大，则可以使用对数搜索算法和跳跃搜索算法。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the concept of searching for a given element from
    a list of data elements. We discussed several important search algorithms, such
    as linear search, binary search, jump search, interpolation search, and exponential
    search. The implementations of these algorithms were discussed using Python in
    detail. We will be discussing sorting algorithms in the next chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从数据元素列表中搜索给定元素的概念。我们讨论了几个重要的搜索算法，例如线性搜索、二分搜索、跳跃搜索、插值搜索和对数搜索。这些算法的实现是用
    Python 详细讨论的。我们将在下一章讨论排序算法。
- en: Exercise
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: On average, how many comparisons are required in a linear search of `n` elements?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在线性搜索 `n` 个元素时，平均需要多少次比较？
- en: Assume there are eight elements in a sorted array. What is the average number
    of comparisons that will be required if all the searches are successful and if
    the binary search algorithm is used?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有一个排序数组中有八个元素。如果所有搜索都成功，并且使用二分搜索算法，平均需要多少次比较？
- en: What is the worst-case time complexity of the binary search algorithm?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二分查找算法的最坏情况时间复杂度是多少？
- en: When should the interpolation search algorithm perform better than the binary
    search algorithm?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下插值搜索算法的性能会比二分搜索算法更好？
- en: Join our community on Discord
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
