- en: Chapter 3. Basic Building Blocks of a User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Stock Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons, buttons, and more buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offering options with `CheckBoxes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `TextCtrl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing choices with the `Choice` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `Menus` and `MenuBars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `ToolBars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `PopupMenus`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping controls with a `StaticBox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even the most complex objects are typically created from many smaller, simpler
    objects or parts. The task of the application developer is to utilize these smaller
    parts and link them together in a way that is meaningful, in order to achieve
    the desired function of the application. In order to be able to build the application,
    it is necessary to know what parts are available to you.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython provides a large collection of classes and utilities. In fact, the
    basic collection is so rich that it is very much possible to construct a fully-functional
    application without inventing any of your own parts. So lets jump in and take
    a look at some of the most common and basic parts that can be found in nearly
    any desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Stock Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly all applications have buttons in them and among the buttons there are
    many common ones such as Ok and Cancel that appear over and over again. In wxPython,
    these common buttons are known as Stock Buttons, because they are constructed
    by passing a Stock ID to the constructor of a `Button.`
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a simple `Panel` that has four `Buttons` on it, to see how Stock
    Buttons can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Common buttons are created by using a standard `Button` with a Stock ID and
    no label. The framework will then create the correct type of button with the proper
    label for the current platform. Each platform has slightly different standards
    for these common buttons. By using Stock Buttons, these cross-platform differences
    can be handled by the framework. For example, take a look at the following two
    screenshots of the previous sample code being run on Windows 7 and OS X respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Screenshot of Windows 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot of OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Platform Notice: On Linux, depending upon the version of GTK, Stock Buttons
    will also have the proper theme provided icon displayed on them as well.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stock buttons can be created from nearly all of the Stock IDs. If your text
    editor does not provide completion hints, here is a quick way to see all of the
    available Stock IDs: Just run the following code in your Python interpreter to
    introspect the `wx` namespace for all of the ID constants.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* contains a detailed discussion
    about the IDs used to construct Stock Buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Buttons, buttons, and more buttons* recipe in this chapter shows how to
    use the other button classes available in wxPython.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Standard dialog button layout* recipe in Chapter 7, *Window Layout and
    Design* shows how Stock Buttons are used to achieve easy control layout in dialogs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons, buttons, and more buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The regular `Button` class only allows for displaying a label on the button.
    If this is a little too plain for the needs of your application, you're in luck.
    wxPython also provides a wide variety of other types of buttons that provide a
    different look and feel, as well as extended functionality. This recipe will introduce
    a number of the other button controls that are available in wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version Notice: The `agw` package and `GradientButton` class used in the following
    code are only available in wxPython 2.8.9.2 and later.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see what these different `Buttons` look like and what they can do, we will
    make a simple `Panel` with some different examples of these additional button
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows the basic use of four different button classes, so let's take
    a look at each of them one by one to see what they can do.
  prefs: []
  type: TYPE_NORMAL
- en: ToggleButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ToggleButton` is another native button provided by wxPython. It is just
    like the standard `Button`, but provides two states. The button will be toggled
    from its regular state to a pressed state when clicked on. A second click will
    toggle it back to its regular state once again.
  prefs: []
  type: TYPE_NORMAL
- en: BitmapButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `BitmapButton` is a native platform button used for showing an image instead
    of label text. The usage of this button is just like the standard `Button` except
    that it takes a `Bitmap` as an argument instead of a label string. The `Bitmap`
    for each state of when the button is being pressed or interacted with by the mouse
    can also be customized with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBitmapDisabled` | Sets the Bitmap to show when the button is disabled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBitmapFocus` | Sets the Bitmap to show when the button has the keyboard
    focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBitmapHover` | Sets the Bitmap to show when the mouse cursor is hovering
    over the button. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBitmapLabel` | Sets the default button (same as what is provided to the
    constructor). In the absence of other bitmaps, this one will be used for all states.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBitmapSelected` | Sets the Bitmap to use when the button is pressed.
    |'
  prefs: []
  type: TYPE_TB
- en: PlateButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PlateButton` is an owner-drawn button class provided by the `platebtn`
    module in `wx.lib. PlateButtons` are a type of flat button control that will change
    its background colour when the mouse hovers over it or when it is clicked on.
    A `PlateButton` can be displayed with just a label, with just a `Bitmap`, with
    both a label and a `Bitmap`, or any of the previous combinations plus as a drop-down
    `Menu.`
  prefs: []
  type: TYPE_NORMAL
- en: The look and feel of the button can also be customized to control the color
    of the highlighting, the text label color, the button shape, and how the highlight
    is drawn. The `PB_STYLE_SQUARE` style flag will make the button take up a square
    shape instead of using its default rounded edges and the `PB_STYLE_GRADIENT` style
    flag will cause the background to be drawn as a gradient based on the highlighting
    colour. In addition to this customizability, the `PlateButton` also fully implements
    the `BitmapButton` API so it can be used as a drop-in replacement for a `BitmapButton`
    in existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: GradientButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GradientButton` is very similar to the `PlateButton`. The only difference
    is that it is not a flat button, it doesn't support a drop-down menu, and it is
    more flexible in what it allows for configuring the gradient colors.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are still quite a few more button implementations out there that you may
    find useful in your application.
  prefs: []
  type: TYPE_NORMAL
- en: GenericButtons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GenericButtons` are a collection of classes in `wx.lib.buttons` that provide
    some basic owner-drawn buttons as well as owner-drawn implementations of the native
    buttons that maintain the look of the native buttons but work around some limitations.
    For example, there is `GenBitmapTextButton` which provides a bitmap button that
    also supports displaying a label, and `GenBitmapToggleButton` which allows for
    a toggle button that shows a `Bitmap.`'
  prefs: []
  type: TYPE_NORMAL
- en: AquaButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AquaButtons` are an owner-drawn button class with a glassy appearance that
    approximates the look and feel of native Macintosh Aqua Buttons. Because the class
    is owner drawn, it will provide the same look and feel on all platforms. This
    class can be found in `wx.lib.agw.aquabutton`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating Stock Buttons* recipe in this chapter shows how to create standard
    buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offering options with CheckBoxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `CheckBox` is a common, basic control that allows for a user to select one
    of two or three states, depending on the style of `CheckBox`, though it is typically
    associated with just a `True` or `False` state. In this recipe, we will take a
    look at how to use the `CheckBox` control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how `CheckBoxes` work, we will create a little window with two different
    kinds of `CheckBoxes` in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created two `CheckBoxes`; the first is the standard two-state `CheckBox`
    and the second is a three-state `CheckBox`. The state of a two state `CheckBox`
    can be programmatically controlled through its `GetValue` and `SetValue` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three-state checkbox is created by specifying the two style flags `CHK_3STATE`
    and `CHK_ALLOW_3RD_STATE_FOR_USER`. The second style flag can be omitted if you
    want to limit users from being able to set the undetermined state, so that it
    can only be done programmatically. Three-state checkboxes use the `Get3StateValue`
    and `Set3StateValue` methods with the following values to programmatically control
    the `CheckBox` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wx.CHK_CHECKED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wx.CHK_UNCHECKED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wx.CHK_UNDETERMINED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* shows how to use the `BoxSizer` class
    to control layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the TextCtrl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TextCtrl` is the basic means of allowing users to input textual data into
    an application. This control has many possible uses and modes of operation. This
    recipe will show how to create a simple login dialog that uses two `TextCtrls`
    to provide input fields for the login name and password.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, lets create the `Dialog` class that will hold the other controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s make the `Panel` that will hold the `TextCtlr` controls for the
    users to enter their login information into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/1780_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did a number of things in the previous code, but since the focus of this
    recipe is on the `TextCtrl` object, let's start by taking a look at the two `TextCtrl`
    object that we created.
  prefs: []
  type: TYPE_NORMAL
- en: The first text control for the username is just a default `TextCtrl` created
    with all of the default arguments. By default, a `TextCtrl` object is created
    as a single line control. This creates just a simple text box that the user can
    type any arbitrary number of characters into.
  prefs: []
  type: TYPE_NORMAL
- en: The second text control uses the special `TE_PASSWORD` style flag. This creates
    a `TextCtrl` that will disguise its input with asterisk characters, just like
    you see in any password entry field in most applications or websites. As a user
    types in this control, each character that is typed in will be displayed as an
    asterisk, but the actual character values are stored internally by the control
    and can be accessed via `GetValue`.
  prefs: []
  type: TYPE_NORMAL
- en: This dialog should be shown with `ShowModal`, and when `ShowModal` returns you
    can just retrieve the values by using the accessor methods `GetUsername` and `GetPassword`
    in order to perform the login validation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TextCtrl` class has a fairly large collection of style flags that can be
    supplied to its constructor to modify its behavior for different use cases. Included
    below is a list of most-commonly-used style flags and a description of what each
    one does. The rest can be found in wxPython's online API documentation ([http://wxpython.org/docs/api/](http://wxpython.org/docs/api/)).
  prefs: []
  type: TYPE_NORMAL
- en: '| Style flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_PROCESS_ENTER` | Will cause the control to generate a `wx.EVT_COMMAND_TEXT_ENTER`
    event when the *Enter* key is pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_PROCESS_TAB` | Allows a `wx.EVT_CHAR` event to be issued when the
    *Tab* key is pressed. Without this style set, the *Tab* key will allow the user
    to tab into the next control in the window. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_MULTILINE` | Allows the `TextCtrl` to have multiple lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_READONLY` | Makes the control read only, so that the user cannot enter
    text into it. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_RICH2` | Use the `RichText` version of the control. (only applicable
    on Windows). |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_LEFT` | Aligns all text to the left-hand side of the control. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_CENTER` | Aligns all text to the center of the control |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TE_RIGHT` | Aligns all text to the right-hand side of the control. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Validating Input with validators* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* shows how to use a Validator to validate user
    input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* shows how to use the BoxSizer class to
    control layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing choices with the Choice control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Choice` control is a means to allow the user to make a single selection
    from a list of possible selections. It does this by displaying the currently-selected
    choice and offering the list of other possible choices in a pop-up when the control
    is clicked on by the user. This makes it very efficient in its use of screen space.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how the `Choice` control works, we will make a simple `Panel` that has
    a `Choice` control with three choices in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Choice` control manages a list of strings. The list of strings that the
    control contains can be specified either in the constructor or by calling the
    `SetItems` method with a list of strings to put in the control. When clicked on,
    the control will display a pop-up list of all of the strings. After the user makes
    a selection, an `EVT_CHOICE` event will be fired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Platform Notice: The `Choice` control in Windows does not automatically select
    its first item when created. Due to this inconsistency, it is sometimes desirable
    to explicitly set the selection after creating the control, as we have done in
    this example, in order to ensure consistent behavior across platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The items in the control can be manipulated or changed after the control has
    been created by using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Append` | Append a string to the end of the list managed by the control
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AppendItems` | Append a list of strings to the list managed by the control
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Insert` | Insert a string into the list managed by the control |'
  prefs: []
  type: TYPE_TB
- en: '| `SetItems` | Set the list of strings that the control displays |'
  prefs: []
  type: TYPE_TB
- en: Adding Menus and MenuBars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications have menus. Menus are a means to providing the users of the
    application with a way to execute actions either by clicking on them or by using
    keyboard shortcuts that can be associated with each menu item. An application''s
    menus consist of three components: a `MenuBar, Menus`, and `MenuItems`. The `MenuBar`
    contains the `Menus` and the `Menus` contain the `MenuItems`. This recipe will
    show how to add a `MenuBar` with some Menus to a `Frame`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will make a `Frame` that has some `Menu` options for controlling actions
    in a `TextCtrl:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to look at is where we created the `MenuBar` object. The `MenuBar`
    is what we need to attach all of our `Menus` to, and it will ultimately become
    responsible for managing them. Next we start to make our `Menus`, which is a rather
    straightforward process. All that needs to be done is to call `Append` for each
    new item that we wish to add to the `Menu`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Append` accepts a few arguments, but the important one to notice is the one
    for the label. The string that we pass can have some special formatting options
    in it to setup keyboard shortcuts for the `MenuItem`. Placing an ''&'' before
    a letter in the label will setup a keyboard mnemonic that will allow for keyboard
    navigation to the item. More importantly, though, is that placing a *Tab* character
    (`\t`) followed by a shortcut option *Ctrl + C* will setup a keyboard shortcut
    to select the menu option and cause an `EVT_MENU` event to be generated.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Platform Notice: On OS X, the *Ctrl* keyword will be automatically translated
    to the Apple/Command key.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just need to call `Append` on our `MenuBar` in order to add each
    of the `Menus` that we created to it, and then finally call `SetMenuBar` on the
    `Frame` to add the `MenuBar` to our `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Menus have some additional functionality that we did not cover above. Following
    below are some references to a few more things that you can do with `Menus`.
  prefs: []
  type: TYPE_NORMAL
- en: SubMenus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Menus` can have submenus appended to them, via the `AppendMenu` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing MenuItems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MenuItems` are created when calling `Append` on a `Menu`. The `Append` method
    takes a "kind" keyword parameter that can accept any of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ITEM_NORMAL` | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ITEM_SEPARATOR` | Creates a separator item. It''s easier to just call
    `AppendSeparator` than do this. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ITEM_CHECK` | Adds a `CheckBox` to the `Menu`. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ITEM_RADIO` | Adds a `RadioButton` to the `Menu`. |'
  prefs: []
  type: TYPE_TB
- en: '`MenuItems` can also have `Bitmaps` added to them by calling `SetBitmap` on
    the `MenuItem` object returned by calling `Append` on the `Menu`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Platform Notice: On Linux/GTK, `MenuItems` that use Stock IDs will automatically
    get system theme provided bitmaps associated with them.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* discusses the use of
    the built-in standard control IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using UpdateUI events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* discusses how to use `UpdateUI` events to
    manage the UI's state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ToolBars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ToolBars` are a lot like `Menus` in that they provide a means to link an action
    in the interface with an action in the application. They differ in that `ToolBars`
    use images to represent actions and must be clicked on directly in order to initiate
    the action. They make for an easy point and click interface for the user to interact
    with. This recipe will show a custom `ToolBar` class that automatically gets bitmaps
    from the system''s `ArtProvider`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by defining our custom `ToolBar` class, and then map some Stock
    IDs to art resource IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make use of this custom `ToolBar` class anywhere that we want to
    have a `ToolBar`. The following code snippet is a minimal example of creating
    an `EasyToolBar` with three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EasyToolBar` class makes use of a map of stock IDs to art resource IDs.
    When the `AddEasyTool` method is called, it will look up that art resource in
    the system's art provider. This simplifies the use of the `ToolBar` by quite a
    bit since we don't need to repeat the code for getting the appropriate bitmap
    each time we want to add a tool.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToolBarFrame` class shows an example of the use of the `EasyToolBar`. Using
    a `ToolBar` can be summed up in a four-step process. First, create the `ToolBar`,
    second add the tools, third call `Realize` to tell the `ToolBar` that all of the
    tools have been added, and then fourth and finally call the `SetToolBar` method
    of the `Frame` in order to add the `ToolBar` to the `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ToolBar styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There a number of style flags that can be passed to a `ToolBars` constructor
    to modify its appearance and behavior. Following is a list of some of the more
    useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Style flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_DOCKABLE` | Allows the `ToolBar` to be undocked from the `Frame` (GTK
    Only) |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_FLAT` | Makes the `ToolBar` look flat (MSW and GTK ONLY) |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_HORIZONTAL` | Horizontal tool layout |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_VERTICAL` | Vertical tool layout |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_TEXT` | Show labels below the tool icon |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_NO_TOOLTIPS` | Don''t show `ToolTips` when tools are hovered over
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_BOTTOM` | Put the `ToolBar` at the bottom of the parent window |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TB_RIGHT` | Put the `ToolBar` at the right-hand side of the parent window
    |'
  prefs: []
  type: TYPE_TB
- en: Additional types of tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to add different types of tools or controls to a `ToolBar` besides
    the standard icon tools. Here is a quick reference to some of these other `ToolBar`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '| ToolBar methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AddControl` | Allows for a control such as a `Button` to be added to the
    `ToolBar`. |'
  prefs: []
  type: TYPE_TB
- en: '| `AddCheckLabelTool` | Adds a tool that can be toggled. |'
  prefs: []
  type: TYPE_TB
- en: '| `AddRadioLabelTool` | Adds a tool that will work like a `RadioButton`. |'
  prefs: []
  type: TYPE_TB
- en: '| `AddSeparator` | Adds a vertical line to the `ToolBar` to separate items.
    |'
  prefs: []
  type: TYPE_TB
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ToolBar` tools will fire an `EVT_TOOL` event when clicked on. If you already
    have a `MenuItem` for the same ID that is bound to an `EVT_MENU` event handler,
    it is not necessary to create a separate event handler for the tool event. The
    system will automatically route the tool event to your menu handler.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding Menus and MenuBars* recipe in this chapter discusses the use of
    menus and menu events, which are closely related to toolbars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing the ArtProvider* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    includes further examples and information about retrieving bitmap resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use PopupMenus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pop-up menus (a.k.a context menus) are a useful way of providing context-sensitive
    access to actions when a user right clicks on a control or on a part of a window.
    Pop-up menus work the same way as a regular menu but require some special handling
    since there is no `MenuBar` to manage them. This recipe will create a mixin class
    to help manage a pop-up menu.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will define a mixin class to manage the creation and lifetime of a
    context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This little mixin class is very generic and can be used with any type of window
    subclass to add custom context menu support. The subclass that uses this mixin
    must override the `CreateContextMenu` method to make its own `Menu`, and then
    the mixin will take care of the rest. Following is a minimal example of using
    the `PopupMenuMixin` class. It will create a `Panel` that has a context menu with
    three items on it; a more complete example is included in the example code that
    accompanies this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `EVT_CONTEXT_MENU` is fired when a user right-clicks, or initiates a context
    menu from the keyboard. Because context menus can be shown in multiple ways, it
    is important to use `EVT_CONTEXT_MENU` instead of using the mouse right-click
    event. Our mixin class will catch this event and first clean up any existing `Menu`.
    Since pop-up menus do not have a `MenuBar` to manage them, it is necessary to
    clean them up ourselves, otherwise, if they are not destroyed, they can cause
    memory leaks. Next, the subclass's `CreateContextMenu` method will be called to
    add the items to the `Menu`. Finally, we display the `Menu` by calling the `PopupMenu`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on an item in the `Menu`, an `EVT_MENU` event will be sent
    to the window that the pop-up menu belongs to. Hence, it is necessary to `Bind`
    your own menu handlers to handle the `MenuEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding Menus and MenuBars* recipe in this chapter shows how to create menu
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using mixin classes* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* discusses how
    to use mixin classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping controls with a StaticBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StaticBox` is a fairly simple control used to group other related controls
    together, by drawing a border around them that optionally includes a label. The
    usage of the `StaticBox` control is a little different than other controls though,
    due to its relationship with the controls it contains. Hence, this recipe will
    show how to use a `StaticBox`, and will give an explanation of some of its quirks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how to add controls to a `StaticBox`, let''s make a `Panel` class that
    has a `StaticBox`, and add a few controls to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though a `StaticBox` is a container for other controls, it is actually
    a sibling of the controls that it contains, instead of being a parent window.
    The most important thing to remember when working with a `StaticBox` is that it
    must be created before any of the controls that it will contain. If it is not
    created before its siblings, then they will have issues processing mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: The `StaticBox` uses a `StaticBoxSizer` to add the controls to the box, as well
    as to manage its size and to position the controls inside of it. The usage of
    a `StaticBoxSizer` is used just like a regular `BoxSizer` in all regards except
    that its constructor takes a `StaticBox` as the first argument. Calling the `Add`
    method of `StaticBoxSizer` is used to then add the controls to the `StaticBox`.
    Like with the `BoxSizer`, the `Add` method of `StaticBoxSizer` takes the object
    being added as the first parameter, and then optionally the proportion, the sizer
    flags, and border keyword parameters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using* a *BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window
    Layout and Design"), *Window Layout and Design* contains more examples of sizer-based
    control layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
