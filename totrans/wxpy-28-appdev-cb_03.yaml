- en: Chapter 3. Basic Building Blocks of a User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 用户界面的基本构建块
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating Stock Buttons
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建股票按钮
- en: Buttons, buttons, and more buttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮，按钮，还有更多的按钮
- en: Offering options with `CheckBoxes`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供带有`复选框`的选项
- en: Using the `TextCtrl`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TextCtrl`
- en: Providing choices with the `Choice` control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Choice` 控件提供选择
- en: Adding `Menus` and `MenuBars`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `菜单` 和 `菜单栏`
- en: Working with `ToolBars`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `ToolBars` 一起工作
- en: How to use `PopupMenus`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `PopupMenus`
- en: Grouping controls with a `StaticBox`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`StaticBox`分组控件
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Even the most complex objects are typically created from many smaller, simpler
    objects or parts. The task of the application developer is to utilize these smaller
    parts and link them together in a way that is meaningful, in order to achieve
    the desired function of the application. In order to be able to build the application,
    it is necessary to know what parts are available to you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最复杂的对象通常也是由许多较小的、更简单的对象或部分组成的。应用开发者的任务是利用这些较小的部分并将它们以有意义的方式连接起来，以达到应用所需的功能。为了能够构建应用，有必要知道有哪些部分可供使用。
- en: wxPython provides a large collection of classes and utilities. In fact, the
    basic collection is so rich that it is very much possible to construct a fully-functional
    application without inventing any of your own parts. So lets jump in and take
    a look at some of the most common and basic parts that can be found in nearly
    any desktop application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 提供了大量类和实用工具。实际上，基本集合非常丰富，以至于完全有可能在不发明任何自定义部分的情况下构建一个功能齐全的应用程序。所以让我们开始，看看几乎在任何桌面应用程序中都能找到的一些最常见和基本的部分。
- en: Creating Stock Buttons
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建股票按钮
- en: Nearly all applications have buttons in them and among the buttons there are
    many common ones such as Ok and Cancel that appear over and over again. In wxPython,
    these common buttons are known as Stock Buttons, because they are constructed
    by passing a Stock ID to the constructor of a `Button.`
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序都包含按钮，在这些按钮中有很多常见的按钮，例如“确定”和“取消”，它们反复出现。在wxPython中，这些常见的按钮被称为库存按钮（Stock
    Buttons），因为它们是通过传递一个库存ID给`Button`构造函数来构建的。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s make a simple `Panel` that has four `Buttons` on it, to see how Stock
    Buttons can be created:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`面板`，在其上放置四个`按钮`，以查看如何创建股票按钮：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Common buttons are created by using a standard `Button` with a Stock ID and
    no label. The framework will then create the correct type of button with the proper
    label for the current platform. Each platform has slightly different standards
    for these common buttons. By using Stock Buttons, these cross-platform differences
    can be handled by the framework. For example, take a look at the following two
    screenshots of the previous sample code being run on Windows 7 and OS X respectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 常见按钮是通过使用带有库存ID但没有标签的标准`Button`创建的。框架随后将为当前平台创建正确类型的按钮并带有适当的标签。每个平台对于这些常见按钮都有略微不同的标准。通过使用库存按钮，这些跨平台差异可以由框架处理。例如，查看以下两个屏幕截图，展示了之前示例代码在Windows
    7和OS X上分别运行的情况。
- en: 'Screenshot of Windows 7:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 7 的屏幕截图：
- en: '![How it works...](img/1780_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_03_01.jpg)'
- en: 'Screenshot of OS X:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OS X的屏幕截图：
- en: '![How it works...](img/1780_03_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_03_02.jpg)'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Platform Notice: On Linux, depending upon the version of GTK, Stock Buttons
    will also have the proper theme provided icon displayed on them as well.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 平台通知：在Linux上，根据GTK的版本，标准按钮也将显示适当的主题图标。
- en: There's more...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Stock buttons can be created from nearly all of the Stock IDs. If your text
    editor does not provide completion hints, here is a quick way to see all of the
    available Stock IDs: Just run the following code in your Python interpreter to
    introspect the `wx` namespace for all of the ID constants.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从几乎所有的股票ID创建股票按钮。如果你的文本编辑器不提供自动完成提示，这里有一个快速查看所有可用股票ID的方法：只需在你的Python解释器中运行以下代码，以检查`wx`命名空间中的所有ID常量。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* contains a detailed discussion
    about the IDs used to construct Stock Buttons.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*使用股票ID*配方，*使用wxPython入门*详细讨论了用于构建股票按钮的ID。'
- en: The *Buttons, buttons, and more buttons* recipe in this chapter shows how to
    use the other button classes available in wxPython.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *按钮、按钮，还有更多按钮* 菜单展示了如何使用 wxPython 中可用的其他按钮类。
- en: The *Standard dialog button layout* recipe in Chapter 7, *Window Layout and
    Design* shows how Stock Buttons are used to achieve easy control layout in dialogs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7章“窗口布局与设计”中的*标准对话框按钮布局*配方展示了如何使用Stock Buttons在对话框中实现易于控制的布局。
- en: Buttons, buttons, and more buttons
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮，按钮，还有更多的按钮
- en: The regular `Button` class only allows for displaying a label on the button.
    If this is a little too plain for the needs of your application, you're in luck.
    wxPython also provides a wide variety of other types of buttons that provide a
    different look and feel, as well as extended functionality. This recipe will introduce
    a number of the other button controls that are available in wxPython.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的 `Button` 类仅允许在按钮上显示标签。如果这对你应用的某些需求来说略显单调，那么你很幸运。wxPython 还提供了多种不同外观和感觉的按钮类型，以及扩展的功能。本食谱将介绍
    wxPython 中可用的其他一些按钮控件。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Version Notice: The `agw` package and `GradientButton` class used in the following
    code are only available in wxPython 2.8.9.2 and later.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 版本说明：以下代码中使用的`agw`包和`GradientButton`类仅在wxPython 2.8.9.2及以后的版本中可用。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see what these different `Buttons` look like and what they can do, we will
    make a simple `Panel` with some different examples of these additional button
    classes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些不同的`按钮`的外观以及它们能做什么，我们将创建一个简单的`面板`，其中包含这些额外按钮类的不同示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code generates the following window:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下窗口：
- en: '![How to do it...](img/1780_03_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_03_03.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows the basic use of four different button classes, so let's take
    a look at each of them one by one to see what they can do.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了四个不同按钮类的基本用法，所以让我们逐一查看每个按钮类，看看它们能做什么。
- en: ToggleButton
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换按钮
- en: The `ToggleButton` is another native button provided by wxPython. It is just
    like the standard `Button`, but provides two states. The button will be toggled
    from its regular state to a pressed state when clicked on. A second click will
    toggle it back to its regular state once again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleButton` 是 wxPython 提供的另一个原生按钮。它就像标准的 `Button` 一样，但提供了两种状态。当点击按钮时，按钮将从其常规状态切换到按下状态。第二次点击将再次将其切换回常规状态。'
- en: BitmapButton
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图按钮
- en: 'The `BitmapButton` is a native platform button used for showing an image instead
    of label text. The usage of this button is just like the standard `Button` except
    that it takes a `Bitmap` as an argument instead of a label string. The `Bitmap`
    for each state of when the button is being pressed or interacted with by the mouse
    can also be customized with the following methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapButton` 是一个原生平台按钮，用于显示图像而不是标签文本。此按钮的使用方式与标准 `Button` 类似，只是它接受一个 `Bitmap`
    作为参数，而不是标签字符串。当按钮被按下或通过鼠标与之交互时，每个状态的 `Bitmap` 也可以通过以下方法进行自定义：'
- en: '| Method | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SetBitmapDisabled` | Sets the Bitmap to show when the button is disabled.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `SetBitmapDisabled` | 设置按钮禁用时显示的位图。 |'
- en: '| `SetBitmapFocus` | Sets the Bitmap to show when the button has the keyboard
    focus. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `SetBitmapFocus` | 设置按钮获得键盘焦点时显示的位图。 |'
- en: '| `SetBitmapHover` | Sets the Bitmap to show when the mouse cursor is hovering
    over the button. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `SetBitmapHover` | 设置鼠标光标悬停在按钮上时显示的位图。 |'
- en: '| `SetBitmapLabel` | Sets the default button (same as what is provided to the
    constructor). In the absence of other bitmaps, this one will be used for all states.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `SetBitmapLabel` | 设置默认按钮（与提供给构造函数的相同）。在没有其他位图的情况下，此位图将用于所有状态。 |'
- en: '| `SetBitmapSelected` | Sets the Bitmap to use when the button is pressed.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `SetBitmapSelected` | 设置按钮按下时使用的位图。 |'
- en: PlateButton
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面板按钮
- en: The `PlateButton` is an owner-drawn button class provided by the `platebtn`
    module in `wx.lib. PlateButtons` are a type of flat button control that will change
    its background colour when the mouse hovers over it or when it is clicked on.
    A `PlateButton` can be displayed with just a label, with just a `Bitmap`, with
    both a label and a `Bitmap`, or any of the previous combinations plus as a drop-down
    `Menu.`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlateButton` 是由 `wx.lib.platebtn` 模块提供的一个由所有者绘制的按钮类。`PlateButtons` 是一种平面按钮控件，当鼠标悬停在其上或点击时，会改变其背景颜色。`PlateButton`
    可以仅显示标签，仅显示 `Bitmap`，同时显示标签和 `Bitmap`，或者任何上述组合加上一个下拉 `Menu`。'
- en: The look and feel of the button can also be customized to control the color
    of the highlighting, the text label color, the button shape, and how the highlight
    is drawn. The `PB_STYLE_SQUARE` style flag will make the button take up a square
    shape instead of using its default rounded edges and the `PB_STYLE_GRADIENT` style
    flag will cause the background to be drawn as a gradient based on the highlighting
    colour. In addition to this customizability, the `PlateButton` also fully implements
    the `BitmapButton` API so it can be used as a drop-in replacement for a `BitmapButton`
    in existing applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的外观和感觉也可以自定义，以控制高亮颜色、文本标签颜色、按钮形状以及高亮显示的绘制方式。`PB_STYLE_SQUARE`样式标志将使按钮呈现正方形形状，而不是使用其默认的圆角，而`PB_STYLE_GRADIENT`样式标志将导致背景根据高亮颜色绘制为渐变色。除了这种可定制性之外，`PlateButton`还完全实现了`BitmapButton`
    API，因此它可以作为现有应用程序中`BitmapButton`的即插即用替代品。
- en: GradientButton
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GradientButton
- en: The `GradientButton` is very similar to the `PlateButton`. The only difference
    is that it is not a flat button, it doesn't support a drop-down menu, and it is
    more flexible in what it allows for configuring the gradient colors.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`GradientButton`与`PlateButton`非常相似。唯一的区别在于它不是一个平面按钮，不支持下拉菜单，并且在配置渐变颜色方面更加灵活。'
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are still quite a few more button implementations out there that you may
    find useful in your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有相当多的按钮实现可供选择，你可能会在你的应用程序中找到它们很有用。
- en: GenericButtons
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用按钮
- en: '`GenericButtons` are a collection of classes in `wx.lib.buttons` that provide
    some basic owner-drawn buttons as well as owner-drawn implementations of the native
    buttons that maintain the look of the native buttons but work around some limitations.
    For example, there is `GenBitmapTextButton` which provides a bitmap button that
    also supports displaying a label, and `GenBitmapToggleButton` which allows for
    a toggle button that shows a `Bitmap.`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenericButtons` 是 `wx.lib.buttons` 中的一组类，它提供了一些基本的自定义按钮，以及一些自定义的本地按钮实现。这些自定义的本地按钮保持了本地按钮的外观，但解决了某些限制。例如，有
    `GenBitmapTextButton`，它提供了一个同时支持显示标签的位图按钮，以及 `GenBitmapToggleButton`，它允许创建一个显示
    `Bitmap` 的切换按钮。'
- en: AquaButton
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AquaButton
- en: '`AquaButtons` are an owner-drawn button class with a glassy appearance that
    approximates the look and feel of native Macintosh Aqua Buttons. Because the class
    is owner drawn, it will provide the same look and feel on all platforms. This
    class can be found in `wx.lib.agw.aquabutton`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`AquaButtons` 是一个由所有者绘制的按钮类，具有类似玻璃外观，近似于原生 Macintosh Aqua 按钮的外观和感觉。由于该类由所有者绘制，它将在所有平台上提供相同的外观和感觉。此类可以在
    `wx.lib.agw.aquabutton` 中找到。'
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating Stock Buttons* recipe in this chapter shows how to create standard
    buttons.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *创建股票按钮* 菜单展示了如何创建标准按钮。
- en: Offering options with CheckBoxes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供带有复选框的选项
- en: A `CheckBox` is a common, basic control that allows for a user to select one
    of two or three states, depending on the style of `CheckBox`, though it is typically
    associated with just a `True` or `False` state. In this recipe, we will take a
    look at how to use the `CheckBox` control.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckBox` 是一种常见的基本控件，允许用户根据 `CheckBox` 的样式选择两种或三种状态之一，尽管它通常只与 `True` 或 `False`
    状态相关联。在本教程中，我们将探讨如何使用 `CheckBox` 控件。'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see how `CheckBoxes` work, we will create a little window with two different
    kinds of `CheckBoxes` in it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`CheckBoxes`如何工作，我们将创建一个包含两种不同类型`CheckBoxes`的小窗口：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created two `CheckBoxes`; the first is the standard two-state `CheckBox`
    and the second is a three-state `CheckBox`. The state of a two state `CheckBox`
    can be programmatically controlled through its `GetValue` and `SetValue` methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 `CheckBoxes`；第一个是标准的双态 `CheckBox`，第二个是一个三态 `CheckBox`。双态 `CheckBox`
    的状态可以通过其 `GetValue` 和 `SetValue` 方法进行程序控制。
- en: 'The three-state checkbox is created by specifying the two style flags `CHK_3STATE`
    and `CHK_ALLOW_3RD_STATE_FOR_USER`. The second style flag can be omitted if you
    want to limit users from being able to set the undetermined state, so that it
    can only be done programmatically. Three-state checkboxes use the `Get3StateValue`
    and `Set3StateValue` methods with the following values to programmatically control
    the `CheckBox` state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 三状态复选框是通过指定两个样式标志 `CHK_3STATE` 和 `CHK_ALLOW_3RD_STATE_FOR_USER` 来创建的。如果您想限制用户无法设置不确定状态，从而只能通过程序来设置，则可以省略第二个样式标志。三状态复选框使用
    `Get3StateValue` 和 `Set3StateValue` 方法，以下列值来程序化控制 `CheckBox` 的状态：
- en: '`wx.CHK_CHECKED`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CHK_CHECKED`'
- en: '`wx.CHK_UNCHECKED`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CHK_UNCHECKED`'
- en: '`wx.CHK_UNDETERMINED`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CHK_UNDETERMINED`'
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* shows how to use the `BoxSizer` class
    to control layout.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。窗口布局与设计")中的*使用BoxSizer布局*配方，*窗口布局与设计*展示了如何使用`BoxSizer`类来控制布局。'
- en: Using the TextCtrl
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TextCtrl
- en: The `TextCtrl` is the basic means of allowing users to input textual data into
    an application. This control has many possible uses and modes of operation. This
    recipe will show how to create a simple login dialog that uses two `TextCtrls`
    to provide input fields for the login name and password.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextCtrl` 是允许用户将文本数据输入到应用程序中的基本手段。这个控件有许多可能的用途和操作模式。本食谱将展示如何创建一个简单的登录对话框，该对话框使用两个
    `TextCtrls` 来提供登录名和密码的输入字段。'
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, lets create the `Dialog` class that will hold the other controls:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`Dialog`类，它将包含其他控件：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next let''s make the `Panel` that will hold the `TextCtlr` controls for the
    users to enter their login information into:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们创建一个`Panel`，它将包含用于用户输入登录信息的`TextCtlr`控件：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![How to do it...](img/1780_03_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_03_04.jpg)'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We did a number of things in the previous code, but since the focus of this
    recipe is on the `TextCtrl` object, let's start by taking a look at the two `TextCtrl`
    object that we created.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们做了很多事情，但由于本菜谱的重点在于`TextCtrl`对象，让我们先来看看我们创建的两个`TextCtrl`对象。
- en: The first text control for the username is just a default `TextCtrl` created
    with all of the default arguments. By default, a `TextCtrl` object is created
    as a single line control. This creates just a simple text box that the user can
    type any arbitrary number of characters into.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名的第一个文本控件只是一个使用所有默认参数创建的默认`TextCtrl`。默认情况下，一个`TextCtrl`对象被创建为一个单行控件。这仅仅创建了一个简单的文本框，用户可以输入任意数量的字符。
- en: The second text control uses the special `TE_PASSWORD` style flag. This creates
    a `TextCtrl` that will disguise its input with asterisk characters, just like
    you see in any password entry field in most applications or websites. As a user
    types in this control, each character that is typed in will be displayed as an
    asterisk, but the actual character values are stored internally by the control
    and can be accessed via `GetValue`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种文本控制使用特殊的 `TE_PASSWORD` 样式标志。这会创建一个 `TextCtrl`，它会用星号字符隐藏其输入，就像你在大多数应用程序或网站中的任何密码输入字段中看到的那样。当用户在此控件中输入时，每个输入的字符都会显示为星号，但实际的字符值由控件内部存储，可以通过
    `GetValue` 方法访问。
- en: This dialog should be shown with `ShowModal`, and when `ShowModal` returns you
    can just retrieve the values by using the accessor methods `GetUsername` and `GetPassword`
    in order to perform the login validation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框应以`ShowModal`方式显示，当`ShowModal`返回时，您可以通过使用访问器方法`GetUsername`和`GetPassword`来检索值，以便执行登录验证。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `TextCtrl` class has a fairly large collection of style flags that can be
    supplied to its constructor to modify its behavior for different use cases. Included
    below is a list of most-commonly-used style flags and a description of what each
    one does. The rest can be found in wxPython's online API documentation ([http://wxpython.org/docs/api/](http://wxpython.org/docs/api/)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextCtrl` 类提供了一系列样式标志，可以在其构造函数中提供以修改其在不同用例中的行为。以下列出了最常用的样式标志及其功能的描述。其余的可以在
    wxPython 的在线 API 文档中找到（[http://wxpython.org/docs/api/](http://wxpython.org/docs/api/)）。'
- en: '| Style flags | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.TE_PROCESS_ENTER` | Will cause the control to generate a `wx.EVT_COMMAND_TEXT_ENTER`
    event when the *Enter* key is pressed. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_PROCESS_ENTER` | 将在按下 *Enter* 键时使控件生成一个 `wx.EVT_COMMAND_TEXT_ENTER`
    事件。 |'
- en: '| `wx.TE_PROCESS_TAB` | Allows a `wx.EVT_CHAR` event to be issued when the
    *Tab* key is pressed. Without this style set, the *Tab* key will allow the user
    to tab into the next control in the window. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_PROCESS_TAB` | 允许在按下 *Tab* 键时发出一个 `wx.EVT_CHAR` 事件。如果没有设置此样式，*Tab*
    键将允许用户切换到窗口中的下一个控件。 |'
- en: '| `wx.TE_MULTILINE` | Allows the `TextCtrl` to have multiple lines. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_MULTILINE` | 允许 `TextCtrl` 有多行。 |'
- en: '| `wx.TE_READONLY` | Makes the control read only, so that the user cannot enter
    text into it. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_READONLY` | 使控件为只读，用户无法向其中输入文本。 |'
- en: '| `wx.TE_RICH2` | Use the `RichText` version of the control. (only applicable
    on Windows). |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_RICH2` | 使用控件的`RichText`版本。（仅适用于Windows）。 |'
- en: '| `wx.TE_LEFT` | Aligns all text to the left-hand side of the control. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_LEFT` | 将所有文本对齐到控件左侧。 |'
- en: '| `wx.TE_CENTER` | Aligns all text to the center of the control |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_CENTER` | 将所有文本对齐到控件中心 |'
- en: '| `wx.TE_RIGHT` | Aligns all text to the right-hand side of the control. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TE_RIGHT` | 将所有文本对齐到控件右侧。 |'
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Validating Input with validators* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* shows how to use a Validator to validate user
    input.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。响应事件")中的*使用验证器验证输入*配方展示了如何使用验证器来验证用户输入。'
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* shows how to use the BoxSizer class to
    control layout
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用BoxSizer布局](ch07.html "第7章。窗口布局与设计")中的*使用BoxSizer*配方展示了如何使用BoxSizer类来控制布局'
- en: Providing choices with the Choice control
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择控件提供选项
- en: The `Choice` control is a means to allow the user to make a single selection
    from a list of possible selections. It does this by displaying the currently-selected
    choice and offering the list of other possible choices in a pop-up when the control
    is clicked on by the user. This makes it very efficient in its use of screen space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`选择`控件是一种允许用户从可能的选项列表中做出单一选择的手段。它通过显示当前选中的选项，并在用户点击控件时弹出一个包含其他可能选项的列表来实现这一点。这使得它在屏幕空间的使用上非常高效。'
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see how the `Choice` control works, we will make a simple `Panel` that has
    a `Choice` control with three choices in it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`Choice`控件的工作原理，我们将创建一个简单的`Panel`，其中包含一个具有三个选项的`Choice`控件：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Choice` control manages a list of strings. The list of strings that the
    control contains can be specified either in the constructor or by calling the
    `SetItems` method with a list of strings to put in the control. When clicked on,
    the control will display a pop-up list of all of the strings. After the user makes
    a selection, an `EVT_CHOICE` event will be fired.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Choice` 控件管理一个字符串列表。该控件包含的字符串列表可以通过构造函数指定，或者通过调用带有要放入控件的字符串列表的 `SetItems`
    方法来指定。当点击时，控件将显示一个包含所有字符串的弹出列表。用户做出选择后，将触发一个 `EVT_CHOICE` 事件。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Platform Notice: The `Choice` control in Windows does not automatically select
    its first item when created. Due to this inconsistency, it is sometimes desirable
    to explicitly set the selection after creating the control, as we have done in
    this example, in order to ensure consistent behavior across platforms.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 平台通知：在 Windows 中，`Choice` 控件在创建时不会自动选择其第一个项目。由于这种不一致性，有时在创建控件后显式设置选择是可取的，正如我们在本例中所做的那样，以确保跨平台行为的一致性。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The items in the control can be manipulated or changed after the control has
    been created by using the following methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 控制项创建后，可以使用以下方法进行操作或更改：
- en: '| Method | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Append` | Append a string to the end of the list managed by the control
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Append` | 将字符串添加到由控制器管理的列表末尾 |'
- en: '| `AppendItems` | Append a list of strings to the list managed by the control
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `AppendItems` | 将字符串列表追加到由控件管理的列表中 |'
- en: '| `Insert` | Insert a string into the list managed by the control |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `插入` | 将字符串插入由控件管理的列表中 |'
- en: '| `SetItems` | Set the list of strings that the control displays |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `SetItems` | 设置控制显示的字符串列表 |'
- en: Adding Menus and MenuBars
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单和菜单栏
- en: 'Most applications have menus. Menus are a means to providing the users of the
    application with a way to execute actions either by clicking on them or by using
    keyboard shortcuts that can be associated with each menu item. An application''s
    menus consist of three components: a `MenuBar, Menus`, and `MenuItems`. The `MenuBar`
    contains the `Menus` and the `Menus` contain the `MenuItems`. This recipe will
    show how to add a `MenuBar` with some Menus to a `Frame`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都有菜单。菜单是提供给应用程序用户执行操作的一种方式，可以通过点击它们或使用与每个菜单项关联的键盘快捷键来实现。应用程序的菜单由三个组件组成：`MenuBar`（菜单栏）、`Menus`（菜单）和`MenuItems`（菜单项）。`MenuBar`包含`Menus`，而`Menus`包含`MenuItems`。本教程将展示如何向`Frame`添加一个包含一些菜单的`MenuBar`。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here we will make a `Frame` that has some `Menu` options for controlling actions
    in a `TextCtrl:`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个具有一些`菜单`选项的`Frame`，用于控制`TextCtrl:`中的操作：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing to look at is where we created the `MenuBar` object. The `MenuBar`
    is what we need to attach all of our `Menus` to, and it will ultimately become
    responsible for managing them. Next we start to make our `Menus`, which is a rather
    straightforward process. All that needs to be done is to call `Append` for each
    new item that we wish to add to the `Menu`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要查看的是我们创建了哪个 `MenuBar` 对象。`MenuBar` 是我们将所有 `Menus` 附着的对象，它最终将负责管理它们。接下来，我们开始创建我们的
    `Menus`，这是一个相当直接的过程。需要做的只是为每个我们希望添加到 `Menu` 中的新项目调用 `Append` 方法。
- en: '`Append` accepts a few arguments, but the important one to notice is the one
    for the label. The string that we pass can have some special formatting options
    in it to setup keyboard shortcuts for the `MenuItem`. Placing an ''&'' before
    a letter in the label will setup a keyboard mnemonic that will allow for keyboard
    navigation to the item. More importantly, though, is that placing a *Tab* character
    (`\t`) followed by a shortcut option *Ctrl + C* will setup a keyboard shortcut
    to select the menu option and cause an `EVT_MENU` event to be generated.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Append` 函数接受几个参数，但需要注意的重要参数是标签参数。我们传递的字符串中可以包含一些特殊的格式化选项，用于为 `MenuItem` 设置键盘快捷键。在标签中放置一个字母前的
    ''&'' 将设置一个键盘助记符，允许通过键盘导航到该项目。然而，更重要的是，放置一个 *Tab* 字符 (`\t`) 后跟一个快捷键选项 *Ctrl +
    C* 将设置一个键盘快捷键来选择菜单选项，并导致生成一个 `EVT_MENU` 事件。'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Platform Notice: On OS X, the *Ctrl* keyword will be automatically translated
    to the Apple/Command key.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 平台通知：在 OS X 操作系统中，*Ctrl* 键字将自动转换为 Apple/Command 键。
- en: Finally, we just need to call `Append` on our `MenuBar` in order to add each
    of the `Menus` that we created to it, and then finally call `SetMenuBar` on the
    `Frame` to add the `MenuBar` to our `Frame`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需在我们的`MenuBar`上调用`Append`方法，以便将我们创建的每个`Menus`添加到其中，然后最终在`Frame`上调用`SetMenuBar`方法，将`MenuBar`添加到我们的`Frame`中。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Menus have some additional functionality that we did not cover above. Following
    below are some references to a few more things that you can do with `Menus`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单还有一些我们上面没有提到的附加功能。以下是一些关于你可以使用`菜单`做更多事情的参考。
- en: SubMenus
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子菜单
- en: '`Menus` can have submenus appended to them, via the `AppendMenu` function.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`菜单`可以通过`AppendMenu`函数添加子菜单。'
- en: Customizing MenuItems
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义菜单项
- en: '`MenuItems` are created when calling `Append` on a `Menu`. The `Append` method
    takes a "kind" keyword parameter that can accept any of the following values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Menu`上调用`Append`方法时，会创建`MenuItems`。`Append`方法接受一个名为"kind"的关键字参数，它可以接受以下任何值：
- en: '| Value | Description |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.ITEM_NORMAL` | Default value |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ITEM_NORMAL` | 默认值 |'
- en: '| `wx.ITEM_SEPARATOR` | Creates a separator item. It''s easier to just call
    `AppendSeparator` than do this. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ITEM_SEPARATOR` | 创建一个分隔符项。直接调用 `AppendSeparator` 比这样做更简单。 |'
- en: '| `wx.ITEM_CHECK` | Adds a `CheckBox` to the `Menu`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ITEM_CHECK` | 向 `Menu` 添加一个 `CheckBox`。 |'
- en: '| `wx.ITEM_RADIO` | Adds a `RadioButton` to the `Menu`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ITEM_RADIO` | 向 `Menu` 添加一个 `RadioButton`。 |'
- en: '`MenuItems` can also have `Bitmaps` added to them by calling `SetBitmap` on
    the `MenuItem` object returned by calling `Append` on the `Menu`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItems`也可以通过在`Menu`对象的`Append`方法返回的`MenuItem`对象上调用`SetBitmap`方法来添加`Bitmaps`。'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Platform Notice: On Linux/GTK, `MenuItems` that use Stock IDs will automatically
    get system theme provided bitmaps associated with them.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 平台通知：在 Linux/GTK 上，使用库存 ID 的 `MenuItems` 将自动获得与它们关联的系统主题提供的位图。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* discusses the use of
    the built-in standard control IDs.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*使用库存ID*配方，在*使用wxPython入门*一书中讨论了内置标准控件ID的使用。'
- en: The *Using UpdateUI events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* discusses how to use `UpdateUI` events to
    manage the UI's state.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。响应事件")中的*使用UpdateUI事件*配方，在*响应事件*一节中讨论了如何使用`UpdateUI`事件来管理UI的状态。'
- en: Working with ToolBars
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具栏
- en: '`ToolBars` are a lot like `Menus` in that they provide a means to link an action
    in the interface with an action in the application. They differ in that `ToolBars`
    use images to represent actions and must be clicked on directly in order to initiate
    the action. They make for an easy point and click interface for the user to interact
    with. This recipe will show a custom `ToolBar` class that automatically gets bitmaps
    from the system''s `ArtProvider`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`工具栏`与`菜单`有很多相似之处，它们都提供了一种将界面中的操作与应用程序中的操作相连接的方式。它们的不同之处在于`工具栏`使用图像来表示操作，并且必须直接点击以启动操作。它们为用户提供了一个简单直观的点选界面。本食谱将展示一个自定义的`工具栏`类，该类会自动从系统的`ArtProvider`获取位图。'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by defining our custom `ToolBar` class, and then map some Stock
    IDs to art resource IDs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的自定义`ToolBar`类，然后映射一些股票ID到艺术资源ID：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can make use of this custom `ToolBar` class anywhere that we want to
    have a `ToolBar`. The following code snippet is a minimal example of creating
    an `EasyToolBar` with three items:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这个自定义的 `ToolBar` 类用于任何我们需要 `ToolBar` 的地方。以下是一个创建包含三个项目的 `EasyToolBar`
    的最小示例代码片段：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `EasyToolBar` class makes use of a map of stock IDs to art resource IDs.
    When the `AddEasyTool` method is called, it will look up that art resource in
    the system's art provider. This simplifies the use of the `ToolBar` by quite a
    bit since we don't need to repeat the code for getting the appropriate bitmap
    each time we want to add a tool.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`EasyToolBar` 类利用了一个股票ID到艺术资源ID的映射。当调用 `AddEasyTool` 方法时，它将在系统的艺术提供者中查找该艺术资源。这大大简化了
    `ToolBar` 的使用，因为我们不需要每次添加工具时都重复编写获取适当位图的代码。'
- en: The `ToolBarFrame` class shows an example of the use of the `EasyToolBar`. Using
    a `ToolBar` can be summed up in a four-step process. First, create the `ToolBar`,
    second add the tools, third call `Realize` to tell the `ToolBar` that all of the
    tools have been added, and then fourth and finally call the `SetToolBar` method
    of the `Frame` in order to add the `ToolBar` to the `Frame`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolBarFrame` 类展示了如何使用 `EasyToolBar` 的一个示例。使用 `ToolBar` 可以概括为四个步骤。首先，创建 `ToolBar`，其次添加工具，然后调用
    `Realize` 方法来告知 `ToolBar` 所有工具已经添加完毕，最后，调用 `Frame` 的 `SetToolBar` 方法以将 `ToolBar`
    添加到 `Frame` 中。'
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: ToolBar styles
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具栏样式
- en: 'There a number of style flags that can be passed to a `ToolBars` constructor
    to modify its appearance and behavior. Following is a list of some of the more
    useful ones:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多样式标志可以传递给`ToolBars`构造函数以修改其外观和行为。以下是其中一些更有用的列表：
- en: '| Style flags | Description |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.TB_DOCKABLE` | Allows the `ToolBar` to be undocked from the `Frame` (GTK
    Only) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_DOCKABLE` | 允许 `ToolBar` 从 `Frame` 中解耦（仅限 GTK） |'
- en: '| `wx.TB_FLAT` | Makes the `ToolBar` look flat (MSW and GTK ONLY) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_FLAT` | 使 `ToolBar` 看起来更扁平（仅限 MSW 和 GTK） |'
- en: '| `wx.TB_HORIZONTAL` | Horizontal tool layout |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_HORIZONTAL` | 水平工具布局 |'
- en: '| `wx.TB_VERTICAL` | Vertical tool layout |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_VERTICAL` | 垂直工具布局 |'
- en: '| `wx.TB_TEXT` | Show labels below the tool icon |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_TEXT` | 在工具图标下方显示标签 |'
- en: '| `wx.TB_NO_TOOLTIPS` | Don''t show `ToolTips` when tools are hovered over
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_NO_TOOLTIPS` | 当工具被悬停时不要显示 `ToolTips` |'
- en: '| `wx.TB_BOTTOM` | Put the `ToolBar` at the bottom of the parent window |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_BOTTOM` | 将 `ToolBar` 放置在父窗口的底部 |'
- en: '| `wx.TB_RIGHT` | Put the `ToolBar` at the right-hand side of the parent window
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TB_RIGHT` | 将 `ToolBar` 放置在父窗口的右侧 |'
- en: Additional types of tools
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他类型的工具
- en: It is possible to add different types of tools or controls to a `ToolBar` besides
    the standard icon tools. Here is a quick reference to some of these other `ToolBar`
    methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的图标工具外，还可以向`ToolBar`添加不同类型的工具或控件。以下是一些其他`ToolBar`方法的快速参考。
- en: '| ToolBar methods | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 工具栏方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AddControl` | Allows for a control such as a `Button` to be added to the
    `ToolBar`. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `AddControl` | 允许将如 `Button` 这样的控件添加到 `ToolBar` 中。 |'
- en: '| `AddCheckLabelTool` | Adds a tool that can be toggled. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `AddCheckLabelTool` | 添加一个可切换的工具。 |'
- en: '| `AddRadioLabelTool` | Adds a tool that will work like a `RadioButton`. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `AddRadioLabelTool` | 添加一个将像 `RadioButton` 一样工作的工具。 |'
- en: '| `AddSeparator` | Adds a vertical line to the `ToolBar` to separate items.
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `AddSeparator` | 在 `ToolBar` 中添加一条垂直线以分隔项目。 |'
- en: Events
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: '`ToolBar` tools will fire an `EVT_TOOL` event when clicked on. If you already
    have a `MenuItem` for the same ID that is bound to an `EVT_MENU` event handler,
    it is not necessary to create a separate event handler for the tool event. The
    system will automatically route the tool event to your menu handler.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolBar` 工具在点击时会触发一个 `EVT_TOOL` 事件。如果你已经有一个与相同 ID 绑定到 `EVT_MENU` 事件处理器的 `MenuItem`，那么就不需要为工具事件创建单独的事件处理器。系统会自动将工具事件路由到你的菜单处理器。'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding Menus and MenuBars* recipe in this chapter discusses the use of
    menus and menu events, which are closely related to toolbars.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*添加菜单和菜单栏*的配方讨论了菜单和菜单事件的使用，这些与工具栏密切相关。
- en: The *Customizing the ArtProvider* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    includes further examples and information about retrieving bitmap resources.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。创建组件和扩展功能")的*自定义ArtProvider*配方中，*创建组件和扩展功能*包括更多关于检索位图资源的示例和信息。
- en: How to use PopupMenus
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用弹出菜单
- en: Pop-up menus (a.k.a context menus) are a useful way of providing context-sensitive
    access to actions when a user right clicks on a control or on a part of a window.
    Pop-up menus work the same way as a regular menu but require some special handling
    since there is no `MenuBar` to manage them. This recipe will create a mixin class
    to help manage a pop-up menu.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单（也称为上下文菜单）是在用户右击控件或窗口的一部分时提供上下文相关操作访问的有用方式。弹出菜单的工作方式与常规菜单相同，但需要一些特殊处理，因为没有`MenuBar`来管理它们。本食谱将创建一个混合类来帮助管理弹出菜单。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will define a mixin class to manage the creation and lifetime of a
    context menu:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个混合类来管理上下文菜单的创建和生命周期：
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This little mixin class is very generic and can be used with any type of window
    subclass to add custom context menu support. The subclass that uses this mixin
    must override the `CreateContextMenu` method to make its own `Menu`, and then
    the mixin will take care of the rest. Following is a minimal example of using
    the `PopupMenuMixin` class. It will create a `Panel` that has a context menu with
    three items on it; a more complete example is included in the example code that
    accompanies this topic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小巧的混合类非常通用，可以与任何类型的窗口子类一起使用，以添加自定义上下文菜单支持。使用此混合类的子类必须重写`CreateContextMenu`方法来创建自己的`Menu`，然后混合类将处理其余部分。以下是一个使用`PopupMenuMixin`类的最小示例。它将创建一个带有三个项目的上下文菜单的`Panel`；更完整的示例包含在伴随此主题的示例代码中。
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `EVT_CONTEXT_MENU` is fired when a user right-clicks, or initiates a context
    menu from the keyboard. Because context menus can be shown in multiple ways, it
    is important to use `EVT_CONTEXT_MENU` instead of using the mouse right-click
    event. Our mixin class will catch this event and first clean up any existing `Menu`.
    Since pop-up menus do not have a `MenuBar` to manage them, it is necessary to
    clean them up ourselves, otherwise, if they are not destroyed, they can cause
    memory leaks. Next, the subclass's `CreateContextMenu` method will be called to
    add the items to the `Menu`. Finally, we display the `Menu` by calling the `PopupMenu`
    method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户右键点击或从键盘发起上下文菜单时，会触发 `EVT_CONTEXT_MENU` 事件。因为上下文菜单可以通过多种方式显示，所以使用 `EVT_CONTEXT_MENU`
    而不是使用鼠标右键事件是很重要的。我们的混合类将捕获此事件，并首先清理任何现有的 `Menu`。由于弹出菜单没有 `MenuBar` 来管理它们，因此我们需要自己清理它们，否则，如果它们没有被销毁，可能会导致内存泄漏。接下来，将调用子类的
    `CreateContextMenu` 方法来向 `Menu` 添加项目。最后，我们通过调用 `PopupMenu` 方法来显示 `Menu`。
- en: When a user clicks on an item in the `Menu`, an `EVT_MENU` event will be sent
    to the window that the pop-up menu belongs to. Hence, it is necessary to `Bind`
    your own menu handlers to handle the `MenuEvents`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击菜单中的项目时，将向属于弹出菜单的窗口发送一个`EVT_MENU`事件。因此，有必要`绑定`你自己的菜单处理程序来处理`MenuEvents`。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding Menus and MenuBars* recipe in this chapter shows how to create menu
    objects.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *添加菜单和菜单栏* 菜单展示了如何创建菜单对象。
- en: The *Using mixin classes* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* discusses how
    to use mixin classes.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。设计方法和技巧")中的*使用混合类*配方，*设计方法和技巧*讨论了如何使用混合类。'
- en: Grouping controls with a StaticBox
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StaticBox对控件进行分组
- en: The `StaticBox` is a fairly simple control used to group other related controls
    together, by drawing a border around them that optionally includes a label. The
    usage of the `StaticBox` control is a little different than other controls though,
    due to its relationship with the controls it contains. Hence, this recipe will
    show how to use a `StaticBox`, and will give an explanation of some of its quirks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticBox` 是一个相对简单的控件，用于将其他相关控件组合在一起，通过围绕它们绘制一个可选包含标签的边框来实现。然而，由于它与包含的控件之间的关系，`StaticBox`
    控件的用法与其他控件略有不同。因此，这个菜谱将展示如何使用 `StaticBox`，并解释一些它的特性。'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see how to add controls to a `StaticBox`, let''s make a `Panel` class that
    has a `StaticBox`, and add a few controls to it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何向一个`StaticBox`添加控件，让我们创建一个包含`StaticBox`的`Panel`类，并向其添加一些控件：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even though a `StaticBox` is a container for other controls, it is actually
    a sibling of the controls that it contains, instead of being a parent window.
    The most important thing to remember when working with a `StaticBox` is that it
    must be created before any of the controls that it will contain. If it is not
    created before its siblings, then they will have issues processing mouse events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`StaticBox`是其他控件的容器，但实际上它是它所包含的控件的兄弟，而不是父窗口。在使用`StaticBox`时需要记住的最重要的一点是，它必须在它将包含的任何控件之前创建。如果它在其兄弟控件之前没有创建，那么它们在处理鼠标事件时将会有问题。
- en: The `StaticBox` uses a `StaticBoxSizer` to add the controls to the box, as well
    as to manage its size and to position the controls inside of it. The usage of
    a `StaticBoxSizer` is used just like a regular `BoxSizer` in all regards except
    that its constructor takes a `StaticBox` as the first argument. Calling the `Add`
    method of `StaticBoxSizer` is used to then add the controls to the `StaticBox`.
    Like with the `BoxSizer`, the `Add` method of `StaticBoxSizer` takes the object
    being added as the first parameter, and then optionally the proportion, the sizer
    flags, and border keyword parameters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticBox` 使用 `StaticBoxSizer` 来将控件添加到框中，同时管理其大小并在其中定位控件。`StaticBoxSizer`
    的使用方法与常规的 `BoxSizer` 在所有方面都相同，只是其构造函数接受一个 `StaticBox` 作为第一个参数。调用 `StaticBoxSizer`
    的 `Add` 方法用于将控件添加到 `StaticBox` 中。与 `BoxSizer` 类似，`StaticBoxSizer` 的 `Add` 方法将待添加的对象作为第一个参数，然后可选地包括比例、布局标志和边框关键字参数。'
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using* a *BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window
    Layout and Design"), *Window Layout and Design* contains more examples of sizer-based
    control layout.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。窗口布局与设计")的*使用*一个*BoxSizer*的食谱中，*窗口布局与设计*包含了更多基于sizer的控件布局示例。
