- en: Chapter 5. Audio Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build an audio media player!
  prefs: []
  type: TYPE_NORMAL
- en: Our application should have features offered by typical media players, such
    as play, pause, fast forward, rewind, next, mute, volume updates, and more. Our
    player should let the listener easily access individual media files or media library
    from his or her local drive.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, our player should be able to scan entire directories for
    a song and accordingly, auto update the playlist with all supported formats. All
    this and more.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start our project!
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On completion our player will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our audio player will be capable of playing audio files in AU, MP2, MP3, OGG/Vorbis,
    WAV, and WMA formats. It will have all the controls that you would expect of a
    small media player.
  prefs: []
  type: TYPE_NORMAL
- en: We will use cross-platform modules to write our code. This will ensure that
    our player can play audio files on Windows, Mac OS X, and Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to getting to hear good music while testing our code, this project
    will introduce us to several new ideas related to GUI programming with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: For one, we get to work with new sets of widgets, such as the Listbox, Progressbar,
    Scale, Radiobutton, and PMW Balloon widget.
  prefs: []
  type: TYPE_NORMAL
- en: We also take a look at the power of the Canvas widget in accommodating and precise
    positioning of other widgets within it.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the project, we take a look at a Tkinter extension named
    PMW. We also discuss some more Tkinter extensions that we do not use here, but
    are good to have in our GUI programming arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Though not a topic for this book, we also get a brief insight into the world
    of audio programming with Python, which necessarily looks at how to work with
    external libraries and API implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the key objectives outlined for this project include:'
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcing our experiences and learning from previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with new set of widgets, such as Listbox, Scale, Progressbar, and Radiobutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know more of the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with external APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know about some common Tkinter extensions, such as PMW, WCK, Tix,
    and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to refactor code at each stage of development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission Checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the following additional libraries for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Pyglet for audio manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Window users can download and install binary packages for pyglet from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mac OS X and Linux users should download and compile pyglet from the source
    ZIP file available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pyglet.org/download.html](http://www.pyglet.org/download.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When installing from source, you will also need to add the `AVbin.dll` to your
    current program directory. The link to the DLL file is also available at the preceding
    download page.
  prefs: []
  type: TYPE_NORMAL
- en: PMW Tkinter extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will be using **Python mega widgets** (**PMW**) Tkinter extension to code
    some widgets features not available in core Tkinter. PMW must be installed from
    the source package for all platforms. The package can be downloaded at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/](http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use Version 1.3.3 in our application, and other versions of PMW may not be
    compatible with our code.
  prefs: []
  type: TYPE_NORMAL
- en: Additional font
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an optional component meant only to augment our styling. We install
    a font to mimic the font of a digital clock. We have used the following font for
    this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.dafont.com/ds-digital.font](http://www.dafont.com/ds-digital.font)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed pyglet and PMW, execute the following command from
    your Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the command executes without any error message, you are ready to code your
    media player.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the audio to play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first goal of our project is to add the ability to play the audio file.
    As usual, we will keep the audio related logic separate from our GUI section.
    Therefore, we create two separate files: `main-gui.py` and `player.py`. (See *code
    5.01*)'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first code a basic GUI, which includes a Play button (which toggles between
    play and stop functionality) and an Add File button. At the end of this iteration,
    we should be able to load a file, play it, and stop it. By the end of this section,
    our application will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the GUI class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create the `GUI` class. The code for `main-gui.py` is as follows (see
    *code 5.01 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class named `GUI`, and run the Tkinter mainloop from within its
    `__init__ method`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will separate the actual audio manipulation logic such as play, pause, rewind,
    forward, and others in a separate class to be defined later. However, because
    we want those functionalities to be available in this `GUI` class, we pass an
    object instantiated out of that `player` class as an argument to our `__init__`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `self.player = player` within our `__init__` method ensures that the
    `player` class instance is available throughout the `GUI` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like we want to access the properties and methods of the `player` class
    from this `GUI` class, we also want the methods and attributes of the `GUI` class
    to be available within our `player` class. We, therefore, use the line `player.parent
    = self` in the `__init__` method. This creates a reference to self so that all
    its methods can be assessed inside the `player` class using the syntax `parent.attribute`
    and `parent.method()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these two lines of code, we have ensured that all properties of the `GUI`
    class will be available in the `player` class and vice versa; all properties of
    the `player` class will be available in the `GUI` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – creating the Play button and Add File button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this, we add two methods: `create_button_frame` and `create_bottom_frame`.
    The `create_button_frame` method holds the Play button, and the `create_bottom_frame`
    method holds the Add File button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the two buttons is associated with a `TkinterPhotoImage` class icon.
    We have provided a set of icons in a separate folder named `icons`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – toggling between play and pause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Play button has a command callback that toggles the button between play
    and stop functionality. The `toggle` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method, `toggle_play_pause`, changes the icon alternatively between a play
    and pause icon. It also calls the `play` and `pause` methods of the `player` class
    to play and pause the songs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 – add file dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Add File button opens `tkFileDialog`, which associates the file opened
    with a class attribute named `currentTrack`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – creating the Player class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's code the basic `player` class. For now, we will only add play and
    pause functionality to the class. The code for our `player` class is built upon
    the pyglet library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pyglet provides an object-oriented interface for developing rich media applications,
    such as games, audio and video tools, and others. It is a popular choice with
    Python programmers for media manipulation, because it has no external dependencies,
    supports a large number of formats, and is available on all major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed further, you might want to look at the API documentation
    of the pyglet player available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation tells us that we can play an audio file using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this code snippet to play the audio file. Accordingly, the code
    for our `Player` class is as follows(see *code 5.01 player.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class named `Player` and initialize its parent class as `None`.
    Recall that in our `GUI` class, we have defined a reference `player.parent = self`,
    so as to be able to assess our `GUI` class properties from within our `player`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define our `play_media` method, which is responsible for actually playing
    the sound. The method accesses the `currentTrack` attribute of the `GUI` class
    and tries to play it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this code can play audio files, pyglet requires running its own event
    loop to play the audio. This means it will return control to our GUI mainloop
    only after it has completed playing the entire sound, while freezing the Tkinter
    mainloop if run directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We, therefore, need to call the play method in a separate thread. We use the
    threading module to define a new method named `start_play_thread`, which simply
    calls our `play_media` method in a separate thread, thus preventing freezing out
    of GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we define the pause method, which pauses or stops the audio file being
    currently played. Pyglet does not differentiate between pause and stop functions.
    Therefore, we are typically stopping the audio using the pause command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 6 – running the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We finally run the application by creating an object out of our `GUI` class.
    Because this `GUI` class requires an object from the `player` class, we also instantiate
    a player object and pass it as an argument to our `GUI` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The last section of code creates an object from the `player` class that we are
    yet to define. The `player` class will take care of all audio manipulation using
    pyglet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first create an object out of the `player` class and pass it as an argument
    to the `__init__` method of our `GUI` class. This ensures that all attributes
    and methods of the `player` class are available within the `GUI` class using the
    syntax `player.attribute` and `player.method()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created a `GUI` class, added a button that toggles between
    play and pause. We added another button to add a file using `tkFileDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a `Player` class, which uses pyglet for playing audio files.
    The files are played in a separate thread to avoid freezing of the Tkinter mainloop
    while the audio is playing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ran our application by first creating a player object and passing
    it as an argument to another object created by our `GUI` class.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a functional audio player, where you can load a single file using
    `tkFileDialog`. After loading, you can press the Play button and the audio file
    starts playing. You can stop the audio by clicking the Play button, which toggles
    alternatively between play and pause functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a playlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the capability to play a single audio file, but what is an audio
    player if it does not allow for a playlist?
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a playlist feature to our player. Once a playlist is added, we accordingly
    need to provide buttons to add files to the playlist, delete files from it, and
    add all supported files from a chosen directory and the ability to delete all
    items in the list at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this iteration, we will have a player that looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a playlist](img/7941_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use Tkinter Listbox widget to provide a playlist. Let''s look at some
    of the key features of the Listbox widget:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a Listbox like you create any other widget as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you initially create the Listbox widget, it is empty. To insert one or
    more lines of text into the Listbox, you use the `insert()` method, which takes
    two arguments: an index of the position where the text is to be inserted and the
    actual string to be inserted as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `curselection()` method returns the index of all items selected in the
    list, and the `get()` method returns the list item for a given index as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, the Listbox widget has several other configurable options. For
    a complete Listbox widget reference, type the following into your Python interactive
    shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – adding an empty Listbox widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first add an empty Listbox widget, as follows (see *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new frame, `list_frame`, to hold our List widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a Listbox widget within this frame and set some styling options, such
    as background color, foreground color, and mouse cursor. The styling of active
    line is set using the Listbox option, `activestyle`, which means that we do not
    want to underline the selected item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `selectmode` option is configured as extended. See the following information
    box for a list of choices available and their meaning. We will use the `EXTENDED`
    select mode, because even though a single file can be played at once, we want
    to allow the user to select more than one file together at once for deletion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add a scrollbar to the Listbox, similar to the way we did in our text editor
    project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bind the double-click of mouse to another method named `identify_track_to_play`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Listbox widget offers four selection modes using the `selectmode` option
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SINGLE`: It allows only a single row to be selected at one time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BROWSE` (Default mode): It is similar to `SINGLE` but allows for moving the
    selection by dragging the mouse.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULTIPLE`: It allows for multiple selections by clicking on items one at a
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXTENDED`: It allows for selection of multiple range of items using *Shift*
    and *Control* keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – identify track to play
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our program was simpler in the first iteration, where we had only song to play.
    However, given a playlist, now we have to identify which song needs to be played
    from the given list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule is simple. If a user clicks on a given song, it becomes our selected
    track. If the user has made no selection and hits the Play button, the first song
    in the playlist should be played. Put in code this would look like as follows
    (see *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – adding items to the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a Listbox and we can play any item by double-clicking on it,
    let's add methods to populate and remove items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even before we do any modifications to our list, let''s first define
    an empty list named `alltracks` to keep track of all items in the playlist. We
    will need to update this list after any changes are done to the list, as follows(see
    *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We had already created an `add file` method in the last section. Let''s modify
    it slightly so that the file selected does not become the selected track, instead
    it gets added to the playlist, as follows (see *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The file selected through `tkFileDialog` is inserted at the end of the list
    box, and our attribute, `alltracks`, is updated with all elements in the Listbox
    widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the `get()` method returns a tuple of all items. Because tuples
    are immutable, we explicitly convert the tuple into a list by using the `list`
    type declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 – deleting items from the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add a new button to delete selected files. This is added to our existing
    `create_bottom_frame` method, as follows (see *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This button has a command callback to a method named `del_selected`. The code
    for `del_selected` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we update our `alltracks` list after deletion of items from the Listbox
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can make a selection from your list box and click on the Delete button
    to remove all selected items from the list box.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – adding multiple items to the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding individual audio files to a playlist can become tedious. We want to allow
    the users to select a directory, and our list should get populated with all supported
    media formats from that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, add a new button to allow for adding all media files from a
    given directory. This is also added to our existing `create_bottom_frame` method,
    as follows (see *code 5.02 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the `os` module to grab all supported types. Let''s first import
    the `os` module into the current namespace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the associated command callback is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `add_dir` method first creates a temporary list, `tfilelist`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through all filenames fetched through the `tkFileDialog.askdirectory()`
    method. If it encounters a supported file format, it appends the file to the temporary
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through all items in the `tfilelist`, inserting them into our
    Listbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It finally updates our `alltracks` attribute with all items in the newly modified
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 6 – deleting all items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we add a button to delete all items from the playlist. The associated
    button is added to the `create_bottom_frame` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now its associated command callback is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our second iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In this iteration, we saw how to work with the Listbox widget. In particular,
    we learned to add Listbox, add items to he Listbox widget, select a particular
    item from the Listbox widget, and delete one or more items from it.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a playlist where you can add and delete items.
  prefs: []
  type: TYPE_NORMAL
- en: The Listbox widget has an event binding for double-click of the mouse button
    on an item. This associated event callback selects the clicked item, and sends
    it across to be played on a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we saw a list of common operations done on the Listbox widget.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more controls to the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a playlist, we need to ensure that songs play in a queue. We
    also need to add a few more controls typically found in audio players, such as
    Next, Previous, Fast Forward, Rewind, and Mute buttons. We also need to provide
    a method to change the volume of playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this iteration, our player would have the following additional
    controls in the top-button frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding more controls to the player](img/7941_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The pyglet API documentation provides simple interfaces for all these controls.
    For your reference, the documentation is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by adding methods to handle these in our `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – fast forwarding a track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can fast forward a track as follows (see *code 5.03 player.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – rewinding a track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can rewind a track as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – pausing a track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can pause a track as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – setting the volume of playback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can set the volume of playback as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – muting and unmuting a track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can mute and unmute a track as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not discuss the code here in detail. For coding these functionalities,
    we have used the API documentation for pyglet available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also access this documentation for the pyglet media player class by
    typing these two lines in your Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have been indiscriminately using try/except blocks in this program to hide
    all errors emanating from the `player` class.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be the best programming practice, but we ignore all `player`
    class errors so as not to deviate from our discussion on Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal case, you would handle all different kind of errors using different
    except blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – adding the control buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the backend code to handle events, such as fast forward, rewind,
    volume change, mute, and others, it is simply time to add buttons for each of
    these controls to our `GUI` class. We link each of the buttons to its respective
    command callback.
  prefs: []
  type: TYPE_NORMAL
- en: So, we modify our `create_button_frame` widget to add buttons for these new
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added hundreds of buttons so far in our previous project. So, we do
    not reproduce the entire code here for sake of brevity. Rather, we simply show
    the implementation of the Previous Track button as one of its sample, and how
    it calls the associated command callback to the `previous()` method of the `player`
    class as follows (see *code 5.03 GUI.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 – changing volume with the ttk Scale widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to these buttons, we also use the ttk Scale widget to allow the
    users to change the volume. The native Scale widget implementation in core Tkinter
    looks rather old fashioned and we instead settle for the ttk Scale widget, which
    has same set of configurable options as the core Tkinter Scale widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As per the pyglet documentation, the volume of playback must be specified as
    a float ranging from `0.0` (no sound) to `1.0` (maximum sound), and our `updateVolume`
    method uses this as the basis.
  prefs: []
  type: TYPE_NORMAL
- en: This has an attached callback to another method, `vol_update`, in the `GUI`
    class, which simply delegates the task to the `player` method to handle volume
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The pyglet `Player` class expects volume to be specified as a float, but the
    command here receives the new value of scale as a string. We, therefore, first
    convert it to float, and then pass it to the `set_vol` method of the `player`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes the second iteration where we added playback control features
    to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section was more about sticking to the API documentation of pyglet and
    trusting it as a blackbox to deliver what it says: namely, to be able to play
    and control audio.'
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to use the ttk Scale widget in a practical demonstration of
    building our volume control.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it came to choosing an external implementation (as we did for audio API
    here), we first searched through the Python Standard Library at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.python.org/library/](http://docs.python.org/library/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the Standard Library does not have a suitable package for us, we turned
    our attention to Python Package Index to see if there exists another high-level
    audio interface implementation. The Python package index lives at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pypi.python.org/](http://pypi.python.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we came across several audio packages. After comparing the packages
    against our needs and seeing how active its community was, we settled for pyglet.
    The same program could have been implemented with several other packages, though
    with varying levels of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, the lower you go down the protocol stack, the more complex your
    programs would get.
  prefs: []
  type: TYPE_NORMAL
- en: However, at lower layers of the protocol, you get a finer control over the implementation
    at the cost of increasing learning curves.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, because the pyglet `player` class does not differentiate between
    pause and stop functionality, we had to altogether do away with the pause functionality
    and settle for a simpler implementation where pause and stop mean the same.
  prefs: []
  type: TYPE_NORMAL
- en: For a finer control of audio source, we will have to go deeper into the protocol
    stacks, which we will avoid for now, so as not to digress from our topic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the top display console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this iteration, we will add a display console at the top of our player. This
    console will display the time counter for our music player. It will also display
    the currently played track.
  prefs: []
  type: TYPE_NORMAL
- en: We will also code a progress bar, which will show the progress of the current
    track being played.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this iteration, the top frame of our player will look like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the top display console](img/7941_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to precisely place our timer clock text and the currently playing track
    text on the top of an image.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the Canvas widget allows for a deep nested placement of other widgets
    inside it with precise coordinate-based control. This is all that we want to display
    the console. We will, therefore, use the Canvas widget as the container for our
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the top console and progress bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We accordingly define a new method named `create_console_frame` in our `GUI`
    class, which holds our image, clock text, and currently playing text for creating
    the top console and progress bar as follows(see *code 5.04 GUI.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a new frame, `consoleframe`, and adds a Canvas widget of desired
    height and width to the frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `canvas.create_image` to add the background image. The background image
    is provided in the `icons` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `canvas.create_text` to add one text for displaying the clock and another
    text to display the currently playing track. The desired location of each of these
    texts is specified using x, y coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also specify a special font for displaying our clock. If this font is installed
    on a computer, the text is displayed in the specified font. If the font is not
    installed, display occurs in the default font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we display a ttkProgressbar widget, which shall be used to display
    the progress of track as it plays. We use the determinate mode of the progress
    bar, because we want to display the completion of track relative to its overall
    length. For now, the overall length of track is initialized to `1`. It will be
    updated as the song starts to play.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A ttkProgressbar widget displays the status of progress of an operation. The
    progress bar can run in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Determinate`: This mode shows the amount of work completed relative to the
    total amount of work.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Indeterminate`: This provides an animated show of the progress, but does not
    show the relative amount of work completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – getting the total duration of a track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The contents of the display panel and the progress on the progress bar need
    to be updated every time a new song starts playing. In our current code, a new
    song starts playing when a user clicks on the Play button or double-clicks on
    a particular track, or when the Next or Previous button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we update the clock or the progress bar, we need to know two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Total length of current track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration for which a current track has been played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, pyglet provides API calls to determine both these things. As per
    its documentation, the total length of a song currently playing can be obtained
    from the code: `source.duration`.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the current duration of play can be obtained using `myplayer.time`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s, therefore, define two new methods in our `Player` class to get the
    value of these two variables, as follows (*code 5.04player.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we slightly modify our `start_play_thread` method to call our `song_len`
    method so that our `song_length` attribute is updated with the value of the song
    length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we made the method to sleep for one second, so as to enable to length
    metadata to populate. If we do not make it sleep for a second, the code would
    execute so fast that it would end even before the `song_length` variable is updated
    by pyglet.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have access to the total length and current duration of play. We now
    want to update the current track every time a new track is played.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – updating console at launch of play
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new track is played when a user hits the Play button, or when he or she double-clicks
    a particular song, or when he or she clicks the Next or Previous button.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the code from previous iteration (*code 5.03 GUI.py*), all these
    methods call the `self.player.start_play_thread()`functionality to start the playback.
    However, now we need to update the console display every time a new player thread
    is started.
  prefs: []
  type: TYPE_NORMAL
- en: We, therefore, need to refactor our code. For one, we will route all calls to
    `player.start_play_thread()`through a single method, which will update the display
    as the player thread starts.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – updating timer clock and progress bar at regular intervals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We, therefore, define a new method named `launch_play`,and replace all instances
    of `player.start_play_thread()`from previous code to now call our `launch_play`
    method, as follows (see *Code 5.04.py main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code first tries to stop any other track that might be playing at that time,
    because we don't want multiple tracks playing at a given time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then starts to play the next track in a separate thread. The thread method
    automatically updates the song length, and now we have access to the song length
    in the variable `self.player.song_len`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines break the song length into equivalent minutes and seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line breaks the file name and gets hold of the song name from the complete
    path. It then appends the time calculated in minutes and seconds to the file name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We set the `maximum` value for our progress bar, which is a floating point
    number specifying the maximum value of the progress bar. For viewing all configurable
    options for ttk Progressbar, enter the following into your Python interactive
    console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line uses `canvas.itemconfig` to update the song name and song length
    in the display console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like we use `config` to change value of widget related options, the Canvas
    widget uses `itemconfig` to change the options for individual items within the
    canvas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The format for `itemconfig` is as follows: `itemconfig(itemid, **options)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this step, we will learn to update timer clock and progress bar at regular
    intervals. Although song name and song length are to be updated just once for
    a given song, the play duration and progress bar need to be updated at small intervals.
    We, therefore, handle it in a separate method named `update_clock_and_progressbar()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to display time in the format you normally find in a digital clock.
    We accordingly define a string format named `timepattern`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timepattern = ''{0:02d}:{1:02d}''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us turn our attention to updating the display clock and the progress
    bar. We have already made a call to `update_clock_and_progressbar()`which is supposed
    to take care of this work. Let''s now code this method, as follows(see *Code 5.04.py
    main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code runs itself every 1000 ms, forces a root update, and changes the time
    and progress bar value. To keep running regularly, it calls back itself after
    every 1000 ms.
  prefs: []
  type: TYPE_NORMAL
- en: When a track is over, it resets the values of clock and progress bar to zero,
    and exits out of the update loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the `canvas.after` method to call the same method at intervals of one
    second. Thus, this method would get to be called at one second interval throughout
    playing of the current track. We also kept a condition to break out of the loop
    when the current track ended playing.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes this iteration. In this iteration, we built a functional display
    console and a progress bar to display time and information about the current track.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating a blank canvas in the top area of our root window. We
    then added an image that resembles a display console. We then used `canvas.create_text`
    to precisely position the timer clock, name of currently playing track, and the
    total track length in the console.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a ttk progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculated the track length using the pyglet API. Next, we made all
    calls to play the track to be routed through an intermediate method which updated
    the console with information about the currently playing track.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a method to update the clock and progress bar at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over tracks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we have a functional player. It though lacks a vital feature. There is
    no tracking over loop. That means every time a user listens to a track, the player
    stops after playing that track. It does not jump to the next track in our playlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s provide some radio buttons to let the user choose the looping structure.
    By the end of this iteration, we will add the following to our player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping over tracks](img/7941_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In essence, our player should provide choice amongst:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No loop**: Playing a track and ending there'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop Current**: Playing a single track repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop All**: Playing through the entire playlist, one after another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's code this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the radio buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The corresponding code for creating radio buttons in the `GUI` class is as
    follows (see *Code 5.05 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – on end of song callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at the player end logic first when a song ends. We need a way to
    call a method once a song has completed playing. Luckily, the pyglet player allows
    for an `on_eos` (on end of song) callback.
  prefs: []
  type: TYPE_NORMAL
- en: We first modify our existing `play_media` method in the `player` class to include
    this callback.(See *Code 5.05 player.py*)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This callback is executed on end of a given song. We add the callback to a method
    named `what_next`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – what next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This `what_next` method essentially looks for the selected choice on looping
    and accordingly takes some action. The code for `what_next` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `on_eos` callback is also called just in case a track is stopped in the
    middle. That means that if a stop action occurs, we don't want to do anything
    next. We, therefore, break out of the method by calling a blank return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code then checks the value of `self.parent.selectedloopchoice`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the selected loop value is `1`(**No Loop**), it does not play the next song,
    but breaks out of the method with a return statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the loop value is `2` (loop over the current song), it again calls the `launch_play`
    method without changing the current track.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the loop value is `3` (**Loop All**), it calls another method named `fetch_next_track`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 – fetching the next track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code of `fetch_next_track` to fetch the next track is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This code simply increments index by one, sets the current track variable to
    the next item in the list of all songs, and calls `launch_play()` to play the
    next track.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes the coding of looping in our player.
  prefs: []
  type: TYPE_NORMAL
- en: This iteration relied on the fact that pyglet allows an `on_oes` (on end of
    song) callback. At the end of a track, we use this callback to check the looping
    choice specified by the user.
  prefs: []
  type: TYPE_NORMAL
- en: If the user does not want to loop through the playlist, we pass a blank return
    statement. If the user wants to loop over the current song, we call the `launch_play`
    method without incrementing the current track. If the user wants to loop through
    the entire list, we call a method named `fetch_next_track`, which increments the
    index of song by one, and then calls the `launch_play` method to play the next
    song.
  prefs: []
  type: TYPE_NORMAL
- en: In this iteration, we also saw a sample usage of radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Our player is now equipped to loop over a playlist based on preferences provided
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the contextual menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this quick iteration, we add a contextual pop-up menu or the right-click
    menu with shortcuts to some common operations on the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will add just two functions to the right-click menu: **Play** and
    **Delete**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After completion, the right-click menu will open, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the contextual menu](img/7941_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the contextual menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have done similar contextual menus in our text editor, so we do a quick round
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a new method, `context_menu`, and call it from the `GUI __init__` method,
    as follows (see *Code 5.06 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define a `show_context_menu` method and bind it to right-click of mouse`<<Button-3>>`
    from within our `create_list_frame`, immediately next to where the Listbox widget
    is defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: overriding the close button'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we are at it, let us code a little overlooked function. Now that we have
    the capability to loop over entire playlists, we do not want the player to close
    without stopping the songs being played. Let us, therefore, override the `root.destroy()`
    method to stop tracks before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the destroy method, we first add a protocol override method to
    our `GUI __init__` method, as follows (see *Code 5.06 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally let''s define our `close_player` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The contextual menu is now added to our program. A user can now right-click
    on an item and select to play or delete it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also overridden our close button to ensure that any playing track is
    stopped before we exit the player.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tooltip and finalizing our player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this iteration, we add tooltip also named the Balloon widget to all the buttons
    in our player.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tooltip is a small popup, which shows up when you hover your mouse over the
    Bound widget (buttons in our case). A typical tooltip on our application would
    look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a tooltip and finalizing our player](img/7941_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although core Tkinter has many useful widgets, it is far from complete. For
    us, the tooltip or Balloon widget is not provided as a core Tkinter widget. We,
    therefore, look for these widgets in what are named **Tkinter extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: These extensions are nothing but modified Tkinter widgets to act and behave
    with new functionalities not offered by Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are literally hundreds of Tkinter extensions. In fact, we could write
    our own Tkinter extensions. However, some of the popular Tkinter extensions are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Mega Widgets** (**PMW**) available at [http://pmw.sourceforge.net](http://pmw.sourceforge.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tix** available at [http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TkZinc** available at [http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widget Construction Kit**(**WCK**) available at [http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PMW list of extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Talking about PMW, here is a quick list of widget extensions from the package:'
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ButtonBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ComboBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EntryField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HistoryText
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LabeledWidget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MainMenuBar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MenuBar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MessageBar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoteBook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OptionMenu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PanedWidget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RadioSelect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScrolledCanvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScrolledField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScrolledFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScrolledListBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScrolledText
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TimeCounter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialogs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AboutDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ComboBoxDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CounterDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MessageDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PromptDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SelectionDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextDialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Balloon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blt(used for graph generation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color Module functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PMW offers a large list of extended widgets. For a demonstration of all these
    widgets, browse into the PMW package that you installed earlier, and look for
    a directory named `demo`. Within `demo`, look for a file, `all.py`, which demonstrates
    all PMW extensions with sample working code.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – importing PMW
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PMW provides the Balloon widget implementation, but it is not part of standard
    Tkinter library. We need to add it. To add PMW, refer to our discussion under
    the *Mission Checklist* section. Once added, you need to import PMW into your
    namespace, as follows (see *Code 5.07 main-gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – instantiating the Balloon widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We then instantiate the Balloon widget within the mainloop from our `__init__`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – adding Balloon tooltips to all buttons in our player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we bind the Balloon widget to each of the button widgets in our player.
    We will not reproduce the code for each button. However, the format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So our Add File button would have a balloon binding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We add similar code for each button in *5.07 main-gui.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we end this iteration, let us add a title to our player and add a title
    bar icon as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes the iteration. We added Balloon tooltips to our player buttons
    using PMW Tkinter extension.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we got to know about Tkinter extensions and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you come across a widget implementation need that is not available as a
    core widget, try looking for implementations of it in PMW or Tix. If you don't
    find one that suits your need, search the Internet for some other Tkinter extension.
  prefs: []
  type: TYPE_NORMAL
- en: If you still don't find your desired implementation, try out WCK, which lets
    you implement all types of custom widgets. However, note that WCK is not under
    active development for long.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this project. Our audio media player is ready!
  prefs: []
  type: TYPE_NORMAL
- en: Let us recap the things that we touched upon in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics we covered in this project could be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We reinforced a lot of GUI programming techniques that we discussed during previous
    projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to work with more widgets, such as Listbox, ttk Scale, Progressbar,
    and Radiobutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We got further insight into the power of the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw how to work with external APIs to ease program development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We got to know about some common Tkinter extensions, such as PMW, WCK, Tix,
    and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also saw how to refactor code at each stage of development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some hotshot challenges on which you can work:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our code adds each button separately. This makes the program long
    and adds unnecessary boilerplates. Refactor this code to add all buttons using
    loops. This should considerably shorten the length of our `GUI` class, while streamlining
    the buttons to be handled from a small loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, the program keeps record of songs only during a single program run.
    The songs need to be loaded in subsequent runs. Try to incorporate auto-playlist
    load based on last run playlist history using object persistence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find a Python package that lets you extract useful metadata from your audio
    files: things such as its author, genre or frequencies, and number of channels.
    Use these metadata to display more information about the current track in the
    display console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add skinning ability to the player, letting the user select a different skin
    for the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look out for some network related packages to support streaming of online audio.
    Incorporate the feature of being able to tune in to online radio stations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
