- en: Chapter 5. Audio Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 音频播放器
- en: Let's now build an audio media player!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建一个音频媒体播放器！
- en: Our application should have features offered by typical media players, such
    as play, pause, fast forward, rewind, next, mute, volume updates, and more. Our
    player should let the listener easily access individual media files or media library
    from his or her local drive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应具备典型媒体播放器的功能，如播放、暂停、快进、快退、下一曲、静音、音量更新等。我们的播放器应允许听众轻松访问其本地驱动器中的单个媒体文件或媒体库。
- en: In addition to this, our player should be able to scan entire directories for
    a song and accordingly, auto update the playlist with all supported formats. All
    this and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的播放器还应能够扫描整个目录以查找歌曲，并相应地自动更新包含所有支持格式的播放列表。所有这些以及更多。
- en: Let us start our project!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的项目！
- en: Mission Briefing
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: 'On completion our player will look as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的播放器将如下所示：
- en: '![Mission Briefing](img/7941_05_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_05_01.jpg)'
- en: Our audio player will be capable of playing audio files in AU, MP2, MP3, OGG/Vorbis,
    WAV, and WMA formats. It will have all the controls that you would expect of a
    small media player.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音频播放器将能够播放AU、MP2、MP3、OGG/Vorbis、WAV和WMA格式的音频文件。它将拥有您期望的小型媒体播放器所具有的所有控件。
- en: We will use cross-platform modules to write our code. This will ensure that
    our player can play audio files on Windows, Mac OS X, and Linux platforms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用跨平台模块来编写我们的代码。这将确保我们的播放器可以在Windows、Mac OS X和Linux平台上播放音频文件。
- en: Why Is It Awesome?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此出色？
- en: In addition to getting to hear good music while testing our code, this project
    will introduce us to several new ideas related to GUI programming with Tkinter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在测试代码的同时能够听到好音乐，这个项目还将向我们介绍与Tkinter GUI编程相关的几个新想法。
- en: For one, we get to work with new sets of widgets, such as the Listbox, Progressbar,
    Scale, Radiobutton, and PMW Balloon widget.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将与新的小部件集一起工作，例如Listbox、Progressbar、Scale、Radiobutton和PMW Balloon小部件。
- en: We also take a look at the power of the Canvas widget in accommodating and precise
    positioning of other widgets within it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了Canvas小部件在容纳和精确定位其中其他小部件方面的强大功能。
- en: Towards the end of the project, we take a look at a Tkinter extension named
    PMW. We also discuss some more Tkinter extensions that we do not use here, but
    are good to have in our GUI programming arsenal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的后期，我们将查看一个名为PMW的Tkinter扩展。我们还讨论了一些我们没有使用但值得在GUI编程工具箱中拥有的Tkinter扩展。
- en: Though not a topic for this book, we also get a brief insight into the world
    of audio programming with Python, which necessarily looks at how to work with
    external libraries and API implementations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是本书的主题，但我们还简要了解了使用Python进行音频编程的世界，这必然涉及到如何与外部库和API实现协同工作。
- en: Your Hotshot Objectives
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的高目标
- en: 'Some of the key objectives outlined for this project include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个项目概述的一些关键目标包括：
- en: Reinforcing our experiences and learning from previous projects
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巩固我们之前的经验和从之前的项目中学习
- en: Working with new set of widgets, such as Listbox, Scale, Progressbar, and Radiobutton
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与新的小部件集一起工作，例如Listbox、Scale、Progressbar和Radiobutton
- en: Getting to know more of the Canvas widget
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Canvas小部件的更多功能
- en: Working with external APIs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部API协同工作
- en: Getting to know about some common Tkinter extensions, such as PMW, WCK, Tix,
    and others
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一些常见的Tkinter扩展，如PMW、WCK、Tix等
- en: Learning to refactor code at each stage of development
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发的每个阶段学习如何重构代码
- en: Mission Checklist
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: 'We will use the following additional libraries for this project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下额外的库来完成这个项目：
- en: Pyglet for audio manipulation
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pyglet音频处理
- en: 'Window users can download and install binary packages for pyglet from:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口用户可以从以下位置下载并安装pyglet的二进制包：
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet)'
- en: 'Mac OS X and Linux users should download and compile pyglet from the source
    ZIP file available at:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X和Linux用户应从以下源ZIP文件下载并编译pyglet：
- en: '[http://www.pyglet.org/download.html](http://www.pyglet.org/download.html)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pyglet.org/download.html](http://www.pyglet.org/download.html)'
- en: When installing from source, you will also need to add the `AVbin.dll` to your
    current program directory. The link to the DLL file is also available at the preceding
    download page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当从源代码安装时，你还需要将`AVbin.dll`添加到你的当前程序目录中。DLL文件的链接也可以在先前的下载页面找到。
- en: PMW Tkinter extension
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PMW Tkinter扩展
- en: 'We will be using **Python mega widgets** (**PMW**) Tkinter extension to code
    some widgets features not available in core Tkinter. PMW must be installed from
    the source package for all platforms. The package can be downloaded at:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Python mega widgets**（**PMW**）Tkinter扩展来编写一些在核心Tkinter中不可用的小部件功能。PMW必须从源包安装到所有平台。该包可以从以下网址下载：
- en: '[http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/](http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/](http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/)'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use Version 1.3.3 in our application, and other versions of PMW may not be
    compatible with our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用版本1.3.3，其他版本的PMW可能不与我们的代码兼容。
- en: Additional font
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外字体
- en: 'This is an optional component meant only to augment our styling. We install
    a font to mimic the font of a digital clock. We have used the following font for
    this project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选组件，仅用于增强我们的样式。我们安装了一个字体来模仿数字时钟的字体。我们在这个项目中使用了以下字体：
- en: '[http://www.dafont.com/ds-digital.font](http://www.dafont.com/ds-digital.font)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.dafont.com/ds-digital.font](http://www.dafont.com/ds-digital.font)'
- en: 'After you have installed pyglet and PMW, execute the following command from
    your Python shell:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了pyglet和PMW之后，从您的Python shell中执行以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the command executes without any error message, you are ready to code your
    media player.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行没有错误信息，您就可以开始编写您的媒体播放器代码了。
- en: Getting the audio to play
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取音频播放
- en: 'The first goal of our project is to add the ability to play the audio file.
    As usual, we will keep the audio related logic separate from our GUI section.
    Therefore, we create two separate files: `main-gui.py` and `player.py`. (See *code
    5.01*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的第一个目标是添加播放音频文件的能力。像往常一样，我们将把音频相关逻辑与我们的GUI部分分开。因此，我们创建了两个单独的文件：`main-gui.py`和`player.py`。（见*代码5.01*）
- en: Prepare for Lift Off
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'We first code a basic GUI, which includes a Play button (which toggles between
    play and stop functionality) and an Add File button. At the end of this iteration,
    we should be able to load a file, play it, and stop it. By the end of this section,
    our application will look like the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个基本的GUI，其中包括一个播放按钮（在播放和停止功能之间切换）和一个添加文件按钮。在这个迭代的最后，我们应该能够加载一个文件，播放它，并停止它。到本节结束时，我们的应用程序将看起来像以下截图：
- en: '![Prepare for Lift Off](img/7941_05_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_05_02.jpg)'
- en: Engage Thrusters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the GUI class
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建GUI类
- en: 'Let''s create the `GUI` class. The code for `main-gui.py` is as follows (see
    *code 5.01 main-gui.py*):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`GUI`类。`main-gui.py`的代码如下（见*代码5.01 main-gui.py*）：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The description of the code is listed as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a class named `GUI`, and run the Tkinter mainloop from within its
    `__init__ method`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`GUI`的类，并在其`__init__`方法中运行Tkinter主循环。
- en: We will separate the actual audio manipulation logic such as play, pause, rewind,
    forward, and others in a separate class to be defined later. However, because
    we want those functionalities to be available in this `GUI` class, we pass an
    object instantiated out of that `player` class as an argument to our `__init__`
    method.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把实际的音频操作逻辑，如播放、暂停、倒带、快进等，放在一个稍后定义的单独类中。然而，因为我们希望这些功能在`GUI`类中可用，所以我们把从那个`player`类实例化的对象作为参数传递给我们的`__init__`方法。
- en: The line `self.player = player` within our `__init__` method ensures that the
    `player` class instance is available throughout the `GUI` class.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中的`self.player = player`这一行确保了`player`类实例在整个`GUI`类中可用。
- en: Just like we want to access the properties and methods of the `player` class
    from this `GUI` class, we also want the methods and attributes of the `GUI` class
    to be available within our `player` class. We, therefore, use the line `player.parent
    = self` in the `__init__` method. This creates a reference to self so that all
    its methods can be assessed inside the `player` class using the syntax `parent.attribute`
    and `parent.method()`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像我们要从`GUI`类中访问`player`类的属性和方法一样，我们也希望`GUI`类的方法和属性在`player`类中可用。因此，我们在`__init__`方法中使用`player.parent
    = self`这一行。这创建了对self的引用，因此可以使用`parent.attribute`和`parent.method()`语法在`player`类内部评估所有其方法。
- en: With these two lines of code, we have ensured that all properties of the `GUI`
    class will be available in the `player` class and vice versa; all properties of
    the `player` class will be available in the `GUI` class.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这两行代码，我们确保了`GUI`类的所有属性都将可用在`player`类中，反之亦然；`player`类的所有属性也将可用在`GUI`类中。
- en: Step 2 – creating the Play button and Add File button
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 创建播放按钮和添加文件按钮
- en: 'For this, we add two methods: `create_button_frame` and `create_bottom_frame`.
    The `create_button_frame` method holds the Play button, and the `create_bottom_frame`
    method holds the Add File button, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加了两个方法：`create_button_frame`和`create_bottom_frame`。`create_button_frame`方法包含播放按钮，而`create_bottom_frame`方法包含添加文件按钮，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The description of the code is listed as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Each of the two buttons is associated with a `TkinterPhotoImage` class icon.
    We have provided a set of icons in a separate folder named `icons`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个按钮都与一个`TkinterPhotoImage`类图标相关联。我们已经在名为`icons`的单独文件夹中提供了一套图标。
- en: Step 3 – toggling between play and pause
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 在播放和暂停之间切换
- en: 'The Play button has a command callback that toggles the button between play
    and stop functionality. The `toggle` method is defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 播放按钮有一个命令回调，用于在播放和停止功能之间切换按钮。`toggle`方法定义如下：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is listed as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The method, `toggle_play_pause`, changes the icon alternatively between a play
    and pause icon. It also calls the `play` and `pause` methods of the `player` class
    to play and pause the songs.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toggle_play_pause`方法会在播放和暂停图标之间交替更改图标。它还会调用`player`类的`play`和`pause`方法来播放和暂停歌曲。'
- en: Step 4 – add file dialog
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 添加文件对话框
- en: 'The Add File button opens `tkFileDialog`, which associates the file opened
    with a class attribute named `currentTrack`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文件按钮打开`tkFileDialog`，将打开的文件与一个名为`currentTrack`的类属性相关联，如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Step 5 – creating the Player class
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 创建播放器类
- en: Now, let's code the basic `player` class. For now, we will only add play and
    pause functionality to the class. The code for our `player` class is built upon
    the pyglet library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写基本的`player`类代码。目前，我们只将播放和暂停功能添加到该类。我们的`player`类代码建立在pyglet库的基础上。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pyglet provides an object-oriented interface for developing rich media applications,
    such as games, audio and video tools, and others. It is a popular choice with
    Python programmers for media manipulation, because it has no external dependencies,
    supports a large number of formats, and is available on all major operating systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet提供了一个面向对象的接口，用于开发丰富的媒体应用程序，如游戏、音频和视频工具等。它是Python程序员在媒体处理方面的热门选择，因为它没有外部依赖，支持大量格式，并且可在所有主要操作系统上使用。
- en: 'Before we proceed further, you might want to look at the API documentation
    of the pyglet player available at:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你可能想查看pyglet播放器的API文档，该文档可在以下位置找到：
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
- en: 'The documentation tells us that we can play an audio file using the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 文档告诉我们可以使用以下代码播放音频文件：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use this code snippet to play the audio file. Accordingly, the code
    for our `Player` class is as follows(see *code 5.01 player.py*):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此代码片段来播放音频文件。因此，我们的`Player`类代码如下（见*代码5.01 player.py*）：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the code is listed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a class named `Player` and initialize its parent class as `None`.
    Recall that in our `GUI` class, we have defined a reference `player.parent = self`,
    so as to be able to assess our `GUI` class properties from within our `player`
    class.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Player`的类，并将其父类初始化为`None`。回想一下，在我们的`GUI`类中，我们定义了一个引用`player.parent
    = self`，以便在`player`类内部评估我们的`GUI`类属性。
- en: We then define our `play_media` method, which is responsible for actually playing
    the sound. The method accesses the `currentTrack` attribute of the `GUI` class
    and tries to play it.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后定义我们的`play_media`方法，该方法负责实际播放声音。该方法访问`GUI`类的`currentTrack`属性并尝试播放它。
- en: Although this code can play audio files, pyglet requires running its own event
    loop to play the audio. This means it will return control to our GUI mainloop
    only after it has completed playing the entire sound, while freezing the Tkinter
    mainloop if run directly.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这段代码可以播放音频文件，但pyglet需要运行它自己的事件循环来播放音频。这意味着它将在播放完整个声音后，将控制权返回到我们的GUI主循环，如果在直接运行时，将会冻结Tkinter主循环。
- en: We, therefore, need to call the play method in a separate thread. We use the
    threading module to define a new method named `start_play_thread`, which simply
    calls our `play_media` method in a separate thread, thus preventing freezing out
    of GUI.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们需要在单独的线程中调用播放方法。我们使用threading模块定义了一个名为`start_play_thread`的新方法，它简单地在一个单独的线程中调用我们的`play_media`方法，从而防止GUI冻结。
- en: Lastly, we define the pause method, which pauses or stops the audio file being
    currently played. Pyglet does not differentiate between pause and stop functions.
    Therefore, we are typically stopping the audio using the pause command.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了暂停方法，该方法可以暂停或停止当前播放的音频文件。Pyglet不区分暂停和停止功能。因此，我们通常使用暂停命令来停止音频。
- en: Step 6 – running the application
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 运行应用程序
- en: 'We finally run the application by creating an object out of our `GUI` class.
    Because this `GUI` class requires an object from the `player` class, we also instantiate
    a player object and pass it as an argument to our `GUI` class, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终通过创建一个`GUI`类的对象来运行应用程序。因为这个`GUI`类需要一个`player`类的对象，所以我们实例化了一个播放器对象，并将其作为参数传递给我们的`GUI`类，如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The description of the code is listed as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: The last section of code creates an object from the `player` class that we are
    yet to define. The `player` class will take care of all audio manipulation using
    pyglet.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的最后部分创建了一个我们尚未定义的`player`类的对象。`player`类将负责使用pyglet进行所有音频操作。
- en: We first create an object out of the `player` class and pass it as an argument
    to the `__init__` method of our `GUI` class. This ensures that all attributes
    and methods of the `player` class are available within the `GUI` class using the
    syntax `player.attribute` and `player.method()`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建了一个`player`类的对象，并将其作为参数传递给我们的`GUI`类的`__init__`方法。这确保了`player`类的所有属性和方法都可以在`GUI`类中使用`player.attribute`和`player.method()`的语法在内部使用。
- en: Objective Complete – Mini Debriefing
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our first iteration.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一次迭代。
- en: In this section, we created a `GUI` class, added a button that toggles between
    play and pause. We added another button to add a file using `tkFileDialog`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个`GUI`类，添加了一个在播放和暂停之间切换的按钮。我们还添加了一个按钮，使用`tkFileDialog`来添加文件。
- en: We also created a `Player` class, which uses pyglet for playing audio files.
    The files are played in a separate thread to avoid freezing of the Tkinter mainloop
    while the audio is playing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`Player`类，该类使用pyglet来播放音频文件。文件在单独的线程中播放，以避免在播放音频时冻结Tkinter主循环。
- en: Finally, we ran our application by first creating a player object and passing
    it as an argument to another object created by our `GUI` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过首先创建一个播放器对象，并将其作为参数传递给由我们的`GUI`类创建的另一个对象来运行我们的应用程序。
- en: We now have a functional audio player, where you can load a single file using
    `tkFileDialog`. After loading, you can press the Play button and the audio file
    starts playing. You can stop the audio by clicking the Play button, which toggles
    alternatively between play and pause functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能齐全的音频播放器，你可以使用`tkFileDialog`加载单个文件。加载后，你可以按下播放按钮，音频文件开始播放。你可以通过点击播放按钮来停止音频，该按钮在播放和暂停功能之间切换。
- en: Adding a playlist
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加播放列表
- en: We now have the capability to play a single audio file, but what is an audio
    player if it does not allow for a playlist?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了播放单个音频文件的能力，但如果一个音频播放器不支持播放列表，那它又是什么呢？
- en: Let's add a playlist feature to our player. Once a playlist is added, we accordingly
    need to provide buttons to add files to the playlist, delete files from it, and
    add all supported files from a chosen directory and the ability to delete all
    items in the list at once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在播放器中添加播放列表功能。一旦添加了播放列表，我们就需要相应地提供按钮来添加文件到播放列表，从播放列表中删除文件，以及从所选目录添加所有支持的文件，并能够一次性删除列表中的所有项目。
- en: 'At the end of this iteration, we will have a player that looks like the following
    screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一迭代的最后，我们将有一个如下截图所示的播放器：
- en: '![Adding a playlist](img/7941_05_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![添加播放列表](img/7941_05_03.jpg)'
- en: Prepare for Lift Off
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'We will use Tkinter Listbox widget to provide a playlist. Let''s look at some
    of the key features of the Listbox widget:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Tkinter Listbox小部件来提供播放列表。让我们看看Listbox小部件的一些关键特性：
- en: 'You create a Listbox like you create any other widget as follows:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建一个Listbox就像创建任何其他小部件一样，如下所示：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you initially create the Listbox widget, it is empty. To insert one or
    more lines of text into the Listbox, you use the `insert()` method, which takes
    two arguments: an index of the position where the text is to be inserted and the
    actual string to be inserted as follows:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您最初创建列表小部件时，它是空的。要将一行或多行文本插入列表小部件，您使用`insert()`方法，该方法需要两个参数：文本要插入的位置的索引以及要插入的实际字符串，如下所示：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `curselection()` method returns the index of all items selected in the
    list, and the `get()` method returns the list item for a given index as follows:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curselection()`方法返回列表中所有选中项的索引，而`get()`方法返回给定索引的列表项，如下所示：'
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition, the Listbox widget has several other configurable options. For
    a complete Listbox widget reference, type the following into your Python interactive
    shell:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，列表小部件还有几个其他可配置的选项。要获取完整的列表小部件参考信息，请在您的Python交互式shell中输入以下内容：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Engage Thrusters
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – adding an empty Listbox widget
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 添加一个空的列表小部件
- en: 'Let''s first add an empty Listbox widget, as follows (see *code 5.02 main-gui.py*):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加一个空的列表小部件，如下所示（见*code 5.02 main-gui.py*）：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The description of the code is listed as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a new frame, `list_frame`, to hold our List widget.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的框架，名为`list_frame`，用于存放我们的列表小部件。
- en: We create a Listbox widget within this frame and set some styling options, such
    as background color, foreground color, and mouse cursor. The styling of active
    line is set using the Listbox option, `activestyle`, which means that we do not
    want to underline the selected item.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个框架内，我们创建了一个列表小部件并设置了一些样式选项，例如背景颜色、前景颜色和鼠标光标。使用列表小部件选项`activestyle`设置活动行的样式，这意味着我们不想在选中项下划线。
- en: The `selectmode` option is configured as extended. See the following information
    box for a list of choices available and their meaning. We will use the `EXTENDED`
    select mode, because even though a single file can be played at once, we want
    to allow the user to select more than one file together at once for deletion.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectmode`选项配置为扩展。请参阅以下信息框以获取可用选项及其含义。我们将使用`EXTENDED`选择模式，因为尽管一次可以播放一个文件，但我们希望允许用户一次选择多个文件进行删除。'
- en: We add a scrollbar to the Listbox, similar to the way we did in our text editor
    project.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向列表小部件添加了一个滚动条，这与我们在文本编辑器项目中的做法类似。
- en: We bind the double-click of mouse to another method named `identify_track_to_play`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将鼠标的双击绑定到另一个名为`identify_track_to_play`的方法。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Listbox widget offers four selection modes using the `selectmode` option
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表小部件提供了四种选择模式，使用`selectmode`选项如下：
- en: '`SINGLE`: It allows only a single row to be selected at one time.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SINGLE`：它允许一次只选择一行。'
- en: '`BROWSE` (Default mode): It is similar to `SINGLE` but allows for moving the
    selection by dragging the mouse.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`BROWSE`（默认模式）：它与`SINGLE`类似，但允许通过拖动鼠标移动选择。'
- en: '`MULTIPLE`: It allows for multiple selections by clicking on items one at a
    time.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`MULTIPLE`：它允许通过逐个点击项目进行多选。'
- en: '`EXTENDED`: It allows for selection of multiple range of items using *Shift*
    and *Control* keys.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTENDED`：它允许使用*Shift*和*Control*键选择多个范围的项。'
- en: Step 2 – identify track to play
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 识别要播放的曲目
- en: Our program was simpler in the first iteration, where we had only song to play.
    However, given a playlist, now we have to identify which song needs to be played
    from the given list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，我们的程序比较简单，因为我们只有一首歌要播放。然而，给定一个播放列表，现在我们必须确定从给定列表中需要播放哪首歌。
- en: 'The rule is simple. If a user clicks on a given song, it becomes our selected
    track. If the user has made no selection and hits the Play button, the first song
    in the playlist should be played. Put in code this would look like as follows
    (see *code 5.02 main-gui.py*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 规则很简单。如果用户点击一首特定的歌曲，它就成为我们的选中曲目。如果用户没有做出选择并点击播放按钮，播放列表中的第一首歌曲应该被播放。用代码表示如下（见*code
    5.02 main-gui.py*）：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Step 3 – adding items to the list
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 向列表添加项目
- en: Now that we have a Listbox and we can play any item by double-clicking on it,
    let's add methods to populate and remove items from the list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了列表小部件，并且可以通过双击来播放任何项目，让我们添加填充和从列表中删除项目的方法。
- en: 'However, even before we do any modifications to our list, let''s first define
    an empty list named `alltracks` to keep track of all items in the playlist. We
    will need to update this list after any changes are done to the list, as follows(see
    *code 5.02 main-gui.py*):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们对列表进行任何修改之前，让我们首先定义一个名为`alltracks`的空列表来跟踪播放列表中的所有项目。在列表发生任何更改后，我们需要更新此列表，如下所示（见*code
    5.02 main-gui.py*）：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We had already created an `add file` method in the last section. Let''s modify
    it slightly so that the file selected does not become the selected track, instead
    it gets added to the playlist, as follows (see *code 5.02 main-gui.py*):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分中已经创建了一个`添加文件`方法。现在让我们稍作修改，以便选定的文件不会成为选定的曲目，而是被添加到播放列表中，如下所示（见*代码5.02
    main-gui.py*）：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The description of the code is listed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下列所示：
- en: The file selected through `tkFileDialog` is inserted at the end of the list
    box, and our attribute, `alltracks`, is updated with all elements in the Listbox
    widget.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`tkFileDialog`选定的文件被插入到列表框的末尾，并且我们的属性`alltracks`被更新为Listbox小部件中的所有元素。
- en: Notice that the `get()` method returns a tuple of all items. Because tuples
    are immutable, we explicitly convert the tuple into a list by using the `list`
    type declaration.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`get()`方法返回一个包含所有项目的元组。因为元组是不可变的，所以我们通过使用`list`类型声明显式地将元组转换为列表。
- en: Step 4 – deleting items from the list
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 从列表中删除项目
- en: 'Let''s add a new button to delete selected files. This is added to our existing
    `create_bottom_frame` method, as follows (see *code 5.02 main-gui.py*):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新按钮来删除选定的文件。这添加到我们现有的`create_bottom_frame`方法中，如下所示（见*代码5.02 main-gui.py*）：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This button has a command callback to a method named `del_selected`. The code
    for `del_selected` is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮有一个名为`del_selected`的方法的命令回调。`del_selected`的代码如下：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, we update our `alltracks` list after deletion of items from the Listbox
    widget.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们在从Listbox小部件中删除项目后更新我们的`alltracks`列表。
- en: Now, you can make a selection from your list box and click on the Delete button
    to remove all selected items from the list box.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从列表框中选择一个项目，然后点击删除按钮，从列表框中删除所有选定的项目。
- en: Step 5 – adding multiple items to the list
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 向列表中添加多个项目
- en: Adding individual audio files to a playlist can become tedious. We want to allow
    the users to select a directory, and our list should get populated with all supported
    media formats from that directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 向播放列表中添加单个音频文件可能会变得繁琐。我们希望允许用户选择一个目录，并且我们的列表应该填充来自该目录的所有支持的媒体格式。
- en: 'We, therefore, add a new button to allow for adding all media files from a
    given directory. This is also added to our existing `create_bottom_frame` method,
    as follows (see *code 5.02 main-gui.py*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加了一个新的按钮，允许添加给定目录中的所有媒体文件。这也添加到我们现有的`create_bottom_frame`方法中，如下所示（见*代码5.02
    main-gui.py*）：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to use the `os` module to grab all supported types. Let''s first import
    the `os` module into the current namespace, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`os`模块来获取所有支持的类型。让我们首先将`os`模块导入到当前命名空间中，如下所示：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now the associated command callback is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相关的命令回调如下：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The description of the code is listed as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下列所示：
- en: The `add_dir` method first creates a temporary list, `tfilelist`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_dir`方法首先创建一个临时列表，`tfilelist`。'
- en: It then iterates through all filenames fetched through the `tkFileDialog.askdirectory()`
    method. If it encounters a supported file format, it appends the file to the temporary
    list.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它遍历通过`tkFileDialog.askdirectory()`方法获取的所有文件名。如果它遇到支持的文件格式，它将文件追加到临时列表中。
- en: It then iterates through all items in the `tfilelist`, inserting them into our
    Listbox.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它遍历`tfilelist`中的所有项目，将它们插入到我们的Listbox中。
- en: It finally updates our `alltracks` attribute with all items in the newly modified
    list.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它使用新修改的列表中的所有项目更新我们的`alltracks`属性。
- en: Step 6 – deleting all items
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 删除所有项目
- en: 'Finally, we add a button to delete all items from the playlist. The associated
    button is added to the `create_bottom_frame` method, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个按钮来删除播放列表中的所有项目。相关的按钮添加到`create_bottom_frame`方法中，如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now its associated command callback is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它的相关命令回调如下：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Objective Complete – Mini Debriefing
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our second iteration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第二次迭代。
- en: In this iteration, we saw how to work with the Listbox widget. In particular,
    we learned to add Listbox, add items to he Listbox widget, select a particular
    item from the Listbox widget, and delete one or more items from it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们学习了如何使用Listbox小部件。特别是，我们学会了如何向Listbox小部件添加项目，向其中添加项目，从Listbox小部件中选择特定项目，以及从中删除一个或多个项目。
- en: You now have a playlist where you can add and delete items.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个可以添加和删除项目的播放列表。
- en: The Listbox widget has an event binding for double-click of the mouse button
    on an item. This associated event callback selects the clicked item, and sends
    it across to be played on a separate thread.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Listbox小部件在项目上双击鼠标按钮时有一个事件绑定。这个相关的事件回调函数选择被点击的项目，并将其发送到另一个线程进行播放。
- en: In the process, we saw a list of common operations done on the Listbox widget.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们看到了在Listbox小部件上执行的一些常见操作。
- en: Adding more controls to the player
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向播放器添加更多控制
- en: Now that we have a playlist, we need to ensure that songs play in a queue. We
    also need to add a few more controls typically found in audio players, such as
    Next, Previous, Fast Forward, Rewind, and Mute buttons. We also need to provide
    a method to change the volume of playback.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了播放列表，我们需要确保歌曲按队列播放。我们还需要添加一些在音频播放器中通常可以看到的控制按钮，如“下一曲”、“上一曲”、“快进”、“回放”和“静音”按钮。我们还需要提供一个方法来更改播放音量。
- en: 'At the end of this iteration, our player would have the following additional
    controls in the top-button frame:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代结束时，我们的播放器在顶部按钮框架中会有以下额外的控制按钮：
- en: '![Adding more controls to the player](img/7941_05_04.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![向播放器添加更多控制](img/7941_05_04.jpg)'
- en: 'The pyglet API documentation provides simple interfaces for all these controls.
    For your reference, the documentation is available at:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: pyglet API文档为所有这些控制提供了简单的接口。为了您的参考，文档可在以下网址找到：
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
- en: Let's begin by adding methods to handle these in our `Player` class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的`Player`类添加处理这些方法的方法开始。
- en: Engage Thrusters
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – fast forwarding a track
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 快进曲目
- en: 'We can fast forward a track as follows (see *code 5.03 player.py*):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样快进曲目（见 *代码 5.03 player.py*）：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Step 2 – rewinding a track
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 回放曲目
- en: 'We can rewind a track as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样回放曲目：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Step 3 – pausing a track
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 暂停曲目
- en: 'We can pause a track as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样暂停一个曲目：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Step 4 – setting the volume of playback
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 设置播放音量
- en: 'We can set the volume of playback as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样设置播放音量：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Step 5 – muting and unmuting a track
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 静音和取消静音曲目
- en: 'We can mute and unmute a track as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样静音和取消静音曲目：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will not discuss the code here in detail. For coding these functionalities,
    we have used the API documentation for pyglet available at:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细讨论代码。为了实现这些功能，我们使用了pyglet的API文档，该文档可在以下网址找到：
- en: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pyglet.org/doc/api/pyglet.media.Player-class.html](http://www.pyglet.org/doc/api/pyglet.media.Player-class.html)'
- en: 'You can also access this documentation for the pyglet media player class by
    typing these two lines in your Python interactive shell:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在Python交互式外壳中输入这两行来访问pyglet媒体播放器类的文档：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have been indiscriminately using try/except blocks in this program to hide
    all errors emanating from the `player` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在程序中使用try/except块来隐藏来自`player`类的所有错误。
- en: This might not be the best programming practice, but we ignore all `player`
    class errors so as not to deviate from our discussion on Tkinter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是最好的编程实践，但我们忽略所有`player`类的错误，以免偏离我们对Tkinter的讨论。
- en: In a normal case, you would handle all different kind of errors using different
    except blocks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，你会使用不同的except块来处理所有不同类型的错误。
- en: Step 6 – adding the control buttons
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 添加控制按钮
- en: Now that we have the backend code to handle events, such as fast forward, rewind,
    volume change, mute, and others, it is simply time to add buttons for each of
    these controls to our `GUI` class. We link each of the buttons to its respective
    command callback.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理事件的后端代码，如快进、回放、音量更改、静音等，现在是时候向我们的`GUI`类添加每个这些控制的按钮了。我们将每个按钮链接到其相应的命令回调。
- en: So, we modify our `create_button_frame` widget to add buttons for these new
    controls.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们修改我们的`create_button_frame`小部件以添加这些新控制按钮的按钮。
- en: 'We have added hundreds of buttons so far in our previous project. So, we do
    not reproduce the entire code here for sake of brevity. Rather, we simply show
    the implementation of the Previous Track button as one of its sample, and how
    it calls the associated command callback to the `previous()` method of the `player`
    class as follows (see *code 5.03 GUI.py*):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的项目中已经添加了数百个按钮。因此，为了简洁起见，我们在这里不重复整个代码。相反，我们仅展示作为其样本之一的“上一曲目”按钮的实现，以及它是如何调用`player`类的`previous()`方法的关联命令回调（见
    *代码 5.03 GUI.py*）：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Step 7 – changing volume with the ttk Scale widget
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步 - 使用ttk Scale小部件更改音量
- en: 'In addition to these buttons, we also use the ttk Scale widget to allow the
    users to change the volume. The native Scale widget implementation in core Tkinter
    looks rather old fashioned and we instead settle for the ttk Scale widget, which
    has same set of configurable options as the core Tkinter Scale widget, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些按钮外，我们还使用ttk Scale小部件允许用户更改音量。Tkinter核心中的原生Scale小部件实现看起来相当过时，所以我们选择了ttk
    Scale小部件，它具有与核心Tkinter Scale小部件相同的可配置选项，如下所示：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As per the pyglet documentation, the volume of playback must be specified as
    a float ranging from `0.0` (no sound) to `1.0` (maximum sound), and our `updateVolume`
    method uses this as the basis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据pyglet文档，播放音量必须指定为一个范围从`0.0`（无声音）到`1.0`（最大声音）的浮点数，我们的`updateVolume`方法就是基于这个。
- en: This has an attached callback to another method, `vol_update`, in the `GUI`
    class, which simply delegates the task to the `player` method to handle volume
    changes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个附加的回调到`GUI`类中的另一个方法`vol_update`，它简单地将任务委托给`player`方法来处理音量变化。
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The description of the code is listed as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The pyglet `Player` class expects volume to be specified as a float, but the
    command here receives the new value of scale as a string. We, therefore, first
    convert it to float, and then pass it to the `set_vol` method of the `player`
    class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyglet的`Player`类期望音量被指定为一个浮点数，但这里的命令接收到的scale的新值是一个字符串。因此，我们首先将其转换为浮点数，然后将其传递给`player`类的`set_vol`方法。
- en: Objective Complete – Mini Debriefing
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: This completes the second iteration where we added playback control features
    to our program.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了第二次迭代，我们在程序中添加了播放控制功能。
- en: 'This section was more about sticking to the API documentation of pyglet and
    trusting it as a blackbox to deliver what it says: namely, to be able to play
    and control audio.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节更多的是关于坚持pyglet的API文档，并把它作为一个黑盒来信任它所承诺的功能：即能够播放和控制音频。
- en: We also saw how to use the ttk Scale widget in a practical demonstration of
    building our volume control.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在构建音量控制的实际演示中看到了如何使用ttk Scale小部件。
- en: Classified Intel
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: 'When it came to choosing an external implementation (as we did for audio API
    here), we first searched through the Python Standard Library at:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到选择外部实现（就像我们在音频API中所做的那样）时，我们首先在以下位置搜索Python标准库：
- en: '[http://docs.python.org/library/](http://docs.python.org/library/)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.python.org/library/](http://docs.python.org/library/)'
- en: 'Because the Standard Library does not have a suitable package for us, we turned
    our attention to Python Package Index to see if there exists another high-level
    audio interface implementation. The Python package index lives at:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准库没有适合我们的合适包，我们将注意力转向Python包索引，看看是否存在另一个高级音频接口实现。Python包索引位于：
- en: '[http://pypi.python.org/](http://pypi.python.org/)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://pypi.python.org/](http://pypi.python.org/)'
- en: Fortunately, we came across several audio packages. After comparing the packages
    against our needs and seeing how active its community was, we settled for pyglet.
    The same program could have been implemented with several other packages, though
    with varying levels of complexity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们遇到了几个音频包。在比较这些包与我们的需求以及看到其社区活跃度后，我们选择了pyglet。虽然可以用几个其他包实现相同的程序，但复杂度各不相同。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In general, the lower you go down the protocol stack, the more complex your
    programs would get.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你越深入协议堆栈，你的程序就会越复杂。
- en: However, at lower layers of the protocol, you get a finer control over the implementation
    at the cost of increasing learning curves.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在协议的较低层，你可以在增加学习曲线的成本下获得对实现的更精细控制。
- en: For instance, because the pyglet `player` class does not differentiate between
    pause and stop functionality, we had to altogether do away with the pause functionality
    and settle for a simpler implementation where pause and stop mean the same.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于pyglet的`player`类没有区分暂停和停止功能，我们不得不完全放弃暂停功能，并接受一个更简单的实现，其中暂停和停止意味着相同。
- en: For a finer control of audio source, we will have to go deeper into the protocol
    stacks, which we will avoid for now, so as not to digress from our topic.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精细地控制音频源，我们不得不深入研究协议堆栈，但我们现在将避免这样做，以免偏离主题。
- en: Adding the top display console
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加顶级显示控制台
- en: In this iteration, we will add a display console at the top of our player. This
    console will display the time counter for our music player. It will also display
    the currently played track.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，我们将在玩家顶部添加一个显示控制台。这个控制台将显示音乐播放器的计时器。它还将显示当前播放的曲目。
- en: We will also code a progress bar, which will show the progress of the current
    track being played.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一个进度条，它将显示当前播放曲目的进度。
- en: 'At the end of this iteration, the top frame of our player will look like the
    following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代的最后，我们玩家的顶部框架将看起来像以下截图：
- en: '![Adding the top display console](img/7941_05_05.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![添加顶部显示控制台](img/7941_05_05.jpg)'
- en: Prepare for Lift Off
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: We need to precisely place our timer clock text and the currently playing track
    text on the top of an image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要精确地将计时器时钟文本和当前播放曲目文本放置在图像的顶部。
- en: Recall that the Canvas widget allows for a deep nested placement of other widgets
    inside it with precise coordinate-based control. This is all that we want to display
    the console. We will, therefore, use the Canvas widget as the container for our
    console.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Canvas小部件允许在内部以精确的坐标控制方式深度嵌套其他小部件。这正是我们想要显示控制台的方式。因此，我们将使用Canvas小部件作为控制台的容器。
- en: Engage Thrusters
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the top console and progress bar
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建顶部控制台和进度条
- en: 'We accordingly define a new method named `create_console_frame` in our `GUI`
    class, which holds our image, clock text, and currently playing text for creating
    the top console and progress bar as follows(see *code 5.04 GUI.py*):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`GUI`类中定义了一个名为`create_console_frame`的新方法，它包含我们的图像、时钟文本和当前播放文本，以创建顶部控制台和进度条，如下所示（见*代码5.04
    GUI.py*）：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The description of the code is listed as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The code defines a new frame, `consoleframe`, and adds a Canvas widget of desired
    height and width to the frame.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码定义了一个新的框架，`consoleframe`，并将所需高度和宽度的Canvas小部件添加到框架中。
- en: We use `canvas.create_image` to add the background image. The background image
    is provided in the `icons` folder.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`canvas.create_image`来添加背景图像。背景图像位于`icons`文件夹中。
- en: We use `canvas.create_text` to add one text for displaying the clock and another
    text to display the currently playing track. The desired location of each of these
    texts is specified using x, y coordinates.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`canvas.create_text`添加一个用于显示时钟的文本和一个用于显示当前播放曲目的文本。每个文本的期望位置都使用x，y坐标指定。
- en: We also specify a special font for displaying our clock. If this font is installed
    on a computer, the text is displayed in the specified font. If the font is not
    installed, display occurs in the default font.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还指定了一个特殊的字体来显示我们的时钟。如果这个字体安装在了电脑上，文本将以指定的字体显示。如果字体未安装，则使用默认字体显示。
- en: Finally, we display a ttkProgressbar widget, which shall be used to display
    the progress of track as it plays. We use the determinate mode of the progress
    bar, because we want to display the completion of track relative to its overall
    length. For now, the overall length of track is initialized to `1`. It will be
    updated as the song starts to play.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们显示一个ttkProgressbar小部件，它将用于显示曲目播放时的进度。我们使用进度条的确定模式，因为我们想显示相对于整个长度的完成情况。目前，曲目的整体长度初始化为`1`。随着歌曲的开始播放，它将被更新。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A ttkProgressbar widget displays the status of progress of an operation. The
    progress bar can run in two modes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ttkProgressbar小部件显示操作的进度状态。进度条可以运行在两种模式：
- en: '`Determinate`: This mode shows the amount of work completed relative to the
    total amount of work.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Determinate`：这种模式显示了相对于总工作量的完成量。'
- en: '`Indeterminate`: This provides an animated show of the progress, but does not
    show the relative amount of work completed.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Indeterminate`：这种模式提供了一个动画的进度显示，但不会显示完成的工作的相对量。'
- en: Step 2 – getting the total duration of a track
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 获取曲目的总时长
- en: The contents of the display panel and the progress on the progress bar need
    to be updated every time a new song starts playing. In our current code, a new
    song starts playing when a user clicks on the Play button or double-clicks on
    a particular track, or when the Next or Previous button is clicked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新歌曲开始播放时，显示面板的内容和进度条上的进度都需要更新。在我们的当前代码中，当用户点击播放按钮或双击特定曲目，或者点击下一曲或上一曲按钮时，新歌曲开始播放。
- en: 'Before we update the clock or the progress bar, we need to know two things:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新时钟或进度条之前，我们需要知道两件事：
- en: Total length of current track
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前曲目的总长度
- en: Duration for which a current track has been played
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前曲目播放的持续时间
- en: 'Fortunately, pyglet provides API calls to determine both these things. As per
    its documentation, the total length of a song currently playing can be obtained
    from the code: `source.duration`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，pyglet提供了API调用来确定这两件事。根据其文档，当前播放歌曲的总长度可以通过以下代码获得：`source.duration`。
- en: Similarly, the current duration of play can be obtained using `myplayer.time`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以使用`myplayer.time`获取当前播放的持续时间。
- en: 'Let''s, therefore, define two new methods in our `Player` class to get the
    value of these two variables, as follows (*code 5.04player.py*):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`Player`类中定义了两个新方法来获取这两个变量的值，如下（*代码5.04player.py*）：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we slightly modify our `start_play_thread` method to call our `song_len`
    method so that our `song_length` attribute is updated with the value of the song
    length.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们稍微修改一下`start_play_thread`方法，使其调用我们的`song_len`方法，以便我们的`song_length`属性能够更新为歌曲长度值。
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we made the method to sleep for one second, so as to enable to length
    metadata to populate. If we do not make it sleep for a second, the code would
    execute so fast that it would end even before the `song_length` variable is updated
    by pyglet.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使方法休眠一秒钟，以便让长度元数据填充。如果我们不使其休眠一秒钟，代码会执行得太快，以至于在`song_length`变量被pyglet更新之前就会结束。
- en: Now, we have access to the total length and current duration of play. We now
    want to update the current track every time a new track is played.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问总长度和当前播放的持续时间。我们现在希望在每次播放新曲目时更新当前曲目。
- en: Step 3 – updating console at launch of play
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 在播放启动时更新控制台
- en: A new track is played when a user hits the Play button, or when he or she double-clicks
    a particular song, or when he or she clicks the Next or Previous button.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击播放按钮、双击特定歌曲或点击下一曲或上一曲按钮时，会播放新曲目。
- en: If you look at the code from previous iteration (*code 5.03 GUI.py*), all these
    methods call the `self.player.start_play_thread()`functionality to start the playback.
    However, now we need to update the console display every time a new player thread
    is started.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看之前的迭代代码（*代码5.03 GUI.py*），所有这些方法都调用`self.player.start_play_thread()`功能来启动播放。然而，现在我们需要在每次启动新的播放线程时更新控制台显示。
- en: We, therefore, need to refactor our code. For one, we will route all calls to
    `player.start_play_thread()`through a single method, which will update the display
    as the player thread starts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要重构我们的代码。首先，我们将所有调用`player.start_play_thread()`的路由到一个单一的方法中，该方法将在播放线程启动时更新显示。
- en: Step 4 – updating timer clock and progress bar at regular intervals
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 定期更新计时器和进度条
- en: 'We, therefore, define a new method named `launch_play`,and replace all instances
    of `player.start_play_thread()`from previous code to now call our `launch_play`
    method, as follows (see *Code 5.04.py main-gui.py*):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个名为`launch_play`的新方法，并将之前代码中所有`player.start_play_thread()`的实例替换为现在调用我们的`launch_play`方法，如下（见*代码5.04.py
    main-gui.py*）：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The description of the code is listed as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The code first tries to stop any other track that might be playing at that time,
    because we don't want multiple tracks playing at a given time.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码首先尝试停止当时可能正在播放的任何其他曲目，因为我们不希望在特定时间内播放多个曲目。
- en: It then starts to play the next track in a separate thread. The thread method
    automatically updates the song length, and now we have access to the song length
    in the variable `self.player.song_len`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它开始在另一个线程中播放下一首曲目。线程方法会自动更新歌曲长度，现在我们可以通过变量`self.player.song_len`访问歌曲长度。
- en: The next two lines break the song length into equivalent minutes and seconds.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行将歌曲长度转换为等价的分钟和秒。
- en: The next line breaks the file name and gets hold of the song name from the complete
    path. It then appends the time calculated in minutes and seconds to the file name.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行将文件名分割，并从完整路径中获取歌曲名称。然后它将计算出的分钟和秒数追加到文件名中。
- en: 'We set the `maximum` value for our progress bar, which is a floating point
    number specifying the maximum value of the progress bar. For viewing all configurable
    options for ttk Progressbar, enter the following into your Python interactive
    console:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为进度条设置了`maximum`值，这是一个浮点数，指定了进度条的最大值。要查看ttk Progressbar的所有可配置选项，请在你的Python交互式控制台中输入以下内容：
- en: '[PRE36]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next line uses `canvas.itemconfig` to update the song name and song length
    in the display console.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行使用`canvas.itemconfig`更新显示控制台中的歌曲名称和歌曲长度。
- en: Note
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just like we use `config` to change value of widget related options, the Canvas
    widget uses `itemconfig` to change the options for individual items within the
    canvas.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像我们使用 `config` 来更改与小部件相关选项的值一样，Canvas 小部件使用 `itemconfig` 来更改画布内单个项目的选项。
- en: 'The format for `itemconfig` is as follows: `itemconfig(itemid, **options)`.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`itemconfig` 的格式如下：`itemconfig(itemid, **options)`。'
- en: In this step, we will learn to update timer clock and progress bar at regular
    intervals. Although song name and song length are to be updated just once for
    a given song, the play duration and progress bar need to be updated at small intervals.
    We, therefore, handle it in a separate method named `update_clock_and_progressbar()`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们将学习如何定期更新计时器和进度条。尽管对于一首特定的歌曲，歌曲名称和歌曲长度只需更新一次，但播放时间和进度条需要在小间隔内更新。因此，我们通过一个名为
    `update_clock_and_progressbar()` 的独立方法来处理它。
- en: 'We want to display time in the format you normally find in a digital clock.
    We accordingly define a string format named `timepattern`, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以你通常在数字时钟中找到的格式显示时间。因此，我们定义了一个名为 `timepattern` 的字符串格式，如下所示：
- en: '`timepattern = ''{0:02d}:{1:02d}''`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`timepattern = ''{0:02d}:{1:02d}''`。'
- en: 'Now, let us turn our attention to updating the display clock and the progress
    bar. We have already made a call to `update_clock_and_progressbar()`which is supposed
    to take care of this work. Let''s now code this method, as follows(see *Code 5.04.py
    main-gui.py*):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向更新显示时钟和进度条。我们已经调用了 `update_clock_and_progressbar()`，它应该负责这项工作。现在让我们编写这个方法，如下所示（见
    *Code 5.04.py main-gui.py*）：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code runs itself every 1000 ms, forces a root update, and changes the time
    and progress bar value. To keep running regularly, it calls back itself after
    every 1000 ms.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码每1000毫秒运行一次，强制根更新，并更改时间和进度条值。为了保持定期运行，它在每1000毫秒后调用自己。
- en: When a track is over, it resets the values of clock and progress bar to zero,
    and exits out of the update loop.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当一首曲目结束时，它会将计时器和进度条的重置为零，并退出更新循环。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used the `canvas.after` method to call the same method at intervals of one
    second. Thus, this method would get to be called at one second interval throughout
    playing of the current track. We also kept a condition to break out of the loop
    when the current track ended playing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `canvas.after` 方法以一秒的间隔调用相同的方法。因此，在整个当前曲目的播放过程中，该方法将以一秒的间隔被调用。我们还设置了一个条件，当当前曲目播放结束时跳出循环。
- en: Objective Complete – Mini Debriefing
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: This completes this iteration. In this iteration, we built a functional display
    console and a progress bar to display time and information about the current track.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了这一迭代。在这个迭代中，我们构建了一个功能性的显示控制台和进度条来显示时间和当前曲目的信息。
- en: We started by creating a blank canvas in the top area of our root window. We
    then added an image that resembles a display console. We then used `canvas.create_text`
    to precisely position the timer clock, name of currently playing track, and the
    total track length in the console.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在根窗口的顶部创建了一个空白画布。然后我们添加了一个类似于显示控制台的画面。然后我们使用 `canvas.create_text` 来精确地定位计时器时钟、当前播放曲目的名称和总曲目长度在控制台中。
- en: We also created a ttk progress bar.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个 ttk 进度条。
- en: We then calculated the track length using the pyglet API. Next, we made all
    calls to play the track to be routed through an intermediate method which updated
    the console with information about the currently playing track.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 pyglet API 计算了曲目长度。接下来，我们通过一个中间方法播放曲目，该方法更新控制台上的当前播放曲目信息。
- en: We also added a method to update the clock and progress bar at regular intervals.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个方法来定期更新时钟和进度条。
- en: Looping over tracks
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环播放曲目
- en: So now we have a functional player. It though lacks a vital feature. There is
    no tracking over loop. That means every time a user listens to a track, the player
    stops after playing that track. It does not jump to the next track in our playlist.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有一个功能性的播放器。尽管它缺少一个关键功能。没有循环跟踪。这意味着每次用户收听曲目时，播放器在播放完该曲目后会停止。它不会跳转到播放列表中的下一曲目。
- en: 'Let''s provide some radio buttons to let the user choose the looping structure.
    By the end of this iteration, we will add the following to our player:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供一些单选按钮，让用户选择循环结构。在这个迭代的结束时，我们将向我们的播放器添加以下功能：
- en: '![Looping over tracks](img/7941_05_06.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![循环播放曲目](img/7941_05_06.jpg)'
- en: 'In essence, our player should provide choice amongst:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们的播放器应该提供以下选择：
- en: '**No loop**: Playing a track and ending there'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无循环**：播放一首曲目并结束'
- en: '**Loop Current**: Playing a single track repeatedly'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环当前**：重复播放单个曲目'
- en: '**Loop All**: Playing through the entire playlist, one after another'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全部循环**：播放整个播放列表，一首接一首'
- en: Let's code this feature.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来编写这个功能。
- en: Engage Thrusters
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the radio buttons
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建单选按钮
- en: 'The corresponding code for creating radio buttons in the `GUI` class is as
    follows (see *Code 5.05 main-gui.py*):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI`类中创建单选按钮的对应代码如下（见*代码5.05 main-gui.py*）：
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Step 2 – on end of song callback
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 歌曲结束回调
- en: Let's look at the player end logic first when a song ends. We need a way to
    call a method once a song has completed playing. Luckily, the pyglet player allows
    for an `on_eos` (on end of song) callback.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看当歌曲结束时播放器结束逻辑的代码。我们需要一种方法在歌曲播放完成后调用一个方法。幸运的是，pyglet播放器允许一个`on_eos`（歌曲结束）回调。
- en: We first modify our existing `play_media` method in the `player` class to include
    this callback.(See *Code 5.05 player.py*)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先修改了`player`类中现有的`play_media`方法，以包含这个回调函数。（见*代码5.05 player.py*）
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This callback is executed on end of a given song. We add the callback to a method
    named `what_next`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调在给定歌曲结束时执行。我们将回调添加到名为`what_next`的方法中。
- en: Step 3 – what next?
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 下一步是什么？
- en: 'This `what_next` method essentially looks for the selected choice on looping
    and accordingly takes some action. The code for `what_next` is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`what_next`方法本质上是在循环中查找所选选项并相应地采取一些行动。`what_next`的代码如下：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The description of the code is listed as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `on_eos` callback is also called just in case a track is stopped in the
    middle. That means that if a stop action occurs, we don't want to do anything
    next. We, therefore, break out of the method by calling a blank return.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在中间停止了曲目，`on_eos`回调也会被调用。这意味着如果发生停止操作，我们不想做任何事情。因此，我们通过调用一个空返回来跳出方法。
- en: The code then checks the value of `self.parent.selectedloopchoice`.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后代码检查`self.parent.selectedloopchoice`的值。
- en: If the selected loop value is `1`(**No Loop**), it does not play the next song,
    but breaks out of the method with a return statement.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果选定的循环值是`1`（**不循环**），它不会播放下一首歌曲，而是通过返回语句跳出方法。
- en: If the loop value is `2` (loop over the current song), it again calls the `launch_play`
    method without changing the current track.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果循环值是`2`（循环当前歌曲），它再次调用`launch_play`方法而不更改当前曲目。
- en: If the loop value is `3` (**Loop All**), it calls another method named `fetch_next_track`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果循环值是`3`（**全部循环**），它将调用另一个名为`fetch_next_track`的方法。
- en: Step 4 – fetching the next track
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 获取下一曲目
- en: 'The code of `fetch_next_track` to fetch the next track is as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 获取下一曲目的`fetch_next_track`方法的代码如下：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description of the code is listed as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This code simply increments index by one, sets the current track variable to
    the next item in the list of all songs, and calls `launch_play()` to play the
    next track.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码简单地增加索引值，将当前曲目变量设置为所有歌曲列表中的下一个项目，并调用`launch_play()`来播放下一曲目。
- en: Objective Complete – Mini Debriefing
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes the coding of looping in our player.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们在播放器中循环的编码。
- en: This iteration relied on the fact that pyglet allows an `on_oes` (on end of
    song) callback. At the end of a track, we use this callback to check the looping
    choice specified by the user.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这次迭代依赖于pyglet允许一个`on_oes`（歌曲结束）回调。在曲目结束时，我们使用这个回调来检查用户指定的循环选择。
- en: If the user does not want to loop through the playlist, we pass a blank return
    statement. If the user wants to loop over the current song, we call the `launch_play`
    method without incrementing the current track. If the user wants to loop through
    the entire list, we call a method named `fetch_next_track`, which increments the
    index of song by one, and then calls the `launch_play` method to play the next
    song.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不想循环播放列表，我们传递一个空返回语句。如果用户想要循环当前歌曲，我们调用`launch_play`方法而不增加当前曲目。如果用户想要循环整个列表，我们调用一个名为`fetch_next_track`的方法，该方法将歌曲索引增加一个，然后调用`launch_play`方法来播放下一首歌曲。
- en: In this iteration, we also saw a sample usage of radio buttons.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们还看到了单选按钮的一个示例用法。
- en: Our player is now equipped to loop over a playlist based on preferences provided
    by the user.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的播放器现在可以根据用户提供的偏好循环播放播放列表。
- en: Adding the contextual menu
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加上下文菜单
- en: In this quick iteration, we add a contextual pop-up menu or the right-click
    menu with shortcuts to some common operations on the player.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次快速迭代中，我们添加了一个上下文弹出菜单或右键单击菜单，带有对播放器上一些常见操作的快捷方式。
- en: 'For now, we will add just two functions to the right-click menu: **Play** and
    **Delete**.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将在右键菜单中添加两个功能：**播放**和**删除**。
- en: 'After completion, the right-click menu will open, as shown in the following
    screenshot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，右键菜单将打开，如下面的截图所示：
- en: '![Adding the contextual menu](img/7941_05_07.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![添加上下文菜单](img/7941_05_07.jpg)'
- en: Engage Thrusters
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the contextual menu
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建上下文菜单
- en: We have done similar contextual menus in our text editor, so we do a quick round
    up.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的文本编辑器中做了类似的功能上下文菜单，所以这里做一个快速总结。
- en: 'We add a new method, `context_menu`, and call it from the `GUI __init__` method,
    as follows (see *Code 5.06 main-gui.py*):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新方法`context_menu`，并从`GUI __init__`方法中调用它，如下所示（见*代码5.06 main-gui.py*）：
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also define a `show_context_menu` method and bind it to right-click of mouse`<<Button-3>>`
    from within our `create_list_frame`, immediately next to where the Listbox widget
    is defined, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`show_context_menu`方法，并将其绑定到`create_list_frame`中的鼠标右键点击`<<Button-3>>`，紧挨着Listbox控件定义的地方，如下所示：
- en: '[PRE43]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Step 2: overriding the close button'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：重写关闭按钮
- en: While we are at it, let us code a little overlooked function. Now that we have
    the capability to loop over entire playlists, we do not want the player to close
    without stopping the songs being played. Let us, therefore, override the `root.destroy()`
    method to stop tracks before exiting.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们做到这一点时，让我们编写一个被忽视的小功能。现在我们已经有了遍历整个播放列表的能力，我们不希望播放器在停止播放的歌曲之前关闭。因此，让我们重写`root.destroy()`方法，在退出之前停止曲目。
- en: 'To override the destroy method, we first add a protocol override method to
    our `GUI __init__` method, as follows (see *Code 5.06 main-gui.py*):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写destroy方法，我们首先在`GUI __init__`方法中添加一个协议重写方法，如下所示（见*代码5.06 main-gui.py*）：
- en: '[PRE44]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally let''s define our `close_player` method, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义我们的`close_player`方法，如下所示：
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Objective Complete – Mini Debriefing
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: The contextual menu is now added to our program. A user can now right-click
    on an item and select to play or delete it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上下文菜单已添加到我们的程序中。用户现在可以右键单击一个项目，选择播放或删除它。
- en: We have also overridden our close button to ensure that any playing track is
    stopped before we exit the player.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还重写了我们的关闭按钮，以确保在我们退出播放器之前，任何正在播放的曲目都会停止。
- en: Adding a tooltip and finalizing our player
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具提示并完成我们的播放器
- en: In this iteration, we add tooltip also named the Balloon widget to all the buttons
    in our player.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将工具提示（也称为气球控件）添加到我们播放器中的所有按钮上。
- en: 'A tooltip is a small popup, which shows up when you hover your mouse over the
    Bound widget (buttons in our case). A typical tooltip on our application would
    look as shown in the following screenshot:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示是一个小弹出窗口，当你在绑定控件（在我们的例子中是按钮）上悬停鼠标时会出现。我们应用程序上的典型工具提示如下面的截图所示：
- en: '![Adding a tooltip and finalizing our player](img/7941_05_08.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![添加工具提示并完成我们的播放器](img/7941_05_08.jpg)'
- en: Prepare for Lift Off
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Although core Tkinter has many useful widgets, it is far from complete. For
    us, the tooltip or Balloon widget is not provided as a core Tkinter widget. We,
    therefore, look for these widgets in what are named **Tkinter extensions**.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Tkinter的核心库有许多有用的控件，但它远非完整。对我们来说，工具提示或气球控件并不是作为Tkinter的核心控件提供的。因此，我们在所谓的**Tkinter扩展**中寻找这些控件。
- en: These extensions are nothing but modified Tkinter widgets to act and behave
    with new functionalities not offered by Tkinter.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展实际上只是经过修改的Tkinter控件，以实现Tkinter未提供的新功能。
- en: 'There are literally hundreds of Tkinter extensions. In fact, we could write
    our own Tkinter extensions. However, some of the popular Tkinter extensions are
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有数百个Tkinter扩展。事实上，我们可以编写自己的Tkinter扩展。然而，一些流行的Tkinter扩展如下：
- en: '**Python Mega Widgets** (**PMW**) available at [http://pmw.sourceforge.net](http://pmw.sourceforge.net)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python Mega Widgets**（**PMW**）可在[http://pmw.sourceforge.net](http://pmw.sourceforge.net)找到'
- en: '**Tix** available at [http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tix**可在[http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix)找到'
- en: '**TkZinc** available at [http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TkZinc**可在[http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc)找到'
- en: '**Widget Construction Kit**(**WCK**) available at [http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Widget Construction Kit**（**WCK**）可在[http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm)找到'
- en: PMW list of extensions
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PMW扩展列表
- en: 'Talking about PMW, here is a quick list of widget extensions from the package:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到PMW，以下是从该包中提供的快速控件扩展列表：
- en: Widgets
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控件
- en: ButtonBox
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ButtonBox
- en: ComboBox
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ComboBox
- en: Counter
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: EntryField
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EntryField
- en: Group
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Group
- en: HistoryText
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HistoryText
- en: LabeledWidget
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LabeledWidget
- en: MainMenuBar
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MainMenuBar
- en: MenuBar
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MenuBar
- en: MessageBar
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MessageBar
- en: NoteBook
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoteBook
- en: OptionMenu
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OptionMenu
- en: PanedWidget
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PanedWidget
- en: RadioSelect
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RadioSelect
- en: ScrolledCanvas
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScrolledCanvas
- en: ScrolledField
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScrolledField
- en: ScrolledFrame
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScrolledFrame
- en: ScrolledListBox
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScrolledListBox
- en: ScrolledText
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScrolledText
- en: TimeCounter
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间计数器
- en: Dialogs
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对话框
- en: AboutDialog
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AboutDialog
- en: ComboBoxDialog
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ComboBoxDialog
- en: CounterDialog
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CounterDialog
- en: Dialog
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dialog
- en: MessageDialog
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MessageDialog
- en: PromptDialog
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PromptDialog
- en: SelectionDialog
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SelectionDialog
- en: TextDialog
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TextDialog
- en: Miscellaneous
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 杂项
- en: Balloon
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Balloon
- en: Blt(used for graph generation)
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blt（用于图形生成）
- en: Color Module functions
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色模块函数
- en: Tip
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: PMW offers a large list of extended widgets. For a demonstration of all these
    widgets, browse into the PMW package that you installed earlier, and look for
    a directory named `demo`. Within `demo`, look for a file, `all.py`, which demonstrates
    all PMW extensions with sample working code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: PMW 提供了大量扩展小部件的列表。要演示所有这些小部件，请浏览您之前安装的 PMW 包，并查找名为 `demo` 的目录。在 `demo` 目录中，查找名为
    `all.py` 的文件，该文件演示了所有 PMW 扩展及其示例代码。
- en: Engage Thrusters
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – importing PMW
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 导入 PMW
- en: 'PMW provides the Balloon widget implementation, but it is not part of standard
    Tkinter library. We need to add it. To add PMW, refer to our discussion under
    the *Mission Checklist* section. Once added, you need to import PMW into your
    namespace, as follows (see *Code 5.07 main-gui.py*):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: PMW 提供了气球小部件的实现，但它不是 Tkinter 标准库的一部分。我们需要添加它。要添加 PMW，请参考我们在 *任务清单* 部分的讨论。一旦添加，您需要将
    PMW 导入到您的命名空间中，如下所示（参见 *代码 5.07 main-gui.py*）：
- en: '[PRE46]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Step 2 – instantiating the Balloon widget
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 实例化气球小部件
- en: 'We then instantiate the Balloon widget within the mainloop from our `__init__`
    method as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `__init__` 方法中从主循环中实例化气球小部件，如下所示：
- en: '[PRE47]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Step 3 – adding Balloon tooltips to all buttons in our player
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 为我们播放器中的所有按钮添加气球工具提示
- en: 'Finally, we bind the Balloon widget to each of the button widgets in our player.
    We will not reproduce the code for each button. However, the format is as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将气球小部件绑定到我们播放器中的每个按钮小部件上。我们不会为每个按钮重复代码。然而，格式如下：
- en: '[PRE48]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So our Add File button would have a balloon binding as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的“添加文件”按钮将具有以下气球绑定：
- en: '[PRE49]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We add similar code for each button in *5.07 main-gui.py*.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *5.07 main-gui.py* 中的每个按钮上添加了类似的代码。
- en: 'Before we end this iteration, let us add a title to our player and add a title
    bar icon as well, as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这个迭代之前，让我们给我们的播放器添加一个标题，并添加一个标题栏图标，如下所示：
- en: '[PRE50]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Objective Complete – Mini Debriefing
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes the iteration. We added Balloon tooltips to our player buttons
    using PMW Tkinter extension.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代。我们使用 PMW Tkinter 扩展为我们的播放器按钮添加了气球工具提示。
- en: Most importantly, we got to know about Tkinter extensions and when to use them.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们了解了 Tkinter 扩展及其何时使用。
- en: Tip
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you come across a widget implementation need that is not available as a
    core widget, try looking for implementations of it in PMW or Tix. If you don't
    find one that suits your need, search the Internet for some other Tkinter extension.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当您遇到一个作为核心小部件不可用的小部件实现需求时，请尝试在 PMW 或 Tix 中查找其实现。如果您找不到适合您需求的一个，请在互联网上搜索其他 Tkinter
    扩展。
- en: If you still don't find your desired implementation, try out WCK, which lets
    you implement all types of custom widgets. However, note that WCK is not under
    active development for long.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然找不到您想要实现的功能，请尝试使用 WCK，它允许您实现所有类型的自定义小部件。然而，请注意 WCK 已经长时间没有活跃开发了。
- en: Mission Accomplished
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: This brings us to the end of this project. Our audio media player is ready!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本项目的结束。我们的音频媒体播放器已经准备好了！
- en: Let us recap the things that we touched upon in this project.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在这个项目中我们提到的事情。
- en: 'Some of the topics we covered in this project could be summarized as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个项目中涉及的一些主题可以总结如下：
- en: We reinforced a lot of GUI programming techniques that we discussed during previous
    projects
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们加强了许多在前一个项目中讨论过的 GUI 编程技术
- en: We learned how to work with more widgets, such as Listbox, ttk Scale, Progressbar,
    and Radiobutton
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何使用更多的小部件，例如 Listbox、ttk Scale、Progressbar 和 Radiobutton
- en: We got further insight into the power of the Canvas widget
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进一步了解了 Canvas 小部件的强大功能
- en: We saw how to work with external APIs to ease program development
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何使用外部 API 来简化程序开发
- en: We got to know about some common Tkinter extensions, such as PMW, WCK, Tix,
    and others
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了一些常见的 Tkinter 扩展，例如 PMW、WCK、Tix 等
- en: We also saw how to refactor code at each stage of development
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到了如何在开发的每个阶段重构代码
- en: A Hotshot Challenge
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热身挑战
- en: 'Here are some hotshot challenges on which you can work:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以尝试的挑战：
- en: Currently, our code adds each button separately. This makes the program long
    and adds unnecessary boilerplates. Refactor this code to add all buttons using
    loops. This should considerably shorten the length of our `GUI` class, while streamlining
    the buttons to be handled from a small loop.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们的代码是单独添加每个按钮的。这使得程序变得冗长，并添加了不必要的样板代码。重构此代码，使用循环来添加所有按钮。这应该会显著缩短我们`GUI`类的长度，同时简化按钮的处理，使其可以通过一个小循环来处理。
- en: Currently, the program keeps record of songs only during a single program run.
    The songs need to be loaded in subsequent runs. Try to incorporate auto-playlist
    load based on last run playlist history using object persistence.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，程序仅在单个程序运行期间记录歌曲。歌曲需要在后续运行中加载。尝试通过对象持久化，根据上次运行的播放列表历史自动加载播放列表。
- en: 'Find a Python package that lets you extract useful metadata from your audio
    files: things such as its author, genre or frequencies, and number of channels.
    Use these metadata to display more information about the current track in the
    display console.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个Python包，让你能够从音频文件中提取有用的元数据：例如作者、流派、频率和声道数。使用这些元数据在显示控制台中显示更多关于当前曲目信息。
- en: Add skinning ability to the player, letting the user select a different skin
    for the player.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为播放器添加皮肤功能，让用户可以为播放器选择不同的皮肤。
- en: Look out for some network related packages to support streaming of online audio.
    Incorporate the feature of being able to tune in to online radio stations.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意查找一些支持在线音频流的网络相关包。整合能够收听在线电台的功能。
