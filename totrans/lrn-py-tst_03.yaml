- en: Chapter 3. Unit Testing with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about what `doctest` does, how it works, and
    what you can expect out of it. Why are we devoting another chapter to it?
  prefs: []
  type: TYPE_NORMAL
- en: We're not. This chapter isn't really about `doctest`. It's about the testing
    discipline called **unit testing**. Since unit testing is an idea, not a piece
    of software, we'll be using `doctest` to practice with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to see:'
  prefs: []
  type: TYPE_NORMAL
- en: What unit testing actually is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How unit testing helps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `doctest` relates to unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, why do we care what unit testing is? One answer is that unit testing
    is a best practice that has been evolving toward its current form over most of
    the time that programming has existed. Another answer is that the core principles
    of unit testing are just good sense. It might actually be a little embarrassing
    to our community as a whole that it took us so long to recognize this.
  prefs: []
  type: TYPE_NORMAL
- en: So what is it? Unit testing means testing the smallest meaningful pieces of
    code (such pieces are called units), in such a way that guarantees that the success
    or failure of each test depends only on the unit and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a reason for each part of this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: We test the smallest meaningful pieces of code so that failed tests tell us
    where the problem is. The larger the tested chunk of code, the larger the area
    where a problem might originate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make sure that each test depends only on the tested unit for success or failure
    because, if it invokes any code outside the unit, we can't guarantee that the
    test's success or failure is actually due to that unit. When tests aren't independent,
    you can't trust them to tell you what the problem is and where to find it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We made some efforts to write our tests in [Chapter 2](ch02.html "Chapter 2. Working
    with doctest"), *Working with doctest*, according to this discipline, although
    we allowed ourselves some wiggle room because we were focusing on writing a testable
    specification. In this chapter, we're going to be more rigorous.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing is often associated with unit testing. Automated testing makes
    it fast and easy to run unit tests, and unit tests tend to be amenable to automation.
    We're certainly going to make heavy use of automated testing, both with `doctest`
    now, and later with tools such as unittest and Nose as well. However, strictly
    speaking, unit testing is not tied to automated testing. You can do unit testing
    with nothing but your own code and some discipline.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any test that involves more than one unit is automatically not a unit test.
    That matters because the results of unit tests tend to be particularly clear about
    what a problem is and where to find it.
  prefs: []
  type: TYPE_NORMAL
- en: When you test multiple units at once, the results of the various units get mixed
    together. In the end, you have to wonder about both what the problem is (is the
    mistake in this piece of code, or is it correctly handling bad input from some
    other piece of code?), and where the problem is (this output is wrong, but how
    do the involved units work together to create the error?).
  prefs: []
  type: TYPE_NORMAL
- en: Empirical scientists must perform experiments that check only one hypothesis
    at a time, whether the subject at hand is Chemistry, Physics, or the behavior
    of a body of program code.
  prefs: []
  type: TYPE_NORMAL
- en: Example – identifying units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine for a moment that one of your coworkers has written the following code,
    and it''s your responsibility to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to think about: Which sections of this code are the units?
    Is there only one unit consisting of the entire class? Is each method a separate
    unit? What about each statement, or maybe each expression?'
  prefs: []
  type: TYPE_NORMAL
- en: In some sense, the answer is subjective because part of the definition of a
    unit is that it is meaningful. You can say that the whole class is a single unit,
    and in some circumstances that might be the best answer. However, it is easy to
    subdivide most classes into methods, and normally methods make better units because
    they have well-defined interfaces and partially isolated behaviors, and because
    their intent and meaning should be well understood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Statements and expressions don''t make good units because they are almost never
    particularly meaningful in isolation. Furthermore, statements and expressions
    are difficult to target: unlike classes and methods, they don''t have names or
    easy ways to focus a test on them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some things to think about: What will be the consequences of choosing
    a different definition of unit for this code? If you have decided that methods
    are the best units, what would be different if you had picked classes? Likewise,
    if you picked classes, what would be different if you''d picked methods?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some things to think about: Take a look at `method4`. The result of
    this method depends on all of the other methods working correctly; worse, it depends
    on the unique ID of the self object. Can `method4` be treated as a unit? If we
    could change anything except `method4`, what is that we have to change to allow
    it to be tested as a unit and produce a predictable result?'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can't organize a suite of unit tests until you decide what constitutes a
    unit. The capabilities of your chosen programming language affect this choice.
    For example, C++ and Java make it difficult or impossible to treat methods as
    units (because you can't access a method without first instantiating the class
    it's part of); thus, in these languages each class is usually treated as a single
    unit, or metaprogramming tricks are used to force the methods into isolation so
    that they can be tested as units. C, on the other hand, doesn't support classes
    as language features at all, so the obvious choice of unit is the function. Python
    is flexible enough that either classes or methods can be considered as units and,
    of course, it has standalone functions as well; it is also natural to think of
    them as units.
  prefs: []
  type: TYPE_NORMAL
- en: The smaller the units are, the more useful the tests tend to be because they
    narrow down the location and nature of bugs more quickly. For example, if you
    choose to treat the `Testable` class as a unit, tests of the class will fail if
    there is a mistake in any of the methods. This tells you that there's a mistake
    in `Testable`, but not that it's in `method2`, or wherever it actually is. On
    the other hand, there is a certain amount of rigamarole involved in treating `method4`
    and its like as units, to such an extent that the next chapter of the book is
    dedicated to dealing with such situations. Even so, I recommend using methods
    and functions as units most of the time because it pays off in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: When you were thinking about `method4`, you probably realized that the function
    calls to `id` and `self.method3` were the problem, and that the method can be
    tested as a unit if they didn't invoke other units. In Python, replacing the functions
    with stand-ins at runtime is fairly easy to do, and we'll be discussing a structured
    approach to this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Check your understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the code for this simple class, and use it to figure out the
    answers to the questions. It''s okay to check back through the book. This is just
    a way for you to make sure you''re ready to move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we're using methods as units, how many units exist in the preceding
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: There are three units that exist in the preceding code and that are
    as follows: `__init__`, `method1`, and `method2`. `__init__` is a method, just
    as `method1` and `method2`. The fact that it''s a constructor means that it''s
    all tangled up with the other units, but it''s still a method containing code
    and a possible location for bugs, and so we cannot afford to treat this as anything
    other than a unit.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which units make assumptions about the correct operation of other units? In
    other words, which units are not independent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Both `method1` and `method2` assume that `__init__` works right, and
    `method2` makes the same assumption as that of `method1`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you write a test for `method2` that does not assume that other units
    work correctly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: The tests for `method2` will need to use a fake `method1` that is a
    part of the test code, and not a part of the code being tested.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unit testing during the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to walk through the development of one class, treating it as a complete
    programming project and integrating unit testing at each step of the process.
    For something as small as a single standalone class, this may seem silly, but
    it illustrates the practices that keep larger projects from getting bogged down
    in a tangle of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create a PID controller class. A PID controller is a tool from
    control theory, a way of controlling machines so that they move smoothly and efficiently.
    The robot arms that assemble cars in factories are controlled by PID controllers.
    We'll be using a PID controller for this demonstration because it's a very useful,
    and a very real-world idea. Many programmers have been asked to implement PID
    controllers at some point in their careers. This example is meant to be read as
    if we are contractors and are being paid to produce results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you find that the PID controllers are more interesting than simply an example
    in a programming book, wikipedia''s article is a good place to begin learning
    about this: [http://en.wikipedia.org/wiki/PID_controller](http://en.wikipedia.org/wiki/PID_controller).'
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our imaginary client gives us the following specification:'
  prefs: []
  type: TYPE_NORMAL
- en: We want a class that implements a PID controller for a single variable. The
    measurement, setpoint and output should all be real numbers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need to be able to adjust the setpoint at runtime, but we want it to have
    a memory, so we can easily return to the previous setpoint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We'll take this and make it more formal, not to mention complete, by writing
    a set of acceptance tests as unit tests that describe the behavior. This way we'll
    at least have it set down precisely as what we believe the client intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write a set of tests that describe the constructor. After looking
    up what a PID controller actually is, we have learned that they are defined by
    three gains and a setpoint. The controller has three components: proportional,
    integral, and derivative (this is where the name PID comes from). Each gain is
    a number that determines how much effect one of the three parts of the controller
    has on the final result. The setpoint determines what the goal of the controller
    is; in other words, to where it''s trying to move the controlled variable. Looking
    at all this, we decide that the constructor should just store the gains and the
    setpoint along with initializing some internal state that we know we''ll need
    because we read about PID controllers. With this, we know enough to write some
    constructor tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We also need tests that describe measurement processing. This means testing
    the actual use of the controller, taking a measured value as its input, and producing
    a control signal that should smoothly move the measured variable toward the setpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of a PID controller is based on time; we know that, so we're going
    to need to be able to feed the controller time values that we choose if we expect
    the tests to produce predictable results. We do this by replacing `time.time`
    with a different function of the same signature, which produces predictable results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that taken care of, we plug our test input values into the math
    that defines a PID controller along with the gains to figure out what the correct
    outputs will be, and use these numbers to write the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to write tests that describe setpoint handling. Our client asked for
    a "memory" for setpoints, which we''ll interpret as a stack, so we write tests
    that ensure that the setpoint stack works. Writing code that uses this stack behavior
    brings to our attention the fact that a PID controller with no setpoint is not
    a meaningful entity, so we add a test that checks that the PID class rejects this
    situation by raising an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: PID controllers are well-defined elsewhere, so the sparse specification that
    our client gave us works pretty well over all. Still, we had to codify several
    assumptions when we wrote our acceptance tests; it would probably be wise to check
    with the client and make sure that we didn't go astray, which means that, before
    we even ran the tests, they already helped us by pointing out questions we needed
    to ask them.
  prefs: []
  type: TYPE_NORMAL
- en: We took extra steps in the tests to help isolate them from each other, by forcing
    the `pid` module to reimport before each group of test statements. This has the
    effect of resetting anything that might have changed in the module, and causes
    it to reimport any modules that it depends on. This is particularly important,
    since we replaced `time.time` with a dummy function. We want to be sure that the
    `pid` module uses the dummy time function, so we reload the `pid` module. If the
    real-time function is used instead of the dummy, the test won't be useful because
    it will succeed only once. Tests need to be repeatable.
  prefs: []
  type: TYPE_NORMAL
- en: The stand-in time function was created by making an iterator that counts through
    the integers from 1 to 999 (as floating point values), and binding `time.time`
    to that iterator's `__next__` method. Once we were done with the time-dependent
    tests, we replaced the original `time.time`.
  prefs: []
  type: TYPE_NORMAL
- en: We did get a little bit lazy, though, because we didn't bother to isolate the
    assorted tests from the PID constructor. If there's a bug in the constructor,
    it might cause a false error report in any of the tests that are dependent on
    it. We could have been more rigorous by using a mock object instead of an actual
    PID object, and thus even skipped invoking the constructor during the tests of
    other units but, as we aren't talking about mock objects until the next chapter,
    we'll allow ourselves a bit of laziness here.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we have tests for a module that doesn't exist. That's good! Writing
    the tests was easier than writing the module, and this gives us a stepping stone
    towards getting the module right, quickly and easily. As a general rule, you always
    want to have tests ready before the code that the test is written for.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that I said "you want to have tests ready," not "you want to have all of
    the tests ready." You don't want, or need, to have every test in place before
    you start writing code. What you want is to have the tests in place that define
    the things you already know at the start of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have some tests, we can begin writing code to satisfy the tests,
    and thus also the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if the code is already written? We can still write tests for its units.
    This isn't as productive as writing the tests in parallel with the code, but this
    at least gives us a way to check our assumptions and make sure that we don't introduce
    regressions. A test suite written late is better than no test suite at all.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to run the tests because this is always the first thing you
    do when you need to decide what to do next. If all the tests pass, either you're
    done with the program or you need to write more tests. If one or more tests fail,
    you pick one and make it pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we run the tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time they tell us that we don''t have a `pid` module. Let''s create
    one and fill it with a first attempt at a `PID` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll run the tests again, and see how we did as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This immediately tells us that there''s a bug in the `calculate_response` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Development](img/3211OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are more error reports in the same vein. There should be five in total.
    It seems that the `calculate_response` method is working backwards, producing
    negatives when it should give us positives, and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that we need to look for a sign error in `calculate_response`, and
    we find it on the fourth line, where the input value should be subtracted from
    the setpoint and not the other way around. Things should work better if we change
    this line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As expected, that change fixes things. The tests all pass, now.
  prefs: []
  type: TYPE_NORMAL
- en: We used our tests to tell us what was needed to be done, and to tell us when
    our code was complete. Our first run of the tests gave us a list of things that
    needed to be written; a to-do list of sorts. After we wrote some code, we ran
    the tests again to see if it was doing what we expected, which gave us a new to-do
    list. We kept on alternately running the tests and writing code to make one of
    the tests pass until they all did. When all the tests pass, either we're done,
    or we need to write more tests.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we find a bug that isn't already caught by a test, the right thing
    to do is to add a test that catches it, and then we need to fix the bug. This
    gives a fixed bug, but also a test that covers some part of the program that wasn't
    tested before. Your new test might well catch more bugs that you weren't even
    aware of, and it will help you avoid recreating the fixed bug.
  prefs: []
  type: TYPE_NORMAL
- en: This "test a little, code a little" style of programming is called **Test-driven
    Development**, and you'll find that it's very productive.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the pattern in the way the tests failed was immediately apparent.
    There's no guarantee that will be the case, of course, but it often is. Combined
    with the ability to narrow your attention to the specific units that are having
    problems, debugging is usually a snap.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we have a PID controller, it passes our tests... are we done? Maybe. Let's
    ask the client.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that they mostly like it. They have a few things they'd like
    to be changed, though. They want us to be able to optionally specify the current
    time as a parameter to `calculate_response`, so that the specified time is used
    instead of the current system time. They also want us to change the signature
    of the constructor so that it accepts an initial measurement and optionally a
    measurement time as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: So, the program passes all of our tests, but the tests don't correctly describe
    the requirements anymore. What to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll add the initial value parameter to the constructor tests, and
    update the expected results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll add another test of the constructor, a test that checks the correct
    behavior when the optional initial time parameter is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we change the `calculate_response` tests to use the new signature for
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a second `calculate_response` test that checks whether the function
    behaves properly when the optional time parameter is passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we adjust the constructor call in the setpoint method tests. This change
    looks the same as the constructor call changes in the other tests.
  prefs: []
  type: TYPE_NORMAL
- en: When we're adjusting the tests, we discover that the behavior of the `calculate_response`
    method has changed due to the addition of the initial value and initial time parameters
    to the constructor. The tests will report this as an error but it's not clear
    that if it really is wrong, so we check this with the client. After talking it
    over, the client decides that this is actually correct behavior, so we change
    our tests to reflect that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our complete specification and test document now looks like this (new or changed
    lines are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our tests didn't match the requirements and so we needed to change them. That's
    fine, but we don't want to change them too much because the tests we have already
    help us to avoid some problems that we've previously spotted or had to fix. The
    last thing we want for the computer is to stop checking for known problems. Because
    of this, we very much prefer adding new tests, instead of changing old ones.
  prefs: []
  type: TYPE_NORMAL
- en: This is one reason why we added new tests to check the behavior when the optional
    time parameters were supplied. The other reason is that, if we added these parameters
    to the existing tests, we wouldn't have any tests of what happens when you don't
    use these parameters. We always want to check every code path through each unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of the initial parameter to the constructor is a big deal. It
    not only changes the way the constructor should behave, it also changes the way
    the `calculate_response` method should behave in a rather dramatic way. Since
    there is a change in the correct behavior (a fact that we didn''t realize until
    the tests pointed it out to us, which in turn allowed us to get a confirmation
    of what the correct behavior should be from our clients before we started writing
    the code), we have no choice but to go through and change the tests, recalculating
    the expected outputs and all. Doing all that work has a benefit, though, over
    and above the future ability to check whether the function is working correctly:
    this makes it much easier to comprehend how the function should work when we actually
    write it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we change a test to reflect new correct behavior, we still try to change
    it as little as possible. After all, we don't want the test to stop checking for
    old behavior that's still correct, and we don't want to introduce a bug in the
    test itself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To a certain extent, the code being tested acts as a test of the test, so even
    bugs in your tests don't survive very long when you use good testing discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Development, again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time to do some more coding. In real life, we might cycle between development
    and feedback any number of times, depending on how well we're able to communicate
    with our clients. In fact, it might be a good thing to increase the number of
    times we go back and forth, even if this means that each cycle is short. Keeping
    the clients in the loop and up-to-date is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step, as always, is to run the tests and get an updated list of the
    things that need to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Development, again](img/3211OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are actually a lot more errors that are reported, but the very first one
    gives us a good hint about what we need to fix right off. The constructor needs
    to change to match the tests' expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `doctest` error report to guide us, and rerunning the tests frequently,
    we can quickly get our PID class into shape. In practice, this works best using
    short development cycles where you make only a few changes to the code, and then
    run the tests again. Fix one thing, and then test again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve gone back and forth between coding and testing enough times, we''ll
    end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once again, all of the tests pass including all of the revised tests from the
    client, and it's remarkable how rewarding that lack of an error report can be.
    We're ready to see whether the client is willing to accept delivery of the code
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Later stages of the process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are later phases of development when it's your job to maintain the code,
    or to integrate it into another product. Functionally, they work in the same way
    as the development phase. If you're handling pre-existing code and are asked to
    maintain or integrate it, you'll be much happier if it comes to you with a test
    suite already written because, until you've mastered the intricacies of the code,
    the test suite is the only way in which you'll be able to modify the code with
    confidence.
  prefs: []
  type: TYPE_NORMAL
- en: If you're unfortunate enough to be handed a pile of code with no tests, writing
    tests is a good first step. Each test you write is one more unit of the code that
    you can honestly say you understand, and know what to expect from. And, of course,
    each test you write is one more unit that you can count on to tell you if you
    introduce a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've walked through the process of developing a project using unit testing
    and test-driven development, paying attention to the ways that we can identify
    units, and covering some of the ways in which we can isolate `doctest` tests for
    individual units.
  prefs: []
  type: TYPE_NORMAL
- en: We've also talked about the philosophy and discipline of unit testing, what
    it is in detail, and why it is valuable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss mock objects, a powerful tool for isolating
    units.
  prefs: []
  type: TYPE_NORMAL
