<html><head></head><body>
<section id="chapter-1-understanding-functional-programming" class="level2 chapterHead" data-number="0.5">&#13;
<h2 class="chapterHead" data-number="0.5"><span class="titlemark"> 1</span><br/>&#13;
<span id="x1-180001"/>Understanding Functional Programming</h2>&#13;
<p>Functional programming defines a computation using expressions and evaluation; often, they are encapsulated in function definitions. It de-emphasizes or avoids the complexity of state change and mutable objects. This tends to create programs that are more succinct and expressive. In this chapter, we’ll introduce some of the techniques that characterize functional programming. We’ll identify some of the ways to map these features to <span class="keyWord">Python</span>. Finally, we’ll also address some ways in which the benefits of functional programming accrue when we use these design patterns to build Python applications.</p>&#13;
<p>This book doesn’t contain a tutorial introduction to the Python language. We assume the reader knows some Python. In many cases, if the reader knows a functional programming language, then that knowledge can be applied to Python via the examples in this book. For background information on Python, see <span class="cmti-10x-x-109">Python in a Nutshell, 4th Edition</span>, or any of the Python introductions from Packt Publishing.</p>&#13;
<p>Python has a broad variety of programming features, including numerous ways to support functional programming. As we will see throughout this book, Python is not a <span class="cmti-10x-x-109">purely </span>functional programming language; instead, it relies on a mixture of features. We’ll see that the language offers enough of the right kinds of features to provide the benefits of functional programming. It also retains all the optimization power of an imperative programming language. Further, we can mix the object-oriented and functional features to make use of the best aspects of both paradigms.</p>&#13;
<p>We’ll also look at a problem domain that we’ll use for many of the examples in this book. We’ll try to stick closely<span id="dx1-18001"/> to <span class="keyWord">Exploratory Data Analysis</span> (<span class="keyWord">EDA</span>). For more information, see <a href="https://www.itl.nist.gov/div898/handbook/eda/eda.htm" class="url">https://www.itl.nist.gov/div898/handbook/eda/eda.htm</a>. The idea of ”exploratory” means doing data collection followed by analysis, with a goal of inferring what model would be appropriate to describe the data. This is a helpful domain because many of the algorithms are good examples of functional programming. Furthermore, the benefits of functional programming accrue rapidly when exploring data to locate trends and relationships.</p>&#13;
<p>Our goal is to establish some essential principles of functional programming. The more serious Python code will begin in <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential</span> <span class="cmti-10x-x-109">Functional Concepts</span></a>.</p>&#13;
<p>In this chapter, we’ll focus on the following topics:</p>&#13;
<ul>&#13;
<li><p>Comparing and contrasting the functional paradigm with other ways of designing software. We’ll look at how Python’s approach can be called a ”hybrid” between functional programming and object-oriented programming.</p></li>&#13;
<li><p>We’ll look in depth at a specific example extracted from the functional programming literature.</p></li>&#13;
<li><p>We’ll conclude with an overview of EDA and why this discipline seems to provide numerous examples of functional programming.</p></li>&#13;
</ul>&#13;
<div id="tcolobox-5" class="packt_tip">&#13;
&#13;
&#13;
<p>We’ll focus on Python 3.10 features in this book. This includes the new <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement.</p>&#13;
&#13;
&#13;
&#13;
&#13;
<p>Throughout this book, we’ll include Python 3 type hints in the examples. Type hints can help a reader visualize the essential purpose behind a function definition. Type hints are analyzed with the <span class="keyWord">mypy</span><span id="dx1-18002"/> tool. As with unit testing, <span class="keyWord">mypy </span>can be part of a tool chain to produce high-quality software.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-18003r1"/></p>&#13;
<section id="the-functional-style-of-programming" class="level3 sectionHead" data-number="0.5.1">&#13;
<h3 class="sectionHead" data-number="0.5.1"><span class="titlemark">1.1 </span> <span id="x1-190001"/>The functional style of programming</h3>&#13;
<p>We’ll define functional programming through a series of examples. The distinguishing feature between these examples is the concept of <span class="keyWord">state</span>,<span id="dx1-19001"/> specifically the state of the computation.</p>&#13;
<p>Python’s strong imperative<span id="dx1-19002"/> traits mean that the state of a computation is defined by the values of the variables in the various namespaces. Some kinds of statements make a well-defined change to the state by adding, changing, or removing a variable. We call this <span class="keyWord">imperative </span>because specific kinds of statements change the state.</p>&#13;
<p>In Python, the assignment<span id="dx1-19003"/> statement is the primary<span id="dx1-19004"/> way to change the state. Python has other statements, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">global</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">nonlocal</code></span></span>, which modify<span id="dx1-19005"/> the rules for variables in a particular namespace. Statements such<span id="dx1-19006"/> as <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">class</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">import</code></span></span> change the processing context. The bulk of the remaining statements<span id="dx1-19007"/> provide ways to choose which assignment statements get executed. The focus of all these various statement<span id="dx1-19008"/> types, however, is on changing the state of the variables.</p>&#13;
<p>In a functional language, we replace the state—the changing values of variables—with a simpler notion of evaluating functions. Each function<span id="dx1-19009"/> evaluation creates a new object or objects from existing objects. Since a functional program is a composition<span id="dx1-19010"/> of functions, we can design lower-level functions that are easy to understand, and then create compositions of functions that can also be easier to visualize than a complex sequence of statements.</p>&#13;
<p>Function evaluation more closely parallels mathematical formalisms. Because of this, we can often use simple algebra to design an algorithm that clearly handles the edge cases and boundary conditions. This makes us more confident that the functions work. It also makes it easy to locate test cases for formal unit testing.</p>&#13;
<p>It’s important to note that functional programs tend to be relatively succinct, expressive, and efficient compared to imperative (object-oriented or procedural) programs. The benefit isn’t automatic; it requires careful design. This design effort for functional programming is often smaller than for procedural programming. Some developers experienced in imperative and object-oriented styles may find it a challenge to shift their focus from stateful designs to functional designs. <span id="x1-19011r19"/></p>&#13;
</section>&#13;
<section id="comparing-and-contrasting-procedural-and-functional-styles" class="level3 sectionHead" data-number="0.5.2">&#13;
<h3 class="sectionHead" data-number="0.5.2"><span class="titlemark">1.2 </span> <span id="x1-200002"/>Comparing and contrasting procedural and functional styles</h3>&#13;
<p>We’ll use a tiny example<span id="dx1-20001"/> program to illustrate a non-functional, or procedural, style of programming. This example<span id="dx1-20002"/> computes a sum of a sequence of numbers. Each of the numbers has a specific property that makes it part of the sequence.</p>&#13;
<pre id="listing-2" class="lstlisting"><code>def sum_numeric(limit: int = 10) -&gt; int: &#13;
    s = 0 &#13;
    for n in range(1, limit): &#13;
        if n % 3 == 0 or n % 5 == 0: &#13;
            s += n &#13;
    return s</code></pre>&#13;
<p>The sum computed by this function includes only numbers that are multiples of 3 or 5. We’ve made this program strictly procedural, avoiding any explicit use of Python’s object features. The function’s state is defined by the values of the variables <span class="obeylines-h"><span class="verb"><code class="inlineCode">s</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>. The variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> takes on values such that 1 <span class="cmsy-10x-x-109">≤ </span><span class="italic">n &lt; </span>10. As the iteration involves an ordered exploration of values for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> variable, we can prove that it will terminate when the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is equal to the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">limit</code></span></span>.</p>&#13;
<p>There are two explicit assignment statements, both setting values for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">s</code></span></span> variable. These state changes are visible. The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is set implicitly by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. The state change in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">s</code></span></span> variable is an essential element of the state of the computation.</p>&#13;
<p>Now let’s look at this again from a purely functional perspective. Then, we’ll examine a more Pythonic perspective that retains the essence of a functional approach while leveraging a number of Python’s features. <span id="x1-20009r1"/></p>&#13;
<section id="using-the-functional-paradigm" class="level4 subsectionHead" data-number="0.5.2.1">&#13;
<h4 class="subsectionHead" data-number="0.5.2.1"><span class="titlemark">1.2.1 </span> <span id="x1-210001"/>Using the functional paradigm</h4>&#13;
<p>In a functional<span id="dx1-21001"/> sense, the sum of the multiples of 3 and 5 can be decomposed into two parts:</p>&#13;
<ul>&#13;
<li><p>The sum of a sequence of numbers</p></li>&#13;
<li><p>A sequence of values that pass a simple test condition, for example, being multiples of 3 and 5</p></li>&#13;
</ul>&#13;
<p>To be super formal, we can define the sum as a function using simpler language components. The sum of a sequence has a recursive definition:</p>&#13;
<pre id="listing-3" class="lstlisting"><code>from collections.abc import Sequence &#13;
def sumr(seq : Sequence[int]) -&gt; int: &#13;
    if len(seq) == 0: &#13;
        return 0 &#13;
    return seq[0] + sumr(seq[1:])</code></pre>&#13;
<p>We’ve defined the sum in two cases. The <span class="keyWord">base case </span>states that the sum of a zero-length sequence is 0. The <span class="keyWord">recursive case </span>states that the sum of a sequence is the first value plus the sum of the rest of the sequence. Since the recursive definition<span id="dx1-21007"/> depends on a shorter sequence, we can be sure that it will (eventually) devolve to the base case.</p>&#13;
<p>Here are some examples of how this function works:</p>&#13;
<div id="tcolobox-7" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sumr([7, 11]) &#13;
18 &#13;
&gt;&gt;&gt; sumr([11]) &#13;
11 &#13;
&gt;&gt;&gt; sumr([]) &#13;
0</code></pre>&#13;
&#13;
</div>&#13;
<p>The first example computes the sum of a list with multiple items. The second example shows how the recursion rule works by adding the first item, <span class="obeylines-h"><span class="verb"><code class="inlineCode">seq[0]</code></span></span>, to the sum of the remaining items, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sumr(seq[1:])</code></span></span>. Eventually, the computation<span id="dx1-21015"/> of the result involves the sum of an empty list, which is defined as 0.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> operator on the last line of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sumr</code></span></span> function and the initial value of 0 in the base case characterize the equation as a sum. Consider what would happen if we changed the operator to <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> and the initial value to 1: this new expression would compute a product. We’ll return to this simple idea of <span class="keyWord">generalization </span>in the following chapters.</p>&#13;
<p>Similarly, generating a sequence<span id="dx1-21016"/> of values with a given property can have a recursive definition, as follows:</p>&#13;
<pre id="listing-4" class="lstlisting"><code>from collections.abc import Sequence, Callable &#13;
def until( &#13;
        limit: int, &#13;
        filter_func: Callable[[int], bool], &#13;
        v: int &#13;
) -&gt; list[int]: &#13;
    if v == limit: &#13;
        return [] &#13;
    elif filter_func(v): &#13;
        return [v] + until(limit, filter_func, v + 1) &#13;
    else: &#13;
        return until(limit, filter_func, v + 1)</code></pre>&#13;
<p>In this function, we’ve compared a given value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span>, against the upper bound, <span class="obeylines-h"><span class="verb"><code class="inlineCode">limit</code></span></span>. If <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span> has reached the upper bound, the resulting list must be empty. This is the base case for the given recursion.</p>&#13;
<p>There are two more cases defined by an externally defined <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter_func()</code></span></span> function. The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span> is passed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter_func()</code></span></span> function; if this returns a very small list, containing one element, this can be concatenated with any remaining values computed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">until()</code></span></span> function.</p>&#13;
<p>If the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span> is rejected by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter_func()</code></span></span> function, this value is ignored and the result is simply defined by any remaining values computed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">until()</code></span></span> function.</p>&#13;
<p>We can see that the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span> will increase from an initial value until it reaches <span class="obeylines-h"><span class="verb"><code class="inlineCode">limit</code></span></span>, assuring us that we’ll reach the base case.</p>&#13;
<p>Before we can see how to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">until()</code></span></span> function, we’ll define a small function to filter values that are multiples of 3 or 5:</p>&#13;
<pre id="listing-5" class="lstlisting"><code>def mult_3_5(x: int) -&gt; bool: &#13;
    return x % 3 == 0 or x % 5 == 0</code></pre>&#13;
<p>We could also have defined this as a lambda object to emphasize succinct definitions<span id="dx1-21031"/> of simple functions. Anything more complex<span id="dx1-21032"/> than a one-line expression requires the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement.</p>&#13;
<p>This function can be combined with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">until()</code></span></span> function to generate a sequence of values, which are multiples of 3 and 5. Here’s an example:</p>&#13;
<div id="tcolobox-8" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; until(10, mult_3_5, 0) &#13;
[0, 3, 5, 6, 9]</code></pre>&#13;
&#13;
</div>&#13;
<p>Looking back at the decomposition at the top of this section, we now have a way to compute sums and a way to compute the sequence of values.</p>&#13;
<p>We can combine the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sumr()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">until()</code></span></span> functions to compute a sum of values. Here’s the resulting code:</p>&#13;
<pre id="listing-6" class="lstlisting"><code>def sum_functional(limit: int = 10) -&gt; int: &#13;
    return sumr(until(limit, mult_3_5, 0))</code></pre>&#13;
<p>This small application to compute a sum doesn’t make use of the assignment statement to set the values of variables. It is a purely functional, recursive definition that matches the mathematical abstractions, making it easier to reason about. We can be confident each piece works separately, giving confidence in the whole.</p>&#13;
<p>As a practical matter, we’ll use a number of Python features to simplify creating functional programs. We’ll take a look at a number of these optimizations in the next version of this example. <span id="x1-21038r21"/></p>&#13;
</section>&#13;
<section id="using-a-functional-hybrid" class="level4 subsectionHead" data-number="0.5.2.2">&#13;
<h4 class="subsectionHead" data-number="0.5.2.2"><span class="titlemark">1.2.2 </span> <span id="x1-220002"/>Using a functional hybrid</h4>&#13;
<p>We’ll continue this example with a mostly functional<span id="dx1-22001"/> version of the previous example to compute the sum of multiples of 3 and 5. Our <span class="keyWord">hybrid </span>functional version might look like the following:</p>&#13;
<pre id="listing-7" class="lstlisting"><code>def sum_hybrid(limit: int = 10) -&gt; int: &#13;
    return sum( &#13;
        n for n in range(1, limit) &#13;
        if n % 3 == 0 or n % 5 == 0 &#13;
    )</code></pre>&#13;
<p>We’ve used a generator expression to iterate through a collection of values and compute the sum of these values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(1,</code><code class="inlineCode"> 10)</code></span></span> object is an iterable; it generates a sequence of values <span class="cmsy-10x-x-109">{</span><span class="italic">n</span><span class="cmsy-10x-x-109">∣</span>1 <span class="cmsy-10x-x-109">≤ </span><span class="italic">n &lt; </span>10<span class="cmsy-10x-x-109">}</span>, often summarized as “values of <span class="italic">n</span> such that 1 is less than or equal to <span class="italic">n </span>and <span class="italic">n </span>is less than 10.” The more complex expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code><code class="inlineCode"> for</code><code class="inlineCode"> n</code><code class="inlineCode"> in</code><code class="inlineCode"> range(1,</code><code class="inlineCode"> 10)</code><code class="inlineCode"> if</code><code class="inlineCode"> n</code><code class="inlineCode"> %</code><code class="inlineCode"> 3</code><code class="inlineCode"> ==</code><code class="inlineCode"> 0</code><code class="inlineCode"> or</code><code class="inlineCode"> n</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">%</code><code class="inlineCode"> 5</code><code class="inlineCode"> ==</code><code class="inlineCode"> 0</code></span></span> is also a generator. It produces a set of values, <span class="cmsy-10x-x-109">{</span><span class="italic">n</span><span class="cmsy-10x-x-109">∣</span>1 <span class="cmsy-10x-x-109">≤ </span><span class="italic">n &lt; </span>10 <span class="cmsy-10x-x-109">∧ </span>(<span class="italic">n </span><span class="cmsy-10x-x-109">≡ </span>0 mod 3 <span class="cmsy-10x-x-109">∨</span><span class="italic">n </span><span class="cmsy-10x-x-109">≡ </span>0 mod 5)<span class="cmsy-10x-x-109">}</span>; something we can describe as “values of <span class="italic">n </span>such that 1 is less than or equal to <span class="italic">n </span>and <span class="italic">n </span>is less than 10 and <span class="italic">n </span>is equivalent to 0 modulo 3 or <span class="italic">n </span>is equivalent to 0 modulo 5.” These are multiples of 3 and 5 taken from the set of values between 1 and 10. The variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is bound, in turn, to each of the values provided by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range</code></span></span> object. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function consumes the iterable values, creating a final object, 23.</p>&#13;
<div id="tcolobox-9" class="packt_tip">&#13;
&#13;
&#13;
<p>The bound variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>, doesn’t exist outside the generator expression. The variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> isn’t visible elsewhere in the program.</p>&#13;
&#13;
</div>&#13;
<p>The variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> in this example isn’t directly comparable to the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> in the first two imperative examples. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement (outside a generator expression) creates a proper variable in the local namespace. The generator expression does not create a variable in the same way that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement does:</p>&#13;
<div id="tcolobox-10" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sum( &#13;
...     n for n in range(1, 10) &#13;
...     if n % 3 == 0 or n % 5 == 0 &#13;
... ) &#13;
23 &#13;
&gt;&gt;&gt; n &#13;
Traceback (most recent call last): &#13;
   File "&lt;stdin&gt;", line 1, in &lt;module&gt; &#13;
NameError: name ’n’ is not defined</code></pre>&#13;
&#13;
</div>&#13;
<p>The generator expression<span id="dx1-22017"/> doesn’t pollute the namespace with variables, like <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>, which aren’t relevant outside the very narrow context of the expression. This is a pleasant feature that ensures we won’t be confused by the values of variables that don’t have a meaning outside a single expression. <span id="x1-22018r22"/></p>&#13;
</section>&#13;
<section id="the-stack-of-turtles" class="level4 subsectionHead" data-number="0.5.2.3">&#13;
<h4 class="subsectionHead" data-number="0.5.2.3"><span class="titlemark">1.2.3 </span> <span id="x1-230003"/>The stack of turtles</h4>&#13;
<p>When we use Python for functional programming, we embark down a path<span id="dx1-23001"/> that will involve a hybrid that’s not strictly functional. Python is not <span class="keyWord">Haskell</span>,<span id="dx1-23002"/> <span class="keyWord">OCaml</span>, or <span class="keyWord">Erlang</span><span id="dx1-23003"/>. For that matter, our underlying processor hardware is not functional; it’s not even strictly object-oriented, as CPUs are generally procedural.</p>&#13;
<blockquote>&#13;
<p><em>All programming languages rest on abstractions, libraries, frameworks and virtual machines. These abstractions, in turn, may rely on other abstractions, libraries, frameworks and virtual machines. The most apt metaphor is this: the world is carried on the back of a giant turtle. The turtle stands on the back of another giant turtle. And that turtle, in turn, is standing on the back of yet another turtle.</em></p>&#13;
<p><em>It’s turtles all the way down.</em></p>&#13;
<p class="cite"><em>— Anonymous</em></p>&#13;
</blockquote>&#13;
<p>There’s no practical end to the layers of abstractions<span id="dx1-23004"/>. Even something as concrete as circuits and electronics may be an abstraction to help designers summarize the details of quantum electrodynamics.</p>&#13;
<p>More importantly, the presence of abstractions and virtual machines doesn’t materially change our approach to designing software to exploit the functional programming features of Python.</p>&#13;
<p>Even within the functional programming community, there are both purer and less pure functional programming languages. Some languages make extensive use of monads to handle stateful things such as file system input and output. Other languages rely on a hybridized environment that’s similar to the way we use Python. In Python, software can be generally functional, with carefully chosen procedural exceptions.</p>&#13;
<p>Our functional Python programs<span id="dx1-23005"/> will rely on the following three stacks of abstractions:</p>&#13;
<ul>&#13;
<li><p>Our applications will be functions—all the way down—until we hit the objects;</p></li>&#13;
<li><p>The underlying Python runtime environment that supports our functional programming is objects—all the way down—until we hit the libraries;</p></li>&#13;
<li><p>The libraries that support Python are a turtle on which Python stands.</p></li>&#13;
</ul>&#13;
<p>The operating system and hardware form their own stack of turtles. These details aren’t relevant to the problems we’re going to solve. <span id="x1-23006r20"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="a-classic-example-of-functional-programming" class="level3 sectionHead" data-number="0.5.3">&#13;
<h3 class="sectionHead" data-number="0.5.3"><span class="titlemark">1.3 </span> <span id="x1-240003"/>A classic example of functional programming</h3>&#13;
<p>As part of our introduction, we’ll look at a classic example<span id="dx1-24001"/> of functional programming. This is based on the paper <span class="cmti-10x-x-109">Why Functional Programming Matters</span> by John Hughes. The article appeared in a paper called <span class="cmti-10x-x-109">Research Topics in</span> <span class="cmti-10x-x-109">Functional Programming</span>, edited by D. Turner, published by Addison-Wesley in 1990.</p>&#13;
<p>Here’s a link to one of the papers in <span class="cmti-10x-x-109">Research Topics in Functional</span> <span class="cmti-10x-x-109">Programming</span>, “Why Functional Programming Matters”: <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" class="url">http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf</a></p>&#13;
<p>This paper is a profound discussion of functional programming. There are several examples given. We’ll look at just one: the <span class="keyWord">Newton-Raphson algorithm </span>for locating<span id="dx1-24002"/> any roots of a function. In this case, we’ll define a function that will compute a square root of a number.</p>&#13;
<p>It’s important because many versions<span id="dx1-24003"/> of this algorithm rely on the explicit state managed via loops. Indeed, the Hughes paper provides a snippet of the <span class="keyWord">Fortran</span> code that emphasizes stateful, imperative processing.</p>&#13;
<p>The backbone of this approximation is the calculation of the next approximation from the current approximation. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span> function takes <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, an approximation to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt(n)</code></span></span> value, and calculates a next value that brackets the proper root. Take a look at the following example:</p>&#13;
<pre id="listing-8" class="lstlisting"><code>def next_(n: float, x: float) -&gt; float: &#13;
    return (x + n / x) / 2</code></pre>&#13;
<p>This function computes a series of values that will quickly converge on some value <span class="italic">x </span>such that <span class="italic">x </span>= <img src="../Images/file4.jpg" class="frac" data-align="middle" alt="n x"/>, which means <span class="italic">x </span>= <img src="../Images/file5.jpg" class="sqrt" alt="√-- n"/>.</p>&#13;
<div id="tcolobox-11" class="infobox note">&#13;
&#13;
&#13;
<p>Note that the name <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> would collide with a built-in function. Calling it <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span> lets us follow the original presentation as closely as possible, using Pythonic names.</p>&#13;
&#13;
</div>&#13;
<p>Here’s how the function looks when used in Python’s interactive REPL:</p>&#13;
<div id="tcolobox-12" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; n = 2 &#13;
&gt;&gt;&gt; f = lambda x: next_(n, x) &#13;
&gt;&gt;&gt; a0 = 1.0 &#13;
&gt;&gt;&gt; [round(x, 4) &#13;
... for x in (a0, f(a0), f(f(a0)), f(f(f(a0))),) &#13;
... ] &#13;
[1.0, 1.5, 1.4167, 1.4142]</code></pre>&#13;
&#13;
</div>&#13;
<p>We defined the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f()</code></span></span> function as a lambda that will converge on <img src="../Images/file6.jpg" class="sqrt" alt="√ -- n"/> where <span class="italic">n </span>= 2. We started with 1.0 as the initial value for <span class="italic">a</span><sub><span class="cmr-8">0</span></sub>. Then we evaluated a sequence of recursive evaluations: <span class="italic">a</span><sub><span class="cmr-8">1</span></sub> = <span class="italic">f</span>(<span class="italic">a</span><sub><span class="cmr-8">0</span></sub>), <span class="italic">a</span><sub><span class="cmr-8">2</span></sub> = <span class="italic">f</span>(<span class="italic">f</span>(<span class="italic">a</span><sub><span class="cmr-8">0</span></sub>)), and so on. We evaluated these functions using a generator expression so that we could round each value to four decimal places. This makes the output easier to read and easier to use with <span class="obeylines-h"><span class="verb"><code class="inlineCode">doctest</code></span></span>. The sequence appears to converge rapidly on <img src="../Images/file7.jpg" class="sqrt" alt="√-- 2"/>. To get a more precise answer, we must continue to perform the series of steps after the first four shown above.</p>&#13;
<p>We can write a function<span id="dx1-24014"/> that will (in principle) generate an infinite sequence of <span class="italic">a</span><sub><span class="cmmi-8">i</span></sub> values. This series will converge on the proper square root:</p>&#13;
<pre id="listing-9" class="lstlisting"><code>from collections.abc import Iterator, Callable &#13;
def repeat( &#13;
        f: Callable[[float], float], &#13;
        a: float &#13;
) -&gt; Iterator[float]: &#13;
    yield a &#13;
    yield from repeat(f, f(a))</code></pre>&#13;
<p>This function will generate a sequence of approximations using a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">f()</code></span></span>, and an initial value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span>. If we provide the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span> function defined earlier, we’ll get a sequence of approximations to the square root of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> argument.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span> function expects the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f()</code></span></span> function to have a single argument; however, our <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span> function has two arguments. We’ve used a lambda object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> x:</code><code class="inlineCode"> next_(n,</code><code class="inlineCode"> x)</code></span></span>, to create a partial version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span> function with one of two variables bound.</p>&#13;
<div id="tcolobox-13" class="packt_tip">&#13;
&#13;
&#13;
<p>The Python generator functions can’t be trivially recursive; they must explicitly iterate over the recursive results, yielding them individually.</p>&#13;
<p>Attempting to use a simple <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code><code class="inlineCode"> repeat(f,</code><code class="inlineCode"> f(a))</code></span></span> will end the iteration, returning a generator expression instead of yielding values.</p>&#13;
<p>There are two ways to return all the values instead of returning a generator expression, which are as follows:</p>&#13;
<ul>&#13;
<li><p>We can write an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to yield values as follows:</p>&#13;
<pre id="listing-10" class="lstlisting"><code>for x in some_iter: yield x</code></pre></li>&#13;
<li><p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> expression as follows:</p>&#13;
<pre id="listing-11" class="lstlisting"><code>yield from some_iter</code></pre></li>&#13;
</ul>&#13;
<p>Both techniques of yielding the values of a recursive generator function are will have similar results. We’ll try to emphasize <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span>.</p>&#13;
<p>It turns out that <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> are a bit more sophisticated than we’ve shown here. For our purposes, we’ll limit ourselves to working with recursive results. For more information on the full feature set for <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span>, see PEP 342 and PEP 380: <a href="https://peps.python.org/pep-0342/" class="url">https://peps.python.org/pep-0342/</a> and <a href="https://peps.python.org/pep-0380/" class="url">https://peps.python.org/pep-0380/</a>.</p>&#13;
&#13;
</div>&#13;
<p>Of course, we don’t want the entire infinite<span id="dx1-24024"/> sequence created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span> function. It’s essential to stop generating values when we’ve found the square root we’re looking for. The common symbol for the limit we can consider “close enough” is the Greek letter <span class="keyWord">epsilon</span>, <span class="italic">𝜖</span>.</p>&#13;
<p>In Python, we have to be a little clever when taking items from an infinite sequence one at a time. It works out well to use a simple interface function that wraps a slightly more complex recursion. Take a look at the following code snippet:</p>&#13;
<pre id="listing-12" class="lstlisting"><code>from collections.abc import Iterator &#13;
def within( &#13;
        𝜖: float, &#13;
        iterable: Iterator[float] &#13;
) -&gt; float: &#13;
    def head_tail( &#13;
            𝜖: float, &#13;
            a: float, &#13;
            iterable: Iterator[float] &#13;
    ) -&gt; float: &#13;
        b = next(iterable) &#13;
        if abs(a-b) &lt;= 𝜖: &#13;
            return b &#13;
        return head_tail(𝜖, b, iterable) &#13;
 &#13;
    return head_tail(𝜖, next(iterable), iterable)</code></pre>&#13;
<p>We’ve defined an internal function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_tail()</code></span></span>, which accepts the tolerance, <span class="italic">𝜖</span>, an item from the iterable sequence, <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span>, and the rest of the iterable sequence, <span class="obeylines-h"><span class="verb"><code class="inlineCode">iterable</code></span></span>. The first item from the iterable, extracted with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> function, is bound to a name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span>. If <span class="cmsy-10x-x-109">|</span><span class="italic">a </span><span class="cmsy-10x-x-109">− </span><span class="italic">b</span><span class="cmsy-10x-x-109">|≤ </span><span class="italic">𝜖</span>, the two values of <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span> are close enough to call the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span> the square root; the difference is less than or equal to the very small value of <span class="italic">𝜖</span>. Otherwise, we use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span> value in a recursive invocation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_tail()</code></span></span> function to examine the next pair of values.</p>&#13;
<p>Our <span class="obeylines-h"><span class="verb"><code class="inlineCode">within()</code></span></span> function properly<span id="dx1-24041"/> initializes the internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_tail()</code></span></span> function with the first value from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iterable</code></span></span> parameter.</p>&#13;
<p>We can use the three functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">within()</code></span></span>, to create a square root function, as follows:</p>&#13;
<pre id="listing-13" class="lstlisting"><code>def sqrt(n: float) -&gt; float: &#13;
    return within( &#13;
        𝜖=0.0001, &#13;
        iterable=repeat( &#13;
            lambda x: next_(n, x), &#13;
            1.0 &#13;
        ) &#13;
    )</code></pre>&#13;
<p>We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span> function to generate a (potentially) infinite sequence of values based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_(n,x)</code></span></span> function. Our <span class="obeylines-h"><span class="verb"><code class="inlineCode">within()</code></span></span> function will stop generating values in the sequence when it locates two values with a difference less than <span class="italic">𝜖</span>.</p>&#13;
<p>This definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt()</code></span></span> function provides useful default values to the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">within()</code></span></span> function. It provides an <span class="italic">𝜖 </span>value of 0.0001 and an initial <span class="italic">a</span><sub><span class="cmr-8">0</span></sub> value of 1.0.</p>&#13;
<p>A more advanced version could use default parameter values to make changes possible. As an exercise, the definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt()</code></span></span> can be rewritten so an expression such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt(1.0,</code><code class="inlineCode"> 0.000_01,</code><code class="inlineCode"> 3)</code></span></span> will start with an approximation of 1.0 and compute the value of <img src="../Images/file8.jpg" class="sqrt" alt="√ -- 3"/> to within 0.00001. For most applications, the initial <span class="italic">a</span><sub><span class="cmr-8">0</span></sub> value can be 1.0. However, the closer it is to the actual square root, the more rapidly this algorithm converges.</p>&#13;
<p>The original example<span id="dx1-24050"/> of this approximation algorithm was shown in the Miranda language. It’s easy to see there are some profound differences between Miranda and Python. In spite of the differences, the similarities give us confidence that many kinds of functional programming can be easily implemented in Python.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">within</code></span></span> function shown here is written to match the original article’s function definition. Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> library provides a <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function that might be better for this application than the <span class="obeylines-h"><span class="verb"><code class="inlineCode">within()</code></span></span> function. Similarly, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">math.isclose()</code></span></span> function may be better than the <span class="obeylines-h"><span class="verb"><code class="inlineCode">abs(a-b)</code><code class="inlineCode"> &lt;=</code><code class="inlineCode"> </code><span class="italic">𝜖</span></span></span> expression used here. Python offers a great many pre-built functional programming features; we’ll look closely at these functions in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools</span> <span class="cmti-10x-x-109">Module</span></a> and <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 9</span></a>, <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Itertools for Combinatorics – Permutations and</span> <span class="cmti-10x-x-109">Combinations</span></a>. <span id="x1-24051r24"/></p>&#13;
</section>&#13;
<section id="exploratory-data-analysis" class="level3 sectionHead" data-number="0.5.4">&#13;
<h3 class="sectionHead" data-number="0.5.4"><span class="titlemark">1.4 </span> <span id="x1-250004"/>Exploratory data analysis</h3>&#13;
<p>Later in this book, we’ll use the field of exploratory<span id="dx1-25001"/> data analysis as a source for concrete examples of functional programming. This field is rich with algorithms and approaches to working with complex datasets; functional programming is often a very good fit between the problem domain and automated solutions.</p>&#13;
<p>While details vary from author to author, there are several widely accepted stages of EDA. These include the following:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Data preparation</span>: This might<span id="dx1-25002"/> involve extraction and transformation for source applications. It might involve parsing a source data format and doing some kind of data scrubbing to remove unusable or invalid data. This is an excellent application of functional design techniques.</p></li>&#13;
</ul>&#13;
<div id="tcolobox-14" class="infobox note">&#13;
&#13;
&#13;
<p>David Mertz’s superb book <span class="cmti-10x-x-109">Cleaning</span> <span class="cmti-10x-x-109">Data for Effective Data Science</span>( <a href="https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291" class="url">https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291</a>) provides additional information on data cleaning. This is a crucial subject for all data science and analytical work.</p>&#13;
&#13;
</div>&#13;
<ul>&#13;
<li><p><span class="keyWord">Data exploration</span>: This is a description<span id="dx1-25003"/> of the available data. This usually involves the essential statistical functions. This is another excellent place to explore functional programming. We can describe our focus as univariate and bivariate statistics, but that sounds too daunting and complex. What this really means is that we’ll focus on mean, median, mode, and other related descriptive statistics. Data exploration may also involve data visualization. We’ll skirt this issue because it doesn’t involve very much functional programming.</p></li>&#13;
</ul>&#13;
<div id="tcolobox-15" class="infobox note">&#13;
&#13;
&#13;
<p>For more information on Python visualization, see <span class="cmti-10x-x-109">Interactive Data Visualization with Python</span>, <a href="https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944" class="url">https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944</a>. See <a href="https://www.projectpro.io/article/python-data-visualization-libraries/543" class="url">https://www.projectpro.io/article/python-data-visualization-libraries/543</a> for some additional visualization libraries.</p>&#13;
&#13;
</div>&#13;
<ul>&#13;
<li><p><span class="keyWord">Data modeling and machine learning</span>: This tends<span id="dx1-25004"/> to be prescriptive as it involves extending a model to new data. We’re going to skirt around this because some of the models can become mathematically complex. If we spend too much time on these topics, we won’t be able to focus on functional programming.</p></li>&#13;
<li><p><span class="keyWord">Evaluation and comparison</span>: When there<span id="dx1-25005"/> are alternative<span id="dx1-25006"/> models, each must be evaluated to determine which is a better fit for the available data. This can involve ordinary descriptive statistics of model outputs, which can benefit from functional design techniques.</p></li>&#13;
</ul>&#13;
<p>One goal of EDA is often to create a model that can be deployed as a decision support application. In many cases, a model might be a simple function. A functional programming approach can apply the model to new data and display results for human consumption. <span id="x1-25007r25"/></p>&#13;
</section>&#13;
<section id="summary" class="level3 sectionHead" data-number="0.5.5">&#13;
<h3 class="sectionHead" data-number="0.5.5"><span class="titlemark">1.5 </span> <span id="x1-260005"/>Summary</h3>&#13;
<p>In this chapter, we’ve looked at programming paradigms with an eye toward distinguishing the functional paradigm from the imperative paradigm. For our purposes, object-oriented programming is a kind of imperative programming; it relies on explicit state changes. Our objective in this book is to explore the functional programming features of Python. We’ve noted that some parts of Python don’t allow purely functional programming; we’ll be using some hybrid techniques that meld the good features of succinct, expressive functional programming with some high-performance optimizations in Python.</p>&#13;
<p>In the next chapter, we’ll look at five specific functional programming techniques in detail. These techniques will form the essential foundation for our hybridized functional programming in Python. <span id="x1-26001r26"/></p>&#13;
</section>&#13;
<section id="exercises" class="level3 sectionHead" data-number="0.5.6">&#13;
<h3 class="sectionHead" data-number="0.5.6"><span class="titlemark">1.6 </span> <span id="x1-270006"/>Exercises</h3>&#13;
<p>The exercises in this book are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader will need to replace the book’s example function name with their own solution to confirm that it works. <span id="x1-27001r23"/></p>&#13;
<section id="convert-an-imperative-algorithm-to-functional-code" class="level4 subsectionHead" data-number="0.5.6.1">&#13;
<h4 class="subsectionHead" data-number="0.5.6.1"><span class="titlemark">1.6.1 </span> <span id="x1-280001"/>Convert an imperative algorithm to functional code</h4>&#13;
<p>The following algorithm is stated as imperative assignment statements and a while construct to indicate processing something iteratively.</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_1.1.JPG" class="frac" data-align="middle" alt="Algorithm 1: Imperative iteration "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 1: </span><span class="content">Imperative iteration </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
<p>What does this appear to compute? Given Python built-in functions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum</code></span></span>, can this be simplified?</p>&#13;
<p>It helps to write this in Python and refactor the code to be sure that correct answers are created.</p>&#13;
<p>A test case is the following:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file10.jpg" class="math-display" alt="V ← {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73} "/>&#13;
</div>&#13;
<p>The computed value for <span class="italic">m </span>is approximately <span class="obeylines-h"><span class="verb"><code class="inlineCode">7.5</code></span></span>. <span id="x1-28003r28"/></p>&#13;
</section>&#13;
<section id="convert-step-wise-computation-to-functional-code" class="level4 subsectionHead" data-number="0.5.6.2">&#13;
<h4 class="subsectionHead" data-number="0.5.6.2"><span class="titlemark">1.6.2 </span> <span id="x1-290002"/>Convert step-wise computation to functional code</h4>&#13;
<p>The following algorithm is stated as a long series of single assignment statements. The rad(<span class="italic">x</span>) function converts degrees to radians, rad(<span class="italic">d</span>) = <span class="italic">π </span><span class="cmsy-10x-x-109">×</span><img src="../Images/file11.jpg" class="frac" data-align="middle" alt="1d80"/>. See the <span class="obeylines-h"><span class="verb"><code class="inlineCode">math</code></span></span> module for an implementation.</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_1.2.JPG" class="frac" data-align="middle" alt="Algorithm 2: Imperative computation "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 2: </span><span class="content">Imperative computation </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
<p>Is this code easy to understand? Can you summarize this computation as a short mathematical-looking formula?</p>&#13;
<p>Breaking it down into sections, lines 1 to 8 seem to be focused on some conversions, differences, and mid-point computations. Lines 9 to 12 compute two values, <span class="italic">x </span>and <span class="italic">y</span>. Can these be summarized or simplified? The final four lines do a relatively direct computation of <span class="italic">d</span>. Can this be summarized or simplified? As a hint, look at <span class="obeylines-h"><span class="verb"><code class="inlineCode">math.hypot()</code></span></span> for a function that might be applicable in this case.</p>&#13;
<p>It helps to write this in Python and refactor the code.</p>&#13;
<p>A test case is the following:</p>&#13;
<div class="algorithmic">&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lat</span><sub><span class="cmr-8">1</span></sub> <span class="cmsy-10x-x-109">← </span>32<span class="italic">.</span>82950 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lon</span><sub><span class="cmr-8">1</span></sub> <span class="cmsy-10x-x-109">←−</span>79<span class="italic">.</span>93021 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lat</span><sub><span class="cmr-8">2</span></sub> <span class="cmsy-10x-x-109">← </span>32<span class="italic">.</span>74412 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lon</span><sub><span class="cmr-8">2</span></sub> <span class="cmsy-10x-x-109">←−</span>79<span class="italic">.</span>85226</span>&#13;
</div>&#13;
<p>The computed value for <span class="italic">d </span>is approximately <span class="obeylines-h"><span class="verb"><code class="inlineCode">6.4577</code></span></span>.</p>&#13;
<p>Refactoring the code can help to confirm your understanding. <span id="x1-29003r30"/></p>&#13;
</section>&#13;
<section id="revise-the-sqrt-function" class="level4 subsectionHead" data-number="0.5.6.3">&#13;
<h4 class="subsectionHead" data-number="0.5.6.3"><span class="titlemark">1.6.3 </span> <span id="x1-300003"/>Revise the sqrt() function</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt()</code></span></span> function defined in the <span class="cmti-10x-x-109">A classic example of functional programming</span> section has only a single parameter value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>. Rewrite this to create a more advanced version using default parameter values to make changes possible. An expression such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">sqrt(1.0,</code><code class="inlineCode"> 0.000_01,</code><code class="inlineCode"> 3)</code></span></span> will start with an approximation of 1.0 and compute the value to a precision of 0.00001. The final parameter value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">3</code></span></span>, is the value of <span class="italic">n</span>, the number we need to compute the square root of. <span id="x1-30001r32"/></p>&#13;
</section>&#13;
<section id="data-cleansing-steps" class="level4 subsectionHead" data-number="0.5.6.4">&#13;
<h4 class="subsectionHead" data-number="0.5.6.4"><span class="titlemark">1.6.4 </span> <span id="x1-310004"/>Data cleansing steps</h4>&#13;
<p>A file of source data has US ZIP codes in a variety of formats. This problem often arises when spreadsheet software is used to collect or transform data.</p>&#13;
<ul>&#13;
<li><p>Some ZIP codes were processed as numbers. This doesn’t work out well for places in New England, where ZIP codes have a leading zero. For example, one of Portsmouth, New Hampshire’s codes should be stated as <span class="obeylines-h"><span class="verb"><code class="inlineCode">03801</code></span></span>. In the source file, it is <span class="obeylines-h"><span class="verb"><code class="inlineCode">3801</code></span></span>. For the most part, these numbers will have five or nine digits, but some codes in New England will be four or eight digits when a single leading zero was dropped. For Puerto Rico, there may be two leading zeroes.</p></li>&#13;
<li><p>Some ZIP codes are stored as strings, 12345<span class="cmsy-10x-x-109">−</span>0100, where a four-digit extension for a post-office box has been appended to the base five-digit code.</p></li>&#13;
</ul>&#13;
<p>A CSV-format file has only text values. However, when data in the file has been processed by a spreadsheet, problems can arise. Because a ZIP code has only digits, it can be treated as numeric data. This means the original data values will have been converted to a number, and then back to a text representation. These conversions will drop the leading zeroes. There are a number of workarounds in various spreadsheet applications to prevent this problem. If they’re not used, the data can have anomalous values that can be cleansed to restore the original representation.</p>&#13;
<p>The objective of the exercise is to compute a histogram of the most popular ZIP codes in the source data file. The data must be cleansed to have the following two ZIP formats:</p>&#13;
<ul>&#13;
<li><p>Five characters with no post-office box, for example <span class="obeylines-h"><span class="verb"><code class="inlineCode">03801</code></span></span></p></li>&#13;
<li><p>Ten characters with a hyphen, for example <span class="obeylines-h"><span class="verb"><code class="inlineCode">03899-9876</code></span></span></p></li>&#13;
</ul>&#13;
<p>The essential histogram can be done with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter</code></span></span> object as follows.</p>&#13;
<pre id="listing-14" class="lstlisting"><code>from collections import Counter &#13;
import csv &#13;
from pathlib import Path &#13;
 &#13;
DEFAULT_PATH = Path.cwd() / "address.csv" &#13;
 &#13;
def main(source_path: Path = DEFAULT_PATH) -&gt; None: &#13;
    frequency: Counter[str] = Counter() &#13;
    with source_path.open() as source: &#13;
        rdr = csv.DictReader(source) &#13;
        for row in rdr: &#13;
            if "-" in row[’ZIP’]: &#13;
                text_zip = row[’ZIP’] &#13;
                missing_zeroes = 10 - len(text_zip) &#13;
                if missing_zeroes: &#13;
                    text_zip = missing_zeroes*’0’ + text_zip &#13;
            else: &#13;
                text_zip = row[’ZIP’] &#13;
                if 5 &lt; len(row[’ZIP’]) &lt; 9: &#13;
                    missing_zeroes = 9 - len(text_zip) &#13;
                else: &#13;
                    missing_zeroes = 5 - len(text_zip) &#13;
                if missing_zeroes: &#13;
                    text_zip = missing_zeroes*’0’ + text_zip &#13;
            frequency[text_zip] += 1 &#13;
    print(frequency) &#13;
 &#13;
if __name__ == "__main__": &#13;
    main()</code></pre>&#13;
<p>This makes use of imperative processing features to read a file. The overall design, using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to process rows of a file, is an essential Pythonic feature that we can preserve.</p>&#13;
<p>On the other hand, the processing of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">text_zip</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">missing_zeroes</code></span></span> variables through a number of state changes seems like it’s a potential source for confusion.</p>&#13;
<p>This can be refactored through several rewrites:</p>&#13;
<ol>&#13;
<li><div id="x1-31031x1">&#13;
<p>Decompose the <span class="obeylines-h"><span class="verb"><code class="inlineCode">main()</code></span></span> function into two parts. A new <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_histogram()</code></span></span> function should be written to contain much of the processing detail. This function will process the opened file, and return a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> object. A suggested signature is the following:</p>&#13;
<pre id="listing-15" class="lstlisting"><code>    def zip_histogram( &#13;
            reader: csv.DictReader[str]) -&gt; Counter[str]: &#13;
        pass</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">main()</code></span></span> function is left with the responsibility to open the file, create the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv.DictReader</code></span></span> instance, evaluate <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_histogram()</code></span></span>, and print the histogram.</p>&#13;
</div></li>&#13;
<li><div id="x1-31036x2">&#13;
<p>Once the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_histogram()</code></span></span> function has been defined, the cleansing of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ZIP</code></span></span> attribute can be refactored into a separate function, with a name like <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_cleanse()</code></span></span>. Rather than setting the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">text_zip</code></span></span> variable, this function can return the cleansed result. This can be tested separately to be sure the various cases are handled gracefully.</p>&#13;
</div></li>&#13;
<li><div id="x1-31038x3">&#13;
<p>The distinction between long ZIP codes with a hyphen and without a hyphen is something that should be fixed. Once the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_cleanse()</code></span></span> works in general, add a new function to inject hyphens into ZIP codes with only digits. This should transform <span class="obeylines-h"><span class="verb"><code class="inlineCode">38011234</code></span></span> to <span class="obeylines-h"><span class="verb"><code class="inlineCode">03801-1234</code></span></span>. Note that short, five-digit ZIP codes do not need to have a hyphen added; this additional transformation only applies to nine-digit codes to make them into ten-position strings.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>The final <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_histogram()</code></span></span> function should look something like the following:</p>&#13;
<pre id="listing-16" class="lstlisting"><code>def zip_histogram( &#13;
        reader: csv.DictReader[str]) -&gt; Counter[str]: &#13;
    return Counter( &#13;
        zip_cleanse( &#13;
            row[’ZIP’] &#13;
        ) for row in reader &#13;
    )</code></pre>&#13;
<p>This provides a framework for performing a focused data cleanup in the given column. It allows us to distinguish between CSV and file processing features, and the details of how to clean up a specific column of data. <span id="x1-31046r33"/></p>&#13;
</section>&#13;
<section id="advanced-optimize-this-functional-code" class="level4 subsectionHead" data-number="0.5.6.5">&#13;
<h4 class="subsectionHead" data-number="0.5.6.5"><span class="titlemark">1.6.5 </span> <span id="x1-320005"/>(Advanced) Optimize this functional code</h4>&#13;
<p>The following algorithm is stated as a single ”step” that has been decomposed into three separate formulae. The decomposition is more a concession to the need to fit the expression into the limits of a printed page than a useful optimization. The rad(<span class="italic">x</span>) function converts degrees to radians, rad(<span class="italic">d</span>) = <span class="italic">π </span><span class="cmsy-10x-x-109">×</span><img src="../Images/file13.jpg" class="frac" data-align="middle" alt="-d- 180"/>.</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_1.3.JPG" class="left" data-align="middle" alt="Algorithm 3: Redundant expressions "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 3: </span><span class="content">Redundant expressions </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
<p>There are a number of redundant expressions, like rad(<span class="italic">lat</span><sub><span class="cmr-8">1</span></sub>) and rad(<span class="italic">lat</span><sub><span class="cmr-8">2</span></sub>). If these are assigned to local variables, can the expression be simplified?</p>&#13;
<p>The final computation of <span class="italic">d </span>does not match the conventional understanding of computing a hypotenuse, <img src="../Images/file15.jpg" class="sqrt" alt="∘ ------- x2 + y2"/>. Should the code be refactored to match the definition in <span class="obeylines-h"><span class="verb"><code class="inlineCode">math.hypot</code></span></span>?</p>&#13;
<p>It helps to start by writing this in Python and then refactoring the code.</p>&#13;
<p>A test case is the following:</p>&#13;
<div class="algorithmic">&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lat</span><sub><span class="cmr-8">1</span></sub> <span class="cmsy-10x-x-109">← </span>32<span class="italic">.</span>82950 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lon</span><sub><span class="cmr-8">1</span></sub> <span class="cmsy-10x-x-109">←−</span>79<span class="italic">.</span>93021 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lat</span><sub><span class="cmr-8">2</span></sub> <span class="cmsy-10x-x-109">← </span>32<span class="italic">.</span>74412 </span><br/>&#13;
<span class="label-5.475pt"> </span> <span class="algorithmic"> <span class="italic">lon</span><sub><span class="cmr-8">2</span></sub> <span class="cmsy-10x-x-109">←−</span>79<span class="italic">.</span>85226</span>&#13;
</div>&#13;
<p>The computed value for <span class="italic">d </span>is approximately <span class="obeylines-h"><span class="verb"><code class="inlineCode">6.4577</code></span></span>.</p>&#13;
<p>Refactoring the code can help to confirm your understanding of what this code really does.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-1" class="level3 likesectionHead" data-number="0.5.7">&#13;
<h3 class="likesectionHead" data-number="0.5.7"><span id="x1-330005"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
<p><span id="x1-33001r18"/></p>&#13;
</section>&#13;
</section></body></html>