- en: 'Chapter 6. Dictionaries: Keyed Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **dictionary** is an abstract data structure that can be described as a collection
    of keys and associated values, where each key only appears once within the collection.
    This associated relationship between the keys and values is why dictionaries are
    sometimes referred to as **associative arrays**. Dictionaries are also known as
    **maps**, or more specifically, **hash maps** for **hash table**-based dictionaries
    and **tree maps** for **search tree**-based dictionaries. The four most common
    functions associated with a dictionary are **add**, **update**, **get**, and **remove**.
    Other common operations include **contains**, **count**, **reassign**, and **set**.
    Each of these operations will be examined in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The mapped, or associative, nature of dictionaries allows for extremely efficient
    insert, search, and update operations. By specifying the key when creating, editing,
    or getting a value, most operations in a well-designed dictionary have a minimal
    **O**(*1*) cost. Perhaps, it's because of this efficiency that dictionaries are
    one of the most common data structures you will encounter in your day-to-day development
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why something described as a collection of associated
    keys and values should be referred to as a dictionary. This name is an analogy
    with a physical dictionary, where each word (key) has an associated definition
    (value). If this is still a little too abstract, consider a valet service. When
    you pull up a car to an event, you step out of your car and someone hands you
    a little ticket before driving away with your vehicle. This ticket represents
    your car, and only your car. There are no other tickets with the same identifier
    as the one you are now holding. Therefore, there is only one-way to get your car
    back is presenting this specific ticket to the valet service. Once you do so,
    someone rolls up with your vehicle, you hand them a tip, and then you drive away.
  prefs: []
  type: TYPE_NORMAL
- en: This process is a concrete example of the dictionary data structure. Each ticket
    represents a *key*, while each vehicle represents a *value* of some type. Each
    key is unique and uniquely identifies one specific value. When your code calls
    for a value, the valet service is the *collection* that uses the key to locate
    and return the value you are looking for. Tipping your development machine is
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a dictionary data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common dictionary operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study - arcade ticket totals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash table based dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search tree based dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries are so commonplace that it's no wonder that each of the languages
    we are examining supports them with concrete implementations. Here are some examples
    of initializing a dictionary, adding a few key/value pairs to the collection,
    and then removing one of those pairs from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides a concrete implementation of the dictionary data structure through
    the `Dictionary<TKey, TValue>` class. Since this class is generic, the caller
    may define the types used for both the keys and values. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example initializes a new dictionary where the keys will be `string` types,
    and the values will be `int` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides a `Dictionary<K, V>` class, but it has been recently deprecated
    in favor of any class that implements the `Map<K, V>` interface. Here, we''ll
    look at an example of the `HashMap<K, V>` class. This class extends `AbstractMap<K,
    V>` and implements the `Map<K, V>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This class is called `HashMap` because it is a concrete, hash table based implementation
    of a map. It is interesting to note that Java will not permit primitives to be
    used as either the keys or the values in a `HashMap` class, so in our preceding
    example, we are substituting String types for our values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hash tables**'
  prefs: []
  type: TYPE_NORMAL
- en: Since one of Java's dictionary implementations is called a **hash map**, this
    seems like a good time to introduce **hash tables**, which are sometimes referred
    to as hash maps. Hash tables use a **hash function** to map data to indexed positions
    in an array. Technically, a hash function is any function that can be used to
    plot data of a random size to data of a static size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In well-designed hash tables, the search, insert, and delete functions have
    an **O**(1) cost, as the complexity is independent of the number of elements the
    collection contains. In many situations, hash tables are much more efficient in
    comparison to arrays, lists, or other lookup data structures. This is the reason
    they are so frequently used to build dictionaries. This is also the reason they
    are commonly used in database indexing, caches, and as the foundation of the **set**
    data structure. We will discuss sets in more detail in [Chapter 7](part0041_split_000.html#173722-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 7. Sets: No Duplicates"), *Sets: No Duplicates*.'
  prefs: []
  type: TYPE_NORMAL
- en: In truth, hash tables are a data structure unto themselves, although they are
    most commonly used to create associative arrays. So, why then are we not examining
    the hash table data structure in more depth? In most languages, a dictionary is
    preferred over a hash table for similar applications. This is because dictionaries
    are **generically typed**, while hash tables rely on the language's root object
    type to assign values internally, such as C#'s `object` type. While hash tables
    permit virtually any object to be used as a key or value, a generically typed
    dictionary will limit the caller to assigning only objects of the declared types
    as the key or value of an element. This approach is both type-safe as well as
    more efficient because values do not need to be **boxed** and **unboxed** (cast)
    every time a value is updated or retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, do not make the mistake of assuming that a dictionary is simply
    a hash table by another name. It is true that a hash table roughly corresponds
    to some variation of `Dictionary<object, object>`, but it is a different class
    with different functionality and methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C provides immutable as well as mutable dictionary classes, `NSDictionary`
    and `NSMutableDictionary`, respectively. Since we''ll be working with a mutable
    dictionary in our example later, let''s just examine `NSDictionary` here. `NSDictionary`
    can be initialized with a literal array of *1.*..*n* key/value pairs using the
    `@{K : V, K : V}` syntax. There are also two common initializer methods. The first
    is `dictionaryWithObjectsAndKeys:`, which accepts an array of object/key pairs
    terminated by `nil`. The second is `dictionaryWithObjects:forKeys:`, which accepts
    an array of objects and a second array of keys. Similar to Java''s `HashMap`,
    Objective-C''s `NSDictionary` and `NSMutableDictionary` class clusters do not
    permit scalar data to be used as keys or values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that the `dictionaryWithObjects:forKeys:` approach is more
    verbose, making it slightly more readable. However, you must take extra care to
    ensure that your keys and values are correctly mapped to one another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries in Swift are created using the `Dictionary` class. Swift dictionaries
    are mutable when initialized as variables using `var`, but can also be created
    as immutable by initializing them as constants using `let`. Keys used in the dictionary
    can be either integers or strings. The `Dictionary` class can also accept values
    of any type, including those types normally considered primitives in other languages,
    since these are actually named types in Swift and are defined in the Swift standard
    library using structures. In either case, both your key and value types must be
    declared when the collection is initialized, and these cannot be changed later.
    Since we''ll be working with a variable, or mutable, dictionary later, we''ll
    initialize a constant immutable collection here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will examine **structures** in more detail later in [Chapter 8](part0047_split_000.html#1CQAE2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 8. Structs: Complex Types"), *Structs: Complex Types*.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all concrete implementations of the dictionary data structures expose the
    same operational methods. However, the more common operations should be available
    or made available as needed by the developer. Here are some operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**: The add operation, sometimes referred to as an insert, introduces
    a new key/value pair into the collection. Add operations have an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**get**: The get operation, sometimes called a **lookup**, returns the value
    mapped to a given key. If no value is found for the given key, some dictionaries
    will raise an *exception*. By specifying the key, get operations have an **O**(*1*)
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**update**: The update operation allows the caller to modify a value that is
    already a part of the collection. Not all dictionary implementations provide a
    defined update method, but rather support updating a value via *reference*. This
    means the object can be modified directly once it has been pulled from the dictionary
    using a get operation. By specifying the key, update operations have an **O**(*1*)
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**remove**: The remove, or *delete*, operation will remove a key/value pair
    from the collection given a valid key. Most dictionaries will gracefully ignore
    a specified key that does not exist. By specifying the key, remove operations
    have an **O**(1) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**contains**: The contains operation returns a Boolean value, identifying whether
    a given key can be found in the collection. Contains operations must iterate through
    the collection of keys in the dictionary to search for a match. Therefore, this
    operation has a worst-case cost of **O**(*n*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count**: Count, sometimes referred to as *size*, can be either a method or
    simply a property of the collection that returns the number of key/value elements
    within the dictionary. Count is typically a simple property on the collection
    and, therefore, has an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reassign**: A reassign operation allows for assigning a new value to an existing
    key. This operation is somewhat less common in many implementations as the update
    operation serves as the reassign operation. By specifying the key, reassign operations
    have an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**set**: The set operation is sometimes seen as a single replacement for both
    add and reassign operations. Set will either insert a new key/value pair if the
    key does not already exist, or it will reassign the value to the specified key.
    There is no need to support set, add, and reassign operations within the same
    implementation. As with add and update, set operations have an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: arcade ticket totals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Business problem**: an arcade manager wants to cut costs by eliminating physical
    tickets from her games. Tickets are very costly and wasteful, since they must
    be thrown away or recycled once a customer has redeemed them. She has decided
    to introduce an electronic point system that allows customers to earn points rather
    than tickets, and store the points digitally. Once she has the hardware in place
    to support the changeover, she needs a mobile app that allows her and her customers
    to efficiently track their current point totals.'
  prefs: []
  type: TYPE_NORMAL
- en: This app has several key requirements. First, it should store data for the customer
    based solely on the name they provide during check-in. Second, it must keep a
    running total of all points earned, lost, and redeemed. Third, it must be capable
    of showing the customer's points and the total number of customers in the arcade
    at any given time. Finally, it should allow for the removal of individual customer
    records or all customer records at once. Based on these requirements, the developer
    decides that a dictionary will be the most efficient way to track all customer
    points, so the core class's functionality will be based on that data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides the generic collection `Dictionary<TKey, TValue>`. This class provides
    all of the basic operations we would expect to see in a concrete dictionary implementation,
    with the added benefit of generic type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Dictionary<TKey, TValue>`, we create one private field for our class
    called `_points`. Our constructor instantiates this field, giving us the underlying
    data structure to build our `PointsDictionary` class on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateCustomerPoints(string customerName, int points)` method provides
    the core *update* functionality for our class. This method first confirms that
    the key exists in our collection. If the key does not exist, the method immediately
    returns `0`. Otherwise, we use subscript notation to both get the key and update
    the key's value. Using subscript notation once again, we finally return the updated
    value to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We keep this method private, choosing to create several additional update methods
    that are more fitting to our business requirements. These public methods, discussed
    later, will expose the update functionality to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The two `RegisterCustomer()` methods provide the *add* functionality to our
    class. In both cases, we require a customer name to act as the key. If a returning
    customer checks in with a previous balance, we want to acknowledge it so that
    our class overloads the method. Ultimately, the overloaded method calls `Dictionary<TKey,
    TValue>.Add(T)` to insert a new record into the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *get* functionality is introduced by the `GetCustomerPoints(string customerName)`
    method. In this method, we use `TryGetValue()` to safely confirm that the `customerName`
    key exists and to get the value at the same time. If the key does not exist, the
    app handles the issue gracefully and does not assign any value to `points`. The
    method then returns whatever value is currently set in `points`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we come to the public update methods, `AddCustomerPoints(string customerName,
    int points)`, `RemoveÇustomerPoints(string customerName, int points)`, and `RedeemCustomerPoints(string
    customerName, int points)`. Each of these methods calls the private `UpdateCustomerPoints(string
    customerName, int points)` method, but first it negates `points` in the case of
    the latter two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomerCheckout(string customerName)` method introduces the collection''s
    *remove* functionality. The method first records the final value for the customer
    key, and then calls `Dictionary<TKey, TValue>.Remove(T)` to delete the customer''s
    key from the collection. Finally, it returns the customer''s last point value
    to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dictionary<TKey, TValue>` interface conveniently provides the `ContainsKey()`
    method, which the `CustomerExists(string customerName)` method uses to introduce
    our class'' *contains* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Count` field on the `Dictionary<TKey, TValue>` class, `CustomersOnPremises()`
    provides the *count* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, as per our business requirements, we need a way to remove all of the
    objects from the collection. The `ClosingTime()` method uses the `Dictionary<TKey,
    TValue>.Clear()` method to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, Java supplies a `Dictionary` class, but it has been
    deprecated in favor of any class that implements `Map<K, V>` interface. The `HashMap<K,
    V>` implements the interface and provides a dictionary based on a hash table.
    As with the previous C# example, the `HashMap<K, V>` class exposes all the basic
    operations we would expect to see in a concrete implementation of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of `HashMap<K, V>` becomes the core of our Java `PointsDictionary`
    class. Again, we name the private field `_points`, while our constructor instantiates
    the collection. You may note that we are not explicitly declaring types when we
    instantiate the `_points` collection. In Java, it is not necessary to explicitly
    declare types at instantiation when we have already defined the key and value
    types at declaration. You can declare the types if you really want to, but this
    will generate a warning in the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UpdateCustomerPoints(string customerName, int points)` method provides
    the core *update* functionality for our class. This method first confirms that
    the key exists in our collection. If the key does not exist, the method immediately
    returns `0`. Otherwise, we use `put()` and `get()` to update the key''s value.
    Using `get()` once again, we finally return the updated value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The two `RegisterCustomer()` methods provide the *add* functionality to our
    class. In both cases, we require a customer name to act as the key. If a returning
    customer is checking in with a previous balance, we want to acknowledge it so
    that our class overloads the method. Ultimately, the overloaded method calls `HashMap<K,
    V>.put(E)` to insert a new record into the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *get* functionality is introduced by the `GetCustomerPoints(string customerName)`
    method. In this method, we use the `get()` method, checking that the return value
    is not null, to safely confirm that the `customerName` key exists. Using a ternary
    operator, we return `0` if it does not or the value if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we come to the public update methods, `AddCustomerPoints(String customerName,
    int points)`, `RemoveÇustomerPoints(String customerName, int points)`, and `RedeemCustomerPoints(String
    customerName, int points)`. Each of these methods calls the private `UpdateCustomerPoints(String
    customerName, int points)` method, but first it negates `points` in the case of
    the latter two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomerCheckout(String customerName)` method introduces the collection''s
    *remove* functionality. The method first records the final value for the customer
    key and then calls `HashMap<K, V>.remove(E)` to delete the customer''s key from
    the collection. Finally, it returns the customer''s last point value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HashMap<K, V>` method conveniently provides the `containsKey()` method,
    which the `CustomerExists(String customerName)` method uses to introduce our class''
    *contains* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `size()` field on the `HashMap<K, V>` class, `CustomersOnPremises()`
    provides the *count* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, per our business requirements, we need a way to remove all of the objects
    from the collection. The `ClosingTime()` method uses the `HashMap<K, V>.clear()`
    method to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Objective-C example, we will use the `NSMutableDictionary` class cluster
    to represent our collection. The `NSMutableDictionary` class cluster does not
    expose all of the basic operations we would expect to see in a concrete implementation
    of a dictionary, but those that are not readily available are very simple to replicate.
    It is important to note that Objective-C does not allow scalar values to be added
    to instances of the `NSDictionary` or `NSMutableDictionary` collections. Therefore,
    since we are trying to store integers for our values, we will have to place each
    of the `NSInteger` scalars in `NSNumber` wrappers before they can be added to
    the collection. Unfortunately, this adds some overhead to our implementation as
    all of these values must be boxed and unboxed as they are inserted or retrieved
    from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the class cluster `NSMutableDictionary`, we create an ivar for our class
    called `_points`. Our initializer instantiates this dictionary, giving us the
    underlying data structure to build our `PointsDictionary` class on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updatePoints:forCustomer:` method provides the core *update* functionality
    for our class. This method first confirms that the key exists in our collection
    by calling our `customerExists:` method. If the key does not exist, the method
    immediately returns `0`. Otherwise, the method uses `objectForKey:` to get the
    stored `NSNumber` object. From this, we immediately extract the `NSInteger` value
    by calling `integerValue` on the object. Next, the value is adjusted and updated
    in the dictionary using `setValue:forKey:`. Using `objectForKey:` once again,
    we finally return the updated value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `registerCustomer:` methods provide the *add* functionality to our class.
    In both cases, we require a customer name to act as the key. If a returning customer
    is checking in with a previous balance, we want to acknowledge it so that our
    class overloads the method in `registerCustomer:withPreviousBalance:`. Ultimately,
    the overloaded method is calls `setObject:forKey:` to insert a new key/value pair
    into the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *get* functionality is introduced by the `getCustomerPoints:` method. In
    this method, we use `objectForKey:` to get the `NSNumber` object for the passed
    key and assign it to `rawPoints`. Next, the method checks that `rawPoints` is
    not `nil` and returns `integerValue` of `rawPoints` if it is available, or 0 otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we come to the public update methods, `addPoints:toCustomer:`, `removePoints:fromCustomer:`
    and `redeemPoints:forCustomer:`. Each of these methods calls the private `updatePoints:forCustomer:`
    method, but first, it negates `points` in the case of the latter two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customerCheckout:`, method introduces the collection''s *remove* functionality.
    The method first records the final value for the customer key, and then calls
    `removeObjectForKey:` to delete the customer''s key from the collection. Finally,
    it returns the customer''s last point value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NSMutableDictionary` class cluster does not provide a mechanism for determining
    whether a key exists in the collection. A simple workaround is to just call `objectForKey:`;
    and if the returned value is `nil`, the key does not exist, and `nil` evaluates
    to `NO`. Based on this principle, therefore, our `customerExists:` method simply
    returns `objectForKey:`, allowing the return value to be evaluated as a `BOOL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `count` property on the `NSDictionary` class, `customersOnPremises`
    provides the *count* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, as per our business requirements, we need a way to remove all of the
    objects from the collection. The `closingTime` method uses the `removeAllObjects`
    method to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides the `Dictionary` class which, like Objective-C''s `NSMutableDictionary`,
    does not expose all of the operations we would expect to see in a concrete implementation
    of a dictionary data structure. Again, these missing functions are simple to replicate.
    It is worth noting the difference between the Swift dictionary''s value type and
    its Objective-C counterpart. Since primitives in Swift are wrapped in `structs`,
    we have no problem adding `Int` objects to our collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Dictionary` class, we create a private property for our class called
    `_points`. Since our property is declared and instantiated simultaneously and
    there is no other custom code requiring instantiation, we can exclude the explicit
    public initializer and rely on the default initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updatePointsForCustomer()` method provides the core *update* functionality
    for our class. This method first confirms that the key exists in our collection
    by calling our `customerExists()` method. If the key does not exist, the method
    immediately returns `0`. Otherwise, the method uses subscript notation to get
    the stored value. Next, the value is adjusted and updated in the dictionary, again
    using subscript notation. Finally, we return the updated value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `registerCustomer()` methods provide the *add* functionality to our class.
    In both cases, we require a customer name to act as the key. If a returning customer
    checks in with a previous balance, we want to acknowledge it so that our class
    overloads the method in `registerCustomerWithPreviousBalance()`. Ultimately, the
    overloaded method uses subscript notation to insert a new key/value pair into
    the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *get* functionality is introduced by the `getCustomerPoints()` method.
    In this method, we use subscript notation to get the value for our key, but then
    we confirm the return value is not `nil` before returning the value. If the value
    is not `nil`, our method returns the value; otherwise, it returns `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we come to the public update methods, `addPointsToCustomer()`, `removePointsFromCustomer()`,
    and `redeemPointsForCustomer()`. Each of these methods calls the private `updatePointsForCustomer()`
    method, but first, it negates `points` in the case of the latter two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customerCheckout()` method introduces the collection''s *remove* functionality.
    The method first records the final value for the customer key, and then calls
    `removeObjectForKey:` to delete the customer''s key from the collection. Finally,
    it returns the customer''s last point value to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `NSMutableDictionary`, `Dictionary` does not provide a mechanism
    for determining whether a key exists in the collection. Luckily, our workaround
    from Objective-C works just fine in Swift as well. Our method uses subscript notation,
    and if the returned value is `nil`, the key does not exist, and `nil` evaluates
    to `false`. Based on this principle, therefore, our `customerExists()` method
    simply returns `_points[cusrtomerName]`, allowing the return value to be evaluated
    as `Bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `count` property on the `Dictionary` class, `customersOnPremises()`
    provides the *count* functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, per our business requirements we need a way to remove all of the objects
    from the collection. The `closingTime()` method uses the `Dictionary.removeAll()`
    method to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have examined how dictionaries are used in common applications,
    we should take some time to examine how dictionaries are implemented under the
    hood. The majority of dictionaries come in two distinct flavors: hash table based
    and search tree based. Although the mechanics of the two approaches are similar,
    and they typically share many of the same methods and functionality, the inner
    workings and ideal applications for each type are very different.'
  prefs: []
  type: TYPE_NORMAL
- en: Hash table based dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common implementation of a dictionary is the **hash table based** associative
    array. When properly implemented, the hash table approach is extremely efficient
    and allows for **O**(1) complexity searches, inserts, and deletes. In each of
    the languages we are examining, the basic dictionary classes are based on hash
    tables by default. The general concept of a hash table based dictionary is that
    mapping for a specified key is stored at an index of an array, where the index
    is obtained by applying a hash function to the key. Callers then examine the same
    index of the array for the specified key and use the binding that is stored there
    to retrieve the value of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Hash table based dictionaries have one drawback, the hash function has the potential
    to create **collisions**, or it can sometimes attempt to map two keys to the same
    index. Therefore, hash table based implementations must have a mechanism in place
    to resolve these conflicts. Many **collision resolution strategies** exist, but
    the details of these are beyond the scope of this text.
  prefs: []
  type: TYPE_NORMAL
- en: Search tree based dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A less common implementation of a dictionary is the **search tree based** associative
    array. Dictionaries based on search trees are well suited to sorting keys and
    values by some criteria or property of the value, plus they can be built to work
    more efficiently with custom key or value types. Another advantage of a search
    tree based implementation is the addition of operations beyond the basic functions
    described earlier, such as the ability to find a mapping whose key is similar
    to a specified key. These advantages come at a price, however, in that, the basic
    operations in search tree based implementations have a higher cost, while the
    collections themselves are more restrictive on the types of data they can work
    with. Sorting operations relating to search tree based dictionaries will be discussed
    in more detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the dictionary, or associative
    array, data structure. You learned how to initialize dictionaries, and we examined
    the hash table data structure upon which most concrete dictionary implementations
    are based. We discussed the various common operations found in dictionaries, including
    their operational costs. Following this, we examined a case study where dictionaries
    would be very beneficial. Finally, we looked at two varying implementations of
    dictionaries, including the hash table based dictionary and the search tree based
    dictionary.
  prefs: []
  type: TYPE_NORMAL
