["```py\n>>> i = \"asdf\"\n>>> j = \"asdf\"\n>>> id(i) == id(j)\nTrue\n>>> i = 10000000000000000000000000000000\n>>> j = 10000000000000000000000000000000\n>>> id(j) == id(i) #cpython 3.5 reuses integers till 256\nFalse\n>>> i = 4\n>>> j = 4\n>>> id(i) == id(j)\nTrue\n>>> class Kls:\n...     pass\n... \n>>> k = Kls()\n>>> j = Kls()\n>>> id(k) == id(j) #always different as id gives memory address\nFalse\n```", "```py\n>>> # bad\n... print('a' + ' ' + 'simple' + ' ' + 'sentence' +  ' ' + '')\na simple sentence\n>>> #good\n... print(' '.join(['a','simple','sentence','.']))\na simple sentence .\n```", "```py\n>>> class C:\n...     def __init__(self, arg1, arg2):\n...         self.str = arg1\n...         self.lst = arg2\n... \n>>> iC = C(\"arun\",[1,2])\n>>> iC.str\n'arun'\n>>> iC.lst\n[1, 2]\n>>> iC.lst.append(4)\n>>> iC.lst\n[1, 2, 4]\n```", "```py\n>>> k = []\n>>> k.__class__\n<class 'list'>\n>>> type(k)\n<class 'list'>\n# type is instance's class\n>>> class M:\n...     def __init__(self,d):\n...         self.d = d\n...     def square(self):\n...         return self.d * self.d\n... \n>>> \n>>> class N:\n...     def __init__(self,d):\n...         self.d = d\n...     def cube(self):\n...         return self.d * self.d * self.d\n... \n>>> \n>>> m = M(4)\n>>> type(m)  #type is its class\n<class '__main__.M'>\n>>> m.square()  #square defined in class M\n16\n>>> m.__class__ = N # now type should change\n>>> m.cube()        # cube in class N\n64\n>>> type(m)\n<class '__main__.N'> # yes type is changed\n```", "```py\n>>> def func(): # a function\n...     print(\"adf\")\n... \n>>> func()\nadf\n>>> func.__call__() #implicit call method\nadf\n>>> func.__class__.__call__(func)\nadf\n>>> func.__call__\n<method-wrapper '__call__' of function object at 0x7ff7d9f24ea0>\n>>> class C: #a callable class\n...     def __call__(self):\n...         print(\"adf\")\n... \n>>> c = C()\n>>> c()\nadf\n>>> c.__call__() #implicit passing of self\nadf\n>>> c.__class__.__call__(c) #explicit passing of self\nadf\n>>> callable(lambda x:x+1)  #testing whether object is callable or not\nTrue\n>>> isinstance(lambda x:x+1, collections.Callable) #testing whether object is callable or not\nTrue\n```", "```py\n>>> class D:\n...     pass\n... \n>>> class C:\n...     def do(self,):\n...             print(\"do run\",self)\n... \n>>> def doo(obj):\n...     print(\"doo run\",obj)\n... \n>>> c = C()\n>>> d = D()\n>>> doo(c)\ndoo run <__main__.C object at 0x7fcf543625c0>\n>>> doo(d)\ndoo run <__main__.D object at 0x7fcf54362400>\n>>> # we do not need to pass object in case of C class do method\n... \n>>> c.do() #implicit pass of c object to do method\ndo run <__main__.C object at 0x7fcf543625c0>\n>>> C.doo = doo\n>>> c.doo()\ndoo run <__main__.C object at 0x7fcf543625c0>\n>>> C.doo()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: doo() missing 1 required positional argument: 'obj'\n>>> C.do()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: do() missing 1 required positional argument: 'self'\n>>> C.do(c)\ndo run <__main__.C object at 0x7fcf543625c0>\n>>> C.do(d)\ndo run <__main__.D object at 0x7fcf54362400>\n>>> c.do.__func__(d) #we called real function this way\ndo run <__main__.D object at 0x7fcf54362400>\n```", "```py\n>>> #in library\n... class PrintVals:\n...     def __init__(self, endl):\n...         self.endl = endl\n...         \n...     def print_D8(self, data):\n...         print(\"{0} {1} {2}\".format(data[0],data[1],self.endl))\n... \n>>> class PrintKVals: #from in2 library\n...     def __init__(self, knm):\n...         self.knm = knm\n...     \n...     def print_D8(self, data):\n...         print(\"{2}:{0} {1}\".format(data[0],data[1],self.knm))\n...\n>>> class CollectPrint:\n...     \n...     def __init__(self, endl):\n...         self.endl = endl\n...         self.knm = \"[k]\"\n...     \n...     print_D8 = PrintVals.print_D8\n...     print_D8K = PrintKVals.print_D8\n... \n>>> c = CollectPrint(\"}\")\n>>> c.print_D8([1,2])\n1 2 }\n>>> c.print_D8K([1,2])\n[k]:1 2\n```", "```py\n>>> class Meta(type):\n...     def __call__(*args):\n...         print(\"meta call\",args)\n... \n>>> class C(metaclass=Meta):\n...     pass\n... \n>>> \n>>> c = C()\nmeta call (<class '__main__.C'>,)\n>>> c = C.__class__.__call__(C)\nmeta call (<class '__main__.C'>,)\n```", "```py\n>>> class C:\n...     def __call__(*args):\n...         print(\"C call\",args)\n... \n>>> c = C()\n>>> c()\nC call (<__main__.C object at 0x7f5d70c2bb38>,)\n>>> c.__class__.__call__(c)\nC call (<__main__.C object at 0x7f5d70c2bb38>,)\n```", "```py\n>>> function_class = (lambda x:x).__class__\n>>> function_class\n<class 'function'>\n>>> def foo():\n...     print(\"hello world\")\n... \n>>> \n>>> def myprint(*args,**kwargs):\n...     print(\"this is my print\")\n...     print(*args,**kwargs)\n... \n>>> newfunc1 = function_class(foo.__code__, {'print':myprint})\n>>> newfunc1()\nthis is my print\nhello world\n>>> newfunc2 = function_class(compile(\"print('asdf')\",\"filename\",\"single\"),{'print':print})\n>>> newfunc2()\nasdf\n```", "```py\n>>> class Meta(type):\n...     def __call__(*args):\n...         print(\"meta call \",args)\n...         return None\n... \n>>> \n>>> class C(metaclass=Meta):\n...     def __init__(*args):\n...         print(\"C init not called\",args)\n... \n>>> c = C() #init will not get called \nmeta call  (<class '__main__.C'>,)\n>>> print(c)\nNone\n>>>\n```", "```py\n>>> class Meta(type):\n...     def __call__(*args):\n...         print(\"meta call ,class object :\",args)\n...         class_object = args[0]\n...         if '__new__' in class_object.__dict__:\n...             new_method = getattr(class_object,'__new__',None)\n...             instance = new_method(class_object)\n...         else:\n...             instance = object.__new__(class_object)\n...         if '__init__' in class_object.__dict__:\n...             init_method =  getattr(class_object,'__init__',None)\n...             init_method(instance,*args[1:])\n...         return instance\n...\n>>> class C(metaclass=Meta):\n...     def __init__(instance_object, *args):\n...         print(\"class init\",args)\n...     def __new__(*args):\n...         print(\"class new\",args)\n...         return object.__new__(*args)\n...\n>>> class D(metaclass=Meta):\n...     pass\n...\n>>> c=C(1,2)\nmeta call ,class object : (<class '__main__.C'>, 1, 2)\nclass new (<class '__main__.C'>,)\nclass init (1, 2)\n>>> d = D(1,2)\nmeta call ,class object : (<class '__main__.D'>, 1, 2)\n>>>\n```", "```py\n__build_class__(func, name, *bases, metaclass=None, **kwds) -> class\n```", "```py\n>>> function_class = (lambda x:x).__class__\n>>> M = __build_class__(function_class(\n...                         compile(\"def __init__(self,):\\n    print('adf')\",\n...                                 '<stdin>',\n...                                 'exec'),\n...                         {'print':print}\n...                         ),\n...                     'MyCls')\n>>> m = M()\nadf\n>>> print(M,m)\n<class '__main__.MyCls'> <__main__.MyCls object at 0x0088B430>\n>>>\n```", "```py\n    >>> class C:\n    ...     def __str__(self,):\n    ...             return 'Class String'\n    ...     def do(self):\n    ...             return 'Class method'\n    ... \n    >>> c = C()\n    >>> print(c)\n    Class String\n    >>> print(c.do())\n    Class method\n    >>> def strf(*args):\n    ...     return 'Instance String',args\n    ... \n    >>> def doo(*args):\n    ...     return 'Instance Method'\n    ... \n    >>> c.do = doo\n    >>> c.__str__ = strf\n    >>> print(c)\n    Class String\n    >>> print(c.do())\n    Instance Method\n    ```", "```py\n    >>> class C:\n    ...     def do(self):\n    ...             print(\"asdf\")\n    ...     def __getattribute__(self,attr):\n    ...             raise AttributeError('object has no attribute \"%s\"'%attr)\n    ... \n    >>> c = C()\n    >>> c.do()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"<stdin>\", line 5, in __getattribute__\n    AttributeError: object has no attribute \"do\"\n    >>> \n    ```", "```py\n    >>> class Desc:\n    ...     def __init__(self, i):\n    ...             self.i = i\n    ...     def __get__(self, obj, objtype):\n    ...             return self.i\n    ...     def __set__(self,obj, value):\n    ...             self.i = value\n    ...\n    >>> class C:\n    ...     attx = Desc(23)\n    ...\n    >>> c = C()\n    >>> c.attx\n    23\n    >>> c.__dict__['attx'] = 1234\n    >>> c.attx\n    23\n    >>> C.attx = 12\n    >>> c.attx\n    1234\n    ```", "```py\n    >>> class Desc:\n    ...     def __init__(self, i):\n    ...             self.i = i\n    ...     def __get__(self, obj, objtype):\n    ...             return self.i\n    ...\n    >>> class C:\n    ...     attx = Desc(23)\n    ...\n    >>> c = C()\n    >>> c.attx\n    23\n    >>> c.__dict__['attx'] = 34\n    >>> c.attx\n    34\n    ```", "```py\n    >>> class C:\n    ...     def __getattr__(self, key):\n    ...             return key+'_#'\n    ...\n    >>> c = C()\n    >>> c.asdf\n    'asdf_#'\n    ```", "```py\n>>> class C:\n...     @staticmethod\n...     def sdo(*args):\n...             print(args)\n...     @classmethod\n...     def cdo(*args):\n...             print(args)\n...     def do(*args):\n...             print(args)\n...\n>>> ic = C()\n# staticmethod called through class: no implicit argument is passed\n>>> C.sdo(1,2)\n(1, 2)\n# staticmethod called through instance:no implicit argument is passed\n>>> ic.sdo(1,2)(1, 2)\n# classmethod called through instance: first argument implicitly class\n>>> ic.cdo(1,2)\n(<class '__main__.C'>, 1, 2)\n# classmethod called through class: first argument implicitly class\n>>> C.cdo(1,2)\n(<class '__main__.C'>, 1, 2)\n# instancemethod called through instance: first argument implicitly instance\n>>> ic.do(1,2)\n(<__main__.C object at 0x00DC9E30>, 1, 2)\n#instancemethod called through class: no implicit argument, acts like static method.\n>>> C.do(1,2)\n(1, 2)\n```", "```py\nfrom functools import partial\n>>> class my_instancemethod:\n...     def __init__(self, f):\n...         # we store reference to function in instance\n...         # for future reference\n...         self.f = f\n...     def __get__(self, obj, objtype):\n...         # obj is None when called from class\n...         # objtype is always present\n...         if obj is not None:\n...             return partial(self.f,obj)\n...         else: # called from class\n...             return self.f\n...\n>>> class my_classmethod:\n...     def __init__(self, f):\n...         self.f = f\n...     def __get__(self, obj, objtype):\n...         # we pass objtype i.e class object\n...         # when called from instance or class\n...         return partial(self.f,objtype)\n...\n>>> class my_staticmethod:\n...     def __init__(self, f):\n...         self.f = f\n...     def __get__(self, obj, objtype):\n...         # we do not pass anything\n...         # for both conditions\n...         return self.f\n...\n>>> class C:\n...     @my_instancemethod\n...     def ido(*args):\n...         print(\"imethod\",args)\n...     @my_classmethod\n...     def cdo(*args):\n...         print(\"cmethod\",args)\n...     @my_staticmethod\n...     def sdo(*args):\n...         print(\"smethod\",args)\n...\n>>> c = C()\n>>> c.ido(1,2)\nimethod (<__main__.C object at 0x00D7CBD0>, 1, 2)\n>>> C.ido(1,2)\nimethod (1, 2)\n>>> c.cdo(1,2)\ncmethod (<class '__main__.C'>, 1, 2)\n>>> C.cdo(1,2)\ncmethod (<class '__main__.C'>, 1, 2)\n>>> c.sdo(1,2)\nsmethod (1, 2)\n>>> C.sdo(1,2)\nsmethod (1, 2)\n```"]