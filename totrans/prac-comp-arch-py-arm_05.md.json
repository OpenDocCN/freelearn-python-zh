["```py\n\n r = [0,0,0,0,0,0,0,0]                  #. Define a list of 8 registers and set them all to 0.\n```", "```py\n\nmem = [4,6,1,2,7,8,4,4,5]            # Create a 9-location memory. Fill with some data\nr =   [0,0,0,0,0,0,0,0]                 # Create a set of 8 registers, all initialized to 0\ninst   = 'add r[4],mem[3],mem[7]'       # inst is our solitary instruction, stored as a string\ninst1  = inst.replace(' ',',')          # Step 1: Replace any space with a comma\ninst2  = inst1.split(',')               # Step 2: Split instruction into tokens at each comma\ntoken0 = inst2[0]                       # Step 3: Get token0 via the 'add' instruction\ntoken1 = inst2[1]                       # Step 4: Get token1, register 'r[4]'\ntoken2 = inst2[2]                       # Step 5: Get token2, 'mem[3]'\ntoken3 = inst2[3]                       # Step 6: Get token3, 'mem[7]'\nvalue1 = int(token1[2])                 # Step 7: Get the register number as an integer\nvalue2 = int(token2[4])                 # Step 8: Get the first memory number as an integer\nvalue3 = int(token3[4])                 # Step 9: Get the second memory number as an integer\nif token0 == ‹add›:                     # Step 10: Test for an 'add' instruction\n  r[value1] = mem[value2] + mem[value3]# Step 11: If ADD, then add the contents of the memory\nprint('Registers: ',r)\n```", "```py\n\ninst2 = ['add', 'r[4]', 'mem[3]', 'mem[7]']\n```", "```py\n\n>>> x = 'asssfg! !   !,!!rr'\n>>> x\n'asssfg! !   !,!!rr'\n>>> y = x.split('!')\n>>> y\n['asssfg', ' ', '   ', ',', '', 'rr']\n```", "```py\n\nRegisters:  [0, 0, 0, 0, 6, 0, 0, 0]    Output from the program. The correct value is in r4\n```", "```py\n\nprog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1','CMPL r1 10', \\\n     'BNE 2','STOP']\n```", "```py\n\nLDRL r0 0           Load r0 with literal 0\nADDL r1 r1 1        Add 1 to r1 and put the result in r1\nADD  r0 r0 r1       Add r1 to r0 and put the result in r0\nCMPL r1 10          Compare the contents of r1 with literal 10\nBNE  2              Branch to instruction 2 if the last result is not 0\nSTOP                Stop\n```", "```py\n\nprog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1', \\\n      'CMPL r1 10','BNE 2','STOP']\nDefine and initialize variables (PC, registers, memory)\nwhile run == True:\n   read instruction from prog\n   point to next instruction (increment program counter)\n   split instruction into fields (opcode plus operands)\n   if   first field = op-code1 get operands and execute\n   elif first field = op-code2 get operands and execute\n   elif first field = op-code3 . . .\n   . . .\n```", "```py\n   else declare an error if no instruction matches.\n```", "```py\n\n#                                 @ Test fetch/execute cycle\n#0       LDRL r0 0                @ Load register r0 with 0 (the sum)\n#1       LDRL r1 0                @ Load register r1 with 0 (the counter)\n#2 Loop  ADDL r1 r1 1             @ REPEAT Increment counter in r1\\. Loop address = 2\n#3       ADD  r0 r0 r1            @ Add the count to the sum in r0\n#4       CMPL r1 10               @ Compare the count with 10\n#5       BNE  Loop                @ Branch back to Loop until all numbers added (BNE 2)\n#6       STOP                     @ Terminate execution\nprog=['LDRL r0 0','LDRL r1 0','ADDL r1 r1 1','ADD r0 r0 r1','CMPL r1 10', \\\n      'BNE 2','STOP']\nr = [0] * 8                       # Initialize r[0], r[1], ... r[7] and initialize to 0\nz = 0                             # Z is zero flag: if a compare result is 0, z = 1\nrun = True                        # Run flag True to execute\npc = 0                            # Pc is program counter, initially 0\nwhile run == True:                # The fetch/execute loop\n    inst = prog[pc]               # Read next instruction from memory\n    oldPC = pc                    # Save the old value of the the pc (program counter)\n    pc = pc + 1                   # Point to the next instruction\n    inst = inst.split(' ')        # Split divides the instruction into tokens (separate fields)\n    if inst[0] == 'ADD':          # Test for ADD rd,rS1,rS2 instruction\n        rd  = int(inst[1][1])     # Get dest, source 1 and source 2\n        rS1 = int(inst[2][1])\n        rS2 = int(inst[3][1])\n        r[rd] = r[rS1] + r[rS2]   # Add reg 1 and 2 sum in destination register\n    elif inst[0] == 'ADDL':       # Test for ADD literal instruction, ADDL\n        rd  = int(inst[1][1])     # If found, get destination register\n        rS1 = int(inst[2][1])     # Now get source 1 register\n        literal =  int(inst[3])   # Now get the literal\n        r[rd] = r[rS1] + literal  # Add reg 1 and literal\n    elif inst[0] == 'BNE':        # Test for branch on not zero\n        if z == 0:                # If z is 0 (last register not zero)\n           pc = int(inst[1])      # Get branch destination from operation\n    elif inst[0] == 'CMPL':       # Test register for equality with a literal\n        z = 0                     # Set z flag to 0 (assume not equal)\n        rVal = r[int(inst[1][1])] # Register value\n        intVal = int(inst[2])     # Literal value\n        if rVal == intVal: z = 1  # If reg value =s literal, z=1\n    elif inst[0] == 'LDRL':       # Test for load literal into register operation\n        rd = int(inst[1][1])      # Get destination register\n        data = int(inst[2])       # Test literal value\n        r[rd] = data              # Store literal in destination register\n    elif inst[0] == 'STOP':       # Test for STOP instruction\n        run = False               # If STOP found, then set run flag to False\n        print('End of program reached')\n    else:                         # If we end up here, not a valid instruction\n        run = False               # So set run flag to False and stop\n        print('Error: illegal instruction ',inst)\n    print('PC = ',oldPC,'r0 = ',r[0],'r1 = ',r[1],'z = ',z)  # Print results\n                                  # Repeat loop until Run = False\n```", "```py\n\ninst =  ['ADDL', 'r1', 'r2', '3'] # An instruction converted into a list of substrings\n```", "```py\n\nrS1 = int(rS1[1])              # get second character of the rS1 string and convert it into an integer\n```", "```py\n\nrS1 = int(inst[2][1])        # inst[2][1], which gets character 1 of substring 2.\n```", "```py\n\nr[rD] = mem[r[rS1]+lit]\n```", "```py\n\nLDRI  r1,[r2,0]    @ Get the element pointed at by r2\\. Here the offset is 0\nINC   r2           @ Increment r2 to point to the next element\n```", "```py\n\nx = y + 0b111      # Addition using a binary integer\n```", "```py\nx = y + 15         # Addition using a decimal integer\n```", "```py\n\nx = 0b1110110\nx = x << 2\n```", "```py\n\nx = 0b11101101 & 0b00001111\n```", "```py\n\n0x1234 = 0b0001001000110100\n0xA0C2 = 0b1010000011000010\n0xFFFF = 0b1111111111111111\n```", "```py\n\nx = 0b0011100101010011   # A 16-bit binary string we are going to process\ny = (x >> 8) & 0xF       # Shift x right 8 places and mask it to 4 bits\nprint('y is ',bin(y))    # Print the result in binary form using bin()\n```", "```py\n\nx = 0xF009       # Set up 16-bit number       1111000000001001\ny = x << 2       # Shift left twice to get      111100000000100100 = 0x3C024 (18 bits)\ny = y & 0xFFFF   # Constrain to 16 bits to get     1100000000100100 = 0xC024\n```", "```py\n\n()                          Parentheses               Highest precedence\n~                           Negation\n*,/, %                      Multiplication, division, modulus\n+,-                         Addition, subtraction\n<<, >>                      Bitwise shift left, right\n&                           Logical (bitwise) AND\n^                           Logical (bitwise) XOR\n|                           Logical (bitwise) OR\n<, <+, >, >+, <>, !=, ==    Boolean comparisons         Lowest precedence\n```", "```py\n\nbinOp = binCode >> 25             # Extract the 7-bit opcode binOp by shifting 25 bits right\nrD    = binCode >> 22 & 0b111     # Extract the destination register as rD. 0b111 is a mask\nrS1   = binCode >> 19 & 0b111     # Extract source register 1 as rS1\nrS2   = binCode >> 16 & 0b111     # Extract the source register 2 as rS2\nlit   = binCode & 0xFFFF          # Extract the low-order 16 bits (the literal) as lit\nop0 = r[rD]                       # Read contents of destination register operand 0 as op0\nop1 = r[rS1]                      # Read contents of source 1 register as op1\nop2 = r[rS2]                      # Read contents of source 2 register as op2\n```", "```py\n00000000000000000000001000000001   (after shifting 22 places right).\n```", "```py\n\n00000000000000000000001000000001      (after shifting 22 places right)\n00000000000000000000000000000111      (the three-bit mask)\n00000000000000000000000000000001      (The result; the 1 in bit position 9 has been removed)\n```", "```py\n\nop0 = r[rD]    # Operand 0 is the contents of the destination register\nop1 = r[rS1]   # Operand 1 is the contents of source register 1\nop2 = r[rS2]   # Operand 2 is the contents of source register 2\n```", "```py\n\nif   opCode == 0b0100010: r[rD] = lit               # Load register with literal\nelif opCode == 0b0100001: r[rD] = mem[lit]          # Load register from memory\nelif opCode == 0b0100011: r[rD] = mem[op1 + lit]    # Load register indirect\nelif opCode == 0b0100100: mem[lit] = r[rD]          # Store register in memory\n```", "```py\n\n01 00010 110 000 000 0000000011000001,\n```", "```py\n\nelif opCode==0b1000000: reg[dest]=alu(1,reg[src1],reg[src2]) # Add register to register\nelif opCode==0b1000001: reg[dest]=alu(1,reg[src1],literal)   # Add literal to register\nelif opCode==0b1000010: reg[dest]=alu(2,reg[src1],reg[src2]) # Subtract register from register\nelif opCode==0b1000011: reg[dest]=alu(2,reg[src1],literal)   # Subtract literal from register\n```", "```py\n\n +0101                               +5 + -5 = 0\n +1011\n 10000 Z = 1, N = 0, C = 1, V = 0   \n                            The result is zero and the Z-bit is set. The C bit is 1, and N, V bits are clear\n +1101                               -3 + -3 = -6\n +1101\n 11010 Z = 0, N = 1, C = 1, V = 0    The result is negative, N = 1, and a carry is generated, C = 1\n +1101                               -3 + +5 = +2\n +0101\n 10010 Z = 0, N = 0, C = 1, V = 0    The result is positive and the carry bit is set\n +0101                               +5 + 6 = -5\n +0110\n  1011 Z = 0, N = 1, C = 0, V = 1\n                                 Two positive numbers are added and the result is negative. V is set\n  1010                               -6 + -4 = +7\n +1100\n 10111 Z = 0, N = 0, C = 1, V = 1\n                                 Two negative numbers are added and the result is positive. V is set\n```", "```py\n\ndef alu(f,p,q):                  # Define the alu function with the f, p, and q input parameters\n    global z,n                   # Declare flags as global\n    if f == 1: r = p + q         # If f (the operation) is 1, do an addition\n    if f == 2: r = p – q         # If f is 2, do a subtraction\n    z, n = 0, 0                  # Clear zero and negative flags\n    if r & 0xFFFF == 0: z = 1    # If the result is 0 in 16 bits, then z = 1\n    if r & 0x8000 != 0: n = 1    # If result is negative (msb = 1), then n = 1\n    return (0xFFFF & r)          # Ensure result is restricted to 16 bits\n```", "```py\n\nthis, that  = myFunction(f,g)  # Assign f to this and g to that\n```", "```py\n\n if opCode == 0b1000000: r[rD] = alu(1,r[rS1],r[rS2])\n```", "```py\n\ndef fun_1():                      # A dummy function\n    p = 3                         # p is local to fun_1 and set to 3\n    global q                      # q is global and visible everywhere\n    print('In fun_1 p =',p)       # Print p in fun_1\n    print('In fun_1 q =',q)       # Print q in fun_1\n    q = q + 1                     # q is changed in this function\n    p = p + 1                     # p is changed in this function\n    r = 5                         # set local variable r to 5\n    return()                      # You don't need a return\np = 5                             # p is defined in the body\nq = 10                            # q is defined in the body\nprint('In body: p =',p, 'q =',q ) # Print current values of p and q\nfun_1()                           # Call fun_1 and see what happens to p and q\nprint('In body after fun_1 q =',q, 'after fun_1 p = ',p)\n```", "```py\n\nIn body: p = 5 q = 10\nIn fun_1 p = 3\nIn fun_1 q = 10\nIn body after fun_1 q = 11 after fun_1 p =  5\n```", "```py\n\nglobal z,n\n```", "```py\n\n     LDRL r2,0        @ Load r2 (the sum) with 0\n     LDRL r0,5        @ Load r0 (the loop counter) with 5\n     LDRL r1,1        @ Load r1 (the register added to the sum) with 1\nLoop ADD  r2,r2,r1    @ Repeat: add r1 to r2\n     INC  r1          @ Increment r1 so that we add 1, 2, 3 … as we go round the loop\n     DEC  r0          @ Decrement the loop counter in r0\n     BNE  Loop        @ Until loop counter = 0\n     STOP             @ Program completed\n```", "```py\n\nif   opCode == 0b1100000:            pc = 0xFFFF & (pc + literal) # Branch always\nelif opCode == 0b1100001 and z == 1: pc = 0xFFFF & (pc + literal) # Branch on zero\nelif opCode == 0b1100010 and z == 0: pc = 0xFFFF & (pc + literal) # Branch on not zero\nelif opCode == 0b1100011 and n == 1: pc = 0xFFFF & (pc + literal) # Branch on minus\n```"]