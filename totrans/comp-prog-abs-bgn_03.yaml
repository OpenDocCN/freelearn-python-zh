- en: '*Chapter 2:* Introduction to Programming Languages'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to write a computer program, we need a programming language. However,
    we don't have just one or two to pick from; there are thousands of different languages
    available at our disposal. In this chapter, we will talk about what a programming
    language is, why there are so many languages available, how all of these languages
    are related, and how a computer can understand the code that we write. Toward
    the end, we will talk about the grammar of a programming language, also known
    as its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand why we have programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how programming languages evolved from one language to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how programming languages are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the difference between interpreted and compiled languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the concepts of syntax, keywords, and reserved words in a programming
    language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we have programming languages?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine code is very difficult. As we saw in the previous chapter, machine code
    is not made for us humans. It is perfect for computers, but we need something
    more comfortable to read, write, and understand.
  prefs: []
  type: TYPE_NORMAL
- en: The time it takes to write a program,  find errors and bugs in code, and update
    a program to add new features costs money. If the language we use can help us
    reduce the chance of introducing errors in code, it will reduce the costs. If
    it helps us understand the code when we read it, it will let us add new features
    faster, and so reduce costs. One goal of a programming language is that it must
    help us be efficient when we write programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is at this point that the higher-level programming languages enter the scene.
    They enable us to write our code in something that often, at least to some degree,
    resembles English. In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016),
    *Introduction to Computer Programs* we saw one attempt to do this: assembly language.
    The introduction to this language helped somewhat, but it was still not good enough.
    What we need is something closer to human language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compare it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, they both do the same thing. The first one is in assembly
    language and the second one is something that resembles a high-level language.
    Even if you have never seen code before, it is not hard to understand what this
    program is doing. It compares two text strings, `Alice` and `Bob`, and if they
    are equal, prints this result to the screen, and if not, prints **Not Equal**.
    Of course, they are not equal, so the output here is **Not Equal**.
  prefs: []
  type: TYPE_NORMAL
- en: What these two examples show is the leap that was taken to prove how easy code
    could be if we compare machine code and assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016), *Introduction
    to Computer Programs* we saw a program that was first written in machine code
    and then in assembly that printed the text **Hello, World** to the screen. What
    would that program look like in some of the high-level languages that we use today?
    Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In C, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, we would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In C#, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in JavaScript, we would observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that they all are different and that some have some extra stuff surrounding
    the part that prints the text, but this comparison makes clear that the step from
    machine code is huge.
  prefs: []
  type: TYPE_NORMAL
- en: This step clears the path for several different ways to organize and structure
    code, and since the advent of the first high-level programming languages in the
    50s, we have seen tremendous development. Right up to today, a vast amount of
    languages have been developed.
  prefs: []
  type: TYPE_NORMAL
- en: How programming languages have evolved?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between 1943 and 1945, Konrad Zuse, a German civil engineer, developed a programming
    language called Plankalkül. Even though this language was not implemented at the
    time, it held the foundations for what we now call high-level programming languages
    and was an inspiration for other languages that followed.
  prefs: []
  type: TYPE_NORMAL
- en: In late 1953, John W. Backus, an American computer scientist working at IBM,
    submitted a proposal to his superiors to develop an alternative to assembly. In
    1954, Backus and his team published the first draft specification for this language,
    and in April 1957, the first version of the FORTRAN (the all caps naming standard
    later changed to Fortran) programming language was released. At first, this language
    was met with some skepticism as it could not produce programs that ran as fast
    as the ones written in Assembly. However, the fact that programs written in this
    new language had far fewer lines and were more comfortable to write and understand
    soon outweighed the fact that it ran a bit slower than the handwritten assembly
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Fortran became a success and is still used today, even if it is only used for
    some very specialized applications, such as how to measure the performance of
    supercomputers.
  prefs: []
  type: TYPE_NORMAL
- en: Fortran was soon followed by some other programming languages that have influenced
    how we write programs today.
  prefs: []
  type: TYPE_NORMAL
- en: In 1958, a programming language called Lisp was created by John McCarty, an
    American computer scientist working at MIT. Lisp originated many concepts that
    were later adopted by other programming languages. In [*Chapter 10*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145),
    *Programming Paradigms*, we will talk about the different paradigms used in programming,
    and Lisp introduced one such paradigm called functional programming. Lisp lives
    today through several languages, often referred to as Lisp dialects. Among them,
    we find languages such as Clojure, Common Lisp, and Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: In 1958, another important language was created that has influenced several
    of the most popular languages we use today. It is called ALGOL and was developed
    by a committee of American and European computer scientists at a meeting in Zurich.
    The most important legacy of ALGOL is how we structure code into separate blocks,
    a concept widely used today.
  prefs: []
  type: TYPE_NORMAL
- en: The 1950s finally saw one more language that is worth mentioning as it is still
    in use, and that is COBOL. The idea was to create a language that was English-like
    and oriented toward business applications. The name is an abbreviation for **Common
    Business-Oriented Language**. A group of representatives from academia, computer
    users, and manufacturers developed COBOL at the University of Pennsylvania in
    1959\. One member of this group was Grace Hopper. She had earlier invented an
    English-like data processing language called FLOW-MATIC, which became an essential
    source of inspiration for COBOL. For a long time, COBOL was the number one language
    for developing business applications and is still in use today in the financial
    sector.
  prefs: []
  type: TYPE_NORMAL
- en: The modern era of programming languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These languages created the foundation and served as an inspiration for languages
    developed during the 60s and 70s. We will mention a few languages developed during
    this time as they have been essential in either introducing new concepts to programming
    or have served as an inspiration to others.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1960s, two Norwegian computer scientists, Ole-Johan Dahl and Kristen
    Nygaard, invented a language called Simula, which popularized another paradigm,
    object orientation. We will talk more about what object orientation is in [*Chapter
    10*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145), *Programming Paradigms*.
    It has inspired several modern languages that use this paradigm, such as C++,
    Java, and C# (pronounced C sharp).
  prefs: []
  type: TYPE_NORMAL
- en: Between 1969 and 1973, Dennis Ritchie and Ken Thomson at Bell Labs developed
    a programming language called C, which is still one of the most popular programming
    languages and the primary influencer for many of today's top languages. Among
    these, we find languages such as C++, Java, Go, JavaScript, Perl, PHP, Python,
    and C#. What is it that makes C so popular and influential? There are several
    answers to this. One reason is the way the code looks and the rules for how the
    code is structured. This style inspires many languages, and they reuse it with
    minor or no modifications. Another reason is that programs written in C run fast
    and for that reason, when an application requires high speed or in some other
    way needs high performance, C or some of its related languages are perfect for
    the job.
  prefs: []
  type: TYPE_NORMAL
- en: Why so many languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several reasons why someone will develop a new language. One can be
    that the person uses language but doesn't think the structure of the code is good
    enough, or they think that some things could be done more efficiently. It can
    also be that a language is developed to target a special kind of application.
    In [*Chapter 3*](B15554_03_Final_NM_ePub.xhtml#_idTextAnchor046), *Types of Applications*
    we will look at some different types of applications, and these might have some
    requirements that make one language better suited to meet them than other languages
    will.
  prefs: []
  type: TYPE_NORMAL
- en: A programming language can give a programmer direct access to computer hardware.
    This means that it will let the programmer have more control over how data will
    be represented and stored in the computer's memory. The benefit of this is that
    programs written in this sort of language have the potential of being more efficient
    or running faster. However, this comes at the cost of complexity. When more control
    is given to the programmer, we also give the programmer more chances to make errors.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages give us less control but are easier to use. The disadvantage
    here is that programs written in these languages tend to run slower.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to write a high-end game where we want the best possible
    graphics, the best sound, advanced computer AI, and multiplayer capabilities,
    we will need to do our best to get as much performance as possible out of the
    computer hardware. We will then select a language that will give us as much control
    as possible as we want to fine-tune all aspects of our program to their optimum
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead write some administrative software, the speed of the application
    will not be our focus; rather, we want a programming language that will help us
    write high-quality software with as few errors as possible. Some programming languages
    also have a structure that makes writing programs easier, which in turn reduces
    the time spent by the programmer in writing the software.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements like this can also be the motivation for creating a new programming
    language. A programming language is nothing more than a tool that we use to create
    programs, and as with all tools, we want it to be as functional for the task as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: The family tree of programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forming a family tree of how programming languages are related is not easy as
    we can argue for a while over how much they have influenced each other. It would
    also be impossible for us to draw a tree that includes all of the existing languages
    as there are so many that fitting them into even a page of this book would be
    impossible. What we can do, however, is draw a tree that includes languages that
    are either popular right now or that have influenced these languages in a significant
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The selection of languages we will use here is based on their popularity—that
    is, they are the languages that you are most likely to use. To know what languages
    are the most popular ones today, we can turn to several sources. The question
    is how to measure how popular a language is, and different sources use different
    criteria to make this selection. If we browse through several top lists online,
    we will soon discover that there are some languages that make it into all of these
    lists. So, let's start with them and see how we can build a tree from there.
  prefs: []
  type: TYPE_NORMAL
- en: The languages I will include, in no particular order, are JavaScript, Java,
    Python, PHP, C, C++, C#, and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start with one language—for example, C—and look at what languages it
    is influenced by, we will find assembly language, Fortran, and ALGOL (if we just
    focus on the ones we mentioned earlier). We can now start to draw this tree. If
    we then do the same for the other languages and see which ones have influenced
    them and which ones they have influenced, we will end up with a tree that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Family tree of some programming languages](img/B15554_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Family tree of some programming languages'
  prefs: []
  type: TYPE_NORMAL
- en: We could have lengthy discussions on whether this is an accurate representation,
    but it gives us a general idea of how languages inspire each other. Of the languages
    we have talked about, only COBOL can't directly be linked to any of these languages.
    This does not mean that COBOL is not essential, but to the languages that made
    it into this tree, COBOL has not had any significant influence.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note about this diagram is that languages that have ALGOL as
    their common ancestor are overrepresented. The reason for this is that among the
    most popular languages today, they all come from a group often referred to as
    the ALGOL family of languages. I have also taken the liberty to leave out some
    intermediate languages from some of these relationships to reduce the size of
    the tree. What we don't see in this family tree is a language that springs up
    that is totally unrelated to any existing language. What that means is that new
    languages are created as a reaction to an existing language. When creating a new
    language, we take the parts we like from one or more languages and change the
    parts we don't like.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this tree can be interesting is that if I learn one programming language,
    then learning a related language is much easier then learning one that is further
    away in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Translating code into something that the computer understands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code that a programmer writes is called source code. As we saw in [*Chapter
    1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016), *Introduction to Computer
    Programs* this code must be translated into machine code so that the computer
    can understand it. There are two main principles of how this translation is done.
    We will first explore these two concepts and look at their pros and cons before
    we look at a combination of these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to carry out this translation is by using an interpreter. An interpreter
    will look at a single line of source code, translate it into machine code, let
    the computer execute this line, and then move on to the next line of code. The
    way the interpreter works is a bit like how a simultaneous translator works with
    human languages. A simultaneous translator will, for example, work for the UN.
    In the UN, everyone is entitled to speak in their native language. A group of
    translators listens to the talk, and as they listen, they will translate it into
    another language. Delegates can then listen to the speech in real time in their
    native language through headphones, in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: A simultaneous translator will translate everything in real time](img/B15554_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: A simultaneous translator will translate everything in real time'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how compiling works.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to carry out the translation is by using a technique called compiling.
    When we compile source code into machine code, we first translate every line of
    code, and it is not until the translation of all of the lines of code has been
    done that the program is executed. We can compare this to the concept of translating
    a book. First, an author writes the book in one language. A translator will then
    translate the whole book into another language. It is not until the translation
    of all of the text in the original book is done that it will be available to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: When translating a book, a translator will translate all of the
    text before the book is published](img/B15554_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: When translating a book, a translator will translate all of the
    text before the book is published'
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will see how interpretation and compilation compare.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing interpretation and compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interpreting and compiling are two of the main techniques for translating source
    code. A programming language can use either one of these techniques, and a language
    is therefore often referred to as either an interpreted or compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look more closely at these two techniques so that we can understand them
    better before we compare them.
  prefs: []
  type: TYPE_NORMAL
- en: When translating source code written by a programmer, a specialized program
    called an interpreter can do the job. The interpreter will read the source code
    line by line and translate each line immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a diagram of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: An interpreter translates one line of source code into machine
    code](img/Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: An interpreter translates one line of source code into machine
    code'
  prefs: []
  type: TYPE_NORMAL
- en: First, the interpreter will read a line from the source code on the left. In
    this diagram, it reads the first line, called **Code line 1**. It will then translate
    this line into machine code and send it to the processor of the computer, the
    CPU, which will execute the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will then go on to the next line, shown in the following diagram, and repeat
    the process for that line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: When one line has executed, the interpreter continues with the
    next line](img/Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: When one line has executed, the interpreter continues with the
    next line'
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter will repeat this process until there are no more lines to process
    in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: A compiler will instead translate all the code in the source code document and
    store it in a file containing the machine code instructions. When we want to run
    the program, we can use this file to run it; it is at this point that the CPU
    will execute the machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: A compiler translates all of the source code and stores the resulting
    machine code in a file](img/B15554_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A compiler translates all of the source code and stores the resulting
    machine code in a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the advantages and disadvantages of these two methods of translation?
    Let''s start with interpretation and look at some of the benefits first:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a smaller program size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have the code and an interpreter, we can run it on any platform (for example,
    Windows, Linux, macOS, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreted languages tend to be more flexible for programmers to use. One example
    of this is called dynamic typing, which is something we will talk more about in
    [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with Data
    – Variables*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some disadvantages of the interpreter approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The program runs slower as it takes some time to do the translation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone who wants to run the program must have an interpreter installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user of the program has access to the source code, so if it is a commercial
    application, all the code we have written will be accessible to anyone, including
    any potential business secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a compiled solution, the advantages and disadvantages are pretty much the
    opposite of those for an interpreter. The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It runs faster as the translation is done all at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No extra program is needed to run the application—that is, the application has
    all the information it needs to run, so the user does not need to have any other
    programs installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled programming languages tend to help the programmer with things such
    as type checking to a higher degree. Type checking is something we will discuss
    in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with
    Data – Variables*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The programs tend to be larger as they need to come with instructions on how
    they will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make versions for all of the platforms that we intend the program
    to run on—that is, we need a Windows version, a macOS version, and a Linux version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time it takes to complete the translation can be long, making it harder
    to try things out as we write the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, there are pros and cons to both techniques. A programming language
    is either interpreted or compiled, with some exceptions that we will look at soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of interpreted languages are PHP, Ruby, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of compiled languages are C, C++, COBOL, ALGOL, Fortran, and Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Languages that both compile and interpret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We also have a group of languages that both compile and interpret. When they
    compile the source code, they do not directly compile it into machine code. They
    follow an intermediate step where they compile the source code into byte code.
    This byte code is then interpreted as the program executes. The benefit of doing
    this is that we get some of the advantages of both techniques. For example, this
    byte code can be distributed to anyone who wants to run the program, and then
    an interpreter will interpret the byte code into machine code for the current
    system that the program is executed on.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage that compiled languages have—and this applies to the technique
    of mixing them, too—is that if there is an error in the source code, the compiler
    will detect this because the syntax (remember that the syntax is the grammar of
    a language) has to be correct and if it is not, the compiler can't proceed and
    will stop the translation. The programmer then needs to go back and correct the
    error before the program can compile again.
  prefs: []
  type: TYPE_NORMAL
- en: Mixed technique languages share a disadvantage with interpreted languages, which
    is that programs written with them will run slower than programs written in a
    compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of mixed technique languages are Python, Java, C#, and Perl.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and the building blocks of a programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as human languages have grammar to dictate the rules of the language,
    a programming language has syntax. The syntax is the rules for how we write a
    program using a language. There is one big difference between grammar and syntax
    and that is about forgiveness for errors. If you meet someone who speaks your
    native language but makes some errors here and there, you will still be able to
    understand what that person is trying to communicate to you. That is not the case
    for the syntax of a programming language. It does not forgive at all, and you
    will need to get it spot on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Humans understand each other even if the grammar is wrong](img/B15554_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Humans understand each other even if the grammar is wrong'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, the code we write will be translated by either a compiler
    or an interpreter, and for that translation to work, the syntax must be flawless.
  prefs: []
  type: TYPE_NORMAL
- en: Each programming language has its own syntax rules, but as we saw in the family
    tree earlier, languages can be related. So, many languages share a syntax with
    only slight variations, where others have a more specialized syntax. When learning
    a new language, we must learn the syntax for that language. That is why moving
    between closely related languages is easier as they will most likely share a lot
    of their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an error in the syntax, it will be discovered during the translation,
    and here is where a compiled and an interpreted language will differ. For a compiled
    language, all the translation will be done before we can execute the program.
    If we have an error in the syntax, the compilation will stop as soon as the compiler
    discovers the mistake. We must then find the fault and correct it, then let the
    compiler try to translate the code again. It is not until our code does not have
    any syntax errors that we have something we can run completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: A compiler will not produce any output until there are no errors
    in the syntax](img/B15554_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: A compiler will not produce any output until there are no errors
    in the syntax'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different for an interpreted language as it will translate line by
    line as we run the program. This means that a syntax error can be hidden in a
    corner of the program that is rarely executed and will not be discovered until
    we eventually want to run that line of code. When this happens, the program will
    crash with an error message letting us know what problem was there with our syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: An interpreter will translate every line it encounters and'
  prefs: []
  type: TYPE_NORMAL
- en: executes it until it finds a syntax error](img/B15554_02_09.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: An interpreter will translate every line it encounters and executes
    it until it finds a syntax error'
  prefs: []
  type: TYPE_NORMAL
- en: This means that a source code document that we have written can either be syntactically
    correct or incorrect. The syntax is a set of rules defining how the source code
    will be written and structured. But that is not all. The syntax also defines other
    things, such as the words that make up the language. These are called **keywords**.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When learning a new language, we must keep track of its keywords as these words
    are reserved by the language and so we can't use them to name things in our program.
    If we use a keyword by accident for something other than its intended use, we
    will get an error. Keywords are sometimes also referred to as reserved words.
  prefs: []
  type: TYPE_NORMAL
- en: 'A language will typically have between 30 and 50 keywords. Here is a list of
    some common keywords in many languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most programming languages are case sensitive, so the use of uppercase and lowercase
    letters matters—for example, `if` is not the same thing as `If` or `IF`.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from keywords, we also have something called operators, which we can use
    to represent the actions we want to perform on data.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A programming language will also have several operators, and these are what
    we use to accomplish things such as addition and multiplication, as well as to
    compare items. The symbols that can be used are also defined as part of the language
    syntax. Here is a list of some commonly used operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Commonly used operators in programming languages](img/B15554_Table_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Commonly used operators in programming languages
  prefs: []
  type: TYPE_NORMAL
- en: Operators are so-called because they perform operations on data. As we can see
    in the preceding table, there are operators to perform arithmetic operations,
    such as addition and multiplication. Other operators are used for comparison—for
    example, to see whether two values are equal, whether one is greater than another,
    and so on. In [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working
    with Data – Variables* we will see more about what operators are typically found
    in a programming language and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Having our code in one long sequence would make it difficult to read. It would
    be like having a book with no chapters or paragraphs. To add the concept of chapters
    and paragraphs to our code, we use something called **code blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common for a language to also allow us to define blocks of code. There
    are several reasons why you would want to do that, and we will talk more about
    them in later chapters. However, for now, we can think of a block of code like
    a paragraph in standard text. The language then defines how we mark the beginning
    and end of the block. A common technique that many languages employ is using parentheses,
    also called braces or curly brackets—`{}`. Everything within these parentheses
    is considered part of the block. Other languages might have different ways to
    do the same thing, so again, when switching between languages, we must learn what
    the syntax rules are for that language.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some of the basic concepts that a programming language
    uses to define its syntax, we should make one clarification. Many concepts that
    come up in programming share names with concepts in mathematics. So, let's see
    how programming is related to mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Relations to mathematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming is closely related to mathematics as programming has borrowed many
    concepts from it. One of these concepts is the use of variables. In [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with Data – Variables*,
    we will talk about what a variable is and how it works, but they are essentially
    the same as they are in mathematics in the sense that we can use a name to represent
    a variable (a value that can change). The rules for how we can name variables
    are also part of the language syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Another concept borrowed from mathematics is functions. In mathematics, a function
    is something that takes an input value and transforms it in some way to produce
    an output. This is close to how we can describe functions in programming as well,
    but that is not all there is to functions in programming. We will talk about functions
    in [*Chapter 8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116), *Understanding
    Functions*, and then we will see that we need to think about programming functions
    in a different way than how we view their mathematical equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we must remember when approaching programming is that if we understand
    how these concepts work in mathematics, that does not mean that we can apply this
    knowledge directly to programming, even if they happen to share the same name.
    They will be related, but how things are done in programming will differ from
    how things work in math.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by talking about why machine code is so difficult
    to understand and the motivation for creating programming languages that are easier
    to use for programmers. We then saw how programming languages have evolved over
    the years, and how most of them are similar as they have influenced each other
    as they evolved.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed some different techniques—interpreting and compiling—that
    are used to translate source code into machine code. We also saw how some languages
    use a mixed technique, employing both compiling and interpreting to complete translation.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we learned about the grammar or syntax of a programming
    language and that each language has its own syntax rules. We also learned that
    there is a close relationship between mathematics and programming, and that programming
    has borrowed some ideas and concepts from mathematics but that even if they share
    the same name, they do not necessarily do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: All of this knowledge will give you a solid base to build on with what we will
    learn in the next chapter, where we will look at some of the main types of applications
    that we can develop. We will also learn about the ways in which they are related
    to each other.
  prefs: []
  type: TYPE_NORMAL
