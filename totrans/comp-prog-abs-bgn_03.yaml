- en: '*Chapter 2:* Introduction to Programming Languages'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章：* 编程语言简介'
- en: To be able to write a computer program, we need a programming language. However,
    we don't have just one or two to pick from; there are thousands of different languages
    available at our disposal. In this chapter, we will talk about what a programming
    language is, why there are so many languages available, how all of these languages
    are related, and how a computer can understand the code that we write. Toward
    the end, we will talk about the grammar of a programming language, also known
    as its syntax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够编写计算机程序，我们需要一种编程语言。然而，我们并没有只有一两种可供选择；我们有数千种不同的语言可供选择。在本章中，我们将讨论什么是编程语言，为什么有这么多语言可供选择，所有这些语言是如何相互关联的，以及计算机是如何理解我们编写的代码的。在结尾部分，我们将讨论编程语言的语法，也称为其语法。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下事情：
- en: Understand why we have programming languages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们有编程语言
- en: Understand how programming languages evolved from one language to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编程语言是如何从一种语言演变到另一种语言的
- en: Understand how programming languages are related
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编程语言是如何相互关联的
- en: Understand the difference between interpreted and compiled languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解解释型和编译型语言之间的区别
- en: Understand the concepts of syntax, keywords, and reserved words in a programming
    language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编程语言中的语法、关键字和保留字的概念
- en: Why do we have programming languages?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们有编程语言？
- en: Machine code is very difficult. As we saw in the previous chapter, machine code
    is not made for us humans. It is perfect for computers, but we need something
    more comfortable to read, write, and understand.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言非常难以理解。正如我们在上一章中看到的，汇编语言并不是为我们人类设计的。它非常适合计算机，但我们需要更易于阅读、编写和理解的东西。
- en: The time it takes to write a program,  find errors and bugs in code, and update
    a program to add new features costs money. If the language we use can help us
    reduce the chance of introducing errors in code, it will reduce the costs. If
    it helps us understand the code when we read it, it will let us add new features
    faster, and so reduce costs. One goal of a programming language is that it must
    help us be efficient when we write programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序、在代码中查找错误和缺陷以及更新程序以添加新功能所需的时间都会产生费用。如果我们使用的语言可以帮助我们减少在代码中引入错误的机会，它将降低成本。如果它帮助我们阅读代码时理解代码，它将使我们能够更快地添加新功能，从而降低成本。编程语言的一个目标就是它必须帮助我们编写程序时更有效率。
- en: 'It is at this point that the higher-level programming languages enter the scene.
    They enable us to write our code in something that often, at least to some degree,
    resembles English. In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016),
    *Introduction to Computer Programs* we saw one attempt to do this: assembly language.
    The introduction to this language helped somewhat, but it was still not good enough.
    What we need is something closer to human language.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这一点上，高级编程语言登上了舞台。它们使我们能够用一种常常至少在某种程度上类似于英语的东西来编写我们的代码。在[*第一章*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)《计算机程序简介》中，我们看到了一个尝试这样做的方法：汇编语言。这种语言的介绍有所帮助，但仍然不够好。我们需要的是更接近人类语言的东西。
- en: 'Look at the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码片段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, compare it to the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再比较以下代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Believe it or not, they both do the same thing. The first one is in assembly
    language and the second one is something that resembles a high-level language.
    Even if you have never seen code before, it is not hard to understand what this
    program is doing. It compares two text strings, `Alice` and `Bob`, and if they
    are equal, prints this result to the screen, and if not, prints **Not Equal**.
    Of course, they are not equal, so the output here is **Not Equal**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，它们都做了同样的事情。第一个是用汇编语言编写的，第二个则类似于一种高级语言。即使你以前从未见过代码，理解这个程序在做什么也不难。它比较两个文本字符串“Alice”和“Bob”，如果它们相等，则将此结果打印到屏幕上，如果不相等，则打印**不相等**。当然，它们不相等，所以这里的输出是**不相等**。
- en: What these two examples show is the leap that was taken to prove how easy code
    could be if we compare machine code and assembly code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子所展示的是，如果我们比较机器代码和汇编代码，代码可以变得多么简单。
- en: In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016), *Introduction
    to Computer Programs* we saw a program that was first written in machine code
    and then in assembly that printed the text **Hello, World** to the screen. What
    would that program look like in some of the high-level languages that we use today?
    Let's look at some examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)，*计算机程序简介*中，我们看到了一个最初用机器码编写，然后汇编的程序，该程序将文本**Hello,
    World**打印到屏幕上。那么，这个程序在我们今天使用的某些高级语言中会是什么样子？让我们看看一些例子。
- en: 'In Python, it would look as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，它看起来如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In C, it looks as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，它看起来如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In C++, we have the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们有以下内容：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Java, we would see the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们会看到以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In C#, we have the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们有以下内容：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in JavaScript, we would observe the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在JavaScript中，我们会观察到以下内容：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that they all are different and that some have some extra stuff surrounding
    the part that prints the text, but this comparison makes clear that the step from
    machine code is huge.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它们都是不同的，有些在打印文本的部分周围有一些额外的东西，但这个比较清楚地表明，从机器码到高级语言的转变是巨大的。
- en: This step clears the path for several different ways to organize and structure
    code, and since the advent of the first high-level programming languages in the
    50s, we have seen tremendous development. Right up to today, a vast amount of
    languages have been developed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步为组织代码和结构代码的几种不同方式铺平了道路，并且自从20世纪50年代出现第一种高级编程语言以来，我们已经看到了巨大的发展。直到今天，已经开发出了大量的语言。
- en: How programming languages have evolved?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语言是如何演变的？
- en: Between 1943 and 1945, Konrad Zuse, a German civil engineer, developed a programming
    language called Plankalkül. Even though this language was not implemented at the
    time, it held the foundations for what we now call high-level programming languages
    and was an inspiration for other languages that followed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在1943年至1945年之间，德国土木工程师康拉德·祖塞（Konrad Zuse）开发了一种名为Plankalkül的编程语言。尽管这种语言当时并未实现，但它为我们现在称之为高级编程语言的基础，并为后来的其他语言提供了灵感。
- en: In late 1953, John W. Backus, an American computer scientist working at IBM,
    submitted a proposal to his superiors to develop an alternative to assembly. In
    1954, Backus and his team published the first draft specification for this language,
    and in April 1957, the first version of the FORTRAN (the all caps naming standard
    later changed to Fortran) programming language was released. At first, this language
    was met with some skepticism as it could not produce programs that ran as fast
    as the ones written in Assembly. However, the fact that programs written in this
    new language had far fewer lines and were more comfortable to write and understand
    soon outweighed the fact that it ran a bit slower than the handwritten assembly
    programs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在1953年底，约翰·W·巴克斯特（John W. Backus），一位在IBM工作的美国计算机科学家，向他的上级提交了一份提案，提议开发一种替代汇编语言的方案。1954年，巴克斯特和他的团队发布了这种语言的第一个草案规范，并在1957年4月，发布了FORTRAN（后来将全大写命名标准改为Fortran）编程语言的第一版。最初，这种语言遭到了一些怀疑，因为它无法产生像汇编语言编写的程序那样运行得快的程序。然而，用这种新语言编写的程序行数远少于汇编程序，编写和理解起来更加舒适，这些优点很快就超过了它比手写汇编程序运行慢的事实。
- en: Fortran became a success and is still used today, even if it is only used for
    some very specialized applications, such as how to measure the performance of
    supercomputers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran取得了成功，并且至今仍在使用，即使它只用于一些非常专业的应用，例如如何衡量超级计算机的性能。
- en: Fortran was soon followed by some other programming languages that have influenced
    how we write programs today.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran很快就被一些其他编程语言所跟随，这些语言影响了我们今天编写程序的方式。
- en: In 1958, a programming language called Lisp was created by John McCarty, an
    American computer scientist working at MIT. Lisp originated many concepts that
    were later adopted by other programming languages. In [*Chapter 10*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145),
    *Programming Paradigms*, we will talk about the different paradigms used in programming,
    and Lisp introduced one such paradigm called functional programming. Lisp lives
    today through several languages, often referred to as Lisp dialects. Among them,
    we find languages such as Clojure, Common Lisp, and Scheme.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 1958年，由麻省理工学院（MIT）工作的美国计算机科学家约翰·麦卡锡（John McCarty）创建了一种名为Lisp的编程语言。Lisp提出了许多后来被其他编程语言采纳的概念。在[*第十章*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145)，*编程范式*中，我们将讨论编程中使用的不同范式，Lisp引入了一种称为函数式编程的范式。Lisp今天通过几种语言继续存在，通常被称为Lisp方言。其中，我们发现了一些语言，如Clojure、Common
    Lisp和Scheme。
- en: In 1958, another important language was created that has influenced several
    of the most popular languages we use today. It is called ALGOL and was developed
    by a committee of American and European computer scientists at a meeting in Zurich.
    The most important legacy of ALGOL is how we structure code into separate blocks,
    a concept widely used today.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在1958年，另一种重要的语言被创造出来，它影响了今天我们使用的几种最受欢迎的语言。它被称为ALGOL，是由美国和欧洲计算机科学家在苏黎世的一次会议上开发的一个委员会。ALGOL最重要的遗产是我们如何将代码结构化成独立的块，这是一个今天广泛使用的概念。
- en: The 1950s finally saw one more language that is worth mentioning as it is still
    in use, and that is COBOL. The idea was to create a language that was English-like
    and oriented toward business applications. The name is an abbreviation for **Common
    Business-Oriented Language**. A group of representatives from academia, computer
    users, and manufacturers developed COBOL at the University of Pennsylvania in
    1959\. One member of this group was Grace Hopper. She had earlier invented an
    English-like data processing language called FLOW-MATIC, which became an essential
    source of inspiration for COBOL. For a long time, COBOL was the number one language
    for developing business applications and is still in use today in the financial
    sector.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪50年代终于又出现了一种值得提及的语言，那就是COBOL。其想法是创建一种类似英语且面向商业应用的语言。这个名字是**通用面向商业语言**的缩写。一群来自学术界、计算机用户和制造商的代表在1959年宾夕法尼亚大学开发了COBOL。这个小组的成员之一是Grace
    Hopper。她之前发明了一种类似英语的数据处理语言，名为FLOW-MATIC，这成为COBOL不可或缺的灵感来源。长期以来，COBOL一直是开发商业应用的第一大语言，并且至今仍在金融领域使用。
- en: The modern era of programming languages
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言的现代时代
- en: These languages created the foundation and served as an inspiration for languages
    developed during the 60s and 70s. We will mention a few languages developed during
    this time as they have been essential in either introducing new concepts to programming
    or have served as an inspiration to others.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言为60年代和70年代开发的语言奠定了基础，并成为了这些语言的灵感来源。我们将提到这个时期开发的一些语言，因为它们在引入新的编程概念或为他人提供灵感方面至关重要。
- en: In the late 1960s, two Norwegian computer scientists, Ole-Johan Dahl and Kristen
    Nygaard, invented a language called Simula, which popularized another paradigm,
    object orientation. We will talk more about what object orientation is in [*Chapter
    10*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145), *Programming Paradigms*.
    It has inspired several modern languages that use this paradigm, such as C++,
    Java, and C# (pronounced C sharp).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代末，两位挪威计算机科学家Ole-Johan Dahl和Kristen Nygaard发明了一种名为Simula的语言，它普及了另一种范式，即面向对象。我们将在[*第10章*](B15554_10_Final_NM_ePub.xhtml#_idTextAnchor145)“编程范式”中更多地讨论面向对象是什么。它启发了使用这种范式的几种现代语言，如C++、Java和C#（发音为C
    sharp）。
- en: Between 1969 and 1973, Dennis Ritchie and Ken Thomson at Bell Labs developed
    a programming language called C, which is still one of the most popular programming
    languages and the primary influencer for many of today's top languages. Among
    these, we find languages such as C++, Java, Go, JavaScript, Perl, PHP, Python,
    and C#. What is it that makes C so popular and influential? There are several
    answers to this. One reason is the way the code looks and the rules for how the
    code is structured. This style inspires many languages, and they reuse it with
    minor or no modifications. Another reason is that programs written in C run fast
    and for that reason, when an application requires high speed or in some other
    way needs high performance, C or some of its related languages are perfect for
    the job.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在1969年至1973年期间，贝尔实验室的Dennis Ritchie和Ken Thomson开发了一种名为C的编程语言，它仍然是最受欢迎的编程语言之一，并且是许多当今顶级语言的主要影响者。其中，我们发现了诸如C++、Java、Go、JavaScript、Perl、PHP、Python和C#等语言。是什么让C如此受欢迎和有影响力呢？有几个答案。一个原因是代码的外观和代码结构的规则。这种风格启发了许多语言，并且它们在细微或无修改的情况下重新使用它。另一个原因是用C编写的程序运行速度快，因此，当应用程序需要高速或以某种方式需要高性能时，C或其相关语言是这项工作的完美选择。
- en: Why so many languages?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么有这么多语言？
- en: There are several reasons why someone will develop a new language. One can be
    that the person uses language but doesn't think the structure of the code is good
    enough, or they think that some things could be done more efficiently. It can
    also be that a language is developed to target a special kind of application.
    In [*Chapter 3*](B15554_03_Final_NM_ePub.xhtml#_idTextAnchor046), *Types of Applications*
    we will look at some different types of applications, and these might have some
    requirements that make one language better suited to meet them than other languages
    will.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因会导致有人开发一种新的语言。其中一个原因可能是，这个人使用语言，但认为代码的结构不够好，或者他们认为某些事情可以更高效地完成。也可能是因为开发了一种语言来针对一种特殊类型的应用。在[*第三章*](B15554_03_Final_NM_ePub.xhtml#_idTextAnchor046)
    *应用类型*中，我们将探讨一些不同的应用类型，这些类型可能有一些要求，使得一种语言比其他语言更适合满足这些要求。
- en: A programming language can give a programmer direct access to computer hardware.
    This means that it will let the programmer have more control over how data will
    be represented and stored in the computer's memory. The benefit of this is that
    programs written in this sort of language have the potential of being more efficient
    or running faster. However, this comes at the cost of complexity. When more control
    is given to the programmer, we also give the programmer more chances to make errors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程语言可以给程序员直接访问计算机硬件的能力。这意味着它将允许程序员更多地控制数据在计算机内存中的表示和存储方式。这种语言的优点是，用这种语言编写的程序有可能更高效或运行更快。然而，这也会带来复杂性。当给予程序员更多控制时，我们也给了程序员更多犯错误的机会。
- en: Some languages give us less control but are easier to use. The disadvantage
    here is that programs written in these languages tend to run slower.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言给我们较少的控制，但更容易使用。这里的缺点是，用这些语言编写的程序往往运行得更慢。
- en: For example, if we want to write a high-end game where we want the best possible
    graphics, the best sound, advanced computer AI, and multiplayer capabilities,
    we will need to do our best to get as much performance as possible out of the
    computer hardware. We will then select a language that will give us as much control
    as possible as we want to fine-tune all aspects of our program to their optimum
    configurations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想编写一个高端游戏，我们希望有最好的图形、最好的声音、先进的计算机人工智能和多玩家功能，我们将尽最大努力从计算机硬件中获得尽可能多的性能。然后我们将选择一种尽可能给我们更多控制的编程语言，因为我们希望将程序的各个方面调整到最佳配置。
- en: If we instead write some administrative software, the speed of the application
    will not be our focus; rather, we want a programming language that will help us
    write high-quality software with as few errors as possible. Some programming languages
    also have a structure that makes writing programs easier, which in turn reduces
    the time spent by the programmer in writing the software.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们相反编写一些管理软件，我们不会关注应用程序的速度；相反，我们希望有一种编程语言可以帮助我们编写尽可能少错误的、高质量的软件。一些编程语言的结构也使得编写程序更容易，这反过来又减少了程序员编写软件所花费的时间。
- en: Requirements like this can also be the motivation for creating a new programming
    language. A programming language is nothing more than a tool that we use to create
    programs, and as with all tools, we want it to be as functional for the task as
    possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的要求也可以是创建一种新编程语言的动机。编程语言不过是我们用来创建程序的工具，就像所有工具一样，我们希望它尽可能适用于任务。
- en: The family tree of programming languages
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语言的家族树
- en: Forming a family tree of how programming languages are related is not easy as
    we can argue for a while over how much they have influenced each other. It would
    also be impossible for us to draw a tree that includes all of the existing languages
    as there are so many that fitting them into even a page of this book would be
    impossible. What we can do, however, is draw a tree that includes languages that
    are either popular right now or that have influenced these languages in a significant
    way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 形成编程语言之间关系的家族树并不容易，因为我们可能会就它们相互影响多少进行一番争论。要绘制一个包括所有现有语言的树也是不可能的，因为它们的数量如此之多，即使将它们放入这本书的一页也是不可能的。然而，我们可以绘制一个包括目前流行或以显著方式影响这些语言的语言的树。
- en: The selection of languages we will use here is based on their popularity—that
    is, they are the languages that you are most likely to use. To know what languages
    are the most popular ones today, we can turn to several sources. The question
    is how to measure how popular a language is, and different sources use different
    criteria to make this selection. If we browse through several top lists online,
    we will soon discover that there are some languages that make it into all of these
    lists. So, let's start with them and see how we can build a tree from there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的语言选择是基于它们的流行度——也就是说，它们是你最有可能使用的语言。要知道今天哪些语言是最受欢迎的，我们可以转向几个来源。问题是如何衡量一种语言的流行度，不同的来源使用不同的标准来做出这个选择。如果我们浏览几个在线的顶级列表，我们很快就会发现有一些语言出现在所有这些列表中。所以，让我们从它们开始，看看我们如何从那里构建一棵树。
- en: The languages I will include, in no particular order, are JavaScript, Java,
    Python, PHP, C, C++, C#, and Ruby.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要包括的语言，不分先后顺序，有JavaScript、Java、Python、PHP、C、C++、C#和Ruby。
- en: 'If we start with one language—for example, C—and look at what languages it
    is influenced by, we will find assembly language, Fortran, and ALGOL (if we just
    focus on the ones we mentioned earlier). We can now start to draw this tree. If
    we then do the same for the other languages and see which ones have influenced
    them and which ones they have influenced, we will end up with a tree that looks
    something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一种语言开始——例如，C——并看看它影响了哪些语言，我们会发现汇编语言、Fortran和ALGOL（如果我们只关注我们之前提到的那些）。现在我们可以开始绘制这棵树。如果我们对其他语言做同样的事情，看看哪些语言影响了它们，以及它们影响了哪些语言，我们最终会得到一棵看起来像这样的树：
- en: '![Figure 2.1: Family tree of some programming languages](img/B15554_02_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：一些编程语言的家族树](img/B15554_02_01.jpg)'
- en: 'Figure 2.1: Family tree of some programming languages'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：一些编程语言的家族树
- en: We could have lengthy discussions on whether this is an accurate representation,
    but it gives us a general idea of how languages inspire each other. Of the languages
    we have talked about, only COBOL can't directly be linked to any of these languages.
    This does not mean that COBOL is not essential, but to the languages that made
    it into this tree, COBOL has not had any significant influence.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以就这是否是一个准确的表现进行长时间的讨论，但它给了我们一个关于语言如何相互启发的总体概念。在我们讨论的语言中，只有COBOL不能直接与这些语言中的任何一个直接联系起来。这并不意味着COBOL不是必要的，但对于进入这棵树的那些语言来说，COBOL并没有产生任何显著的影响。
- en: Another thing to note about this diagram is that languages that have ALGOL as
    their common ancestor are overrepresented. The reason for this is that among the
    most popular languages today, they all come from a group often referred to as
    the ALGOL family of languages. I have also taken the liberty to leave out some
    intermediate languages from some of these relationships to reduce the size of
    the tree. What we don't see in this family tree is a language that springs up
    that is totally unrelated to any existing language. What that means is that new
    languages are created as a reaction to an existing language. When creating a new
    language, we take the parts we like from one or more languages and change the
    parts we don't like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个图表的另一件事是，那些以ALGOL为共同祖先的语言被过度代表了。原因是，在当今最受欢迎的语言中，它们都来自一个常被称为ALGOL语言家族的群体。我还自由地省略了一些中间语言，以减少树的大小。在这个家族树中，我们没有看到一种完全与任何现有语言无关的新语言出现。这意味着新语言是作为对现有语言的反应而创造的。在创建一种新语言时，我们取自一种或多种语言的我们喜欢的部分，并改变我们不喜欢的部分。
- en: The reason this tree can be interesting is that if I learn one programming language,
    then learning a related language is much easier then learning one that is further
    away in the tree.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树之所以有趣，是因为如果我学习了一种编程语言，那么学习一个相关的语言要比学习树中更远的语言容易得多。
- en: Translating code into something that the computer understands
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码翻译成计算机能理解的内容
- en: The code that a programmer writes is called source code. As we saw in [*Chapter
    1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016), *Introduction to Computer
    Programs* this code must be translated into machine code so that the computer
    can understand it. There are two main principles of how this translation is done.
    We will first explore these two concepts and look at their pros and cons before
    we look at a combination of these two concepts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写的代码被称为源代码。正如我们在[*第一章*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)，“计算机程序简介”中看到的，此代码必须翻译成机器码，以便计算机能够理解它。这种翻译的主要有两个原则。在我们探讨这两个概念并查看它们的优缺点之前，我们将先看看这两种概念的结合。
- en: Interpreting
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: 'One way to carry out this translation is by using an interpreter. An interpreter
    will look at a single line of source code, translate it into machine code, let
    the computer execute this line, and then move on to the next line of code. The
    way the interpreter works is a bit like how a simultaneous translator works with
    human languages. A simultaneous translator will, for example, work for the UN.
    In the UN, everyone is entitled to speak in their native language. A group of
    translators listens to the talk, and as they listen, they will translate it into
    another language. Delegates can then listen to the speech in real time in their
    native language through headphones, in this way:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这种翻译的一种方式是使用解释器。解释器会查看一行源代码，将其翻译成机器码，让计算机执行这一行，然后继续到下一行代码。解释器的工作方式有点像同声传译员处理人类语言的方式。例如，同声传译员可能会为联合国工作。在联合国，每个人都有权用母语发言。一组翻译人员会听取讲话，在听的过程中，他们会将其翻译成另一种语言。代表们可以通过耳机实时地用母语听到演讲，方式如下：
- en: '![Figure 2.2: A simultaneous translator will translate everything in real time](img/B15554_02_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：同声传译员将所有内容实时翻译](img/B15554_02_02.jpg)'
- en: 'Figure 2.2: A simultaneous translator will translate everything in real time'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：同声传译员将所有内容实时翻译
- en: Next, let's see how compiling works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看编译是如何工作的。
- en: Compiling
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: 'Another way to carry out the translation is by using a technique called compiling.
    When we compile source code into machine code, we first translate every line of
    code, and it is not until the translation of all of the lines of code has been
    done that the program is executed. We can compare this to the concept of translating
    a book. First, an author writes the book in one language. A translator will then
    translate the whole book into another language. It is not until the translation
    of all of the text in the original book is done that it will be available to read:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这种翻译的另一种方式是使用称为编译的技术。当我们把源代码编译成机器码时，我们首先翻译每一行代码，只有在所有代码行的翻译都完成后，程序才会执行。我们可以将这比作翻译一本书的概念。首先，作者用一种语言写书。然后，翻译者会将整本书翻译成另一种语言。只有在原书中所有文本的翻译都完成后，它才会可供阅读：
- en: '![Figure 2.3: When translating a book, a translator will translate all of the
    text before the book is published](img/B15554_02_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：在翻译一本书时，翻译者会在书出版前翻译所有文本](img/B15554_02_03.jpg)'
- en: 'Figure 2.3: When translating a book, a translator will translate all of the
    text before the book is published'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：在翻译一本书时，翻译者会在书出版前翻译所有文本
- en: After this, we will see how interpretation and compilation compare.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将看到解释和编译是如何进行比较的。
- en: Comparing interpretation and compilation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较解释和编译
- en: Interpreting and compiling are two of the main techniques for translating source
    code. A programming language can use either one of these techniques, and a language
    is therefore often referred to as either an interpreted or compiled language.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解释和编译是翻译源代码的两种主要技术。一种编程语言可以使用这两种技术中的任何一种，因此一种语言通常被称为解释型语言或编译型语言。
- en: Let's look more closely at these two techniques so that we can understand them
    better before we compare them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这两种技术，以便在我们比较它们之前更好地理解它们。
- en: When translating source code written by a programmer, a specialized program
    called an interpreter can do the job. The interpreter will read the source code
    line by line and translate each line immediately.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当翻译程序员编写的源代码时，一个称为解释器的专用程序可以完成这项工作。解释器会逐行读取源代码，并立即翻译每一行。
- en: 'Let''s see a diagram of this process:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个过程的示意图：
- en: '![Figure 2.4: An interpreter translates one line of source code into machine
    code](img/Figure_2.4.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：解释器将一行源代码翻译成机器码](img/Figure_2.4.jpg)'
- en: 'Figure 2.4: An interpreter translates one line of source code into machine
    code'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：解释器将一行源代码翻译成机器码
- en: First, the interpreter will read a line from the source code on the left. In
    this diagram, it reads the first line, called **Code line 1**. It will then translate
    this line into machine code and send it to the processor of the computer, the
    CPU, which will execute the instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解释器将从左侧的源代码中读取一行。在这个图中，它读取第一行，称为**代码行1**。然后它将这一行翻译成机器码并发送到计算机的处理器，即CPU，CPU将执行指令。
- en: 'It will then go on to the next line, shown in the following diagram, and repeat
    the process for that line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将继续到下一行，如下面的图所示，并重复对该行的处理过程：
- en: '![Figure 2.5: When one line has executed, the interpreter continues with the
    next line](img/Figure_2.5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：当一行执行完毕后，解释器继续执行下一行](img/Figure_2.5.jpg)'
- en: 'Figure 2.5: When one line has executed, the interpreter continues with the
    next line'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：当一行执行完毕后，解释器继续执行下一行
- en: The interpreter will repeat this process until there are no more lines to process
    in the source code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将重复此过程，直到没有更多行需要在源代码中处理。
- en: A compiler will instead translate all the code in the source code document and
    store it in a file containing the machine code instructions. When we want to run
    the program, we can use this file to run it; it is at this point that the CPU
    will execute the machine code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将翻译源代码文档中的所有代码，并将其存储在包含机器码指令的文件中。当我们想要运行程序时，我们可以使用这个文件来运行它；此时CPU将执行机器码。
- en: 'The following diagram illustrates this process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了这个过程：
- en: '![Figure 2.6: A compiler translates all of the source code and stores the resulting
    machine code in a file](img/B15554_02_06.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：编译器将所有源代码翻译成机器码并存储在文件中](img/B15554_02_06.jpg)'
- en: 'Figure 2.6: A compiler translates all of the source code and stores the resulting
    machine code in a file'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：编译器将所有源代码翻译成机器码并存储在文件中
- en: 'What are the advantages and disadvantages of these two methods of translation?
    Let''s start with interpretation and look at some of the benefits first:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种翻译方法的优缺点是什么？让我们从解释开始，先看看一些好处：
- en: It has a smaller program size.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的程序大小更小。
- en: If we have the code and an interpreter, we can run it on any platform (for example,
    Windows, Linux, macOS, and so on).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有代码和解释器，我们可以在任何平台上运行它（例如，Windows、Linux、macOS等）。
- en: Interpreted languages tend to be more flexible for programmers to use. One example
    of this is called dynamic typing, which is something we will talk more about in
    [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with Data
    – Variables*.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释型语言通常对程序员来说更加灵活。其中一个例子是动态类型，我们将在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)，“与数据一起工作——变量”中进一步讨论。
- en: 'Some disadvantages of the interpreter approach are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器方法的一些不利之处如下：
- en: The program runs slower as it takes some time to do the translation.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序运行较慢，因为它需要一些时间来完成翻译。
- en: Anyone who wants to run the program must have an interpreter installed.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何想要运行程序的人都必须安装解释器。
- en: The user of the program has access to the source code, so if it is a commercial
    application, all the code we have written will be accessible to anyone, including
    any potential business secrets.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的用户可以访问源代码，因此如果它是一个商业应用程序，我们编写的所有代码都将对任何人可访问，包括任何潜在的商业机密。
- en: 'For a compiled solution, the advantages and disadvantages are pretty much the
    opposite of those for an interpreter. The advantages are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译型解决方案，其优缺点与解释型解决方案正好相反。优点如下：
- en: It runs faster as the translation is done all at once.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它运行得更快，因为翻译是一次性完成的。
- en: No extra program is needed to run the application—that is, the application has
    all the information it needs to run, so the user does not need to have any other
    programs installed.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序不需要额外的程序——也就是说，应用程序拥有运行所需的所有信息，因此用户不需要安装任何其他程序。
- en: Compiled programming languages tend to help the programmer with things such
    as type checking to a higher degree. Type checking is something we will discuss
    in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with
    Data – Variables*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译型编程语言往往在诸如类型检查等方面为程序员提供更高的帮助。类型检查是我们将在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)，“与数据一起工作——变量”中讨论的内容。
- en: 'The disadvantages are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不利之处如下：
- en: The programs tend to be larger as they need to come with instructions on how
    they will be executed.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序往往更大，因为它们需要包含如何执行的说明。
- en: We need to make versions for all of the platforms that we intend the program
    to run on—that is, we need a Windows version, a macOS version, and a Linux version.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为所有我们打算让程序运行的平台制作版本——也就是说，我们需要一个Windows版本、一个macOS版本和一个Linux版本。
- en: The time it takes to complete the translation can be long, making it harder
    to try things out as we write the program.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成翻译所需的时间可能很长，这使得我们在编写程序时尝试新事物变得更加困难。
- en: As we can see, there are pros and cons to both techniques. A programming language
    is either interpreted or compiled, with some exceptions that we will look at soon.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这两种技术都有优点和缺点。编程语言要么是解释的，要么是编译的，尽管有一些例外，我们很快就会看到。
- en: 'Note:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Some examples of interpreted languages are PHP, Ruby, and JavaScript.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解释语言的例子有PHP、Ruby和JavaScript。
- en: Some examples of compiled languages are C, C++, COBOL, ALGOL, Fortran, and Lisp.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译语言的例子有C、C++、COBOL、ALGOL、Fortran和Lisp。
- en: Languages that both compile and interpret
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时编译和解释的语言
- en: We also have a group of languages that both compile and interpret. When they
    compile the source code, they do not directly compile it into machine code. They
    follow an intermediate step where they compile the source code into byte code.
    This byte code is then interpreted as the program executes. The benefit of doing
    this is that we get some of the advantages of both techniques. For example, this
    byte code can be distributed to anyone who wants to run the program, and then
    an interpreter will interpret the byte code into machine code for the current
    system that the program is executed on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一组既编译又解释的语言。当它们编译源代码时，它们不会直接将其编译成机器代码。它们遵循一个中间步骤，将源代码编译成字节码。然后，在程序执行时，将这些字节码解释为程序运行的当前系统的机器代码。这样做的好处是，我们可以获得这两种技术的一些优点。例如，这种字节码可以被分发给任何想要运行程序的人，然后解释器将字节码解释为当前系统上的机器代码。
- en: Another advantage that compiled languages have—and this applies to the technique
    of mixing them, too—is that if there is an error in the source code, the compiler
    will detect this because the syntax (remember that the syntax is the grammar of
    a language) has to be correct and if it is not, the compiler can't proceed and
    will stop the translation. The programmer then needs to go back and correct the
    error before the program can compile again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言还有另一个优点——这也适用于混合技术的方法——那就是如果源代码中存在错误，编译器会检测到这一点，因为语法（记住语法是语言的语法）必须正确，如果不正确，编译器就无法继续并停止翻译。然后程序员需要回去纠正错误，程序才能再次编译。
- en: Mixed technique languages share a disadvantage with interpreted languages, which
    is that programs written with them will run slower than programs written in a
    compiled language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 混合技术语言与解释语言共享一个缺点，那就是用它们编写的程序运行速度会比用编译语言编写的程序慢。
- en: 'Note:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Some examples of mixed technique languages are Python, Java, C#, and Perl.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一些混合技术语言的例子有Python、Java、C#和Perl。
- en: Syntax and the building blocks of a programming language
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和编程语言的基本构建块
- en: 'Just as human languages have grammar to dictate the rules of the language,
    a programming language has syntax. The syntax is the rules for how we write a
    program using a language. There is one big difference between grammar and syntax
    and that is about forgiveness for errors. If you meet someone who speaks your
    native language but makes some errors here and there, you will still be able to
    understand what that person is trying to communicate to you. That is not the case
    for the syntax of a programming language. It does not forgive at all, and you
    will need to get it spot on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人类语言有语法来规定语言的规则一样，编程语言也有语法。语法是我们使用语言编写程序时的规则。语法和语法的最大区别在于对错误的宽容度。如果你遇到一个说你的母语但偶尔犯错的人，你仍然能够理解这个人试图向你传达的信息。编程语言的语法并非如此。它不会宽容任何错误，你需要做到完美无缺：
- en: '![Figure 2.7: Humans understand each other even if the grammar is wrong](img/B15554_02_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：即使语法错误，人类也能相互理解](img/B15554_02_07.jpg)'
- en: 'Figure 2.7: Humans understand each other even if the grammar is wrong'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：即使语法错误，人类也能相互理解
- en: As we discussed earlier, the code we write will be translated by either a compiler
    or an interpreter, and for that translation to work, the syntax must be flawless.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Each programming language has its own syntax rules, but as we saw in the family
    tree earlier, languages can be related. So, many languages share a syntax with
    only slight variations, where others have a more specialized syntax. When learning
    a new language, we must learn the syntax for that language. That is why moving
    between closely related languages is easier as they will most likely share a lot
    of their syntax.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an error in the syntax, it will be discovered during the translation,
    and here is where a compiled and an interpreted language will differ. For a compiled
    language, all the translation will be done before we can execute the program.
    If we have an error in the syntax, the compilation will stop as soon as the compiler
    discovers the mistake. We must then find the fault and correct it, then let the
    compiler try to translate the code again. It is not until our code does not have
    any syntax errors that we have something we can run completely:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: A compiler will not produce any output until there are no errors
    in the syntax](img/B15554_02_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: A compiler will not produce any output until there are no errors
    in the syntax'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different for an interpreted language as it will translate line by
    line as we run the program. This means that a syntax error can be hidden in a
    corner of the program that is rarely executed and will not be discovered until
    we eventually want to run that line of code. When this happens, the program will
    crash with an error message letting us know what problem was there with our syntax:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: An interpreter will translate every line it encounters and'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: executes it until it finds a syntax error](img/B15554_02_09.jpg)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: An interpreter will translate every line it encounters and executes
    it until it finds a syntax error'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: This means that a source code document that we have written can either be syntactically
    correct or incorrect. The syntax is a set of rules defining how the source code
    will be written and structured. But that is not all. The syntax also defines other
    things, such as the words that make up the language. These are called **keywords**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When learning a new language, we must keep track of its keywords as these words
    are reserved by the language and so we can't use them to name things in our program.
    If we use a keyword by accident for something other than its intended use, we
    will get an error. Keywords are sometimes also referred to as reserved words.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'A language will typically have between 30 and 50 keywords. Here is a list of
    some common keywords in many languages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`for`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most programming languages are case sensitive, so the use of uppercase and lowercase
    letters matters—for example, `if` is not the same thing as `If` or `IF`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Apart from keywords, we also have something called operators, which we can use
    to represent the actions we want to perform on data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A programming language will also have several operators, and these are what
    we use to accomplish things such as addition and multiplication, as well as to
    compare items. The symbols that can be used are also defined as part of the language
    syntax. Here is a list of some commonly used operators:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Commonly used operators in programming languages](img/B15554_Table_2.1.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Commonly used operators in programming languages
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Operators are so-called because they perform operations on data. As we can see
    in the preceding table, there are operators to perform arithmetic operations,
    such as addition and multiplication. Other operators are used for comparison—for
    example, to see whether two values are equal, whether one is greater than another,
    and so on. In [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working
    with Data – Variables* we will see more about what operators are typically found
    in a programming language and how they can be used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Having our code in one long sequence would make it difficult to read. It would
    be like having a book with no chapters or paragraphs. To add the concept of chapters
    and paragraphs to our code, we use something called **code blocks**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common for a language to also allow us to define blocks of code. There
    are several reasons why you would want to do that, and we will talk more about
    them in later chapters. However, for now, we can think of a block of code like
    a paragraph in standard text. The language then defines how we mark the beginning
    and end of the block. A common technique that many languages employ is using parentheses,
    also called braces or curly brackets—`{}`. Everything within these parentheses
    is considered part of the block. Other languages might have different ways to
    do the same thing, so again, when switching between languages, we must learn what
    the syntax rules are for that language.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some of the basic concepts that a programming language
    uses to define its syntax, we should make one clarification. Many concepts that
    come up in programming share names with concepts in mathematics. So, let's see
    how programming is related to mathematics.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Relations to mathematics
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming is closely related to mathematics as programming has borrowed many
    concepts from it. One of these concepts is the use of variables. In [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with Data – Variables*,
    we will talk about what a variable is and how it works, but they are essentially
    the same as they are in mathematics in the sense that we can use a name to represent
    a variable (a value that can change). The rules for how we can name variables
    are also part of the language syntax.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Another concept borrowed from mathematics is functions. In mathematics, a function
    is something that takes an input value and transforms it in some way to produce
    an output. This is close to how we can describe functions in programming as well,
    but that is not all there is to functions in programming. We will talk about functions
    in [*Chapter 8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116), *Understanding
    Functions*, and then we will see that we need to think about programming functions
    in a different way than how we view their mathematical equivalent.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: One thing we must remember when approaching programming is that if we understand
    how these concepts work in mathematics, that does not mean that we can apply this
    knowledge directly to programming, even if they happen to share the same name.
    They will be related, but how things are done in programming will differ from
    how things work in math.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by talking about why machine code is so difficult
    to understand and the motivation for creating programming languages that are easier
    to use for programmers. We then saw how programming languages have evolved over
    the years, and how most of them are similar as they have influenced each other
    as they evolved.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed some different techniques—interpreting and compiling—that
    are used to translate source code into machine code. We also saw how some languages
    use a mixed technique, employing both compiling and interpreting to complete translation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we learned about the grammar or syntax of a programming
    language and that each language has its own syntax rules. We also learned that
    there is a close relationship between mathematics and programming, and that programming
    has borrowed some ideas and concepts from mathematics but that even if they share
    the same name, they do not necessarily do the same thing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: All of this knowledge will give you a solid base to build on with what we will
    learn in the next chapter, where we will look at some of the main types of applications
    that we can develop. We will also learn about the ways in which they are related
    to each other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
