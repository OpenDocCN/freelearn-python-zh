- en: Chapter 5. Custom Template Filters and Tags
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：自定义模板过滤器和标签
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Following conventions for your own template filters and tags
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循你自己的模板过滤器或标签的约定
- en: Creating a template filter to show how many days have passed since a post was
    published
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以显示自文章发布以来过去了多少天
- en: Creating a template filter to extract the first media object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以提取第一个媒体对象
- en: Creating a template filter to humanize URLs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以使URL人性化
- en: Creating a template tag to include a template if it exists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以包含一个模板（如果存在）
- en: Creating a template tag to load a QuerySet in a template
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以在模板中加载QuerySet
- en: Creating a template tag to parse content as a template
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以将内容解析为模板
- en: Creating a template tag to modify request query parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以修改请求查询参数
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As you know, Django has an extensive template system with features such as template
    inheritance, filters to change the representation of values, and tags for presentational
    logic. Moreover, Django allows you to add your own template filters and tags to
    your apps. Custom filters or tags should be located in a template-tag library
    file under the `templatetags` Python package in your app. Then, your template-tag
    library can be loaded in any template with a `{% load %}` template tag. In this
    chapter, we will create several useful filters and tags that will give more control
    to template editors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Django有一个功能丰富的模板系统，具有模板继承、用于更改值表示的过滤器以及用于表现逻辑的标签等功能。此外，Django允许你向你的应用程序添加自己的模板过滤器和标签。自定义过滤器或标签应位于应用程序`templatetags`
    Python包下的模板标签库文件中。然后，你可以使用`{% load %}`模板标签在任何模板中加载你的模板标签库。在本章中，我们将创建几个有用的过滤器和标签，这将赋予模板编辑器更多的控制权。
- en: To see the template tags of this chapter in action, create a virtual environment,
    extract the code provided for this chapter there, run the development server,
    and visit `http://127.0.0.1:8000/en/` in a browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的模板标签在实际中的应用，请创建一个虚拟环境，将本章提供的代码提取到其中，运行开发服务器，并在浏览器中访问`http://127.0.0.1:8000/en/`。
- en: Following conventions for your own template filters and tags
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循你自己的模板过滤器或标签的约定
- en: Custom template filters and tags can become a total mess if you don't have persistent
    guidelines to follow. Template filters and tags should serve template editors
    as much as possible. They should be both handy and flexible. In this recipe, we
    will take a look at some conventions that should be used when enhancing the functionality
    of the Django template system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有持续遵循的指导方针，自定义模板过滤器或标签可能会变得一团糟。模板过滤器或标签应该尽可能地为模板编辑器提供服务。它们应该既方便又灵活。在本食谱中，我们将探讨一些在增强Django模板系统功能时应遵循的约定。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these conventions when extending the Django template system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展Django模板系统时，遵循以下约定：
- en: Don't create or use custom template filters or tags when the logic for the page
    fits better in the view, context processors, or model methods. When your content
    is context-specific, such as a list of objects or object-detail view, load the
    object in the view. If you need to show some content on every page, create a context
    processor. Use custom methods of the model instead of template filters when you
    need to get some properties of an object that are not related to the context of
    the template.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面的逻辑更适合视图、上下文处理器或模型方法时，不要创建或使用自定义模板过滤器或标签。当你的内容是上下文特定的，例如对象列表或对象详情视图，请在视图中加载对象。如果你需要在每个页面上显示一些内容，请创建一个上下文处理器。当你需要获取与模板上下文无关的对象属性时，使用模型的自定义方法而不是模板过滤器。
- en: Name the template-tag library with the `_tags` suffix. When your app is named
    differently than your template-tag library, you can avoid ambiguous package importing
    problems.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`_tags`后缀命名模板标签库。如果你的应用程序名称与你的模板标签库不同，你可以避免模糊的包导入问题。
- en: 'In the newly created library, separate the filters from tags, for example,
    using comments as shown the following code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的库中，将过滤器与标签分开，例如，使用以下代码中的注释进行说明：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When creating advanced custom template tags, make sure that their syntax is
    easy to remember by including the following constructs:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建高级自定义模板标签时，确保它们的语法易于记忆，包括以下结构：
- en: '`for [app_name.model_name]`: Include this construct in order to use a specific
    model'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for [app_name.model_name]`：包含此结构以使用特定的模型'
- en: '`using [template_name]`: Include this construct in order to use a template
    for the output of the template tag'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using [template_name]`：包含此结构以使用模板输出模板标签'
- en: '`limit [count]`: Include this construct in order to limit the results to a
    specific amount'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit [count]`：包含此结构以将结果限制在特定数量'
- en: '`as [context_variable]`: Include this construct in order to save the results
    to a context variable that can be reused multiple times'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as [context_variable]`：包含此结构以将结果保存到可以多次重用的上下文变量'
- en: Try to avoid multiple values that are defined positionally in the template tags,
    unless they are self-explanatory. Otherwise, this will likely confuse the template
    developers.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽量避免在模板标签中定义多个位置值，除非它们是自我解释的。否则，这可能会让模板开发者感到困惑。
- en: Make as many resolvable arguments as possible. Strings without quotes should
    be treated as context variables that need to be resolved or short words that remind
    you of the structure of the template tag components.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能多地创建可解析的参数。没有引号的单个字符串应被视为需要解析的上下文变量或提醒你模板标签组件结构的简短单词。
- en: Creating a template filter to show how many days have passed since a post was
    published
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以显示自帖子发布以来已过去多少天
- en: Not all people keep track of the date and when talking about creation or modification
    dates of cutting-edge information; for many of us, it is convenient to read the
    time difference. For example, the blog entry was posted *three days ago*, the
    news article was published *today*, and the user last logged in *yesterday*. In
    this recipe, we will create a template filter named `days_since`, which converts
    dates to humanized time differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有人都会跟踪日期，在谈论前沿信息的创建或修改日期时；对我们中的许多人来说，读取时间差更方便。例如，博客条目是三天前发布的，新闻文章是今天发布的，用户最后一次登录是昨天。在这个菜谱中，我们将创建一个名为
    `days_since` 的模板过滤器，它将日期转换为人性化的时间差。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create the `utils` app and put it under `INSTALLED_APPS` in the settings, if
    you haven't done that yet. Then, create a `templatetags` Python package in this
    app (Python packages are directories with an empty `__init__.py` file).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请创建一个 `utils` 应用程序并将其放在设置中的 `INSTALLED_APPS` 下。然后，在这个应用程序中创建一个 `templatetags`
    Python 包（Python 包是包含空 `__init__.py` 文件的目录）。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a `utility_tags.py` file with the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 `utility_tags.py` 文件：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you use this filter in a template as shown in the following code, it will
    render something similar to *yesterday* or *5 days ago*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像以下代码所示在模板中使用此过滤器，它将渲染类似 *昨天* 或 *5天前* 的内容：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can apply this filter to values of the `date` and `datetime` types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此过滤器应用于 `date` 和 `datetime` 类型的值。
- en: 'Each template-tag library has a register, where filters and tags are collected.
    Django filters are functions registered by the `@register.filter` decorator. By
    default, the filter in the template system will be named same as the function
    or other callable object. If you want, you can set a different name for the filter
    by passing the name to the decorator, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板标签库都有一个注册表，其中收集了过滤器和标签。Django 过滤器是由 `@register.filter` 装饰器注册的函数。默认情况下，模板系统中的过滤器将命名为与函数或其它可调用对象相同的名称。如果你想，你可以通过将名称传递给装饰器来为过滤器设置不同的名称，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The filter itself is quite self-explanatory. At first, the current date is read.
    If the given value of the filter is of the `datetime` type, `date` is extracted.
    Then, the difference between today and the extracted value is calculated. Depending
    on the number of days, different string results are returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器本身相当直观。最初，读取当前日期。如果过滤器的给定值是 `datetime` 类型，则提取 `date`。然后，计算今天与提取值之间的差异。根据天数，返回不同的字符串结果。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: This filter is also easy to extend in order to show the difference in time,
    such as *just now*, *7 minutes ago*, and *3 hours ago*. Just operate on the `datetime`
    values instead of the date values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器也很容易扩展以显示时间差异，例如 *刚刚*、*7分钟前* 和 *3小时前*。只需对 `datetime` 值而不是日期值进行操作。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a template filter to extract the first media object* recipe
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个用于提取第一个媒体对象的模板过滤器* 菜谱'
- en: The *Creating a template filter to humanize URLs* recipe
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个用于人性化 URL 的模板过滤器* 菜谱'
- en: Creating a template filter to extract the first media object
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于提取第一个媒体对象的模板过滤器
- en: Imagine that you are developing a blog overview page, and for each post, you
    want to show images, music, or videos in that page taken from the content. In
    such a case, you need to extract the `<figure>`, `<img>`, `<object>`, `<embed>`,
    `<video>`, `<audio>`, and `<iframe>` tags from the HTML content of the post. In
    this recipe, we will see how to perform this using regular expressions in the
    `first_media` filter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个博客概览页面，并且对于每篇帖子，你想要在该页面上显示从内容中获取的图片、音乐或视频。在这种情况下，你需要从帖子的HTML内容中提取`<figure>`、`<img>`、`<object>`、`<embed>`、`<video>`、`<audio>`和`<iframe>`标签。在这个配方中，我们将看到如何使用正则表达式在`first_media`过滤器中执行此操作。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the `utils` app that should be set in `INSTALLED_APPS` in
    the settings and the `templatetags` package in this app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`utils`应用开始，这个应用应该在设置中的`INSTALLED_APPS`中设置，并且在这个应用中设置`templatetags`包。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the `utility_tags.py` file, add the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utility_tags.py`文件中，添加以下内容：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If the HTML content in the database is valid, when you put the following code
    in the template, it will retrieve the media tags from the content field of the
    object; otherwise, an empty string will be returned if no media is found:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中的HTML内容有效，当你将以下代码放入模板中时，它将从对象的`content`字段中检索媒体标签；如果没有找到媒体，将返回一个空字符串。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Regular expressions are powerful feature to search/replace patterns of text.
    At first, we will define the compiled regular expression as `media_file_regex`.
    In our case, we will search for all the possible media tags that can also occur
    in multiple lines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是搜索/替换文本模式的一个强大功能。首先，我们将定义编译后的正则表达式为`media_file_regex`。在我们的例子中，我们将搜索所有可能出现在多行中的媒体标签。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Python strings can be concatenated without a plus (+) symbol.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串可以不使用加号（`+`）进行连接。
- en: 'Let''s see how this regular expression works, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个正则表达式是如何工作的，如下所示：
- en: Alternating patterns are separated by the pipe (`|`) symbol.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交替模式由竖线（`|`）符号分隔。
- en: For possibly multiline tags, we will use the `[\S\s]+?` pattern that matches
    any symbol at least once; however, as little times as possible, until we find
    the the string that goes after it. Therefore, `<figure[\S\s]+?</figure>` searches
    for a `<figure>` tag and everything after it, until it finds the closing `</figure>`
    tag.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可能的多行标签，我们将使用`[\S\s]+?`模式，该模式至少匹配一次任何符号；然而，尽可能少地匹配，直到我们找到它后面的字符串。因此，`<figure[\S\s]+?</figure>`搜索一个`<figure>`标签以及它之后的所有内容，直到找到关闭的`</figure>`标签。
- en: Similarly, with the `[^>]+` pattern, we search for any symbol except the greater
    than (`>`) symbol at least once and as many times as possible.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，使用`[^>]+`模式，我们搜索至少一次且尽可能多次的任何符号，除了大于（`>`）符号。
- en: The `re.MULTILINE` flag ensures that the search will happen in multiple lines.
    Then, in the filter, we will perform a search for this regular expression pattern.
    By default, the result of the filter will show the `<`, `>`, and `&` symbols escaped
    as the `&lt;`, `&gt;`, and `&amp;` entities. However, we use the `mark_safe()`
    function that marks the result as safe and HTML-ready in order to be shown in
    the template without escaping.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.MULTILINE`标志确保搜索将在多行中发生。然后，在过滤器中，我们将对这个正则表达式模式进行搜索。默认情况下，过滤器的结果将显示为`<`、`>`和`&`符号，它们被转义为`&lt;`、`&gt;`和`&amp;`实体。然而，我们使用`mark_safe()`函数将结果标记为安全且HTML就绪，以便在模板中显示而不进行转义。'
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: If you are interested in regular expressions, you can learn more about them
    in the official Python documentation at [https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对正则表达式感兴趣，你可以在官方Python文档中了解更多信息，链接为[https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html)。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个用于显示自帖子发布以来已过去多少天的模板过滤器*配方'
- en: The *Creating a template filter to humanize URLs* recipe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个用于使URL人性化的模板过滤器*配方'
- en: Creating a template filter to humanize URLs
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于使URL人性化的模板过滤器
- en: Usually, common web users enter URLs in address fields without protocol and
    trailing slashes. In this recipe, we will create a `humanize_url` filter that
    is used to present URLs to the user in a shorter format, truncating very long
    addresses, similar to what Twitter does with the links in the tweets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，普通网络用户在地址字段中输入URL时没有协议和尾随斜杠。在这个配方中，我们将创建一个`humanize_url`过滤器，用于以更短的形式向用户展示URL，截断非常长的地址，类似于Twitter对推文中的链接所做的那样。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Similar to the previous recipes, we will start with the `utils` app that should
    be set in `INSTALLED_APPS` in the settings and contain the `templatetags` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱类似，我们将从 `utils` 应用程序开始，该应用程序应在设置中的 `INSTALLED_APPS` 中设置，并包含 `templatetags`
    包。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the `FILTERS` section of the `utility_tags.py` template library in the `utils`
    app, let''s add a `humanize_url` filter and register it, as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `utils` 应用中的 `utility_tags.py` 模板库的 `FILTERS` 部分，让我们添加一个 `humanize_url` 过滤器并将其注册，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can use the `humanize_url` filter in any template, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模板中使用 `humanize_url` 过滤器，如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The filter uses regular expressions to remove the leading protocol and trailing
    slash, shorten the URL to the given amount of letters, and add an ellipsis to
    the end if the URL doesn't fit in the specified letter count.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该过滤器使用正则表达式删除前缀协议和尾随斜杠，将 URL 缩短到指定的字母数，如果 URL 不适合指定的字母数，则在末尾添加省略号。
- en: See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以显示自帖子发布以来已过去多少天* 的食谱'
- en: The *Creating a template filter to extract the first media object* recipe
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以提取第一个媒体对象* 的食谱'
- en: The *Creating a template tag to include a template if it exists* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以包含存在的模板* 的食谱'
- en: Creating a template tag to include a template if it exists
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签以包含存在的模板
- en: Django has the `{% include %}` template tag that renders and includes another
    template. However, there is a problem in some situations, where an error is raised
    if the template does not exist. In this recipe, we will see how to create a `{%
    try_to_include %}` template tag that includes another template and fails silently
    if there is no such template.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Django 有 `{% include %}` 模板标签，它渲染并包含另一个模板。然而，在某些情况下存在一个问题，如果模板不存在，则会引发错误。在这个食谱中，我们将看到如何创建一个
    `{% try_to_include %}` 模板标签，该标签包含另一个模板，如果不存在该模板，则静默失败。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start again with the `utils` app that is installed and ready for custom
    template tags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从已安装并准备好自定义模板标签的 `utils` 应用程序开始。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Advanced custom template tags consist of two things: the function that is parsing
    the arguments of the template tag and the `Node` class that is responsible for
    the logic of the template tag as well as the output. Perform the following steps
    to create the `{% try_to_include %}` template tag:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 高级自定义模板标签由两部分组成：解析模板标签参数的函数以及负责模板标签逻辑和输出的 `Node` 类。按照以下步骤创建 `{% try_to_include
    %}` 模板标签：
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个解析模板标签参数的函数，如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need the `Node` class in the same file, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在同一个文件中的 `Node` 类，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `{% try_to_include %}` template tag expects one argument, that is, `template_name`.
    Therefore, in the `try_to_include()` function, we try to assign the split contents
    of the token only to the `tag_name` variable (which is `try_to_include`) and the
    `template_name` variable. If this doesn't work, the template syntax error is raised.
    The function returns the `IncludeNode` object, which gets the `template_name`
    field for later use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% try_to_include %}` 模板标签期望一个参数，即 `template_name`。因此，在 `try_to_include()`
    函数中，我们尝试将标记的分隔内容仅分配给 `tag_name` 变量（即 `try_to_include`）和 `template_name` 变量。如果这不起作用，则引发模板语法错误。该函数返回
    `IncludeNode` 对象，该对象获取 `template_name` 字段以供以后使用。'
- en: In the `render()` method of `IncludeNode`, we resolve the `template_name` variable.
    If a context variable was passed to the template tag, its value will be used here
    for `template_name`. If a quoted string was passed to the template tag, then the
    content in the quotes will be used for `template_name`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IncludeNode` 的 `render()` 方法中，我们解析 `template_name` 变量。如果向模板标签传递了上下文变量，则其值将在这里用于
    `template_name`。如果向模板标签传递了引号字符串，则引号内的内容将用于 `template_name`。
- en: Lastly, we will try to load the template and render it with the current template
    context. If that doesn't work, an empty string is returned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将尝试加载模板并使用当前模板上下文进行渲染。如果不起作用，则返回空字符串。
- en: 'There are at least two situations where we could use this template tag:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种情况我们可以使用这个模板标签：
- en: 'It is used when including a template whose path is defined in a model, as follows:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在模型中定义路径时包含模板，如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is used when including a template whose path is defined with the `{% with
    %}` template tag somewhere high in the template context variable''s scope. This
    is especially useful when you need to create custom layouts for plugins in the
    placeholder of a template in Django CMS:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于在模板上下文变量作用域中定义路径的模板中包含模板时。这在需要为Django CMS中的占位符创建自定义布局的插件时特别有用：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: You can use the `{% try_to_include %}` tag as well as the default `{% include
    %}` tag to include the templates that extend other templates. This is beneficial
    for large-scale portals, where you have different kinds of lists in which complex
    items share the same structure as widgets but have a different source of data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`{% try_to_include %}`标签以及默认的`{% include %}`标签来包含扩展其他模板的模板。这对于大型门户来说是有益的，在这些门户中，你有不同种类的列表，其中复杂的项目与小部件具有相同的结构，但数据来源不同。
- en: 'For example, in the artist list template, you can include the artist item template,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在艺术家列表模板中，你可以包含艺术家项目模板，如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This template will extend from the item base, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将从项目基类扩展，如下所示：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The item base defines the markup for any item and also includes a Like widget,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 项目基类定义了任何项目的标记，并包括一个Like小部件，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating templates for Django CMS* recipe in [Chapter 7](ch07.html "Chapter 7. Django
    CMS"), *Django CMS*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。Django CMS")的*为Django CMS创建模板*菜谱中，*Django CMS*
- en: The *Writing your own CMS plugin* recipe in [Chapter 7](ch07.html "Chapter 7. Django
    CMS"), *Django CMS*
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。Django CMS")的*编写自己的CMS插件*菜谱中，*Django CMS*
- en: The *Implementing the Like widget* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。模板和JavaScript")的*实现Like小部件*菜谱中，*模板和JavaScript*
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在模板中创建一个加载QuerySet的模板标签*菜谱'
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个将内容解析为模板的模板标签*菜谱'
- en: The *Creating a template tag to modify request query parameters* recipe
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个修改请求查询参数的模板标签*菜谱'
- en: Creating a template tag to load a QuerySet in a template
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中创建一个加载QuerySet的模板标签
- en: Most often, the content that should be shown on a webpage will have to be defined
    in the view. If this is the content to be shown on every page, it is logical to
    create a context processor. Another situation is where you need to show additional
    content such as the latest news or a random quote on some pages; for example,
    the starting page or the details page of an object. In this case, you can load
    the necessary content with the `{% get_objects %}` template tag, which we will
    implement in this recipe.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应该在视图中定义要在网页上显示的内容。如果这是要在每个页面上显示的内容，那么创建一个上下文处理器是合理的。另一种情况是，你需要在某些页面上显示额外的内容，例如最新新闻或随机引言；例如，对象的起始页面或详细信息页面。在这种情况下，你可以使用`{%
    get_objects %}`模板标签加载必要的内容，我们将在本菜谱中实现它。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we will start with the `utils` app that should be installed and
    ready for custom template tags.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从应该安装并准备好自定义模板标签的`utils`应用开始。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'An advanced custom template tag consists of a function that parses arguments
    that are passed to the tag and a `Node` class that renders the output of the tag
    or modifies the template context. Perform the following steps to create the `{%
    get_objects %}` template tag:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高级自定义模板标签由一个解析传递给标签的参数的函数和一个`Node`类组成，该类渲染标签的输出或修改模板上下文。执行以下步骤以创建`{% get_objects
    %}`模板标签：
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个解析模板标签参数的函数，如下所示：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we will create the `Node` class in the same file, as shown in the following
    code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在同一文件中创建`Node`类，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `{% get_objects %}` template tag loads QuerySet defined by the method of
    the manager from a specified app and model, limits the result to the specified
    amount, and saves the result to a context variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% get_objects %}`模板标签从指定的应用和模型的方法中加载定义的QuerySet，将结果限制到指定的数量，并将结果保存到上下文变量中。'
- en: 'The following code is the simplest example of how to use the template tag that
    we have just created. It will load all news articles in any template using the
    following snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用我们刚刚创建的模板标签的最简单示例。它将在任何模板中使用以下片段加载所有新闻文章：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is using the `all()` method of the default `objects` manager of the `Article`
    model and it will sort the articles by the `ordering` attribute defined in the
    `Meta` class of the model.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用`Article`模型的默认`objects`管理器的`all()`方法，并且它将根据模型`Meta`类中定义的`ordering`属性对文章进行排序。
- en: 'A more advanced example would be required to create a custom manager with a
    custom method to query the objects from the database. A manager is an interface
    that provides the database query operations to models. Each model has at least
    one manager called `objects` by default. As an example, let''s create an `Artist`
    model that has a draft or published status and a new `custom_manager` that allows
    you to select random published artists:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个需要自定义管理器和自定义方法来从数据库查询对象的更高级的示例。管理器是一个提供数据库查询操作给模型的接口。每个模型默认至少有一个名为`objects`的管理器。作为一个例子，让我们创建一个具有草稿或发布状态以及允许选择随机发布艺术家的`custom_manager`的`Artist`模型：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To load a random published artist, you add the following snippet to any template:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载一个随机发布的艺术家，您可以将以下片段添加到任何模板中：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's look at the code of the `{% get_objects %}` template tag. In the parsing
    function, there is one of the two formats expected; with the limit and without
    it. The string is parsed, the model is recognized, and then the components of
    the template tag are passed to the `ObjectNode` class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`{% get_objects %}`模板标签的代码。在解析函数中，有两种预期的格式之一；带有限制和不带限制。字符串将被解析，模型将被识别，然后模板标签的组件传递给`ObjectNode`类。
- en: In the `render()` method of the `Node` class, we will check the manager's name
    and its method's name. If this is not defined, `_default_manager` will be used,
    which is an automatic property of any model injected by Django and points to the
    first available `models.Manager()` instance. In most cases, `_default_manager`
    will be same as `objects`. After that, we will call the method of the manager
    and fall back to empty `QuerySet` if the method doesn't exist. If a limit is defined,
    we will resolve the value of it and limit `QuerySet`. Lastly, we will save the
    `QuerySet` to the context variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Node`类的`render()`方法中，我们将检查管理器的名称及其方法名称。如果没有定义，将使用`_default_manager`，这是Django注入的任何模型的一个自动属性，指向第一个可用的`models.Manager()`实例。在大多数情况下，`_default_manager`将与`objects`相同。之后，我们将调用管理器的方法，如果方法不存在，则回退到空的`QuerySet`。如果定义了限制，我们将解析其值并限制`QuerySet`。最后，我们将`QuerySet`保存到上下文变量中。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a template tag to include a template if it exists* recipe
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以包含一个模板（如果存在）*的配方'
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以将内容解析为模板*的配方'
- en: The *Creating a template tag to modify request query parameters* recipe
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以修改请求查询参数*的配方'
- en: Creating a template tag to parse content as a template
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签以将内容解析为模板
- en: In this recipe, we will create a `{% parse %}` template tag, which will allow
    you to put template snippets in the database. This is valuable when you want to
    provide different content for authenticated and unauthenticated users, when you
    want to include a personalized salutation or you don't want to hardcode the media
    paths in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个`{% parse %}`模板标签，这将允许您将模板片段放入数据库。当您想为认证用户和非认证用户提供不同的内容，或者想包含个性化的问候语或不想在数据库中硬编码媒体路径时，这非常有用。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we will start with the `utils` app that should be installed and ready
    for custom template tags.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将从应该安装并准备好自定义模板标签的`utils`应用开始。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag and a `Node` class that renders the output of the tag
    or modifies the template context. Perform the following steps to create them:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高级的自定义模板标签由一个解析传递给标签的参数的函数和一个渲染标签输出或修改模板上下文的`Node`类组成。按照以下步骤创建它们：
- en: 'First, let''s create the function parsing the arguments of the template tag,
    as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个解析模板标签参数的函数，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we will create the `Node` class in the same file, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在同一文件中创建`Node`类，如下所示：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `{% parse %}` template tag allows you to parse a value as a template and
    render it immediately or save it as a context variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% parse %}`模板标签允许您将值解析为模板并立即渲染或将其保存为上下文变量。'
- en: 'If we have an object with a description field, which can contain template variables
    or logic, we can parse and render it using the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个包含描述字段的对象，该字段可以包含模板变量或逻辑，我们可以使用以下代码进行解析和渲染：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is also possible to define a value in order to parse using a quoted string
    as shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以定义一个值以便使用引号字符串进行解析，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's take a look at the code of the `{% parse %}` template tag. The parsing
    function checks the arguments of the template tag bit by bit. At first, we expect
    the `parse` name, then the template value, and at last we expect the optional
    `as` word followed by the context variable name. The template value and variable
    name are passed to the `ParseNode` class. The `render()` method of that class,
    at first, resolves the value of the template variable and creates a template object
    out of it. Then, it renders the template with all the context variables. If the
    variable name is defined, the result is saved to it; otherwise, the result is
    shown immediately.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`{% parse %}`模板标签的代码。解析函数逐个检查模板标签的参数。首先，我们期望`parse`名称，然后是模板值，最后我们期望可选的`as`词后跟上下文变量名称。模板值和变量名称传递给`ParseNode`类。该类的`render()`方法首先解析模板变量的值，并从中创建一个模板对象。然后，它使用所有上下文变量渲染模板。如果变量名称已定义，结果被保存到它；否则，结果立即显示。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a template tag to include a template if it exists* recipe
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以包含模板（如果存在）*菜谱'
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在模板中创建加载QuerySet的模板标签*菜谱'
- en: The *Creating a template tag to modify request query parameters* recipe
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签来修改请求查询参数*菜谱'
- en: Creating a template tag to modify request query parameters
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签来修改请求查询参数
- en: Django has a convenient and flexible system to create canonical and clean URLs
    just by adding regular expression rules to the URL configuration files. However,
    there is a lack of built-in mechanisms in order to manage query parameters. Views
    such as search or filterable object lists need to accept query parameters to drill
    down through the filtered results using another parameter or to go to another
    page. In this recipe, we will create the `{% modify_query %}`, `{% add_to_query
    %}`, and `{% remove_from_query %}` template tags, which let you add, change, or
    remove the parameters of the current query.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过向URL配置文件添加正则表达式规则，提供了一个方便且灵活的系统来创建规范和干净的URL。然而，在管理查询参数方面，缺乏内置机制。例如，搜索或可筛选对象列表视图需要接受查询参数，以便通过另一个参数深入筛选结果或转到另一页。在这个菜谱中，我们将创建`{%
    modify_query %}`、`{% add_to_query %}`和`{% remove_from_query %}`模板标签，这些标签允许您添加、更改或删除当前查询的参数。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we start with the `utils` app that should be set in `INSTALLED_APPS`
    and contain the `templatetags` package.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们从`utils`应用开始，它应该在`INSTALLED_APPS`中设置，并包含`templatetags`包。
- en: 'Also, make sure that you have the `request` context processor set for the `TEMPLATE_CONTEXT_PROCESSORS`
    setting, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保您已为`TEMPLATE_CONTEXT_PROCESSORS`设置配置了`request`上下文处理器，如下所示：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做...
- en: 'For these template tags, we will be using the `simple_tag` decorator that parses
    the components and requires you to just define the rendering function, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些模板标签，我们将使用`simple_tag`装饰器来解析组件，并要求您只需定义渲染函数，如下所示：
- en: 'At first, we will create the `{% modify_query %}` template tag:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`{% modify_query %}`模板标签：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, let''s create the `{% add_to_query %}` template tag:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建`{% add_to_query %}`模板标签：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, let''s create the `{% remove_from_query %}` template tag:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建`{% remove_from_query %}`模板标签：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the three created template tags behave similarly. At first, they read the
    current query parameters from the `request.GET` dictionary-like `QueryDict` object
    to a new list of key value `query_params` tuples. Then, the values are updated
    depending on the positional arguments and keyword arguments. Lastly, the new query
    string is formed, all spaces and special characters are URL-encoded, and the ampersands
    connecting the query parameters are escaped. This new query string is returned
    to the template.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的三个创建的模板标签表现相似。首先，它们从`request.GET`字典样式的`QueryDict`对象中读取当前查询参数到一个新的键值`query_params`元组列表中。然后，根据位置参数和关键字参数更新值。最后，形成新的查询字符串，所有空格和特殊字符都进行URL编码，并且连接查询参数的与号被转义。这个新的查询字符串被返回到模板中。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To read more about the `QueryDict` objects, refer to the official Django documentation
    at [https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `QueryDict` 对象的信息，请参阅官方 Django 文档，[https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects)。
- en: 'Let''s take a look at an example of how the `{% modify_query %}` template tag
    can be used. Positional arguments in the template tag define which query parameters
    are to be removed and the keyword arguments define which query parameters are
    to be modified at the current query. If the current URL is `http://127.0.0.1:8000/artists/?category=fine-art&page=5`,
    we can use the following template tag to render a link that goes to the next page:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `{% modify_query %}` 模板标签的示例。模板标签中的位置参数定义了要删除哪些查询参数，而关键字参数定义了在当前查询中要修改哪些查询参数。如果当前
    URL 是 `http://127.0.0.1:8000/artists/?category=fine-art&page=5`，我们可以使用以下模板标签来渲染一个链接，该链接跳转到下一页：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following snippet is the output rendered using the preceding template tag:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是使用前面的模板标签渲染的输出：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also use the following example to render a link that resets pagination
    and goes to another category, *Sculpture*, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下示例来渲染一个链接，该链接重置分页并跳转到另一个分类，*雕塑*，如下所示：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following snippet is the output rendered using the preceding template tag:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是使用前面的模板标签渲染的输出：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `{% add_to_query %}` template tag, you can add the parameters step-by-step
    with the same name. For example, if the current URL is `http://127.0.0.1:8000/artists/?category=fine-art`,
    you can add another category, *Sculpture*, with the help of the following link:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{% add_to_query %}` 模板标签，您可以逐步添加具有相同名称的参数。例如，如果当前 URL 是 `http://127.0.0.1:8000/artists/?category=fine-art`，您可以使用以下链接添加另一个分类，*雕塑*：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will be rendered in the template as shown in the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模板中渲染成如下片段：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, with the help of the `{% remove_from_query %}` template tag, you can
    remove the parameters step-by-step with the same name. For example, if the current
    URL is `http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`,
    you can remove the *Sculpture* category with the help of the following link:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，借助 `{% remove_from_query %}` 模板标签，您可以逐步删除具有相同名称的参数。例如，如果当前 URL 是 `http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`，您可以使用以下链接帮助删除
    *雕塑* 分类：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will be rendered in the template as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模板中渲染如下：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Filtering object lists* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。表单和视图")中的 *过滤对象列表* 配方，*表单和视图*'
- en: The *Creating a template tag to include a template if it exists* recipe
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以包含存在的模板* 的配方'
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以在模板中加载 QuerySet* 的配方'
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以将内容解析为模板* 的配方'
