- en: Chapter 5. Custom Template Filters and Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Following conventions for your own template filters and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to show how many days have passed since a post was
    published
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to extract the first media object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to humanize URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to include a template if it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to load a QuerySet in a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to parse content as a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to modify request query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, Django has an extensive template system with features such as template
    inheritance, filters to change the representation of values, and tags for presentational
    logic. Moreover, Django allows you to add your own template filters and tags to
    your apps. Custom filters or tags should be located in a template-tag library
    file under the `templatetags` Python package in your app. Then, your template-tag
    library can be loaded in any template with a `{% load %}` template tag. In this
    chapter, we will create several useful filters and tags that will give more control
    to template editors.
  prefs: []
  type: TYPE_NORMAL
- en: To see the template tags of this chapter in action, create a virtual environment,
    extract the code provided for this chapter there, run the development server,
    and visit `http://127.0.0.1:8000/en/` in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Following conventions for your own template filters and tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom template filters and tags can become a total mess if you don't have persistent
    guidelines to follow. Template filters and tags should serve template editors
    as much as possible. They should be both handy and flexible. In this recipe, we
    will take a look at some conventions that should be used when enhancing the functionality
    of the Django template system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these conventions when extending the Django template system:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't create or use custom template filters or tags when the logic for the page
    fits better in the view, context processors, or model methods. When your content
    is context-specific, such as a list of objects or object-detail view, load the
    object in the view. If you need to show some content on every page, create a context
    processor. Use custom methods of the model instead of template filters when you
    need to get some properties of an object that are not related to the context of
    the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the template-tag library with the `_tags` suffix. When your app is named
    differently than your template-tag library, you can avoid ambiguous package importing
    problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the newly created library, separate the filters from tags, for example,
    using comments as shown the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When creating advanced custom template tags, make sure that their syntax is
    easy to remember by including the following constructs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for [app_name.model_name]`: Include this construct in order to use a specific
    model'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using [template_name]`: Include this construct in order to use a template
    for the output of the template tag'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit [count]`: Include this construct in order to limit the results to a
    specific amount'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as [context_variable]`: Include this construct in order to save the results
    to a context variable that can be reused multiple times'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid multiple values that are defined positionally in the template tags,
    unless they are self-explanatory. Otherwise, this will likely confuse the template
    developers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make as many resolvable arguments as possible. Strings without quotes should
    be treated as context variables that need to be resolved or short words that remind
    you of the structure of the template tag components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a template filter to show how many days have passed since a post was
    published
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all people keep track of the date and when talking about creation or modification
    dates of cutting-edge information; for many of us, it is convenient to read the
    time difference. For example, the blog entry was posted *three days ago*, the
    news article was published *today*, and the user last logged in *yesterday*. In
    this recipe, we will create a template filter named `days_since`, which converts
    dates to humanized time differences.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the `utils` app and put it under `INSTALLED_APPS` in the settings, if
    you haven't done that yet. Then, create a `templatetags` Python package in this
    app (Python packages are directories with an empty `__init__.py` file).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `utility_tags.py` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use this filter in a template as shown in the following code, it will
    render something similar to *yesterday* or *5 days ago*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can apply this filter to values of the `date` and `datetime` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each template-tag library has a register, where filters and tags are collected.
    Django filters are functions registered by the `@register.filter` decorator. By
    default, the filter in the template system will be named same as the function
    or other callable object. If you want, you can set a different name for the filter
    by passing the name to the decorator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The filter itself is quite self-explanatory. At first, the current date is read.
    If the given value of the filter is of the `datetime` type, `date` is extracted.
    Then, the difference between today and the extracted value is calculated. Depending
    on the number of days, different string results are returned.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This filter is also easy to extend in order to show the difference in time,
    such as *just now*, *7 minutes ago*, and *3 hours ago*. Just operate on the `datetime`
    values instead of the date values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template filter to extract the first media object* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to humanize URLs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to extract the first media object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are developing a blog overview page, and for each post, you
    want to show images, music, or videos in that page taken from the content. In
    such a case, you need to extract the `<figure>`, `<img>`, `<object>`, `<embed>`,
    `<video>`, `<audio>`, and `<iframe>` tags from the HTML content of the post. In
    this recipe, we will see how to perform this using regular expressions in the
    `first_media` filter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the `utils` app that should be set in `INSTALLED_APPS` in
    the settings and the `templatetags` package in this app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `utility_tags.py` file, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the HTML content in the database is valid, when you put the following code
    in the template, it will retrieve the media tags from the content field of the
    object; otherwise, an empty string will be returned if no media is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are powerful feature to search/replace patterns of text.
    At first, we will define the compiled regular expression as `media_file_regex`.
    In our case, we will search for all the possible media tags that can also occur
    in multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python strings can be concatenated without a plus (+) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this regular expression works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Alternating patterns are separated by the pipe (`|`) symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For possibly multiline tags, we will use the `[\S\s]+?` pattern that matches
    any symbol at least once; however, as little times as possible, until we find
    the the string that goes after it. Therefore, `<figure[\S\s]+?</figure>` searches
    for a `<figure>` tag and everything after it, until it finds the closing `</figure>`
    tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, with the `[^>]+` pattern, we search for any symbol except the greater
    than (`>`) symbol at least once and as many times as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `re.MULTILINE` flag ensures that the search will happen in multiple lines.
    Then, in the filter, we will perform a search for this regular expression pattern.
    By default, the result of the filter will show the `<`, `>`, and `&` symbols escaped
    as the `&lt;`, `&gt;`, and `&amp;` entities. However, we use the `mark_safe()`
    function that marks the result as safe and HTML-ready in order to be shown in
    the template without escaping.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested in regular expressions, you can learn more about them
    in the official Python documentation at [https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to humanize URLs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to humanize URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, common web users enter URLs in address fields without protocol and
    trailing slashes. In this recipe, we will create a `humanize_url` filter that
    is used to present URLs to the user in a shorter format, truncating very long
    addresses, similar to what Twitter does with the links in the tweets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous recipes, we will start with the `utils` app that should
    be set in `INSTALLED_APPS` in the settings and contain the `templatetags` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `FILTERS` section of the `utility_tags.py` template library in the `utils`
    app, let''s add a `humanize_url` filter and register it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `humanize_url` filter in any template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The filter uses regular expressions to remove the leading protocol and trailing
    slash, shorten the URL to the given amount of letters, and add an ellipsis to
    the end if the URL doesn't fit in the specified letter count.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to extract the first media object* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to include a template if it exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has the `{% include %}` template tag that renders and includes another
    template. However, there is a problem in some situations, where an error is raised
    if the template does not exist. In this recipe, we will see how to create a `{%
    try_to_include %}` template tag that includes another template and fails silently
    if there is no such template.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start again with the `utils` app that is installed and ready for custom
    template tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Advanced custom template tags consist of two things: the function that is parsing
    the arguments of the template tag and the `Node` class that is responsible for
    the logic of the template tag as well as the output. Perform the following steps
    to create the `{% try_to_include %}` template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need the `Node` class in the same file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `{% try_to_include %}` template tag expects one argument, that is, `template_name`.
    Therefore, in the `try_to_include()` function, we try to assign the split contents
    of the token only to the `tag_name` variable (which is `try_to_include`) and the
    `template_name` variable. If this doesn't work, the template syntax error is raised.
    The function returns the `IncludeNode` object, which gets the `template_name`
    field for later use.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render()` method of `IncludeNode`, we resolve the `template_name` variable.
    If a context variable was passed to the template tag, its value will be used here
    for `template_name`. If a quoted string was passed to the template tag, then the
    content in the quotes will be used for `template_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will try to load the template and render it with the current template
    context. If that doesn't work, an empty string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two situations where we could use this template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used when including a template whose path is defined in a model, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is used when including a template whose path is defined with the `{% with
    %}` template tag somewhere high in the template context variable''s scope. This
    is especially useful when you need to create custom layouts for plugins in the
    placeholder of a template in Django CMS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `{% try_to_include %}` tag as well as the default `{% include
    %}` tag to include the templates that extend other templates. This is beneficial
    for large-scale portals, where you have different kinds of lists in which complex
    items share the same structure as widgets but have a different source of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the artist list template, you can include the artist item template,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will extend from the item base, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The item base defines the markup for any item and also includes a Like widget,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating templates for Django CMS* recipe in [Chapter 7](ch07.html "Chapter 7. Django
    CMS"), *Django CMS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing your own CMS plugin* recipe in [Chapter 7](ch07.html "Chapter 7. Django
    CMS"), *Django CMS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to load a QuerySet in a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most often, the content that should be shown on a webpage will have to be defined
    in the view. If this is the content to be shown on every page, it is logical to
    create a context processor. Another situation is where you need to show additional
    content such as the latest news or a random quote on some pages; for example,
    the starting page or the details page of an object. In this case, you can load
    the necessary content with the `{% get_objects %}` template tag, which we will
    implement in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will start with the `utils` app that should be installed and
    ready for custom template tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An advanced custom template tag consists of a function that parses arguments
    that are passed to the tag and a `Node` class that renders the output of the tag
    or modifies the template context. Perform the following steps to create the `{%
    get_objects %}` template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create the `Node` class in the same file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `{% get_objects %}` template tag loads QuerySet defined by the method of
    the manager from a specified app and model, limits the result to the specified
    amount, and saves the result to a context variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the simplest example of how to use the template tag that
    we have just created. It will load all news articles in any template using the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is using the `all()` method of the default `objects` manager of the `Article`
    model and it will sort the articles by the `ordering` attribute defined in the
    `Meta` class of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more advanced example would be required to create a custom manager with a
    custom method to query the objects from the database. A manager is an interface
    that provides the database query operations to models. Each model has at least
    one manager called `objects` by default. As an example, let''s create an `Artist`
    model that has a draft or published status and a new `custom_manager` that allows
    you to select random published artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To load a random published artist, you add the following snippet to any template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the code of the `{% get_objects %}` template tag. In the parsing
    function, there is one of the two formats expected; with the limit and without
    it. The string is parsed, the model is recognized, and then the components of
    the template tag are passed to the `ObjectNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render()` method of the `Node` class, we will check the manager's name
    and its method's name. If this is not defined, `_default_manager` will be used,
    which is an automatic property of any model injected by Django and points to the
    first available `models.Manager()` instance. In most cases, `_default_manager`
    will be same as `objects`. After that, we will call the method of the manager
    and fall back to empty `QuerySet` if the method doesn't exist. If a limit is defined,
    we will resolve the value of it and limit `QuerySet`. Lastly, we will save the
    `QuerySet` to the context variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to parse content as a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a `{% parse %}` template tag, which will allow
    you to put template snippets in the database. This is valuable when you want to
    provide different content for authenticated and unauthenticated users, when you
    want to include a personalized salutation or you don't want to hardcode the media
    paths in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we will start with the `utils` app that should be installed and ready
    for custom template tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag and a `Node` class that renders the output of the tag
    or modifies the template context. Perform the following steps to create them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function parsing the arguments of the template tag,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create the `Node` class in the same file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `{% parse %}` template tag allows you to parse a value as a template and
    render it immediately or save it as a context variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an object with a description field, which can contain template variables
    or logic, we can parse and render it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to define a value in order to parse using a quoted string
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the code of the `{% parse %}` template tag. The parsing
    function checks the arguments of the template tag bit by bit. At first, we expect
    the `parse` name, then the template value, and at last we expect the optional
    `as` word followed by the context variable name. The template value and variable
    name are passed to the `ParseNode` class. The `render()` method of that class,
    at first, resolves the value of the template variable and creates a template object
    out of it. Then, it renders the template with all the context variables. If the
    variable name is defined, the result is saved to it; otherwise, the result is
    shown immediately.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to modify request query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a convenient and flexible system to create canonical and clean URLs
    just by adding regular expression rules to the URL configuration files. However,
    there is a lack of built-in mechanisms in order to manage query parameters. Views
    such as search or filterable object lists need to accept query parameters to drill
    down through the filtered results using another parameter or to go to another
    page. In this recipe, we will create the `{% modify_query %}`, `{% add_to_query
    %}`, and `{% remove_from_query %}` template tags, which let you add, change, or
    remove the parameters of the current query.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we start with the `utils` app that should be set in `INSTALLED_APPS`
    and contain the `templatetags` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, make sure that you have the `request` context processor set for the `TEMPLATE_CONTEXT_PROCESSORS`
    setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these template tags, we will be using the `simple_tag` decorator that parses
    the components and requires you to just define the rendering function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we will create the `{% modify_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s create the `{% add_to_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, let''s create the `{% remove_from_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the three created template tags behave similarly. At first, they read the
    current query parameters from the `request.GET` dictionary-like `QueryDict` object
    to a new list of key value `query_params` tuples. Then, the values are updated
    depending on the positional arguments and keyword arguments. Lastly, the new query
    string is formed, all spaces and special characters are URL-encoded, and the ampersands
    connecting the query parameters are escaped. This new query string is returned
    to the template.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To read more about the `QueryDict` objects, refer to the official Django documentation
    at [https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/1.8/ref/request-response/#querydict-objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of how the `{% modify_query %}` template tag
    can be used. Positional arguments in the template tag define which query parameters
    are to be removed and the keyword arguments define which query parameters are
    to be modified at the current query. If the current URL is `http://127.0.0.1:8000/artists/?category=fine-art&page=5`,
    we can use the following template tag to render a link that goes to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet is the output rendered using the preceding template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following example to render a link that resets pagination
    and goes to another category, *Sculpture*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet is the output rendered using the preceding template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `{% add_to_query %}` template tag, you can add the parameters step-by-step
    with the same name. For example, if the current URL is `http://127.0.0.1:8000/artists/?category=fine-art`,
    you can add another category, *Sculpture*, with the help of the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be rendered in the template as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, with the help of the `{% remove_from_query %}` template tag, you can
    remove the parameters step-by-step with the same name. For example, if the current
    URL is `http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`,
    you can remove the *Sculpture* category with the help of the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be rendered in the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
