- en: Getting Started with PyQt and PySide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will lay the groundwork so that we can start the creation
    of GUIs with Python bindings, such as PyQt and PySide. These bindings are able to
    utilize all Python programming language functionalities and various Python-based
    tools that are available in the Python world, together with the powerful Qt framework,
    which, in turn, allows us to visualize our imagination and development processes
    in real and widely functional GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt versus PySide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQt5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PySide2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQt versus PySide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see, PyQt and PySide represent the bindings of the Python programming
    language functionality with the Qt library. These tools are very similar and provide
    just the ability to implement the Python syntax with C++, because Qt is basically
    a C++ language-based framework. The bindings are implemented as a set of Python
    modules and contain the classes that realize the GUI and infrastructure implementation. PySide
    is a community managed Qt Project ([http://qt-project.org](http://qt-project.org)),
    while PyQt is a binding that's developed by the British firm, Riverbank Computing
    ([https://riverbankcomputing.com](https://riverbankcomputing.com)) . The most
    recent versions of these bindings, at the time of writing this book, support the
    Qt5.x framework in both the PySide2 and PyQt5 versions. Within this book, the
    most recent versions of the bindings, PyQt5 and PySide2, will be used. These versions
    can be downloaded and installed from official sources, with `pip` or other available
    package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using these tools with Python, you need to have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloaded and installed Python from [https://www.python.org/downloads/](https://www.python.org/downloads/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of PyQt5, you need to have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Built and installed SIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downloaded and installed the PyQt5 package from the official source or with
    `pip`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of PySide2, you need to have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installed libclang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downloaded and installed the PySide2 package from the official source:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the option that is most recommended is downloading and installing
    the Anaconda toolset. Anaconda, by default, has PyQt5 installed and ready to work.
    In addition, the PySide2 binding can be installed using the command in the cmd/Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, PySide2 can be installed using Anaconda Navigator, which is provided
    as a default tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, PySide2 with the Python 2.x Anaconda environment will be used
    and PyQt5 with Python 3.x Anaconda. This circumvents numerous version conflicts
    and gets the necessary knowledge about the differences between Python versions
    2.x/3.x in practice.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between PyQt5 and PySide2 bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the Python and Qt bindings are installed, let's describe some of
    the differences between PyQt and PySide. These differences are not constant over
    the period in question and may be excluded in the future. Firstly, there is a
    different `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the PyQt5 binding, `import` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the PySide2 binding, use the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the difference is in the name of the binding that is used to
    import the module. The statement to import some modules or classes can be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `import` statement of PyQt5 to Qt looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But with PySide2, it is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Also, other classes can have different importing locations. It is recommended
    to learn these import locations for both PyQt5 and PySide2 binding modules and
    classes in relation to the versions used.
  prefs: []
  type: TYPE_NORMAL
- en: The PySide2 binding only supports API 2, which means that classes including
    `QStrings`, `QStringLists`, and `QVariants` are not available.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots have some different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for PyQt5 signals is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the PySide2 binding, we need to modify this syntax so that it''s similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some facts about the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: The signal decorator of PySide2 is `@Signal`, not `@pyqtSignal`, as it is in
    PyQt5 binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PySide2 will not export C++ components deprecated by Qt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also differences with property declaration. If, in PyQt5, this looks
    like `QtCore.pyqtProperty`,then for PySide2, this will be `QtCore.Property`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different tool names are available with bindings. For example, the PyQt5 tool
    name, `pyuic5`, will be `pyside2-uic` with PySide2, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PySide uses `event()` and `connect()` with the `QObject` class. These property
    names cannot be used in the code for something else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By working with the `QThread` class, in PySide2, after calling `stop()`, we
    need to use `wait()` when quitting the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PySide2 `sender()` method returns `None` when a slot is a Lambda function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With inheritance using PySide2, the parent class constructors always need to
    be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PyQt5 class construction is similar to this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In PySide2, the class name needs to be added to the `super()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'PySide2 only supports new-style classes, which are classes that are available
    as part of inheritance with PyQt5:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With PySide2, we need change to the new style by adding `object`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The old-style signals look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With PySide2, the old-style signals need to be rewritten as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Only signals without arguments will have the auto connection to the constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `triggered()` signal will be connected to the slot
    handler instead of the `triggered(bool)` signal.
  prefs: []
  type: TYPE_NORMAL
- en: PySide2 is related to `shiboken2`, the Python binding generator that is used
    to create the PySide2 modules, and is the Qt C++ API to Python. Shiboken is a
    generator runner plugin that provides C++ code for CPython extensions. PyQt5 is
    built using the SIP bindings generator, the tool that creates Python bindings
    for C and C++ libraries.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the differences between PyQt5 and PySide2 are not the cardinal
    point in the comparison. All of these problems can easily be prevented. Within
    this book, we will try to avoid the limitations and restrictions related to the
    versions of the bindings, languages, and framework features. Hence, as we mentioned previously,
    we will use the most recent Anaconda 2 environment for PySide2, and the most recent
    Anaconda 3 environment for PyQt5\. Also, modern programming approaches, including
    the utilization of the new-style classes, will be adopted.
  prefs: []
  type: TYPE_NORMAL
- en: Frequent questions that arise inside the community regarding the differences
    between PyQt5 and PySide2 are related to the licenses of these bindings. PySide2
    is under the GNU **Lesser General Public License** (**LGPL**), or the Qt Commercial
    License, as a counterweight to PyQt5, under the Riverbank Commercial License,
    or GPL v3\. Also, some third-party components of PySide2 are under licenses that
    may not be the LGPLs. If you are intending to use the software for commercial
    purposes, you need to read these license rules carefully.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start our learning of GUI creation with Python by exploring the PyQt5
    binding to the Qt framework. As we mentioned previously, PyQt5 is a binding to
    the Qt application framework that''s provided by the Qt company and developed
    by RiverBank Computing. At the time of writing, PyQt5 may be used on Windows,
    Linux, Unix platforms, macOS, Android, and iOS. The downloaded PyQt5 package does
    not have a copy of Qt, and by now, you must have downloaded and installed the
    correct licensed copy of Qt framework from the official source. PyQt5 is a dual
    licensed software, licensed under the Riverbank Commercial License and the GPL
    v3\. This means that if the GPL license is to be used, then the code provided
    by the developer must also use a compatible license. PyQt5 modules contain the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt`: This is a consolidation of the modules, such as in the Qt library—the
    base of all classes. This is the base class of the Qt library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic with GUI creation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore`: These are the core Qt classes; they provide core functionality, such
    as signals/slots or alignment of the elements.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWidgets`: This is the GUI for creating classes which create desktop applications,
    such as creating a window.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtGui`: These are the core classes for widgets and GUIs, such as adding icons
    and working with colors and texts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtPrintSupport`: This provides local/remote printing functionality integration
    with the applications, with the ability to generate PostScript and PDF files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMultimedia`: These are classes for multimedia content and APIs to access
    camera and radio. It has audio and video classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMultimediaWidgets`: These are additional classes for multimedia widgets
    and controls, such as video widgets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSql`: This provides integration with SQL databases. This includes the SQL
    database, drivers, fields, table models, and queries classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSvg`: This provides support for rendering the contents of the **Structured
    Vector Graphics** (**SVG**).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QML**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQml`: Classes for integrating the QML language infrastructure with PyQt5
    applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQuick`: Provides the extension for the QML user interfaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQuickWidgets`: Used to render a QML scene in traditional widgets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices, networking, and the web**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtBluetooth`: These are classes to connect with Bluetooth devices, such as
    scanning for devices, gathering information, and exchanging data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtNfc`: This provides the classes to connect between NFC devices (near-field
    communication protocols used by devices).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtNetwork`: These are the core network classes. This facilitates the creation
    of UDP and TCP clients and servers, and includes the classes that implement HTTP
    clients and support DNS lookups. Options to work with sockets, network configuration,
    and SSL certificates are available.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtNetworkAuth`: These are classes for network authorization (OAuth).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebChannel`: This is for use of the classes that enable peer-to-peer communication
    between a server, Python/QML application and client, HTML/JavaScript, or QML application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebEngine`: These are classes for integrating QML WebEngine objects with
    Python.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebEngineCore`: These are the core web engine classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebEngineWidgets`: This provides a Chromium-based web browser.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebSockets`: This is an implementation of the WebSocket protocol.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtPurchasing`: This provides in-app purchasing, App Store, and Google Play
    support.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DAnimation`: Classes used for animations that are applied to the object
    properties in simulations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`Qt3DCore`**: The core classes for the near real-time simulation systems
    with 2D and 3D rendering.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DExtras`: Classes that provide pre-built elements for Qt3D, such as geometries,
    meshes and materials, and camera controllers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DInput`: Classes for handling user input with Qt3D.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DLogic`: Synchronization of the frames with the Qt3D backend.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DRender`: Classes for 2D and 3D rendering with Qt3D.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtDataVisualization`: Contains the classes that visualize data in 3D as surface
    graphs, bars, and scatter plots.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtXml`:Classes that provide the simple API for XML (SAX) and **Document Object
    Model** (**DOM**) interfaces for the XML parser of the Qt framework.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtXmlPatterns`: Classes for additional XML technologies, such as XPath and
    XQuery, **Extensible Stylesheet Language Transformations** (**XSLT**), and XML
    schema validation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtLocation`: This provides classes for the creation of the mapping applications
    with data from the popular location services that provide navigation information
    and geocoding, along with place searching.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtPositioning`: This module provides the classes for working with positioning
    information from satellites, Wi-Fi, and so on, and can be used to determine a
    position on a map.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSensors`: This provides classes for working with a system''s hardware sensors,
    such as gyroscopes and accelerometers, altimeters, ambient light and temperature
    sensors, and magnetometers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSerialPort`: This module provides the classes for working with serial ports
    of the system, and for configuring, I/O operations, and getting and setting the
    control signals of the RS-232 pinouts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtDBus`: This provides classes for working with the D-Bus protocol—the **Inter-Process
    Communication** (**IPC**) and **Remote Procedure Calling** (**RPC**) mechanism.
    This was designed to allow interaction between system-level processes, such as
    printers and hardware driver services, and other user processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QAxContainer`: This provides classes that provide access to ActiveX (internet-enabled
    components) controls and COM objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtChart`: This provides classes for the creation of 2D charts. These include
    line and spline charts, area and scatter charts, bar charts, pie charts, box-and-whiskers
    charts, candlestick charts, and polar charts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtDesigner`: A module with classes that provides extensions for using the
    Qt Designer with Python.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtHelp`: Classes that allow the creation/viewing of searchable help and documentation
    in the applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uic`: The **User Interface Compiler** (`uic`) handles the files that are created
    using the Qt Designer graphical interface tool and the generation of Python code
    from the `gui.ui` files that are created.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtTest`: This provides unit testing for the applications. It includes the
    `QSignalSpy` class, which provides introspection of the signals and slots.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extras**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtAndroidExtras`: Classes specific to Android platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMacExtras`: Classes specific to macOS and iOS platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWinExtras`: Classes specific to Windows, such as a progress indicator on
    the taskbar button and a thumbnail toolbar.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtX11Extras`: Classes specific to the X11 windowing system.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the PyQt5 framework provides a number of utility programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pyuic5`: A utility that converts `gui.ui` files, which are created using the
    Qt Designer graphical tool, into standard Python code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyrcc5`: A utility that embeds icons, images, translation files, and so on,
    as described by the resource collection file in any Python module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pylupdate5`:A utility for extracting the translatable strings from Python
    code and creating/updating translation files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PySide2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PySide2 library, as we mentioned previously, is a coupling of the classes
    that were provided so that Qt could be used with Python. It is developed by the
    Qt project community. These libraries (PyQt and PySide) are very similar and have
    a construction that uses the main Qt functionality for creating GUIs with Python.
    In this sense, PySide2 facilitates the use of Qt5 APIs in Python applications.
    This gives software developers the ability to use the full potential of Qt. The
    PySide2 module provides access to individual Qt modules, such as Qt Widgets, Qt
    Core, and Qt GUI. Some of these will repeat the preceding content, but for comparison
    purposes, it is necessary to describe these modules here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUI creation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore`: This is the core non-GUI functionality class that provides core functionality
    signals/slots or calibration of the components, similar to the PyQt5 library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWidgets`: This implements C++ classes to extend Qt GUI widget functionality
    and provides the graphical components, such as buttons, window, and widgets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtGui`: This has classes for the windowing system and graphics in the Qt library,
    such as events, OpenGL, OpenGL ES, and Vulkan integration; 2D graphics; imaging;
    typography fonts; and colors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtPrintSupport`: This is a cross-platform printing functionality of the Qt
    library.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMultimedia`: This is a low-level multimedia functionality for audio, video,
    radio, camera, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMultimediaWidgets`: These classes are for the creation of multimedia widgets
    from the Qt Multimedia Widgets module.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSql`: This is the module for database implementations in the application.
    This includes the drivers, SQL API, and user interface layers for SQL databases.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSvg`: This provides classes to display SVG files, such as rendering (`QSvgRenderer`)
    and drawing (`QSvgWidget`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtConcurrent`: This provides high-level API functionality for the concurrent
    execution of code. It can be used for writing multithreaded constructions of the
    applications without using low-level threading primitives, such as mutexes, read-write
    locks, wait conditions, or semaphores.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QML**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQml`:This is a Python API for the Qt QML infrastructure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQuick`: This is a class for Qt Quick in Qt/C++ applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtQuickWidgets`: This is the `QQuickWidget` class for Qt Quick in widget-based
    applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking and web**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtNetwork`: This is a network programming class that allows the creation of UDP
    and TCP clients and servers, and includes the classes that implement HTTP clients
    and support DNS lookups. Options to work with sockets, network configuration,
    and SSL certificates are available.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebChannel`: This is a class for peer-to-peer communication between a server
    and a client HTML/JavaScript or QML application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebEngineCore`: The core functionality is to fuse the web content, the public
    API shared by `QtWebEngine`, and the `QtWebEnginEWidgets` classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebEngineWidgets`: This provides a web browser engine with common C++ classes
    to provide and collaborate with web content.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebSockets`: Interfaces for the Qt application that can act as servers/clients
    that can process WebSocket requests or receive data from the server. This also
    includes C++ classes that enable socket-based communication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DAnimation`: This is a module that provides classes with basic elements
    to animate 3D objects in the Qt framework.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DCore`: This is the Qt3D module with classes for the core types that are
    used for near real-time simulations, built on the Qt3D framework.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DExtras`: This provides prebuilt elements for working with Qt3D.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DInput`: This is a module with classes for handling user input with Qt3D.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DLogic`: This provides classes for the synchronization of frames with the
    Qt3D backend.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt3DRender`: This is a module with classes for 2D/3D rendering with Qt3D.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtDataVisualization`: This provides classes to visualize data in 3D as surface
    graphs, bars, and scatter plots.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtXml`: C++ implementations of the simple API for XML (SAX) and DOM interfaces
    with the Qt application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtXmlPatterns`: XQuery, XPath, XSLT, and XML schema validation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtScxml`: Classes for creation using state machines from SCXML files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtLocation`: This provides C++ interfaces for location and navigational information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtPositioning`: This provides positioning access through QML and Python interfaces
    to the satellite and area monitoring data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtSensors`: This provides classes for reading a system''s sensor hardware
    via QML and Python interfaces. It also provides a motion gesture recognition API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QAxContainer`: This provides the `QAxObject` object and the `QAxWidget` widget,
    which are used as containers for the ActiveX controls and COM objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCharts`: This is the most commonly used chart components.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtTextToSpeech`: This is an API to access text-to-speech engines with the `QTextToSpeechEngine`,
    `QTextToSpeech`, and `QVoice` classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtHelp`: This provides classes to include online help and documentation in
    applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtUiTools`: This provides classes to handle Qt Designer forms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtTest`: This provides classes for unit testing of the Qt applications and
    libraries.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extras**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWindowsExtras`: Classes so that you can use a number of Windows APIs with
    Qt.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtMacExtras`: Classes specific to macOS and iOS operating systems.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtX11Extras`: Information regarding the X11 configuration.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Application construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two Python bindings (PyQt5 and PySide2) to the Qt library are similar in
    nature. The most commonly used modules are related to GUI creation. These include Qt
    Core, Qt Widgets, and Qt GUI. As we can see, these modules are available in both
    PyQt5 and PySide2. It is precisely these modules that will be examined in detail
    within this book. The programming approach that will be used in this book implies
    writing the Python code inside Python files, with a declaration of the classes,
    functions, variables, and so on. Before we start this exciting process, we would
    like to consider a slightly different way of creating the GUI application in the
    design part—creation involving Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This graphical user tool for creating GUI applications with Qt is available
    with almost all variations of the PyQt and PySide libraries, as provided by the
    Anaconda toolset, with PyQt5 standalone, or can be downloaded and installed with
    Qt. Let''s try to do something with Qt Designer. For this, we just need to open
    Designer by clicking on the icon, or we do this through the cmd/Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the designer window, along with options to create forms, buttons,
    labels, and so on. Create the simple widget and add some elements, including frames
    and different buttons, to the widget, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d433afe-14ca-4020-b190-eada486f19b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we need to save this file with a name, such as `design_app`**.** It should
    be noted that Qt Designer uses XML `*.ui` files to store designs and does not
    generate any code itself. Choose the Save option and then save the file as `design_app.ui`
    in the `App/`directory. As a result, we will have a file with a UI extension and
    XML inside it. However, it would be preferable for this file to be a Python file
    containing Python code. To do this, we need to convert this code into Python with
    the help of an additional utility—`pyuic5` (PyQt5) or `pyside2-uic` (PySide2).
    Type the following command in the cmd/Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see the `design_app.py` file with Python code inside the `App/`directory.
  prefs: []
  type: TYPE_NORMAL
- en: This book will not describe GUI development with Qt Designer. This brief introduction
    to this tool is sufficient to understand how a developer can use Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following this brief introduction to Qt Designer, let's move on to the main
    objective of this book, namely, the correct choice in terms of the construction
    and writing of the qualitative Python code for the application with the GUI. Most
    programming practices require an understanding of the functionality and the form
    of the future application in order to appreciate how everything in the application
    works. But this is not what we will do. We will use Python—a real-time dynamic
    programming language that gives us the opportunity to implement almost everything
    in the world in a graphical window. We need to start low and go high.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to organize the directories with application files in the correct
    manner. Although this book will demonstrate examples of both bindings, it is recommended
    that you create directories, such as `App/App_PySide2` and `App/App_PyQt5`,inside
    the `App/`directory. But if your choice of a certain Python binding has been made, it's
    not obligatory. Then, we need to execute a rewrite of the files, as we described
    in previous chapters, and add some more files. There are many different ways to
    create GUI applications. If the GUI app that will be created is small in size,
    on a small scale, or simply provides a limited functionality, for example, only
    performing several functions, it makes sense to put the code in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a bad idea, because each application can be rebuilt, updated,
    upgraded, or enlarged with additional code. And splitting the small application
    into several files will have no, or almost no, effect on performance and productivity.
    On the other hand, incorporating large-scale application code in a single file will
    lead to problems in terms of editors reading this file, as well as maintenance
    problems, and confusion in general. Problems may also arise in regards to rebuilding
    and changing the functionality. For example, if some style properties need to
    be changed, it will be necessary to find these parameters, and something will
    always go unnoticed. GUI applications usually have many lines of code, unlike
    the lines of functions for some special operations. In other words, it is a good
    idea to split the application between the different files in some way and import
    classes and functions from these files to the file with the main GUI application.
    This is the art of programming—to create applications with files, classes, and
    functions in the right places. We need to understand that some of them need to
    be located in the spaces that are allowed in order to exclude the problems associated
    with namespacing. We will utilize the **object-oriented programming** (**OOP**)
    approach, which means that we want to use the code many times in different places,
    and sometimes in other applications in the future. In addition, the styling code
    of GUI applications commonly requires many lines.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, let's split the application into the three files as they are
    created: `u_app.py`, `u_tools.py`, and a `u_style.py` file that we will add now.
    Then, put them into the `App/App_PySide2` and `App/App_PyQt5` directories. The
    `u_app.py` file will contain the main class of the GUI application, along with
    instructions to run it. Change the code inside as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to the `u_app.py` file, the following code creates the class with PyQt5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are creating the main class of the GUI application. This class
    will combine all of the functionality from the other modules (third-party packages)
    and create the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PySide2 `u_app.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the file with the main class that will be used with the PySide2 binding
    to Qt. The `u_tools.py` file will contain the classes and functions to provide
    some functionality or additional features for the GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the content of this file to the following in the case of the PyQt5 `u_tools.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the file that includes classes. We will use convenient functions that
    are not related, in the full sense, to the GUI representation of the application
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PySide2 `u_tools.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Where possible, we will avoid differences in syntax, used modules, and classes
    between the Python versions and Python bindings in the Qt library (PySide2/PyQt5).
  prefs: []
  type: TYPE_NORMAL
- en: The `u_style.py` file will contain the classes and functions that provide styling
    to the GUI application, including widgets, buttons, labels, frames, colors, and
    fonts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_style.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These styling files will only contain graphically related objects and graphics
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PySide2 `u_style.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only differences between the PySide2 and PyQt5 bindings is
    in the name import statements and in the printing of the `string` variable, which
    depends on the different Python versions. Throughout this book, the code in these
    files will be augmented or changed as we add new elements, widgets, and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, these applications can be run using the cmd/Terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the same result, in other words, an empty widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b58da04-ba27-4781-829d-0becb2b99f6a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the cmd/Terminal, we have the same output that we did when the system arguments
    were passed with `QApplication`, that is, a list with the name of the application
    and a `string` variable of the `UTools` class.
  prefs: []
  type: TYPE_NORMAL
- en: Application features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the process that will be executed when the application is created
    and run the `u_app.py` file with the script. Let''s look at what happens, line
    by line:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `u_app.py` file, the import section that import the `UTools` class, which
    will provide some functionality, was fixed, including functions, or, like it was
    in this case, `string` variables with text. The `UWid` class, which implements
    `Qwidget` (a widget that will be shown as a graphical element), will also be imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UApp` class is created. This is the main class of the application and will
    contain the tools, functions, elements, and layouts for these elements, as well
    as additional features. This class will inherit the `UTools` and `UWid` classes
    in order to realize their functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instructions such as `if __name__ == "__main__"` specify whether this file
    will run from the cmd/Terminal or in another way, such as an executable script.
    The `__name__` variable will contain the `"__main__"` value, and instructions
    to the `if` statement will be realized. In other cases, if the classes, functions,
    or variables of this file are imported into another application or code, these
    instructions will not be realized, and the imported code will be used as an element
    in another construction that implies the OOP approach. These instructions are
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`import sys`—this is how you import the `sys` module from the standard Python
    library. The `sys` module provides access to the variables and functions that
    are used, maintained, or interact with the Python interpreter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing `QtWidgets`, `QtGui`, and `QtCore`—these most commonly used modules
    for creating the application, adding graphical elements, working with features
    such as images, colors, and fonts, and core functions to provide functionality,
    such as events, signals and slots, and configuration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declaration of the object of the `QApplication` class from the `QtWidgets`
    module: The inheritance scheme of this class is `QtCore.QObject`—`QtCore.QCoreApplication`—`QtGui.QGuiApplication`—`QtWidgets.QApplication`.
    This class provides the main settings and control flow for the GUI application.
    For any Qt GUI application, there is precisely one `QApplication` object. The
    `qApp` attribute provides access to the `QApplication` object from any place in
    the application. This object takes the `sys.argv` parameter, which is the list
    of command-line arguments that are passed to a Python script. As we can see in
    the cmd/Terminal output, this parameter has the name of the file that contains
    the script (`u_app.py`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating the class instance of the main application class with a widget and
    calling the `show()` method to visualize the widget: In the other case, if we
    do not implement the instance and do not call the `show()` method, the application
    will be created but not visualized in the GUI performance because we will not
    have a visual element (`Qwidget`, in this case). `sys.exit(app.exec_())` is the
    line that''s used to execute the application; all lines of code that follow will
    not be executed. `sys.exit()` is the `exit()` method of the `sys` module and will
    exit from Python. This means that the program will be exited if an error occurs
    or will be closed with the application window. `app.exec_()` starts the main loop
    of the application, and returns the status code (success = `0`) , such as application
    exit or the appearance of some error, that will be used with `sys.exit()`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we run the file with application definitions from the cmd/Terminal, or by
    other means, this starts the application in an infinite loop and will continue
    until the application is closed or another exit event arises. To demonstrate these
    features, let's temporarily add to the `u_app.py` file, including instructions
    to run, along with some informative lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the PyQt5 `u_app.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the PySide2 `u_app.py` file, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run these files in the cmd/Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The results in the case of the PyQt5 `u_app.py` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40836d3e-7b18-4876-af24-35e53a28f508.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results in the case of the PySide2 `u_app.py` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46d608b1-e9d3-44bd-8338-4456944d641b.png)'
  prefs: []
  type: TYPE_IMG
- en: By implementing the preceding steps, we have constructed our application!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was the final introductory chapter of this book and the final chapter of
    the first section. In this chapter, we covered the creation of the GUI application
    with the PyQt5 and PySide2 Python bindings. All of the chapters that follow will
    continue this theme. It is highly recommended that you review the code of the
    various examples regarding comparisons of the different Python bindings to the
    Qt library. This chapter included a brief description of PyQt5 and PySide, which
    may help when it comes to choosing one of these frameworks. Both bindings have
    numerous advantages and some disadvantages too.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will consider the `QWidget` and `QMainWindow` classes, which
    provide the main window and widgets window for displaying the GUI application.
  prefs: []
  type: TYPE_NORMAL
