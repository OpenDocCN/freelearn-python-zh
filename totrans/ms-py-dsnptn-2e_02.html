<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-44" class="chapter-number"><a id="_idTextAnchor046"/>2</h1>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor047"/>SOLID Principles</h1>
			<p>In the world of software engineering, principles and best practices are the backbone of a robust, maintainable, and efficient code base. In the previous chapter, we introduced the foundational principles every developer needs <span class="No-Break">to follow.</span></p>
			<p>In this chapter, we continue exploring design principles, focusing on <strong class="bold">SOLID</strong>, an acronym coined by<a id="_idIndexMarker048"/> Robert C. Martin, representing a set of five design principles he proposed, aimed at making software more understandable, flexible, <span class="No-Break">and maintainable.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><strong class="bold">Single responsibility </strong><span class="No-Break"><strong class="bold">principle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SRP</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Open-closed </strong><span class="No-Break"><strong class="bold">principle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OCP</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Liskov substitution </strong><span class="No-Break"><strong class="bold">principle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LSP</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Interface segregation </strong><span class="No-Break"><strong class="bold">principle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ISP</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Dependency inversion </strong><span class="No-Break"><strong class="bold">principle</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DIP</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>By the end of this chapter, you’ll have an understanding of these five additional design principles and how to apply them <span class="No-Break">in Python.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor048"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor049"/>SRP</h1>
			<p>The <a id="_idIndexMarker049"/>SRP is a fundamental concept in software design. It advocates that <a id="_idIndexMarker050"/>when defining a class to provide functionality, that class should have only one reason to exist and should be responsible for only one aspect of the functionality. In simpler terms, it promotes the idea that each class should have one job or responsibility, and that job should be encapsulated within <span class="No-Break">that class.</span></p>
			<p>Thus by adhering to the SRP, you are essentially striving for classes that are focused, cohesive, and specialized in their functionality. This approach plays a crucial role in enhancing the maintainability and comprehensibility of your code base. When each class has a well-defined and single purpose, it becomes easier to manage, understand, and extend <span class="No-Break">your code.</span></p>
			<p>Of course, there is no obligation for you to follow the SRP. But knowing about the principle and thinking about your code with that in mind will improve your code base <span class="No-Break">over time.</span></p>
			<p>In practice, applying <a id="_idIndexMarker051"/>the SRP often leads to smaller, more focused classes, which<a id="_idIndexMarker052"/> can be combined and composed to create complex systems while maintaining a clear and <span class="No-Break">organized structure.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The SRP is not about minimizing the number of lines of code in a class but rather about ensuring that a class has a single reason to change, reducing the likelihood of unintended side effects when <span class="No-Break">making modifications.</span></p>
			<p>Let’s go through a small example to make things <span class="No-Break">more clear.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>An example of software design following the SRP</h2>
			<p>Let’s imagine some<a id="_idIndexMarker053"/> code that you could have in many different types of applications such as content or document management tools or a specialized web app, which includes functionality to generate a PDF file and save it to disk. To help understand the SRP, let’s consider an initial version where the code does not follow this principle. In such a version, the developer would probably define a class dealing with reports, called <strong class="source-inline">Report</strong>, and would implement it in a way that makes it responsible for generating a report and also saving it to a file. The typical code for this class would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
class Report:
    def __init__(self, content):
        self.content = content
    def generate(self):
        print(f"Report content: {self.content}")
    def save_to_file(self, filename):
        with open(filename, 'w') as file:
            file.write(self.content)</pre>			<p>As you can see, the <strong class="source-inline">Report</strong> class has two responsibilities. First, generating a report, and then, saving the report’s content to <span class="No-Break">a file.</span></p>
			<p>Of course, that is fine. But design principles encourage us to think about improving things for the future, as the requirements evolve and the code grows to handle complexity and change. Here, the SRP teaches us to separate things. To adhere to the SRP, we can refactor that code to use two different classes that would each have one responsibility, <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker054"/></span><span class="No-Break">follows:</span></p>
			<ol>
				<li>Create the first class, responsible for generating the <span class="No-Break">report’s content:</span><pre class="source-code">
class Report:
    def __init__(self, content: str):
        self.content: str = content
    def generate(self):
        print(f"Report content: {self.content}")</pre></li>				<li>Create a second class to deal with the need to save the report to <span class="No-Break">a file:</span><pre class="source-code">
class ReportSaver:
    def __init__(self, report: Report):
        self.report: Report = report
    def save_to_file(self, filename: str):
        with open(filename, 'w') as file:
            file.write(self.report.content)</pre></li>				<li>To confirm that<a id="_idIndexMarker055"/> our refactored version works, let’s add the following code to make it possible to immediately <span class="No-Break">test things:</span><pre class="source-code">
if __name__ == "__main__":
    report_content = "This is the content."
    report = Report(report_content)
    report.generate()
    report_saver = ReportSaver(report)
    report_saver.save_to_file("report.txt")</pre></li>			</ol>
			<p>To recapitulate, here is the complete code, saved in the <span class="No-Break"><strong class="source-inline">ch02/srp.py</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">class Report:</strong>
    def __init__(self, content: str):
        self.content: str = content
    def generate(self):
        print(f"Report content: {self.content}")
<strong class="bold">class ReportSaver:</strong>
    def __init__(self, report: Report):
        self.report: Report = report
    def save_to_file(self, filename: str):
        with open(filename, "w") as file:
            file.write(self.report.content)
if __name__ == "__main__":
    report_content = "This is the content."
    report = Report(report_content)
    report.generate()
    report_saver = ReportSaver(report)
    report_saver.save_to_file("report.txt")</pre>			<p>To see the result of the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch02/srp.py</pre>			<p>You will get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Report content: This is the content.</strong></pre>			<p>In addition to <a id="_idIndexMarker056"/>that output, you will notice that a <strong class="source-inline">report.txt</strong> file has been created. So, everything works <span class="No-Break">as expected.</span></p>
			<p>As you can see, by following the SRP, you can achieve cleaner, more maintainable, and adaptable code, which contributes to the overall quality and longevity of your <span class="No-Break">software projects.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>OCP</h1>
			<p>The<a id="_idIndexMarker057"/> OCP is another fundamental principle in software design. It<a id="_idIndexMarker058"/> emphasizes that software entities, such as classes and modules, should be open for extension but closed for modification. What does that mean? It means that once a software entity is defined and implemented, it should not be changed to add new functionality. Instead, the entity should be extended through inheritance or interfaces to accommodate new requirements <span class="No-Break">and behaviors.</span></p>
			<p>When thinking about this principle and if you have some experience writing code for non-trivial programs, you can see how it makes sense, since modifying an entity introduces a risk of breaking some other part of the code base relying <span class="No-Break">on it.</span></p>
			<p>The OCP provides a robust foundation for building flexible and maintainable software systems. It allows developers to introduce new features or behaviors without altering the existing code base. By adhering to the OCP, you can minimize the risk of introducing bugs or unintended side effects when making changes to <span class="No-Break">your software.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor052"/>An example of design following the OCP</h2>
			<p>Consider a <strong class="source-inline">Rectangle</strong> class <a id="_idIndexMarker059"/>defined for rectangle shapes. Let’s say we add a way to calculate the area of different shapes, maybe by using a function. The hypothetical code for the definition of both the class and the function could look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
class Rectangle:
    def __init__(self, width:float, height: float):
        self.width: float = width
        self.height: float = height
def calculate_area(shape) -&gt; float:
    if isinstance(shape, Rectangle):
        return shape.width * shape.height</pre>			<p class="callout-heading">Note</p>
			<p class="callout">This code is not in the example code files. It is a hypothetical idea to start with in our thinking, and not the code you would end up using. <span class="No-Break">Keep reading.</span></p>
			<p>Given <a id="_idIndexMarker060"/>that code, if we want to add more shapes, we have to modify the <strong class="source-inline">calculate_area</strong> function. That is not ideal as we will keep coming back to change that code and that means more time testing things to <span class="No-Break">avoid bugs.</span></p>
			<p>As we aim to become good at writing maintainable code, let’s see how we could improve that code by adhering to the OCP, while extending it to support another type of shape, the circle (using a <span class="No-Break"><strong class="source-inline">Circle</strong></span><span class="No-Break"> class):</span></p>
			<ol>
				<li>Start by importing what we <span class="No-Break">will need:</span><pre class="source-code">
import math
from typing import Protocol</pre></li>				<li>Define a <strong class="source-inline">Shape</strong> protocol for an interface providing a method for the <span class="No-Break">shape’s area:</span><pre class="source-code">
class Shape(Protocol):
    def area(self) -&gt; float:
        ...</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational Design Principles</em>, to understand Python’s <strong class="source-inline">Protocol</strong> concept <span class="No-Break">and technique.</span></p>
			<ol>
				<li value="3">Define the <strong class="source-inline">Rectangle</strong> class, which conforms to the <span class="No-Break"><strong class="source-inline">Shape</strong></span><span class="No-Break"> protocol:</span><pre class="source-code">
class Rectangle:
    def __init__(self, width: float, height: float):
        self.width: float = width
        self.height: float = height
    def area(self) -&gt; float:
        return self.width * self.height</pre></li>				<li>Also define the <strong class="source-inline">Circle</strong> class, which also conforms to the <span class="No-Break"><strong class="source-inline">Shape</strong></span><span class="No-Break"> protocol:</span><pre class="source-code">
class Circle:
    def __init__(self, radius: float):
        self.radius: float = radius
    def area(self) -&gt; float:
        return math.pi * (self.radius**2)</pre></li>				<li>Implement <a id="_idIndexMarker061"/>the <strong class="source-inline">calculate_area</strong> function in such a way that adding a new shape won’t require us to <span class="No-Break">modify it:</span><pre class="source-code">
def calculate_area(shape: Shape) -&gt; float:
    return shape.area()</pre></li>				<li>Add some code for testing the <strong class="source-inline">calculate_area</strong> function on the two types of <span class="No-Break">shape objects:</span><pre class="source-code">
if __name__ == "__main__":
    rect = Rectangle(12, 8)
    rect_area = calculate_area(rect)
    print(f"Rectangle area: {rect_area}")
    circ = Circle(6.5)
    circ_area = calculate_area(circ)
    print(f"Circle area: {circ_area:.2f}")</pre></li>			</ol>
			<p>The following <a id="_idIndexMarker062"/>is the complete code for this example, saved in the <span class="No-Break"><strong class="source-inline">ch02/ocp.py</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import math
from typing import Protocol
class Shape(Protocol):
    def area(self) -&gt; float:
        ...
class Rectangle:
    def __init__(self, width: float, height: float):
        self.width: float = width
        self.height: float = height
    def area(self) -&gt; float:
        return self.width * self.height
class Circle:
    def __init__(self, radius: float):
        self.radius: float = radius
    def area(self) -&gt; float:
        return math.pi * (self.radius**2)
def calculate_area(shape: Shape) -&gt; float:
    return shape.area()
if __name__ == "__main__":
    rect = Rectangle(12, 8)
    rect_area = calculate_area(rect)
    print(f"Rectangle area: {rect_area}")
    circ = Circle(6.5)
    circ_area = calculate_area(circ)
    print(f"Circle area: {circ_area:.2f}")</pre>			<p>To see the result of this code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch02/ocp.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Rectangle area: 96</strong>
<strong class="bold">Circle area: 132.73</strong></pre>			<p>Things work fine! The <a id="_idIndexMarker063"/>main win is that we were able to define a new shape without modifying the <strong class="source-inline">calculate_area</strong> function. The new design is elegant and allows ease of maintenance thanks to following <span class="No-Break">the OCP.</span></p>
			<p>So, you have now discovered another principle you should be using daily, which promotes designs both adaptable to evolving requirements and stable for their <span class="No-Break">existing functionalities.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>LSP</h1>
			<p>The LSP <a id="_idIndexMarker064"/>is another fundamental concept in object-oriented <a id="_idIndexMarker065"/>programming. It dictates how subclasses should relate to their superclasses. According to the LSP, if a program uses objects of a superclass, then the substitution of these objects with objects of a subclass should not change the correctness and expected behavior of <span class="No-Break">the program.</span></p>
			<p>Following this principle is important for maintaining the robustness of a software system. It ensures that, when using inheritance, subclasses extend their parent classes without altering their external behavior. For example, if a function works correctly with an object of a superclass, it should also work correctly with objects of any subclass of <span class="No-Break">this superclass.</span></p>
			<p>The LSP allows developers to introduce new subclass types without the risk of breaking existing functionality. This is particularly important in large-scale systems where changes in one part can have effects on other parts of the system. By following the LSP, developers can safely modify and extend classes, knowing that their new subclasses will integrate seamlessly with the established hierarchy <span class="No-Break">and functionality.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>An example of design following the LSP</h2>
			<p>Let’s <a id="_idIndexMarker066"/>consider a <strong class="source-inline">Bird</strong> class and a <strong class="source-inline">Penguin</strong> class that <span class="No-Break">subclasses it:</span></p>
			<pre class="source-code">
class Bird:
    def fly(self):
        print("I can fly")
class Penguin(Bird):
    def fly(self):
        print("I can't fly")</pre>			<p>Then, for the needs of a hypothetical program that makes birds fly, we add a <span class="No-Break"><strong class="source-inline">make_bird_fly</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
def make_bird_fly(bird):
    bird.fly()</pre>			<p>With the<a id="_idIndexMarker067"/> current code, we can see that if we pass an instance of the <strong class="source-inline">Bird</strong> class to the function, we get the expected behavior (<strong class="source-inline">the bird will fly</strong>), whereas if we pass an instance of the <strong class="source-inline">Penguin</strong> class, we will get another behavior (<strong class="source-inline">it will not fly</strong>). You can analyze the code representing this first design provided in the <strong class="source-inline">ch02/lsp_violation.py</strong> file and run it to test this result. This shows us or at least gives us the intuition of what the LSP wants to help us avoid. So now, how could we improve the design by following <span class="No-Break">the LSP?</span></p>
			<p>To adhere to the LSP, we can refactor the code and introduce new classes to ensure that the behavior <span class="No-Break">remains consistent:</span></p>
			<ol>
				<li>We keep the <strong class="source-inline">Bird</strong> class, but we use a better method to represent the behavior we want; let’s call it <strong class="source-inline">move()</strong>. The class will now look <span class="No-Break">as follows:</span><pre class="source-code">
class Bird:
    def move(self):
        print("I'm moving")</pre></li>				<li>Then, we introduce a <strong class="source-inline">FlyingBird</strong> class and a <strong class="source-inline">FlightlessBird</strong> class, both inheriting from the <span class="No-Break"><strong class="source-inline">Bird</strong></span><span class="No-Break"> class:</span><pre class="source-code">
class FlyingBird(Bird):
    def move(self):
        print("I'm flying")
class FlightlessBird(Bird):
    def move(self):
        print("I'm walking")</pre></li>				<li>Now, the <strong class="source-inline">make_bird_move</strong> function can be defined <span class="No-Break">as follows:</span><pre class="source-code">
def make_bird_move(bird):
    bird.move()</pre></li>				<li>As usual, we add some code necessary to test <span class="No-Break">the design:</span><pre class="source-code">
if __name__ == "__main__":
    generic_bird = Bird()
    eagle = FlyingBird()
    penguin = FlightlessBird()
    make_bird_move(generic_bird)
    make_bird_move(eagle)
    make_bird_move(penguin)</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker068"/>code for this new design, saved in the <strong class="source-inline">ch02/lsp.py</strong> file, is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Bird:
    def move(self):
        print("I'm moving")
class FlyingBird(Bird):
    def move(self):
        print("I'm flying")
class FlightlessBird(Bird):
    def move(self):
        print("I'm walking")
def make_bird_move(bird):
    bird.move()
if __name__ == "__main__":
    generic_bird = Bird()
    eagle = FlyingBird()
    penguin = FlightlessBird()
    make_bird_move(generic_bird)
    make_bird_move(eagle)
    make_bird_move(penguin)</pre>			<p>To test the example, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch02/lsp.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">I'm moving</strong>
<strong class="bold">I'm flying</strong>
<strong class="bold">I'm walking</strong></pre>			<p>This output<a id="_idIndexMarker069"/> confirms the result we wanted to get in terms of design, which is maintaining the program’s correctness when substituting a generic <strong class="source-inline">Bird</strong> class with a <strong class="source-inline">Penguin</strong> class or with an <strong class="source-inline">Eagle</strong> class; that is, each object moves whether it is an instance of a <strong class="source-inline">Bird</strong> class or an instance of a subclass. And that result was possible thanks to following <span class="No-Break">the LSP.</span></p>
			<p>This <a id="_idIndexMarker070"/>example demonstrates that all subclasses (<strong class="source-inline">FlyingBird</strong> and <strong class="source-inline">FlightlessBird</strong>) can be used in place of their superclass (<strong class="source-inline">Bird</strong>) without disrupting the expected behavior of the program. This conforms to <span class="No-Break">the LSP.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/>ISP</h1>
			<p>The ISP <a id="_idIndexMarker071"/>advocates for designing smaller, more specific<a id="_idIndexMarker072"/> interfaces rather than broad, general-purpose ones. This principle states that a class should not be forced to implement interfaces it does not use. In the context of Python, this implies that a class shouldn’t be forced to inherit and implement methods that are irrelevant to <span class="No-Break">its purpose.</span></p>
			<p>The ISP suggests that when designing software, one should avoid creating large, monolithic interfaces. Instead, the focus should be on creating smaller, more focused interfaces. This allows classes to only inherit or implement what they need, ensuring that each class only contains relevant and <span class="No-Break">necessary methods.</span></p>
			<p>Following this principle helps us build software with modularity, code readability and maintainability qualities, reduced side effects, and software that benefits from easier refactoring and testing, among <span class="No-Break">other things.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>An example of design following the ISP</h2>
			<p>Let’s <a id="_idIndexMarker073"/>consider an <strong class="source-inline">AllInOnePrinter</strong> class that implements functionalities for printing, scanning, and faxing documents. The definition for that class would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
class AllInOnePrinter:
    def print_document(self):
        print("Printing")
    def scan_document(self):
        print("Scanning")
    def fax_document(self):
        print("Faxing")</pre>			<p>If we wanted to introduce a specialized <strong class="source-inline">SimplePrinter</strong> class that only prints, it would have to implement or inherit the <strong class="source-inline">scan_document</strong> and <strong class="source-inline">fax_document</strong> methods (even though it only prints). That is <span class="No-Break">not ideal.</span></p>
			<p>To adhere to the ISP, we can create a separate interface for each functionality so that each class <a id="_idIndexMarker074"/>implements only the interfaces <span class="No-Break">it needs.</span></p>
			<p class="callout-heading">Note about interfaces</p>
			<p class="callout">Refer to the presentation in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational Design Principles</em>, of the <strong class="bold">program to interfaces, not implementations principle</strong>, to understand the importance of interfaces and the techniques we use in Python to define them (abstract base classes, protocols, etc.). In particular, here is the situation where protocols are the natural answer, that is, they help define small interfaces where each interface is created for doing only <span class="No-Break">one thing.</span></p>
			<ol>
				<li>Let’s start by defining the <span class="No-Break">three interfaces:</span><pre class="source-code">
from typing import Protocol
class Printer(Protocol):
    def print_document(self):
        ...
class Scanner(Protocol):
    def scan_document(self):
        ...
class Fax(Protocol):
    def fax_document(self):
        ...</pre></li>				<li>Then, we keep the <strong class="source-inline">AllInOnePrinter</strong> class, which already implements <span class="No-Break">the interfaces:</span><pre class="source-code">
class AllInOnePrinter:
    def print_document(self):
        print("Printing")
    def scan_document(self):
        print("Scanning")
    def fax_document(self):
        print("Faxing")</pre></li>				<li>We add <a id="_idIndexMarker075"/>the <strong class="source-inline">SimplePrinter</strong> class, implementing the <strong class="source-inline">Printer</strong> interface, <span class="No-Break">as follows:</span><pre class="source-code">
class SimplePrinter:
    def print_document(self):
        print("Simply Printing")</pre></li>				<li>We also add a function that, when passed an object that implements the <strong class="source-inline">Printer</strong> interface, calls the right method on it to do <span class="No-Break">the printing:</span><pre class="source-code">
def do_the_print(printer: Printer):
    printer.print_document()</pre></li>				<li>Finally, we <a id="_idIndexMarker076"/>add code for testing the classes and the <span class="No-Break">implemented interfaces:</span><pre class="source-code">
if __name__ == "__main__":
    all_in_one = AllInOnePrinter()
    all_in_one.scan_document()
    all_in_one.fax_document()
    do_the_print(all_in_one)
    simple = SimplePrinter()
    do_the_print(simple)</pre></li>			</ol>
			<p>Here is the complete code for this new <span class="No-Break">design (</span><span class="No-Break"><strong class="source-inline">ch02/isp.py</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
from typing import Protocol
class Printer(Protocol):
    def print_document(self):
        ...
class Scanner(Protocol):
    def scan_document(self):
        ...
class Fax(Protocol):
    def fax_document(self):
        ...
class AllInOnePrinter:
    def print_document(self):
        print("Printing")
    def scan_document(self):
        print("Scanning")
    def fax_document(self):
        print("Faxing")
class SimplePrinter:
    def print_document(self):
        print("Simply Printing")
def do_the_print(printer: Printer):
    printer.print_document()
if __name__ == "__main__":
    all_in_one = AllInOnePrinter()
    all_in_one.scan_document()
    all_in_one.fax_document()
    do_the_print(all_in_one)
    simple = SimplePrinter()
    do_the_print(simple)</pre>			<p>To test this code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch02/isp.py</pre>			<p>You will <a id="_idIndexMarker077"/>get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Scanning</strong>
<strong class="bold">Faxing</strong>
<strong class="bold">Printing</strong>
<strong class="bold">Simply Printing</strong></pre>			<p>Because of the new design, each class only needs to implement the methods relevant to its behavior. This illustrates <span class="No-Break">the ISP.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>DIP</h1>
			<p>The DIP<a id="_idIndexMarker078"/> advocates that high-level modules should not depend <a id="_idIndexMarker079"/>directly on low-level modules. Instead, both should depend on abstractions or interfaces. By doing so, you decouple the high-level components from the details of the <span class="No-Break">low-level components.</span></p>
			<p>This principle allows for the reduction of the coupling between different parts of the system you are building, making it more maintainable and extendable, as we will see in <span class="No-Break">an example.</span></p>
			<p>Following the DIP brings loose coupling within a system because it encourages the use of interfaces as intermediaries between different parts of the system. When high-level modules depend on interfaces, they remain isolated from the specific implementations of low-level modules. This separation of concerns enhances maintainability <span class="No-Break">and extensibility.</span></p>
			<p>In essence, the DIP<a id="_idIndexMarker080"/> is closely linked to the loose coupling principle, which was covered in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational Design Principles</em>, by promoting a <a id="_idIndexMarker081"/>design where components interact through interfaces rather than concrete implementations. This reduces the interdependencies between modules, making it easier to modify or extend one part of the system without <span class="No-Break">affecting others.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>An example of design following the ISP</h2>
			<p>Consider<a id="_idIndexMarker082"/> a <strong class="source-inline">Notification</strong> class responsible for sending notifications via email, using an <strong class="source-inline">Email</strong> class. The code for both classes would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">class Email:</strong>
    def send_email(self, message):
        print(f"Sending email: {message}")
<strong class="bold">class Notification:</strong>
    def __init__(self):
        self.email = Email()
    def send(self, message):
        self.email.send_email(message)</pre>			<p class="callout-heading">Note about the code</p>
			<p class="callout">This is not yet the final version of <span class="No-Break">the example.</span></p>
			<p>Currently, the high-level <strong class="source-inline">Notification</strong> class is dependent on the low-level <strong class="source-inline">Email</strong> class, and that is not ideal. To adhere to the DIP, we can introduce an abstraction, with a new code, <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Define a <span class="No-Break"><strong class="source-inline">MessageSender</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
from typing import Protocol
class MessageSender(Protocol):
    def send(self, message: str):
        ...</pre></li>				<li>Define<a id="_idIndexMarker083"/> the <strong class="source-inline">Email</strong> class, which implements the <strong class="source-inline">MessageSender</strong> interface, <span class="No-Break">as follows:</span><pre class="source-code">
class Email:
    def send(self, message: str):
        print(f"Sending email: {message}")</pre></li>				<li>Define the <strong class="source-inline">Notification</strong> class, which also implements the <strong class="source-inline">MessageSender</strong> interface, and has an object that implements <strong class="source-inline">MessageSender</strong> stored in its <strong class="source-inline">sender</strong> attribute, for handling the actual message sending. The code for that definition is <span class="No-Break">as follows:</span><pre class="source-code">
class Notification:
    def __init__(self, sender: MessageSender):
        self.sender: MessageSender = sender
    def send(self, message: str):
        self.sender.send(message)</pre></li>				<li>Finally, add some code for testing <span class="No-Break">the design:</span><pre class="source-code">
if __name__ == "__main__":
    email = Email()
    notif = Notification(sender=email)
    notif.send(message="This is the message.")</pre></li>			</ol>
			<p>The complete code for<a id="_idIndexMarker084"/> the implementation we just proposed is as <span class="No-Break">follows (</span><span class="No-Break"><strong class="source-inline">ch02/dip.py</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
from typing import Protocol
class MessageSender(Protocol):
    def send(self, message: str):
        ...
class Email:
    def send(self, message: str):
        print(f"Sending email: {message}")
class Notification:
    def __init__(self, sender: MessageSender):
        self.sender = sender
    def send(self, message: str):
        self.sender.send(message)
if __name__ == "__main__":
    email = Email()
    notif = Notification(sender=email)
    notif.send(message="This is the message.")</pre>			<p>To test the code, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">python ch02/dip.py</strong></pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Sending email: This is the message.</strong></pre>			<p>As you see, with <a id="_idIndexMarker085"/>the updated design, both <strong class="source-inline">Notification</strong> and <strong class="source-inline">Email</strong> are based on the <strong class="source-inline">MessageSender</strong> abstraction, so this design adheres to <span class="No-Break">the DIP.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Summary</h1>
			<p>In this chapter, we explored additional principles to the ones presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational Design Principles</em>. Understanding and applying SOLID is crucial for writing maintainable, robust, and scalable Python code. These principles provide a strong foundation for good software design, making it easier to manage complexity, reduce errors, and improve the overall quality of <span class="No-Break">your code.</span></p>
			<p>In the next chapter, we will start exploring design patterns in Python, another essential topic for Python developers aiming <span class="No-Break">for excellence.</span></p>
		</div>
	

		<div id="_idContainer009" class="Content">
			<h1 id="_idParaDest-58" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor060"/>Part 2: From the Gang of Four</h1>
			<p>This part explores the classic design patterns from the Gang of Four (GoF), which are used to solve everyday problems, and how to apply them as a Python developer. This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21896_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Creational Design Patterns</em></li>
				<li><a href="B21896_04.xhtml#_idTextAnchor088"><em class="italic">Chapter 4</em></a>, <em class="italic">Structural Design Patterns</em></li>
				<li><a href="B21896_05.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Behavioral Design Patterns</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer010" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>