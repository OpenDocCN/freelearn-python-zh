<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Working with Python Modules</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Python Modules</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will talk about Python modules, specifically covering the following topics:</p>
<ul>
<li>Using and importing modules and namespaces</li>
<li>Implementing virtual Python environments</li>
<li>Python package installation options</li>
<li>Utilizing requirement files and resolving conflicts</li>
<li>Using local patches and constraint files</li>
<li>Working with packages</li>
<li>Creating wheels and bundles</li>
<li>Comparing source code to bytecode</li>
<li>How to create and reference module packages</li>
<li>Operating system-specific binaries</li>
<li>How to upload programs to PyPI</li>
<li>Project packaging</li>
<li>Uploading to PyPI</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Python modules are the highest-level components of Python programs. As suggested by their name, modules are modular, capable of being plugged in with other modules as part of an overall program to provide better separation of code while combining together to create a cohesive application.</p>
<p class="mce-root">Modules allow easy reuse of code, and provide separate namespaces to prevent variable shadowing between blocks of code. Variable shadowing involves having duplicate variables in different namespaces, possibly causing the interpreter to use an incorrect variable. Each Python file a developer creates is considered a separate module, allowing different files to be imported into a single, overall file that forms the final application.</p>
<p>Realistically, any Python file can be made a module by simply removing the <kbd>.py</kbd> extension; this is most commonly seen when importing libraries. Python packages are collections of modules; what makes a package special is the inclusion of an <kbd>__init__.py</kbd> file. We will cover the differences in detail later, so for now just recognize that there are several names for the same items.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using and importing modules and namespaces</h1>
                </header>
            
            <article>
                
<p class="mce-root">A key point with modules is that they produce separate namespaces. A namespace (also called a <strong>scope</strong>) is simply the domain of control that a module, or component of a module, has. Normally, objects within a module are not visible outside that module, that is, attempting to call a variable located in a separate module will produce an error.</p>
<p class="mce-root">Namespaces are also used to segregate objects within the same program. For example, a variable defined within a function is only visible for use while operating within that function. Attempting to call that variable from another function will result in an error. This is why global variables are available; they can be called by any function and interacted with. This is also why global variables are frowned upon as a best practice because of the possibility of modifying a global variable without realizing it, causing a breakage later on in the program.</p>
<p class="mce-root">Scope essentially works inside-out. If a variable is called for use in a function, the Python interpreter will first look within that function for the variable's declaration. If it's not there, Python will move up the stack and look for a globally-defined variable. If not found there, Python will look in the built-in libraries that are always available. If still not found, Python will throw an error. In terms of flow, it looks something like this: <em>local scope</em> -&gt; <em>global scope</em> -&gt; <em>built-in module</em> -&gt; <em>error</em>.</p>
<p>One slight change to the scope discovery process comes when importing modules. Imported modules will be examined for object calls as well, with the caveat that an error will still be generated unless the desired object is explicitly identified via dot-nomenclature.</p>
<p>For example, if you want to generate a random number between 0 and 1,000, you can't just call the <kbd class="western">randint()</kbd> function without importing the <kbd class="western">random</kbd> library. Once a module is imported, any publicly available classes, methods, functions, and variables can be used by expressly calling them with <kbd>&lt;module_name&gt;</kbd> and <kbd>&lt;object_name&gt;</kbd><em>.</em> Following is an example of this:</p>
<pre><strong>&gt;&gt;&gt; randint(0, 1000)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'randint' is not defined
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.randint(0, 1000)
607</strong></pre>
<p>In the preceding example, <kbd>randint()</kbd> is first called on its own. Since it is not part of the normal Python built-in functions, the interpreter knows nothing about it, thus throwing an error.</p>
<p>However, after importing the <kbd>random</kbd> library that actually contains the various random number generation functions, <kbd>randint()</kbd> can then be explicitly called via dot-nomenclature, that is, <kbd>random.randint()</kbd>. This tells the Python interpreter to look for <kbd>randint()</kbd> within the <kbd>random</kbd> library, resulting in the desired result.</p>
<p>To clarify, when importing modules into a program, Python assumes some things about namespaces. If a normal import is performed, that is, <kbd>import foo</kbd>, then both the main program and <kbd>foo</kbd> maintain their separate namespaces. To use a function within the <kbd>foo</kbd> module, you have to expressly identify it using dot-nomenclature: <kbd>foo.bar()</kbd>.</p>
<p>On the other hand, if part of a module is imported, for example, <kbd>from foo import bar</kbd>, then that imported component becomes a part of the main program's namespace. This also happens if all components are imported using a wildcard: <kbd>from foo import *</kbd>.</p>
<p><span><span>The following&#160;example</span></span> shows these properties in action:</p>
<pre><strong>&gt;&gt;&gt; from random import randint
&gt;&gt;&gt; randint(0, 10)
2
&gt;&gt;&gt; randrange(0, 25)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'randrange' is not defined</strong></pre>
<p>In the preceding example, the <kbd class="western">randint()</kbd> function from the <kbd>random</kbd> module is expressly imported by itself; this importation puts <kbd>randint()</kbd> within the main program's namespace. This allows <kbd>randint()</kbd> to be called without having to clarify it as <kbd>random.randint()</kbd>. However, when attempting to do the same thing with the <kbd>randrange()</kbd> function, an error occurs because it wasn't imported.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">To illustrate scope, we will create nested functions, where a function is defined and then called within an enclosing function:</p>
<ol>
<li><kbd>nested_functions.py</kbd>&#160;includes a nested function, and ends with calling the nested function:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def first_funct():</strong><br/><strong>      ...    x = 1</strong><br/><strong>      ...    print(x)</strong><br/><strong>      ...    def second_funct():</strong><br/><strong>      ...        x = 2</strong><br/><strong>      ...        print(x)</strong><br/><strong>      ...    second_funct()</strong><br/><strong>      ...</strong></pre>
<ol start="2">
<li>First, call the parent function&#160;and checks the results:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; first_funct()</strong><br/><strong>      1</strong><br/><strong>      2</strong></pre>
<ol start="3">
<li>Next, call the nested function directly and notice that an error is received<span>:</span></li>
</ol>
<pre><strong>      &gt;&gt;&gt; second_funct()</strong><br/><strong>      Traceback (most recent call last):</strong><br/><strong>      File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>      NameError: name 'second_funct' is not defined</strong></pre>
<ol start="4">
<li>To work with another module, import the desired module:</li>
</ol>
<pre class="mce-root"><strong>      &gt;&gt;&gt; import math</strong></pre>
<ol start="5">
<li>Below, we call the&#160;<kbd>sin()</kbd> function&#160;from within the module in the form <kbd class="western">&lt;module&gt;.&lt;function&gt;</kbd>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; math.sin(45)</strong><br/><strong>      0.8509035245341184</strong></pre>
<ol start="6">
<li class="mce-root">Try calling a function, as demonstrated below,&#160;without using the dot-nomenclature to specify its library package results in an error:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; sin(45)
      Traceback (most recent call last):
        File "&lt;stdin&gt;", line 1, in &lt;module&gt;
       NameError: name 'sin' is not defined</strong></pre>
<ol start="7">
<li>Alternatively, the example below shows how to&#160;import all items from a module using the <kbd>*</kbd> wildcard to place the items within the current program's namespace:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from math import *
      &gt;&gt;&gt; sin(45)
      0.8509035245341184</strong></pre>
<ol start="8">
<li>A common way to run modules as scripts is to simply call the module explicitly from the command line, providing any arguments as necessary. This can be set up by configuring the module to accept command-line arguments, as shown in <kbd>print_funct.py</kbd>: <strong><strong><br/></strong></strong></li>
</ol>
<pre>        def print_funct(arg):
            print(arg)
            if __name__ == "__main__":
                import sys
                print_funct(sys.argv[1])</pre>
<ol start="9">
<li><kbd>print_mult_args.py</kbd> shows that, if more than one argument is expected, and the quantity is known, each one can be specified using its respective index values in the arguments list:</li>
</ol>
<pre>        def print_funct(arg1, arg2, arg3):
            print(arg1, arg2, arg3)
        if __name__ == "__main__":
            import sys
            print_funct(sys.argv[1], sys.argv[2], sys.argv[3])</pre>
<ol start="10">
<li>Alternatively, where the function can capture multiple arguments but the quantity is unknown, the <kbd>*args</kbd> parameter can be used, as shown below:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def print_input(*args):
      ...   for val, input in enumerate(args):
      ...       print("{}. {}".format(val, input))
      ...
      &gt;&gt;&gt; print_input("spam", "spam", "eggs", "spam")
      0. spam
      1. spam
      2. eggs
      3. spam</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The location of a named assignment within the code determines its namespace visibility. In the preceding example, steps 1-3, if you directly call <kbd>second_funct()</kbd> immediately after calling <kbd>first_funct()</kbd>, you'll get an error stating <kbd>second_funct()</kbd> is not defined. This is true, because globally, the second function doesn't exist; it's nested within the first function and can't be seen outside the first function's scope. Everything within the first function is part of its namespace, just as the value for <kbd>x</kbd> within the second function can't be called directly but has to use the <kbd>second_funct()</kbd> call to get its value.</p>
<p>In the preceding examples, step 4-7, the <kbd class="western">math</kbd> module is imported in its entirety, but it keeps its own namespace. Thus, calling <kbd>math.sin()</kbd> provides a result, but calling <kbd class="western">sin()</kbd> by itself results in an error.</p>
<p>Then, the <kbd class="western">math</kbd> module is imported using a wildcard. This tells the Python interpreter to import all the functions into the main namespace, rather than keeping them within the separate <kbd class="western">math</kbd> namespace. This time, when <kbd class="western">sin()</kbd> is called by itself, it provides the correct answer.</p>
<p>This demonstrates the point that namespaces are important to keep code separated while allowing the use of the same variables and function names. By using dot-nomenclature, the exact object can be called with no fear of name shadowing causing the wrong result to be provided.</p>
<p>In preceding examples, steps 7-10, using <kbd class="western">sys.argv()</kbd> allows Python to parse command-line arguments and places them in a list for use. <kbd class="western">sys.argv([0])</kbd> is always the name of the program taking the arguments, so it can be safely ignored. All other arguments are stored in a list and can, therefore, be accessed by their index value.</p>
<p>Using <kbd class="western">*args</kbd> tells Python to accept any number of arguments, allowing the program to accept a varying number of input values. An alternative version, <kbd class="western">**kwargs</kbd>, does the same thing but with keyword:value pairs.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">In addition to knowing about namespaces, there are some other important terms to know about when installing and working with modules:</p>
<ul>
<li class="mce-root"><a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a> is the primary database for third-party Python packages.</li>
<li class="mce-root"><kbd>pip</kbd> is the primary installer program for third-party modules and, since Python 3.4, has been included by default with Python binary installations.</li>
<li class="mce-root">A virtual Python environment allows packages to be installed for a particular application's development, rather than being installed system-wide.</li>
<li class="mce-root"><kbd>venv</kbd> has been the primary tool for creating virtual Python environments since Python 3.3. With Python 3.4, it automatically installs <kbd>pip</kbd> and <kbd>setuptools</kbd> in all virtual environments.</li>
<li>The following are common terms for Python files: module, package, library, and distribution. While they have distinct definitions (<a href="https://packaging.python.org/glossary/">https://packaging.python.org/glossary/</a>), this book will use them interchangeably at times.</li>
</ul>
<p>The following is part of <kbd>dice_roller.py</kbd>,&#160;an example of embedded tests from one of the first Python programs this author wrote when first learning Python:</p>
<pre>import random
def randomNumGen(choice):
    if choice == 1: #d6 roll
        die = random.randint(1, 6)
    elif choice == 2: #d10 roll
        die = random.randint(1, 10)
    elif choice == 3: #d100 roll
        die = random.randint(1, 100)
    elif choice == 4: #d4 roll
      die = random.randint(1, 4)
    elif choice == 5: #d8 roll
      die = random.randint(1, 8)
    elif choice == 6: #d12 roll
      die = random.randint(1, 12)
    elif choice == 7: #d20 roll
      die = random.randint(1, 20)
    else: #simple error message
        return "Shouldn't be here. Invalid choice"
    return die
if __name__ == "__main__":
    import sys
    print(randomNumGen(int(sys.argv[1])))</pre>
<p>In this example, we are simply creating a random number generator that simulates rolling different polyhedral dice (commonly used in role-playing games). The <kbd class="western">random</kbd> library is imported, then the function defining how the dice rolls are generated is created. For each die roll, the integer provided indicates how many sides the die has. With this method, any number of possible values can be simulated with a single integer input.</p>
<p>The key part of this program is at the end. The part <kbd class="western">if __name__ == "__main__"</kbd> tells Python that, if the namespace for the module is <kbd>main</kbd>, that is, it is the main program and not imported into another program, then the interpreter should run the code below this line. Otherwise, when imported, only the code above this line is available to the main program. (It's also worth noting that this line is necessary for cross-platform compatibility with Windows.)</p>
<p>When this program is called from the command line, the <kbd class="western">sys</kbd> library is imported. Then, the first argument provided to the program is read from the command line and passed into the <kbd class="western">randomNumGen()</kbd> function as an argument. The result is printed to the screen. Following are some examples of results from this program:</p>
<pre><strong>$ python3 dice_roller.py 1
2
$ python3 dice_roller.py 2
10
$ python3 dice_roller.py 3
63
$ python3 dice_roller.py 4
2
$ python3 dice_roller.py 5
5
$ python3 dice_roller.py 6
6
$ python3 dice_roller.py 7
17
$ python3 dice_roller.py 8
Shouldn't be here. Invalid choice</strong></pre>
<p>Configuring a module in this manner is an easy way to allow a user to interface directly with the module on a stand-alone basis. It is also a great way to run tests on the script; the tests are only run when the file is called as a stand-alone, otherwise the tests are ignored. <kbd>dice_roller_tests.py</kbd> is the full dice-rolling simulator that this author wrote:</p>
<pre>import random #randint
def randomNumGen(choice):
    """Get a random number to simulate a d6, d10, or d100 roll."""
    
    if choice == 1: #d6 roll
      die = random.randint(1, 6)
    elif choice == 2: #d10 roll
        die = random.randint(1, 10)
    elif choice == 3: #d100 roll
        die = random.randint(1, 100)
    elif choice == 4: #d4 roll
      die = random.randint(1, 4)
    elif choice == 5: #d8 roll
      die = random.randint(1, 8)
    elif choice == 6: #d12 roll
      die = random.randint(1, 12)
    elif choice == 7: #d20 roll
      die = random.randint(1, 20)
    else: #simple error message
        return "Shouldn't be here. Invalid choice"
    return die
def multiDie(dice_number, die_type):
    """Add die rolls together, e.g. 2d6, 4d10, etc."""
    
#---Initialize variables 
    final_roll = 0
    val = 0
    
    while val &lt; dice_number:
        final_roll += randomNumGen(die_type)
        val += 1
    return final_roll
def test():
    """Test criteria to show script works."""
    
    _1d6 = multiDie(1,1) #1d6
    print("1d6 = ", _1d6, end=' ') 
    _2d6 = multiDie(2,1) #2d6
    print("\n2d6 = ", _2d6, end=' ')
    _3d6 = multiDie(3,1) #3d6
    print("\n3d6 = ", _3d6, end=' ')
    _4d6 = multiDie(4,1) #4d6
    print("\n4d6 = ", _4d6, end=' ')
    _1d10 = multiDie(1,2) #1d10
    print("\n1d10 = ", _1d10, end=' ')
    _2d10 = multiDie(2,2) #2d10
    print("\n2d10 = ", _2d10, end=' ')
    _3d10 = multiDie(2,2) #3d10
    print("\n3d10 = ", _3d10, end=' ')
    _d100 = multiDie(1,3) #d100
    print("\n1d100 = ", _d100, end=' ') 
    
if __name__ == "__main__": #run test() if calling as a separate program
    test()</pre>
<p>This program builds on the previous random-dice program by allowing multiple dice to be added together. In addition, the <kbd class="western">test()</kbd> function only runs when the program is called by itself to provide a sanity check of the code. The <kbd>test</kbd> function would probably be better if it wasn't in a function with the rest of the code, as it is still accessible when the module is imported, as shown below:</p>
<pre><strong>&gt;&gt;&gt; import dice_roller_tests.py
&gt;&gt;&gt; dice_roller_tests.test()
1d6 = 1 
2d6 = 8 
3d6 = 10 
4d6 = 12 
1d10 = 5 
2d10 = 8 
3d10 = 6 
1d100 = 26</strong></pre>
<p>So, if you have any code you don't want to be accessible when the module is imported, make sure to include it <em>below the line</em>, as it were.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing virtual Python environments</h1>
                </header>
            
            <article>
                
<p class="mce-root">As touched on previously, Python virtual environments create separate Python environments, much like virtual machines allow multiple but separate operating systems. Python virtual environments are particularly useful when installing multiple<br/>
instances of the same module.</p>
<p class="mce-root">For example, assume you are working on a project that requires version 1.2 of a particular library module for legacy support. Now assume you download a Python program that uses version 2.2 of the same library. If you install everything in the default global location on your hard drive, for example, <kbd>/usr/lib/python3.6/site-packages</kbd>, the new program will install the updated library into the same location, overwriting the legacy software. Since you were using an old library for legacy support, there's a good chance that the updated library will break your application.</p>
<p class="mce-root">Also, on shared systems (especially if you don't have admin rights), there is a strong possibility that you simply can't install modules on the system, at least not in the default global <kbd>site-packages</kbd> directory. You may luck out and be able to install software for your account but, if you can't, you have to either request permission to install it or go without.</p>
<p class="mce-root">This is where virtual Python environments come into play. Each environment has its own installation directories and there is no sharing of libraries between environments. This means that each version of a module within an environment stays the same, even if you update global libraries. It also means you can have multiple versions of modules installed on your computer at the same time without having conflicts.</p>
<p>Virtual environments have their own shells as well, allowing access to an OS shell that is independent of any other environment or the underlying operating system. This recipe also shows how to spawn a new Python shell from <kbd class="western">pipenv</kbd>. Doing this ensures all commands will have access to the installed packages within the virtual environment.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">The old way to manage virtual environments was with the <kbd>venv</kbd> tool. To install it, use the command&#160;<kbd>sudo apt install python3-venv</kbd>.</p>
<p class="mce-root">To manage virtual environments in a modern way, the <kbd>pipenv</kbd> module (<a href="https://docs.pipenv.org/">https://docs.pipenv.org/</a>) was developed; it automatically creates and manages virtual environments for projects, as well as adding and removing packages from <kbd>Pipfile</kbd> when you install/uninstall packages. It can be installed using&#160;<kbd>pip install pipenv</kbd>.</p>
<p class="mce-root"><kbd>Pipfile</kbd> is an alternative to <kbd>requirements.txt</kbd>, which is used to specify exact versions of modules to include in a program. <kbd>Pipfile</kbd> actually comprises two separate files: <kbd>Pipfile</kbd> and (optionally) <kbd>Pipfile.lock</kbd>. <kbd>Pipfile</kbd> is simply a listing of the source location of imported modules, the module names themselves (defaulting to the most recent version), and any development packages that are required. <kbd>pipfile.py</kbd>, below, is an example of a <kbd>Pipfile</kbd> from the Pipenv site (<a href="https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock">https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock</a>):</p>
<pre>[[source]]
url = "https://pypi.python.org/simple"
verify_ssl = true
name = "pypi"

[packages]
requests = "*"


[dev-packages]
pytest = "*"</pre>
<p class="mce-root"><kbd>Pipfile.lock</kbd> takes the <kbd>Pipfile</kbd> and sets actual version numbers to all the packages, as well as identifying specific hashes for those files. Hashed values are beneficial to minimize security risks; that is, if a particular module version has a vulnerability, its hash value allows it to be easily identified, rather than having to search by version name or some other method. <kbd>pipfile_lock.py</kbd>, below, is an example of a <kbd>Pipfile.lock</kbd> file from the Pipenv site (<a href="https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock">https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock</a>):</p>
<pre>{
  "_meta": {
    "hash": {
      "sha256": "8d14434df45e0ef884d6c3f6e8048ba72335637a8631cc44792f52fd20b6f97a"
    },
    "host-environment-markers": {
      "implementation_name": "cpython",
      "implementation_version": "3.6.1",
      "os_name": "posix",
      "platform_machine": "x86_64",
      "platform_python_implementation": "CPython",
      "platform_release": "16.7.0",
      "platform_system": "Darwin",
      "platform_version": "Darwin Kernel Version 16.7.0: Thu Jun 15 17:36:27 PDT 2017; root:xnu-3789.70.16~2/RELEASE_X86_64",
      "python_full_version": "3.6.1",
      "python_version": "3.6",
      "sys_platform": "darwin"
    },
    "pipfile-spec": 5,
    "requires": {},
    "sources": [
      {
        "name": "pypi",
        "url": "https://pypi.python.org/simple",
        "verify_ssl": true
      }
    ]
  },
  "default": {
    "certifi": {
      "hashes": [
        "sha256:54a07c09c586b0e4c619f02a5e94e36619da8e2b053e20f594348c0611803704",
        "sha256:40523d2efb60523e113b44602298f0960e900388cf3bb6043f645cf57ea9e3f5"
      ],
      "version": "==2017.7.27.1"
    },
    "chardet": {
      "hashes": [
         "sha256:fc323ffcaeaed0e0a02bf4d117757b98aed530d9ed4531e3e15460124c106691",
         "sha256:84ab92ed1c4d4f16916e05906b6b75a6c0fb5db821cc65e70cbd64a3e2a5eaae"
      ],
      "version": "==3.0.4"
    },<br/>***further entries truncated***</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The original, normal way to create a virtual environment comprises three separate steps. First, the virtual environment is created:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; python3 -m venv &lt;dir_name&gt;</strong></pre>
<ol start="2">
<li>Next, the virtual environment is activated so it can be used:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; source &lt;dir_name&gt;/bin/activate</strong></pre>
<ol start="3">
<li>Finally, <kbd>pip</kbd> is used to install the necessary module:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; pip install &lt;module&gt;</strong></pre>
<ol start="4">
<li>To make this process easier, <kbd>pipenv</kbd> combines the <kbd>pip</kbd> and <kbd>venv</kbd> calls, so first we have to move to the desired directory where the virtual environment will be placed:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; cd &lt;project_name&gt;</strong></pre>
<ol start="5">
<li>Next, we simply call <kbd>pipenv</kbd> to create the environment and install the desired module:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; pipenv install &lt;module&gt;</strong></pre>
<ol start="6">
<li>Use <kbd class="western">pipenv</kbd> to call the <kbd class="western">shell</kbd> command and wait for the shell to be created. Observe that a virtual environment has been created and the command prompt is now activated within the environment. The following screenshot includes the commands from the previous steps, for clarity:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/b58c3a4e-9285-46d1-aa4d-57aa5414ef5b.png" style="width:40.33em;height:29.08em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The preceding <kbd>pipenv</kbd> example shows the developer changing to the desired directory for the project, and then invoking <kbd>pipenv</kbd> to simultaneously create the virtual environment, activate it, and install the desired module.</p>
<p class="mce-root">In addition to creating the virtual environment, once you have created your Python program, you can run the program using <kbd>pipenv</kbd> as well:</p>
<pre class="mce-root"><strong>&gt;&gt;&gt; pipenv run python3 &lt;program_name&gt;.py</strong></pre>
<p>Doing this ensures all installed packages in the virtual environment are available to&#160;your program, thus reducing the likelihood of unexpected errors.</p>
<p>When launching a <kbd class="western">pipenv shell</kbd>, a new virtual environment is created, with indications of where the environment is created in the file system. In this case, two environment executables are created, referencing both the Python 3.6 command and the default Python command. (Depending on the systems, these may actually reference different versions of Python. For example, the default Python command may call the Python 2.7 environment instead of Python 3.6.)</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>On a side note, the <kbd>-m</kbd> option indicates that Python is to run the module as a stand-alone script, that is, its contents will be ran within the <kbd>__main__</kbd> namespace. Doing this means you don't have to know the full path to the module, as Python will look for the script in <kbd>sys.path</kbd>. In other words, for modules that you would normally import into another Python file can be run directly from the command line.</p>
<p>In the example of running <kbd>pipenv</kbd>, the command takes advantage of the fact that Python allows the <kbd>-m</kbd> option to run a module directly or allow it to be imported; in this case, <kbd>pipenv</kbd> imports <kbd>venv</kbd> to create the virtual environment as part of the creation process.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Python package installation options</h1>
                </header>
            
            <article>
                
<p>Installing packages normally happens by looking at&#160;<a href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a> for the desired module, but <kbd>pip</kbd> supports installing from version control, local projects, and from distribution files as well.</p>
<p>Python <em>wheels</em> are pre-built archives that can speed up the package installation process compared to installing from source files. They can be compared to installing pre-made binary applications for an operating system rather than building and installing source files.</p>
<p>Wheels were developed to replace Python <em>eggs</em>, which performed wheels' functions before the new packaging standards were developed. Wheels improve on eggs by specifying the <kbd class="western">.dist-info</kbd> directory (a database of installed Python packages that is very close to the on-disk format) and by implementing package metadata (which helps identify software dependencies).</p>
<p><kbd class="western">pip</kbd> installs from wheels whenever possible, though this feature can be disabled using <kbd class="western">pip install --no-binary</kbd>. If wheel files aren't available, <kbd class="western">pip</kbd>&#160;will look for source files. Wheels can be downloaded from PyPI manually or pulled from a local repository; just tell <kbd class="western">pip</kbd> where the local file is located.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Use <kbd>pip</kbd> to pull the latest version of the package directly from PyPI:</li>
</ol>
<pre><strong>      $ pip install &lt;package_name&gt;</strong></pre>
<ol start="2">
<li>Alternately, a specific version of the package can be downloaded:</li>
</ol>
<pre><strong>      $ pip install &lt;package_name&gt;==1.2.2</strong></pre>
<p style="padding-left: 60px">Here is an example of downgrading&#160;<kbd>pygments</kbd> from our earlier install in&#160;<kbd>pipenv</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/87e27597-4810-43b6-832b-eebcbe09d104.png" style="width:39.92em;height:13.25em;"/></div>
<ol start="3">
<li>As a final option, a minimum version of a package can be downloaded; this is common when a package has a significant change between versions:</li>
</ol>
<pre><strong>      $ pip install "&lt;package_name&gt; &gt;= 1.1"<br/></strong></pre>
<ol start="4">
<li>If a PyPI package has a wheel file available, <kbd class="western">pip</kbd> will automatically download the wheel; otherwise, it will pull the source code and compile it.</li>
</ol>
<pre><strong>      $ pip install &lt;some_package&gt;</strong></pre>
<ol start="5">
<li>To install a local wheel file, provide the full path to the file:</li>
</ol>
<pre><strong>      $ pip install /local_files/SomePackage-1.2-py2.py3-none-any.whl</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The wheel file name format breaks down to <kbd class="western">&lt;package_name&gt;-&lt;version&gt;-&lt;language_version&gt;-&lt;abi_tag&gt;-&lt;platform_tag&gt;.whl</kbd>. The package name is the name of the module to be installed, followed by the version of this particular wheel file.</p>
<p>The language version refers to Python 2 or Python 3; it can be as specific as necessary, such as <kbd>py27</kbd> (any Python 2.7.x version) or <kbd>py3</kbd> (any Python 3.x.x version).</p>
<p>The <strong>ABI</strong> tag refers to the <strong>Application Binary Interface</strong>. In the past, the underlying C API (<strong>Application Programming Interface</strong>) that the Python interpreter relies on changed with every release, typically by adding API features rather than changing or removing existing APIs. The Windows OS is particularly affected, where each Python feature release creates a new name for the Python Window's DLL.</p>
<p>The ABI refers to Python's binary compatibility. While changes to Python structure definitions may not break API compatibility, ABI compatibility may be affected. Most ABI issues occur from changes in the in-memory structure layout.</p>
<p>Since version 3.2, a limited set of API features has been guaranteed to be stable for the ABI. Specifying an ABI tag allows the developer to specify which Python implementations a package is compatible with, for example, PyPy versus CPython. Generally speaking, this tag is set to <kbd>none</kbd>, implying there is no specific ABI requirement.</p>
<p>The platform tag specifies which OS and CPU the <kbd>wheel</kbd> package is designed to run. This is normally <kbd>any</kbd>, unless the wheel's developer had a particular reason to limit the package to a specific system type.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing requirement files and resolving conflicts</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, a requirements file, <kbd>requirements.txt</kbd>, can be created to provide a list of packages to install all at once, via <kbd>pip install -r requirements.txt</kbd>. The requirements file can specify specific or minimum versions, or simply specify the library name and the latest version will be installed.</p>
<p>It should be noted that files pulled from the requirements file aren't necessarily installed in a particular order. If you require certain packages to be installed prior to others, you will have to take measures to ensure that the installation is sequential, such as having multiple <kbd>pip install</kbd> calls.</p>
<p>Requirements files can specify version numbers of packages explicitly. For example, two different modules (<em>m1</em> and <em>m2</em>) both depend on a third module (<em>m3</em>). The module <em>m1</em> requires <em>m3</em> to be at least version 1.5, but <em>m2</em> requires it to be no later than version 2.0; the current version of <em>m3</em> is 2.3. In addition, the latest version of <em>m2</em> (version 1.7) is known to contain a bug.</p>
<p>Hash digests can be used in requirements files to verify downloaded packages to guard against a compromise of the PyPI database or the HTTPS certificate chain. This is actually a good thing, as in 2017 ten Python libraries (<a href="https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/">https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/</a>) uploaded to PyPI were found to be hosting malicious files.</p>
<p>Because PyPI does not perform any security checks or code auditing when packages are uploaded, it is actually very easy to upload malicious software.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p class="CDPAlignLeft CDPAlign">Manually create <kbd>requirements.txt</kbd> by typing in the packages to include in the project. The following is an example from <a href="https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format">https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format</a>:</p>
</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="font-size: 1em;color: black;width:25.83em;height:15.33em;" src="images/db110b1a-6544-408d-aad7-f5c16a4952eb.png"/></div>
<ol start="2">
<li class="mce-root"><span>Alternatively, run</span> <kbd>pip freeze &gt; requirements.txt</kbd>. This automatically directs the currently installed packages to a properly formatted requirements file.</li>
<li class="mce-root">To implement hash-checking mode, simply include the digest with the package name in the requirements file, demonstrated below:</li>
</ol>
<pre style="color: black" class="western"><strong>      FooProject == 1.2 --hash=sha256:&lt;hash_digest&gt;</strong></pre>
<div class="packt_infobox">Note: Supported hash algorithms include: md5, sha1, sha224, sha384, sha256, and sha512.</div>
<ol start="4">
<li>If there are module conflicts, or special versioning is needed, provide the first module required:</li>
</ol>
<pre class="western"><strong>      m1</strong></pre>
<ol start="5">
<li>Indicate the second module, but ensure the version installed pre-dates the known bad version:</li>
</ol>
<pre style="color: black" class="western"><strong>      m2&lt;1.7</strong></pre>
<ol start="6">
<li>Provide the third module, ensuring it is at least equal to the minimum version required, but no greater than the maximum version that can be used:</li>
</ol>
<pre style="color: black" class="western"><strong>     m3&gt;=1.5, &lt;=2.0</strong></pre>
<p style="padding-left: 60px">While the preceding screenshot shows some version specifier requirements, here is an example showing some of the different ways to specify module versions in <kbd>requirements.txt</kbd>:</p>
<pre><strong>        flask</strong><br/><strong>        flask-pretty == 0.2.0</strong><br/><strong>        flask-security &lt;= 3.0</strong><br/><strong>        flask-oauthlib &gt;= 0.9.0, &lt;= 0.9.4</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this example, module <kbd>m1</kbd> is specified as a requirement, but the version number doesn't matter; in this case, <kbd class="western">pip</kbd> will install the latest version. However, because of the bug in the latest version of <kbd>m2</kbd>, an earlier version is specified to be installed. Finally, <kbd>m3</kbd> must be a version between 1.5 and 2.0 to satisfy the installation. Naturally, if one of these conditions can't be met, the installation will fail and the offending library and version numbers will be displayed for further troubleshooting.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It's worth noting that <kbd class="western">pip</kbd> doesn't have true dependency resolution; it will simply install the first file specified. Thus, it is possible to have dependency conflicts or a sub-dependency that doesn't match the actual requirement. This is why a requirements file is useful, as it alleviates some dependency problems.</p>
<p>Verifying hashes also ensures that a package can't be changed without its version number changing as well, such as in an automated server deployment. This is an ideal situation for efficiency, as it eliminates the need for a private index server that maintains only approved packages.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using local patches and constraint files</h1>
                </header>
            
            <article>
                
<p>The benefit of open-source software is the ability to view and modify source code. If you are working on a project and create a local version of a PyPI module, such as customizing for a project or creating a patch, <kbd>requirements.txt</kbd> can be used to override the normal download of the file.</p>
<p>Constraints files are a modification of requirements files that simply indicate what version of a library is installed, but they don't actually control the installation of files.</p>
<p>One example of using a constraints file is when using a local patched version of a PyPI module, for example,&#160;<strong>ReqFile</strong>. Some software packages downloaded from PyPI rely on ReqFile, but other packages don't. Rather than writing a requirements file for every single package from PyPI that depends on ReqFile, a constraints file can be created as a master record and implemented across all Python projects. Any package being installed that requires ReqFile will see the constraints file and install from the local repository, rather than from PyPI.</p>
<p>In this manner, a single file can be used by every developer and it no longer matters what a PyPI package depends on; the correct version will either be pulled down from PyPI, or the local version will be used as needed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Tag the in-house version of the file. Assuming you are using Git, a tag is generated by using the following:</li>
</ol>
<pre><strong>      git tag -a &lt;tag_name&gt; -m "&lt;tag_message&gt;"<br/>      # git tag -a v0.3 -m "Changed the calculations"</strong></pre>
<ol start="2">
<li>Upload it to the version control system.</li>
<li>Indicate the local version in the <kbd>requirements.txt</kbd> file, as shown in the following example:</li>
</ol>
<pre><strong>      git+https://&lt;vcs&gt;/&lt;dependency&gt;@&lt;tag_name&gt;#egg=&lt;dependency&gt;<br/>      # git+https://gitlab/pump_laws@v0.3#egg=pump_laws</strong></pre>
<ol start="4">
<li>Write the <kbd>constraints.txt</kbd> file in the same manner as a <kbd>requirements.txt</kbd> file. The following example comes from <a href="https://github.com/mldbai/mldb">https://github.com/mldbai/mldb</a> (this was released under the Apache v2.0 license by MLDB.ai):</li>
</ol>
<pre><strong>      # math / science / graph stuff</strong><br/><strong>      bokeh==0.11.1</strong><br/><strong>      numpy==1.10.4</strong><br/><strong>      pandas==0.17.1</strong><br/><strong>      scipy==0.17.0</strong><br/><strong>      openpyxl==2.3.3</strong><br/><strong>      patsy==0.4.1</strong><br/><strong>      matplotlib==1.5.1</strong><br/><strong>      ggplot==0.6.8</strong><br/><strong>      Theano==0.7.0</strong><br/><strong>      seaborn==0.7.0</strong><br/><strong>      scikit-learn==0.17</strong><br/><br/><strong>      pymldb==0.8.1</strong><br/><strong>      pivottablejs==0.1.0</strong><br/><br/><strong>      # Progress bar</strong><br/><strong>      tqdm==4.11.0</strong><br/><br/><strong>      # notebook and friends</strong><br/><strong>      ipython==5.1.0</strong><br/><strong>      jupyter==1.0.0</strong><br/><strong>      jupyter-client==4.4.0</strong><br/><strong>      jupyter-console==5.0.0</strong><br/><strong>      jupyter-core==4.2.1</strong><br/><br/><strong>      # validator</strong><br/><strong>      uWSGI==2.0.12</strong><br/><strong>      pycrypto==2.6.1</strong><br/><br/><strong>      tornado==4.4.2</strong><br/><br/><strong>      ## The following requirements were added by pip freeze:</strong><br/><strong>      backports-abc==0.5</strong><br/><strong>      backports.shutil-get-terminal-size==1.0.0</strong><br/><strong>      backports.ssl-match-hostname==3.5.0.1</strong><br/><strong>      bleach==1.5.0</strong><br/><br/><strong>      ***further files truncated***</strong></pre>
<ol start="5">
<li>Next, run the command, <kbd>pip install -c constraints.txt</kbd>, to make the file available to Python.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the preceding example, <kbd>&lt;vcs&gt;</kbd> is the version control system being used; it could be a local server or an online service such as, GitHub. <kbd>&lt;tag_name&gt;</kbd> is the version control tag used to identify this particular update to the control system.</p>
<p>If a required dependency was a top-level requirement for the project, then that particular line in the requirements file can simply be replaced. If it is a sub-dependency of another file, then the above command would be added as a new line.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Constraints files differ from requirements files in one key way: putting a package in the constraints file does not cause the package to be installed, whereas a requirements file will install all packages listed. Constraints files are simply requirements files that control which version of a package will be installed, but provide no control over the actual installation.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with packages</h1>
                </header>
            
            <article>
                
<p>There are a variety of utilities available to work with Python packages. Every so often, a developer needs to uninstall Python packages from a system. Uninstalling packages is as easy as installing them.</p>
<p>As it is easy to install packages and forget what has been installed in the past, <kbd>pip</kbd> provides the ability to list all currently installed packages, as well as indicating which ones are out of date. The examples in the next section are from the Python list&#160;(<a href="https://pip.pypa.io/en/stable/reference/pip_list/">https://pip.pypa.io/en/stable/reference/pip_list/</a>) and show documentation pages (<a href="https://pip.pypa.io/en/stable/reference/pip_show/">https://pip.pypa.io/en/stable/reference/pip_show/</a>).</p>
<p>Finally, when looking for packages to install, rather than opening a browser and navigating to PyPI directly, it is possible to find packages from the command line.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To uninstall packages, run the&#160;<kbd>pip uninstall &lt;package_name&gt;</kbd> command. This will uninstall most packages on the system.</li>
<li>Requirements files can be used to remove a number of packages at once, by using the <kbd>-r</kbd> option, such as <kbd>pip uninstall -r &lt;requirements_file&gt;</kbd>. The <kbd>-y</kbd> option allows for automatic confirmation of file removal.</li>
</ol>
<ol start="3">
<li>List currently installed packages by running <kbd class="western">pip list</kbd><span>.</span></li>
</ol>
<div style="color: black" class="CDPAlignCenter CDPAlign"><img src="images/bc2f7bb7-c3d1-4b11-96de-b440ccfc91a3.png" style="width:39.25em;height:29.00em;"/></div>
<ol start="4">
<li>To show packages that are outdated, use <kbd class="western">pip list --outdated</kbd>, as follows:</li>
</ol>
<pre><strong>      $ pip list --outdated
      docutils (Current: 0.10 Latest: 0.11)
      Sphinx (Current: 1.2.1 Latest: 1.2.2)<br/></strong></pre>
<p style="padding-left: 60px"><span>While it is possible to update all outdated packages at once, this is not available within&#160;</span><kbd>pip</kbd><span>&#160;itself. There are two primary options: the first involves using&#160;</span><kbd>sed</kbd><span>,&#160;</span><kbd>awk</kbd><span>, or&#160;</span><kbd>grep</kbd><span>&#160;to walk through the list of packages, find the outdated packages, and update them. Alternatively, install the package&#160;</span><kbd>pip-review</kbd> to see outdated packages and update them. In addition, a number of other tools have been created by different developers, as well as instructions on how to do it yourself, so you should decide which works best for you.</p>
<div class="packt_infobox">Note: Automatically upgrading all Python packages can break dependencies. You should only update packages on an as-needed basis.</div>
<ol start="5">
<li>Details of a particular installed package can be shown using <kbd class="western">pip show &lt;package_name&gt;</kbd>, as follows:</li>
</ol>
<pre><strong>      $ pip show sphinx
      Name: Sphinx
      Version: 1.7.2
      Summary: Python documentation generator
      Home-page: http://sphinx-doc.org/
      Author: Georg Brandl
      Author-email: georg@python.org
      License: BSD
      Location: /my/env/lib/python2.7/site-packages
      Requires: docutils, snowballstemmer, alabaster, Pygments, <br/>                imagesize, Jinja2, babel, six</strong></pre>
<ol start="6">
<li>Run the command <kbd class="western">pip search "query_string"</kbd>. The example below comes from <a href="https://pip.pypa.io/en/stable/reference/pip_search/">https://pip.pypa.io/en/stable/reference/pip_search/</a>, and shows how the output looks:</li>
</ol>
<pre><strong>      $ pip search peppercorn
      pepperedform    - Helpers for using peppercorn with formprocess.
      peppercorn      - A library for converting a token stream into [...]</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When searching for packages, the query can be a package name or simply a word, as <kbd class="western">pip</kbd> will find all packages with that string in the package name or in the package description. This is a useful way to locate a package if you know what you want to do but don't know the actual name of the package.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Packages installed with <kbd>python setup.py install</kbd>, and program wrappers that were installed using <kbd>python setup.py develop</kbd>, cannot be uninstalled via <kbd>pip</kbd>, as they do not provide metadata about which files were installed.</p>
<p>A number of other options are available for listing files, such as listing only non-global packages, beta versions of packages, outputting the list in columns, and other tools that may prove useful.</p>
<p>Additional information can be shown by using the <kbd class="western">--verbose</kbd> option, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/3c79380c-48e9-427f-8f87-518368985821.png" style="width:38.58em;height:30.83em;"/></div>
<p>The verbose option shows the same information as the default mode, but also includes such information as the classifier information that would found on the package's PyPI page. While this information could obviously be found simply by going to the PyPI site, if you are on a stand-alone computer or otherwise unable to connect to the internet, this can be useful when figuring out whether a package is supported by our current environment or when looking for similar packages within a particular topic.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating wheels and bundles</h1>
                </header>
            
            <article>
                
<p><kbd>pip wheel</kbd> allows the developer to bundle all project dependencies, along with any compiled files, into a single archive file. This is useful for installing when index servers aren't available, and eliminates recompiling code. However, recognize that compiled packages are normally OS- and architecture-specific, as they are normally C code, meaning they are generally not portable across different systems without recompiling. This is also a good use of hash-checking to ensure future wheels are built with identical packages.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an archive (from the official documentation: <a href="https://pip.pypa.io/en/latest/user_guide/#installation-bundles)">https://pip.pypa.io/en/latest/user_guide/#installation-bundles)</a>, perform the following:</p>
<ol>
<li>Create a temporary directory:</li>
</ol>
<pre><strong>      $ tempdir = $(mktemp -d /tmp/archive_dir)</strong></pre>
<ol start="2">
<li>Create a wheel file:</li>
</ol>
<pre><strong>      $ pip wheel -r requirements.txt --wheel-dir = $tempdir</strong></pre>
<ol start="3">
<li>Let the OS know where to place the archive file:</li>
</ol>
<pre><strong>      $ cwd = `pwd`</strong></pre>
<ol start="4">
<li>Change to the temporary directory and create the archive file:</li>
</ol>
<pre><strong>      $ (cd "$tempdir"; tar -cjvf "$cwd/&lt;archive&gt;.tar.bz2" *)</strong></pre>
<p>To install from an archive, do the following:</p>
<ol>
<li>Create a temporary directory:</li>
</ol>
<pre><strong>      $ tempdir=$(mktemp -d /tmp/wheelhouse-XXXXX)</strong></pre>
<ol start="2">
<li>Change to the temporary directory and unarchive the file:</li>
</ol>
<pre><strong>      $ (cd $tempdir; tar -xvf /path/to/&lt;archive&gt;.tar.bz2)</strong></pre>
<ol start="3">
<li>Use <kbd>pip</kbd> to install the unarchived files:</li>
</ol>
<pre><strong>      $ pip install --force-reinstall --ignore-installed --upgrade --no-index --no-deps $tempdir/*</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the first example (creating an archive), a temporary directory is first made, then the wheel is created using a requirements file and placed in the temporary directory. Next, the <kbd>cwd</kbd> variable is created and set equal to the present working directory (<kbd>pwd</kbd>). Finally, a combined command is issued, changing to the temporary directory, and creating an archive file in <kbd>cwd</kbd> of all the files in the temporary directory.</p>
<p>In the second example (installing from an archive), a temporary directory is created. Then, a combined command is given to change to that temporary directory and extract the files that make up the archive file. Then, using <kbd>pip</kbd>, the bundled files are used to install the Python program onto the computer in the temporary directory.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><kbd>--force-reinstall</kbd> will reinstall all packages when upgrading, even if they are already current. <kbd>--ignore-installed</kbd> forces a reinstall, ignoring whether the packages are already present. <kbd>--upgrade</kbd> upgrades all specified packages to the newest version available. <kbd>--no-index</kbd> ignores the package index and only looks at at URLs to parse for archives. <kbd>--no-deps</kbd> ensures that no package dependencies are installed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Comparing source code to bytecode</h1>
                </header>
            
            <article>
                
<p class="mce-root">Interpreted languages, such as Python, typically take raw source code and generate bytecode. Bytecode is encoded instructions that are on a lower level than source code but not quite as optimized as machine code, that is, assembly language.</p>
<p>Bytecode is often executed within the interpreter (which is a type of virtual machine), though it can also be compiled further into assembly language. Bytecode is used primarily to allow easy, cross-platform compatibility. Python, Java, Ruby, Perl, and similar languages, are examples of languages that use bytecode interpreters for different architectures while the source code stays the same.</p>
<p>While Python automatically compiles source code into bytecode, there are some options and features that can be used to modify how the interpreter works with bytecode. These options can improve the performance of Python programs, a key feature as interpreted languages are, by nature, slower than compiled languages</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To create bytecode, simply execute a Python program via <kbd>python &lt;program&gt;.py</kbd>.</li>
<li>When running a Python command from the command line, there are a couple of switches that can reduce the size of the compiled bytecode. Be aware that some programs may expect the statements that are removed from the following examples to function correctly, so only use them if you know what to expect.</li>
</ol>
<p style="padding-left: 60px">-O removes <kbd>assert</kbd> <span>statements from the compiled code. These statements provide some debugging help when testing the program, but generally aren't required for production code.</span></p>
<p style="padding-left: 60px">-OO removes both <kbd>assert</kbd> and <kbd>__doc__</kbd> strings for even more size reduction.</p>
<ol start="3">
<li>Loading programs from bytecode into memory is faster than with source code, but actual program execution is no faster (due to the nature of the Python interpreter).</li>
<li>The <kbd>compileall</kbd> module can generate bytecode for all modules within a directory. More information on the command can be found at&#160;<a href="https://docs.python.org/3.6/library/compileall.html">https://docs.python.org/3.6/library/compileall.html</a>.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When source code (<kbd>.py</kbd>) is read by the Python interpreter, the bytecode is generated and stored in <kbd>__pycache__</kbd> as <kbd>&lt;module_name&gt;.&lt;version&gt;.pyc</kbd>. The <kbd>.pyc</kbd> extension indicates that it is compiled Python code. This naming convention is what allows different versions of Python code to exist simultaneously on the system.</p>
<p>When source code is modified, Python will automatically check the date with the compiled version in cache and, if it's out of date, will automatically recompile the bytecode. However, a module that is loaded directly from the command line will not be stored in <kbd>__pycache__</kbd> and is recompiled every time. In addition, if there is no source module, the cache can't be checked, that is, a bytecode-only package won't have a cache associated with it.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Because bytecode is platform-independent (due to being run through the platform's interpreter), Python code can be released either as <kbd>.py</kbd> source files or as <kbd>.pyc</kbd> bytecode. This is where bytecode-only packages come into play; to provide a bit of obfuscation and (subjective) security, Python programs can be released without the source code and only the pre-compiled <kbd>.pyc</kbd> files are provided. In this case, the compiled code is placed in the source directory rather than the source-code files.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to create and reference module packages</h1>
                </header>
            
            <article>
                
<p>We have talked about modules and packages, using the terms interchangeably. However, there is a difference between a module and a package: packages are actually collections of modules and they include a <kbd>__init__.py</kbd> file, which can just be an empty file.</p>
<p>The dot-nomenclature used in modules to access specific functions or variables is also used in packages. This time, dotted names allow multiple modules within a package to be accessed without having name conflicts; each package creates its own namespace, and all the modules have their own namespaces.</p>
<p>When packages contain sub-packages (as in the following example), importing modules can be done with either absolute or relative paths. For example, to import the <kbd class="western">sepia.py</kbd> module, one could import it with an absolute path: <kbd class="western">from video.effects.specialFX import sepia</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>When making a package, follow the normal filesystem hierarchy in terms of directory structure; that is, modules that relate to each other should be placed in their own directory.</li>
<li>A possible package for a video file handler is shown in <kbd>package_tree.py</kbd>:</li>
</ol>
<pre><strong>      video/                  # Top-level package</strong><br/><strong>          __init__.py         # Top-level initialization</strong><br/><strong>          formats/            # Sub-package for file formats</strong><br/><strong>              __init__.py     # Package-level initialization</strong><br/><strong>              avi_in.py</strong><br/><strong>              avi_out.py</strong><br/><strong>              mpg2_in.py</strong><br/><strong>              mpg2_out.py</strong><br/><strong>              webm_in.py</strong><br/><strong>              webm_out.py</strong><br/><strong>          effects/             # Sub-package for video effects</strong><br/><strong>              specialFX/       # Sub-package for special effects</strong><br/><strong>                  __init__.py</strong><br/><strong>                  sepia.py</strong><br/><strong>                  mosaic.py</strong><br/><strong>                  old_movie.py</strong><br/><strong>                  glass.py</strong><br/><strong>                  pencil.py</strong><br/><strong>                  tv.py</strong><br/><strong>              transform/        # Sub-package for transform effects</strong><br/><strong>                  __init__.py</strong><br/><strong>                  flip.py</strong><br/><strong>                  skew.py</strong><br/><strong>                  rotate.py</strong><br/><strong>                  mirror.py</strong><br/><strong>                  wave.py</strong><br/><strong>                  broken_glass.py</strong><br/><strong>              draw/              # Sub-package for draw effects</strong><br/><strong>                  __init__.py</strong><br/><strong>                  rectangle.py</strong><br/><strong>                  ellipse.py</strong><br/><strong>                  border.py</strong><br/><strong>                  line.py</strong><br/><strong>                  polygon.py</strong></pre>
<ol start="3">
<li>But, what happens if you were already in the <kbd class="western">specialFX/</kbd> directory and wanted to import from another package? Use relative paths to walk the directory and import using dots, just like changing directories on the command-line:</li>
</ol>
<pre><strong>      from . import mosaic
      from .. import transform
      from .. draw import rectangle</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this example, the whole <kbd>video</kbd> package comprises two sub-packages, video formats and video effects, with video effects having several sub-packages of its own. Within each package, each <kbd>.py</kbd> file is a separate module. During module importation, Python looks for packages on <kbd>sys.path</kbd>.</p>
<p>The inclusion of the <kbd>__init__.py</kbd> files is necessary so Python will treat the directories as packages. This prevents directories with common names from shadowing Python modules further along the search path. They also allow calling modules as stand-alone programs via the <kbd>-m</kbd> option, when calling Python programs.</p>
<p>Initialization files are normally empty but can contain initialization code for the package. They can also contain an <kbd>__all__</kbd> list, which is a Python list of modules that should be imported whenever <kbd>from &lt;package&gt; import *</kbd> is used.</p>
<p>The reason for <kbd>__all__</kbd> is for the developer to explicitly indicate which files should be imported. This is to prevent excessive delay from importing all modules within a package that aren't necessarily needed for other developers. It also limits the chance of undesired side-effects when a module is inadvertently imported. The catch is, the developer needs to update the <kbd>__all__</kbd> list every time the package is updated.</p>
<p>Relative imports are based on the name of the current module. As the main module for a program always has the name <kbd class="western">"__main__"</kbd>, any modules that will be the main module of an application must use absolute imports.</p>
<p>To be honest, it is generally safer to use absolute imports just to make sure you know exactly what you're importing; with most development environments nowadays providing suggestions for paths, it is just as easy to write out the auto-populated path as it is to use relative paths.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If <kbd>__all__</kbd> is not defined in <kbd>__init__.py</kbd>, then <kbd>import *</kbd> only imports the modules within the specified package, not all sub-packages or their modules. For example, <kbd>from video.formats import *</kbd> only imports the video formats; the modules in the <kbd>effects/</kbd> directory will not be included.</p>
<p>This is a best practice for Python programmers: as the Zen of Python (<a href="https://www.python.org/dev/peps/pep-0020/">https://www.python.org/dev/peps/pep-0020/</a>) states, explicit is better than implicit. Thus, importing a specific sub-module from a package is a good thing, whereas <kbd>import *</kbd> is frowned upon because of the possibility of variable name conflicts.</p>
<p>Packages have the <kbd class="western">__path__</kbd> attribute, which is rarely used. This attribute is a list that has the name of the directory where the package's <kbd class="western">__init__.py</kbd> file is located. This location is accessed before the rest of the code for the file is run.</p>
<p>Modifying the package path affects future searches for modules and sub-packages within the package. This is useful when it is necessary to extend the number of modules found during a package search.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Operating system-specific binaries</h1>
                </header>
            
            <article>
                
<p>Python programs are normally provided in source code or wheel files. However, there are times when a developer wants to provide OS-specific files, such as a Windows <kbd class="western">.exe</kbd>, for ease of installation. Python has a number of options for developers to create stand-alone executable files.</p>
<p><strong>py2exe</strong> (<a href="https://pypi.python.org/pypi/py2exe/">https://pypi.python.org/pypi/py2exe/</a>) is one option for creating Windows-specific files. Unfortunately, it is difficult to tell how maintained this project is, as the last release on <a href="https://pypi.python.org/pypi/py2exe/0.9.2.2">https://pypi.python.org/pypi/py2exe/0.9.2.2</a> was in 2014, while <a href="http://www.py2exe.org/">http://www.py2exe.org</a> references a release from 2008. It also appears to be only available for Python 3.4 and older versions. However, if you believe this program may be useful, it does convert Python scripts into Windows executables without requiring the installation of Python.</p>
<p><strong>py2app</strong> (<a href="https://py2app.readthedocs.io/en/latest/">https://py2app.readthedocs.io/en/latest/</a>) is the primary tool for creating stand-alone Mac bundles. This tool is still maintained at <a href="https://bitbucket.org/ronaldoussoren/py2app">https://bitbucket.org/ronaldoussoren/py2app</a>, and the latest release came out in January 2018. Building is much like with <kbd class="western">py2exe</kbd>, but there are several library dependencies required, listed at <a href="https://py2app.readthedocs.io/en/latest/dependencies.html">https://py2app.readthedocs.io/en/latest/dependencies.html</a>.</p>
<p>There are more cross-platform tools for making OS-specific executable programs than there are for specific operating systems. This is good, as many developers use Linux as their development environment and may not have access to a Windows or Mac machine.</p>
<p>For developers who don't want to set up multiple operating systems themselves, there are several online services that allow you to rent operating systems online. For example, <a href="http://virtualmacosx.com">http://virtualmacosx.com</a> allows you access to a hosted Mac environment, while there are multiple options for Windows hosting, from Amazon Web Services to regular web hosts.</p>
<p>For those desiring local control of binary execution,&#160;cx_Freeze (<a href="https://anthony-tuininga.github.io/cx_Freeze/">https://anthony-tuininga.github.io/cx_Freeze/</a>) is one of the more popular executable creation programs for Python. It only works with Python 2.7 or newer, but that shouldn't be a problem for most developers. However, if you want to use it with Python 2 code, you will have to use <strong>cx_Freeze</strong> version 5; starting with version 6, support for Python 2 code has been dropped.</p>
<div class="packt_infobox">The modules created by cx_Freeze are stored in ZIP files. Packages, by default, are stored in the file system but can be included in the same ZIP files, if desired.</div>
<p><strong>PyInstaller</strong> (<a href="http://www.pyinstaller.org">http://www.pyinstaller.org</a>) has, as its main goal, compatibility with third-party packages, requiring no user intervention to make external packages work during binary creation. It is available for Python 2.7 and newer versions.</p>
<p>PyInstaller provides multiple ways to package your Python code: as a single directory (containing the executable as well as all necessary modules), as a single file (self-contained and requiring no external dependencies), or in custom mode.</p>
<p>The majority of third-party packages will work with PyInstaller with no additional configuration required. Conveniently, a list, located at <a href="https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages">https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages,</a> is provided for packages known to work with PyInstaller; if there are any limitations, for example, only working on Windows, these are noted as well.</p>
<p><strong>Cython</strong> (<a href="http://cython.org">http://cython.org</a>) is actually a superset of Python, designed to give C-like performance to Python code. This is done by allowing types to be added to the Python code; whereas Python is normally dynamically typed, Cython allows static typing of variables. The resulting code is compiled into C code, which can be executed by the normal Python interpreter as normal, but at the speed of compiled C code.</p>
<p>While normally used to create extensions for Python, or to speed up Python processing, using the <kbd class="western">--embed</kbd> flag with the <kbd class="western">cpython</kbd> command will create a C file, which can then be compiled to a normal application file.</p>
<p>Naturally, this takes more knowledge of using <kbd class="western">gcc</kbd> or your compiler of choice, as you have to know how to import the Python headers during compilation, and which other directories need to be included. As such, Cython isn't recommended for developers unfamiliar with C code, but it can be a powerful way to make full-featured applications by utilizing both Python and C languages.</p>
<p><strong>Nuitka</strong> (<a href="http://nuitka.net">http://nuitka.net</a>) is a relatively new Python compiler program. It is compatible with Python 2.6 and later, but also requires <kbd class="western">gcc</kbd> or another C compiler. The latest version, 0.5.29, is beta-ware, but the author claims it is able to compile every Python construct currently available without a problem.</p>
<p>Nuitka functions much like Cython, in that it uses a C compiler to convert Python code into C code, and make executable files. Entire programs can be compiled, with the modules embedded in the file, but individual modules can be compiled by themselves, if desired.</p>
<p>By default, the resulting binary requires Python to be installed, plus the necessary C extension modules. However, it is possible to create true stand-alone executables by using the <kbd class="western">--stand-alone</kbd> flag.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root"><span>Write your Python program.</span></li>
<li>To create a Windows <kbd class="western">.exe</kbd> file, create a <kbd class="western">setup.py</kbd> file to tell the libraries what you want to do. This is mainly importing the <kbd class="western">setup()</kbd> function from the <kbd class="western">Distutils</kbd> library, importing <kbd class="western">py2exe</kbd>, and then calling <kbd class="western">setup</kbd> and telling it what type of application it is making, for example, a console, and what the main Python file is. <kbd>py2exe_setup.py</kbd>, following, is an example from the documentation of a <kbd class="western">setup.py</kbd> file:</li>
</ol>
<pre style="color: black" class="western"><strong>      from distutils.core import setup
      import py2exe
      setup(console=['hello.py'])</strong></pre>
<ol start="3">
<li>Run the setup script by calling <kbd class="western">python setup.py py2exe</kbd>. This creates two directories: <kbd class="western">build/</kbd> and <kbd class="western">dist/</kbd>. The <kbd class="western">dist/</kbd> directory is where the new files are placed, while <kbd class="western">build/</kbd> is used for temporary files during the creation process.</li>
<li class="mce-root">Test the application by moving to the <kbd class="western">dist/</kbd> directory and running the <kbd class="western">.exe</kbd> file located there.</li>
<li class="mce-root">To make a macOS <kbd class="western">.app</kbd> file, create the <kbd class="western">setup.py</kbd> file. Any icons or data files required for the application need to be included during this step.</li>
<li class="mce-root">Clean up the <kbd class="western">build/</kbd> and <kbd class="western">dist/</kbd> directories to ensure there are no files that may be accidentally included.</li>
<li class="mce-root">Use Alias mode to build the application in-place, that is, not ready for distribution. This allows you to test the program before bundling for delivery.</li>
<li class="mce-root">Test the application and verify it works correctly in alias mode.</li>
<li>Clean up the <kbd class="western">build/</kbd> and <kbd class="western">dist/</kbd> directories again.</li>
<li class="mce-root">Run <kbd class="western">python setup.py py2app</kbd> to create the distributable <kbd class="western">.app</kbd> file.</li>
<li>For cross-platform files, the easiest way to use cx_Freeze is to use the <kbd class="western">cxfreeze</kbd> script:</li>
</ol>
<pre class="western"><strong>      cxfreeze &lt;program&gt;.py --target-dir=&lt;directory&gt;</strong></pre>
<p style="padding-left: 60px">Other options are available for this command, such as compressing the bytecode, setting an initialization script, or even excluding modules.</p>
<p style="padding-left: 60px">If more functionality is required, a <kbd class="western">distutils</kbd> setup script can be created. The command <kbd class="western">cxfreeze-quickstart</kbd> can be used to generate a simple setup script; the cx_Freeze documentation provides an example <kbd class="western">setup.py</kbd> file (<kbd>cxfreeze_setup.py</kbd>):</p>
<pre style="color: black" class="western">      import sys
      from cx_Freeze import setup, Executable

      # Dependencies are automatically detected, but it might need fine tuning.
      build_exe_options = {"packages": ["os"], "excludes": ["tkinter"]}

      # GUI applications require a different base on Windows (the default is for 
      # console application).
      base = None
      if sys.platform == "win32":
          base = "Win32GUI"

      setup(  name = "guifoo",
              version = "0.1",
              description = "My GUI application!",
              options = {"build_exe": build_exe_options},
              executables = [Executable("guifoo.py", base=base)])</pre>
<p style="color: black;padding-left: 60px">To run the setup script, run the command: <kbd class="western">python setup.py build</kbd>. This will create the directory <kbd class="western">build/</kbd>, which contains the subdirectory <kbd class="western">exe.xxx</kbd>, where <kbd>xxx</kbd> is the platform-specific executable binary indicator:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li class="mce-root">For developers who need even more control, or are looking at creating C scripts for extending or embedding Python, manually working with the classes and modules within the cx_Freeze program is possible.</li>
</ul>
</li>
</ul>
<ol start="12">
<li>If using PyInstaller, its use is like most other Python programs,&#160; and is a simple command:</li>
</ol>
<pre style="color: black" class="western"><strong>      pyinstaller &lt;program&gt;.py</strong></pre>
<p style="color: black;padding-left: 60px">This generates the binary bundle in the <kbd class="western">dist/</kbd> subdirectory. Naturally, there many other options available when running this command:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Optionally, UPX (<a href="https://upx.github.io/">https://upx.github.io/</a>) can be used to compress the executable files and libraries. When used, UPX compresses the files and wraps them in a self-decompressing file. When executed, the UPX wrapper decompresses the enclosed files and the resulting binary is executed normally.</li>
<li>To create multiple Python environments for a single operating system, it is recommended you to create virtual Python environments for each Python version to be generated. Then, install PyInstaller in each environment and build the binary within each environment.</li>
<li>Like cx_Freeze, to create binaries for different operating systems, the other OSes must be available and PyInstaller used on each one.</li>
<li>Create your Python file; save it with the extension <kbd class="western">.pyx</kbd>. For example, <kbd class="western">helloworld.pyx</kbd>.</li>
</ul>
</li>
</ul>
<ol start="13">
<li>When working with Cython, create a <kbd class="western">setup.py</kbd> file that looks similar to <kbd>cython_setup.py</kbd>&#160;from <a href="http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython">http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython</a>:</li>
</ol>
<pre style="color: black" class="western"><strong>      from distutils.core import setup
      from Cython.Build import cythonize

      setup(
          ext_modules = cythonize("helloworld.pyx")
      )</strong></pre>
<ol start="14">
<li>Create the Cython file by running the following:</li>
</ol>
<pre style="color: black" class="western"><strong>      $ python setup.py build_ext --inplace</strong></pre>
<ol start="15">
<li>This creates a file in the local directory: <kbd class="western">helloworld.so</kbd> on *nix and <kbd class="western">helloworld.pyd</kbd> on Windows.</li>
<li>To use the binary, simply import it into Python as normal.</li>
<li>If your Python program doesn't require additional C libraries or a special build configuration, you can use the <kbd class="western">pyximport</kbd> library. The <kbd class="western">install()</kbd> function from this library allows loading <kbd class="western">.pyx</kbd> files directly when imported, rather than having to rerun <kbd class="western">setup.py</kbd> every time the code changes.</li>
</ol>
<ol start="18">
<li>To compile a program using Nuitka with all modules embedded, use the following command:</li>
</ol>
<pre class="western"><strong>      nuitka --recurse-all &lt;program&gt;.py</strong></pre>
<ol start="19">
<li>To compile a single module, use the following command:</li>
</ol>
<pre class="western"><strong>      nuitka --module &lt;module&gt;.py</strong></pre>
<ol start="20">
<li>To compile an entire package and embed all modules, the previous commands are combined into a similar format:</li>
</ol>
<pre class="western"><strong>      nuitka --module &lt;package&gt; --recurse-directory=&lt;package&gt;</strong></pre>
<ol start="21">
<li>To make a truly cross-platform binary, use the option <kbd class="western">--standalone</kbd>, copy the <kbd class="western">&lt;program&gt;.dist</kbd> directory to the destination system, and then run the <kbd class="western">.exe</kbd> file inside that directory.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Depending on a user's system configuration, you may need to provide the Microsoft Visual C runtime DLL. The <kbd class="western">py2exe</kbd> documentation provides different files to choose from, depending on the version of Python you are working with.</p>
<p>In addition, <kbd class="western">py2exe</kbd> does not create the installation builder, that is, installation wizard. While it may not be necessary for your application, Windows users generally expect a wizard to be available when running an <kbd class="western">.exe</kbd> file. A number of free, open-source, and proprietary installation builders are available.</p>
<p>One benefit of building Mac binaries is that they are simple to pack for distribution; once the <kbd class="western">.app</kbd> file is generated, right-click on the file and choose <span class="packt_screen">Create Archive</span>. After that, your application is ready to be shipped out.</p>
<p>A common problem with cx_Freeze is that the program doesn't automatically detect a file that needs to be copied. This frequently occurs if you are dynamically importing modules into your program, for example, a plugin system.</p>
<p>Binaries created by cx_Freeze are generated for the OS it was run on; for instance, to create a Windows <kbd class="western">.exe</kbd> file, cx_Freeze has to be used on a Windows computer. Thus, to make a truly cross-platform Python program that is distributed as executable binaries, you must have access to other operating systems. This can be alleviated by using virtual machines, cloud hosts, or simply purchasing the relevant systems.</p>
<p>When PyInstaller is run, it analyzes the supplied Python program and creates a <kbd class="western">&lt;program&gt;.spec</kbd> file in the same folder as the Python program. In addition, the <kbd class="western">build/</kbd> subdirectory is placed in the same location.</p>
<p>The <kbd class="western">build/</kbd> directory contains log files and the working files used to actually create the binary. After the executable file is generated, a <kbd class="western">dist/</kbd> directory is placed in the same location as the Python program, and the binary is placed in the <kbd class="western">dist/</kbd> directory.</p>
<p>The executable file generated by Nuitka will have the <kbd class="western">.exe</kbd> extension on all platforms. It is still usable on non-Windows OSes, but it is recommended to change the extension to a system-specific one to avoid confusion.</p>
<p>The binary files created with any of the commands previously shown require Python to be installed on the end system, as well as any C extension modules that are used.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to upload programs to PyPI</h1>
                </header>
            
            <article>
                
<p>If you have developed a package and want to post it on PyPI for distribution, there are several things you need to do to ensure the proper uploading and registration of your project. While this section will highlight some of the key features of configuring your packages for distribution on PyPI, it is not all-inclusive. Make sure you look at the documentation on the PyPI site to ensure you have the latest information.</p>
<p>One of the first things to do is install the <kbd>twine</kbd> package into your Python environment. <kbd>twine</kbd> is a collection of utilities for interacting with PyPI. The prime reason for its use is that is authenticates your connection to the database using HTTPS; this ensures your username and password are encrypted when interacting with PyPI. While some people may not care whether a malicious entity captures their login credentials for a Python repository, a number of people use the same login name and password for multiple sites, meaning that someone learning the PyPI login information could potentially access other sites as well.</p>
<p><kbd>twine</kbd> also allows you to pre-create your distribution files, that is, you can test your package files before releasing them to ensure everything works. As part of this, you can upload any packing format, including wheels, to PyPI.</p>
<p>Finally, it allows you to digitally pre-sign your files and pass the <kbd>.asc</kbd> files to the command line when uploading the files. This ensures data security by verifying you are passing your credentials into the GPG application, and not something else.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Your project files need to be configured in the proper way so they are of use to other developers, and are listed properly on PyPI. The most important step of this process is setting up the <kbd>setup.py</kbd> file, which sits in the root of your project's directory.</p>
<p><kbd>setup.py</kbd> contains configuration data for your project, particularly the <kbd>setup()</kbd> function, which defines the details of the project. It is also the command-line interface for running commands related to the packaging process.</p>
<p>A license (<kbd>license.txt</kbd>) should be included with the package. This file is important because, in some areas, a package without an explicit license cannot be legally used or distributed by anyone but the copyright holder. Including the license ensures both the creator and users are legally protected against copyright infringement issues.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a manifest file.</li>
<li>Configure <kbd>setup.py</kbd> by defining the options for the <kbd>distutils setup()</kbd> function.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A manifest file is also important if you need to package files that aren't automatically included in the source distribution. By default, the following files are included in the package when generated (known as the standard include set):</p>
<ul>
<li>All Python source files implied by the <kbd>py_modules</kbd> and <kbd>packages</kbd> options</li>
<li>All C source files listed in <kbd>ext_modules</kbd> or <kbd>libraries</kbd> options</li>
<li>Any scripts identified with the <kbd>scripts</kbd> option</li>
<li>Any test scripts, for instance, anything that looks like <kbd>test*.py</kbd></li>
<li>Setup and readme files: <kbd>setup.py</kbd>, <kbd>setup.cfg</kbd>, and <kbd>README.txt</kbd></li>
<li>All files that match the <kbd>package_data</kbd> and <kbd>data_files</kbd> metadata</li>
</ul>
<p class="mce-root">Any files that don't meet these criteria, such as a license file, need to be included in a <kbd>MANIFEST.ini</kbd> template file. The manifest template is a list of instructions on how to generate the actual manifest file that lists the exact files to include in the source distribution.</p>
<p>The manifest template can include or exclude any desired files; wildcards are available as well. For example, <kbd>manifest_template.py</kbd>&#160;from the <kbd>distutils</kbd> package shows one way to list files:</p>
<pre>include *.txt<br/>recursive-include examples *.txt *.py<br/>prune examples/sample?/build</pre>
<p>This example indicates that all <kbd>.txt</kbd> files in the root directory should be included, as well as all <kbd>.txt</kbd> and <kbd>.py</kbd> files in the <kbd>examples/</kbd> subdirectory. In addition, all directories that match <kbd>examples/sample?/build</kbd> will be excluded from the package.</p>
<p>The manifest file is processed after the defaults above are considered, so if you want to exclude files from the standard include set, you can explicitly list them in the manifest. If, however, you want to completely ignore all defaults in the standard set, you can use the <kbd>--no-defaults</kbd> option to completely disable the standard set.</p>
<p>The order of commands in the manifest template is important. After the standard include set is processed, the template commands are processed in order. Once that is done, the final resulting command set is processed; all files to be pruned are removed. The resulting list of files is written to the manifest file for future reference; the manifest file is then used to build the source distribution archive.</p>
<p>It is important to note that the manifest template does not affect binary distributions, such as wheels. It is only for use in source-file packaging.</p>
<p>As mentioned previously, <kbd>setup.py</kbd> is a key file for the packaging process, and the <kbd>setup()</kbd> function is what enables the details of the project to be defined.</p>
<p>There are a number of arguments that can be provided to the <kbd>setup()</kbd> function, some of which will be covered in the following list. A good example of this is shown is the <em>Listing Packages</em>&#160;section:</p>
<ul>
<li><strong>name</strong>: The name of the project, as it will be listed on PyPI. Only ASCII alphanumeric characters, underscores, hyphens, and periods are acceptable. Must also start and end with an ASCII character. This is a required field.<br/>
Project names are case-insensitive when pulled via <kbd>pip</kbd>, that is,&#160;<kbd>My.Project = My-project = my-PROJECT</kbd>, so make sure the name itself is unique, not just a different capitalization compared to another project.</li>
</ul>
<ul>
<li><strong>version</strong>: The current version of your project. This is used to tell users whether they have the latest version installed, as well as indicating which specific versions they've tested their software against. This is a required field.</li>
</ul>
<p style="padding-left: 60px" class="mce-root">There is actually a document on PEP 440 (<a href="https://www.python.org/dev/peps/pep-0440/">https://www.python.org/dev/peps/pep-0440/</a>)&#160;that indicates how to write your version numbers. <kbd>versioning.py</kbd> is an example of versioning a project:</p>
<pre><strong><span class="mf">      2.1</span><span class="o">.</span><span class="mf">0.</span><span class="n">dev1</span>  <span class="c1"># Development release</span>
<span class="mf">      2.1</span><span class="o">.</span><span class="mi">0</span><span class="n">a1</span>     <span class="c1"># Alpha Release</span>
<span class="o">      2.1.</span><span class="mb">0b1</span>     <span class="c1"># Beta Release</span>
<span class="o">      2.1.</span><span class="mi">0</span><span class="n">rc1</span>    <span class="c1"># Release Candidate</span>
<span class="o">      2.1.</span><span class="mi">0</span>       <span class="c1"># Final Release</span>
<span class="o">      2.1.</span><span class="mf">0.</span><span class="n">post1</span> <span class="c1"># Post Release</span>
<span class="mf">      2018.04</span>     <span class="c1"># Date based release</span>
      19          <span class="c1"># Serial release</span></strong></pre>
<ul>
<li><strong>description</strong>: A short and long description of your project. These will be displayed on PyPI when the project is published. The short description is required but the long description is optional.</li>
<li><strong>url</strong>: The homepage URL for your project. <span>This is an optional field.</span></li>
<li><strong>author</strong>: The developer name(s) or organization name. This is an optional field.</li>
<li><strong>author_email</strong><em>:</em> The email address for the author listed above. Obfuscating the email address by spelling out the special characters, for example, <kbd>your_name</kbd> at <kbd>your_organization</kbd> dot com, is discouraged as this is a computer-readable field; use <kbd>your_name@your_organization.com</kbd>. This is an optional field.</li>
<li><strong>classifiers</strong>: These categorize your project to help users find it on PyPI. There&#160;is a list of classifiers (<a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers">https://pypi.python.org/pypi?%3Aaction=list_classifiers</a>) that can be used, but they are optional. Some possible classifiers include: development status, framework used, intended use case, license, and so on.</li>
<li><strong>keywords</strong>: List of keywords that describe your project. It is suggested you to use keywords that might be used by a user searching for your project. This is an optional field.</li>
<li><strong>packages</strong>: List of packages used in your project. The list can be manually entered, but <kbd>setuptools.find_packages()</kbd> can be used to locate them automatically. A list of excluded packages can also be included to ignore packages that are not intended for release. This is a required field.<br/>
An optional method for listing packages is to distribute a single Python file, which to change the <kbd>packages</kbd> argument to <kbd>py_modules</kbd>, which then expects <kbd>my_module.py</kbd> to exist in the project.</li>
</ul>
<ul>
<li><strong>install_requires</strong>: Specifies the minimum dependencies for the project to run. <kbd>pip</kbd> uses this argument to automatically identify dependencies, so these packages must be valid, existing projects. This is an optional field.</li>
<li><strong>python_requires</strong>: Specifies the Python versions the project will run on. This will prevent <kbd>pip</kbd> from installing the project on invalid versions. This is an optional field.<br/>
This is a relatively recent feature; <kbd>setuptools</kbd> version 24.2.0 is the minimum version required for creating source distributions and wheels to ensure <kbd>pip</kbd> properly recognizes this field. In addition, <kbd>pip</kbd> version 9.0.0 or newer is required; earlier versions will ignore this field and install the package regardless of Python version.</li>
<li><strong>package_data</strong>: This is used to indicate additional files to be installed in the package, such as other data files or documentation. This argument is a dictionary mapping the package name to a list of relative path names. This is an optional field.</li>
<li><strong>data_fields</strong>: While <kbd>package_data</kbd> is the preferred method for identifying additional files, and is normally sufficient for the purpose, there are times when data files need to be placed outside your project package, for example, configuration files that need to be stored in a particular location in the file system. This is an optional field.</li>
<li><strong>py_modules</strong>: List of names for single-file modules that are included in the project. This is a required field.</li>
<li><strong>entry_points</strong>: Dictionary of executable scripts, such as plugins, that are defined within your project or that your project depends upon. Entry points provide cross-platform support and allow <kbd>pip</kbd> to create the appropriate executable form for the target platform. Because of these capabilities, entry points should be used in lieu of the <em>scripts</em> argument. This is an optional field.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project packaging</h1>
                </header>
            
            <article>
                
<p>Everything we have talked about so far is just the basics required to get your project configured and set up for packaging; we haven't actually packaged it yet. To actually create a package that can be installed from PyPI or another package index, you need to run the <kbd>setup.py</kbd> script.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a source code-based distribution. The minimum required for a package is a source distribution. A source distribution provides the metadata and essential source code files needed by <kbd>pip</kbd> for installation. A source distribution is essentially raw code and requires a build step prior to installation to build out the installation metadata from <kbd>setup.py</kbd>. A source distribution is created by running <kbd>python setup.py sdist</kbd>.</li>
<li>While source distributions are a necessity, it is more convenient to create wheels. Wheel packages are highly recommended, as they are pre-built packages that can be installed without waiting for the build process. This means installation is significantly faster compared to working with a source distribution.<br/>
There are several types of wheels, depending on whether the project is pure Python and whether it natively supports both Python 2 and 3. To build wheels, you must first install the wheel package: <kbd>pip install wheel</kbd>.</li>
<li>The preferred wheel package is a universal wheel. Universal wheels are pure Python, that is, do not contain C-code compiled extensions, and natively support both Python 2 and 3 environments. Universal wheels can be installed anywhere using <kbd>pip</kbd>.<br/>
To build a universal wheel, the following command is used:</li>
</ol>
<pre><strong>      python setup.py bdist_wheel --universal</strong></pre>
<p style="padding-left: 90px"><kbd>--universal</kbd> should only be used when there are no C extensions in use and the Python code runs on both Python 2 and Python 3 without needing modifications, such as running <kbd>2to3</kbd>.<br/>
<kbd>bdist_wheel</kbd> signifies that the distribution is a binary one, as opposed to a source distribution. When used in conjunction with <kbd>--universal</kbd>, it does not check to ensure that it is being used correctly, so no warnings will be provided if the criteria are not met.<br/>
The reason universal wheels shouldn't be used with C extensions is because <kbd>pip</kbd> prefers wheels over source distributions. Since an incorrect wheel will mostly likely prevent the C extension from being built, the extension won't be available for use.</p>
<ol start="4">
<li>Alternatively, pure Python wheels can be used. Pure Python wheels are created when the Python source code doesn't natively support both Python 2 and 3 functionality. If the code can be modified for use between the two versions, such as via <kbd>2to3</kbd>, you can manually create wheels for each version.<br/>
To build a wheel, use the following command:</li>
</ol>
<pre><strong>      python setup.py bdist_wheel</strong></pre>
<p style="padding-left: 90px"><kbd>bdist_wheel</kbd> will identify the code and build a wheel that is compatible for any Python installation with the same major version number, that is, 2.x or 3.x.</p>
<ol start="5">
<li>Finally, platform wheels can be used when making packages for specific platforms. Platform wheels are binary builds specific to a certain platform/architecture due to the inclusion of compiled C extensions. Thus, if you need to make a program that is only used on macOS, a platform wheel must be used.<br/>
The same command as a pure Python wheel is used, but <kbd>bdist_wheel</kbd> will detect that the code is not pure Python code and will build a wheel whose name will identify it as only usable on a specific platform. This is the same tag as referenced in the <em>Installing from Wheels</em> section.<em><br/></em></li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Uploading to PyPI</h1>
                </header>
            
            <article>
                
<p>When <kbd>setup.py</kbd> is run, it creates the new directory <kbd>dist/</kbd> in your project's root directory. This is where the distribution files are placed for uploading. These files are only created when the build command is run; any changes to the source code or configuration files require rebuilding the distribution files.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before uploading to the main PyPI site, there is a PyPI test site (<a href="https://testpypi.python.org/pypi">https://testpypi.python.org/pypi</a>) you can practice with. This allows developers the opportunity to ensure they know what they are doing with the entire building and uploading process, so they don't break anything on the main site. The test site is cleaned up on a semi-regular basis, so it shouldn't be relied on as a storage site while developing.</p>
<p>In addition, check the long and short descriptions in your <kbd>setup.py</kbd> to ensure they are valid. Certain directives and URLs are forbidden and stripped during uploading; this is one reason why it is good to test your project on the PyPI test site to see if there are any problems with your configuration.</p>
<p>Before uploading to PyPI, you need to create a user account. Once you have manually created an account on the web site, you can create a <kbd>$HOME/.pypirc</kbd> file to store your username and password. This file will be referenced when uploading so you won't have to manually enter it every time. However, be aware that your PyPI password is stored in plaintext, so if you are concerned about that you will have to manually provide it for every upload.</p>
<p>Once you have a created a PyPI account, you can upload your distributions to PyPI via <kbd>twine</kbd>; for new distributions, <kbd>twine</kbd> will automatically handle the registration of the project on the site. Install <kbd>twine</kbd> as normal using <kbd>pip</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create your distributions:</li>
</ol>
<pre><strong>      python setup.py sdist bdist_wheel --universal</strong></pre>
<ol start="2">
<li>Register your project (if for a first upload):</li>
</ol>
<pre><strong>      twine register dist/&lt;project&gt;.&lt;version&gt;.tar.gz</strong><br/><strong>      twine register dist/&lt;package_name&gt;-&lt;version&gt;-<br/>      &lt;language_version&gt;-&lt;abi_tag&gt;-&lt;platform_tag&gt;.whl</strong></pre>
<ol start="3">
<li>Upload distributions:</li>
</ol>
<pre><strong>      twine upload dist/*</strong></pre>
<ol start="4">
<li>The following error indicates you need to register your package:</li>
</ol>
<pre><strong>      HTTPError: 403 Client Error: You are not allowed to <br/>                         edit 'xyz' package information</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>twine</kbd> securely authenticates users to the PyPI database using HTTPS. The older way of uploading packages to PyPI was using <kbd>python setup.py upload</kbd>; this was insecure as the data was transferred via unencrypted HTTP, so your login credentials could be sniffed. With <kbd>twine</kbd>, connections are made through verified TLS to prevent credential theft.</p>
<p>This also allows a developer to pre-create distribution files, whereas <kbd>setup.py upload</kbd> only works with distributions that are created at the same time. Thus, using <kbd>twine</kbd>, a developer is able to test files prior to uploading them to PyPI, to ensure they work.</p>
<p>Finally, you can pre-sign your uploads with digital signatures and attach the <kbd>.asc</kbd> certification files to the <kbd>twine</kbd> upload. This ensures the developer's password is entered into GPG and not some other software, such as malware.</p>


            </article>

            
        </section>
    </div>
</body>
</html>