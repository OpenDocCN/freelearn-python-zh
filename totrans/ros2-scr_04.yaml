- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uncovering ROS 2 Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now start your first ROS 2 programs. As you will see, a ROS 2 program
    is called a **node**.
  prefs: []
  type: TYPE_NORMAL
- en: What’s inside a node, what does it do, and how do nodes communicate with each
    other? How do you configure nodes and start several of them at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: That’s what we will focus on in this chapter. We won’t write any code yet but
    instead focus on discovering the concepts through hands-on experimentation, using
    existing demos that were installed along with ROS 2.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a global understanding of the main
    ROS 2 core concepts. You will also be familiar with the most important ROS 2 tools
    that you will use later in all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I won’t explain everything. We are going to embark on a discovery
    phase, where we use the different core concepts and guess how they work. Not everything
    has to make sense right now and don’t worry too much if some concepts are still
    a bit blurry for you. Just try to get through the chapter by running all the commands
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is not to get a complete understanding or to remember all the
    commands, but rather to get an *intuition* of how things work. This will help
    you tremendously for *Part 2* when we go through each concept with much more detail—and
    develop with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running your first node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what a node is, we will simply run one and make some observations
    using some of the most useful ROS 2 tools.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, I recommend having a few open terminals. You can start a few
    terminal windows and arrange them on your screen or run Terminator (see *Extra
    tools for ROS development* in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048))
    with at least three tabs. To clear any confusion when running a command, I will
    also tell you in which terminal to run the command (Terminal 1, Terminal 2, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Starting a node from the terminal with ros2 run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s discover your first ROS 2 tool, and probably the most important one:
    the **ros2** command-line tool. You will use this tool all the time in your future
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ros2** comes with a lot of functions. We will explore some of them in this
    chapter, and more in the following ones. There is no need to remember all the
    commands: just use them to build an understanding now, and later you will easily
    be able to retrieve them from the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a node, you have to follow this template: **ros2 run <****package>
    <executable>**.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later, nodes are organized inside packages. That’s why you first
    need to specify the package name where the node is and the executable name for
    that node. As we installed ROS Desktop, a lot of demo packages are already included,
    for example, **demo_nodes_cpp**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, start the talker node from the **demo_nodes_cpp** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After you run this command, the node starts. To stop it, simply press *Ctrl*
    + *C* in the terminal where the node is running.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened here? From what we can observe, this node is simply a program
    that will print a log in the terminal every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, keep the node alive, or start it again if you stopped it. In another terminal
    (Terminal 2), let’s start a different node, which is the listener node from the
    same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This node is also a simple program that will print some logs in the terminal.
    However, as you can see, when the two nodes are running (talker and listener),
    whatever is printed on the talker seems to also be received on the listener, which
    then prints it.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have two nodes running, and we can clearly see that they
    communicate with each other. If you stop the talker node, you will see that the
    listener node stops printing logs as well. When you restart the talker, the listener
    starts printing what the talker is “sending.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few tips for when you use the `ros2` command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Use auto-completion as much as you can. It will make you type commands faster,
    but more importantly, you will be sure that you type the right command, package
    name, node name, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any doubts about a command or sub-command, you can get help from
    the terminal by adding `-h` to the command. For example, use `ros2 -h` for the
    global help, or `ros2 run -h` for help specifically for the run sub-command. There’s
    no need to remember all the commands if you know where to find the information.
  prefs: []
  type: TYPE_NORMAL
- en: Introspecting the nodes with rqt_graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another very useful tool we will discover here, which is a good complement
    to the command line: **rqt_graph**. This tool will show you all running nodes
    with a nice visual.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the 2 nodes alive (Terminals 1 and 2) and start **rqt_graph** in Terminal
    3\. The command is identical to the tool name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a new graphical window, where you should see the two nodes.
    If you don’t see anything, make sure both nodes are running, and refresh the view
    by clicking on the button with a refresh icon, in the top-left corner. You can
    also select **Nodes/Topics (all)** from the top left drop-down menu. Then, you
    should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – rqt_graph with two nodes](img/B22403_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – rqt_graph with two nodes
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that both nodes are up and running (nothing new for now), but
    we also see an arrow going from the talker node to a box, and another one from
    that box to the listener node. This is the ROS 2 communication that allows the
    talker node to send some data—here, some text—to the listener node. We will talk
    about this communication in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What we can conclude for now is that we started two different ROS programs (nodes)
    in two different terminals, using the **ros2 run** command. It seems that those
    two programs are communicating with each other, and we can confirm that with **rqt_graph**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further and look at what kind of ROS communication it is, let’s
    run another set of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Running a 2D robot simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first two nodes we ran are very simple programs that print logs on the terminal
    and send some text between each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, stop all existing nodes (press *Ctrl* + *C* in each terminal), and let’s
    start again with some other nodes. In Terminal 1, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see a few logs, but more importantly, you will get a new window with
    a blue background and a turtle in the middle. This turtle represents a (very simplified)
    simulated robot that moves in 2D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 2, start this second node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After you see this, make sure Terminal 2 is selected, and use the arrow keys
    (up, down, left, right). When doing this, you should see the turtle robot moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Moving the simulated turtle robot (TurtleSim)](img/B22403_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Moving the simulated turtle robot (TurtleSim)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can already guess that the second node we started (with **turtle_teleop_key**)
    is reading the keys you press on the keyboard and sending some kind of information/command
    to the **turtlesim** node, which then makes the turtle robot move. To confirm
    that, start **rqt_graph** again on Terminal 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed, refresh the view a few times. Select **Nodes/Topics (all)**, and
    you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes](img/B22403_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes
  prefs: []
  type: TYPE_NORMAL
- en: We can find a node named **turtlesim** and another one named **teleop_turtle**,
    and we can clearly see that the two nodes are communicating with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the executable name (`turtle_teleop_key`) we used to start the
    node is not necessarily the same as the node name (`teleop_turtle`). We’ll come
    back to this later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What can we get from those two experiments? As you can see, a ROS 2 node can
    be any kind of computer program that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to print logs in the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical windows (2D, can also be 3D)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware drivers and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A node, on top of being a computer program, also benefits from the ROS 2 functionalities:
    logs, communication with other nodes, and other features we will discover throughout
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to start a node and use the **ros2** command-line tool,
    let’s focus on how they communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nodes communicate with each other using ROS 2 communication features. There
    are three types of communication: topics, services, and actions. We will discover
    all three of them, starting with **topics**.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will make some basic discoveries to get an idea of what a ROS 2 topic
    is, and you’ll learn much more about them, including how to write code for topics,
    in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211).
  prefs: []
  type: TYPE_NORMAL
- en: Running a topic publisher and subscriber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stop all running nodes (*Ctrl* + *C*), and let’s come back to our first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 3, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If needed, refresh the view a few times, select **Nodes/Topics (all)**, and
    you should get the same visual as in *Figure 3**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle, you will see a **/chatter** box. This box represents a ROS 2
    topic. What you can also see is that the talker node is sending something to the
    **/chatter** topic, which will then be received by the listener node.
  prefs: []
  type: TYPE_NORMAL
- en: We say that the talker is a **publisher**, and the listener is a **subscriber**.
  prefs: []
  type: TYPE_NORMAL
- en: An important detail is that the talker is not actually sending data directly
    to the listener. The talker is publishing on the **/chatter** topic, and the listener
    is subscribing to the **/chatter** topic. Because of this, the data flows from
    the talker to the listener.
  prefs: []
  type: TYPE_NORMAL
- en: A name and an interface (data type)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From **rqt_graph**, we can already see that one node can send data to another
    node through a topic. An important point is that the topic is defined by a name.
    Both publishers and subscribers use the same name to make communication successful.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to it than just a name. Let’s come back to the terminal and use
    the **ros2** command-line tool to discover more information.
  prefs: []
  type: TYPE_NORMAL
- en: You previously used **ros2 run** to start a node. We also have **ros2 topic**
    to interact with topics. You can get more help with all available topic commands
    with **ros2 topic -h**. The **ros2 topic list** command will list all available
    topics, which means all topic communications between running nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 3 (if you stopped **rqt_graph**), or in Terminal 4, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For any node you create, you will always see **/rosout** and **/parameter_events**.
    Those are not important for now and you can just ignore them. What’s important
    is the **/chatter** topic. We already know it’s used between the talker and listener
    node, but now the question is this: What kind of data is being sent?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this information, we can use **ros2 topic** **info <topic_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see how many nodes are publishing and subscribing to this topic. We
    have one publisher (talker node) and one subscriber (listener node). We can also
    see what kind of message is being sent: **std_msgs/msg/String**. In ROS 2, this
    message is called an **interface**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what’s inside an interface, run **ros2 interface** **show <interface_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be a bunch of comments (starting with **#**) that you can ignore.
    The important thing is this: **string data**. This tells us what’s being sent
    on that topic. Here, it’s a string (chain of characters) with the name **data**.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when the talker node wants to send a message to the **/chatter** topic,
    it needs to send a **data** field of type string. The listener, to get that information,
    will need to subscribe to **/chatter**, and expect to receive the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is how a topic is defined: a name and an interface (data type). Both publishers
    and subscribers should use the same name and interface to communicate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes sense: as an analogy, imagine you and I are talking through an online
    chat. If we are not in the same chat room (same topic name), we won’t be able
    to find each other. Also, if I’m talking to you in a language you don’t speak,
    this would not make sense to you. To communicate, we both need to agree on what
    language we use (same interface).'
  prefs: []
  type: TYPE_NORMAL
- en: More experimentation with topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s practice a bit more with a challenge. This time, I won’t just show you
    what commands to run directly but give you a challenge so you can practice on
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I will sometimes give you some challenges/activities in this book with various
    levels of difficulty —this first challenge being quite small. I will then give
    you the solution (or a part of it). Of course, I encourage you to stop reading
    after the instructions and only use the previous pages to solve the challenge.
    Then, read the solution and compare it with what you did.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the second example we did with the 2D **turtlesim** robot (two nodes).
  prefs: []
  type: TYPE_NORMAL
- en: What I challenge you to do right now is to find the topic name and interface
    used by the **turtle_teleop** node to send a velocity command to the **turtlesim**
    node. Use the previous commands from this chapter to try to get that information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the two nodes and **rqt_graph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 3, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you refresh the view on **rqt_graph** and select **Nodes/Topics (all)**.
    You will get the same as previously, as in *Figure 3**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: There are some more things on this screen, but we just need one piece of information.
    As you can see, there is a **/turtle1/cmd_vel** box, here representing a topic.
    The **teleop_turtle** node is a publisher, and the **turtlesim** node is a subscriber
    to that topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is quite logical: the **teleop_turtle** node will read the keys that you
    press, and then publish on the topic. On its end, the **turtlesim** node will
    subscribe to that topic to get the latest velocity command for the robot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get roughly the same information from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From the list of all running topics, we can spot the **/****turtle1/cmd_vel**
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to retrieve the interface (data type) for that topic, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the details of what’s inside the interface, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This interface is a bit more complex than the one we had before. There’s no
    need to make sense of all of that for now, as we will dive into interfaces later
    in this book. The goal here is just to find a topic name and interface.
  prefs: []
  type: TYPE_NORMAL
- en: From this information, let’s say we want to make the robot move forward. We
    can guess that we would need to set a value for the **x** field, inside the **linear**
    field (as **x** is pointing forward in ROS).
  prefs: []
  type: TYPE_NORMAL
- en: Recap – topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With those two experiments, you can see that nodes communicate with each other
    using topics. One node can publish or subscribe to a topic. When publishing, the
    node sends some data. When subscribing, it receives the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A topic is defined by a name and a data type. That’s all you need to remember
    for now. Let’s switch to the second communication type: services.'
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topics are very useful to send a stream of data/commands from one node to another
    node. However, this is not the only way to communicate. You can also find client/server
    communications in ROS 2\. In this case, **services** will be used.
  prefs: []
  type: TYPE_NORMAL
- en: As we did for topics, we will run two nodes communicating with each other, this
    time with services, and we will try to analyze, using the ROS 2 tools, what’s
    happening and how the communication is working.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282), you will get a much more
    detailed explanation about services, when to use them versus topics, and how to
    include them in your code. For now, let’s just continue with our discovery phase.
  prefs: []
  type: TYPE_NORMAL
- en: Running a service server and client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stop all running nodes. This time, we will start another node from **demo_nodes_cpp**,
    which contains a simple service server to add two integer numbers. We will also
    start a **client** node, which will send a request to the **server** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you run the client node, you can see this log in Terminal 1 (server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see this log in Terminal 2 (client):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From what we observe here, it seems that the server node is hanging and waiting.
    The client node will send a request to the server, with two integer numbers, in
    this example: **2** and **3**. The server node receives the request, adds the
    number, and returns the result: **5**. Then, the client gets the response and
    prints the result.'
  prefs: []
  type: TYPE_NORMAL
- en: This is basically how a service works in ROS 2\. You run one node that contains
    a server, then any other node (client) can send a request to that server. The
    server processes the request and returns a response to the client node.
  prefs: []
  type: TYPE_NORMAL
- en: A name and an interface (data type)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for topics, services are defined by two things: a name, and an interface
    (data type). The only difference is that the interface will contain two parts:
    a **request** and a **response**.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, **rqt_graph** does not support service introspection—although
    there are some plans to implement this in future ROS 2 distributions.
  prefs: []
  type: TYPE_NORMAL
- en: To find the name of the service, we can use the **ros2** command-line tool again,
    this time with the **service** command, followed by **list**. As you can see,
    if you understand the way to list all topics, then it’s exactly the same for services.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you still have the service node running on Terminal 1, and nothing
    running on Terminal 2 (as the client stopped after receiving the response). In
    Terminal 2 or 3, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of services. Most of them can be discarded. For each node, you
    automatically get six additional services, all of them containing the name **parameter**.
    If we ignore them, we can see the **/add_two_ints** service, which is the service
    server running on the **add_two_ints_server** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we found the name. Now, to get the data type, we can use **ros2 service
    type <service_name>**, and then **ros2 interface** **show <interface_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the interface contains a line with three dashes (**---**).
    This is the separation between the request and the response. With this, you know
    that to send a request to the server (as a client), you need to send one integer
    number named **a**, and another integer number named **b**. Then, you will receive
    a response containing one integer number named **sum**.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a request from the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of running the **add_two_ints_client** node, we can also send a request
    directly from the terminal. I’m adding this here because it’s a very useful way
    to test a service without requiring an existing client node.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is **ros2 service call <service_name> <interface_name> "<request_in_json>"**.
    As you can see, we need to provide both the service name and interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to do that (make sure the server node is still running):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, we send a request with **4** and **7**. The server node
    will print those logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the end, on the client side, we get the response that contains **sum=11**.
  prefs: []
  type: TYPE_NORMAL
- en: More experimentation with services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s another challenge for you to practice with services.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the **turtlesim** node, list the existing services, and find how to spawn
    a new turtle robot in the 2D screen, using the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I recommend you take a bit of time to try to do this on your own.
    Feel free to review all the previous commands from this chapter. No need to remember
    all of them as you can easily find them in the book, using the *Tab* key for auto-completion,
    or by adding **-h** to any command.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stop all running nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In Terminal 2, input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Those are all the services we can use for the **turtlesim** node. As you can
    see, we already have quite a lot. In this challenge, you have to spawn a turtle.
    Great, we can find a **/****spawn** service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the name; now, let’s find the interface (request, response):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have all the information we need. To send a request to the server, we
    have to use the **/spawn** service and the **turtlesim/srv/Spawn** interface.
    We can send a request that contains (**x**, **y**, **theta**) coordinates, plus
    an optional name. Actually, note that all fields in the request are optional.
    If you don’t provide a value for a field, the default will be **0** for numbers,
    and **""** for strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now send our request from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the 2D window, you will see a new turtle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The TurtleSim window after spawning a new turtle](img/B22403_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The TurtleSim window after spawning a new turtle
  prefs: []
  type: TYPE_NORMAL
- en: This turtle has been spawned at the (**x**, **y**, **theta**) coordinates provided
    in the request. You can try to run the **ros2 service call** command again a few
    times with different coordinates, so you can spawn more turtles on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have successfully run a client/server communication between two nodes. Once
    again, a service is defined by a name and an interface (request, response).
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the question of when to use topics versus services, read
    on, as this is something we will see later in this book when you understand more
    about each concept. For now, you have just seen two kinds of communication between
    nodes. Each of them has a name and an interface, and we can already play with
    them in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is now one more ROS 2 communication to discover: actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ROS 2 **action** is basically the same thing as a service (client/server communication),
    but designed for longer tasks, and when you might want to also get some feedback
    during the execution, be able to cancel the execution, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In robotics, we are making robots move. Making a robot move is not something
    that happens instantly. It could take a fraction of a second, but sometimes a
    task could take a few seconds/minutes or more. ROS 2 services have been designed
    for quick execution, for example: a computation, or an immediate action, such
    as spawning a turtle on a screen. Actions are used whenever a client/server communication
    might take more time and we want more control over it.'
  prefs: []
  type: TYPE_NORMAL
- en: We will dive into actions with more details in [*Chapter 7*](B22403_07.xhtml#_idTextAnchor338).
    Actions are what I consider to be an intermediate-level concept, not a beginner
    one, so I won’t start to go too deep right now. Let’s just continue the discovery
    phase with a very simple example, just to get an idea of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Running an action server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stop all running nodes, and start the **turtlesim** node again in Terminal
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve already practiced with topics and services, the following **ros2**
    commands will start to look familiar to you. List all existing actions in Terminal
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From what we observe, it seems that the **turtlesim** node contains an action
    server named **/turtle1/rotate_absolute**. There is no existing client node for
    this action, so we will try to interact with it from the terminal. Of course,
    we will need two things: the name and the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: A name and an interface (data type)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for topics and services, an action will be defined by a name and an interface.
    This time, the interface contains three parts: **goal**, **result**, and **feedback**.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal and result are similar to the request and response for a service. The
    feedback is additional data that can be sent by the server to give some feedback
    during the goal execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the action interface, you can run the **ros2 action info <action_name>
    -t** command. Don’t forget to add **-t** (for type), otherwise, you’ll see some
    details, but no interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the action is running within one server (the **turtlesim**
    node), and we also found the interface: **turtlesim/action/RotateAbsolute**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what’s inside this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see two separations with three dashes (**---**). The first part is the
    goal, the second part is the result, and the third part is the feedback. This
    action is quite simple; we only have one float number for each part of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: As a client, we send the desired angle for rotation. The server node will receive
    the goal and process it while optionally sending some feedback. When the goal
    is finished, the server will send the result to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a goal from the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an action client, we are firstly interested in the goal part of the interface.
    Here, we need to send a float number, which corresponds to the angle (in radians)
    we want to rotate the turtle to.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax to send a goal from the terminal is **ros2 action send_goal <action_name>
    <action_interface> "<goal_in_json>"**. Once again, you need to provide both the
    name and interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the **turtlesim** node is alive, then send a goal from Terminal 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After you run the command, you should see the turtle robot rotate on the 2D
    window. Once the desired angle is reached, the action will finish, and you will
    receive the result.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have run your first action communication in ROS 2\. An **action** is defined
    by two things: a name and an interface (goal, result, feedback). Actions are used
    when you need a client/server kind of communication, and when the duration of
    the action might take some time—versus being executed immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, you have seen all three types of communications in ROS 2: topics,
    services, and actions. Each one will get its own chapter in *Part 2* so you can
    see in detail how they work, how to use them in your code, and how to fully introspect
    them with ROS 2 tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to come back to the node itself and talk about another important
    ROS 2 concept: **parameters**.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, it’s not about communication, but about how to give different settings
    to a node when you start it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly discover how parameters work, and you’ll get a complete explanation
    with more examples and use cases in [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394).
  prefs: []
  type: TYPE_NORMAL
- en: Getting the parameters for a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stop all running nodes, and start the **turtlesim** node in Terminal 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to list all parameters, it’s quite easy, and you can probably guess the
    command. If we have **ros2 topic list** for topics, **ros2 service list** for
    services, and **ros2 action list** for actions, then, for parameters, we have
    **ros2 param list**. The only particularity is that we use the word **param**
    instead of **parameter**. Run this command in Terminal 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the `ros2` `param` `list` command doesn’t work properly and you
    won’t see any parameters or not all of them. This can also happen with a few other
    `ros2` commands. In this case, just run the command again, a few times if needed,
    and this should work. It’s probably some kind of bug in the `ros2` command-line
    tool itself, but nothing to worry about: the application is running correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first see the **turtlesim** node (actually written **/turtlesim**, with
    a leading slash), then a list of names under this node, with an indentation. Those
    names are the parameters, and they belong to the node. That’s the first thing
    about parameters in ROS 2: they exist within a node. If you stop this **turtlesim**
    node, then the parameters would also be destroyed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a bunch of parameters you can ignore: **use_sim_time**, **start_type_description_service**,
    and all the parameters containing **qos_overrides**. Those will be present for
    any node you start. If we get rid of them, we are left with a few parameters,
    including **background_b**, **background_g**, **backgound_r**.'
  prefs: []
  type: TYPE_NORMAL
- en: From this observation, it seems that we would be able to change the background
    color of the 2D window when we start the **turtlesim** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what’s inside those parameters? What kind of value? Is it a round number,
    a float, or a string? Let’s find out, with **ros2 param get <node_name> <param_name>**.
    In Terminal 2, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can guess that the **red, green, blue** (**RGB**) value for the
    background is (**69**, **86**, **255**). It also seems that the parameter value
    is a round number from **0** to **255**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a parameter value for a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have found the name of each parameter, and what kind of value we
    should use, let’s modify the value ourselves when we start the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will need to restart the node, using the same syntax as before:
    **ros2 run <package_name> <executable_name>**. We will then add **--ros-args**
    (only once), and **-p <param_name>:=value** for each parameter we want to modify.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the **turtlesim** node on Terminal 1, and start it again, with a different
    value for some of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we decided that both the blue and red colors would be **0**. We don’t
    specify any value for **background_g**, which means that the default value will
    be used (as seen previously: **86**).'
  prefs: []
  type: TYPE_NORMAL
- en: After you run this command, you should see the 2D screen appear, but this time,
    the background is dark green.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters are settings that can be provided at runtime (which means when we
    run the node). They allow us to easily configure the different nodes that we start,
    and thus, they make ROS 2 applications more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: A parameter exists within a node. You can find all parameters for a node and
    get the value for each one. When starting the node, you can give a custom value
    for the parameters you want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Launch files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s finish this list of ROS 2 concepts with launch files.
  prefs: []
  type: TYPE_NORMAL
- en: A **launch file** will allow you to start several nodes and parameters from
    just one file, which means that you can start your entire application with just
    one command line.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443), you will learn how to write
    your own launch file, but for now, let’s just start a few to see what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start a single node in the terminal, you have seen the **ros2 run** command.
    For launch files, we will use **ros2 launch <****package_name> <launch_file>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop all running nodes, and let’s start the **talker_listener** launch file
    from the **demo_nodes_cpp** package. In Terminal 1, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it seems that both the talker and listener nodes have been
    started. You can easily verify that in Terminal 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With **rqt_graph**, you could also check that the nodes communicate with each
    other. We have proof of that with the logs: on the same screen, we get both logs
    from the talker and listener nodes, and it seems that the listener node is receiving
    messages (using the **/chatter** topic as we saw previously).'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it’s the same thing as if we had started both nodes on two terminals.
    The launch file will simply start the two nodes in one terminal.
  prefs: []
  type: TYPE_NORMAL
- en: If we read the logs more carefully, we can see that each node will be started
    in a different process. To stop the launch file, press *Ctrl* + *C*. This will
    stop all processes (nodes), and your application will end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now try another launch file from the **turtlesim** package. Stop the
    launch file in Terminal 1, and start the **multisim** launch file from the **turtlesim**
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With this, you will see not one, but two 2D windows, containing each a turtle
    robot. As you can see from the logs, we are starting two **turtlesim** nodes (two
    identical nodes with a different name each).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check that from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The nodes have been renamed. Instead of just **/turtlesim**, we get **/turtlesim1/turtlesim**
    and **/turtlesim2/turtlesim**. Those names have been chosen inside the launch
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – launch files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch files are quite useful for starting several nodes (and the parameters
    for those nodes) from one file. With just one command line (**ros2 launch**),
    you can start an entire ROS 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: There is not much more to say about launch files for now, as this concept is
    quite simple (the real challenge is when writing a launch file, not starting it).
    We have now finished discovering the main ROS 2 concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter, you have discovered the most important ROS 2 concepts: nodes,
    topics, services, actions, parameters, and launch files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ROS 2 programs are called nodes. Simply put, they are regular software programs
    that can also benefit from ROS 2 functionalities: logs, communications, parameters,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of communication: topics, services, and actions. Topics
    are used to send a stream of data/commands from one or several nodes to another
    or several other nodes. Services are used when we need client/server communication.
    Actions are basically the same things as services, but for goal executions that
    could take some time.'
  prefs: []
  type: TYPE_NORMAL
- en: On top of communication features, nodes can also use parameters to specify settings
    at runtime. Parameters allow nodes to be easily configured when started.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can start all nodes and parameters from just one command line, using
    a launch file.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the core concepts (for now). You have also discovered the **ros2**
    command-line tool and **rqt_graph**. Those tools are invaluable, and you will
    use them all the time. The experiments we did with those tools here are very similar
    to what you will do in the future for your own ROS 2 projects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was a bit special, in a way that it doesn’t fully explain one concept
    from A to Z. As stated in the introduction, it was more of a concept walkthrough,
    where you discover the main concepts through hands-on discovery. What you get
    is not a complete understanding, but an intuition of how things work, a bit of
    experience with the tools, and an idea of the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to come back to this chapter and run the experiments again as you
    make progress with the book. Everything will make much more sense.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to continue with *Part 2*, where you will create a complete
    ROS 2 application from scratch, using Python and C++ code. Each concept you’ve
    seen so far will get its own dedicated chapter. The intuition you’ve developed
    here will be extremely useful.
  prefs: []
  type: TYPE_NORMAL
