- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Uncovering ROS 2 Core Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示 ROS 2 核心概念
- en: You will now start your first ROS 2 programs. As you will see, a ROS 2 program
    is called a **node**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将开始你的第一个 ROS 2 程序。正如你将看到的，一个 ROS 2 程序被称为 **节点**。
- en: What’s inside a node, what does it do, and how do nodes communicate with each
    other? How do you configure nodes and start several of them at the same time?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 节点内部有什么，它做什么，节点之间是如何通信的？你如何配置节点并同时启动多个节点？
- en: That’s what we will focus on in this chapter. We won’t write any code yet but
    instead focus on discovering the concepts through hands-on experimentation, using
    existing demos that were installed along with ROS 2.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中关注的内容。我们不会编写任何代码，而是通过实际实验来探索概念，使用与 ROS 2 一起安装的现有演示。
- en: By the end of this chapter, you will have a global understanding of the main
    ROS 2 core concepts. You will also be familiar with the most important ROS 2 tools
    that you will use later in all your projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对 ROS 2 的主要核心概念有一个全局的理解。你还将熟悉你将在所有项目中使用的最重要的 ROS 2 工具。
- en: Important note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In this chapter, I won’t explain everything. We are going to embark on a discovery
    phase, where we use the different core concepts and guess how they work. Not everything
    has to make sense right now and don’t worry too much if some concepts are still
    a bit blurry for you. Just try to get through the chapter by running all the commands
    yourself.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我不会解释所有内容。我们将开始一个探索阶段，在这个阶段中，我们将使用不同的核心概念并猜测它们是如何工作的。现在不是所有东西都必须有意义，如果你对某些概念仍然有些模糊，请不要过于担心。只需尝试通过运行所有命令来通过本章。
- en: The goal here is not to get a complete understanding or to remember all the
    commands, but rather to get an *intuition* of how things work. This will help
    you tremendously for *Part 2* when we go through each concept with much more detail—and
    develop with them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标不是获得完整的理解或记住所有命令，而是获得对事物工作方式的*直观感受*。这将极大地帮助你理解第二部分，当我们更详细地介绍每个概念并与之一起开发时。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Running your first node
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个节点
- en: Topics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Actions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Parameters
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Launch files
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动文件
- en: Running your first node
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个节点
- en: To understand what a node is, we will simply run one and make some observations
    using some of the most useful ROS 2 tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解节点是什么，我们将简单地运行一个节点并使用一些最有用的 ROS 2 工具进行一些观察。
- en: For this chapter, I recommend having a few open terminals. You can start a few
    terminal windows and arrange them on your screen or run Terminator (see *Extra
    tools for ROS development* in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048))
    with at least three tabs. To clear any confusion when running a command, I will
    also tell you in which terminal to run the command (Terminal 1, Terminal 2, etc.).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我建议打开几个终端。你可以启动几个终端窗口并将它们排列在你的屏幕上，或者使用 Terminator（见[*第 2 章*](B22403_02.xhtml#_idTextAnchor048)中的*ROS
    开发额外工具*）并至少打开三个标签页。为了在运行命令时消除任何混淆，我还会告诉你应该在哪个终端运行该命令（终端 1、终端 2 等）。
- en: Starting a node from the terminal with ros2 run
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ros2 run 从终端启动节点
- en: 'Let’s discover your first ROS 2 tool, and probably the most important one:
    the **ros2** command-line tool. You will use this tool all the time in your future
    projects.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索你的第一个 ROS 2 工具，可能是最重要的一个：**ros2** 命令行工具。你将在未来的项目中一直使用这个工具。
- en: '**ros2** comes with a lot of functions. We will explore some of them in this
    chapter, and more in the following ones. There is no need to remember all the
    commands: just use them to build an understanding now, and later you will easily
    be able to retrieve them from the terminal.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**ros2** 包含了许多功能。在本章中，我们将探索其中的一些，在后续章节中还将介绍更多。没有必要记住所有命令：现在只需使用它们来建立理解，以后你将能够轻松地从终端中检索它们。'
- en: 'To start a node, you have to follow this template: **ros2 run <****package>
    <executable>**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个节点，你必须遵循以下模板：**ros2 run <包名> <可执行文件>**。
- en: As we will see later, nodes are organized inside packages. That’s why you first
    need to specify the package name where the node is and the executable name for
    that node. As we installed ROS Desktop, a lot of demo packages are already included,
    for example, **demo_nodes_cpp**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，节点组织在包内部。这就是为什么你首先需要指定节点所在的包名以及该节点的可执行文件名。由于我们安装了 ROS 桌面，许多演示包已经包含在内，例如，**demo_nodes_cpp**。
- en: 'In Terminal 1, start the talker node from the **demo_nodes_cpp** package:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 1 中，从 **demo_nodes_cpp** 包启动 talker 节点：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you run this command, the node starts. To stop it, simply press *Ctrl*
    + *C* in the terminal where the node is running.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行此命令后，节点开始。要停止它，只需在节点运行的终端中按 *Ctrl* + *C*。
- en: So, what happened here? From what we can observe, this node is simply a program
    that will print a log in the terminal every second.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？从我们能观察到的来看，这个节点只是一个程序，它会在终端每秒打印一条日志。
- en: 'Now, keep the node alive, or start it again if you stopped it. In another terminal
    (Terminal 2), let’s start a different node, which is the listener node from the
    same package:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保持节点存活，或者如果你停止了它，再次启动它。在另一个终端（终端 2）中，让我们启动一个不同的节点，即来自同一包的监听节点：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This node is also a simple program that will print some logs in the terminal.
    However, as you can see, when the two nodes are running (talker and listener),
    whatever is printed on the talker seems to also be received on the listener, which
    then prints it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点也是一个简单的程序，将在终端打印一些日志。然而，正如你所看到的，当两个节点运行时（说话者和监听者），在说话者上打印的任何内容似乎也会被监听者接收，然后打印出来。
- en: In this example, we have two nodes running, and we can clearly see that they
    communicate with each other. If you stop the talker node, you will see that the
    listener node stops printing logs as well. When you restart the talker, the listener
    starts printing what the talker is “sending.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个节点正在运行，我们可以清楚地看到它们正在相互通信。如果你停止了说话节点，你会看到监听节点也会停止打印日志。当你重新启动说话节点时，监听节点开始打印说话节点“发送”的内容。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here are a few tips for when you use the `ros2` command-line tool:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在使用 `ros2` 命令行工具时的提示：
- en: Use auto-completion as much as you can. It will make you type commands faster,
    but more importantly, you will be sure that you type the right command, package
    name, node name, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地使用自动补全。这将使你更快地输入命令，但更重要的是，你可以确保你输入了正确的命令、包名、节点名等等。
- en: If you have any doubts about a command or sub-command, you can get help from
    the terminal by adding `-h` to the command. For example, use `ros2 -h` for the
    global help, or `ros2 run -h` for help specifically for the run sub-command. There’s
    no need to remember all the commands if you know where to find the information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对一个命令或子命令有疑问，你可以在命令中添加 `-h` 来从终端获取帮助。例如，使用 `ros2 -h` 获取全局帮助，或者使用 `ros2 run
    -h` 获取针对运行子命令的帮助。如果你知道在哪里找到信息，就没有必要记住所有的命令。
- en: Introspecting the nodes with rqt_graph
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 rqt_graph 检查节点
- en: 'There is another very useful tool we will discover here, which is a good complement
    to the command line: **rqt_graph**. This tool will show you all running nodes
    with a nice visual.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将发现另一个非常有用的工具，它是命令行的良好补充：**rqt_graph**。这个工具将用漂亮的视觉效果显示所有正在运行的节点。
- en: 'Keep the 2 nodes alive (Terminals 1 and 2) and start **rqt_graph** in Terminal
    3\. The command is identical to the tool name:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保持两个节点（终端 1 和 2）存活，并在终端 3 中启动 **rqt_graph**。命令与工具名称相同：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will open a new graphical window, where you should see the two nodes.
    If you don’t see anything, make sure both nodes are running, and refresh the view
    by clicking on the button with a refresh icon, in the top-left corner. You can
    also select **Nodes/Topics (all)** from the top left drop-down menu. Then, you
    should get something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的图形窗口，你应该能看到两个节点。如果你什么都没有看到，确保两个节点都在运行，并通过点击左上角带有刷新图标的按钮来刷新视图。你还可以从左上角的下拉菜单中选择
    **Nodes/Topics (all)**。然后，你应该会得到类似以下的内容：
- en: '![Figure 3.1 – rqt_graph with two nodes](img/B22403_03_1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 带有两个节点的 rqt_graph](img/B22403_03_1.jpg)'
- en: Figure 3.1 – rqt_graph with two nodes
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 带有两个节点的 rqt_graph
- en: Here, we can see that both nodes are up and running (nothing new for now), but
    we also see an arrow going from the talker node to a box, and another one from
    that box to the listener node. This is the ROS 2 communication that allows the
    talker node to send some data—here, some text—to the listener node. We will talk
    about this communication in the next section of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个节点都在运行（目前没有新的内容），但我们还看到从说话节点到一个方框的箭头，以及从那个方框到监听节点的另一个箭头。这是 ROS 2
    通信，允许说话节点向监听节点发送一些数据——在这里，是一些文本。我们将在本章的下一节中讨论这种通信。
- en: What we can conclude for now is that we started two different ROS programs (nodes)
    in two different terminals, using the **ros2 run** command. It seems that those
    two programs are communicating with each other, and we can confirm that with **rqt_graph**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以得出的结论是，我们在两个不同的终端中使用了 **ros2 run** 命令启动了两个不同的 ROS 程序（节点）。看起来这两个程序正在相互通信，我们可以用
    **rqt_graph** 来确认这一点。
- en: Before we go further and look at what kind of ROS communication it is, let’s
    run another set of nodes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步了解 ROS 通信的类型之前，让我们运行另一组节点。
- en: Running a 2D robot simulation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 2D 机器人模拟
- en: The first two nodes we ran are very simple programs that print logs on the terminal
    and send some text between each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的前两个节点是非常简单的程序，它们在终端上打印日志并在彼此之间发送一些文本。
- en: 'Now, stop all existing nodes (press *Ctrl* + *C* in each terminal), and let’s
    start again with some other nodes. In Terminal 1, run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，停止所有现有的节点（在每个终端中按 *Ctrl* + *C*），然后让我们用一些其他节点重新开始。在终端 1 中运行以下命令：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll see a few logs, but more importantly, you will get a new window with
    a blue background and a turtle in the middle. This turtle represents a (very simplified)
    simulated robot that moves in 2D space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些日志，但更重要的是，你将得到一个带有蓝色背景和中间有海龟的新窗口。这个海龟代表一个（非常简化的）在 2D 空间中移动的模拟机器人。
- en: 'In Terminal 2, start this second node:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 2 中，启动这个第二个节点：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After you see this, make sure Terminal 2 is selected, and use the arrow keys
    (up, down, left, right). When doing this, you should see the turtle robot moving.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这一点后，确保终端 2 已选中，并使用箭头键（上、下、左、右）。当你这样做的时候，你应该看到海龟机器人移动。
- en: '![Figure 3.2 – Moving the simulated turtle robot (TurtleSim)](img/B22403_03_2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 移动模拟海龟机器人（TurtleSim）](img/B22403_03_2.jpg)'
- en: Figure 3.2 – Moving the simulated turtle robot (TurtleSim)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 移动模拟海龟机器人（TurtleSim）
- en: 'We can already guess that the second node we started (with **turtle_teleop_key**)
    is reading the keys you press on the keyboard and sending some kind of information/command
    to the **turtlesim** node, which then makes the turtle robot move. To confirm
    that, start **rqt_graph** again on Terminal 3:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以猜测，我们启动的第二个节点（使用 **turtle_teleop_key**）正在读取你按在键盘上的键，并将某种信息/命令发送到 **turtlesim**
    节点，然后该节点使海龟机器人移动。为了确认这一点，请在终端 3 上再次启动 **rqt_graph**：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If needed, refresh the view a few times. Select **Nodes/Topics (all)**, and
    you’ll see something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，刷新视图几次。选择 **节点/主题（全部）**，你会看到类似这样的内容：
- en: '![Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes](img/B22403_03_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 带有 turtlesim 和 teleop_turtle 节点的 rqt_graph](img/B22403_03_3.jpg)'
- en: Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 带有 turtlesim 和 teleop_turtle 节点的 rqt_graph
- en: We can find a node named **turtlesim** and another one named **teleop_turtle**,
    and we can clearly see that the two nodes are communicating with each other.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到一个名为 **turtlesim** 的节点和一个名为 **teleop_turtle** 的节点，我们可以清楚地看到这两个节点正在彼此通信。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, the executable name (`turtle_teleop_key`) we used to start the
    node is not necessarily the same as the node name (`teleop_turtle`). We’ll come
    back to this later in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们用来启动节点的可执行文件名（`turtle_teleop_key`）不一定与节点名（`teleop_turtle`）相同。我们将在本书的后面回到这个问题。
- en: Recap – nodes
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 – 节点
- en: 'What can we get from those two experiments? As you can see, a ROS 2 node can
    be any kind of computer program that contains:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个实验中我们能得到什么？正如你所见，ROS 2 节点可以是任何包含以下内容的计算机程序：
- en: Instructions to print logs in the terminal
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令用于在终端打印日志
- en: Graphical windows (2D, can also be 3D)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形窗口（2D，也可以是 3D）
- en: Hardware drivers and more
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件驱动程序等
- en: 'A node, on top of being a computer program, also benefits from the ROS 2 functionalities:
    logs, communication with other nodes, and other features we will discover throughout
    this book.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是一个计算机程序之外，节点还受益于 ROS 2 的功能：日志、与其他节点的通信以及本书中将发现的其它特性。
- en: Now that you’ve seen how to start a node and use the **ros2** command-line tool,
    let’s focus on how they communicate with each other.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何启动节点和使用 **ros2** 命令行工具，让我们关注它们是如何相互通信的。
- en: Topics
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: 'Nodes communicate with each other using ROS 2 communication features. There
    are three types of communication: topics, services, and actions. We will discover
    all three of them, starting with **topics**.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 节点使用 ROS 2 通信功能相互通信。有三种类型的通信：主题、服务和动作。我们将发现所有三种，从 **主题** 开始。
- en: Here, we will make some basic discoveries to get an idea of what a ROS 2 topic
    is, and you’ll learn much more about them, including how to write code for topics,
    in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将做一些基本的发现，以了解 ROS 2 主题是什么，你将了解更多关于它们的信息，包括如何为主题编写代码，在[*第五章*](B22403_05.xhtml#_idTextAnchor211)中。
- en: Running a topic publisher and subscriber
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行主题发布者和订阅者
- en: Stop all running nodes (*Ctrl* + *C*), and let’s come back to our first example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有正在运行的节点（*Ctrl* + *C*），然后让我们回到我们的第一个例子。
- en: 'In Terminal 1, input the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Terminal 2, input the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In Terminal 3, input the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If needed, refresh the view a few times, select **Nodes/Topics (all)**, and
    you should get the same visual as in *Figure 3**.1*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In the middle, you will see a **/chatter** box. This box represents a ROS 2
    topic. What you can also see is that the talker node is sending something to the
    **/chatter** topic, which will then be received by the listener node.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: We say that the talker is a **publisher**, and the listener is a **subscriber**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: An important detail is that the talker is not actually sending data directly
    to the listener. The talker is publishing on the **/chatter** topic, and the listener
    is subscribing to the **/chatter** topic. Because of this, the data flows from
    the talker to the listener.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: A name and an interface (data type)
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From **rqt_graph**, we can already see that one node can send data to another
    node through a topic. An important point is that the topic is defined by a name.
    Both publishers and subscribers use the same name to make communication successful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There is more to it than just a name. Let’s come back to the terminal and use
    the **ros2** command-line tool to discover more information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You previously used **ros2 run** to start a node. We also have **ros2 topic**
    to interact with topics. You can get more help with all available topic commands
    with **ros2 topic -h**. The **ros2 topic list** command will list all available
    topics, which means all topic communications between running nodes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 3 (if you stopped **rqt_graph**), or in Terminal 4, run the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For any node you create, you will always see **/rosout** and **/parameter_events**.
    Those are not important for now and you can just ignore them. What’s important
    is the **/chatter** topic. We already know it’s used between the talker and listener
    node, but now the question is this: What kind of data is being sent?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this information, we can use **ros2 topic** **info <topic_name>**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we see how many nodes are publishing and subscribing to this topic. We
    have one publisher (talker node) and one subscriber (listener node). We can also
    see what kind of message is being sent: **std_msgs/msg/String**. In ROS 2, this
    message is called an **interface**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what’s inside an interface, run **ros2 interface** **show <interface_name>**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There can be a bunch of comments (starting with **#**) that you can ignore.
    The important thing is this: **string data**. This tells us what’s being sent
    on that topic. Here, it’s a string (chain of characters) with the name **data**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: So, when the talker node wants to send a message to the **/chatter** topic,
    it needs to send a **data** field of type string. The listener, to get that information,
    will need to subscribe to **/chatter**, and expect to receive the same data type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'That is how a topic is defined: a name and an interface (data type). Both publishers
    and subscribers should use the same name and interface to communicate.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是主题是如何定义的：一个名称和一个界面（数据类型）。发布者和订阅者都应该使用相同的名称和界面来进行通信。
- en: 'This makes sense: as an analogy, imagine you and I are talking through an online
    chat. If we are not in the same chat room (same topic name), we won’t be able
    to find each other. Also, if I’m talking to you in a language you don’t speak,
    this would not make sense to you. To communicate, we both need to agree on what
    language we use (same interface).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的：作为一个类比，想象你和我通过在线聊天进行交流。如果我们不在同一个聊天室（同一个主题名称），我们就找不到对方。此外，如果我用你不懂的语言和你说话，这对你来说就没有意义。为了交流，我们都需要同意使用什么语言（相同的界面）。
- en: More experimentation with topics
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对主题进行更多实验
- en: Let’s practice a bit more with a challenge. This time, I won’t just show you
    what commands to run directly but give you a challenge so you can practice on
    your own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个挑战来练习一下。这次，我不会直接展示要运行的命令，而是给你一个挑战，这样你可以自己练习。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I will sometimes give you some challenges/activities in this book with various
    levels of difficulty —this first challenge being quite small. I will then give
    you the solution (or a part of it). Of course, I encourage you to stop reading
    after the instructions and only use the previous pages to solve the challenge.
    Then, read the solution and compare it with what you did.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在本书中有时给你一些挑战/活动，难度各不相同——这个第一个挑战相当小。然后我会给你解决方案（或其中一部分）。当然，我鼓励你在阅读说明后停止阅读，只使用前面的页面来解决挑战。然后，阅读解决方案，并与你所做的内容进行比较。
- en: Challenge
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: Run the second example we did with the 2D **turtlesim** robot (two nodes).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们之前用2D **turtlesim**机器人（两个节点）做的第二个例子。
- en: What I challenge you to do right now is to find the topic name and interface
    used by the **turtle_teleop** node to send a velocity command to the **turtlesim**
    node. Use the previous commands from this chapter to try to get that information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在挑战你做的是找到**turtle_teleop**节点用来向**turtlesim**节点发送速度命令的主题名称和界面。使用本章前面的命令尝试获取这些信息。
- en: Solution
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Start the two nodes and **rqt_graph**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 启动两个节点和**rqt_graph**。
- en: 'In Terminal 1, input the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端1中，输入以下内容：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Terminal 2, input the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端2中，输入以下内容：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Terminal 3, input the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端3中，输入以下内容：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Make sure you refresh the view on **rqt_graph** and select **Nodes/Topics (all)**.
    You will get the same as previously, as in *Figure 3**.3*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在**rqt_graph**上刷新视图并选择**节点/主题（全部）**。你将得到与之前相同的内容，如*图3*。3*。
- en: There are some more things on this screen, but we just need one piece of information.
    As you can see, there is a **/turtle1/cmd_vel** box, here representing a topic.
    The **teleop_turtle** node is a publisher, and the **turtlesim** node is a subscriber
    to that topic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上还有一些其他内容，但我们只需要一条信息。正如你所见，有一个**/turtle1/cmd_vel**框，这里代表一个主题。**teleop_turtle**节点是一个发布者，而**turtlesim**节点是该主题的订阅者。
- en: 'This is quite logical: the **teleop_turtle** node will read the keys that you
    press, and then publish on the topic. On its end, the **turtlesim** node will
    subscribe to that topic to get the latest velocity command for the robot.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有逻辑性：**teleop_turtle**节点将读取你按下的键，然后在该主题上发布。在其末端，**turtlesim**节点将订阅该主题以获取机器人的最新速度命令。
- en: 'We can get roughly the same information from the terminal:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从终端中获得大致相同的信息：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the list of all running topics, we can spot the **/****turtle1/cmd_vel**
    topic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有运行的主题列表中，我们可以找到**/****turtle1/cmd_vel**主题。
- en: 'Now, to retrieve the interface (data type) for that topic, run the following
    command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了获取该主题的界面（数据类型），请运行以下命令：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the details of what’s inside the interface, run the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解界面的详细信息，请运行以下命令：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This interface is a bit more complex than the one we had before. There’s no
    need to make sense of all of that for now, as we will dive into interfaces later
    in this book. The goal here is just to find a topic name and interface.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界面比我们之前用的要复杂一些。现在没有必要去理解所有这些内容，因为我们会在本书的后面部分深入探讨界面。这里的目的是仅仅找到主题名称和界面。
- en: From this information, let’s say we want to make the robot move forward. We
    can guess that we would need to set a value for the **x** field, inside the **linear**
    field (as **x** is pointing forward in ROS).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，假设我们想让机器人向前移动。我们可以猜测，我们需要在**linear**字段内设置**x**字段的值（因为在ROS中，**x**指向前方）。
- en: Recap – topics
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述 – 主题
- en: With those two experiments, you can see that nodes communicate with each other
    using topics. One node can publish or subscribe to a topic. When publishing, the
    node sends some data. When subscribing, it receives the data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个实验，你可以看到节点通过主题相互通信。一个节点可以发布或订阅一个主题。发布时，节点发送一些数据。订阅时，它接收数据。
- en: 'A topic is defined by a name and a data type. That’s all you need to remember
    for now. Let’s switch to the second communication type: services.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 主题由一个名称和数据类型定义。现在你需要记住的就是这些。让我们切换到第二种通信类型：服务。
- en: Services
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Topics are very useful to send a stream of data/commands from one node to another
    node. However, this is not the only way to communicate. You can also find client/server
    communications in ROS 2\. In this case, **services** will be used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 主题非常有用，可以从一个节点向另一个节点发送数据/命令流。然而，这并不是唯一的通信方式。你还可以在 ROS 2 中找到客户端/服务器通信。在这种情况下，**服务**将被使用。
- en: As we did for topics, we will run two nodes communicating with each other, this
    time with services, and we will try to analyze, using the ROS 2 tools, what’s
    happening and how the communication is working.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对主题所做的那样，我们将运行两个节点通过服务相互通信，这次我们将尝试使用 ROS 2 工具分析正在发生的事情以及通信是如何工作的。
- en: In [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282), you will get a much more
    detailed explanation about services, when to use them versus topics, and how to
    include them in your code. For now, let’s just continue with our discovery phase.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B22403_06.xhtml#_idTextAnchor282) 中，你将得到关于服务、何时使用它们与主题相比以及如何在代码中包含它们的更详细解释。现在，让我们继续我们的探索阶段。
- en: Running a service server and client
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行服务服务器和客户端
- en: Stop all running nodes. This time, we will start another node from **demo_nodes_cpp**,
    which contains a simple service server to add two integer numbers. We will also
    start a **client** node, which will send a request to the **server** node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有正在运行的节点。这次，我们将从 **demo_nodes_cpp** 中启动另一个节点，它包含一个简单的服务服务器，用于添加两个整数。我们还将启动一个
    **客户端** 节点，该节点将向 **服务器** 节点发送请求。
- en: 'In Terminal 1, input the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 1 中，输入以下命令：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Terminal 2, input the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 2 中，输入以下命令：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As soon as you run the client node, you can see this log in Terminal 1 (server):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行客户端节点，你可以在终端 1（服务器）中看到这个日志：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also see this log in Terminal 2 (client):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在终端 2（客户端）中看到这个日志：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From what we observe here, it seems that the server node is hanging and waiting.
    The client node will send a request to the server, with two integer numbers, in
    this example: **2** and **3**. The server node receives the request, adds the
    number, and returns the result: **5**. Then, the client gets the response and
    prints the result.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在这里观察到的来看，似乎服务器节点正在挂起并等待。客户端节点将向服务器发送一个请求，包含两个整数，在这个例子中是：**2** 和 **3**。服务器节点接收请求，相加数字，并返回结果：**5**。然后，客户端获取响应并打印结果。
- en: This is basically how a service works in ROS 2\. You run one node that contains
    a server, then any other node (client) can send a request to that server. The
    server processes the request and returns a response to the client node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是 ROS 2 中服务工作的方式。你运行一个包含服务器的节点，然后任何其他节点（客户端）都可以向该服务器发送请求。服务器处理请求并返回响应给客户端节点。
- en: A name and an interface (data type)
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个名称和一个接口（数据类型）
- en: 'As for topics, services are defined by two things: a name, and an interface
    (data type). The only difference is that the interface will contain two parts:
    a **request** and a **response**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主题，服务由两个东西定义：一个名称和一个接口（数据类型）。唯一的区别是接口将包含两部分：一个 **请求** 和一个 **响应**。
- en: Unfortunately, **rqt_graph** does not support service introspection—although
    there are some plans to implement this in future ROS 2 distributions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，**rqt_graph** 不支持服务内省——尽管有一些计划在未来 ROS 2 发行版中实现这一功能。
- en: To find the name of the service, we can use the **ros2** command-line tool again,
    this time with the **service** command, followed by **list**. As you can see,
    if you understand the way to list all topics, then it’s exactly the same for services.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到服务的名称，我们可以再次使用 **ros2** 命令行工具，这次使用 **service** 命令，后面跟 **list**。正如你所见，如果你理解了如何列出所有主题，那么对于服务来说也是一样的。
- en: 'At this point, you still have the service node running on Terminal 1, and nothing
    running on Terminal 2 (as the client stopped after receiving the response). In
    Terminal 2 or 3, run the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你仍然在终端 1 上运行着服务节点，而终端 2 上没有运行任何东西（因为客户端在收到响应后停止了）。在终端 2 或 3 上，运行以下命令：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s a lot of services. Most of them can be discarded. For each node, you
    automatically get six additional services, all of them containing the name **parameter**.
    If we ignore them, we can see the **/add_two_ints** service, which is the service
    server running on the **add_two_ints_server** node.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we found the name. Now, to get the data type, we can use **ros2 service
    type <service_name>**, and then **ros2 interface** **show <interface_name>**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that the interface contains a line with three dashes (**---**).
    This is the separation between the request and the response. With this, you know
    that to send a request to the server (as a client), you need to send one integer
    number named **a**, and another integer number named **b**. Then, you will receive
    a response containing one integer number named **sum**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Sending a request from the terminal
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of running the **add_two_ints_client** node, we can also send a request
    directly from the terminal. I’m adding this here because it’s a very useful way
    to test a service without requiring an existing client node.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is **ros2 service call <service_name> <interface_name> "<request_in_json>"**.
    As you can see, we need to provide both the service name and interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to do that (make sure the server node is still running):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this command, we send a request with **4** and **7**. The server node
    will print those logs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the end, on the client side, we get the response that contains **sum=11**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: More experimentation with services
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s another challenge for you to practice with services.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the **turtlesim** node, list the existing services, and find how to spawn
    a new turtle robot in the 2D screen, using the terminal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I recommend you take a bit of time to try to do this on your own.
    Feel free to review all the previous commands from this chapter. No need to remember
    all of them as you can easily find them in the book, using the *Tab* key for auto-completion,
    or by adding **-h** to any command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stop all running nodes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, input the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In Terminal 2, input the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Those are all the services we can use for the **turtlesim** node. As you can
    see, we already have quite a lot. In this challenge, you have to spawn a turtle.
    Great, we can find a **/****spawn** service.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the name; now, let’s find the interface (request, response):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we have all the information we need. To send a request to the server, we
    have to use the **/spawn** service and the **turtlesim/srv/Spawn** interface.
    We can send a request that contains (**x**, **y**, **theta**) coordinates, plus
    an optional name. Actually, note that all fields in the request are optional.
    If you don’t provide a value for a field, the default will be **0** for numbers,
    and **""** for strings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now send our request from the terminal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you look at the 2D window, you will see a new turtle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The TurtleSim window after spawning a new turtle](img/B22403_03_4.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 生成新海龟后的 TurtleSim 窗口](img/B22403_03_4.jpg)'
- en: Figure 3.4 – The TurtleSim window after spawning a new turtle
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 生成新海龟后的 TurtleSim 窗口
- en: This turtle has been spawned at the (**x**, **y**, **theta**) coordinates provided
    in the request. You can try to run the **ros2 service call** command again a few
    times with different coordinates, so you can spawn more turtles on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个海龟已经在请求中提供的（**x**，**y**，**theta**）坐标处生成。您可以尝试再次运行 **ros2 service call** 命令几次，使用不同的坐标，这样您就可以在屏幕上生成更多的海龟。
- en: Recap – services
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 – 服务
- en: You have successfully run a client/server communication between two nodes. Once
    again, a service is defined by a name and an interface (request, response).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经成功在两个节点之间运行了客户端/服务器通信。再次强调，服务是由名称和接口（请求，响应）定义的。
- en: For more details about the question of when to use topics versus services, read
    on, as this is something we will see later in this book when you understand more
    about each concept. For now, you have just seen two kinds of communication between
    nodes. Each of them has a name and an interface, and we can already play with
    them in the terminal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用主题与服务的更多细节，请继续阅读，因为这是我们将在本书的后面部分看到的，那时您将更了解每个概念。现在，您已经看到了节点之间的两种通信方式。每种通信都有一个名称和接口，我们已经在终端中可以与之互动。
- en: 'There is now one more ROS 2 communication to discover: actions.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还有一个需要发现的 ROS 2 通信：动作。
- en: Actions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作
- en: A ROS 2 **action** is basically the same thing as a service (client/server communication),
    but designed for longer tasks, and when you might want to also get some feedback
    during the execution, be able to cancel the execution, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2 的 **动作**基本上与服务（客户端/服务器通信）相同，但设计用于更长时间的任务，并且当您可能希望在执行过程中也获得一些反馈，能够取消执行等。
- en: 'In robotics, we are making robots move. Making a robot move is not something
    that happens instantly. It could take a fraction of a second, but sometimes a
    task could take a few seconds/minutes or more. ROS 2 services have been designed
    for quick execution, for example: a computation, or an immediate action, such
    as spawning a turtle on a screen. Actions are used whenever a client/server communication
    might take more time and we want more control over it.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人领域，我们使机器人移动。使机器人移动不是瞬间发生的事情。它可能只需要一秒钟的几分之一，但有时一个任务可能需要几秒钟/几分钟或更长时间。ROS 2
    服务是为快速执行设计的，例如：计算，或者立即动作，比如在屏幕上生成海龟。当客户端/服务器通信可能需要更多时间，并且我们希望对其有更多控制时，就会使用动作。
- en: We will dive into actions with more details in [*Chapter 7*](B22403_07.xhtml#_idTextAnchor338).
    Actions are what I consider to be an intermediate-level concept, not a beginner
    one, so I won’t start to go too deep right now. Let’s just continue the discovery
    phase with a very simple example, just to get an idea of how it works.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 7 章*](B22403_07.xhtml#_idTextAnchor338) 中更详细地探讨动作。动作是我认为的一个中级概念，而不是初级概念，所以现在我不会深入探讨。让我们只是通过一个非常简单的例子继续探索阶段，以便了解它是如何工作的。
- en: Running an action server
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行动作服务器
- en: 'Stop all running nodes, and start the **turtlesim** node again in Terminal
    1:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有正在运行的节点，并在终端 1 中再次启动 **turtlesim** 节点：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you’ve already practiced with topics and services, the following **ros2**
    commands will start to look familiar to you. List all existing actions in Terminal
    2:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经通过主题和服务实践过的，以下 **ros2** 命令将开始对您来说变得熟悉。在终端 2 中列出所有现有的动作：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From what we observe, it seems that the **turtlesim** node contains an action
    server named **/turtle1/rotate_absolute**. There is no existing client node for
    this action, so we will try to interact with it from the terminal. Of course,
    we will need two things: the name and the interface.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们所观察到的来看，似乎 **turtlesim** 节点包含一个名为 **/turtle1/rotate_absolute** 的动作服务器。目前还没有为这个动作创建客户端节点，因此我们将尝试从终端与之交互。当然，我们需要两样东西：名称和接口。
- en: A name and an interface (data type)
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称和接口（数据类型）
- en: 'As for topics and services, an action will be defined by a name and an interface.
    This time, the interface contains three parts: **goal**, **result**, and **feedback**.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于主题和服务，一个动作将由一个名称和一个接口定义。这次，接口包含三个部分：**目标**、**结果**和**反馈**。
- en: The goal and result are similar to the request and response for a service. The
    feedback is additional data that can be sent by the server to give some feedback
    during the goal execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目标和结果类似于服务的请求和响应。反馈是服务器可以发送的附加数据，可以在目标执行期间提供一些反馈。
- en: 'To get the action interface, you can run the **ros2 action info <action_name>
    -t** command. Don’t forget to add **-t** (for type), otherwise, you’ll see some
    details, but no interface:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can see that the action is running within one server (the **turtlesim**
    node), and we also found the interface: **turtlesim/action/RotateAbsolute**.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what’s inside this interface:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see two separations with three dashes (**---**). The first part is the
    goal, the second part is the result, and the third part is the feedback. This
    action is quite simple; we only have one float number for each part of the interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As a client, we send the desired angle for rotation. The server node will receive
    the goal and process it while optionally sending some feedback. When the goal
    is finished, the server will send the result to the client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Sending a goal from the terminal
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an action client, we are firstly interested in the goal part of the interface.
    Here, we need to send a float number, which corresponds to the angle (in radians)
    we want to rotate the turtle to.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The syntax to send a goal from the terminal is **ros2 action send_goal <action_name>
    <action_interface> "<goal_in_json>"**. Once again, you need to provide both the
    name and interface.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the **turtlesim** node is alive, then send a goal from Terminal 2:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After you run the command, you should see the turtle robot rotate on the 2D
    window. Once the desired angle is reached, the action will finish, and you will
    receive the result.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Recap – actions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have run your first action communication in ROS 2\. An **action** is defined
    by two things: a name and an interface (goal, result, feedback). Actions are used
    when you need a client/server kind of communication, and when the duration of
    the action might take some time—versus being executed immediately.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, you have seen all three types of communications in ROS 2: topics,
    services, and actions. Each one will get its own chapter in *Part 2* so you can
    see in detail how they work, how to use them in your code, and how to fully introspect
    them with ROS 2 tools.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to come back to the node itself and talk about another important
    ROS 2 concept: **parameters**.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This time, it’s not about communication, but about how to give different settings
    to a node when you start it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly discover how parameters work, and you’ll get a complete explanation
    with more examples and use cases in [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Getting the parameters for a node
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stop all running nodes, and start the **turtlesim** node in Terminal 1:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, to list all parameters, it’s quite easy, and you can probably guess the
    command. If we have **ros2 topic list** for topics, **ros2 service list** for
    services, and **ros2 action list** for actions, then, for parameters, we have
    **ros2 param list**. The only particularity is that we use the word **param**
    instead of **parameter**. Run this command in Terminal 2:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the `ros2` `param` `list` command doesn’t work properly and you
    won’t see any parameters or not all of them. This can also happen with a few other
    `ros2` commands. In this case, just run the command again, a few times if needed,
    and this should work. It’s probably some kind of bug in the `ros2` command-line
    tool itself, but nothing to worry about: the application is running correctly.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We first see the **turtlesim** node (actually written **/turtlesim**, with
    a leading slash), then a list of names under this node, with an indentation. Those
    names are the parameters, and they belong to the node. That’s the first thing
    about parameters in ROS 2: they exist within a node. If you stop this **turtlesim**
    node, then the parameters would also be destroyed.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a bunch of parameters you can ignore: **use_sim_time**, **start_type_description_service**,
    and all the parameters containing **qos_overrides**. Those will be present for
    any node you start. If we get rid of them, we are left with a few parameters,
    including **background_b**, **background_g**, **backgound_r**.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: From this observation, it seems that we would be able to change the background
    color of the 2D window when we start the **turtlesim** node.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what’s inside those parameters? What kind of value? Is it a round number,
    a float, or a string? Let’s find out, with **ros2 param get <node_name> <param_name>**.
    In Terminal 2, run the following commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From this, we can guess that the **red, green, blue** (**RGB**) value for the
    background is (**69**, **86**, **255**). It also seems that the parameter value
    is a round number from **0** to **255**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a parameter value for a node
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have found the name of each parameter, and what kind of value we
    should use, let’s modify the value ourselves when we start the node.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will need to restart the node, using the same syntax as before:
    **ros2 run <package_name> <executable_name>**. We will then add **--ros-args**
    (only once), and **-p <param_name>:=value** for each parameter we want to modify.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the **turtlesim** node on Terminal 1, and start it again, with a different
    value for some of the parameters:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we decided that both the blue and red colors would be **0**. We don’t
    specify any value for **background_g**, which means that the default value will
    be used (as seen previously: **86**).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: After you run this command, you should see the 2D screen appear, but this time,
    the background is dark green.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Recap – parameters
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters are settings that can be provided at runtime (which means when we
    run the node). They allow us to easily configure the different nodes that we start,
    and thus, they make ROS 2 applications more dynamic.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: A parameter exists within a node. You can find all parameters for a node and
    get the value for each one. When starting the node, you can give a custom value
    for the parameters you want to modify.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Launch files
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s finish this list of ROS 2 concepts with launch files.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A **launch file** will allow you to start several nodes and parameters from
    just one file, which means that you can start your entire application with just
    one command line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443), you will learn how to write
    your own launch file, but for now, let’s just start a few to see what they do.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Starting a launch file
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start a single node in the terminal, you have seen the **ros2 run** command.
    For launch files, we will use **ros2 launch <****package_name> <launch_file>**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop all running nodes, and let’s start the **talker_listener** launch file
    from the **demo_nodes_cpp** package. In Terminal 1, run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, it seems that both the talker and listener nodes have been
    started. You can easily verify that in Terminal 2:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With **rqt_graph**, you could also check that the nodes communicate with each
    other. We have proof of that with the logs: on the same screen, we get both logs
    from the talker and listener nodes, and it seems that the listener node is receiving
    messages (using the **/chatter** topic as we saw previously).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it’s the same thing as if we had started both nodes on two terminals.
    The launch file will simply start the two nodes in one terminal.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: If we read the logs more carefully, we can see that each node will be started
    in a different process. To stop the launch file, press *Ctrl* + *C*. This will
    stop all processes (nodes), and your application will end.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now try another launch file from the **turtlesim** package. Stop the
    launch file in Terminal 1, and start the **multisim** launch file from the **turtlesim**
    package:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this, you will see not one, but two 2D windows, containing each a turtle
    robot. As you can see from the logs, we are starting two **turtlesim** nodes (two
    identical nodes with a different name each).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check that from the terminal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The nodes have been renamed. Instead of just **/turtlesim**, we get **/turtlesim1/turtlesim**
    and **/turtlesim2/turtlesim**. Those names have been chosen inside the launch
    file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Recap – launch files
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch files are quite useful for starting several nodes (and the parameters
    for those nodes) from one file. With just one command line (**ros2 launch**),
    you can start an entire ROS 2 application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: There is not much more to say about launch files for now, as this concept is
    quite simple (the real challenge is when writing a launch file, not starting it).
    We have now finished discovering the main ROS 2 concepts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter, you have discovered the most important ROS 2 concepts: nodes,
    topics, services, actions, parameters, and launch files.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'ROS 2 programs are called nodes. Simply put, they are regular software programs
    that can also benefit from ROS 2 functionalities: logs, communications, parameters,
    and so on.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of communication: topics, services, and actions. Topics
    are used to send a stream of data/commands from one or several nodes to another
    or several other nodes. Services are used when we need client/server communication.
    Actions are basically the same things as services, but for goal executions that
    could take some time.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种通信类型：主题、服务和动作。主题用于从一个或多个节点向另一个或多个其他节点发送数据/命令流。服务用于需要客户端/服务器通信的情况。动作基本上与服务相同，但对于可能需要一些时间的目标执行。
- en: On top of communication features, nodes can also use parameters to specify settings
    at runtime. Parameters allow nodes to be easily configured when started.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通信功能外，节点还可以使用参数来指定运行时的设置。参数允许节点在启动时轻松配置。
- en: Finally, we can start all nodes and parameters from just one command line, using
    a launch file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过一个启动文件从一条命令行启动所有节点和参数。
- en: That’s it for the core concepts (for now). You have also discovered the **ros2**
    command-line tool and **rqt_graph**. Those tools are invaluable, and you will
    use them all the time. The experiments we did with those tools here are very similar
    to what you will do in the future for your own ROS 2 projects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于核心概念（目前是这样），你已经发现了**ros2**命令行工具和**rqt_graph**。这些工具是无价的，你将经常使用它们。我们使用这些工具进行的实验与你在未来的ROS
    2项目中将要做的非常相似。
- en: This chapter was a bit special, in a way that it doesn’t fully explain one concept
    from A to Z. As stated in the introduction, it was more of a concept walkthrough,
    where you discover the main concepts through hands-on discovery. What you get
    is not a complete understanding, but an intuition of how things work, a bit of
    experience with the tools, and an idea of the big picture.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节有点特别，因为它并没有从A到Z完整地解释一个概念。正如引言中所述，它更像是一个概念巡游，通过实际操作发现主要概念。你得到的不是完整的理解，而是对事物工作方式的直觉，一些工具的使用经验，以及对整体图景的认识。
- en: Feel free to come back to this chapter and run the experiments again as you
    make progress with the book. Everything will make much more sense.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以回到这一章节，在你阅读本书的过程中再次运行实验。一切都会变得更加有意义。
- en: You are now ready to continue with *Part 2*, where you will create a complete
    ROS 2 application from scratch, using Python and C++ code. Each concept you’ve
    seen so far will get its own dedicated chapter. The intuition you’ve developed
    here will be extremely useful.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好继续进行**第2部分**，在那里，你将从头开始创建一个完整的ROS 2应用程序，使用Python和C++代码。你迄今为止看到的每个概念都将有自己的专属章节。在这里培养的直觉将非常有用。
