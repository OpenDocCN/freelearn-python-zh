- en: Chapter 2. Starting with Python Strings, Files, and Menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with text and strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using files and handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a boot-up menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a self-defining menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discuss how to use Python to perform some basic encryption
    by scrambling letters. This will introduce some basic string manipulation, user
    input, progressing on to creating reusable modules, and graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: To follow, we will create some useful Python scripts that can be added to run
    as the Raspberry Pi boots or an easy-to-run command that will provide quick shortcuts
    to common or frequently-used commands. Taking this further, we will make use of
    threading to run multiple tasks and introduce classes to define multiple objects.
  prefs: []
  type: TYPE_NORMAL
- en: As it is customary to start any programming exercise with a *Hello World* example,
    we will kick off with that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `hellopi.py` file using `nano`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our `hellopi.py` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When done, save and exit (*Ctrl* + *X*, *Y*, and *Enter*). To run the file,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you have created your first program!
  prefs: []
  type: TYPE_NORMAL
- en: 'Your result should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/6623OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Hello Raspberry Pi output
  prefs: []
  type: TYPE_NORMAL
- en: Working with text and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good starting point for Python is to gain an understanding of basic text handling
    and strings. A string is a block of characters stored together as a value. As
    you will learn, they can be viewed as a simple list of characters.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script to obtain the user's input, use string manipulation
    to switch around the letters, and print out a coded version of the message. We
    will then extend this example by demonstrating how encoded messages can be passed
    between parties without revealing the encoding methods, while also showing how
    to reuse sections of the code within other Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use most text editors to write Python code. They can be used directly
    on the Raspberry Pi or remotely through VNC or SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few text editors that are available with the Raspberry
    Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nano**: This text editor is available at the terminal and includes syntax
    highlighting and line numbers (with the `-c` option). Refer to the following screenshot:![Getting
    ready](img/6623OT_02_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nano command-line editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**IDLE3**: This Python editor includes the syntax highlighting feature, context
    help, and will run scripts directly from the editor (on pressing *F5*). This program
    requires X-Windows (the Debian desktop) or X11-forwarding to run remotely. We
    will be using Python 3 throughout the book, so ensure that you run IDLE3 (rather
    than IDLE), which will use Python 3 to run the scripts, as shown in the following
    screenshot:![Getting ready](img/6623OT_02_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IDLE3 Python editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Geany**: This text editor provides an **Integrated Development Environment**
    (**IDE**) that supports a range of programming languages, syntax highlighting,
    auto completion, and easy code navigation. This is a feature-rich editor, but
    can be difficult to use for beginners and may sometimes be slow when running on
    the Raspberry Pi. Again, you will need to run this editor with the Debian desktop
    or X11-forwarding. Refer to the following screenshot:![Getting ready](img/6623OT_02_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Geany IDE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To install Geany, use the following command and then run **Geany** from the
    **Programming** menu item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure Geany uses Python 3 when you click on the **Execute** button (to
    run your scripts), you will need to change the *build* commands. Load `hellopi.py`
    and then click on the **Build** menu and select **Set Build Commands**. In the
    window that appears, as shown in the following screenshot, change `python` to
    `python3` in the **Compile** and **Execute** sections. Python is always compiled
    automatically when it is run (producing the temporary `.pyc` files), so you don''t
    need to use the **Compile** button, except maybe to check the syntax of the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting ready](img/6623OT_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Geany Build command settings for Python 3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have the `home` directory of the Raspberry Pi shared across the network
    (refer to *Sharing the home folder of the Raspberry Pi with SMB* recipe in [Chapter
    1](ch01.html "Chapter 1. Getting Started with a Raspberry Pi Computer"), *Getting
    Started with a Raspberry Pi Computer*), you can edit files on another computer.
    However, note that if you use Windows, you must use an editor that supports Linux
    line endings, such as Notepad++ (you should not use the standard Notepad program).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a space for your Python scripts, we will add a `python_scripts` folder
    to your `home` directory with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can open this folder and list the files whenever you need to, using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the *Tab* key to help complete commands in the terminal, for example,
    typing `cd ~/pyt` and then pressing the *Tab* key will finish the command for
    you. If there are multiple options that start with `pyt`, pressing the *Tab* key
    again will list them.
  prefs: []
  type: TYPE_NORMAL
- en: To repeat or edit older commands, use the up and down arrow keys to switch between
    older and newer commands as required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `encryptdecrypt.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the *There''s more…* section of this recipe, we will change `main()`
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you want to skip the section, ensure that you include this change in the
    `encryptdecrypt.py` file, as we will use it later.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding script implements a very basic method to scramble the text using
    a simple form of character substitution called the **Caesar cipher**. Named after
    the Roman emperor Julius Caesar, who originally used this method to send secret
    orders to his armies.
  prefs: []
  type: TYPE_NORMAL
- en: The file defines two functions, `encryptText()` and `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the script is running, the `main()` function obtains the user''s input
    using the `input()` command. The result is stored as a string in the `user_input`
    variable (the command will wait until the user has pressed the *Enter* key before
    continuing), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `input()` function will not handle non-ASCII characters, so we use `try…except`
    to handle this case, which will cause `UnicodeDecodeError` to be raised. For more
    information about using `try…except`, refer to the *Using files and handling errors*
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call the `encryptText()` function with two arguments, the text to be
    encrypted, and the key. After the text has been encrypted, the result is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will use `input()` to wait for the user input again (in this case,
    a prompt to press *Enter*; any other input is ignored). Now, we will unscramble
    the text by reversing the encryption by calling `encryptText()` again, but with
    a negative version of the key, and displaying the result, which should be the
    original message.
  prefs: []
  type: TYPE_NORMAL
- en: The `encryptText()` function performs a simple form of encryption by taking
    the letters in the message and substituting each letter with another in the alphabet
    (determined by counting from the number of letters specified by the encryption
    `key`). In this way, the letter `A` will become `C` when the encryption `key`
    is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the process, the function converts all characters to uppercase.
    This allows us to use the ASCII character set to translate each character into
    numbers easily; the letter `A` is represented by `65` and `Z` by `90`. This is
    achieved with `input_text=input_text.upper()` and then by using `ord(letter)`
    to convert to an ASCII value, which gives us a number representation of the character.
    ASCII is a standard that maps the numbers 0 to 254 (an 8-bit value) and commonly
    used characters and symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B | C | D | E | F | G | H | I | J | K | L | M |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
  prefs: []
  type: TYPE_TB
- en: '| 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 |'
  prefs: []
  type: TYPE_TB
- en: '| **N** | **O** | **P** | **Q** | **R** | **S** | **T** | **U** | **V** | **W**
    | **X** | **Y** | **Z** |'
  prefs: []
  type: TYPE_TB
- en: '| 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 |'
  prefs: []
  type: TYPE_TB
- en: ASCII table for upper case letters
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we will ensure that we have an empty string where we can build our result
    (`result = ""`) and we will also set our encryption `key` to our key value.
  prefs: []
  type: TYPE_NORMAL
- en: The `input_text` variable contains our string, which is stored as a list (this
    is similar to an array) of letters. We can access each item in the list using
    `input_text[0]` for the first item and so on; however, Python also allows us to
    loop through a list using `for…in`, accessing each item in turn.
  prefs: []
  type: TYPE_NORMAL
- en: The `for letter in input_text:` line allows us to break up `input_text` by looping
    through it for each item inside (in this case, the letters in the string) and
    also setting the letter equal to that item. So if `input_text` equaled `HELLO`,
    it would run all the code that is indented under the command five times; each
    time, the `letter` variable would be set to `H`, `E`, `L`, `L`, and finally `O`.
    This allows us to read each letter separately, process it, and add the new encrypted
    letter to the `result` string.
  prefs: []
  type: TYPE_NORMAL
- en: The next part, `if (ord("A") > ascii_value) or (ascii_value > ord("Z")):`, checks
    to see if the character we are looking at is not between `A` and `Z`, which means
    it is probably a number or punctuation mark. In this case, we will exclude the
    character from the encryption (passing the character directly to the `result`
    string unchanged).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the letter is between `A` and `Z`, we can add the value of our encryption
    `key` to the value of our letter to obtain our new encoded letter. That is, for
    an encryption `key` of `10`, we end up with the following set of letters in the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we want the encrypted message to be easy to write out, we have limited the
    output to be between `A` and `Z`. So, if the letter starts as `X`, we want to
    it to wrap around and continue counting from `A`. We can achieve this by using
    the `%` (modulus) function, which gives us the remainder value if we divide a
    number by another. So, if `X` is `24` and we add `10`, we get `34`. The value
    of `34%26` (where `26` is the total number of letters) is `8`. Counting `8` from
    `A`, we reach `H`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in ASCII, the letter `A` is the number `65`, so we will remove this
    offset from `key_value` and then add it back once we have the modulus value. The
    following code ensures that we limit the ASCII values to be between `A` and `Z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, if the value is not between the values for `A` or `Z`, then we
    will allow the value to wrap around (by calculating the modulus using the total
    number of letters between `A` and `Z`, which is `26`). This also works if the
    key is larger than `26` and if we are counting the opposite way too, for instance,
    if the encryption key was negative, and therefore, the decryption key positive.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can convert `key_value` back into a letter by using the `chr()`
    and `str()` functions and adding it to the result string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use `\` to split the code into another line, it doesn't affect
    the calculation. Python can be very fussy about splitting lines, in some cases
    you can find a natural break in the code and separate the line with a carriage
    return, however other times we have to force a line break using the `\` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, given very little time, such a simple encryption method could easily
    be broken. Remember that there are only 25 possible combinations to choose from
    before the result of the encryption is repeated (multiples of 26 will result in
    no encryption at all).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can try this simple experiment. Currently, with this basic form of encryption,
    you will supply the method and key to anyone you wish to read your message. However,
    what happens if you want to send a secure transmission without sending the method
    and key?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to send the same message back and forth three times as demonstrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/6623OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do not need to exchange encryption keys with the other person
  prefs: []
  type: TYPE_NORMAL
- en: The first time, we will encrypt it and send it over to the other party. They
    will then encrypt it again with their own encryption and send it back. The message
    at this stage has two layers of encryption applied to it. We can now remove our
    encryption and return it. Finally, they will receive the message with just their
    encryption, which they can remove and read the message.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that there are only 25 useful encryption combinations with the
    Caesar cipher, so it is possible that they could decrypt the message by accident.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of our previous file as a module using the `import` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will allow access to any function inside the `encryptdecrypt` file using
    `ENC` as the reference. When such a file is imported, it will run any code that
    would normally be run; in this case, the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid this, we can change the call to `main()` only to occur when the file
    is run directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file is run directly, Python will set `__name__` to the `"__main__"`
    global attribute. By using the following code, we can reuse the functions in this
    Python script in other scripts without running any other code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `keypassing.py` script using the following code in the same directory
    as `encryptdecrypt.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding script, we can see that the other person doesn''t
    need to know the encryption key that we are using, and anyone who intercepts the
    message will not be able to see its contents. The script produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is known as the **three-pass protocol**, developed by Adi Shamir
    in 1980 ([http://en.wikipedia.org/wiki/Three-pass_protocol](http://en.wikipedia.org/wiki/Three-pass_protocol)).
    One particular disadvantage of this method is that it is possible for a third
    party to intercept the messages (the so-called man-in-the-middle attack) and characterize
    the encryption method by inserting known values and analyzing the responses.
  prefs: []
  type: TYPE_NORMAL
- en: Using files and handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to easy string handling, Python allows you to read, edit, and create
    files easily. So, by building upon the previous scripts, we can make use of our
    `encryptText()` function to encode complete files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to files can be quite dependent on factors that are outside
    of the direct control of the script, such as whether the file that we are trying
    to open exists or the filesystem has space to store a new file. Therefore, we
    will also take a look at how to handle exceptions and protect operations that
    may result in errors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script will allow you to specify a file through the command line,
    which will be read and encoded to produce an output file. Create a small text
    file named `infile.txt` and save it so that we can test the script. It should
    include a short message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `fileencrypt.py` script using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the script, use the following command (here, `infile` can be any text
    file we want to encrypt, `outfile` is our encrypted version, and `key` is the
    key value we wish to use):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to encrypt `infile.txt` and output it as `encrypted.txt` using
    `30` as the key, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To view the result, use `less encrypted.txt`. Press *Q* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt `encrypted.txt` and output it as `decrypted.txt` using `-30` as
    the key, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To view the result, use `less decrypted.txt`. Press *Q* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script requires us to use arguments that are provided on the command line.
    We will access them by importing the Python module called `sys`. Just like we
    did earlier, we will also import our `encryptdecrypt` module using the `import`
    command. We will use the `as` part to allow us to reference it using `ENC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set values to define what each command-line argument will represent.
    When you run it, you will see that `sys.argv[]` is a list of values shown in the
    following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, the input file is at the index `1` in the list (indexing always starts at
    0), then the output file, and finally, the key, with the total number of arguments
    being `ARG_LENGTH=4`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will define the `convertFile()` function, which we will call in a minute
    from the next block of code.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid errors, we will check whether the length of the `sys.argv` value matches
    the expected number of arguments from the command line. This will ensure that
    the user has supplied us with enough, and we don't try to reference items in the
    `sys.argv[]` list that don't exist. Otherwise, we will return a short message
    explaining what we are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: We will now call the `convertFile()` function using the command-line values
    and making use of Python's built-in exception handling features to ensure that
    errors are responded to accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `try…except` code allows you to try running some code and handle any exceptions
    (errors) within the program itself, rather than everything coming to a sudden
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `try` code is accompanied by the following four optional sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`except ValueError:` – When an error occurs, a specific type of exception can
    be specified and handled with the action, depending on the error we wish to handle
    (that is, for `ValueError`, we could check whether the value is a float value
    and convert it to an integer or prompt for a new one). Multiple exceptions can
    be caught using `except (ValueError,IOError)` as required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`except:` – This is a catch-all case where any other exceptions that we haven''t
    handled can be dealt with. For situations where the code may be called from other
    places, we may also want to raise the exception again using the `raise` command
    so that it can be dealt with by other parts of the program (for instance, as part
    of the GUI, we can warn the user that the input was not correct without needing
    to do so at this stage). Typically, you should either deal with a specific exception
    or ensure that you raise it again so that the particular error is visible on a
    failure; if not handled at all, Python will report it on the terminal along with
    the trace to the function where it occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else:` – This section of code is always executed if the `try` code was successful
    and there was no exception raised; however, any errors in this code will not be
    handled by the `try…except` section it is part of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally:` – This code is always executed, regardless of whether an exception
    was raised or the `try` code ran without problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with other languages, you will find `try…except` similar
    to `try…catch`, and `raise` and `throw` as equivalents. Dealing with exceptions
    can be quite an art form; however, making your code able to handle problems gracefully
    and effectively is all part of good design. In many cases, catching the situations
    where things go wrong is just as important as performing the intended function
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no problem with converting the `key` argument into an integer, we
    will continue to open the input file specified and read the contents into the
    `infile_content` list. This will contain the contents of the file split into separate
    lines as a list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will use a slightly different method to display values within
    the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print ("Error: The key %s should be an integer value!" %(key))'
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to use the `%s` symbol to determine where the key value is printed
    and also to specify the format (`%s` is a string). For numerical values, such
    as floats and integers, we can use `%d` to display integers, `%f` for floats,
    or even `%.4f` to limit the value to four decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we opened the file using the `with…as…:` section.
    This is a special way to open a file, which will ensure that it is closed once
    it has finished (even if there is an error). Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If there is an exception in opening the file (if it doesn't exist, for example,
    it will raise `IOError`), we can flag to the user that there was a problem with
    the filename/path provided. We will also use `except:` on its own to deal with
    any other problems that we may have with the file, such as the encoding type or
    non-text based files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will open a file for our output using `'w'` to open it as a writable
    file. If it doesn't exist, it will create a new file; otherwise, it will overwrite
    the file. We will also have the option to append to the file instead, using `'a'`.
    We will step through each item in `infile_content`, converting each line by passing
    it through our `ENC.encryptText()` function and writing the line to the `f_out`
    file. Once again, when we finish the `with…as…:` section, the file is closed and
    the conversion is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a boot-up menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now apply the methods introduced in the previous scripts and reapply
    them to create a menu that we can customize to present a range of quick-to-run
    commands and programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `menu.py` script using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `menu.ini` file that will contain the following menu items and commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can add your own commands to the list, creating your own custom start-up
    menu. The script will assume the `menu.ini` file is formatted correctly, so if
    you experience an error (for example `ErrorIndex`) it may be because the file
    is not as expected (such as missing commas or blank lines). We could use `except
    ErrorIndex:` to handle any errors, however we are better off highlighting there
    is a problem within the input file so that it can be fixed instead.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to execute other programs from within a Python script, we need to use
    the `call` command. This time, we only wish to use the `call` part of the `subprocess`
    module, so we can simply use `from subprocess import call`. This just imports
    the part we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will open the file and read all the lines into a `menufile` list. We can
    then process each item (or line of the file) using `item.split('','')`, which
    will create a new list consisting of each section of the line divided by the `'',''`
    symbol, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As shown by the `print` statement, we can now access each section independently,
    so we can print the key we need to press for a specific command and the description
    of the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have printed the entire menu of commands, we will wait for the user''s
    input. This is done inside a `while` loop; it will continue to run until we set
    the condition inside `running` to `False`. This means that if an invalid key is
    pressed, we can enter another key until a command is selected or the exit item
    is used. We will then check the input key to see if it matches the allocated key
    for the menu item, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If there is a match, we will extract the command we wish to call. The `call`
    command requires a command and its arguments to be a list, so we will use `.split()`
    to break up the command part into a list (where each space in the command is a
    new item in the list). Also note that there is `/n` after `startx`, this is the
    end of the line character from the `menu.ini` file. We will remove this first
    using `.rstrip()`, which removes any whitespace (spaces, tabs, or line endings)
    from the end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command is formatted into a list of arguments, we will set `running`
    to `False` (so the `while` loop will not enter another loop), execute our command,
    and finish the script. If the user selects `x`, there will be no `commands` set,
    allowing us to exit the menu without calling anything. The script produces a small
    menu of options, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the script run each time, we will start the Raspberry Pi; we can call
    it from `.bash_profile`, which is a bash script that runs when the user's profile
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create or edit the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following commands (assuming `menu.py` is located in the `/home/pi/python_scripts`
    directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When done, save and exit (*Ctrl* + *X*, *Y*, and *Enter*).
  prefs: []
  type: TYPE_NORMAL
- en: The next time you power up your Raspberry Pi, you will have a menu to run your
    favorite commands from, without needing to remember them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also run Python scripts directly, without the `python3` command, making
    them executable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now type `./menu.py` and the script will run using the program defined within
    the file by the first line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating a self-defining menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the previous menu is very useful for defining the most common commands
    and functions we may use when running the Raspberry Pi, we will often change what
    we are doing or develop scripts to automate complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the need to continuously update and edit the `menu.ini` file, we can
    create a menu that can list the installed scripts and dynamically build a menu
    from it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a self-defining menu](img/6623OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A menu of all the Python scripts in the current directory
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the `menuadv.py` script using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script allows us to take a different approach. Rather than predefining
    a list of commands or applications, we can simply keep a folder of useful scripts
    and scan it to create a list to pick from. In this case, the menu will just list
    Python scripts and call them without any command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to access the list of files in a directory, we can use the `os` module's
    `os.listdir()` function. This function allows us to specify a directory and it
    will return a list of the files and directories within it.
  prefs: []
  type: TYPE_NORMAL
- en: Using `SCRIPT_DIR="."` will allow us to search the current directory (the one
    the script is being run from). We can specify an absolute path (that is, `"//home/pi/python_scripts"`),
    a relative path (that is, `"./python_scripts_subdirectory"`), or navigate from
    the current directory to others in the structure (that is, `"../more_scripts"`,
    where the `..` symbol will move up a level from the current directory and then
    into the `more_scripts` directory if it existed).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the directory does not exist, an exception (`OSError`) will be raised. Since
    this menu is intended to simply run and display the list, we are better off letting
    the exception cause an error and stop the script. This will encourage the user
    to fix the directory rather than try to handle the error (perhaps by prompting
    for another path each time). It will also be easier for the user to locate and
    correct the path when the script isn't running.
  prefs: []
  type: TYPE_NORMAL
- en: We will also get the name of the script using `os.path.basename(__file__)`,
    this allows us to later exclude the `menuadv.py` script from the list options.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an empty `scripts` list and ensure that we initialize `item_num`
    to `1`. Now, we will call `os.listdir(SCRIPT_DIR)` directly within a `for…in`
    loop so that we can process each directory or filename returned by it. Next, we
    can check the end of each item using the `endswith()` function (another useful
    string function), which allows us to look for a specific ending to the string
    (in this case, the ending for Python scripts). At this point, we can also exclude
    the `menuadv.py` script from the list, if found.
  prefs: []
  type: TYPE_NORMAL
- en: We print the name of the script along with `item_num` and add it to the script
    list, finally incrementing `item_num` so that it is correct for the next item.
  prefs: []
  type: TYPE_NORMAL
- en: We will now prompt the user to enter the relevant script number (between `1`
    and the total number of scripts) and wait for the user input from `input()`. The
    script will check for a valid input. If it is a number, it will stay in the `try`
    section, and we can then check whether the number is in the correct range (one
    of the listed script numbers). If correct, the script is called using `['python3',
    'scriptname.py']` and the `call()` function as before. If the input is not a number
    (for example, `x`), it will raise the `ValueError` exception. Within the `ValueError`
    exception, we can check whether `x` was pressed and exit the `while` loop by setting
    `running` to `False` (otherwise, the loop will reprint the prompt and wait for
    new input).
  prefs: []
  type: TYPE_NORMAL
- en: The script is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can adjust the preceding script to support other types of scripts, if required.
    Simply add other file extensions, such as `.sh`, to the scripts list and call
    using `sh` or `bash` instead of `python3`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can extend this example further by placing all our useful scripts in a single
    place and adding the `menu` script to the path.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative script locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While not entirely necessary (by default, the script will look in the current
    directory), it will be useful to create a suitable location to keep your scripts
    that you would like to use with the menu. This can be a location within your `home`
    folder (`~` is short for the `home` folder path, which is `/home/pi` by default).
    An example is shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To copy files, you can use `cp sourcefile targetfile`. If you use the `-r` option,
    it will also create the directory if it doesn't exist. To move or rename the files,
    use `mv sourcefile targetfile`. To delete the files, use `rm targetfile`. You
    must use the `-r` option to delete a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Just ensure that if the script is not within the same location, the path is
    updated for `SCRIPT_DIR` to refer to the required location.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scripts to PATH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As before, we could add this script to a start-up file, such as `.bash_profile`,
    and have the menu appear when the user logs in to the Raspberry Pi. Alternatively,
    we can place such scripts into a folder such as `/home/pi/bin`, in which we can
    include the global value call `PATH`. The `PATH` settings are a list of directories
    that scripts and programs will check when trying to locate a file that isn't in
    the current directory (typically, installed programs and software, but also common
    configuration files and scripts).
  prefs: []
  type: TYPE_NORMAL
- en: This will allow us to run the script regardless of what directory we are currently
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the current `PATH` settings using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The actual contents of the `PATH` setting will depend on the initial settings
    of the distribution you are using and also on the applications you have installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `/home/pi/bin` isn''t included, we can temporarily add to this until the
    next boot with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add this to `.bash_profile` to set it every time for the current
    user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time we reboot, the `PATH` settings will be (for a user with the name
    `pi`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When items are automatically located through `PATH`, it can be difficult to
    find a specific version of a file or program. To overcome this, use `whereis`
    before the filename/command, and it will list all the locations where it can be
    found.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you do move the script to the `bin` directory, ensure that you update
    the path in `os.listdir("//home/pi/bin")` to locate and list the scripts you wish
    to display in the menu.
  prefs: []
  type: TYPE_NORMAL
