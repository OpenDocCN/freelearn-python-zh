<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-167"><a id="_idTextAnchor180"/>7</h1>
<h1 id="_idParaDest-168"><a id="_idTextAnchor181"/>Securing and Packaging the App</h1>
<p>In the previous chapter, we deployed our app to <a href="http://tozo.dev">tozo.dev</a>, allowing users to use our web app via a browser on any device, and added monitoring so that we know when things go wrong. </p>
<p>In this chapter, we will focus on how we can keep our app secure, both in terms of the code we use and the methods users use to authenticate. We’ll also package our app so that users can use our app via the app stores.</p>
<p>It is important to view the app’s security as a continual process, whereby the practices and packages must be continually updated and improved. In this chapter, I’ll demonstrate my process for managing package updates, which you can adopt and improve upon. We’ll also adopt current best practices to secure the app.</p>
<p>We’ll also make a major change to support multifactor authentication. While this will allow users to opt-in for greater security, it will also show how to make large changes to the app; specifically, it will show how to alter the database via a migration. </p>
<p>Finally, by packaging our app, we can allow our users to find our app in the app stores and use it as they would any other app on their phone.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Securing the app</li>
<li>Updating packages</li>
<li>Adding multifactor authentication </li>
<li>Converting to a progressive web app</li>
</ul>
<h1 id="_idParaDest-169"><a id="_idTextAnchor182"/>Technical requirements</h1>
<p>To follow the development in this chapter using the companion repository, <a href="https://github.com/pgjones/tozo">https://github.com/pgjones/tozo</a>, see the commits between the <code>r1-ch7-start</code> and <code>r1-ch7-end</code> tags.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor183"/>Securing the app</h1>
<p>Much of what <a id="_idIndexMarker453"/>we’ve done so far uses secure defaults (for example, the Strict<a id="_idTextAnchor184"/> SameSite setting used in <a href="B18727_02.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a><em class="italic">, Creating a Reusable Backend with Quart</em>), however, there is always more than can be done to secure an app. Specifically, we can utilize secure headers to limit what the browser will allow the page to do, further protect against account enumeration, and limit the accounts that can register to limit spam. Let’s look at those security options now.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor185"/>Adding secure headers</h2>
<p>To further secure <a id="_idIndexMarker454"/>our app, we can utilize additional secure headers to limit what the browser will allow the app to do. These headers should be added to every response the app sends; we can do this by adding the following to <em class="italic">backend/src/backend/run.py</em>:</p>
<pre class="source-code">
from quart import Response
from werkzeug.http import COOP 
@app.after_request
async def add_headers(response: Response) -&gt; Response:
    response.content_security_policy.default_src = "'self'"
    response.content_security_policy.connect_src = "'self' *.sentry.io"
    response.content_security_policy.frame_ancestors = "'none'"
<strong class="bold">    response.content_security_policy.report_uri = "https://ingest.sentry.io"  </strong>      
    response.content_security_policy.style_src = "'self' 'unsafe-inline'"
    response.cross_origin_opener_policy = COOP.SAME_ORIGIN
    response.headers["Referrer-Policy"] = "no-referrer, strict-origin-when-cross-origin"
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    response.headers[
        "Strict-Transport-Security"
    ] = "max-age=63072000; includeSubDomains; preload"
    return response</pre>
<p>The highlighted value of <code>report_uri</code> given as <code>“https://ingest.sentry.io”</code> is a placeholder, and the correct value for your usage can be found in the CSP section of the Sentry dashboard for the backend project.</p>
<p>The secure<a id="_idIndexMarker455"/> headers added are as follows:</p>
<ul>
<li><code>Content-Security-Policy</code> (<code>CSP</code>): This is used to limit how the content can interact with the page and other domains. As used, it restricts the content such that it must have been served by our domain (called <code>self</code>) with the exception of any styling content that can also be added inline (called <code>unsafe-inline</code>) as required for MUI to work correctly. The setup also allows connections to <a href="http://sentry.io">sentry.io</a> so that our monitoring can work. Finally, it has a reporting URI so that we can monitor any errors with the CSP itself. </li>
<li><code>Cross-Origin-Opener-Policy</code> (<code>COOP</code>): This isolates our app from other domains (origins).</li>
<li><code>Referrer-Policy</code>: This restricts how the browser can populate the <code>Referer</code> header when following links and is used to protect the user’s privacy.</li>
<li><code>X-Content-Type-Options</code>: This ensures that the browser respects the <code>content</code> type we return from the server.</li>
<li><code>X-Frame-Options</code>: This improves protection against clickjacking and ensures that our app is only displayed on our domain.</li>
<li><code>Strict-Transport-Security</code>: This informs the browser that all subsequent connections to our app must be done over HTTPS.</li>
</ul>
<p class="callout-heading">OWASP</p>
<p class="callout">The authoritative source for web application security best practices<a id="_idIndexMarker456"/> is<a id="_idIndexMarker457"/> the <strong class="bold">OWASP</strong> foundation, which can be found here: <a href="http://owasp.org">owasp.org</a>. The header recommendations in this book are based on their recommendations.</p>
<p>With the secure <a id="_idIndexMarker458"/>headers in place, we can look in more detail at how we log users in while protecting against account enumeration.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor186"/>Protecting against account enumeration</h2>
<p>Account <a id="_idIndexMarker459"/>enumeration is where an attacker <a id="_idIndexMarker460"/>attempts to learn what email addresses are used as registered accounts. By doing so, the attacker can learn who uses a sensitive app (e.g., a dating app) and can learn which accounts they can try to force access to. Protecting against this requires compromises in the user experience, as we discussed in the <em class="italic">Adding user authentication pages</em> section of <a href="B18727_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a><em class="italic">, Building the Single-Page App</em>, in reference to auto logins on registration. </p>
<p>In this book, we’ll adopt the most secure practices possible, which means we need to revisit the login functionality implemented in the <em class="italic">Building the session API</em> section of <a href="B18727_03.xhtml#_idTextAnchor076"><em class="italic">Chapter 3</em></a><em class="italic">, Building the API</em>, as it is susceptible to account enumeration attacks. </p>
<p>The weakness in the login functionality is due to the code only checking the password hash if the given email belongs to a registered member. This means that the route takes significantly longer to respond to emails belonging to registered members than for emails that don’t; this allows an attacker to time the response to understand whether the email is registered or not. Therefore, the mitigation is to always check a password hash, by changing the route in <em class="italic">backend/src/backend/blueprints/sessions.py</em> to the following:</p>
<pre class="source-code">
REFERENCE_HASH = "$2b$12$A.BRD7hCbGciBiqNRTqxZ.odBxGo.XmRmgN4u9Jq7VUkW9xRmPxK."
@blueprint.post("/sessions/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(LoginData)
async def login(data: LoginData) -&gt; ResponseReturnValue:
    """Login to the app.
 
    By providing credentials and then saving the     returned cookie.
    """
    result = await select_member_by_email(        g.connection, data.email     )
    password_hash = REFERENCE_HASH
    if result is not None:
        password_hash = result.password_hash 
    passwords_match = bcrypt.checkpw(
        data.password.encode("utf-8"),
        password_hash.encode("utf-8"),
    )
    if passwords_match and result is not None:
        login_user(AuthUser(str(result.id)), data.remember)
        return {}, 200
    else:
        raise APIError(401, "INVALID_CREDENTIALS")</pre>
<p><code>REFERENCE_HASH</code> is set to a very long random string of characters that is extremely unlikely to be matched by chance.</p>
<p>With the <a id="_idIndexMarker461"/>additional protection against account <a id="_idIndexMarker462"/>enumeration, we can focus on the accounts themselves by adding protection against spam accounts.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor187"/>Protecting against spam accounts</h2>
<p>If you allow <a id="_idIndexMarker463"/>users to register and interact with your <a id="_idIndexMarker464"/>app, it is inevitable that you will have users that will use it to spam you or other users. An easy initial mitigation against this is to prevent users from registering to your app with disposable email addresses (these are free short-lived email addresses that are perfect for spammers). Fortunately, the <code>disposable-email-domains</code> project keeps a track of these domains and is installed by running the following in the <em class="italic">backend</em> directory:</p>
<pre>pdm add disposable-email-domains</pre>
<p>The following can then be added to the start of the <code>register</code> route in <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from disposable_email_domains import blocklist  # type: ignore
async def register(data: MemberData) -&gt; ResponseReturnValue:
    email_domain = data.email.split("@", 1)[1]
    if email_domain in blocklist:
        raise APIError(400, "INVALID_DOMAIN")
<strong class="bold">    ...</strong></pre>
<p>In the previous code block, <code>...</code> represents the existing <code>register</code> code. This will block registrations from the blocked email domains by returning an appropriate error code.</p>
<p>Now, we need to handle this error in the <code>useRegister</code> hook found in <em class="italic">frontend/src/pages/Register.tsx</em>:</p>
<pre class="source-code">
const useRegister = () =&gt; { 
<strong class="bold">      ...</strong>
<strong class="bold">      if (</strong>
<strong class="bold">        error.response?.status === 400 &amp;&amp;</strong>
<strong class="bold">        error.response?.data.code === "WEAK_PASSWORD"</strong>
<strong class="bold">      ) {</strong>
<strong class="bold">        setFieldError("password", "Password is too weak");</strong>
      } else if (
        error.response?.status === 400 &amp;&amp;
        error.response?.data.code === "INVALID_DOMAIN"
      ) {
        setFieldError("email", "Invalid email domain");
<strong class="bold">      } else {</strong>
<strong class="bold">        addToast("Try again", "error");</strong>
<strong class="bold">      }</strong>
<strong class="bold">      ...</strong>
}</pre>
<p>The<a id="_idIndexMarker465"/> highlighted<a id="_idIndexMarker466"/> lines are the existing code in the <code>useRegister</code> hook. It is important that the check is added as an <code>else if</code> clause to the existing <code>if</code> clause (as shown in this snippet), otherwise the user may get multiple confusing error messages.</p>
<p>Keeping an app secure is in practice an arms race against attackers, and I recommend you continue to follow OWASP and adopt the latest guidance. Likewise, we’ll need to keep updating our packages, which we’ll focus on next.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor188"/>Updating packages</h1>
<p>A very common <a id="_idIndexMarker467"/>source of vulnerabilities in web applications is vulnerable dependent packages. This is especially true if the application is using an older version of a package when a new, more secure version is available. To mitigate against this, we can periodically check for known vulnerabilities and, crucially, update the packages as often as possible.</p>
<p class="callout-heading">Importance of lockfiles</p>
<p class="callout">By using npm and PDM, we are using lockfiles; this means that we’ll always install the same package version on any system until we change the lockfile. Without a lockfile, we would quickly be in a position where different systems run with different package versions and potentially different packages. This would make it hard to diagnose bugs, as it may depend on a version we aren’t testing. Crucially though, it would make our app less secure as we would have no control over what was installed.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor189"/>Periodically checking for vulnerabilities</h2>
<p>In our app, we are<a id="_idIndexMarker468"/> using many third-party dependencies, each of which is likely to be using additional third-party dependencies. This means there is a large number of libraries that we need to check for vulnerabilities – too many to do ourselves! Fortunately, when others find vulnerabilities, they are published, and tools exist to check the version installed against the published list of issues. </p>
<p>We’ll use these tools to check our code, allowing us to switch to a fixed version if they find anything. This is something I recommend to be done periodically and automatically, specifically every week, via a GitHub workflow.</p>
<p>To start, we can create a workflow that is scheduled to run at 9 a.m. UTC on a Tuesday by adding the following to <em class="italic">.github/workflows/audit.yml</em>:</p>
<pre class="source-code">
name: Audit
 
on: 
  schedule:
    - cron: "0 9 * * 2"
jobs:</pre>
<p class="callout-heading">Tuesday patches</p>
<p class="callout">Tuesday is typically the day to apply patches as it’s early in the week, almost always a workday (Mondays may not be workdays during holidays), and crucially, gives time on Monday to respond to weekend issues, leaving Tuesday free for patch issues.</p>
<p>To check the frontend code, we can use <code>npm audit</code>, which is built into the <code>npm</code> package<a id="_idIndexMarker469"/> manager. This tool will check the installed frontend dependencies and alert if any insecure package versions are found. To run it on the schedule, the following job should be added to <em class="italic">.github/workflows/audit.yml</em>:</p>
<pre class="source-code">
  frontend-audit:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
 
    steps:
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
 
      - uses: actions/checkout@v3  
      - name: Initialise dependencies
        run: npm ci --cache .npm --prefer-offline
      - name: Audit the dependencies
        run: npm audit</pre>
<p>Now, to check the backend code, we can use <code>pip-audit</code>, which is installed by running the following command in the <em class="italic">backend</em> directory:</p>
<pre>pdm add --dev pip-audit</pre>
<p>We’ll add a <code>pdm</code> script so that we can use <code>pdm run audit</code> to audit the code, as we did in the <em class="italic">Installing Python for backend development</em> section of <a href="B18727_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up Our System for Development;</em> so, add the <a id="_idIndexMarker470"/>following to <em class="italic">backend/pyproject.toml</em>:</p>
<pre class="source-code">
[tool.pdm.scripts]
audit = "pip-audit"</pre>
<p>With this in place, we can add the following job to <em class="italic">.github/workflows/audit.yml</em>:</p>
<pre class="source-code">
  backend-audit:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.10'
 
      - name: Initialise dependencies
        run: |
          pip install pdm
          pdm install 
      - name: Audit the dependencies
        run: pdm run audit</pre>
<p>This workflow will fail if either the <code>frontend-audit</code> or <code>backend-audit</code> job finds packages <a id="_idIndexMarker471"/>with security issues, and will alert us. However, it is best to be proactive and keep our dependencies up to date.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor190"/>A system for monthly updates</h2>
<p>To ensure the<a id="_idIndexMarker472"/> dependencies are up to date, I recommend updating all the packages every month. This ensures that the app never has dependencies that are more than a month old and makes it easier to utilize the dependencies’ latest features. This may seem like a lot of work, however, in my experience, it takes much more effort to do all the upgrades at once than to do them in smaller batches. </p>
<p>To make this process easier, we must unpin the dependencies in the <em class="italic">frontend/package.json</em> and <em class="italic">backend/pyproject.toml</em> files. This doesn’t mean we’ve unpinned the dependencies though, as both <em class="italic">frontend/package-lock.json</em> and <em class="italic">backend/pdm.lock</em> will fully define the exact versions to install. It instead means that we will allow our app to work with any library version if directed – and we will direct it to always use the latest.</p>
<p>The <em class="italic">frontend/package.json</em> file should look like this:</p>
<pre class="source-code">
  "dependencies": {
    "@emotion/react": "*",
    "@emotion/styled": "*",
     ...
  },
  "devDependencies": {
    "@types/zxcvbn": "*",
    "eslint": "*",
    ...
  }</pre>
<p>Note that each dependency is now unpinned, with <code>*</code> meaning any version is allowed. </p>
<p>With these changes made, we can run the following command in the <em class="italic">frontend</em> directory to update the<a id="_idIndexMarker473"/> frontend dependencies:</p>
<pre>npm update </pre>
<p>We can also run a similar command in the <em class="italic">backend</em> directory to update the backend dependencies:</p>
<pre>pdm update </pre>
<p>Finally, to upgrade the infrastructure dependencies, the following should be run in the <em class="italic">infrastructure</em> directory:</p>
<pre>terraform init –upgrade</pre>
<p>These updates will likely result in small changes needing to be made to support the latest versions. It is likely that the CI checks, especially the type checking we’ve used throughout, will warn if these changes are not made.</p>
<p>Now that we have a system for keeping our app up to date, we can add multifactor authentication to help our users secure their accounts.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor191"/>Adding multifactor authentication</h1>
<p>Our app allows <a id="_idIndexMarker474"/>users to log in by providing an <a id="_idIndexMarker475"/>email and a password. This means we allow them to authenticate with something they know (i.e., the password). We could also allow them to use other factors of authentication such as using their fingerprint (i.e., something they are), or a specific mobile device (i.e., something they have). Requiring a user to authenticate using multiple factors makes it much harder for an attacker to gain access to their account, however, it also makes it harder for the user to authenticate themselves. Therefore, it is best to allow users to opt into multifactor authentication.</p>
<p>Users are most familiar with using their phones as an additional factor, which we will implement <a id="_idIndexMarker476"/>using <strong class="bold">time-based one-time passcode</strong> (<strong class="bold">TOTP</strong>) tokens based on a shared secret. The shared secret, on the user’s phone, is an additional factor. It is also common to use SMS messages sent to the user’s phone; however, this method is increasingly easy to attack and should not be considered secure.</p>
<p class="callout-heading">TOTP</p>
<p class="callout">The TOTP algorithm makes use of a shared secret and the current time to generate a code that is valid for a certain period of time (usually about 60 seconds). Any two systems should calculate the same code for the same time and shared secret, hence the user can provide a code that our app should match.</p>
<p><strong class="bold">Multifactor Authentication</strong> (<strong class="bold">MFA</strong>) using <a id="_idIndexMarker477"/>TOTP works by first sharing a secret with the user. This is typically done by showing a QR code in our app, which the user scans using an authentication app. The user’s authentication app will then display a code that the user can enter in our app to confirm that MFA has been set up. Then, on any subsequent logins, the user will need to enter the current code as displayed by their authentication app.</p>
<p>To support MFA in our app, we will need to update the database and associated models, add the functionality to activate it in the backend and frontend, and then, finally, utilize MFA when logging in.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor192"/>Updating the database and models</h2>
<p>To support MFA, we<a id="_idIndexMarker478"/> need to store two pieces of information for each member:</p>
<ul>
<li>The first is the shared secret, which can be <code>NULL</code> if the user hasn’t activated MFA. </li>
<li>The second is the last code they used, which can also be <code>NULL</code>. The last code is required to prevent replay attacks whereby an attacker simply resends the previous MFA code. </li>
</ul>
<p>To add this information, we need to create a new database migration by adding the following code to <em class="italic">backend/src/backend/migrations/1.py</em>:</p>
<pre class="source-code">
from quart_db import Connection
async def migrate(connection: Connection) -&gt; None:
    await connection.execute(
        "ALTER TABLE members ADD COLUMN totp_secret TEXT"
    )
    await connection.execute(
        "ALTER TABLE members ADD COLUMN last_totp TEXT"
    )
async def valid_migration(connection: Connection) -&gt; bool:
    return True</pre>
<p class="callout-heading">Good migrations</p>
<p class="callout">Database migrations must be written with care, as the migration will change the database state while the code is accessing it. For this reason, it is best to write migrations that add functionality while allowing older code to continue to run. For example, it is best not to delete or rename columns in one migration; instead, a new column should be added, then used for a while before the old column is removed.</p>
<p>We also need to update the backend model to account for these two new columns, by changing the <code>Member</code> model in <em class="italic">backend/src/backend/models/member.py</em> to the following (changes <a id="_idIndexMarker479"/>are highlighted):</p>
<pre class="source-code">
@dataclass
class Member:
    id: int
    email: str
    password_hash: str
    created: datetime
    email_verified: datetime | None 
<strong class="bold">    last_totp: str | None</strong>
<strong class="bold">    totp_secret: str | None</strong></pre>
<p>We now also need to update the following model functions in <em class="italic">backend/src/backend/models/member.py</em>:</p>
<pre class="source-code">
async def select_member_by_email(
    db: Connection, email: str
) -&gt; Member | None:
    result = await db.fetch_one(
        """SELECT id, email, password_hash, created,
                  email_verified<strong class="bold">, last_totp, totp_secret</strong>
             FROM members
            WHERE LOWER(email) = LOWER(:email)""",
        {"email": email},
    )
    return None if result is None else Member(**result)
async def select_member_by_id(
    db: Connection, id: int
) -&gt; Member | None:
    result = await db.fetch_one(
        """SELECT id, email, password_hash, created,
                  email_verified<strong class="bold">, last_totp, totp_secret</strong>
             FROM members
            WHERE id = :id""",
        {"id": id},
    )
    return None if result is None else Member(**result)
async def insert_member(
    db: Connection, email: str, password_hash: str
) -&gt; Member:
    result = await db.fetch_one(
        """INSERT INTO members (email, password_hash)
                VALUES (:email, :password_hash)
             RETURNING id, email, password_hash, created,
                       email_verified<strong class="bold">, last_totp,                       totp_secret</strong>""",
        {"email": email, "password_hash": password_hash},
    )
    return Member(**result)</pre>
<p>Note that the only change (as highlighted) is to add the new columns to the SQL query. </p>
<p>To be able to change the values of the <code>last_totp</code> and <code>totp_secret</code> columns, we’ll need to<a id="_idIndexMarker480"/> add the following functions to <em class="italic">backend/src/backend/models/member.py</em>:</p>
<pre class="source-code">
async def update_totp_secret(
    db: Connection, id: int, totp_secret: str | None
) -&gt; None:
    await db.execute(
        """UPDATE members
              SET totp_secret = :totp_secret
            WHERE id = :id""",
        {"id": id, "totp_secret": totp_secret},
    )
async def update_last_totp(
    db: Connection, id: int, last_totp: str | None
) -&gt; None:
    await db.execute(
        """UPDATE members
              SET last_totp = :last_totp
            WHERE id = :id""",
        {"id": id, "last_totp": last_totp},
    )</pre>
<p>With the database and backend models updated, we can add the functionality to activate <a id="_idIndexMarker481"/>MFA.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor193"/>Activating MFA</h2>
<p>To activate MFA, we <a id="_idIndexMarker482"/>will need a page in our app that follows the process shown in <em class="italic">Figure 7.1</em>:</p>
<div><div><img alt="Figure 7.1: MFA activation process " height="528" src="img/B18787_07_01.jpg" width="1080"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: MFA activation process</p>
<p>The secret itself will need to be generated and managed on the backend, which we can do using the <code>pyotp</code> library; the library is installed by running the following in the <em class="italic">backend</em> directory:</p>
<pre>pdm add pyotp</pre>
<p>We can now start adding the backend routes, beginning with a route that returns the member’s MFA status. This will either be <code>active</code> where MFA is in use, <code>inactive</code> where MFA is not in use, or <code>partial</code> where the member is in the process of activating MFA; it will also need to return the shared secret. We’ll return the secret as a URI from which we can generate a QR code. </p>
<p>The code for this route is as follows and should be added to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from typing import Literal
from pyotp.totp import TOTP
from quart_schema import validate_response
@dataclass
class TOTPData:
    state: Literal["ACTIVE", "PARTIAL", "INACTIVE"]
    totp_uri: str | None
@blueprint.get("/members/mfa/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_response(TOTPData)
async def get_mfa_status() -&gt; TOTPData:
    member_id = int(cast(str, current_user.auth_id))
    member = await select_member_by_id(g.connection, member_id)
    assert member is not None  # nosec
    totp_uri = None
    state: Literal["ACTIVE", "PARTIAL", "INACTIVE"]
    if member.totp_secret is None:
        state = "INACTIVE"
    elif (
        member.totp_secret is not None and         member.last_totp is None
    ):
<strong class="bold">        totp_uri = TOTP(member.totp_secret).provisioning_uri(</strong>
<strong class="bold">            member.email, issuer_name="Tozo"</strong>
<strong class="bold">        )</strong>
        state = "PARTIAL"
    else:
        state = "ACTIVE"
    return TOTPData(state=state, totp_uri=totp_uri)</pre>
<p>Note that <code>totp_uri</code> is only returned for a partial state (highlighted), as the secret it contains should only be shared when it is needed.</p>
<p>The next<a id="_idIndexMarker483"/> route we need is to allow a member to initiate MFA, by creating a shared secret. This should be added to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from pyotp import random_base32
from backend.models.member import update_totp_secret
@blueprint.post("/members/mfa/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_response(TOTPData)
async def initiate_mfa() -&gt; TOTPData:
    member_id = int(cast(str, current_user.auth_id))
    member = await select_member_by_id(g.connection, member_id)
    assert member is not None  # nosec
    if member.totp_secret is not None:
        raise APIError(409, "ALREADY_ACTIVE")
    totp_secret = random_base32()
    totp_uri = TOTP(totp_secret).provisioning_uri(
        member.email, issuer_name="Tozo"
    )
    await update_totp_secret(g.connection, member_id, totp_      secret)
    return TOTPData(state="PARTIAL", totp_uri=totp_uri) </pre>
<p>The final route <a id="_idIndexMarker484"/>we need is to confirm the setup by allowing the user to put a TOTP code, which<a id="_idIndexMarker485"/> should be added to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from backend.models.member import update_last_totp
@dataclass 
class TOTPToken: 
    token: str
@blueprint.put("/members/mfa/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_request(TOTPToken)
async def confirm_mfa(data: TOTPToken) -&gt; ResponseReturnValue:
    member_id = int(cast(str, current_user.auth_id))
    member = await select_member_by_id(g.connection, member_id)
    assert member is not None  # nosec
    if member.totp_secret is None:
        raise APIError(409, "NOT_ACTIVE")
    totp = TOTP(member.totp_secret)
    if totp.verify(data.token):
        await update_last_totp(g.connection, member_id, data.          token)
        return {}
    else:
        raise APIError(400, "INVALID_TOKEN")</pre>
<p>We can now <a id="_idIndexMarker486"/>build the frontend page to handle the interface, which will need to display a QR code. We can do that via <code>qrcode.react</code>, which is installed by running the following command in the <em class="italic">frontend</em> directory:</p>
<pre>npm install qrcode.react</pre>
<p>The page we need to build should look like <em class="italic">Figure 7.2</em>:</p>
<div><div><img alt="Figure 7.2: The MFA setup page " height="580" src="img/B18787_07_02.jpg" width="885"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: The MFA setup page</p>
<p>To build the MFA page, we first need to add a specific field for the user to enter one-time <a id="_idIndexMarker487"/>codes, by adding the following to <em class="italic">frontend/src/components/TotpField.tsx</em>:</p>
<pre class="source-code">
import TextField, { TextFieldProps } from "@mui/material/TextField";
import { FieldHookConfig, useField } from "formik";
import { combineHelperText } from "src/utils";
const TotpField = (props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps) =&gt; {
  const [field, meta] = useField&lt;string&gt;(props);
  return (
    &lt;TextField
      {...props}
      autoComplete="one-time-code"
      error={Boolean(meta.error) &amp;&amp; meta.touched}
      helperText={combineHelperText(props.helperText, meta)}
      inputProps={{ inputMode: "numeric", maxLength: 6,        pattern: "[0-9]*" }}
      margin="normal"
      type="text"
      {...field}
    /&gt;
  );
};
export default TotpField;</pre>
<p>Before <a id="_idIndexMarker488"/>we use <code>TotpField</code>, we need to add the functionality required to activate MFA to <em class="italic">frontend/src/pages/MFA.tsx</em>:</p>
<pre class="source-code">
import axios from "axios"; 
import { useQueryClient } from "@tanstack/react-query";
import { useMutation } from "src/query";
const useActivateMFA = (): [() =&gt; Promise&lt;void&gt;, boolean] =&gt; {
  const queryClient = useQueryClient();
  const { mutateAsync: activate, isLoading } = useMutation(
    async () =&gt; await axios.post("/members/mfa/"),
    {
      onSuccess: () =&gt; queryClient.invalidateQueries(["mfa"]),
    },
  );
  return [
    async () =&gt; {
      await activate();
    },
    isLoading,
  ];
};</pre>
<p>The mutation invalidates the <code>mfa</code> queries, as this is the key that we’ll use for the query that determines the user’s MFA state. </p>
<p>We also <a id="_idIndexMarker489"/>need functionality to confirm the MFA activation, which can be added to <em class="italic">frontend/src/pages/MFA.tsx</em>:</p>
<pre class="source-code">
import { FormikHelpers } from "formik";
import { useContext } from "react";
import { ToastContext } from "src/ToastContext";
interface IForm {
  token: string;
}
const useConfirmMFA = () =&gt; {
  const { addToast } = useContext(ToastContext);
  const queryClient = useQueryClient();
  const { mutateAsync: confirm } = useMutation(
    async (data: IForm) =&gt; await axios.put("/members/mfa/", data),
    {
      onSuccess: () =&gt; queryClient.invalidateQueries(["mfa"]),
    },
  );
  return async (
    data: IForm, { setFieldError }: FormikHelpers&lt;IForm&gt;
  ) =&gt; {
    try {
      await confirm(data);
    } catch (error: any) {
      if (axios.isAxiosError(error) &amp;&amp; 
          error.response?.status === 400) {
        setFieldError("token", "Invalid code");
      } else {
        addToast("Try again", "error");
      }
    }
  };
};</pre>
<p>With the functionality<a id="_idIndexMarker490"/> in place, we can add the UI elements, as follows, which should be added to <em class="italic">frontend/src/pages/MFA.tsx</em>:</p>
<pre class="source-code">
import LoadingButton from "@mui/lab/LoadingButton";
import Skeleton from "@mui/material/Skeleton";
import Typography from "@mui/material/Typography";
import { Form, Formik } from "formik";
import { QRCodeSVG } from "qrcode.react";
import * as yup from "yup";
import FormActions from "src/components/FormActions";
import Title from "src/components/Title";
import TotpField from "src/components/TotpField";
import { useQuery } from "src/query";
const validationSchema = yup.object({
  token: yup.string().required("Required"),
}); 
const MFA = () =&gt; {
  const { data } = useQuery(["mfa"], async () =&gt; {
    const response = await axios.get("/members/mfa/");
    return response.data;
  });
  const [activate, isLoading] = useActivateMFA();
  const onSubmit = useConfirmMFA();
  let content = &lt;Skeleton /&gt;;
  if (data?.state === "ACTIVE") {
    content = &lt;Typography variant="body1"&gt;MFA Active&lt;/Typography&gt;;
  } else if (data?.state === "INACTIVE") {
    content = (
      &lt;LoadingButton loading={isLoading} onClick={activate}&gt;
        Activate
      &lt;/LoadingButton&gt;
    );
  } else if (data !== undefined) {
    content = (
      &lt;&gt;
        &lt;QRCodeSVG value={data.totpUri} /&gt;
        &lt;Formik&lt;IForm&gt;
          initialValues={{ token: "" }}
          onSubmit={onSubmit}
          validationSchema={validationSchema}
        &gt;
          {({ dirty, isSubmitting }) =&gt; (
            &lt;Form&gt;
              &lt;TotpField
                fullWidth={true}
                label="One time code"
                name="token"
                required={true}
              /&gt;
              &lt;FormActions
                disabled={!dirty}
                isSubmitting={isSubmitting}
                label="Confirm"
                links={[{ label: "Back", to: "/" }]}
              /&gt;
            &lt;/Form&gt;
          )}
        &lt;/Formik&gt;
      &lt;/&gt;
    );
  }
  return (
    &lt;&gt;
      &lt;Title title="Multi-Factor Authentication" /&gt;
      {content}
    &lt;/&gt;
  );
};
export default MFA; </pre>
<p>The displayed UI code is dependent on the MFA state, including initially when a <code>Skeleton</code> is shown while the MFA state is being fetched from the backend. It then shows a <code>LoadingButton</code> to activate MFA, a QR code and <code>TotpField</code> to confirm MFA activation, and finally confirmation text if MFA is active.</p>
<p>Next, the MFA<a id="_idIndexMarker491"/> page needs to be added to the routing by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import MFA from "src/pages/MFA";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">   ...</strong>
    &lt;Routes&gt;
<strong class="bold">      ...</strong>
      &lt;Route
        path="/mfa/"
        element={&lt;RequireAuth&gt;&lt;MFA /&gt;&lt;/RequireAuth&gt;}
      /&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>In the code block, <code>...</code> represents code that has been omitted for brevity.</p>
<p>To allow the user to find the MFA page, we can add the following <code>MenuItem</code> to the <code>AccountMenu</code> component in <em class="italic">frontend/src/components/AccountMenu.tsx</em>:</p>
<pre class="source-code">
&lt;MenuItem  
  component={Link}  
  onClick={onMenuClose}  
  to="/mfa/" 
&gt; 
  MFA
&lt;/MenuItem&gt;</pre>
<p>Now that the<a id="_idIndexMarker492"/> user can activate MFA, we can utilize it in the login process.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor194"/>Logging in with MFA</h2>
<p>The login<a id="_idIndexMarker493"/> process must also change to ask the user for a one-time code if they have activated MFA. To do this, the backend must indicate to the frontend that an additional token is required for users that have activated MFA. The following code should replace the login route in <em class="italic">backend/src/backend/blueprints/sessions.py</em>:</p>
<pre class="source-code">
from pyotp.totp import TOTP
from backend.models.member import update_last_totp
@dataclass
class LoginData:
    email: EmailStr
    password: str
    remember: bool = False
    token: str | None = None
@blueprint.post("/sessions/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(LoginData)
async def login(data: LoginData) -&gt; ResponseReturnValue:
    member = await select_member_by_email(g.connection, data.email)
    password_hash = REFERENCE_HASH
    if member is not None:
        password_hash = member.password_hash 
    passwords_match = bcrypt.checkpw(
        data.password.encode("utf-8"),
        password_hash.encode("utf-8"),
    )
    if passwords_match:
        assert member is not None  # nosec
        if (
            member.totp_secret is not None and 
            member.last_totp is not None
        ):
            if data.token is None:
                raise APIError(400, "TOKEN_REQUIRED")
            totp = TOTP(member.totp_secret)
            if (
                not totp.verify(data.token) or 
                data.token == member.last_totp
            ):
                raise APIError(401, "INVALID_CREDENTIALS")
            await update_last_totp(
                g.connection, member.id, data.token
            )
        login_user(AuthUser(str(member.id)), data.remember)
        return {}, 200
    else:
        raise APIError(401, "INVALID_CREDENTIALS")</pre>
<p>This code will<a id="_idIndexMarker494"/> return a <code>400</code> error response if the user has activated MFA, but the login data doesn’t include a one-time code (<code>token</code>); this allows the frontend login page to then ask the user for the one-time code and then retry logging in. In addition, the code will return a <code>401</code> invalid credentials message if the one-time code is invalid – noting that it checks the previously used code to prevent replay attacks.</p>
<p>We can now alter the existing login page so that it looks like <em class="italic">Figure 7.3</em> for accounts that have activated MFA:</p>
<div><div><img alt="Figure 7.3: The Login page with the additional One time code field " height="639" src="img/B18787_07_03.jpg" width="718"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.<a id="_idTextAnchor195"/>3: The Login page with the additional One time code field</p>
<p>To begin, we need<a id="_idIndexMarker495"/> to alter the <code>useLogin</code> logic in <em class="italic">frontend/src/pages/Login.tsx</em> to be the following:</p>
<pre class="source-code">
import { useState } from "react";
interface IForm {
  email: string;
  password: string;
  token: string;
}
const useLogin = (): [(data: IForm, helpers: FormikHelpers&lt;IForm&gt;) =&gt; Promise&lt;void&gt;, boolean] =&gt; {
  const [requiresMFA, setRequiresMFA] = useState(false);
  const location = useLocation();
  const navigate = useNavigate();
  const { addToast } = useContext(ToastContext);
  const { setAuthenticated } = useContext(AuthContext);
  const { mutateAsync: login } = useMutation(
    async (data: IForm) =&gt; await axios.post("/sessions/",       data),
  );
  return [
    async (data: IForm, { setFieldError }:       FormikHelpers&lt;IForm&gt;)=&gt;{
      const loginData: any = {
        email: data.email,
        password: data.password,
      };
      if (requiresMFA) {
        loginData["token"] = data.token;
      }
      try {
        await login(loginData);
        setAuthenticated(true);
        navigate((location.state as any)?.from ?? "/");
      } catch (error: any) {
        if (error.response?.status === 400) {
          setRequiresMFA(true);
        } else if (error.response?.status === 401) {
          setFieldError("email", "Invalid credentials");
          setFieldError("password", "Invalid credentials");
          setFieldError("token", "Invalid credentials");
        } else {
          addToast("Try again", "error");
        }
      }
    },
    requiresMFA,
  ];
};</pre>
<p>The <code>useLogin</code> hook returns the login functionality and a flag indicating whether a one-time code is required. This flag is set when a login is attempted, and a <code>400</code> response is returned by<a id="_idIndexMarker496"/> the backend.</p>
<p>We can use the flag from the <code>useLogin</code> hook to show <code>TotpField</code> in the login form by making the highlighted changes to <em class="italic">frontend/src/pages/Login.tsx</em>:</p>
<pre class="source-code">
import TotpField from "src/components/TotpField"; 
const Login = () =&gt; {
<strong class="bold">  const [onSubmit, requiresMFA] = useLogin();</strong>
  ...
  return (
    &lt;&gt;
      &lt;Formik&lt;IForm&gt; 
        initialValues={{
          email: (location.state as any)?.email ?? "",
          password: "",
<strong class="bold">          token: "",</strong>
        }}
        onSubmit={onSubmit}
        validationSchema={validationSchema}
      &gt;
        {({ isSubmitting, values }) =&gt; (
          &lt;Form&gt;
<strong class="bold">            {requiresMFA ? (</strong>
<strong class="bold">              &lt;TotpField</strong>
<strong class="bold">                fullWidth={true}</strong>
<strong class="bold">                label="One time code"</strong>
<strong class="bold">                name="token"</strong>
<strong class="bold">                required={true}</strong>
<strong class="bold">              /&gt;</strong>
<strong class="bold">            ) : null}</strong>
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/&gt;
  );
};</pre>
<p>This will <a id="_idIndexMarker497"/>allow the user to type in a one-time code and complete the login. We can now consider how to handle the user losing the shared secret.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor196"/>Recovering and inactivating MFA</h2>
<p>Users will <a id="_idIndexMarker498"/>inevitably lose the shared secret and need to<a id="_idIndexMarker499"/> recover access to their accounts. This is something that is often done via recovery codes that the user is given when activating MFA. These recovery codes are additional single-use secrets stored in the backend and can be used once to regain access. While this works, any recovery system needs to consider how and what form your customer service will take, as users typically reach out for help. </p>
<p>OWASP provides additional guidance for this, which you can see here: <a href="http://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa">cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa</a>.</p>
<p>We’ve successfully made a major change to our app, which you can use as a template for further major changes you’ll need to make for your app. Next, we package our app for the app stores by converting it into a progressive web app.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor197"/>Converting to a Progressive Web App</h1>
<p>We can make our <a id="_idIndexMarker500"/>app more user-friendly, especially on mobile devices, by converting it into a <strong class="bold">progressive web app</strong> (<strong class="bold">PWA</strong>). PWAs can be installed on a mobile, like all other apps, either via the app stores or directly from a prompt in the browser. PWAs can also work offline and use other advanced features such as push notifications. However, PWAs are more complicated to develop, and service workers (a key feature) can be very difficult to get right.</p>
<p class="callout-heading">Service workers</p>
<p class="callout">Service workers are custom JavaScript scripts that act as a proxy between the web page and the server. This allows the service worker to add offline-frst functionality, such as caching pages for performance or accepting push notifications.</p>
<p>A PWA must have a service worker and a manifest file to work; these are available via the <code>create-react-app</code> tool we used in <a href="B18727_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up Our System for Development</em>. To do so, let’s create a new <code>react</code> app using the PWA template in a temporary directory:</p>
<pre>npx create-react-app temp --template cra-template-pwa-typescript</pre>
<p>We can then copy the service worker code from this temporary project into ours by copying the following files:</p>
<ul>
<li>Copy <em class="italic">temp/src/service-worker.ts</em> to <em class="italic">frontend/src/service-worker.ts</em></li>
<li>Copy <em class="italic">temp/src/serviceWorkerRegistration.ts</em> to <em class="italic">frontend/src/serviceWorkerRegistration.ts</em></li>
</ul>
<p>The <em class="italic">temp</em> directory can now be deleted or kept for reference if you prefer. </p>
<p>To activate the service worker, the following should be added to <em class="italic">frontend/src/index.tsx</em> to register the service worker:</p>
<pre class="source-code">
import * as serviceWorkerRegistration from "src/serviceWorkerRegistration"; 
serviceWorkerRegistration.register();</pre>
<p>This service<a id="_idIndexMarker501"/> worker needs a large number of dependencies from the workbox toolkit (<a href="http://web.dev/workbox/">web.dev/workbox/</a>) to work; these dependencies are developed by Google to make service workers easier to use. These dependencies can be installed by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install workbox-background-sync workbox-background-sync workbox-cacheable-response workbox-core workbox-expiration workbox-navigation-preload workbox-precaching workbox-range-requests workbox-routing workbox-strategies workbox-streams</pre>
<p>The service worker isn’t active while we develop the app using the frontend development server with <code>npm run start</code>, so to test it, we need to serve it locally by the backend development server. First, we must build the frontend, by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm run build</pre>
<p>This will have created files in the <em class="italic">frontend/build</em> directory, which we need to copy over to the backend. This requires the following file movements:</p>
<ul>
<li>Copy the entire <em class="italic">frontend/build/static</em> directory to <em class="italic">backend/src/backend/static</em> </li>
<li>Copy the <em class="italic">frontend/build/index.xhtml</em> file to <em class="italic">backend/src/backend/templates/index.xhtml</em></li>
<li>Copy the remaining files in <em class="italic">frontend/build</em> to <em class="italic">backend/src/backend/static</em> (e.g., <em class="italic">frontend/build/service-worker.js</em> to <em class="italic">backend/src/backend/static/service-worker.js</em>)</li>
</ul>
<p>The remaining files also need to be included in <em class="italic">Dockerfile</em>, and the following should be added next to the existing <code>COPY --from=frontend</code> commands:</p>
<pre>COPY --from=frontend /frontend/build/*.js* /app/backend/static/</pre>
<p>With <a id="_idIndexMarker502"/>the backend running (via <code>pdm run start</code>), the service worker-enabled app is reachable at <code>localhost:5050</code>. You can check the service worker is working via the dev tools console as seen in <em class="italic">Figure 7.4</em>:</p>
<div><div><img alt="Figure 7.4: The service worker output in the browser dev tools " height="218" src="img/B18787_07_04.jpg" width="1321"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: The service worker output in the browser dev tools</p>
<p>The service worker will now start caching the content, and you should be able to refresh the app while the backend is not running.</p>
<p class="callout-heading">App icons</p>
<p class="callout">Web pages in the browser have an icon associated with them, typically shown next to the title in the tab. This icon is called the favicon. A PWA has additional icons used for the app on the mobile home screen (and elsewhere); these icons are defined in the manifest file.</p>
<p>We can now turn our attention to the manifest file, which describes the app and the logo that should be associated with it. Once you have designed a logo, I’d recommend that it be saved as a favicon in the SVG format placed in <em class="italic">frontend/public/favicon.svg</em>. As we are using an SVG format rather than ICO, the following should replace the existing code in <em class="italic">frontend/public/index.xhtml</em> (note the file extension):</p>
<pre>&lt;link rel="icon" href="%PUBLIC_URL%/favicon.svg" /&gt;</pre>
<p>The same logo then needs to be saved in the PNG format as a 192x192 pixel square in <em class="italic">frontend/public/logo192.png</em> and as a 512x512 pixel square in <em class="italic">frontend/public/logo512.png</em>. The manifest should include the following, which should be placed <a id="_idIndexMarker503"/>in <em class="italic">frontend/public/manifest.json</em>:</p>
<pre class="source-code">
{
  "short_name": "Tozo",
  "name": "Tozo todo app",
  "icons": [
    {
      "src": "favicon.svg",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": " image/svg+xml"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#1976d2",
  "background_color": "#ffffff"
}</pre>
<p>As with the service worker, we also need to copy the logos to the backend. For development, copy all the logos to the <em class="italic">backend/src/backend/static/</em> folder. For production, the following should be added to the <em class="italic">Dockerfile</em>:</p>
<pre>COPY --from=frontend /frontend/build/*.png /frontend/build/*.svg /app/backend/static/</pre>
<p>We now <a id="_idIndexMarker504"/>need to serve these new files from the backend, which we can do by adding the following code to <em class="italic">backend/src/backend/blueprints/serving.py</em>:</p>
<pre class="source-code">
from quart import current_app, send_from_directory
@blueprint.get(
    "/&lt;any('service-worker.js', 'service-worker.js.map', 'manifest.json', 'asset-manifest.json', 'favicon.svg', 'logo192.png', 'logo512.png'):path&gt;"  # noqa: E501
)
@rate_exempt
async def resources(path: str) -&gt; ResponseReturnValue:
    assert current_app.static_folder is not None  # nosec
    return await send_from_directory(
        current_app.static_folder, path
    )</pre>
<p>With these changes made, our app is a PWA, which means that we can package it for the app stores. The easiest way to do so is to use <a href="http://pwabuilder.com">pwabuilder.com</a>, which will create iOS and Android packages. To do so, visit <a href="http://pwabuilder.com">pwabuilder.com</a> and enter your app’s domain. It will then present the packages that can be uploaded to the Google Play store and iOS app stores.</p>
<p class="callout-heading">PWA Builder </p>
<p class="callout">PWA Builder is a Microsoft-directed project to improve PWA adoption by making it easier. PWAs are first-class apps on Windows and Android. </p>
<p>There are limitations to this approach; first, while PWAs are first-class apps on Windows and Android systems, they have limited support on Apple’s iOS. It may be the case that your app as packaged by PWA Builder is not accepted on the app store – with little explanation why. In addition, iOS does not support all the features that PWAs can; the most notable being that push notifications will not be supported till 2023.</p>
<p>With the conversion to PWA complete, we can upload the PWA package to the various app stores allowing users to install it on their phones from the store. Further instructions<a id="_idIndexMarker505"/> on how to do so are given for Android (https://docs.pwabuilder.com/#/builder/android) and iOS (<a href="https://docs.pwabuilder.com/#/builder/app-store">https://docs.pwabuilder.com/#/builder/app-store</a>). </p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor198"/>Summary</h1>
<p>In this chapter, we’ve secured our app and adopted a process of continual updates to keep it secure. We’ve also added a major feature, MFA, which will serve as a guide for making future major changes to your app. Finally, we’ve packaged our app ready to be added to the app stores.</p>
<p>This is a great place to be, as you now have a blueprint for a web app that is running in production using many industry best practices. This is a blueprint you can adapt for your own needs with the to-do specific aspects serving as a guide, and I hope that the best practices and tools I’ve introduced to you serve you well.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor199"/>Further reading</h1>
<p>This isn’t the end; there is much more you can and should now do to improve your app to make it more valuable to your users. I’d recommend you add more testing to reduce bugs, specifically by adding end-to-end testing. I’d also recommend you use tools such as Lighthouse, <a href="http://pagespeed.web.dev">pagespeed.web.dev</a>, to identify common performance, accessibility, and general PWA issues.</p>
</div>
</div></body></html>