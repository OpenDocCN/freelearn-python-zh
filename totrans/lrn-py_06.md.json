["```py\nfrom time import sleep, time\n\ndef f():\n    sleep(.3)\n\ndef g():\n    sleep(.5)\n\nt = time()\nf()\nprint('f took: ', time() - t)  # f took: 0.3003859519958496\n\nt = time()\ng()\nprint('g took:', time() - t)  # g took: 0.5005719661712646\n```", "```py\nfrom time import sleep, time\n\ndef f():\n    sleep(.3)\n\ndef g():\n    sleep(.5)\n\ndef measure(func):\n t = time()\n func()\n print(func.__name__, 'took:', time() - t)\n\nmeasure(f)  # f took: 0.30041074752807617\nmeasure(g)  # g took: 0.5006198883056641\n```", "```py\nfrom time import sleep, time\n\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\n\ndef measure(func, *args, **kwargs):\n    t = time()\n    func(*args, **kwargs)\n    print(func.__name__, 'took:', time() - t)\n\nmeasure(f, sleep_time=0.3)  # f took: 0.3004162311553955\nmeasure(f, 0.2)  # f took: 0.20028162002563477\n```", "```py\nfrom time import sleep, time\n\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\n\ndef measure(func):\n def wrapper(*args, **kwargs):\n t = time()\n func(*args, **kwargs)\n print(func.__name__, 'took:', time() - t)\n return wrapper\n\nf = measure(f)  # decoration point\n\nf(0.2)  # f took: 0.2002875804901123\nf(sleep_time=0.3)  # f took: 0.3003721237182617\nprint(f.__name__)  # wrapper  <- ouch!\n```", "```py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decorator(func)\n\n# is equivalent to the following:\n\n@decorator\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\ndef func(arg1, arg2, ...):\n    pass\nfunc = deco1(deco2(func))\n\n# is equivalent to the following:\n\n@deco1\n@deco2\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decoarg(argA, argB)(func)\n\n# is equivalent to the following:\n\n@decoarg(argA, argB)\ndef func(arg1, arg2, ...):\n    pass\n```", "```py\nfrom time import sleep, time\nfrom functools import wraps\n\ndef measure(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        t = time()\n        func(*args, **kwargs)\n        print(func.__name__, 'took:', time() - t)\n    return wrapper\n\n@measure\ndef f(sleep_time=0.1):\n    \"\"\"I'm a cat. I love to sleep! \"\"\"\n    sleep(sleep_time)\n\nf(sleep_time=0.3)  # f took: 0.30039525032043457\nprint(f.__name__, ':', f.__doc__)\n# f : I'm a cat. I love to sleep!\n\n```", "```py\nfrom time import sleep, time\nfrom functools import wraps\n\ndef measure(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        t = time()\n        result = func(*args, **kwargs)\n        print(func.__name__, 'took:', time() - t)\n        return result\n    return wrapper\n\ndef max_result(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if result > 100:\n            print('Result is too big ({0}). Max allowed is 100.'\n                .format(result))\n        return result\n    return wrapper\n\n@measure\n@max_result\ndef cube(n):\n    return n ** 3\n\nprint(cube(2))\nprint(cube(5))\n```", "```py\n$ python two.decorators.py \ncube took: 7.62939453125e-06  #\n8  #\nResult is too big (125). Max allowed is 100.\ncube took: 1.1205673217773438e-05\n125\n\n```", "```py\nfrom functools import wraps\n\ndef max_result(threshold):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if result > threshold:\n                print(\n                    'Result is too big ({0}). Max allowed is {1}.'\n                    .format(result, threshold))\n            return result\n        return wrapper\n    return decorator\n\n@max_result(75)\ndef cube(n):\n    return n ** 3\n\nprint(cube(5))\n```", "```py\n$ python decorators.factory.py \nResult is too big (125). Max allowed is 75.\n125\n\n```", "```py\n@max_result(75)\ndef cube(n):\n    return n ** 3\n\n@max_result(100)\ndef square(n):\n    return n ** 2\n\n@max_result(1000)\ndef multiply(a, b):\n    return a * b\n```", "```py\nclass Simplest():  # when empty, the braces are optional\n pass\n\nprint(type(Simplest))  # what type is this object?\n\nsimp = Simplest()  # we create an instance of Simplest: simp\nprint(type(simp))  # what type is simp?\n# is simp an instance of Simplest?\nprint(type(simp) == Simplest)  # There's a better way for this\n```", "```py\n$ python oop/simplest.class.py \n<class 'type'>\n<class '__main__.Simplest'>\nTrue\n\n```", "```py\nclass Person():\n    species = 'Human'\n\nprint(Person.species)  # Human\nPerson.alive = True  # Added dynamically!\nprint(Person.alive)  # True\n\nman = Person()\nprint(man.species)  # Human (inherited)\nprint(man.alive)  # True (inherited)\n\nPerson.alive = False\nprint(man.alive)  # False (inherited)\n\nman.name = 'Darth'\nman.surname = 'Vader'\nprint(man.name, man.surname)  # Darth Vader\n```", "```py\nclass Point():\n    x = 10\n y = 7\n\np = Point()\nprint(p.x)  # 10 (from class attribute)\nprint(p.y)  # 7 (from class attribute)\n\np.x = 12  # p gets its own 'x' attribute\nprint(p.x)  # 12 (now found on the instance)\nprint(Point.x)  # 10 (class attribute still the same)\n\ndel p.x  # we delete instance attribute\nprint(p.x)  # 10 (now search has to go again to find class attr)\n\np.z = 3  # let's make it a 3D point\nprint(p.z)  # 3\n\nprint(Point.z)\n# AttributeError: type object 'Point' has no attribute 'z'\n```", "```py\nclass Square():\n    side = 8\n    def area(self):  # self is a reference to an instance\n        return self.side ** 2\n\nsq = Square()\nprint(sq.area())  # 64 (side is found on the class)\nprint(Square.area(sq))  # 64 (equivalent to sq.area())\n\nsq.side = 10\nprint(sq.area())  # 100 (side is found on the instance)\n```", "```py\nclass Price():\n    def final_price(self, vat, discount=0):\n        \"\"\"Returns price after applying vat and fixed discount.\"\"\"\n        return (self.net_price * (100 + vat) / 100) - discount\n\np1 = Price()\np1.net_price = 100\nprint(Price.final_price(p1, 20, 10))  # 110 (100 * 1.2 - 10)\nprint(p1.final_price(20, 10))  # equivalent\n```", "```py\nclass Rectangle():\n    def __init__(self, sideA, sideB):\n self.sideA = sideA\n self.sideB = sideB\n\n    def area(self):\n        return self.sideA * self.sideB\n\nr1 = Rectangle(10, 4)\nprint(r1.sideA, r1.sideB)  # 10 4\nprint(r1.area())  # 40\n\nr2 = Rectangle(7, 3)\nprint(r2.area())  # 21\n```", "```py\nclass Engine():\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\nclass ElectricEngine(Engine):  # Is-A Engine\n    pass\n\nclass V8Engine(Engine):  # Is-A Engine\n    pass\n\nclass Car():\n    engine_cls = Engine\n\n    def __init__(self):\n        self.engine = self.engine_cls()  # Has-A Engine\n\n    def start(self):\n        print(\n            'Starting engine {0} for car {1}... Wroom, wroom!'\n            .format(\n                self.engine.__class__.__name__,\n                self.__class__.__name__)\n        )\n        self.engine.start()\n\n    def stop(self):\n        self.engine.stop()\n\nclass RaceCar(Car):  # Is-A Car\n    engine_cls = V8Engine\n\nclass CityCar(Car):  # Is-A Car\n    engine_cls = ElectricEngine\n\nclass F1Car(RaceCar):  # Is-A RaceCar and also Is-A Car\n    engine_cls = V8Engine\n\ncar = Car()\nracecar = RaceCar()\ncitycar = CityCar()\nf1car = F1Car()\ncars = [car, racecar, citycar, f1car]\n\nfor car in cars:\n    car.start()\n\n\"\"\" Prints:\nStarting engine Engine for car Car... Wroom, wroom!\nStarting engine V8Engine for car RaceCar... Wroom, wroom!\nStarting engine ElectricEngine for car CityCar... Wroom, wroom!\nStarting engine V8Engine for car F1Car... Wroom, wroom!\n\"\"\"\n```", "```py\ncar = Car()\nracecar = RaceCar()\nf1car = F1Car()\ncars = [(car, 'car'), (racecar, 'racecar'), (f1car, 'f1car')]\ncar_classes = [Car, RaceCar, F1Car]\n\nfor car, car_name in cars:\n    for class_ in car_classes:\n        belongs = isinstance(car, class_)\n        msg = 'is a' if belongs else 'is not a'\n        print(car_name, msg, class_.__name__)\n\n\"\"\" Prints:\ncar is a Car\ncar is not a RaceCar\ncar is not a F1Car\nracecar is a Car\nracecar is a RaceCar\nracecar is not a F1Car\nf1car is a Car\nf1car is a RaceCar\nf1car is a F1Car\n\"\"\"\n```", "```py\nfor class1 in car_classes:\n    for class2 in car_classes:\n        is_subclass = issubclass(class1, class2)\n        msg = '{0} a subclass of'.format(\n            'is' if is_subclass else 'is not')\n        print(class1.__name__, msg, class2.__name__)\n\n\"\"\" Prints:\nCar is a subclass of Car\nCar is not a subclass of RaceCar\nCar is not a subclass of F1Car\nRaceCar is a subclass of Car\nRaceCar is a subclass of RaceCar\nRaceCar is not a subclass of F1Car\nF1Car is a subclass of Car\nF1Car is a subclass of RaceCar\nF1Car is a subclass of F1Car\n\"\"\"\n```", "```py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        self.title = title\n self.publisher = publisher\n self.pages = pages\n        self.format_ = format_\n```", "```py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        Book.__init__(self, title, publisher, pages)\n        self.format_ = format_\n\nebook = Ebook('Learning Python', 'Packt Publishing', 360, 'PDF')\nprint(ebook.title)  # Learning Python\nprint(ebook.publisher)  # Packt Publishing\nprint(ebook.pages)  # 360\nprint(ebook.format_)  # PDF\n```", "```py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        super().__init__(title, publisher, pages)\n        # Another way to do the same thing is:\n        # super(Ebook, self).__init__(title, publisher, pages)\n        self.format_ = format_\n\nebook = Ebook('Learning Python', 'Packt Publishing', 360, 'PDF')\nprint(ebook.title)  # Learning Python\nprint(ebook.publisher)  # Packt Publishing\nprint(ebook.pages)  # 360\nprint(ebook.format_)  # PDF\n```", "```py\nclass Shape:\n    geometric_type = 'Generic Shape'\n\n    def area(self):  # This acts as placeholder for the interface\n        raise NotImplementedError\n\n    def get_geometric_type(self):\n        return self.geometric_type\n\nclass Plotter:\n\n    def plot(self, ratio, topleft):\n        # Imagine some nice plotting logic here...\n        print('Plotting at {}, ratio {}.'.format(\n            topleft, ratio))\n\nclass Polygon(Shape, Plotter):  # base class for polygons\n    geometric_type = 'Polygon'\n\nclass RegularPolygon(Polygon):  # Is-A Polygon\n    geometric_type = 'Regular Polygon'\n\n    def __init__(self, side):\n        self.side = side\n\nclass RegularHexagon(RegularPolygon): # Is-A RegularPolygon\n    geometric_type = 'RegularHexagon'\n\n    def area(self):\n        return 1.5 * (3 ** .5 * self.side ** 2)\n\nclass Square(RegularPolygon):  # Is-A RegularPolygon\n    geometric_type = 'Square'\n\n    def area(self):\n        return self.side * self.side\n\nhexagon = RegularHexagon(10)\nprint(hexagon.area())  # 259.8076211353316\nprint(hexagon.get_geometric_type())  # RegularHexagon\nhexagon.plot(0.8, (75, 77))  # Plotting at (75, 77), ratio 0.8.\n\nsquare = Square(12)\nprint(square.area())  # 144\nprint(square.get_geometric_type())  # Square\nsquare.plot(0.93, (74, 75))  # Plotting at (74, 75), ratio 0.93.\n```", "```py\nprint(square.__class__.__mro__)\n# prints:\n# (<class '__main__.Square'>, <class '__main__.RegularPolygon'>,\n#  <class '__main__.Polygon'>, <class '__main__.Shape'>,\n#  <class '__main__.Plotter'>, <class 'object'>)\n```", "```py\nclass A:\n    label = 'a'\n\nclass B(A):\n    label = 'b'\n\nclass C(A):\n    label = 'c'\n\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.label)  # Hypothetically this could be either 'b' or 'c'\n```", "```py\nclass A:\n    label = 'a'\n\nclass B(A):\n    pass  # was: label = 'b'\n\nclass C(A):\n    label = 'c'\n\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.label)  # 'c'\nprint(d.__class__.mro())  # notice another way to get the MRO\n# prints:\n# [<class '__main__.D'>, <class '__main__.B'>,\n#  <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]\n```", "```py\nclass String:\n\n    @staticmethod\n    def is_palindrome(s, case_insensitive=True):\n        # we allow only letters and numbers\n        s = ''.join(c for c in s if c.isalnum())  # Study this!\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        for c in range(len(s) // 2):\n            if s[c] != s[-c -1]:\n                return False\n        return True\n\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\n\nprint(String.is_palindrome(\n    'Radar', case_insensitive=False))  # False: Case Sensitive\nprint(String.is_palindrome('A nut for a jar of tuna'))  # True\nprint(String.is_palindrome('Never Odd, Or Even!'))  # True\nprint(String.is_palindrome(\n    'In Girum Imus Nocte Et Consumimur Igni')  # Latin! Show-off!\n)  # True\n\nprint(String.get_unique_words(\n    'I love palindromes. I really really love them!'))\n# {'them!', 'really', 'palindromes.', 'I', 'love'}\n```", "```py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def from_tuple(cls, coords):  # cls is Point\n        return cls(*coords)\n\n    @classmethod\n    def from_point(cls, point):  # cls is Point\n        return cls(point.x, point.y)\n\np = Point.from_tuple((3, 7))\nprint(p.x, p.y)  # 3 7\nq = Point.from_point(p)\nprint(q.x, q.y)  # 3 7\n```", "```py\nclass String:\n\n    @classmethod\n    def is_palindrome(cls, s, case_insensitive=True):\n        s = cls._strip_string(s)\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        return cls._is_palindrome(s)\n\n    @staticmethod\n    def _strip_string(s):\n        return ''.join(c for c in s if c.isalnum())\n\n    @staticmethod\n    def _is_palindrome(s):\n        for c in range(len(s) // 2):\n            if s[c] != s[-c -1]:\n                return False\n        return True\n\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\n\nprint(String.is_palindrome('A nut for a jar of tuna'))  # True\nprint(String.is_palindrome('A nut for a jar of beans'))  # False\n```", "```py\nclass A:\n    def __init__(self, factor):\n        self._factor = factor\n\n    def op1(self):\n        print('Op1 with factor {}...'.format(self._factor))\n\nclass B(A):\n    def op2(self, factor):\n        self._factor = factor\n        print('Op2 with factor {}...'.format(self._factor))\n\nobj = B(100)\nobj.op1()    # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()    # Op1 with factor 42...  <- This is BAD\n\n```", "```py\nclass A:\n    def __init__(self, factor):\n        self.__factor = factor\n\n    def op1(self):\n        print('Op1 with factor {}...'.format(self.__factor))\n\nclass B(A):\n    def op2(self, factor):\n        self.__factor = factor\n        print('Op2 with factor {}...'.format(self.__factor))\n\nobj = B(100)\nobj.op1()    # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()    # Op1 with factor 100...  <- Wohoo! Now it's GOOD!\n\n```", "```py\nprint(obj.__dict__.keys())\n# dict_keys(['_factor'])\n\n```", "```py\nprint(obj.__dict__.keys())\n# dict_keys(['_A__factor', '_B__factor'])\n\n```", "```py\nclass Person:\n    def __init__(self, age):\n        self.age = age  # anyone can modify this freely\n\nclass PersonWithAccessors:\n    def __init__(self, age):\n        self._age = age\n\n    def get_age(self):\n        return self._age\n\n    def set_age(self):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError('Age must be within [18, 99]')\n\nclass PersonPythonic:\n    def __init__(self, age):\n        self._age = age\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, age):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError('Age must be within [18, 99]')\n\nperson = PersonPythonic(39)\nprint(person.age)  # 39 - Notice we access as data attribute\nperson.age = 42  # Notice we access as data attribute\nprint(person.age)  # 42\nperson.age = 100  # ValueError: Age must be within [18, 99]\n```", "```py\nclass Weird:\n    def __init__(self, s):\n        self._s = s\n\n    def __len__(self):\n        return len(self._s)\n\n    def __bool__(self):\n        return '42' in self._s\n\nweird = Weird('Hello! I am 9 years old!')\nprint(len(weird))  # 24\nprint(bool(weird))  # False\n\nweird2 = Weird('Hello! I am 42 years old!')\nprint(len(weird2))  # 25\nprint(bool(weird2))  # True\n```", "```py\nclass OddEven:\n\n    def __init__(self, data):\n        self._data = data\n        self.indexes = (list(range(0, len(data), 2)) +\n list(range(1, len(data), 2)))\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.indexes:\n            return self._data[self.indexes.pop(0)]\n        raise StopIteration\n\noddeven = OddEven('ThIsIsCoOl!')\nprint(''.join(c for c in oddeven))  # TIICO!hssol\n\noddeven = OddEven('HoLa')  # or manually...\nit = iter(oddeven)  # this calls oddeven.__iter__ internally\nprint(next(it))  # H\nprint(next(it))  # L\nprint(next(it))  # o\nprint(next(it))  # a\n```"]