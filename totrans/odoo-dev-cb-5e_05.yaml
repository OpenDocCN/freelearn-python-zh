- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Server-Side Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to declare or extend business models in custom modules in [*Chapter
    4*](B20997_04.xhtml#_idTextAnchor118), *Application Models*. Writing methods for
    calculated fields and ways to restrict the field values are both addressed in
    that chapter’s tutorials. This chapter focuses on the fundamentals of server-side
    programming in Odoo method declarations, record set manipulation, and extending
    inherited methods. You may use this to create or alter business logins in the
    Odoo module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying model methods and implementing API decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying errors to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a blank recordset for a different model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating values of recordset records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing recordset relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending a model’s established business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `write()` and `create()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing how records are searched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data in groups using `read_group()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The online platform for Odoo is one of the prerequisites for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain all the code used in this chapter from the following GitHub
    repository: [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying model methods and using API decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class in Odoo models consists of both business logic methods and field declarations.
    We learned how to add fields to a model in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118),
    *Application Models*. We will now see how to include business logic and methods
    in a model.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we’ll learn how to create a function that may be used by our
    application’s user interface buttons or another piece of code. This method will
    operate on `HostelRoom` and take the necessary steps to modify the state of a
    number of rooms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This tutorial assumes that you have an instance ready, with the `my_hostel`
    add-on module available, as described in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*. You will need to add a `state` field to the `HostelRoom`
    model, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the *Adding models* tutorial in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a method for hostel rooms to change the state of a selection of rooms,
    you need to add the following code to the model definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a helper method to check whether a state transition is allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to change the state of a room to a new state that is passed as
    an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to change the room state by calling the `change_state` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button and status bar in the `<form>` view. This will help us trigger
    these methods from the user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To access these updates, you must update the module or install it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several methods are defined in the tutorial’s code. They are typical Python
    methods with `self` as their first argument and the option of receiving additional
    arguments. The `odoo.api` module’s **decorators** are used to adorn some methods.
  prefs: []
  type: TYPE_NORMAL
- en: TIP
  prefs: []
  type: TYPE_NORMAL
- en: In Odoo 9.0, the API decorators were first added to support both the old and
    new frameworks. The previous API is no longer supported as of Odoo 10.0, however,
    some decorators, such `@api.model`, are still in use.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a new method, if you don’t use a decorator, then the method is
    executed on a recordset. In such methods, `self` is a recordset that can refer
    to an arbitrary number of database records (this includes empty recordsets), and
    the code will often loop over the records in `self` to do something on each individual
    record.
  prefs: []
  type: TYPE_NORMAL
- en: The `@api.model` decorator is similar, but it’s used on methods for which only
    the model is important, not the contents of the recordset, which is not acted
    upon by the method. The concept is similar to Python’s `@``classmethod` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 1*, we created the `is_allowed_transition()` method. The purpose of
    this method is to verify whether a transition from one state to another is valid.
    The tuples in the `allowed` list are the available transitions. For example, we
    don’t want to allow a transition from `closed` to `available`, which is why we
    haven’t put `('``closed, 'available')`.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we created the `change_state()` method. The purpose of this method
    is to change the status of the room. When this method is called, it changes the
    status of the room to the state given by the `new_state` parameter. It only changes
    the room status if the transition is allowed. We used a `for` loop here because
    `self` can contain multiple recordsets.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we created the methods that change the state of the room by calling
    the `change_state()` method. In our case, this method will be triggered by the
    buttons that were added to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 4*, we added `<button>` in the `<form>` view. Upon clicking this button,
    the Odoo web client will invoke the Python function mentioned in the `name` attribute.
    Refer to the *Adding buttons to forms* tutorial in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*, to learn how to call such a method from the user interface. We
    have also added the `state` field with the `statusbar` widget to display the status
    of the room in the `<``form>` view.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the button from the user interface, one of the methods
    from *Step 3* will be called. Here, `self` will be the recordset that contains
    the record of the `hostel.room` model. After that, we call the `change_state()`
    method and pass the appropriate parameter based on the button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: When `change_state()` is called, `self` is the same recordset of the `hostel.room`
    model. The body of the `change_state()` method loops over `self` to process each
    room in the recordset. Looping on `self` looks strange at first, but you will
    get used to this pattern very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, `change_state()` calls `is_allowed_transition()`. The call
    is made using the `room` local variable, but it can be made on any recordset for
    the `hostel.room` model, including, for example, `self`, since `is_allowed_transition()`
    is decorated with `@api.model`. If the transition is allowed, `change_state()`
    assigns the new state to the room by assigning a value to the attribute of the
    recordset. This is only valid on recordsets with a length of `1`, which is guaranteed
    to be the case when iterating over `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors to the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it’s required to stop processing during method execution because
    the user’s activity is invalid or an error condition has been satisfied. By displaying
    an informative error message, this tutorial demonstrates how to handle these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The `UserError` exception is commonly utilized to inform users about errors
    or exceptional situations. It is typically employed when the user’s input fails
    to meet the expected criteria or when a particular operation cannot be executed
    due to specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tutorial requires that you set up an instance with the `my_hostel` add-on
    module installed, as per the instructions from before.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will make a change to the `change_state` method from the previous tutorial
    and display a helpful message when the user is trying to change the state that
    is not allowed by the `is_allowed_transition` method. Perform the following steps
    to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following import at the beginning of the Python file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `change_state` method and raise a `UserError` exception from the
    `else` part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is raised in Python, it propagates up the call stack until
    it is processed. In Odoo, the **remote procedure call** (**RPC**) layer that answers
    the calls made by the web client catches all exceptions and, depending on the
    exception class, triggers different possible behaviors on the web client.
  prefs: []
  type: TYPE_NORMAL
- en: Any exception not defined in `odoo.exceptions` will be handled as an internal
    server error (`UserError` will display an error message in the user interface.
    The code of the tutorial raises `UserError` to ensure that the message is displayed
    in a user-friendly way. In all cases, the current database transaction is rolled
    back.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a function with a strange name, `_()`, which is defined in `odoo.tools.translate`.
    This function is used to mark a string as translatable and to retrieve the translated
    string at runtime, given the language of the end user that’s found in the execution
    context. More information on this is available in [*Chapter* *11*](B20997_11.xhtml#_idTextAnchor595),
    *Internationalisation*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `_()` function, ensure that you pass only strings with the interpolation
    placeholder, not the whole interpolated string. For example, `_(''Warning: could
    not find %s'') % value` is correct, but `_(''Warning: could not find %s'' % value)`
    is incorrect because the first one will not find the string with the substituted
    value in the translation database.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you are working on error-prone code, meaning that the operation
    you are performing may generate an error. Odoo will catch this error and display
    a traceback to the user. If you don’t want to show a full error log to the user,
    you can catch the error and raise a custom exception with a meaningful message.
    In the example provided, we are generating `UserError` from the `try...catch`
    block so that instead of showing a full error log, Odoo will now show a warning
    with a meaningful message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more exception classes defined in `odoo.exceptions`, all deriving
    from the base legacy `except_orm` exception class. Most of them are only used
    internally, apart from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ValidationError`: This exception is raised when a Python constraint on a field
    is not respected. In [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application
    Models*, refer to the *Adding constraint validations to a model* tutorial for
    more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AccessError`: This error is usually generated automatically when the user
    tries to access something that is not allowed. You can raise the error manually
    if you want to show the access error from your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RedirectWarning`: With this error, you can show a redirection button with
    the error message. You need to pass two parameters to this exception: the first
    parameter is the action ID, and the second parameter is the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Warning`: In Odoo 8.0, `odoo.exceptions.Warning` played the same role as `UserError`
    in 9.0 and later. It is now deprecated because the name was deceptive (it is an
    error, not a warning) and it collided with the Python built-in `Warning` class.
    It is kept for backward compatibility only, and you should use `UserError` in
    your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining an empty recordset for a different model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current model’s methods are accessible through `self` while creating Odoo
    code. It is not feasible to start working on a different model by simply instantiating
    its class; you must first obtain a recordset for that model.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows you how to get an empty recordset for any model that’s registered
    in Odoo inside a model method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tutorial will reuse the setup of the library example in the `my_hostel`
    add-on module.
  prefs: []
  type: TYPE_NORMAL
- en: We will write a small method in the `hostel.room` model and search for all `hostel.room.members`.
    To do this, we need to get an empty recordset for `hostel.room.members`. Make
    sure you have added the `hostel.room.members` model and access rights for that
    model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a recordset for `hostel.room.members` in a method of `hostel.room`,
    you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – log_all_room_members](img/B20997_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – log_all_room_members
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HostelRoom` class, write a method called `log_all_room_members`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button to the `<form>` view to invoke our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the module to apply the changes. After that, you will see the `<form>`
    view. You may view the member’s recordset in the server log by clicking that button.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At startup, Odoo loads all the modules and combines the various classes that
    derive from `Model`, and also defines or extends the given model. These classes
    are stored in the `env` attribute of any recordset, available as `self.env`, is
    an instance of the `Environment` class defined in the `odoo.api` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Environment` class plays a central role in Odoo development:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides shortcut access to the registry by emulating a Python dictionary.
    If you know the name of the model you’re looking for, `self.env[model_name]` will
    get you an empty recordset for that model. Moreover, the recordset will share
    the environment of `self`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a `cr` attribute, which is a database cursor you may use to pass raw
    SQL queries. Refer to the *Executing raw SQL queries* tutorial in [*Chapter 8*](B20997_08.xhtml#_idTextAnchor388),
    *Advanced Server-Side Development Techniques*, for more information on this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a `user` attribute, which is a reference to the current user performing
    the call. Take a look at [*Chapter 8*](B20997_08.xhtml#_idTextAnchor388), *Advanced
    Server-Side Development Techniques*, and the *Changing the user performing an
    action* tutorial for more on this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a `context` attribute, which is a dictionary that contains the context
    of the call. This includes information about the language of the user, the time
    zone, and the current selection of records. Refer to the *Calling a method with
    a modified context* tutorial in [*Chapter 8*](B20997_08.xhtml#_idTextAnchor388),
    *Advanced Server-Side Development Techniques*, for more on this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `search()` is explained in the *Searching for records* tutorial
    later.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want to use a modified version of the environment. One such example
    is that you want an environment with a different user and language. In [*Chapter
    8*](B20997_08.xhtml#_idTextAnchor388), *Advanced Server-Side Development Techniques*,
    you will learn how to modify the environment at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating new records is a regular requirement when putting business logic processes
    into practice. How you can build records for the `hostel.room.category` model
    is included in this tutorial. We’ll add a function to the `hostel.room.category`
    model to generate dummy categories for the purposes of our example. We will add
    the `<form>` view to activate this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to understand the structure of the models for which you want to create
    a record, especially their names and types, as well as any constraints that exist
    on these fields (for example, whether some of them are mandatory).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this tutorial, we will reuse the `my_hostel` module from [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118),
    *Application Models*. Take a look at the following example to quickly recall the
    `hostel.room.category` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have added menus, views, and access rights for the `hostel.room.category`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a category with some child categories, you need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Create a category](img/B20997_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Create a category
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method in the `hostel.room.category` model with the name `create_categories`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the body of this method, prepare a dictionary of values for the fields
    of the first child category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prepare a dictionary of values for the fields of the second category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prepare a dictionary of values for the fields of the parent category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `create()` method to create the new records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button in the `<form>` view to trigger the `create_categories` method
    from the user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new record for a model, we can call the `create(values)` method on
    any recordset related to the model. This method returns a new recordset with a
    length of `1` and contains the new record, with the field values specified in
    the `values` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in the dictionary identify the fields by name, while the accompanying
    values reflect the field’s value. Depending on the field type, you need to pass
    different Python types for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Text` field value is given with Python strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Float` and `Integer` field values are given using Python floats or integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `boolean` field value is given preferably using Python Booleans or integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Date` field value is given with the Python `datetime.date` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Datetime` field value is given with the Python `datetime.datetime` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Binary` field value is passed as a Base64-encoded string. The `base64` module
    from the Python standard library provides methods such as `encodebytes(bytestring)`
    to encode a string in Base64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Many2one` field value is given with an integer, which has to be the database
    ID of the related record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`One2many` and `Many2many` fields use a special syntax. The value is a list
    that contains tuples of three elements, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Table 5.1 – Relational field write](img/B20997_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 5.1 – Relational field write
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we create the dictionaries for two categories in the hostel
    room we want to create, and then we use these dictionaries in the `child_ids`
    entry of the dictionary for the hostel room categories being created by using
    the `(0, 0, dict_val)` syntax we explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `create()` is called in *Step 5*, three records are created:'
  prefs: []
  type: TYPE_NORMAL
- en: One for the parent room category, which is returned by `create`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two records for the child room category, which are available in `record.child_ids`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the model defined some default values for some fields, nothing special needs
    to be done. `create()` will take care of computing the default values for the
    fields that aren’t present in the supplied dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create()` method also supports the creation of records in a batch. To
    create multiple records in a batch, you need to pass a list of multiple values
    to the `create()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code will return the recordset of created categories of the hostel room
    category.
  prefs: []
  type: TYPE_NORMAL
- en: Updating values of recordset records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business logic often requires us to update records by changing the values of
    some of their fields. This tutorial shows you how to modify the `room_no` field
    of the partner as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tutorial will use the same simplified `hostel.room` definition of the *Creating
    new records* tutorial. You may refer to this simplified definition to find out
    about the fields.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `room_no` field in the `hostel.room` model. For illustration purposes,
    we will write in this field with the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update a room’s `room_no` field, you can write a new method called `update_room_no()`,
    which is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can add a button to the room’s `<form>` view in `xml`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart the server and update the `my_hostel` module to see the changes. Upon
    clicking the `room_no` will be changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method starts by checking whether the room recordset that’s passed as `self`
    contains exactly one record by calling `ensure_one()`. If this is not the case,
    this procedure will generate an exception, and processing will stop. This is necessary
    because we don’t want to change the room number of multiple records. If you want
    to update multiple values, you can remove `ensure_one()` and update the attribute
    using a loop on the recordset.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method modifies the values of the attributes of the room record.
    It updates the `room_no` field with the defined room number. Just by modifying
    the field attributes of the recordset, you can perform write operations.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three options available if you want to add new values to the fields
    of records:'
  prefs: []
  type: TYPE_NORMAL
- en: Option one is the one that was explained in this tutorial. It works in all contexts
    by assigning values directly to the attribute representing the field of the record.
    It isn’t possible to assign a value to all recordset elements in one go, so, you
    need to iterate on the recordset, unless you are certain that you are only handling
    a single record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Option two is to use the `update()` method by passing dictionary mapping field
    names to the values you want to set. This also only works for recordsets with
    a length of `1`. It can save some typing when you need to update the values of
    several fields at once on the same record. Here’s *Step 2* of the tutorial, rewritten
    to use this option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Option three is to call the `write()` method, passing a dictionary that maps
    the field names to the values you want to set. This method works for recordsets
    of arbitrary size and will update all records with the specified values in one
    single database operation when the two previous options perform one database call
    per record and per field. However, it has some limitations: it does not work if
    the records are not yet present in the database (refer to the *Writing on change
    methods* tutorial in [*Chapter 8*](B20997_08.xhtml#_idTextAnchor388), *Advanced
    Server-Side Development Techniques*, for more information on this). Also, it requires
    a special format when writing relational fields, similar to the one used by the
    `create()` method. Check the following table for the format that’s used to generate
    different values for the relational fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Table 5.2 – Relational field update](img/B20997_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 5.2 – Relational field update
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `1`, `2`, `3`, and `5` operation types cannot be used with the `create()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching for records is also a common operation in business logic methods.
    There are many cases where we need to search the data based on different criteria.
    Finding the room by name and category is demonstrated in this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tutorial will use the same `hostel.room` definition as the *Creating new
    records* tutorial did previously. We will write the code in a method called `find_room(self)`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the rooms, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `find_room` method to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the search domain for your criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `search()` method with the domain, which will return the recordset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `rooms` variable will have a recordset of searched rooms. You can print
    or log that variable to see the result in the server log.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Step 1* defines the method name prefixed with the `def` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* creates a search domain in a local variable. Often, you’ll see this
    creation inline in the call to search, but with complex domains, it is good practice
    to define it separately.'
  prefs: []
  type: TYPE_NORMAL
- en: For a full explanation of the search domain syntax, refer to the *Defining filters
    on record lists – domain* tutorial in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* calls the `search()` method with the domain. The method returns a
    recordset that contains all the records that match the domain, which can then
    be processed further. In this tutorial, we call the method with just the domain,
    but the following keyword arguments are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`offset=N`: This is used to skip the first `N` records that match the query.
    This can be used along with `limit` to implement pagination or to reduce memory
    consumption when processing a very large number of records. It defaults to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit=N`: This indicates that, at most, `N` records should be returned. By
    default, there is no limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order=sort_specification`: This is used to force the order in the recordset
    returned. By default, the order is given by the `_order` attribute of the model
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count=boolean`: If `True`, this returns the number of records instead of the
    recordset. It defaults to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using the `search_count(domain)` method rather than`search(domain,
    count=True)`, as the name of the method conveys the behavior in a much clearer
    way. Both will give the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you need to search from another model so that searching for `self`
    will return a recordset of the current model. To search from another model, we
    need to get an empty recordset for the model. For example, let’s say we want to
    search for some contacts. To do that, we will need to use the `search()` method
    on the `res.partner` model. Refer to the following code. Here, we get the empty
    recordset of `res.partner` to search the contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have two conditions in the domain. You can omit the
    `'&'` from the domain when you have two conditions to compare, because when you
    do not specify the domain; then, Odoo will take `'&'` as a default.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said previously that the `search()` method returned all the records matching
    the domain. This is not actually completely true. The security rules ensure that
    the user only gets those records to which they have `read` access rights. Additionally,
    if the model has a `boolean` field called `active` and no term of the search domain
    specifies a condition on that field, then an implicit condition is added by search
    to only return `active=True` records. So, if you expect a search to return something,
    but you only get empty recordsets, ensure that you check the value of the `active`
    field (if present) to check for record rules.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Calling a method with a different context* tutorial in [*Chapter
    8*](B20997_08.xhtml#_idTextAnchor388), *Advanced Server-Side Development Techniques*,
    for a way to not have the implicit `active=True` condition added. Take a look
    at the *Limiting record access using record rules* tutorial in [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549),
    *Security Access*, for more information about record-level access rules.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you find yourself writing raw SQL queries to find record
    IDs, ensure that you use `self.env['record.model'].search([('id', 'in', tuple(ids))]).ids`
    after retrieving the IDs to ensure that security rules are applied. This is especially
    important in **multi-company** Odoo instances where the record rules are used
    to ensure proper discrimination between companies.
  prefs: []
  type: TYPE_NORMAL
- en: Combining recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you will find that you have obtained recordsets that are not exactly
    what you need. This tutorial shows various ways of combining them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use this tutorial, you need to have two or more recordsets for the same model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to perform common operations on recordsets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To merge two recordsets into one while preserving their order, use the following
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To merge two recordsets into one while ensuring that there are no duplicates
    in the result, use the following operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find the records that are common to two recordsets, use the following operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class for recordsets implements various Python operator redefinitions,
    which are used here. Here’s a summary table of the most useful Python operators
    that can be used on recordsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.3 – Operators used with the domain](img/Image96870.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 5.3 – Operators used with the domain
  prefs: []
  type: TYPE_NORMAL
- en: There are also in-place operators, `+=`, `-=`, `&=`, and `|=`, which modify
    the left-hand side operand instead of creating a new recordset. These are very
    useful when updating a record’s `One2many` or `Many2many` fields. Refer to the
    *Updating values of recordset records* tutorial for an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you already have a recordset, but you just need to work on a subset
    of those records. Of course, you may iterate over the recordset, checking for
    the condition each time and taking action in accordance with the outcome of the
    check. The construction of a new recordset comprising only the interesting records
    and the use of a single operation on that recordset can be simpler and, in certain
    situations, more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows you how to use the `filter()` method to extract a subset
    of recordsets based on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the simplified `hostel.room` model that was shown in the *Creating
    new records* tutorial. This tutorial defines a method to extract rooms that have
    multiple members from a supplied recordset.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To extract records that have multiple members from a recordset, you need to
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the method to filter the recordset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the method to accept the original recordset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an inner `predicate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `filter()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The outcome of this procedure can be printed or logged so that a server log
    can include it. For further information, see the tutorial’s sample code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recordset that is created by the `filter()` method’s implementation is empty.
    This blank recordset receives all the records that the predicate function evaluates
    to `True`. Finally, the fresh recordset is given back. Records in the original
    recordset are still in the same sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'A named internal function was used in the last tutorial. You will frequently
    see an anonymous Lambda function being utilized for such straightforward predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you need to filter a recordset based on the fact that the value of
    a field is *truthy* in the Python sense (non-empty strings, non-zero numbers,
    non-empty containers, and so on). So, if you want to filter records that have
    a category set, you can pass the field name to filter like this: `all_rooms.filter(''category_id'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that `filter()` uses memory to work. Use a search domain or even switch
    to SQL to improve the speed of a method on the critical route at the cost of readability.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing recordset relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with a recordset with a length of `1`, various fields are available
    as record attributes. Relational attributes (`One2many`, `Many2one`, and `Many2many`)
    are also available with values that are recordsets, too. As an example, let’s
    say we want to access the name of the category from the recordset of the `hostel.room`
    model. You can access the category name by traversing through the `Many2one` field’s
    `category_id` as follows: `room.category_id.name`. However, when working with
    recordsets with more than one record, the attributes cannot be used.'
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial demonstrates how to navigate recordset relations using the `mapped()`
    function. We’ll create a function to extract the members’ names from the list
    of rooms that are supplied as input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the `hostel.room` model that was shown in the *Creating new records*
    tutorial in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must do the following actions in order to retrieve the names of members
    from the room recordset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method called `get_members_names()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `mapped()` to get the name of the contacts of the member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply defining the method is *Step 1*. The fields of the recordset are traversed
    in *Step 2* by calling the `mapped(path)` function; `path` is a string that comprises
    field names separated by dots. The next element in the route is applied to the
    new recordset created by `mapped()` for each field in the path. This new recordset
    comprises all the records connected by that field to every element in the current
    recordset. A recordset is returned by `mapped()` if the final field in the route
    is a relational field; otherwise, a Python list is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapped()` method has two useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: When the route is a single scalar field name, the returned list is in the same
    chronological order as the recordset that was processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a relational field is present in the route, the result’s order is not retained,
    but duplicates are eliminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This second property is very useful when you want to perform an operation on
    all the records that are pointed to by a `Many2many` field for all the records
    in `self`, but you need to ensure that the action is performed only once (even
    if two records of `self`share the same target record).
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `mapped()`, keep in mind that it operates in memory inside the Odoo
    server by repeatedly traversing relations and therefore making SQL queries, which
    may not be efficient. However, the code is terse and expressive. If you are trying
    to optimize a method on the critical path of the performance of your instance,
    you may want to rewrite the call to `mapped()` and express it as `search()` with
    the appropriate domain, or even move to SQL (at the cost of readability).
  prefs: []
  type: TYPE_NORMAL
- en: The `mapped()` method can also be called with a function as an argument. In
    this case, it returns a list containing the result of the function that’s applied
    to each record of `self`, or the union of the recordsets that’s returned by the
    function, if the function returns a recordset.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Searching for records* tutorial in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Executing raw SQL queries* tutorial in [*Chapter 8*](B20997_08.xhtml#_idTextAnchor388),
    *Advanced Server-Side* *Development Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you fetch a recordset with the `search()` method, you can pass an optional
    argument order to get a recordset that’s in a particular order. This is useful
    if you already have a recordset from a previous bit of code and you want to sort
    it. It may also be useful if you use a set operation to combine two recordsets,
    for example, which would cause the order to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows you how to use the `sorted()` method to sort an existing
    recordset. We will sort rooms by rating.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the `hostel.room` model that was shown in the *Creating new records*
    tutorial in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to get the sorted recordset of rooms
    based on `rating`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method called `sort_rooms_by_rating()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `sorted()` method, as in the given example, to sort room records based
    on the `room_rating` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply defining the method is *Step 1*. In *Step 2*, we use the recordset of
    the rooms’ `sorted()` function. The field that is supplied as the key parameter
    will have its data fetched internally by the `sorted()` function. Then, it returns
    a `sorted` recordset using Python’s native sorted method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also has one optional argument, `reverse=True`, which returns a recordset
    in reverse order. `reverse` is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sorted()` method will sort the records in a recordset. Called without arguments,
    the `_order` attribute of the model will be used. Otherwise, a function can be
    passed to compute a comparison key in the same way as the Python built-in sorted
    (sequence, key) function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When the default `_order` parameter of the model is used, the sorting is delegated
    to the database, and a new `SELECT` function is performed to get the order. Otherwise,
    the sorting is performed by Odoo. Depending on what is being manipulated, and
    depending on the size of the recordsets, there might be some important performance
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the business logic defined in a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dividing application functionalities into various modules is a popular practice
    in Odoo. You may easily accomplish this by installing or uninstalling the application,
    which will enable or disable functionalities. Furthermore, you must modify the
    behavior of some methods that were predefined in the original app when you add
    new features to it. An old model could occasionally benefit from the addition
    of fresh fields. This is one of the most useful functions of the underlying framework
    and the process is quite simple in Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we will see how you can extend the business logic of one method
    from the method in another module. Additionally, we will use the new module to
    add new fields to an existing module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this tutorial, we will continue to use the `my_hostel` module from the last
    tutorial. Make sure that you have the `hostel.room.category` model in the `my_hostel`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial, we will create a new module called `my_hostel_terminate`,
    which depends on the `my_ hostel` module. In this module, we will manage termination
    dates from the hostel. We will also automatically calculate the withdrawal date
    based on the category.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *How to add features to a model using inheritance* tutorial in [*Chapter
    4*](B20997_04.xhtml#_idTextAnchor118), *Application Models*, we saw how to add
    a field to the existing model. In this module, extend the `hostel.room` model
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, extend the `hostel.room.category` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To add this field in views, you need to follow the *Changing existing views
    – view inheritance* tutorial from [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*. You can find a full example of the code at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To extend the business logic in the `hostel.room` model, you need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From `my_hostel_terminate`, we want to set `date_terminate` in the `rooms`
    record when we change the room status to `Closed`. For this, we will override
    the `make_closed` method from the `my_` `hostel_terminate` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to reset `date_terminate` when the room is returned and available
    to borrow, so we will override the `make_available` method to reset the date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Steps 1* and *2*, in the preceding section, carry out the extension of the
    business logic. We define a model that extends `hostel.room` and redefines the
    `make_closed()` and `make_available()` methods. In the last line of both methods,
    the result that was implemented by the parent class is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the case of Odoo models, the parent class is not what you’d expect by looking
    at the Python class definition. The framework has dynamically generated a class
    hierarchy for our recordset, and the parent class is the definition of the model
    from the modules that we depend on. So, the call to `super()` brings back the
    implementation of `hostel.room` from `my_hostel`. In this implementation, `make_closed()`
    changes the state of the room to `Closed`. So, calling `super()` will invoke the
    parent method and it will set the room state to `Closed`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we choose to extend the default implementation of the methods.
    In the `make_closed()` and `make_available()` methods, we modified the returned
    result *before* the `super()` call. Note that, when you call `super()`, it will
    execute the default implementation. It is also possible to perform some actions
    *after* the `super()` call. Of course, we can also do both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: To alter a method’s behavior in the midst, though, is more challenging. To do
    this, we must restructure the code in order to extract an extension point to a
    different function, which we can then override in the extension module.
  prefs: []
  type: TYPE_NORMAL
- en: You might be inspired to rewrite a function from scratch. Always proceed with
    extreme caution. The extension mechanism and maybe the add-ons that extend the
    method are broken if you do not use the `super()` implementation of your method,
    which means that the extension methods will never be invoked. Avoid doing this
    unless you are working in a controlled environment where you are certain which
    add-ons are installed and you have verified that you are not breaking them. Additionally,
    if necessary, make sure to clearly document everything you do.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can you do before and after calling the original implementation of the
    method? There are lots of things, including (but not limited to) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the arguments that are sent to the initial implementation (in the past)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter the context that was previously provided to the original implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the outcome that the initial implementation returned (after)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call another method (before and after)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create records (before and after)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise a `UserError` error to cancel the execution in forbidden cases (before
    and after)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split `self` into smaller recordsets and call the original implementation on
    each of the subsets in a different way (before)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending write() and create()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending the business logic defined in a model tutorial from this chapter showed
    us how to extend methods that are defined on a model class. If you think about
    it, methods that are defined on the parent class of the model are also part of
    the model. This means that all the base methods that are defined on `models.Model`
    (actually, on `models.BaseModel`, which is the parent class of `models.Model`)
    are also available and can be extended.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows you how to extend `create()` and `write()` to control access
    to some fields of the records.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will extend the library example from the `my_hostel` add-on module in [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo* *Add-On Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `remarks` field to the `hostel.room` model. We only want members of the
    `Hostel Managers` group to be able to write to that field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `remarks` field to the `<form>` view of the `view/hostel_room.xml`
    file to access this field from the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `security/ir.model.access.csv` file to give write access to library
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent users who are not members of the manager group from modifying the
    value of `remarks`, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the `create()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the `write()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install the module to see the code in action. Now, only a manager type of user
    can modify the `remarks` field. To test this implementation, you can log in as
    a demo user or revoke manager access from the current user.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Step 1* in the preceding section redefines the `create()` method. Before calling
    the base implementation of `create()`, our method uses the `user_has_groups()`
    method to check whether the user belongs to the `my_hostel.group_hostel_manager`
    group (this is the XML ID of the group). If this is not the case and a value is
    passed for `remarks`, a `UserError` exception is raised, preventing the creation
    of the record. This check is performed before the base implementation is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* does the same thing for the `write()` method. Prior to writing, we
    check the group and the presence of the field in the values so we can write and
    raise a `UserError` exception if there is a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Having the field set to read only in the web client does not prevent RPC calls
    from writing it. This is why we extend `create()` and `write()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this tutorial, you have seen how you can override the `create()` and `write()`
    methods. However, note that this is not limited to the `create()` and `write()`
    methods. You can override any model method. For example, let’s say you want to
    do something when the record is deleted. To do so, you need to override the `unlink()`
    method (the `unlink()` method will be called when the record is deleted). Here
    is the small code snippet to override the `unlink()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When extending `write()`, note that, before calling the `super()` implementation
    of `write()`, `self` is still unmodified. You can use this to compare the current
    values of the fields to the ones in the `values` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this tutorial, we chose to raise an exception, but we could have also chosen
    to remove the offending field from the `values` dictionary and silently skipped
    updating that field in the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling `super().write()`, if you want to perform additional actions,
    you have to be wary of anything that can cause another call to `write()`, or you
    will create an infinite recursion loop. The workaround is to put a marker in the
    context that will be checked to break the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have added the `MyModelLoopBreaker` key before
    calling the `compute_things()` method. So, if the `write()` method is called again,
    it doesn’t go in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing how records are searched
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Defining the model representation and order* tutorial in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, introduced the `name_get()` method, which is used
    to compute a representation of the record in various places, including in the
    widget that’s used to display `Many2one` relations in the web client.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial will show you how to search for a room in the `Many2one` widget
    by room number and name by redefining `name_search`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this tutorial, we will use the following model definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When using this model, a room in a `Many2one` widget is displayed as `name_search`
    only uses the attribute referred to by the `_rec_name` attribute of the model
    class, which, in our case, is `'name'`. We also want to allow filtering by room
    number.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following steps in order to execute this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to search for `hostel.room` either by the room’s name, one of the
    members, or the room number, you need to define the `_name_search()` method in
    the `HostelRoom` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `previous_room_id` `Many2one` field in the `hostel.room` model to test
    the `_name_search` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following field to the user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart and update the module to reflect these changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can invoke the `_name_search` method by searching in the `previous_room_id`
    `Many2one` field.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default implementation of `name_search()` actually only calls the `_name_search()`
    method, which does the real job. This `_name_search()` method has an additional
    argument, `name_get_uid`, which is used in some corner cases such as if you want
    to compute the results using `sudo()` or with a different user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass most of the arguments that we receive unchanged to the `super()` implementation
    of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is a string that contains the value the user has typed so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args` is either `None` or a search domain that’s used as a prefilter for the
    possible records. (It can come from the domain parameter of the `Many2one` relation,
    for instance.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator` is a string containing the match operator. Generally, you will have
    `''ilike''` or `''=''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit` is the maximum number of rows to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name_get_uid` can be used to specify a different user when calling `name_get()`
    to compute the strings to display in the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our implementation of the method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It generates a new empty list if `args` is `None`, and makes a copy of `args`
    otherwise. We make a copy to avoid our modifications to the list having side effects
    on the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we check that `name` is not an empty string or that `operator` is not
    `'ilike'`. This is to avoid generating a dumb domain, such as `[('name', ilike,
    '')]`, that doesn’t filter anything. In this case, we jump straight to the `super()`
    call implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have `name`, or if `operator` is not `'ilike'`, then we add some filtering
    criteria to `args`. In our case, we add clauses that will search for the supplied
    name in the title of the rooms, in their room number, or the members’ names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `super()` implementation with the modified domain in `args`
    and force `name` to be `''` and `operator` to be `ilike`. We do this to force
    the default implementation of `_name_search()` to not alter the domain it receives,
    so, the one we specified will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We mentioned in the introduction that this method is used in the `Many2one`
    widget. For completeness, it is also used in the following parts of Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: When using the `in` operator on the `One2many` and `Many2many` fields in the
    domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To search for records in the `many2many_tags` widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To search for records in the CSV file import
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Defining the model representation and order* tutorial in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, demonstrates how to define the `name_get()` method,
    which is used to create a text representation of a record.
  prefs: []
  type: TYPE_NORMAL
- en: The *Defining filters on record lists – domain* tutorial in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*, provides more information about search domain syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data in groups using read_group()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous tutorials, we saw how we can search and fetch data from the
    database. However, sometimes, you want results by aggregating records, such as
    the average cost of last month’s sales order. Usually, we use `group by` and the
    `aggregate` function in SQL queries for such a result. Luckily, in Odoo, we have
    the `read_group()` method. In this tutorial, you will learn how to use the `read_group()`
    method to get the aggregate result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we will use the `my_hostel` add-on module from [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo* *Add-On Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `hostel.room` model, as shown in the following model definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `hostel.room.category` model. For simplicity, we will just add it to
    the same `hostel_room.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the `hostel.room` model and getting an average cost price per
    category.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To extract grouped results, we will add the `_get_average_cost` method to the
    `hostel.room` model, which will use the `read_group()` method to fetch the data
    in a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To test this implementation, you need to add a button to the user interface
    that triggers this method. Then, you can print the result in the server log.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `read_group()` method internally uses the SQL `groupby` and `aggregate`
    functions to fetch the data. The most common arguments that are passed to the
    `read_group()` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`domain`: This is used to filter records for grouping. For more information
    on `domain`, refer to the *Searching views* tutorial in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This passes the names of fields you want to fetch with the grouped
    data. Possible values for this argument are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field name`: You can pass the field name into the `fields` argument, but if
    you are using this option, then you must pass this field name to the `groupby`
    parameter too, otherwise it will generate an error.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field_name:agg`: You can pass the field name with the `aggregate` function.
    For example, in `cost_price:avg`, `avg` is an SQL aggregate function. A list of
    PostgreSQL aggregate functions can be found at [https://www.postgresql.org/docs/current/static/functions-aggregate.html](https://www.postgresql.org/docs/current/static/functions-aggregate.html).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name:agg(field_name)`: This is the same as the previous one, but, with this
    syntax, you can provide column aliases, such as `average_price:avg(cost_price)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupby`: This argument accepts a list of field descriptions. Records will
    be grouped based on these fields. For the `date` and `datetime` column, you can
    pass `groupby_function` to apply date groupings based on different time durations.
    You can do grouping based on months for date type fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_group()` also supports some optional arguments, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: This indicates an optional number of records to skip.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This indicates an optional maximum number of records to return.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderby`: If this option is passed, the result will be sorted based on the
    given fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazy`: This accepts Boolean values and, by default, is `True`. If `True` is
    passed, the results are only grouped by the first `groupby`, and the remaining
    `groupby` arguments are put in the `__context` key. If `False`, all `groupby`
    functions are done in one call.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tip
  prefs: []
  type: TYPE_NORMAL
- en: '`read_group()` is a lot faster than reading and processing values from a recordset.
    So, for KPIs or graphs, you should always use `read_group()`.'
  prefs: []
  type: TYPE_NORMAL
