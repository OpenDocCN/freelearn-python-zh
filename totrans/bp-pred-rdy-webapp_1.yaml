- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Setting Up Our System for Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开发设置我们的系统
- en: 'The aim of this book is to provide a blueprint for a web app running in a production
    environment and utilizing as many industrial best practices as possible. To do
    this, we will build a working to-do app, codenamed Tozo, that allows users to
    track a list of tasks. You can see the finished app in *Figure 1.1*:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是提供一个在生产环境中运行的 Web 应用程序的蓝图，并尽可能多地利用工业最佳实践。为此，我们将构建一个可工作的待办事项应用程序，代号为 Tozo，允许用户跟踪任务列表。您可以在*图
    1.1*中看到完成的应用程序：
- en: '![Figure 1.1: The to-do app we’ll build in this book](img/B18727_01_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：本书中将构建的待办事项应用](img/B18727_01_01.jpg)'
- en: 'Figure 1.1: The to-do app we’ll build in this book'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：本书中将构建的待办事项应用
- en: While the aim is to build a working to-do app, we’ll focus on features that
    are useful to any app, with much of the functionality and many of the techniques
    being the same as in the app built here. For example, users will need to log in,
    change their password, and so on. Therefore, my hope is that you can take this
    blueprint, remove the small amount of specific to-do code, and build your own
    app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目标是构建一个可工作的待办事项应用程序，但我们将关注对任何应用程序都实用的功能，其中许多功能和许多技术都与这里构建的应用程序相同。例如，用户需要登录、更改密码等。因此，我的希望是您能够使用这个蓝图，移除少量特定的待办事项代码，并构建您自己的应用程序。
- en: In this chapter, we will take a new machine without any tooling and set it up
    for development. We’ll also set up systems to develop and test the app automatically.
    Specifically, we’ll install a system package manager and use it to install the
    various language runtimes and tooling before setting up a remote repository and
    activating continuous integration. By the end of this chapter, you’ll have everything
    you need to be able to focus solely on developing the app. This means that you
    will be able to quickly build and test the features you need in your app for your
    users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从一个没有任何工具的新机器开始，为开发设置它。我们还将设置系统来自动开发和测试应用程序。具体来说，我们将安装一个系统包管理器，并使用它来安装各种语言运行时和工具，然后在设置远程仓库和激活持续集成之前。到本章结束时，您将拥有开发应用程序所需的一切，这意味着您将能够专注于开发应用程序。这意味着您将能够快速构建和测试您应用程序中用户所需的功能。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Aiming for fast development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在快速开发
- en: Setting up our system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的系统
- en: Installing Python for backend development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后端开发安装 Python
- en: Installing NodeJS for frontend development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为前端开发安装 NodeJS
- en: Installing Terraform for infrastructure development
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基础设施开发安装 Terraform
- en: Installing PostgreSQL for database development
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据库开发安装 PostgreSQL
- en: Adopting a collaborative development process using GitHub
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用基于 GitHub 的协作开发流程
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'I’ve built the app described in this book and you can use it by visiting the
    following link: [https://tozo.dev](https://tozo.dev). The code is also available
    at [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo) (feel free
    to use that code or the code in this book under the MIT license).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经构建了本书中描述的应用程序，您可以通过以下链接访问它：[https://tozo.dev](https://tozo.dev)。代码也可在[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)找到（请随意使用该代码或本书中的代码，MIT
    许可证下使用）。
- en: I’m going to assume you have a working knowledge of TypeScript and Python, as
    these are the languages we’ll use to write the app. However, we’re going to avoid
    any esoteric language features and I hope the code is easily understandable. I’m
    also going to assume you are happy using the command line, rather than focusing
    on GUI instructions, as most tooling is optimized for command-line usage, and
    this is something that should be advantageous.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设您对 TypeScript 和 Python 有一定的了解，因为我们将使用这些语言来编写应用程序。然而，我们将避免使用任何晦涩难懂的语言特性，并希望代码易于理解。我还将假设您乐于使用命令行，而不是专注于图形用户界面指令，因为大多数工具都针对命令行使用进行了优化，这应该是有利的。
- en: To follow the development in this chapter, use the companion repository at [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)
    and see the commits between the `r1-ch1-start` and `r1-ch1-end` tags.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的开发，请使用配套仓库[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)，并查看`r1-ch1-start`和`r1-ch1-end`标签之间的提交。
- en: Aiming for fast development
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旨在快速开发
- en: Before we start setting up our system to build the to-do app, it’s important
    to understand what we are aiming for when building any app, which is to solve
    our customer’s needs by shipping solutions as quickly as possible. This means
    that we must understand their needs, translate them into working code, and crucially,
    deploy the solution with confidence that it works as expected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设置构建待办事项应用程序的系统之前，了解我们在构建任何应用程序时的目标是很重要的，即通过尽可能快地交付解决方案来解决客户的需求。这意味着我们必须了解他们的需求，将它们转化为可工作的代码，并且至关重要，有信心地部署解决方案。
- en: When we are developing an app, the shorter the time between making a change
    to the code and being able to run and see the effect of the change, the better.
    This is why we will run all of the code locally, with auto-reloading enabled;
    this should mean that any change we make is testable in our local browser within
    a few seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发一个应用程序时，代码更改与能够运行并看到更改效果之间的时间越短，越好。这就是为什么我们将所有代码本地运行，并启用自动重新加载；这意味着我们做出的任何更改都可以在几秒钟内通过本地浏览器进行测试。
- en: Hot/auto-reloading
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 热重载/自动重新加载
- en: In development, we ideally want any changes we make to the code to take effect
    immediately so that we can check that the changes have the desired effect. This
    feature is called hot or auto-reloading and is active with the React and Quart
    development servers we are using in this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们理想情况下希望我们对代码所做的任何更改都能立即生效，以便我们可以检查这些更改是否产生了预期的效果。这个功能被称为热重载或自动重新加载，并且在我们这本书中使用的React和Quart开发服务器中是激活的。
- en: I also like to use tooling to help speed up development and gain confidence
    that the code works as expected. This tooling should run as frequently as possible,
    ideally as part of an automated process. I have split this tooling into auto-formatting,
    linting, and testing categories.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我还喜欢使用工具来帮助加快开发速度并增强代码按预期工作的信心。这些工具应该尽可能频繁地运行，理想情况下作为自动化过程的一部分。我已经将这些工具分为自动格式化、代码检查和测试类别。
- en: Auto-formatting the code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码自动格式化
- en: The format and style of code matter as a different style to the one you are
    used to will take longer for you to understand. This will mean more bugs as you
    spend more of your time comprehending the style rather than logic. Also, while
    you can be consistent, almost everyone has a different preferred style, and I’ve
    found that these preferences change over time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的格式和风格很重要，因为与您习惯的风格不同，您需要更长的时间来理解。这意味着您将花费更多的时间来理解风格而不是逻辑，这将导致更多的错误。此外，虽然您可以保持一致，但几乎每个人都有不同的首选风格，我发现这些偏好会随着时间的推移而改变。
- en: In the past, I’ve used tooling to check the styling and report on any inconsistencies.
    This is helpful but wasteful as every inconsistency must be fixed manually. Fortunately,
    most languages now have an official, or dominant, **auto-formatter** that both
    defines a style and changes all of the code to match it. Using the most popular
    auto-formatter means that most developers will recognize your code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我使用工具来检查样式并报告任何不一致性。这很有帮助，但也很浪费，因为每个不一致性都必须手动修复。幸运的是，现在大多数语言都有官方的或占主导地位的**自动格式化工具**，它既定义了风格，又将所有代码更改为匹配该风格。使用最流行的自动格式化工具意味着大多数开发人员都会认识你的代码。
- en: We’ll aim to set up our tooling so that there are auto-formatters for as much
    of the code as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是设置我们的工具，以便尽可能多的代码都有自动格式化工具。
- en: Linting the code
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码检查
- en: 'I think of **linting** in two parts: type checking and static analysis. Type
    checking requires that we include types when writing the code. I use type hinting,
    or typed languages, where possible, as this catches a large number of the errors
    I typically make. Typing also helps document the code, meaning that it makes it
    clear what objects (types) are expected. While typing costs more effort to write,
    I think it easily pays off in bugs avoided. Therefore, checking the typing should
    be our first aim of linting.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为代码检查可以分为两部分：类型检查和静态分析。类型检查要求我们在编写代码时包含类型。我尽可能使用类型提示或类型化语言，因为这可以捕捉到我通常犯的大量错误。类型化还有助于记录代码，这意味着它清楚地说明了预期的对象（类型）。虽然类型化在编写时需要更多的努力，但我认为它很容易在避免错误方面得到回报。因此，检查类型应该是我们代码检查的第一个目标。
- en: The second part, static analysis, allows linters to look for potential issues
    in naming, usage of functions, possible bugs, security issues, and unused code,
    and to flag code that is too complex or poorly constructed. These linters are
    a very low-cost sanity check as they are quick and easy to run and give few false
    issues (positives).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分，静态分析，允许代码检查器查找命名、函数使用、可能的错误、安全问题以及未使用代码中的潜在问题，并标记过于复杂或构建不良的代码。这些代码检查器是一种非常低成本的理智检查，因为它们运行快速且简单，并且很少出现误报（假阳性）。
- en: Testing the code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码
- en: While linting will identify bugs and issues with the code, it cannot detect
    logical issues where correctly written code does the wrong thing. To identify
    these, we need to write tests that check that the execution of the code results
    in the expected output. Therefore, it is important that we write tests as we write
    the code, especially when we discover bugs. We will focus on writing tests that
    provide an easy way to test that the app works as expected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码检查器可以识别代码中的错误和问题，但它无法检测到逻辑问题，即正确编写的代码却做了错误的事情。为了识别这些问题，我们需要编写测试来检查代码的执行结果是否产生预期的输出。因此，我们在编写代码时编写测试非常重要，尤其是在我们发现错误时。我们将专注于编写提供简单测试应用程序是否按预期工作的测试。
- en: Test coverage
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: Test coverage is used to measure how much of the code has been tested by the
    test suite. This is typically done by measuring the ratio of lines executed by
    the tests to the total lines of code. I find this metric unhelpful as it focuses
    on lines executed rather than use cases that matter to the user. Therefore, I’d
    encourage you to focus on testing the use cases you think your users require.
    However, if you’d like to measure coverage this way, you can install `pytest-cov`
    using `pdm`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率用于衡量测试套件测试了多少代码。这通常是通过测量测试执行的代码行数与总代码行数的比率来完成的。我发现这个指标没有帮助，因为它关注的是执行的行数，而不是对用户有意义的用例。因此，我鼓励您关注测试您认为用户需要的用例。然而，如果您想以这种方式测量覆盖率，您可以使用
    `pdm` 安装 `pytest-cov`。
- en: Using auto-formatters, linters, and a testing suite allows us to develop with
    greater confidence and therefore speed, which in turn means a better experience
    for our users. However, in order to use these tools, we will first need to set
    up our system effectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动格式化工具、代码检查器和测试套件，我们可以更有信心地开发，从而提高开发速度，这反过来意味着为我们的用户提供更好的体验。然而，为了使用这些工具，我们首先需要有效地设置我们的系统。
- en: Setting up our system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的系统
- en: To effectively develop our app, we will need to be able to develop and run it.
    This means we will need tooling to manage changes to the code, test and check
    the app for errors, and run it. This tooling can be installed via a system package
    manager, of which there are many choices depending on your operating system. I
    recommend that you install Homebrew on Linux (https://linuxbrew.sh) and macOS
    (https://brew.sh), or Scoop ([https://scoop.sh](https://scoop.sh)) on Windows.
    I’ll show both `brew` and `scoop` commands in this book, but you should only use
    the command that works on your operating system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地开发我们的应用程序，我们需要能够开发和运行它。这意味着我们需要工具来管理代码更改、测试和检查应用程序的错误以及运行它。这些工具可以通过系统包管理器安装，具体取决于您的操作系统。我建议您在
    Linux (https://linuxbrew.sh) 和 macOS (https://brew.sh) 上安装 Homebrew，或在 Windows
    上安装 Scoop ([https://scoop.sh](https://scoop.sh))。在这本书中，我将展示 `brew` 和 `scoop` 命令，但您应该只使用适用于您操作系统的命令。
- en: You will also need a code editor to write the code in and a browser to run the
    app. I recommend that you install VS Code ([https://code.visualstudio.com](https://code.visualstudio.com))
    and Chrome ([https://www.google.com/chrome](https://www.google.com/chrome)) via
    the directions given on their websites. With these tools installed, we can now
    consider how we’ll manage the code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个代码编辑器来编写代码，以及一个浏览器来运行应用程序。我建议您按照他们网站上的说明安装 VS Code ([https://code.visualstudio.com](https://code.visualstudio.com))
    和 Chrome ([https://www.google.com/chrome](https://www.google.com/chrome))。安装了这些工具后，我们现在可以考虑如何管理代码。
- en: Managing the code
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理代码
- en: 'As we develop our app, we will inevitably make mistakes and want to return
    to the previous working version. You may also want to share the code with others,
    or just keep a backup for yourself. This is why we need to manage the code via
    a **version control** system. While there are many different version control systems,
    the majority in this industry use git ([https://git-scm.com](https://git-scm.com)).
    It can be installed via the system package manager as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发应用程序的过程中，我们不可避免地会犯错误并希望回到之前的工作版本。你也可能希望与他人共享代码，或者只是为自己保留一个备份。这就是为什么我们需要通过**版本控制系统**来管理代码。虽然有许多不同的版本控制系统，但这个行业的大多数都使用git
    ([https://git-scm.com](https://git-scm.com))。可以通过以下方式通过系统包管理器安装：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using git
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用git
- en: This book can be completed using `git add` to add files to the repository, `git
    commit` to create commits, and `git push` to update the remote repository. I consider
    these to be the basic git commands. However, git can still be very confusing to
    use, and you may end up with your repository in a mess. It does get easier with
    practice and there is plenty of help online. You can always delete your local
    repository and start again from the remote version (as I have done many times
    before).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书可以通过使用`git add`将文件添加到仓库，`git commit`创建提交，以及`git push`更新远程仓库来完成。我认为这些是基本的git命令。然而，git的使用仍然可能非常复杂，你可能会发现你的仓库处于混乱状态。随着实践的增加，这会变得更容易，而且网上有大量的帮助。你总是可以删除你的本地仓库，并从远程版本重新开始（就像我以前多次做的那样）。
- en: 'Now we have git installed, let’s set the author information as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了git，让我们设置以下作者信息：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted values should be changed to your name and email address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将高亮显示的值更改为你的姓名和电子邮件地址。
- en: 'Next, we can create a repository for our code by creating a directory called
    *tozo* and running the following command within it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在名为*tozo*的目录中创建一个代码仓库，并在其中运行以下命令：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will create a *.git* directory that can be safely ignored. This results
    in the following project structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个可以安全忽略的*.git*目录。这导致以下项目结构：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we develop, we will want git to ignore certain files and paths. We will do
    this by creating *.gitignore* files that list the filenames and file paths that
    we do not want to be part of our repository.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们可能希望git忽略某些文件和路径。我们将通过创建列出我们不希望包含在仓库中的文件名和文件路径的*.gitignore*文件来实现这一点。
- en: Writing good commits
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的提交信息
- en: The history of changes stored by git can serve as an excellent companion document
    for your code if git is used well. This is something that won’t seem advantageous
    at the start, but after a year of development, it will be something you’ll sorely
    miss if you hadn’t done it from the beginning. So, I strongly recommend you write
    good commits.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Git存储的变更历史如果使用得当，可以成为你代码的优秀伴侣文档。这可能在开始时看起来没有优势，但经过一年的开发后，如果你没有从一开始就做这件事，你会非常怀念它。因此，我强烈建议你编写良好的提交信息。
- en: A good commit contains a single atomic change to the code. This means it is
    focused (doesn’t combine different changes into one commit) and that it is complete
    (every commit leaves the code working).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的提交包含对代码的单个原子更改。这意味着它是集中的（不会将不同的更改组合到一个提交中）并且是完整的（每个提交都使代码处于工作状态）。
- en: A good commit is also well described and reasoned. This means the commit message
    explains why the change has been made. This contextual information is invaluable
    as it will be forgotten quickly and is often required to understand the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的提交信息也是经过良好描述和推理的。这意味着提交信息解释了为什么进行更改。这种上下文信息非常有价值，因为它很快就会被遗忘，并且通常需要理解代码。
- en: With git installed, we can start committing changes; however, we should establish
    how we intend to combine changes, which, in my opinion, should be done by rebasing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了git之后，我们可以开始提交更改；然而，我们应该确定我们打算如何合并更改，在我看来，这应该通过变基来完成。
- en: Rebasing rather than merging
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相比合并，使用变基
- en: 'As I put a lot of value on the git commit history, I recommend using rebases
    rather than merges when combining changes. The former will move local new commits
    on top of any remote changes, rewriting and leaving a linear clear history, whereas
    the latter will introduce a merge commit. To make this change, run the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我非常重视git提交历史，我建议在合并更改时使用变基而不是合并。前者会将本地新提交放在任何远程更改之上，重写并留下一个线性清晰的历史记录，而后者将引入一个合并提交。要执行此更改，请运行以下代码：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve now set up our system with a package manager and version control. Next,
    we can install the specific tooling we need for the various aspects of the app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用包管理器和版本控制设置了我们的系统。接下来，我们可以安装应用程序各个方面的特定工具。
- en: Installing Python for backend development
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Python 用于后端开发
- en: There are a variety of languages that are suitable for backend development,
    and any would be a fine choice for your app. In this book, I’ve chosen to use
    Python as I find that the code is more accessible and easier to follow than other
    languages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多适合后端开发的编程语言，任何一种都是你应用程序的一个很好的选择。在这本书中，我选择使用 Python，因为我发现与其他语言相比，Python 的代码更易于理解和跟踪。
- en: 'As we will be writing the backend for our app in **Python**, we will need to
    have it installed locally. While you may have a Python version already installed,
    I’d recommend you use the one installed by the system package manager, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 **Python** 编写应用程序的后端，因此我们需要在本地安装它。虽然你可能已经安装了 Python 版本，但我建议你使用系统包管理器安装的版本，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The package manager we’ve used so far doesn’t know how to install and manage
    Python packages, so we also need another package manager. There are many choices
    in Python, and I think PDM is the best. PDM can be installed with the system package
    manager on Linux and macOS systems, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的包管理器不知道如何安装和管理 Python 包，因此我们还需要另一个包管理器。Python 中有很多选择，我认为 PDM 是最好的。PDM
    可以在 Linux 和 macOS 系统上使用系统包管理器进行安装，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For Windows systems, it can be installed by running the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，可以通过运行以下命令进行安装：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ll keep the backend code separate in a backend folder, so please create
    a *backend* folder at the top level of the project with the following folder structure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把后端代码保存在一个单独的后端文件夹中，所以请在项目的顶层创建一个 *backend* 文件夹，并按照以下文件夹结构进行组织：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to inform git that there are files that we don’t want to be tracked
    in the repository and hence it should ignore them by adding the following to *backend/.gitignore*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通知 git 有一些我们不希望在存储库中跟踪的文件，因此它应该通过添加以下内容到 *backend/.gitignore* 来忽略它们：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For PDM to manage our project, we need to run the following command in the
    *backend* directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 PDM 管理我们的项目，我们需要在 *backend* 目录中运行以下命令：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When prompted, you should choose the Python version installed using the system
    package manager earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，你应该选择之前使用系统包管理器安装的 Python 版本。
- en: We can now focus on the specific Python tooling for fast development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以专注于特定于 Python 的快速开发工具。
- en: Formatting the code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化代码
- en: 'Python does not have an official format or formatter; however, `black` is the
    de facto formatter for code and `isort` is the de facto formatter for imports.
    We can add both to our project by running the following command in the *backend*
    directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有官方的格式或格式化器；然而，`black` 是代码的事实上的格式化器，`isort` 是导入的事实上的格式化器。我们可以通过在 *backend*
    目录中运行以下命令将两者添加到我们的项目中：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The dev flag
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 开发标志
- en: We use the `--dev` flag here as these tools are only required for developing
    the backend and therefore do not need to be installed when running in production.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `--dev` 标志，因为这些工具仅用于后端开发，因此不需要在生产环境中安装。
- en: '`black` and `isort` require the following configuration to work well together.
    This should be added to the end of the *backend/pyproject.toml* file (you may
    have to change the `target-version` if you are using a version of Python other
    than 3.10) as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`black` 和 `isort` 需要以下配置才能良好地协同工作。这应该添加到 *backend/pyproject.toml* 文件末尾（如果你使用的是除
    3.10 之外版本的 Python，你可能需要更改 `target-version`），如下所示：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following commands will run `black` and `isort` on our code in the *src*
    and *tests* folders:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在 *src* 和 *tests* 文件夹中的我们的代码上运行 `black` 和 `isort`：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll be using Jinja templates for emails sent by our app. While these templates
    are code, they are not Python and hence require a different formatter. Thankfully,
    `djhtml` can be used to format the templates and is added by running the following
    command in the *backend* folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jinja 模板来处理我们应用程序发送的电子邮件。虽然这些模板是代码，但它们不是 Python，因此需要不同的格式化器。幸运的是，`djhtml`
    可以用来格式化模板，并且可以通过在 *backend* 文件夹中运行以下命令来添加：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command will run `djhtml` on our template code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们的模板代码上运行 `djhtml`：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve now installed the tooling we need to format the code in the backend. Next,
    we can install the tooling we need to lint the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了格式化后端代码所需的工具。接下来，我们可以安装用于代码检查所需的工具。
- en: Linting the code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对代码进行代码检查
- en: 'Python supports type hints that describe the expected types of variables, functions,
    and so on. We’ll use type hints and tooling to check that we haven’t introduced
    any type-related bugs. The most popular type checking tool for Python is `mypy`.
    It is installed by running the following command in the *backend* directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持类型提示，用于描述变量、函数等的预期类型。我们将使用类型提示和工具来检查我们没有引入任何类型相关的错误。Python最受欢迎的类型检查工具是`mypy`。可以在`*backend*`目录下运行以下命令来安装：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following command will run `mypy` over the backend code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在后端代码上运行`mypy`：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With `mypy` helping us find type errors, we can add `Flake8` to help us find
    other bugs. `Flake8` is installed with `pdm` as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mypy`帮助我们查找类型错误的同时，我们可以添加`Flake8`来帮助我们查找其他错误。`Flake8`可以通过以下方式使用`pdm`安装：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Flake8` must be configured to work with `black` and `mypy` by adding the following
    to *backend/setup.cfg*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flake8`必须配置为与`black`和`mypy`一起工作，通过在`*backend/setup.cfg*`中添加以下内容：'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Flake8` is used by running the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flake8`可以通过运行以下命令来使用：'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is another type of bug that we can use tooling to help us find, and these
    are related to security. A good example would be checking for a SQL injection
    vulnerability. Bandit is another linter that helps identify these bugs, and it
    is installed by running the following command in the *backend* directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用工具来帮助我们发现另一种类型的错误，这些错误与安全相关。一个很好的例子是检查SQL注入漏洞。Bandit是另一个可以帮助识别这些错误的linter，并且可以在`*backend*`目录下运行以下命令来安装：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bandit only needs to lint the `src` code as the test code does not run during
    production. To run Bandit over the `src` code, the following command is used:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit只需要对`src`代码进行lint，因为在生产期间不会运行测试代码。要运行Bandit对`src`代码进行lint，可以使用以下命令：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bandit ModuleNotFoundErrors
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit模块未找到错误
- en: 'Bandit may fail to run with the error `ModuleNotFoundError: No module named
    ‘pkg_resources’`. If this happens, then run `pdm add --dev setuptools` to add
    the missing module.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '如果Bandit运行失败并出现错误`ModuleNotFoundError: No module named ‘pkg_resources’`，则运行`pdm
    add --dev setuptools`以添加缺失的模块。'
- en: 'We now have tooling looking for bugs, but we can also add tooling to look for
    unused code. This is helpful as code can often be forgotten during refactoring,
    leaving files that are much more complex to read and understand than they should
    be. I like to use `vulture` to find unused code, and it is installed by running
    the following command in the *backend* directory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了查找错误的工具，但我们也可以添加工具来查找未使用的代码。这很有帮助，因为在重构过程中，代码往往会被遗忘，导致文件比应有的复杂得多，难以阅读和理解。我喜欢使用`vulture`来查找未使用的代码，并且可以在`*backend*`目录下运行以下命令来安装：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unfortunately, `vulture` can report false positives, so I like to configure
    it to be 100% confident when reporting issues by adding the following configuration
    to *backend/pyproject.toml*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`vulture`可能会报告误报，所以我喜欢通过在`*backend/pyproject.toml*`中添加以下配置来配置它，以确保报告问题时100%有信心：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Like Bandit, it is best to run `vulture` over the `src` code only (not the
    tests) via the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与Bandit一样，最好只通过以下命令在`src`代码上运行`vulture`（而不是测试）：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s look at what we need to test the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们需要测试代码的内容。
- en: Testing the code
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'Python has `unittest` as part of its standard library, however, I think using
    `pytest` is superior. `pytest` is very feature-rich and allows for very simple
    and clear tests, such as the following small example that tests that a simple
    addition is correct:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`unittest`是其标准库的一部分，然而，我认为使用`pytest`更好。`pytest`功能丰富，允许编写非常简单和清晰的测试，例如以下小型示例，它测试简单的加法是否正确：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`pytest` requires the `pytest-asyncio` plugin to test async code, and they
    are both installed with `pdm` as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`需要`pytest-asyncio`插件来测试异步代码，并且它们都可以通过以下方式使用`pdm`安装：'
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`pytest` is best configured to show local variables on test failure as this
    makes it much easier to understand why the test is failing. In addition, the `asyncio`
    mode should be set to `auto` to make writing async tests easier. The following
    configuration should be placed in *backend/pyproject.toml*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`最好配置为在测试失败时显示局部变量，因为这使理解测试失败的原因变得容易得多。此外，`asyncio`模式应设置为`auto`，以便更容易编写异步测试。以下配置应放置在`*backend/pyproject.toml*`中：'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To run the tests, `pytest` is invoked with the `tests` path as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，可以使用以下命令调用`pytest`，指定`tests`路径：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we’ve installed all of the tooling, we need some simple commands to
    run it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有工具，我们需要一些简单的命令来运行它们。
- en: Scripting the commands
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本命令
- en: 'We’ve added a lot of useful tooling to our project; however, each one had a
    different unique command that we’d have to remember. This is something we can
    simplify by making use of PDM’s scripting feature as it can be used to map PDM
    commands to the required commands. We will add the following three PDM scripting
    commands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的项目中添加了许多有用的工具；然而，每个工具都有不同的独特命令，我们不得不记住。我们可以通过利用PDM的脚本功能来简化这一点，因为它可以将PDM命令映射到所需的命令。我们将添加以下三个PDM脚本命令：
- en: '`pdm run format` to run the formatting tooling and format the code'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdm run format`来运行格式化工具并格式化代码'
- en: '`pdm run lint` to run the linting tooling and lint the code'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdm run lint`来运行linting工具并检查代码'
- en: '`pdm run test` to run the tests'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdm run test`来运行测试'
- en: 'PDM’s scripting requires these script commands to be added to the *backend/pyproject.toml*
    file as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PDM的脚本需要将这些脚本命令添加到*backend/pyproject.toml*文件中，如下所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the backend tooling in place and accessible via easy-to-remember commands,
    we can now do the same for the frontend.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端工具就绪且可通过易于记忆的命令访问后，我们现在可以为前端做同样的事情。
- en: Installing NodeJS for frontend development
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装NodeJS进行前端开发
- en: As we want our app to run in the browser, we will need to write the frontend
    in JavaScript or a language that compiles to it. There are many good choices,
    but I’ve chosen to use **TypeScript** as it is JavaScript with the addition of
    typing (as in, it is the same basic language). This means it is close to the required
    runtime language and has the additional safety and documentation from the typing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的应用程序在浏览器中运行，我们需要用JavaScript或编译成它的语言编写前端。有很多好的选择，但我选择使用**TypeScript**，因为它是在JavaScript的基础上增加了类型（即，它是同一种基本语言）。这意味着它与所需的运行时语言非常接近，并且具有来自类型的安全性和文档。
- en: 'As we will be writing the frontend in TypeScript, we will need **NodeJS** installed
    to compile TypeScript to the JavaScript that will run in the browser. NodeJS is
    best installed with the system package manager as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用TypeScript编写前端，我们需要安装**NodeJS**来编译TypeScript到在浏览器中运行的JavaScript。NodeJS最好通过系统包管理器安装，如下所示：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unlike Python, where we installed a specific package manager, NodeJS comes with
    one called `npm`. We’ll use `npm` to manage the frontend dependencies and tooling.
    `npm` also includes the `npx` tool that we will use to run one-off scripts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，我们安装了特定的包管理器，NodeJS自带了一个名为`npm`的包管理器。我们将使用`npm`来管理前端依赖和工具。`npm`还包括`npx`工具，我们将用它来运行一次性脚本。
- en: 'As with the backend, we’ll separate the frontend code into a frontend folder.
    Then, we’ll use the `create-react-app` tool in this new folder to set everything
    up by running the following command in the project directory:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端一样，我们将前端代码分离到一个前端文件夹中。然后，我们将在这个新文件夹中使用`create-react-app`工具，通过在项目目录中运行以下命令来设置一切：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It should give the following folder structure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该给出以下文件夹结构：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of the files also installed, only the *frontend/package.json*, *frontend/package-lock.json*,
    *frontend/tsconfig.json*, *frontend/.gitignore*, *frontend/src/react-app-env.d.ts*,
    and *frontend/public/index.xhtml* files matter at the moment, so you can delete
    or adapt the other files as you’d like.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装的文件中，目前只有*frontend/package.json*、*frontend/package-lock.json*、*frontend/tsconfig.json*、*frontend/.gitignore*、*frontend/src/react-app-env.d.ts*和*frontend/public/index.xhtml*文件是重要的，因此您可以删除或根据需要修改其他文件。
- en: We can now focus on the specific NodeJS tooling for fast development.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于特定的NodeJS工具，以实现快速开发。
- en: Formatting the code
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化代码
- en: 'TypeScript does not have an official format/formatter; however, Prettier is
    the de facto formatter. We should add it to the project as a development dependency
    by running the following command in the *frontend* directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript没有官方的格式/格式化工具；然而，Prettier是事实上的格式化工具。我们应该通过在*frontend*目录中运行以下命令将Prettier添加到项目中作为开发依赖项：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The --save-dev flag
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: --save-dev标志
- en: We use the `--save-dev` flag here as these tools are only required to develop
    the frontend, and therefore do not need to be installed when running in production.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`--save-dev`标志，因为这些工具仅用于开发前端，因此不需要在生产环境中安装。
- en: 'By default, Prettier does not add trailing commas, which is different from
    the style used in Python. To be consistent and therefore not have to think about
    this, Prettier can be configured by adding the following section to *frontend/package.json*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Prettier不会添加尾随逗号，这与Python中使用的样式不同。为了保持一致，因此不必考虑这一点，可以在*frontend/package.json*中添加以下部分进行配置：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following command will then run Prettier over our code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下命令将运行Prettier来处理我们的代码：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We’ve now installed the tooling to format the code and we can focus on the tooling
    to lint it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了格式化代码的工具，我们可以专注于安装检查代码的工具。
- en: Linting the code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码
- en: 'In the preceding section, we required a linter to type check our Python code,
    however, as we are using TypeScript, we do not need to install anything extra
    to type check. However, we can install linters to check for other bugs; the de
    facto linter for TypeScript and JavaScript is `eslint`, which is installed by
    running the following command in the *frontend* directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们需要一个代码检查器来检查我们的Python代码，然而，由于我们使用TypeScript，我们不需要安装任何额外的工具来进行类型检查。但是，我们可以安装代码检查器来检查其他错误；TypeScript和JavaScript的事实上的代码检查器是`eslint`，我们可以在*前端*目录中运行以下命令来安装它：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By default, `eslint` is not compatible with Prettier; fortunately, the `eslint-config-prettier`
    package configures `eslint` to be compatible. It is installed by running the following
    command in the *frontend* directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`eslint`与Prettier不兼容；幸运的是，`eslint-config-prettier`包配置了`eslint`以实现兼容。我们可以在*前端*目录中运行以下命令来安装它：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with the backend, we should order our imports using `eslint-plugin-import`,
    which is installed with `npm` as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端一样，我们应该使用`eslint-plugin-import`来排序我们的导入，该插件是通过以下方式与`npm`一起安装的：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These linters are then configured by replacing the existing `eslintConfig`
    section with the following in *frontend/package.json*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码检查器通过在*frontend/package.json*中用以下内容替换现有的`eslintConfig`部分来进行配置：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The highlighted lines will already be present.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行将已经存在。
- en: '`eslint` can be run over our code via the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令在我们的代码上运行`eslint`：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`eslint` can also fix some of the issues it identifies via the use of the `--fix`
    flag as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`eslint`也可以通过使用`--fix`标志来修复它识别的一些问题，如下所示：'
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve now installed the tooling to lint the code and we can focus on the tooling
    to test it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了代码检查工具，我们可以专注于测试工具。
- en: Testing the code
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'The `create-react-app` tool used earlier also installed a test runner called
    Jest, which we can invoke by running the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的`create-react-app`工具还安装了一个名为Jest的测试运行器，我们可以通过运行以下命令来调用它：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Jest allows for tests to be written using an `expect` syntax, as shown in the
    following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Jest允许使用`expect`语法编写测试，如下面的示例所示：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the testing tooling present, we can focus on analyzing the built bundle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试工具存在的情况下，我们可以专注于分析构建的包。
- en: Analyzing the bundle
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析包
- en: 'The frontend code will be delivered as bundles (in chunks) to the user. These
    bundles, especially the main bundle, should be small so that the user isn’t waiting
    too long for the code to be downloaded. To check the bundle size and analyze what
    is included in each bundle, I use `source-map-explorer`, which is installed by
    running the following command in the *frontend* directory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前端代码将以包（块）的形式交付给用户。这些包，尤其是主包，应该尽可能小，这样用户就不会等待太长时间下载代码。为了检查包大小并分析每个包中包含的内容，我在*前端*目录中运行以下命令使用`source-map-explorer`：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we can analyze the bundle sizes, we first need to build them by running
    the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够分析包大小之前，我们首先需要通过运行以下命令来构建它们：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we can analyze them via this command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过以下命令来分析它们：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output from the preceding command is shown in *Figure 1.2*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在*图1.2*中：
- en: '![Figure 1.2: The output from source-map-explorer showing that the main bundle
    is 141 KB ](img/Figure_1.2_NEW.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：source-map-explorer的输出显示主包为141 KB](img/Figure_1.2_NEW.jpg)'
- en: 'Figure 1.2: The output from source-map-explorer showing that the main bundle
    is 141 KB'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：source-map-explorer的输出显示主包为141 KB
- en: Each bundle should be as small as possible, with a good rule of thumb being
    that bundles should be split when the bundle exceeds 1 MB. We’ll find that we
    need to do this when we add a password complexity analyzer to the frontend in
    [*Chapter 4*](B18727_04.xhtml#_idTextAnchor111), *Creating a Reusable Frontend
    with React*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都应该尽可能小，一个很好的经验法则是当包超过1 MB时应该进行拆分。当我们将在*第4章*中添加密码复杂度分析器到前端时，我们会发现我们需要这样做，*使用React创建可重用前端*。
- en: Scripting the commands
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写命令脚本
- en: 'To match the backend, we want to add the following commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与后端匹配，我们想要添加以下命令：
- en: '`npm run analyze` to run the bundle analyzer'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`npm run analyze`来运行包分析器
- en: '`npm run format` to run the formatting tooling and format the code'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`npm run format`来运行格式化工具并格式化代码
- en: '`npm run lint` to run the linting tooling'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`npm run lint`来运行代码检查工具
- en: '`npm run test` to run the tests'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`npm run test`来运行测试
- en: 'As `npm run test` is already present, we only need to add the other three.
    This is done by adding the following to the `scripts` section in *frontend/package.json*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `npm run test` 已经存在，我们只需要添加其他三个。这可以通过在 *frontend/package.json* 文件的 `scripts`
    部分添加以下内容来完成：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The highlighted lines will already be present in the section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行将已经存在于该部分中。
- en: With the frontend tooling in place and accessible via the easy-to-remember commands,
    we can now do the same for the infrastructure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端工具就绪并可通过易于记忆的命令访问后，我们现在可以为基础设施做同样的事情。
- en: Installing Terraform for infrastructure development
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Terraform进行基础设施开发
- en: We’ll need to create and manage remote infrastructure, starting with a remote
    repository that we will use to develop the app with other developers or to simply
    backup our code. This remote infrastructure could be created manually, for example,
    using GitHub’s web interface. However, by using an Infrastructure as a Code tool,
    we can record all of the changes we make, and then if anything goes wrong, we
    can rerun our code and restore everything to a known state.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建和管理远程基础设施，从我们将用于与其他开发者一起开发应用程序或简单地备份我们的代码的远程仓库开始。这个远程基础设施可以通过手动创建，例如使用GitHub的Web界面。然而，通过使用基础设施即代码工具，我们可以记录我们所做的所有更改，然后如果出现问题，我们可以重新运行我们的代码并将一切恢复到已知状态。
- en: 'I find **Terraform** to be the best tool to manage infrastructure, which we
    can install as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 **Terraform** 是管理基础设施的最佳工具，我们可以按照以下方式安装：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With Terraform installed, we can create a folder within our repository for
    the infrastructure code as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Terraform后，我们可以在我们的仓库中创建一个用于基础设施代码的文件夹，如下所示：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our repository should now have the following structure:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目仓库现在应该具有以下结构：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As with the backend and frontend, we’ll need to install tooling to help development.
    In addition, for the infrastructure, we’ll need tooling to manage secrets.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端和前端一样，我们需要安装工具来帮助开发。此外，对于基础设施，我们还需要工具来管理机密。
- en: Managing secrets
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理机密
- en: To allow Terraform to manage our infrastructure, we will need to provide passwords,
    keys, and other secrets. These secrets will need to be stored (and used) in a
    secure fashion – simply storing passwords in plain text in the repository is a
    common way to be hacked. We will instead encrypt the secrets and store the encrypted
    file in the repository. This means we’ll have to keep the encryption key secret,
    which I recommend you do by using a password manager such as BitWarden.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许Terraform管理我们的基础设施，我们需要提供密码、密钥和其他机密信息。这些机密信息需要以安全的方式存储（并使用）——简单地在仓库中以纯文本形式存储密码是常见的被黑客攻击的方式。我们将加密这些机密信息并将加密文件存储在仓库中。这意味着我们必须保密加密密钥，我建议您使用像BitWarden这样的密码管理器来做到这一点。
- en: 'To encrypt the secrets, we can use `ansible-vault`, which is installed using
    the Python package manager, `pip`, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密机密信息，我们可以使用 `ansible-vault`，它是通过Python包管理器 `pip` 安装的，如下所示：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: pip or PDM
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: pip或PDM
- en: pip is a tool for installing packages, whereas PDM is a project management tool.
    As we don’t have an infrastructure project to manage, it makes more sense to use
    pip to install `ansible-vault`. However, this is the only time we’ll directly
    use pip.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 是安装包的工具，而PDM是项目管理工具。由于我们没有基础设施项目要管理，使用pip安装 `ansible-vault` 更有意义。然而，这将是唯一一次我们直接使用pip。'
- en: 'To configure `ansible-vault`, we need to provide the encryption key. To do
    so, add your encryption key to *infrastructure/.ansible-vault* and inform Ansible
    that it is stored there by adding the following to *infrastructure/ansible.cfg*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 `ansible-vault`，我们需要提供加密密钥。为此，将您的加密密钥添加到 *infrastructure/.ansible-vault*
    文件中，并通过在 *infrastructure/ansible.cfg* 文件中添加以下内容来通知Ansible它已存储在那里：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We’ll need to encrypt two files: Terraform’s state, `terraform.tfstate`, and
    our collection of secret variables, `secrets.auto.tfvars`. The commands to do
    so are the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加密两个文件：Terraform的状态文件 `terraform.tfstate` 和我们的机密变量集合 `secrets.auto.tfvars`。执行此操作的命令如下：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will also need to decrypt these files, which is done via the following commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解密这些文件，可以通过以下命令完成：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To ensure that the password file, encrypted files, and general Terraform autogenerated
    files aren’t considered part of the repository, the following should be added
    to *infrastructure/.gitignore*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保密码文件、加密文件以及Terraform自动生成的通用文件不被视为仓库的一部分，应该在 *infrastructure/.gitignore*
    文件中添加以下内容：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Terraform is now set up and ready to use, which means we can focus on the development
    tooling.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform现在已设置好并准备好使用，这意味着我们可以专注于开发工具。
- en: Formatting, linting, and testing the code
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化、代码检查和测试代码
- en: 'Terraform comes with a built-in formatter, which is invoked via the following
    command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 内置了一个格式化工具，可以通过以下命令调用：
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This formatter also supports a check mode to use when linting, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式化工具还支持在代码检查时使用的检查模式，如下所示：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Terraform also comes with a tool to lint your code, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 还提供了一个用于代码检查的工具，如下所示：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Testing Terraform code is harder as almost all of the code depends on an interaction
    with a third-party service. Instead, I find running and checking that the output
    makes sense to be the only way to test what the code will do. Terraform will provide
    an output of what it plans to do by running the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Terraform 代码比较困难，因为几乎所有代码都依赖于与第三方服务的交互。相反，我发现运行并检查输出是否有意义是测试代码将做什么的唯一方法。Terraform
    将通过运行以下命令提供它计划执行的操作的输出：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is all we need to install and set up to manage all of the infrastructure
    we’ll install in this book. We can now focus on the database.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要安装和设置来管理本书中将要安装的所有基础设施的全部内容。我们现在可以专注于数据库。
- en: Installing PostgreSQL for database development
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PostgreSQL 用于数据库开发
- en: Our app will need to store data (the to-dos) in a structured form, which makes
    a database an ideal choice. This database will need to be running locally to allow
    us to develop with it, so we need to install it. The database I prefer is **PostgreSQL**,
    which is a SQL-based relational database. I prefer it as it is very widely supported,
    and very powerful.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要以结构化形式存储数据（待办事项），这使得数据库成为一个理想的选择。此数据库需要在本地上运行，以便我们可以与之一起开发，因此我们需要安装它。我首选的数据库是
    **PostgreSQL**，这是一个基于 SQL 的关系型数据库。我之所以喜欢它，是因为它非常广泛地受到支持，并且非常强大。
- en: 'PostgreSQL is installed using the system package manager as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 是通过以下方式使用系统包管理器安装的：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If using `brew`, you will likely need to start `postgresql` as a service that
    runs in the background, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `brew`，你可能需要将 `postgresql` 作为在后台运行的服务启动，如下所示：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In addition, when using `brew`, we need to create a superuser, which by convention
    is called *postgres*. This user is created with the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用 `brew` 时，我们需要创建一个超级用户，按照惯例称为 *postgres*。此用户是通过以下命令创建的：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, with `scoop`, you will have to start the PostgreSQL database whenever
    you wish to use it with the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `scoop`，你将需要使用以下命令在需要使用 PostgreSQL 时启动数据库：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With the addition of the database tooling, we have all of the local tooling
    we need to develop our app. This means we can focus on the remote tooling, a GitHub
    repository.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据库工具的添加，我们拥有了所有本地工具来开发我们的应用程序。这意味着我们可以专注于远程工具，即 GitHub 仓库。
- en: "Adopting a collaborative development process \Lusing GitHub"
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub 采用协作开发流程
- en: While you may be working on your own, it is good practice to adopt a development
    process that allows others to collaborate and one that ensures that the code is
    always ready to be deployed to production. We will achieve both aims by using
    a remote repository and **Continuous Integration** (**CI**).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能正在独立工作，但采用允许他人协作并确保代码始终准备好部署到生产环境的发展流程是一种良好的做法。我们将通过使用远程仓库和**持续集成**（**CI**）来实现这两个目标。
- en: A remote repository acts as a backup for all your code and makes it much easier
    to set up CI (testing, linting, and so on). We’ll use GitHub as I find it to have
    all the features needed, although other platforms, such as GitLab, are also valid
    and commonly used in the industry.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 远程仓库充当所有代码的备份，并使得设置 CI（测试、代码检查等）变得容易得多。我们将使用 GitHub，因为它拥有我需要的所有功能，尽管其他平台，如 GitLab，也是有效的，并且在行业中广泛使用。
- en: 'Rather than creating the repository through GitHub’s UI, we’ll use Terraform
    as set up earlier. To do so, we’ll first need a personal access token from GitHub,
    as explained at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).
    The token will need the `repo`, `workflow`, and `delete_repo` scopes. This token
    is a secret and hence best placed in *infrastructure/secrets.auto.tfvars* and
    encrypted as described earlier in the *Managing secrets* section. The code should
    be placed into *infrastructure/secrets.auto.tfvars* as follows (replace `abc1234`
    with your token):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过 GitHub 的 UI 创建存储库，而是使用之前设置的 Terraform。为此，我们首先需要一个来自 GitHub 的个人访问令牌，如[https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)中所述。此令牌需要
    `repo`、`workflow` 和 `delete_repo` 权限。此令牌是秘密的，因此最好放在 *infrastructure/secrets.auto.tfvars*
    中，并按照之前在 *管理秘密* 部分中描述的方式加密。代码应按以下方式放置到 *infrastructure/secrets.auto.tfvars* 中（将
    `abc1234` 替换为您的令牌）：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Terraform itself does not know how to interact with GitHub, which means that
    we need to install the GitHub provider to do so. This is done by adding the following
    code to *infrastructure/main.tf*:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 本身不知道如何与 GitHub 交互，这意味着我们需要安装 GitHub 提供程序来完成此操作。这是通过将以下代码添加到 *infrastructure/main.tf*
    来完成的：
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With the provider present, we can describe the repository we would like to
    exist by adding the following code to *infrastructure/github.tf*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序存在后，我们可以通过添加以下代码到 *infrastructure/github.tf* 来描述我们希望存在的存储库：
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, to actually create the repository, we need to initialize and apply
    Terraform as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了实际创建存储库，我们需要初始化并应用 Terraform，如下所示：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We should now set up `git` so that it knows about the remote repository. To
    do this, we’ll need the correct path, which will depend on your GitHub account
    name and the name of your project. As my GitHub account name is *pgjones* and
    this project is called *tozo*, the path is *pgjones/tozo*, making the following
    command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该设置 `git`，使其了解远程存储库。为此，我们需要正确的路径，这取决于您的 GitHub 账户名称和项目名称。由于我的 GitHub 账户名称是
    *pgjones* 且项目名称为 *tozo*，路径是 *pgjones/tozo*，因此以下命令：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To have our local branch track the remote `origin` `main` branch, run the following
    command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的本地分支跟踪远程 `origin` `main` 分支，请运行以下命令：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To push our local changes on our `main` branch to the remote `feature` branch,
    run the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的 `main` 分支上的本地更改推送到远程 `feature` 分支，请运行以下命令：
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To pull the remote `main` branch to update our local branch, run the following
    command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要将远程`main`分支拉取以更新我们的本地分支，请运行以下命令：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Most in this industry operate a development workflow based on merge (pull)
    requests, which we’ll also adopt. This workflow consists of the following steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行业中的大多数都运行基于合并（拉取）请求的开发工作流程，我们也将采用。此工作流程包括以下步骤：
- en: Develop a feature locally consisting of as few commits as makes sense (small
    changes).
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地开发一个由尽可能少的提交组成的功能（小的更改）。
- en: Push the feature to a remote `feature` branch.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将功能推送到远程 `feature` 分支。
- en: Open a merge request based on that branch.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于该分支打开合并请求。
- en: Review the merge request, merging it to the `main` branch only if CI passes.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查合并请求，只有 CI 通过时才将其合并到 `main` 分支。
- en: Pull the latest `main` branch and repeat.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取最新的`main`分支并重复。
- en: With the repository created, we can now look at adding CI.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库创建后，我们现在可以查看添加 CI。
- en: Adding continuous integration
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加持续集成
- en: 'GitHub provides a CI system called Actions that has a free tier, which we’ll
    use. To start, we need to create the following folder structure:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 提供了一个名为 Actions 的 CI 系统，它有一个免费层，我们将使用它。首先，我们需要创建以下文件夹结构：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can configure a workflow that runs jobs on every change to the `main`
    branch and every merge request by adding the following code to *.github/workflows/ci.yml*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以配置一个工作流程，在 `main` 分支的每次更改和每个合并请求上运行作业，通过将以下代码添加到 *.github/workflows/ci.yml*：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This allows us to add jobs for the infrastructure, backend, and frontend.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够为基础设施、后端和前端添加工作。
- en: Adding CI for the infrastructure code
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为基础设施代码添加 CI
- en: 'We previously set up the commands to format and lint the infrastructure code
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前设置了以下命令来格式化和检查基础设施代码：
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To have these run as part of CI, we need to add the following job to the *.github/workflows/ci.yml*
    file within the `jobs` section:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些操作作为 CI 的一部分运行，我们需要将以下作业添加到 *.github/workflows/ci.yml* 文件中的 `jobs` 部分：
- en: '[PRE76]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can now add a job for the backend code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为后端代码添加一个任务。
- en: Adding CI for the backend code
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为后端代码添加持续集成
- en: 'We previously set up the commands to format, lint, and test the backend code
    as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经设置了以下命令来格式化、检查和测试后端代码：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To have these run as part of CI, we will need to have a database service running
    as well, as the tests run against the database. Fortunately, GitHub supports PostgreSQL
    database services by running a PostgreSQL database alongside the CI job. We can
    make use of this database service and run the commands by adding the following
    job to the `jobs` section in *.github/workflows/ci.yml*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些作为持续集成的一部分运行，我们还需要运行一个数据库服务，因为测试是针对数据库运行的。幸运的是，GitHub通过在持续集成作业旁边运行PostgreSQL数据库来支持PostgreSQL数据库服务。我们可以利用这个数据库服务，并通过在*.github/workflows/ci.yml*中的`jobs`部分添加以下作业来运行命令：
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can now add a job for the frontend code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为前端代码添加一个任务。
- en: Adding CI for the frontend code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为前端代码添加持续集成
- en: 'We previously set up the commands to format, lint, test, and build the frontend
    code as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经设置了以下命令来格式化、检查、测试和构建前端代码：
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can make use of the service and run the commands by adding the following
    job to the `jobs` section of *.github/workflows/ci.yml*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在*.github/workflows/ci.yml*的`jobs`部分添加以下作业来利用该服务并运行命令：
- en: '[PRE80]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We now have everything we need in place to start developing our app. The folder
    structure at this stage is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始开发我们的应用。在这个阶段，文件夹结构如下：
- en: '[PRE81]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We now have all of our checks running on every change to the `main` branch and
    for every pull request. This should ensure that our code remains at a high quality
    and alert us to any issues that may otherwise be missed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的检查都在每次更改`main`分支和每个拉取请求时运行。这应该确保我们的代码保持高质量，并提醒我们可能被忽视的任何问题。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up all of the tooling we need to develop our app. We
    started by installing a system package manager, which we then used to install
    and set up git. With git, we created our local repository and started to commit
    code. We installed Python, NodeJS, Terraform, and the tooling required to format,
    lint, and test the code. Finally, we used Terraform to create and set up a remote
    GitHub repository with working CI, ensuring that our code is automatically checked
    on every change.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了开发我们应用所需的所有工具。我们首先安装了一个系统包管理器，然后使用它来安装和设置git。使用git，我们创建了我们的本地仓库并开始提交代码。我们安装了Python、NodeJS、Terraform以及格式化、检查和测试代码所需的工具。最后，我们使用Terraform创建并设置了一个带有工作持续集成的远程GitHub仓库，确保我们的代码在每次更改时都会自动检查。
- en: The tooling we’ve installed in this chapter is required to develop the app described
    in the following chapters. It will also allow you to do so quickly, as the tooling
    will help you quickly identify issues and errors with the code.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中安装的工具是开发以下章节中描述的应用所必需的。它还将使您能够快速完成这些工作，因为工具将帮助您快速识别代码中的问题和错误。
- en: In the next chapter, we’ll start developing the backend of our app, with the
    focus being on setting up the app framework and extensions that support the features
    we want, for example, authentication.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始开发我们应用的后端，重点是设置应用框架和扩展，以支持我们想要的功能，例如身份验证。
- en: Further reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: It is often useful to switch versions of Python and NodeJS to test the app before
    upgrading it. To do this, I’d recommend `pyenv` (https://github.com/pyenv/pyenv)
    and `n` (https://github.com/tj/n) for Python and NodeJS, respectively.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级应用之前，切换Python和NodeJS的版本以测试应用通常很有用。为此，我推荐使用`pyenv`（https://github.com/pyenv/pyenv）和`n`（https://github.com/tj/n）来分别测试Python和NodeJS。
- en: Part 2 Building a To-Do App
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分 构建待办事项应用
- en: Now, we will build a fully functional to-do tracking application using Quart
    and React. The app will include many common features, such as authentication,
    user management, styled pages, and forms.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Quart和React构建一个功能齐全的待办事项跟踪应用。该应用将包括许多常见功能，如身份验证、用户管理、样式化页面和表单。
- en: 'This part consists of the following chapters:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 2*](B18727_02.xhtml#_idTextAnchor053), *Creating a Reusable Backend
    with Quart*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第2章*](B18727_02.xhtml#_idTextAnchor053)，*使用Quart创建可重用后端*'
- en: '[*Chapter 3*](B18727_03.xhtml#_idTextAnchor076), *Building the API*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B18727_03.xhtml#_idTextAnchor076)，*构建API*'
- en: '[*Chapter 4*](B18727_04.xhtml#_idTextAnchor111), *Creating a Reusable Frontend
    with React*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18727_04.xhtml#_idTextAnchor111)，*使用React创建可重用前端* '
- en: '[*Chapter 5*](B18727_05.xhtml#_idTextAnchor138), *Building the Single-Page
    App*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18727_05.xhtml#_idTextAnchor138)，*构建单页应用*'
