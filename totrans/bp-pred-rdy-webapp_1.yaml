- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Our System for Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of this book is to provide a blueprint for a web app running in a production
    environment and utilizing as many industrial best practices as possible. To do
    this, we will build a working to-do app, codenamed Tozo, that allows users to
    track a list of tasks. You can see the finished app in *Figure 1.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The to-do app we’ll build in this book](img/B18727_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The to-do app we’ll build in this book'
  prefs: []
  type: TYPE_NORMAL
- en: While the aim is to build a working to-do app, we’ll focus on features that
    are useful to any app, with much of the functionality and many of the techniques
    being the same as in the app built here. For example, users will need to log in,
    change their password, and so on. Therefore, my hope is that you can take this
    blueprint, remove the small amount of specific to-do code, and build your own
    app.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a new machine without any tooling and set it up
    for development. We’ll also set up systems to develop and test the app automatically.
    Specifically, we’ll install a system package manager and use it to install the
    various language runtimes and tooling before setting up a remote repository and
    activating continuous integration. By the end of this chapter, you’ll have everything
    you need to be able to focus solely on developing the app. This means that you
    will be able to quickly build and test the features you need in your app for your
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Aiming for fast development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python for backend development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing NodeJS for frontend development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Terraform for infrastructure development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PostgreSQL for database development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting a collaborative development process using GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve built the app described in this book and you can use it by visiting the
    following link: [https://tozo.dev](https://tozo.dev). The code is also available
    at [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo) (feel free
    to use that code or the code in this book under the MIT license).'
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to assume you have a working knowledge of TypeScript and Python, as
    these are the languages we’ll use to write the app. However, we’re going to avoid
    any esoteric language features and I hope the code is easily understandable. I’m
    also going to assume you are happy using the command line, rather than focusing
    on GUI instructions, as most tooling is optimized for command-line usage, and
    this is something that should be advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the development in this chapter, use the companion repository at [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)
    and see the commits between the `r1-ch1-start` and `r1-ch1-end` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Aiming for fast development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start setting up our system to build the to-do app, it’s important
    to understand what we are aiming for when building any app, which is to solve
    our customer’s needs by shipping solutions as quickly as possible. This means
    that we must understand their needs, translate them into working code, and crucially,
    deploy the solution with confidence that it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: When we are developing an app, the shorter the time between making a change
    to the code and being able to run and see the effect of the change, the better.
    This is why we will run all of the code locally, with auto-reloading enabled;
    this should mean that any change we make is testable in our local browser within
    a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Hot/auto-reloading
  prefs: []
  type: TYPE_NORMAL
- en: In development, we ideally want any changes we make to the code to take effect
    immediately so that we can check that the changes have the desired effect. This
    feature is called hot or auto-reloading and is active with the React and Quart
    development servers we are using in this book.
  prefs: []
  type: TYPE_NORMAL
- en: I also like to use tooling to help speed up development and gain confidence
    that the code works as expected. This tooling should run as frequently as possible,
    ideally as part of an automated process. I have split this tooling into auto-formatting,
    linting, and testing categories.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-formatting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format and style of code matter as a different style to the one you are
    used to will take longer for you to understand. This will mean more bugs as you
    spend more of your time comprehending the style rather than logic. Also, while
    you can be consistent, almost everyone has a different preferred style, and I’ve
    found that these preferences change over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, I’ve used tooling to check the styling and report on any inconsistencies.
    This is helpful but wasteful as every inconsistency must be fixed manually. Fortunately,
    most languages now have an official, or dominant, **auto-formatter** that both
    defines a style and changes all of the code to match it. Using the most popular
    auto-formatter means that most developers will recognize your code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll aim to set up our tooling so that there are auto-formatters for as much
    of the code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Linting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I think of **linting** in two parts: type checking and static analysis. Type
    checking requires that we include types when writing the code. I use type hinting,
    or typed languages, where possible, as this catches a large number of the errors
    I typically make. Typing also helps document the code, meaning that it makes it
    clear what objects (types) are expected. While typing costs more effort to write,
    I think it easily pays off in bugs avoided. Therefore, checking the typing should
    be our first aim of linting.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part, static analysis, allows linters to look for potential issues
    in naming, usage of functions, possible bugs, security issues, and unused code,
    and to flag code that is too complex or poorly constructed. These linters are
    a very low-cost sanity check as they are quick and easy to run and give few false
    issues (positives).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While linting will identify bugs and issues with the code, it cannot detect
    logical issues where correctly written code does the wrong thing. To identify
    these, we need to write tests that check that the execution of the code results
    in the expected output. Therefore, it is important that we write tests as we write
    the code, especially when we discover bugs. We will focus on writing tests that
    provide an easy way to test that the app works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage is used to measure how much of the code has been tested by the
    test suite. This is typically done by measuring the ratio of lines executed by
    the tests to the total lines of code. I find this metric unhelpful as it focuses
    on lines executed rather than use cases that matter to the user. Therefore, I’d
    encourage you to focus on testing the use cases you think your users require.
    However, if you’d like to measure coverage this way, you can install `pytest-cov`
    using `pdm`.
  prefs: []
  type: TYPE_NORMAL
- en: Using auto-formatters, linters, and a testing suite allows us to develop with
    greater confidence and therefore speed, which in turn means a better experience
    for our users. However, in order to use these tools, we will first need to set
    up our system effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively develop our app, we will need to be able to develop and run it.
    This means we will need tooling to manage changes to the code, test and check
    the app for errors, and run it. This tooling can be installed via a system package
    manager, of which there are many choices depending on your operating system. I
    recommend that you install Homebrew on Linux (https://linuxbrew.sh) and macOS
    (https://brew.sh), or Scoop ([https://scoop.sh](https://scoop.sh)) on Windows.
    I’ll show both `brew` and `scoop` commands in this book, but you should only use
    the command that works on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a code editor to write the code in and a browser to run the
    app. I recommend that you install VS Code ([https://code.visualstudio.com](https://code.visualstudio.com))
    and Chrome ([https://www.google.com/chrome](https://www.google.com/chrome)) via
    the directions given on their websites. With these tools installed, we can now
    consider how we’ll manage the code.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we develop our app, we will inevitably make mistakes and want to return
    to the previous working version. You may also want to share the code with others,
    or just keep a backup for yourself. This is why we need to manage the code via
    a **version control** system. While there are many different version control systems,
    the majority in this industry use git ([https://git-scm.com](https://git-scm.com)).
    It can be installed via the system package manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using git
  prefs: []
  type: TYPE_NORMAL
- en: This book can be completed using `git add` to add files to the repository, `git
    commit` to create commits, and `git push` to update the remote repository. I consider
    these to be the basic git commands. However, git can still be very confusing to
    use, and you may end up with your repository in a mess. It does get easier with
    practice and there is plenty of help online. You can always delete your local
    repository and start again from the remote version (as I have done many times
    before).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have git installed, let’s set the author information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted values should be changed to your name and email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can create a repository for our code by creating a directory called
    *tozo* and running the following command within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a *.git* directory that can be safely ignored. This results
    in the following project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we develop, we will want git to ignore certain files and paths. We will do
    this by creating *.gitignore* files that list the filenames and file paths that
    we do not want to be part of our repository.
  prefs: []
  type: TYPE_NORMAL
- en: Writing good commits
  prefs: []
  type: TYPE_NORMAL
- en: The history of changes stored by git can serve as an excellent companion document
    for your code if git is used well. This is something that won’t seem advantageous
    at the start, but after a year of development, it will be something you’ll sorely
    miss if you hadn’t done it from the beginning. So, I strongly recommend you write
    good commits.
  prefs: []
  type: TYPE_NORMAL
- en: A good commit contains a single atomic change to the code. This means it is
    focused (doesn’t combine different changes into one commit) and that it is complete
    (every commit leaves the code working).
  prefs: []
  type: TYPE_NORMAL
- en: A good commit is also well described and reasoned. This means the commit message
    explains why the change has been made. This contextual information is invaluable
    as it will be forgotten quickly and is often required to understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: With git installed, we can start committing changes; however, we should establish
    how we intend to combine changes, which, in my opinion, should be done by rebasing.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing rather than merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I put a lot of value on the git commit history, I recommend using rebases
    rather than merges when combining changes. The former will move local new commits
    on top of any remote changes, rewriting and leaving a linear clear history, whereas
    the latter will introduce a merge commit. To make this change, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now set up our system with a package manager and version control. Next,
    we can install the specific tooling we need for the various aspects of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python for backend development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of languages that are suitable for backend development,
    and any would be a fine choice for your app. In this book, I’ve chosen to use
    Python as I find that the code is more accessible and easier to follow than other
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will be writing the backend for our app in **Python**, we will need to
    have it installed locally. While you may have a Python version already installed,
    I’d recommend you use the one installed by the system package manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The package manager we’ve used so far doesn’t know how to install and manage
    Python packages, so we also need another package manager. There are many choices
    in Python, and I think PDM is the best. PDM can be installed with the system package
    manager on Linux and macOS systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows systems, it can be installed by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll keep the backend code separate in a backend folder, so please create
    a *backend* folder at the top level of the project with the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to inform git that there are files that we don’t want to be tracked
    in the repository and hence it should ignore them by adding the following to *backend/.gitignore*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For PDM to manage our project, we need to run the following command in the
    *backend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When prompted, you should choose the Python version installed using the system
    package manager earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We can now focus on the specific Python tooling for fast development.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python does not have an official format or formatter; however, `black` is the
    de facto formatter for code and `isort` is the de facto formatter for imports.
    We can add both to our project by running the following command in the *backend*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The dev flag
  prefs: []
  type: TYPE_NORMAL
- en: We use the `--dev` flag here as these tools are only required for developing
    the backend and therefore do not need to be installed when running in production.
  prefs: []
  type: TYPE_NORMAL
- en: '`black` and `isort` require the following configuration to work well together.
    This should be added to the end of the *backend/pyproject.toml* file (you may
    have to change the `target-version` if you are using a version of Python other
    than 3.10) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands will run `black` and `isort` on our code in the *src*
    and *tests* folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll be using Jinja templates for emails sent by our app. While these templates
    are code, they are not Python and hence require a different formatter. Thankfully,
    `djhtml` can be used to format the templates and is added by running the following
    command in the *backend* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will run `djhtml` on our template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now installed the tooling we need to format the code in the backend. Next,
    we can install the tooling we need to lint the code.
  prefs: []
  type: TYPE_NORMAL
- en: Linting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python supports type hints that describe the expected types of variables, functions,
    and so on. We’ll use type hints and tooling to check that we haven’t introduced
    any type-related bugs. The most popular type checking tool for Python is `mypy`.
    It is installed by running the following command in the *backend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will run `mypy` over the backend code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With `mypy` helping us find type errors, we can add `Flake8` to help us find
    other bugs. `Flake8` is installed with `pdm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Flake8` must be configured to work with `black` and `mypy` by adding the following
    to *backend/setup.cfg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Flake8` is used by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another type of bug that we can use tooling to help us find, and these
    are related to security. A good example would be checking for a SQL injection
    vulnerability. Bandit is another linter that helps identify these bugs, and it
    is installed by running the following command in the *backend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Bandit only needs to lint the `src` code as the test code does not run during
    production. To run Bandit over the `src` code, the following command is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bandit ModuleNotFoundErrors
  prefs: []
  type: TYPE_NORMAL
- en: 'Bandit may fail to run with the error `ModuleNotFoundError: No module named
    ‘pkg_resources’`. If this happens, then run `pdm add --dev setuptools` to add
    the missing module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have tooling looking for bugs, but we can also add tooling to look for
    unused code. This is helpful as code can often be forgotten during refactoring,
    leaving files that are much more complex to read and understand than they should
    be. I like to use `vulture` to find unused code, and it is installed by running
    the following command in the *backend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, `vulture` can report false positives, so I like to configure
    it to be 100% confident when reporting issues by adding the following configuration
    to *backend/pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Like Bandit, it is best to run `vulture` over the `src` code only (not the
    tests) via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at what we need to test the code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has `unittest` as part of its standard library, however, I think using
    `pytest` is superior. `pytest` is very feature-rich and allows for very simple
    and clear tests, such as the following small example that tests that a simple
    addition is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`pytest` requires the `pytest-asyncio` plugin to test async code, and they
    are both installed with `pdm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`pytest` is best configured to show local variables on test failure as this
    makes it much easier to understand why the test is failing. In addition, the `asyncio`
    mode should be set to `auto` to make writing async tests easier. The following
    configuration should be placed in *backend/pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the tests, `pytest` is invoked with the `tests` path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve installed all of the tooling, we need some simple commands to
    run it.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve added a lot of useful tooling to our project; however, each one had a
    different unique command that we’d have to remember. This is something we can
    simplify by making use of PDM’s scripting feature as it can be used to map PDM
    commands to the required commands. We will add the following three PDM scripting
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pdm run format` to run the formatting tooling and format the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdm run lint` to run the linting tooling and lint the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdm run test` to run the tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PDM’s scripting requires these script commands to be added to the *backend/pyproject.toml*
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the backend tooling in place and accessible via easy-to-remember commands,
    we can now do the same for the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Installing NodeJS for frontend development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we want our app to run in the browser, we will need to write the frontend
    in JavaScript or a language that compiles to it. There are many good choices,
    but I’ve chosen to use **TypeScript** as it is JavaScript with the addition of
    typing (as in, it is the same basic language). This means it is close to the required
    runtime language and has the additional safety and documentation from the typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will be writing the frontend in TypeScript, we will need **NodeJS** installed
    to compile TypeScript to the JavaScript that will run in the browser. NodeJS is
    best installed with the system package manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Python, where we installed a specific package manager, NodeJS comes with
    one called `npm`. We’ll use `npm` to manage the frontend dependencies and tooling.
    `npm` also includes the `npx` tool that we will use to run one-off scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the backend, we’ll separate the frontend code into a frontend folder.
    Then, we’ll use the `create-react-app` tool in this new folder to set everything
    up by running the following command in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It should give the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of the files also installed, only the *frontend/package.json*, *frontend/package-lock.json*,
    *frontend/tsconfig.json*, *frontend/.gitignore*, *frontend/src/react-app-env.d.ts*,
    and *frontend/public/index.xhtml* files matter at the moment, so you can delete
    or adapt the other files as you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: We can now focus on the specific NodeJS tooling for fast development.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript does not have an official format/formatter; however, Prettier is
    the de facto formatter. We should add it to the project as a development dependency
    by running the following command in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The --save-dev flag
  prefs: []
  type: TYPE_NORMAL
- en: We use the `--save-dev` flag here as these tools are only required to develop
    the frontend, and therefore do not need to be installed when running in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Prettier does not add trailing commas, which is different from
    the style used in Python. To be consistent and therefore not have to think about
    this, Prettier can be configured by adding the following section to *frontend/package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will then run Prettier over our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now installed the tooling to format the code and we can focus on the tooling
    to lint it.
  prefs: []
  type: TYPE_NORMAL
- en: Linting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, we required a linter to type check our Python code,
    however, as we are using TypeScript, we do not need to install anything extra
    to type check. However, we can install linters to check for other bugs; the de
    facto linter for TypeScript and JavaScript is `eslint`, which is installed by
    running the following command in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `eslint` is not compatible with Prettier; fortunately, the `eslint-config-prettier`
    package configures `eslint` to be compatible. It is installed by running the following
    command in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the backend, we should order our imports using `eslint-plugin-import`,
    which is installed with `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'These linters are then configured by replacing the existing `eslintConfig`
    section with the following in *frontend/package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines will already be present.
  prefs: []
  type: TYPE_NORMAL
- en: '`eslint` can be run over our code via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`eslint` can also fix some of the issues it identifies via the use of the `--fix`
    flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now installed the tooling to lint the code and we can focus on the tooling
    to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `create-react-app` tool used earlier also installed a test runner called
    Jest, which we can invoke by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Jest allows for tests to be written using an `expect` syntax, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With the testing tooling present, we can focus on analyzing the built bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the bundle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The frontend code will be delivered as bundles (in chunks) to the user. These
    bundles, especially the main bundle, should be small so that the user isn’t waiting
    too long for the code to be downloaded. To check the bundle size and analyze what
    is included in each bundle, I use `source-map-explorer`, which is installed by
    running the following command in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can analyze the bundle sizes, we first need to build them by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can analyze them via this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the preceding command is shown in *Figure 1.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: The output from source-map-explorer showing that the main bundle
    is 141 KB ](img/Figure_1.2_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: The output from source-map-explorer showing that the main bundle
    is 141 KB'
  prefs: []
  type: TYPE_NORMAL
- en: Each bundle should be as small as possible, with a good rule of thumb being
    that bundles should be split when the bundle exceeds 1 MB. We’ll find that we
    need to do this when we add a password complexity analyzer to the frontend in
    [*Chapter 4*](B18727_04.xhtml#_idTextAnchor111), *Creating a Reusable Frontend
    with React*.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To match the backend, we want to add the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm run analyze` to run the bundle analyzer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run format` to run the formatting tooling and format the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run lint` to run the linting tooling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run test` to run the tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As `npm run test` is already present, we only need to add the other three.
    This is done by adding the following to the `scripts` section in *frontend/package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines will already be present in the section.
  prefs: []
  type: TYPE_NORMAL
- en: With the frontend tooling in place and accessible via the easy-to-remember commands,
    we can now do the same for the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform for infrastructure development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll need to create and manage remote infrastructure, starting with a remote
    repository that we will use to develop the app with other developers or to simply
    backup our code. This remote infrastructure could be created manually, for example,
    using GitHub’s web interface. However, by using an Infrastructure as a Code tool,
    we can record all of the changes we make, and then if anything goes wrong, we
    can rerun our code and restore everything to a known state.
  prefs: []
  type: TYPE_NORMAL
- en: 'I find **Terraform** to be the best tool to manage infrastructure, which we
    can install as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With Terraform installed, we can create a folder within our repository for
    the infrastructure code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our repository should now have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As with the backend and frontend, we’ll need to install tooling to help development.
    In addition, for the infrastructure, we’ll need tooling to manage secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Managing secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow Terraform to manage our infrastructure, we will need to provide passwords,
    keys, and other secrets. These secrets will need to be stored (and used) in a
    secure fashion – simply storing passwords in plain text in the repository is a
    common way to be hacked. We will instead encrypt the secrets and store the encrypted
    file in the repository. This means we’ll have to keep the encryption key secret,
    which I recommend you do by using a password manager such as BitWarden.
  prefs: []
  type: TYPE_NORMAL
- en: 'To encrypt the secrets, we can use `ansible-vault`, which is installed using
    the Python package manager, `pip`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: pip or PDM
  prefs: []
  type: TYPE_NORMAL
- en: pip is a tool for installing packages, whereas PDM is a project management tool.
    As we don’t have an infrastructure project to manage, it makes more sense to use
    pip to install `ansible-vault`. However, this is the only time we’ll directly
    use pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `ansible-vault`, we need to provide the encryption key. To do
    so, add your encryption key to *infrastructure/.ansible-vault* and inform Ansible
    that it is stored there by adding the following to *infrastructure/ansible.cfg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll need to encrypt two files: Terraform’s state, `terraform.tfstate`, and
    our collection of secret variables, `secrets.auto.tfvars`. The commands to do
    so are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to decrypt these files, which is done via the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the password file, encrypted files, and general Terraform autogenerated
    files aren’t considered part of the repository, the following should be added
    to *infrastructure/.gitignore*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Terraform is now set up and ready to use, which means we can focus on the development
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting, linting, and testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Terraform comes with a built-in formatter, which is invoked via the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This formatter also supports a check mode to use when linting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Terraform also comes with a tool to lint your code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing Terraform code is harder as almost all of the code depends on an interaction
    with a third-party service. Instead, I find running and checking that the output
    makes sense to be the only way to test what the code will do. Terraform will provide
    an output of what it plans to do by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to install and set up to manage all of the infrastructure
    we’ll install in this book. We can now focus on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL for database development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app will need to store data (the to-dos) in a structured form, which makes
    a database an ideal choice. This database will need to be running locally to allow
    us to develop with it, so we need to install it. The database I prefer is **PostgreSQL**,
    which is a SQL-based relational database. I prefer it as it is very widely supported,
    and very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL is installed using the system package manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If using `brew`, you will likely need to start `postgresql` as a service that
    runs in the background, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, when using `brew`, we need to create a superuser, which by convention
    is called *postgres*. This user is created with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with `scoop`, you will have to start the PostgreSQL database whenever
    you wish to use it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With the addition of the database tooling, we have all of the local tooling
    we need to develop our app. This means we can focus on the remote tooling, a GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: "Adopting a collaborative development process \Lusing GitHub"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you may be working on your own, it is good practice to adopt a development
    process that allows others to collaborate and one that ensures that the code is
    always ready to be deployed to production. We will achieve both aims by using
    a remote repository and **Continuous Integration** (**CI**).
  prefs: []
  type: TYPE_NORMAL
- en: A remote repository acts as a backup for all your code and makes it much easier
    to set up CI (testing, linting, and so on). We’ll use GitHub as I find it to have
    all the features needed, although other platforms, such as GitLab, are also valid
    and commonly used in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than creating the repository through GitHub’s UI, we’ll use Terraform
    as set up earlier. To do so, we’ll first need a personal access token from GitHub,
    as explained at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).
    The token will need the `repo`, `workflow`, and `delete_repo` scopes. This token
    is a secret and hence best placed in *infrastructure/secrets.auto.tfvars* and
    encrypted as described earlier in the *Managing secrets* section. The code should
    be placed into *infrastructure/secrets.auto.tfvars* as follows (replace `abc1234`
    with your token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Terraform itself does not know how to interact with GitHub, which means that
    we need to install the GitHub provider to do so. This is done by adding the following
    code to *infrastructure/main.tf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With the provider present, we can describe the repository we would like to
    exist by adding the following code to *infrastructure/github.tf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to actually create the repository, we need to initialize and apply
    Terraform as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now set up `git` so that it knows about the remote repository. To
    do this, we’ll need the correct path, which will depend on your GitHub account
    name and the name of your project. As my GitHub account name is *pgjones* and
    this project is called *tozo*, the path is *pgjones/tozo*, making the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To have our local branch track the remote `origin` `main` branch, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To push our local changes on our `main` branch to the remote `feature` branch,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To pull the remote `main` branch to update our local branch, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Most in this industry operate a development workflow based on merge (pull)
    requests, which we’ll also adopt. This workflow consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a feature locally consisting of as few commits as makes sense (small
    changes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the feature to a remote `feature` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a merge request based on that branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the merge request, merging it to the `main` branch only if CI passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the latest `main` branch and repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the repository created, we can now look at adding CI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub provides a CI system called Actions that has a free tier, which we’ll
    use. To start, we need to create the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can configure a workflow that runs jobs on every change to the `main`
    branch and every merge request by adding the following code to *.github/workflows/ci.yml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to add jobs for the infrastructure, backend, and frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CI for the infrastructure code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously set up the commands to format and lint the infrastructure code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To have these run as part of CI, we need to add the following job to the *.github/workflows/ci.yml*
    file within the `jobs` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can now add a job for the backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CI for the backend code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously set up the commands to format, lint, and test the backend code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To have these run as part of CI, we will need to have a database service running
    as well, as the tests run against the database. Fortunately, GitHub supports PostgreSQL
    database services by running a PostgreSQL database alongside the CI job. We can
    make use of this database service and run the commands by adding the following
    job to the `jobs` section in *.github/workflows/ci.yml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can now add a job for the frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CI for the frontend code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously set up the commands to format, lint, test, and build the frontend
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of the service and run the commands by adding the following
    job to the `jobs` section of *.github/workflows/ci.yml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need in place to start developing our app. The folder
    structure at this stage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We now have all of our checks running on every change to the `main` branch and
    for every pull request. This should ensure that our code remains at a high quality
    and alert us to any issues that may otherwise be missed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up all of the tooling we need to develop our app. We
    started by installing a system package manager, which we then used to install
    and set up git. With git, we created our local repository and started to commit
    code. We installed Python, NodeJS, Terraform, and the tooling required to format,
    lint, and test the code. Finally, we used Terraform to create and set up a remote
    GitHub repository with working CI, ensuring that our code is automatically checked
    on every change.
  prefs: []
  type: TYPE_NORMAL
- en: The tooling we’ve installed in this chapter is required to develop the app described
    in the following chapters. It will also allow you to do so quickly, as the tooling
    will help you quickly identify issues and errors with the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start developing the backend of our app, with the
    focus being on setting up the app framework and extensions that support the features
    we want, for example, authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often useful to switch versions of Python and NodeJS to test the app before
    upgrading it. To do this, I’d recommend `pyenv` (https://github.com/pyenv/pyenv)
    and `n` (https://github.com/tj/n) for Python and NodeJS, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 Building a To-Do App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will build a fully functional to-do tracking application using Quart
    and React. The app will include many common features, such as authentication,
    user management, styled pages, and forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part consists of the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B18727_02.xhtml#_idTextAnchor053), *Creating a Reusable Backend
    with Quart*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18727_03.xhtml#_idTextAnchor076), *Building the API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18727_04.xhtml#_idTextAnchor111), *Creating a Reusable Frontend
    with React*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18727_05.xhtml#_idTextAnchor138), *Building the Single-Page
    App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
