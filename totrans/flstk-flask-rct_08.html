<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-127"><a id="_idTextAnchor158"/>8</h1>
<h1 id="_idParaDest-128"><a id="_idTextAnchor159"/>SQL and Data Modeling</h1>
<p>So far, we’ve explored React, a key library in frontend technology stacks. Now, we will explore the world of backend development, starting with <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) and data modeling.</p>
<p>SQL and data modeling are critical skills for any backend developer, and starting with these skills in the backend development journey will give you a strong foundation to build robust and scalable web applications. SQL<a id="_idIndexMarker462"/> is a standard language used to manage data in relational databases, which are essentially used to store structured data.</p>
<p>Knowledge of SQL will help you to write optimized SQL queries that can improve the performance of your application and reduce server load. Data modeling<a id="_idIndexMarker463"/> will help you to design a database schema that reflects the data your application will work with. Data modeling can help you avoid performance issues, maintainability problems, and other common issues that may arise when working with databases.</p>
<p>We will dive deeply into relational databases and how database tables can relate to one another. We will examine SQL<a id="_idIndexMarker464"/> as a standard language<a id="_idIndexMarker465"/> used by many database management systems, including <strong class="bold">PostgreSQL</strong>, a popu<a id="_idTextAnchor160"/>lar open source <strong class="bold">relational database management </strong><strong class="bold">system</strong> (<strong class="bold">RDBMS</strong>).</p>
<p>Having a robust understanding of relational databases and knowledge of how database relationships work will help you design scalable and maintainable data structures. We will leave no stone unturned, cruising through the setup of PostgreSQL and exploring how Flask applications can communicate with PostgreSQL.</p>
<p>We will also discuss in depth the ability of SQLAlchemy to handle various relational database dialects by providing an interface that allows SQL interaction with a database using Python objects. <strong class="bold">SQLAlchemy</strong> is an industrial-strength object-relational<a id="_idIndexMarker466"/> mapper that provides a powerful interface for interaction with various relational database dialects, including PostgreSQL.</p>
<p>SQLAlchemy makes it easier to write complex database queries and manage database transactions. We will examine how you can come up with a data model and send data from a Flask application to a database.</p>
<p>In addition to data modeling and SQL, migration is also a crucial aspect of backend development. We will examine migration as a way of tracking and updating database structures with Alembic. <strong class="bold">Alembic</strong> is a migration tool that provides<a id="_idIndexMarker467"/> a reliable way of tracking and updating database structures, making it an essential tool for Python developers.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is the relational data model?</li>
<li>Exploring the different database relationships</li>
<li>Setting up PostgreSQL</li>
<li>Understanding database concepts for Flask applications</li>
<li>Understanding SQLAlchemy ORM basics</li>
<li>Modeling data for the speakers conference web application</li>
<li>Sending data to the PostgreSQL database from a Flask application</li>
<li>Migration with Alembic</li>
</ul>
<h1 id="_idParaDest-129"><a id="_idTextAnchor161"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08</a>.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor162"/>What is the relational data model?</h1>
<p>The <strong class="bold">relational data model</strong> is a conceptual approach used to represent<a id="_idIndexMarker468"/> a database as a group of relations. Most web applications are highly data-driven. Developers have to deal with either code-level data storage, in the case of a data structure, or find a way to persistently store data in an RDBMS, such as PostgreSQL or MySQL.</p>
<p>In an RDBMS, you can refer to a table as a relation. Therefore, a relational model represents data as a collection of relations or tables. Breaking down the database structure further, you then have rows and columns making up a table. Then, you have a record, which consists of a combination of rows and columns.</p>
<p>Let’s take a look at a hypothetical table<a id="_idIndexMarker469"/> named <code>customers</code> that depicts the structure of a typical table for clarity:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Id</code></p>
</td>
<td class="No-Table-Style">
<p><code>firstname</code></p>
</td>
<td class="No-Table-Style">
<p><code>lastname</code></p>
</td>
<td class="No-Table-Style">
<p><code>email</code></p>
</td>
<td class="No-Table-Style">
<p><code>phone</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p>Joel</p>
</td>
<td class="No-Table-Style">
<p>Doe</p>
</td>
<td class="No-Table-Style">
<p>Joel@admin.com</p>
</td>
<td class="No-Table-Style">
<p>404-228-5487</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p>Edward</p>
</td>
<td class="No-Table-Style">
<p>Spinster</p>
</td>
<td class="No-Table-Style">
<p>Edward@admin.com</p>
</td>
<td class="No-Table-Style">
<p>403-268-6486</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p>Mabel</p>
</td>
<td class="No-Table-Style">
<p>Emmanuel</p>
</td>
<td class="No-Table-Style">
<p>Mabel@admin.com</p>
</td>
<td class="No-Table-Style">
<p>402-248-4484</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – A table showing customer information</p>
<p>In the preceding <code>customers</code> table, we have five columns and three rows. Each row in a table<a id="_idIndexMarker470"/> is called a tuple. The column headers such as <code>Id</code>, <code>firstname</code>, <code>lastname</code>, <code>email</code>, and <code>phone</code> are called<a id="_idIndexMarker471"/> attributes or fields. In a database, tables are created to store data efficiently. Each table usually represents a business entity or object such as a speaker, venue, subject, customer, product, order, and so on.</p>
<p>For clarity, a business entity<a id="_idIndexMarker472"/> represents things we intend to encapsulate in the application business data model with all the rules, relationships, and ability to be persistent in the database. In the preceding table, we have a customer business entity with the following attributes – <code>Id</code>, <code>firstname</code>, <code>lastname</code>, <code>email</code>, and <code>phone</code>. More often than not, you would have more than one table in your web application.</p>
<p>Expectedly, you need to be able to relate these different tables or relations in your database using primary keys. The primary key<a id="_idIndexMarker473"/> is the unique identifier for the entire row of a table, referring to one or more columns. And if there are multiple columns for the primary key, then the set of primary key columns<a id="_idIndexMarker474"/> is known as a composite key. In our case, <code>Id</code> in the customer table could be set as the primary key.</p>
<p>Additionally, another concept in data relation is a foreign key. A foreign key<a id="_idIndexMarker475"/> refers to a primary key in another (foreign) table. Foreign keys are used to map relationships between tables or relations. The table relationship helps you to store data efficiently where it needs to be stored, and accessing related data becomes easier when needed.</p>
<p>There are many relationships<a id="_idIndexMarker476"/> in database design – <em class="italic">one-to-one</em>, <em class="italic">one-to-many</em>, and <em class="italic">many-to-many</em>. For instance, related tables in a database can help you find out orders made by your customers, how many conference attendees are currently enrolled in each subject, and so on.</p>
<p>In the next section, we will extensively discuss the relationships in a database and how they are used in web application architectural design.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor163"/>Exploring the different database relationships</h1>
<p>In the client-server model, the database<a id="_idIndexMarker477"/> resides at the server end of the infrastructure. The database is core to any production-grade web application in collecting and storing application data. Understanding relationships that exist in a database is vital for organizing, managing, and retrieving useful data from a database.</p>
<p>As previously mentioned, there are three types of relationships that exist in a database – <em class="italic">one-to-one</em>, <em class="italic">one-to-many</em>, and <em class="italic">many-to-many</em>. We will begin by delving into the concept of a one-to-one relationship.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor164"/>One-to-one (1:1) relationship</h2>
<p>A <code>speakers</code> and <code>speakerExtras</code>.</p>
<div><div><img alt="Figure 8.1 – An entity relationship diagram showing the one-to-one relationship" src="img/Figure_8.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – An entity relationship diagram showing the one-to-one relationship</p>
<p>The preceding diagram depicts the <code>speakers</code> table and the <code>speakerExtras</code> table. The <code>speakers</code> table details the basic required information of a speaker object, while the <code>speakerExtras</code> table showcases the optional information that can be added to speaker information. <code>speaker_id</code> in the <code>speakers</code> table is the primary key that can be used to uniquely identify a speaker record.</p>
<p>In the <code>speakerExtras</code> table, a column is added as <code>speaker_id</code>. This <code>speaker_id</code> column in the <code>speakerExtras</code> table is a foreign key with a unique attribute. This <code>speaker_id</code> column is used as a reference key for <code>speaker_id</code> in the <code>speakers</code> table to form a one-to-one relationship between the <code>speakerExtras</code> table and the <code>speakers</code> table.</p>
<p>Most of the time, the one-to-one relationship data model can actually be merged. Merging a one-to-one relationship data model typically means combining the tables into a single table. This is usually done when the two tables have a strong connection and the data in the tables is not complex enough to warrant having separate tables.</p>
<p>However, there are cases where the database design requirement may be a separate table for information that may be optional, so rather than having an empty column in a table, you can create a different table<a id="_idIndexMarker480"/> to handle this optional information<a id="_idIndexMarker481"/> for better database performance.</p>
<p>Let’s take a look at another database relationship, one-to-many.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor165"/>One-to-many (1:M) relationship</h2>
<p>A <strong class="bold">one-to-many relationship</strong> in a data model explains a relationship<a id="_idIndexMarker482"/> between two tables, in which<a id="_idIndexMarker483"/> a row in one table can reference one or many rows in another table. The one-to-many relationship is a kind of parent-child relationship where a child record can only have one parent record.</p>
<p>Most of the time, the parent record has more than one child in another table’s rows. However, in a real-life scenario, we could have a situation in which a parent record has no child record at all. What does a parent with no child record mean? It means that the foreign key column in the child table will be empty for that parent record.</p>
<p>For instance, consider a database design for a store where each customer can have multiple orders. If a new customer record is created but no orders have been placed yet, there will be a customer record with no corresponding order records. In this case, the customer record is the parent record, and the order records are the child records.</p>
<p>Furthermore, a one-to-many relationship in some cases also allows a single record in another table. There are cases where a one-to-many relationship can be constrained to functionally act as a one-to-one relationship. For instance, you could add a unique constraint to the foreign key column in the child table, ensuring that each record in the parent table is associated with, at most, one record in the child table.</p>
<p>This would effectively constrain the relationship to function as a one-to-one relationship, even though the underlying data model is a one-to-many relationship. This one-to-many relationship is almost similar to a one-to-one relationship but with a subtle difference of a unique constraint. Why is this one-to-many relationship important in data modeling?</p>
<p>Like other database relationships, the one-to-many relationship is a fundamental building block of relational database design and is essential for organizing, managing, and analyzing complex data structures. The one-to-many relationship enforces referential integrity of data by ensuring that each record in the child table is associated with a valid record in the parent table. This approach helps prevent data inconsistencies and errors that can arise from orphan records or references to non-existent records.</p>
<p>Let’s take a look at an example of a one-to-many relationship. Imagine we have <code>customers</code> and <code>orders</code> tables in our database. It is possible for a customer to have many 1:M orders with a business over a period of time.</p>
<p>A business might want to keep this record. For example, customers tend to have different orders; a particular <code>orderID</code> can’t belong to many customers. Every customer’s order is unique. The following diagram depicts a one-to-many relationship between customers and orders.</p>
<div><div><img alt="Figure 8.2 – An entity relationship diagram showing the one-to-many relationship" src="img/Figure_8.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – An entity relationship diagram showing the one-to-many relationship</p>
<p>In the preceding diagram, <code>customer_id</code> in the <code>orders</code> table represents the foreign key and the main linking factor between the two entities – <code>customers</code> and <code>orders</code>. If you want to know the number of orders a particular customer has, all you need to do is write a <code>JOIN</code> query that tends to look up <code>customers</code> and <code>orders</code> tables, and check for the occurrence of <code>customer_id</code> in the <code>orders</code> table as a reference key.</p>
<p>In the database design<a id="_idIndexMarker484"/> for your web application<a id="_idIndexMarker485"/> development, you will encounter more of this data relationship, as it is the most commonly used one. Next, we take a look at another database relationship, many-to-many.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor166"/>Many-to-many (M:M) relationship</h2>
<p>A <strong class="bold">many-to-many relationship</strong> in data modeling simply refers<a id="_idIndexMarker486"/> to a data relationship<a id="_idIndexMarker487"/> in which multiple records in one table are related to multiple records in another table. Take, for instance, a conference database design, where you could have the following scenarios:</p>
<ul>
<li>An attendee can be enrolled in multiple conference sessions</li>
<li>A session can have many attendees enrolled in it</li>
</ul>
<p>This implies that an attendee has many conference sessions, and a conference session has many attendees. Thus, there is a many-to-many relationship between the conference attendees and sessions.</p>
<p>Interestingly, unlike a one-to-one relationship and one-to-many relationship, you can’t model a many-to-many relationship with just two tables. In many-to-many relationship modeling, a third join table is required, whereby you have the values of the primary keys of the two tables added to the join table.</p>
<p>Let’s examine the <strong class="bold">entity relationship</strong> (<strong class="bold">ER</strong>) diagram of a many-to-many relationship<a id="_idIndexMarker488"/> for conference attendees and the sessions they enroll in:</p>
<div><div><img alt="Figure 8.3 – An entity relationship diagram showing the many-to-many relationship" src="img/Figure_8.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – An entity relationship diagram showing the many-to-many relationship</p>
<p>Let’s break down the preceding<a id="_idIndexMarker489"/> ER diagram to have a better<a id="_idIndexMarker490"/> understanding of the many-to-many relationship. We have three tables, as clearly shown – <code>attendees</code>, <code>enrollemnt_tbl</code>, and <code>conf_sessions</code>.</p>
<p>The <code>attendees</code> table contains records for conference attendees. Likewise, the <code>conf_sessions</code> table contains records for conference sessions. You then have a join table, <code>enrollment_tbl</code>, which technically forms a one-to-many relationship with each of the two tables.</p>
<p><code>enrollment_tbl</code> contains the primary keys of both the attendees and the <code>conf_sessions</code> tables as foreign keys. With <code>enrollment_tbl</code>, we can query related records from the attendees and <code>conf_sessions</code> tables. In this case, we can access all the sessions<a id="_idIndexMarker491"/> a particular attendee attends <a id="_idIndexMarker492"/>at the conference.</p>
<p>Next, we will delve deeper into database setup, using SQLAlchemy and Alembic, for the database part of a web application.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor167"/>Setting up PostgreSQL, SQLAlchemy, and Alembic</h1>
<p>We are going to start by setting<a id="_idIndexMarker493"/> up the database tools needed for the backend database. PostgreSQL is a popular free and open source RDBMS. It is similar<a id="_idIndexMarker494"/> to other dialects of the <strong class="bold">SQL</strong> databases that exist – for example, MySQL, MariaDB, and Oracle. This database can be used to store data for any web application. PostgreSQL has enterprise-grade features that make it robust, scalable, and reliable.</p>
<p>We will also set up SQLAlchemy, an <code>read</code>, <code>insert</code>, <code>update</code>, and <code>delete</code>, rather than writing SQL queries directly. Finally, in this section, we will set up Alembic to handle database migrations.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor168"/>Setting up PostgreSQL</h2>
<p>To get started with PostgreSQL<a id="_idIndexMarker496"/> locally on your<a id="_idIndexMarker497"/> machine, download it from <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a> and select your operating system package.</p>
<div><div><img alt="Figure 8.4 – A diagram showing the download page of PostgreSQL" src="img/Figure_8.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – A diagram showing the download page of PostgreSQL</p>
<p>Run through the installation<a id="_idIndexMarker498"/> wizard by following the instructions to set up the database. During the PostgreSQL installation, you will be prompted to enter a super user password. It is very important you keep the password you entered as super user, as this will be required to log in to the default PostgreSQL database. Once the installation is complete, log in to the database.</p>
<p>Open the command terminal on your machine and type the following command:</p>
<pre class="console">$     psql -d postgres -U postgres</pre>
<p><code>psql</code> invokes a connection to PostgreSQL from the terminal. Then, you can use the <code>-d</code> option to select the database you want to access and <code>-U</code> to select the user with access permission to the database.</p>
<p class="callout-heading">Note</p>
<p class="callout">If the command terminal replies with <code>psql not recognized as an internal or external command</code>, you might need to add the Postgres <code>bin/ (C:\Program Files\PostgreSQL\14\bin</code>) to the system path of the environment variable.</p>
<p>Then, enter the password you created for the superuser during the installation.</p>
<p>The following screenshot shows the terminal while trying to log in to PostgreSQL.</p>
<div><div><img alt="Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal" src="img/Figure_8.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal</p>
<p>It is always a best practice<a id="_idIndexMarker499"/> to create a new user on Postgres, different from the superuser created during the installation. Now that you are logged in with the default Postgres user, let’s create another user role called <code>admin</code> and assign it the password <code>admin123</code>:</p>
<pre class="console">CREATE ROLE admin WITH LOGIN PASSWORD 'admin123';</pre>
<p>We will now give a new user <code>admin</code> permission to create a database:</p>
<pre class="console">ALTER ROLE admin CREATEDB;</pre>
<p>With all this set, log out from the Postgres user and log in as <code>admin</code>. To log out, type the <code>\</code><code>q</code> command.</p>
<p>Now, log in as an <code>admin</code> user:</p>
<pre class="console">$    psql -d postgres -U admin</pre>
<p>Enter the admin password and log in. Once logged in, create a new database called <code>bizza</code>:</p>
<pre class="console">$    CREATE DATABASE bizza;</pre>
<p>To connect to the newly created database, run the following command:</p>
<pre class="console">$    \connect bizza</pre>
<p>The following screenshot shows how to connect to create a database in PostgreSQL:</p>
<div><div><img alt="Figure 8.6 – A screenshot showing a connection to the bizza database" src="img/Figure_8.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – A screenshot showing a connection to the bizza database</p>
<p>Hurray! We have set up PostgreSQL<a id="_idIndexMarker500"/> successfully. Now, let’s dive into setting up SQLAlchemy.</p>
<p class="callout-heading">Note</p>
<p class="callout">The role name, <code>admin</code>, and password, <code>admin123</code>, could be anything you want; they don’t have to be named as suggested.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor169"/>Setting up SQLAlchemy</h2>
<p>Setting up SQLAlchemy for a Flask application<a id="_idIndexMarker501"/> is simple and straightforward. To set up SQLAlchemy in your project, let’s install SQLAlchemy with the following command in the Terminal right inside your project <code>root</code> directory. Make sure your virtual environment is activated before running the installation command:</p>
<pre class="console">pip install SQLAlchemy</pre>
<p class="callout-heading">Note</p>
<p class="callout">SQLAlchemy is a Python SQL toolkit and ORM library that provides a set of high-level APIs to interact with relational databases.</p>
<p>In addition, we<a id="_idIndexMarker502"/> will use a Flask extension called <strong class="bold">Flask-SQLAlchemy</strong>. Let’s install it by running the following command in the terminal:</p>
<pre class="console">pip install flask-sqlalchemy</pre>
<p class="callout-heading">Note</p>
<p class="callout">The Flask-SQLAlchemy extension provides a wrapper for SQLAlchemy, making it easier to use SQLAlchemy in a Flask application. Flask-SQLAlchemy provides additional features, such as automatic session handling, integration with Flask’s application context, and support for Flask-specific configuration options.</p>
<p>SQLAlchemy will be discussed<a id="_idIndexMarker503"/> deeply in the subsequent section of this chapter, <em class="italic">Understanding SQLAlchemy </em><em class="italic">ORM basics</em>.</p>
<p>Briefly, let’s demonstrate how you can seamlessly integrate SQLAlchemy into your Flask application. The process of integrating SQLAlchemy is as follows:</p>
<ol>
<li>Create a new directory and name it <code>sqlalchemy</code>.</li>
<li>Then, follow the Flask project setup in the <em class="italic">Setting up the development environment with Flask</em> section of <a href="B18554_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</li>
<li>Make sure your development virtual environment is activated.</li>
<li>In the terminal, run the following commands:<pre class="source-code"><strong class="bold">pip install flask</strong><strong class="bold">pip install flask-sqlalchemy</strong></pre></li>
<li>Create a file named <code>app.py</code> within the <code>sqlalchemy</code> directory, and add the following code snippet:<pre class="source-code">from flask import Flask, render_templatefrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__, template_folder='templates')app.config["SQLALCHEMY_DATABASE_URI"] =    "sqlite:///bizza.db"db = SQLAlchemy(app)@app.route('/users')def get_users():    users = User.query.all()    return render_template('users.html', users=users)class User(db.Model):__tablename__= "users"    id = db.Column(db.Integer, primary_key=True)    username = db.Column(db.String(55), unique=True)    name = db.Column(db.String(55), unique=False)    email = db.Column(db.String(100), unique=True)    def __repr__(self):        return '&lt;User {}&gt;'.format(self.username)</pre><p class="list-inset">The preceding code sets up a basic Flask application<a id="_idIndexMarker504"/> that uses SQLAlchemy for database operations. Let’s explain what happens in the preceding code:</p><ul><li><code>from flask import Flask</code>: This imports the <code>Flask</code> class from the Flask package.</li>
<li><code>from flask_sqlalchemy import SQLAlchemy</code>: This imports the <code>SQLAlchemy</code> class from the Flask-SQLAlchemy package.</li>
<li><code>app = Flask(__name__, template_folder="templates")</code>: This creates a new <code>Flask</code> application instance. <code>template_folder</code> is added to ensure that Flask finds the <code>templates</code> directory. <code>App.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///bizza.db"</code>: This sets the database URI for the SQLite database. In this case, the database file is called <code>bizza.db</code> and is located in the <code>instance</code> directory of the Flask application file, <code>app.py</code>. We use <code>SQLite</code> in this example. You can use any database dialect – MySQL, Oracle, PostgreSQL, and so on.</li>
<li><code>db = SQLAlchemy(app)</code>: This creates a new <code>SQLAlchemy</code> instance that is bound to the Flask application.</li>
<li>Then, we have a Flask<a id="_idIndexMarker505"/> route handler that responds to the <code>/users</code> URL endpoint. When a user visits the <code>/users</code> URL, Flask will execute the <code>get_users</code> function, retrieve all the users from the database, and render the <code>users.html</code> template, passing the user’s variable to the template for display.</li>
<li>Lastly, we have the <code>User</code> model with four columns – <code>id</code>, <code>username</code>, <code>name</code>, and <code>email</code>. Each column represents a field in the corresponding database table and specifies its data type and optional constraints, such as uniqueness. This represents how we use SQLAlchemy in Flask to define our models as Python classes, specify their attributes and relationships, and perform database operations.</li>
</ul><p class="list-inset">Now, let’s create the <code>users</code> table in the terminal of the <code>sqlalchemy</code> directory.</p></li>
<li>Enter the following commands in the terminal:<pre class="source-code"><code>users</code> table with sample data with python <code>sample_data.py</code>. The <code>sample_data.py</code> is located inside the project root directory in GitHub.</p></li>
<li>Then, enter the <code>flask run</code> command and go to <code>http://127.0.0.1:5000/users</code> to view the users list from the database.<p class="list-inset">The following is a screenshot that shows how you can use SQLAlchemy to define and retrieve users’ data.</p></li>
</ol>
<div><div><img alt="Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations" src="img/Figure_8.7_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations</p>
<p>With this setup, we have demonstrated<a id="_idIndexMarker506"/> how you can define the SQLAlchemy model and use Python objects to interact with the database in a Flask application.</p>
<p>Next, we will dive into how you can set up Alembic, a database migration tool.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor170"/>Setting up Alembic</h2>
<p><code>pip install alembic</code> or install it from another migration package, <code>Flask-Migrate</code>, using <code>pip install flask-migrate</code>. <code>Flask-Migrate</code> relies on Alembic<a id="_idIndexMarker508"/> for database migration, and we will use it here as a tool of choice for database migration.</p>
<p>The <code>Flask-Migrate</code> migration tool allows you to track<a id="_idIndexMarker509"/> changes to your database. Migration tools come with the ability to manage database structure and operations using a migration script. The essence of Alembic, a migration tool, is to facilitate the automatic generation<a id="_idIndexMarker510"/> of migration SQL scripts.</p>
<p>In the last section of this chapter, we will discuss migration in depth with some implementation details. Next, we will discuss how you can interact with a database from a Flask web application.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor171"/>Understanding database concepts for Flask applications</h1>
<p>Now that we have set up our database and connected with it using the Terminal, it is crucial to have a solid understanding of some database concepts to be able to set up backend services that can collect, store, and retrieve users’ data.</p>
<p>Most modern web applications have a database to store users’ data. As a full stack web developer, part of your responsibility is to be able to set up backend services that can collect, store, and retrieve users’ data. We will dive into interacting with databases from a Flask application shortly, but before that there are few database concepts you need to understand.</p>
<p>Let’s take a quick overview of the following database concepts.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor172"/>RDBMS</h2>
<p>When working with a database<a id="_idIndexMarker511"/> in a production environment, you need an RDBMS. An RDBMS is a software package that allows you to interact with a database. The RDBMS software allows you to define, manipulate, retrieve, and manage data in a database.</p>
<p>You have database features that allow you to manage data in a database and the structure of the database itself. There are many different RDBMS flavors on the market – MySQL, PostgreSQL, Oracle, MsSQL, and MariaDB – but the one we’ll work with is called PostgreSQL.</p>
<p>Let’s take a look at another relevant tool needed to interact with a database, called a <strong class="bold">database applicati<a id="_idTextAnchor173"/>on programming </strong><strong class="bold">interface</strong> (<strong class="bold">DB-API</strong>).</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor174"/>DB-APIs</h2>
<p>A DB-API is an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) that allows communication between a programming<a id="_idIndexMarker512"/> language or web server framework<a id="_idIndexMarker513"/> and a database server, using protocols such as TCP/IP. Python, a language we use<a id="_idIndexMarker514"/> with the Flask<a id="_idIndexMarker515"/> framework, uses a library called psycopg2 that allows Python modules to interact with a PostgreSQL database server.</p>
<p>The DB-API acts as a database adapter, a web interface that allows a web server programming language – Python, in our case – to run SQL queries on a database, using psycopg2 as a library for the DB-API.</p>
<p>Different types of DB-APIs exist for every programming language or server framework and for the various dialects of the SQL database that we have. For instance, we have psycopg2 for PostgreSQL, <code>mysql-python</code> or <code>PyMySQL</code> for MySQL, <code>adodbapi</code> or <code>pymssql</code> for MS SQL Server, and <code>mxODBC</code> or <code>pyodb</code> for Oracle.</p>
<p>The documentation<a id="_idIndexMarker516"/> for PEP 248 DB-API version 1.0 specifies a goal for the DB-API:</p>
<p class="author-quote">“This API has been defined to encourage similarity between the Python modules that are used to access databases. By doing this, we hope to achieve a consistency leading to more easily understood modules, code that is generally more portable across databases, and a broader reach of database connectivity from Python.” (<a href="http://www.python.org/dev/peps/pep-0248/">http://www.python.org/dev/peps/pep-0248/</a>)</p>
<p>In essence, the DB-API gives you a low-level way of writing SQL query statements, making interactions with different databases consistently simple and easy.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor175"/>Client–server model interaction</h2>
<p>Client-server model interaction<a id="_idIndexMarker517"/> is a communication paradigm in which a client requests resources or services from a server over a network. In this model, the client initiates a request to the server, and the server provides the requested service or data in response, creating a client-server interaction that forms the foundation of various applications and network communications.</p>
<p>In the client-server model interaction, the browser acts as a client and the web server as a server. When an end user requests a resource or web page from the server, the request is made through a browser (the client side) through HTTP protocols on a web server (the server side). This same client-server architecture can also be modeled on an end user requesting a resource or web page that contains data from a database.</p>
<p>When a browser makes a request that requires data from the database, the web server receives the request and initiates a connection with the database server. The web server becomes the client, and the database server becomes the server, completing a client-server model from the backend infrastructure (<a href="http://www.python.org/dev/peps/pep-0248/">http://www.python.org/dev/peps/pep-0248/</a>).</p>
<p>Later in this chapter, we will create tables to thoroughly understand how to interact with a database. The following diagram shows the client–server interaction.</p>
<div><div><img alt="Figure 8.8 – A diagram showing the client–server interaction" src="img/Figure_8.8_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – A diagram showing the client–server interaction</p>
<p>In the preceding diagram, the client initiates the interaction by sending a request to the server. The request can be an HTTP request in the case of web-based applications. The server receives the request, interprets it, and performs the necessary operations to generate a response.</p>
<p>Once the response is ready, the server<a id="_idIndexMarker518"/> sends it back to the client. The client receives the response and processes it, utilizing the information provided to complete the client-server interaction. Next, we will dive into ORM basics to understand how you can use Python classes to interact with an RDBMS.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor176"/>Understanding SQLAlchemy ORM basics</h1>
<p>SQLAlchemy offers developers the ability<a id="_idIndexMarker519"/> to work entirely in Python code to create, read, update, and delete tables. SQLAlchemy is the Python SQL toolkit and ORM that allows application developers to interact with databases without writing direct SQL statements.</p>
<p>As SQLAlchemy is an ORM library, Python classes are mapped to tables, and the instances of those classes are mapped to table rows in a relational database. You then have a situation where you can use Python<a id="_idIndexMarker520"/> object-oriented programming code to perform database SQL <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong> (<strong class="bold">CRUD</strong>) operations and other necessary operations in your applications.</p>
<p>The ORM feature of SQLAlchemy gives Python developers the power to harness function calls to generate SQL statements out of the box. With this new way of thinking about databases, developers are able to decouple object models and database schema, leading to a more flexible database structure, elegant SQL statements, and Python code that can interact with different types of database dialects.</p>
<p>SQLAlchemy doesn’t mind the kind of database systems you work with. SQLAlchemy makes it easier to switch from one database to another without altering your code. SQLAlchemy is undoubtedly a powerful tool that simplifies the process of web development, making it faster and more efficient.</p>
<p>With SQLAlchemy’s user-friendly interface, developers can easily create database models and interact with them from their Flask application. Additionally, SQLAlchemy is designed to reduce the chances of introducing bugs into the code base, which is especially important for large-scale applications.</p>
<p>With the provision of a robust framework to handle database interactions, SQLAlchemy allows developers to focus on building the logic of their applications without worrying about the underlying database operations. This results in a more streamlined development process and better overall code quality.</p>
<p>Lastly, the SQLAlchemy ORM library comes with automatic caching. SQLAlchemy caches collections and references between objects once initially loaded. This invariably improves performance and prevents you from sending SQL queries to the database upon every call.</p>
<p>In SQLAlchemy, there are three main vital layers<a id="_idIndexMarker521"/> of abstraction. These layers are the engine, the dialect, and the connection pool. This trio describes how you choose to interact with a database.</p>
<div><div><img alt="Figure 8.9 – The SQLAlchemy layers of abstraction" src="img/Figure_8.9_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The SQLAlchemy layers of abstraction</p>
<p>Let’s dig deeper into the SQLAlchemy layers of abstraction to better understand how they are used in SQLAlchemy.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor177"/>The SQLAlchemy engine</h2>
<p>An SQLAlchemy application<a id="_idIndexMarker522"/> starts with the creation of an engine. You need to create an engine before SQLAlchemy can connect and interact with a database. The engine is at the lowest layer of abstraction in SQLAlchemy, and it works in pretty much the same way in which we use Psycopg2 to interact with a database.</p>
<p>Let’s create an engine to kickstart database connectivity and interaction.</p>
<p>The following snippet demonstrates PostgreSQL database connectivity using <code>create_engine</code> from SQLAlchemy. The SQLAlchemy engine connects to a PostgreSQL database and executes a SQL query in Python:</p>
<pre class="source-code">from sqlalchemy import create_engine# create the engine with the database URL
engine = create_engine
    ("postgresql://admin:admin123@localhost:5432/bizza")
# create a connection to the database
conn = engine.connect()
# execute a SQL query
result = conn.execute('SELECT * FROM speakers')
# loop through the result set and print the values
for row in result:
    print(row)
# close the result set and connection
result.close()
conn.close()</pre>
<p>This is what happens<a id="_idIndexMarker523"/> in the preceding code:</p>
<ul>
<li>The <code>create_engine</code> function is imported from the <code>sqlalchemy</code> library:<pre class="source-code">from sqlalchemy import create_engine</pre></li>
<li>Then, the <code>create_engine()</code> method is invoked in SQLAlchemy and assigned to the engine instance. You then pass in a connection URL string that specifies backend server details, such as the database’s <code>name</code>, <code>username</code>, <code>password</code>, <code>host</code>, and <code>port</code> used for connectivity:<pre class="source-code">engine = create_engine(    'postgresql://admin:admin123@localhost:5432/bizza'    )Database name-bizzaUsername-adminPasswordadmin123</pre></li>
<li>A connection pool is created for the current database, and this is created once in the lifetime application:<pre class="source-code">connection = engine.connect()</pre></li>
<li>We execute the SQL statements using the established connection object:<pre class="source-code">result= connection.execute('SELECT * FROM speakers')</pre></li>
<li>Finally, we loop through the result set returned by the query and print the values.</li>
</ul>
<p>It’s important to close the result<a id="_idIndexMarker524"/> set and the connection using the <code>result.close()</code> and <code>conn.close()</code> methods to free up resources and prevent memory leaks.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor178"/>SQLAlchemy connection pools</h2>
<p>Connection pooling<a id="_idIndexMarker525"/> is an implementation of the object pool design paradigm in software engineering, where connections are reused instead of being created every time a connection to a database is required. In SQLAlchemy, the use of the <code>create_engine()</code> method usually generates a connection pool object that is created once and reused in subsequent connections when carrying out database transactions.</p>
<p>This connection pooling design pattern helps improve performance and better manage application concurrent connections. The default setting of the connection pool can be adjusted to better serve end users of business web applications efficiently.</p>
<p>To update the connection pool, add pooling parameters to <code>create_engine()</code>:</p>
<pre class="source-code">engine = create_engine('postgresql://user:admin123@localhost/bizza', pool_size=20, max_overflow=0)</pre>
<p>The following bullet list shows you how to tweak the connection pool parameters to optimize performance while working with the SQLAlchemy connection pool.</p>
<ul>
<li>With <code>pool_size</code>, you can set the number of connections the pool can handle</li>
<li>With <code>max_overflow</code>, you can specify how many overflow connections the pool supports</li>
<li>With <code>pool_recycle</code>, you can configure the maximum age in seconds of connections in the pool</li>
<li>With <code>pool_timeout</code>, you can specify how many seconds the application needs to wait before giving up getting<a id="_idIndexMarker526"/> a connection from the pool</li>
</ul>
<h2 id="_idParaDest-146"><a id="_idTextAnchor179"/>SQLAlchemy dialect</h2>
<p>One of the main benefits of using SQLAlchemy is that you can use different types of DB-API implementations (Psycopg2) and relational databases without altering your Python code to suit their internal workings.</p>
<p>So, the dialect<a id="_idIndexMarker527"/> is a system in SQLAlchemy that makes interaction with different databases possible. You can use SQLite in your development environment and decide to use MySQL or PostgreSQL in production with your existing code base.</p>
<p>Some examples of relational database dialects are as follows:</p>
<ul>
<li>PostgreSQL</li>
<li>MySQL and MariaDB</li>
<li>SQLite</li>
<li>Oracle</li>
<li>Microsoft SQL Server</li>
</ul>
<p>In order to use these database dialects, you must install appropriate DB-API drivers in your application. When connecting with PostgreSQL, SQLAlchemy uses Psycopg2 as an implementation of the DB-API specification. Psycopg2 is a PostgreSQL adapter for Python. Psycopg2 provides a simple and efficient way to communicate with a PostgreSQL database using Python code.</p>
<p>We’ve talked about how SQLAlchemy dialects work, but what about the data types that are used within those dialects? SQLAlchemy offers a wide variety of data types, and we’ll explore some of them now. After that, we’ll discuss how to map them to Python classes.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor180"/>SQLAlchemy data types – mapping between tables and classes</h2>
<p>SQLAlchemy provides high-level abstractions<a id="_idIndexMarker528"/> to any underlying relational databases we may choose to use in our applications. SQLAlchemy has data type support for the most common traditional databases we are familiar with. For instance, dates, times, strings, integers, and Booleans are well supported by SQLAlchemy.</p>
<p>SQLAlchemy data types allow for precise data storage and retrieval. Each column in a database table has a specific data type that defines the type of data that can be stored in that column, such as integers, strings, or dates. SQLAlchemy provides a range of data types that can be used to define the columns in a database table, including <code>Numeric</code>, <code>String</code>, <code>DateTime</code>, and <code>Boolean</code>.</p>
<p>By using these data types, we can ensure that our data is stored accurately and efficiently, allowing for faster and more reliable data retrieval. Also, the mapping between tables and classes is important because it allows us to work with database tables in an object-oriented manner.</p>
<p>SQLAlchemy provides an ORM system that allows us to map database tables to Python classes. This means that we can work with database data using Python objects and methods, which makes it easier to build and maintain our web applications. Let’s see an example of how SQLAlchemy data types are mapped with Python classes and instance attributes for table and column creations, respectively.</p>
<p>This approach will be used to define tables from Python classes for the Flask applications in this book:</p>
<pre class="source-code">class Speaker(Base):__tablename__ = 'speakers'
speaker_ id=Column(Integer, primary_key=True)
first_name=Column(String)
last_name=Column(String)
email=Column(String)
created_at = Column(DateTime(timezone=True),
    server_default=datetime.now)
updated_at = ColumnDateTime(timezone=True),
    default=datetime.now, onupdate=datetime.now)</pre>
<p>In the preceding code<a id="_idIndexMarker529"/> snippet, we defined a class called <code>Speaker</code> that has some attributes. Let’s dive deeper into the code:</p>
<ul>
<li>The <code>__tablename__</code> attribute is set to <code>speakers</code>, indicating that instances of the <code>Speaker</code> class should be stored in the <code>speakers</code> table in the database.</li>
<li>The <code>speaker_id</code> attribute specifies that this is the <code>primary_key</code> in the table and has an <code>Integer</code> type.</li>
<li>The <code>first_name</code> attribute specifies that a column in the table has the name <code>first_name</code> with a <code>String</code> type.</li>
<li>The <code>last_name</code> attribute specifies that a column in the table has a name <code>last_name</code> with a <code>String</code> type.</li>
<li>The <code>email</code> attribute specifies that a column in the table has the name <code>email</code> with a <code>String</code> type.</li>
<li><code>created_at</code> and <code>updated_at</code> specify columns in the table with the mentioned names that are of type <code>date</code>. Methods are, however, passed to get the current <code>timezone</code>.</li>
</ul>
<p>With the classes and instances defined, we can utilize the internal APIs of SQLAlchemy and the configured dialect to map the class attributes to the corresponding native structure of the database. For example, if we have a string data type in our class, SQLAlchemy will map it to a <code>varchar</code> column in PostgreSQL.</p>
<p>This ensures that the data types used in the class are properly translated into the appropriate database column types, allowing for seamless communication between the Python code and the database.</p>
<p>To build a robust web application for a speakers’ conference web application, we need to model the data correctly. SQLAlchemy provides us with a powerful ORM that makes it easy to map our database tables to classes.</p>
<p>We can then define the attributes<a id="_idIndexMarker530"/> and relationships between these classes, which makes it easy to work with complex data structures. In the next section, we will explore how to model data for our speakers’ conference web application using SQLAlchemy.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor181"/>Modeling data for a speakers’ conference web application</h1>
<p><strong class="bold">Data modeling</strong> is the process of creating a conceptual, logical, and <a id="_idIndexMarker531"/>visual representation of data<a id="_idIndexMarker532"/> structures and relationships<a id="_idIndexMarker533"/> between data elements, in order to understand, analyze, and manage complex information systems. Data modeling involves identifying entities (objects, concepts, or things) that will be represented in a system and defining their attributes and relationships with other entities.</p>
<p>The main purpose of data modeling is to create a clear and precise representation of the data that will be stored, processed, and managed by an information system. A well-designed data model in a web application can ensure that the web application is scalable, efficient, and meets the needs of its users.</p>
<p>Let’s quickly examine some<a id="_idIndexMarker534"/> of the best practices to be considered when designing a data model for the conference speakers’ web application:</p>
<ul>
<li><strong class="bold">Identifying the entities</strong>: Start by identifying the entities or objects that will be represented in the web application based on the system requirements, such as users, speakers, presentation, schedule, attendees, sessions, venue, and sponsors.</li>
<li><strong class="bold">Defining the relationships</strong>: Determine the relationships between these entities, such as one-to-one, one-to-many, or many-to-many relationships. For instance, a speaker can give multiple presentations at the conference, but a presentation can only be given by one speaker.</li>
<li><strong class="bold">Determining the attributes</strong>: Define the attributes or properties of each entity – for instance, a speaker could have attributes such as name, contact address, biography, or presentation topics.</li>
<li><strong class="bold">Considering performance and scalability</strong>: Design the data model to optimize performance and scalability, such as using indexes, caching, or denormalization to reduce query times and improve system response.</li>
<li><strong class="bold">Planning for data storage</strong>: Consider the data storage options available, such as relational databases, NoSQL databases, or flat files, and choose the appropriate option based on the needs of the web application. In this case, PostgreSQL was chosen.</li>
<li><strong class="bold">Data security</strong>: Design the data model to ensure data security, such as using encryption or access controls to protect sensitive data. For instance, when a user logs in, their entered password can be hashed and compared to the stored hash to verify their identity.</li>
<li><strong class="bold">Considering future changes</strong>: Plan for future changes and updates to the web application, such as adding <a id="_idIndexMarker535"/>new entities or attributes, or modifying existing relationships.</li>
</ul>
<p>Are you prepared to begin<a id="_idIndexMarker536"/> developing the backend<a id="_idIndexMarker537"/> of the <em class="italic">Bizza</em> project by establishing and organizing the data model? The <em class="italic">Bizza</em> project aims to create a full stack web application that is database-driven and focuses on conference speakers.</p>
<p>In this data model, we will take a closer look at the database, tables, and relationship between the tables.</p>
<p>The <code>bizza</code> database has the following tables and relationships:</p>
<ul>
<li><code>users</code> and <code>userExtras</code>, a many-to-many relationship between users and roles, a one-to-one relationship between <code>users</code> and <code>speakers</code>, and a one-to-many relationship between <code>users</code> and <code>attendees</code>.</li>
<li><code>users</code> table – a one-to-one relationship between <code>users</code> and <code>userExtras</code>.</li>
<li><code>users</code> table – a many-to-many relationship between <code>users</code> and <code>roles</code>.</li>
<li><code>Speaker</code> model will be linked to the <code>users</code> model to associate each<a id="_idIndexMarker542"/> speaker with their user account. The following relationships exist with other tables – a one-to-many relationship between <code>speakers</code> and <code>sessions</code>, a one-to-one relationship between <code>users</code> and <code>speakers</code>, a one-to-many relationship between <code>speakers</code> and <code>schedules</code>, and a one-to-many relationship between <code>speakers</code> and <code>presentations</code>.</li>
<li><code>Presentation</code> model will be linked to the <code>Speaker</code> model to associate each presentation with its speaker. The following relationships exist with other tables – many-to-one relationships between <code>presentations</code> and <code>speakers</code>, and one-to-many relationships between <code>presentations</code> and <code>schedules</code>.</li>
<li><code>Schedule</code> model will be linked to the <code>Presentation</code> model to associate each presentation with its date and time. The following relationships exist with other tables – many-to-one relationships between <code>schedules</code> and <code>presentations</code>, one-to-many relationships between <code>schedules</code> and <code>sessions</code>, many-to-one relationships between <code>schedules</code> and <code>venues</code>, and many-to-many relationships between <code>schedules</code> and <code>attendees</code>.</li>
<li><code>attendees</code> and <code>schedules</code>.</li>
<li><code>Session</code> model will be linked to the <code>Presentation</code> model to associate each session with its presentations. The following relationships exist with other tables – a many-to-one relationship between <code>sessions</code> and <code>schedules</code>, and a one-to-one relationship between <code>sessions</code> and <code>presentations</code>.</li>
<li><code>venues</code> and <code>schedules</code>.</li>
<li><strong class="bold">Sponsor model</strong>: This model will include data about each sponsor<a id="_idIndexMarker548"/> of the conference, such<a id="_idIndexMarker549"/> as their name, logo, website, and<a id="_idIndexMarker550"/> any other relevant details.</li>
</ul>
<p>Now that we have defined our data model, we will explore in the next section how to seamlessly send data to a PostgreSQL database with just a few simple steps.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor182"/>Sending data to the PostgreSQL database from a Flask app</h1>
<p>Interacting with a database<a id="_idIndexMarker551"/> is a common aspect of most web<a id="_idIndexMarker552"/> applications. Sending data to the PostgreSQL database from a Flask app is simple and straightforward. A web application would not be complete without the ability to store and retrieve data from a database.</p>
<p>The first step in sending data to a database is to ensure there is a connection between the Flask app and the database. This involves installing the required libraries and ensuring that you work in a virtual environment to contain your installation and prevent unexpected occurrences, due to the interference of other libraries.</p>
<p>Let’s make use of the <code>bizza/backend</code> directory created in the <em class="italic">Setting up the development environment with Flask </em>section of <a href="B18554_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. You can create one if you haven’t already. Install and activate the virtual environment.</p>
<p>To create a virtual environment, open your project root directory in a terminal and add the following command:</p>
<pre class="console">python –m venv venv</pre>
<p>Now, let’s activate the virtual environment:</p>
<ul>
<li><strong class="bold">For </strong><strong class="bold">Windows users</strong>:<pre class="source-code"><strong class="bold">Venv\Scripts\activate</strong></pre></li>
<li><strong class="bold">For </strong><strong class="bold">Linux/Mac users</strong>:<pre class="source-code"><strong class="bold">source venv/bin/activate</strong></pre></li>
</ul>
<p>To create a database table from a Python class, you need <code>flask-sqlalchemy</code> installed. We have this installed already. If not, enter the following:</p>
<pre class="console">pip install flask-sqlalchemy</pre>
<p>In the Flask application<a id="_idIndexMarker553"/> module – that is, <code>app.py</code> – update the content<a id="_idIndexMarker554"/> of the <code>app.py</code> with the following code that creates the <code>users</code> table in the <em class="italic">bizza</em> database. In this section, we will only create the <code>users</code> table to demonstrate how to send data from a Flask app to PostgreSQL.</p>
<p>The other models will be shown on GitHub and later in the book until we have a full implementation of the speakers’ conference web app, <em class="italic">Bizza</em>:</p>
<pre class="source-code"># Import flaskfrom flask import Flask
# Import datetime
from datetime import datetime
# Import SQLAlchemy
from flask_sqlalchemy import SQLAlchemy
# Create a Flask instance
app = Flask(__name__)
# Add the PostgreSQL database
app.config['SQLALCHEMY_DATABASE_URI'] =
    'postgresql://&lt;db_username&gt;:&lt;db_password&gt;@localhost:
    5432/&lt;database_name&gt;'
# Initialize the database
db = SQLAlchemy(app)
# User model definition
class User(db.Model):
    __tablename__ = 'users'
    user_id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True,
        nullable=False)
    email = db.Column(db.String(120), unique=True,
        nullable=False)
    password = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    roles = db.Column(db.String(100))
    is_active = db.Column(db.Boolean, default=True)
    is_superuser = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime,
        default=datetime.utcnow())
    updated_at = db.Column(db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow())
    def __repr__(self):
        return '&lt;User %r&gt;' % self.username</pre>
<p>Let’s delve into the preceding<a id="_idIndexMarker555"/> Flask app snippet used<a id="_idIndexMarker556"/> to create the <code>users</code> table in the database:</p>
<ul>
<li><code>from flask import Flask</code> imports the <code>Flask</code> class from the Flask module.</li>
<li><code>from flask_sqlalchemy import SQLAlchemy</code> imports the <code>SQLAlchemy</code> class from the <code>flask_sqlalchemy</code> module.</li>
<li><code>app = Flask(__name__)</code> creates a <code>Flask</code> instance named <code>app</code>.</li>
<li><code>app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://&lt;db_username&gt;:&lt;db_password&gt;@localhost:5432/&lt;database_name&gt;'</code> is where the <code>app.config[]</code> dictionary defines the path to the database with the <code>db username</code> and <code>password</code> set.</li>
<li><code>db = SQLAlchemy(app)</code> initializes an instance of the <code>SQLAlchemy</code> class with the Flask app as the argument.</li>
<li>Then, we start to define the <code>model</code> class for <code>User</code> with <code>class User(db.Model):</code>. The <code>User(db.Model)</code> class defines a <code>User</code> model that inherits from the <code>db.Model</code> class.</li>
<li><code>__tablename__ = 'users'</code> allows us to have a custom name for the table – a <em class="italic">Class User</em> model with a corresponding table name, <code>users</code>. If this is not specified, the lowercase class name (<code>user</code>) will be used.</li>
<li>Then, we add the<a id="_idIndexMarker557"/> columns for the table. Each<a id="_idIndexMarker558"/> column is an object of the <code>Column</code> subclass of SQLAlchemy:<ul><li><code>User_id = db.Column(db.Integer, primary_key=True,nullable=False)</code> defines a primary key column named <code>user_id</code> with an <code>Integer</code> data type</li>
<li><code>username = db.Column(db.String(50), unique=True, nullable=False)</code> defines a column named <code>username</code> with a <code>String</code> data type and enforces that it must be unique and not nullable</li>
<li><code>email = db.Column(db.String(120), unique=True, nullable=False)</code> defines a column named <code>email</code> with a <code>String</code> data type and enforces that it must be unique and not nullable</li>
<li><code>password = db.Column(db.String(256), nullable=False)</code> defines a column named <code>password</code> with a <code>String</code> data type and enforces that it must not be nullable</li>
<li><code>first_name = db.Column(db.String(50), nullable=False)</code> defines a column named <code>first_name</code> with a <code>String</code> data type and enforces that it must not be nullable</li>
<li><code>last_name = db.Column(db.String(50), nullable=False)</code> defines a column named <code>last_name</code> with a <code>String</code> data type and enforces that it must not be nullable</li>
<li><code>is_active = db.Column(db.Boolean, default=True)</code> defines a column named <code>is_active</code> with a b<code>oolean</code> data type and sets a default value of <code>True</code></li>
<li><code>is_superuser = db.Column(db.Boolean, default=False)</code> defines a column named <code>is_superuser</code> with a <code>Boolean</code> data type and sets a default value of <code>False</code></li>
</ul></li>
<li><code>def __repr__(self)</code> defines a method that returns a string representation of the <code>User</code> object.</li>
<li><code>return '&lt;User %r&gt;' % self.username</code> returns a string that includes the username of the <code>User</code> object.</li>
</ul>
<p>Now that we have defined the <code>User</code> class model, it’s time to create the <code>users</code> table in the database and pass in some data:</p>
<ol>
<li>Open a terminal<a id="_idIndexMarker559"/> in the project root directory<a id="_idIndexMarker560"/> and enter the <code>flask </code><code>shell</code> command.</li>
</ol>
<div><div><img alt="Figure 8.10 – A screenshot showing flask shell" src="img/Figure_8.10_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – A screenshot showing flask shell</p>
<ol>
<li value="2">Enter <code>from app import db</code> to connect with the database object.</li>
<li>Enter <code>db.create_all()</code> to create the <code>users</code> table.</li>
</ol>
<div><div><img alt="Figure 8.11 – A screenshot showing db.create_all()" src="img/Figure_8.11_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – A screenshot showing db.create_all()</p>
<ol>
<li value="4">Enter <code>from app import User</code> to gain access to the <code>User</code> model.</li>
<li>Add user data to the table using the <code>flask </code><code>shell</code> terminal:<pre class="source-code">user1=User(username='john',first_name='John',last_name='Stewart',email='admin@admin.com',password='password')</pre></li>
<li>Add <code>db.session.add(user1)</code> and <code>db.session.commit()</code> to add a user to the database session and a commit for data persistence in the database.</li>
<li>Enter <code>User.query.all()</code> to see the <code>users</code> table<a id="_idIndexMarker561"/> with the added<a id="_idIndexMarker562"/> information.</li>
</ol>
<div><div><img alt="Figure 8.12 – A screenshot showing flask shell with inserted data" src="img/Figure_8.12_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – A screenshot showing flask shell with inserted data</p>
<p>Next, we will discuss how you can add and track changes to your database structure with migrations.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor183"/>Migration with Alembic</h1>
<p>As discussed earlier, Alembic<a id="_idIndexMarker563"/> is a migration tool that makes the tracking of changes in a database<a id="_idIndexMarker564"/> a less problematic operation for Flask developers. Since we expect data models to change, we need a tool that can keep track of these changes and ensure they are updated in the database.</p>
<p>This is similar to how we do version control of source code using <code>Git</code>. The same applies to database schema change management, where we keep incremental and reversible changes in the database structure. Working with a database table, you will want to add or remove columns, thus altering the schema in a Python model class.</p>
<p>Once this is done, you need an automatic process to ensure your database table and the state of the data model schema are in sync. Alembic graciously handles the schema migration and ensures that the data model in a Python file is the same as the database structure.</p>
<p>Let’s examine how you can implement migration in a Flask application. We will add another model and use migration to track changes made to the database. Here, we add the <code>Speaker</code> model class.</p>
<p>Install <code>Flask-Migrate</code> with <code>pip</code>, as stated in the <em class="italic">Setting up </em><em class="italic">Alembic</em> section:</p>
<pre class="console">pip install Flask-Migrate</pre>
<p>Inside <code>app.py</code>, add the following snippet:</p>
<pre class="source-code">from flask import Flaskfrom flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =
    'sqlite:///bizza.db'
db = SQLAlchemy(app)
migrate = Migrate(app, db)
class Speaker(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), nullable=False)
    bio = db.Column(db.Text, nullable=False)
    photo = db.Column(db.String(100))
    contact_info = db.Column(db.String(100))
    user_id = db.Column(db.Integer,
        db.ForeignKey('users.user_id'), nullable=False)
    user = db.relationship('User',
        backref=db.backref('speaker', uselist=False))
    def __repr__(self):
        return f"Speaker('{self.name}', '{self.bio}',
            '{self.photo}', '{self.contact_info}')"
if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5000)</pre>
<p>A few changes were made to the <code>app.py</code> file, including the installation of the <code>flask-migrate</code> package, the creation of an instance of the <code>Migrate</code> class with the <code>app</code> and <code>db</code> instances<a id="_idIndexMarker565"/> as arguments, and the addition of a <code>speaker</code> model class that will be tracked<a id="_idIndexMarker566"/> upon its inclusion in the database.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor184"/>Running migrations</h2>
<p>Based on the changes<a id="_idIndexMarker567"/> made to <code>app.py</code> with the addition<a id="_idIndexMarker568"/> of the <code>speaker</code> model class, let’s implement migrations with Alembic:</p>
<ol>
<li>Firstly, inside the project directory, enter the <code>pip install flask-migrate</code> command. The <code>flask-migrate</code> extension provides database migration support for Flask applications.</li>
<li>To generate the initial migration in Flask, enter the following in the command terminal of the project root directory:<pre class="source-code"><code>migrations</code> in your Flask application directory.</p></li>
<li>Then, once you have initialized the migration repository, you can use the <code>flask db migrate</code> command to generate the first migration, based on changes you have made to your models. We have added the new speaker model to the <code>app.py</code> file.</li>
<li>Now, use the <code>flask db migrate -m 'first migration message, speaker model added'</code> command to generate a new migration script, based on the changes made to the database models. The <code>-m</code> flag is used to specify a message describing the changes made in the migration. The following command will create a new migration file with the changes specified in the models:<pre class="source-code"><strong class="bold">flask db init</strong><strong class="bold">flask db migrate -m "first migration speaker model"</strong></pre><p class="list-inset">The following screenshot shows the effects of the commands:</p></li>
</ol>
<div><div><img alt="Figure 8.13 – A screenshot showing the migration commands" src="img/Figure_8.13_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – A screenshot showing the migration commands</p>
<ol>
<li value="5">To commit the schema data model change to a database based on the state of the migration script, run the following command:<pre class="source-code"><strong class="bold">flask db upgrade</strong></pre><p class="list-inset">You will then get the following output:</p></li>
</ol>
<div><div><img alt="Figure 8.14 – A screenshot showing the flask db upgrade command" src="img/Figure_8.14_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – A screenshot showing the flask db upgrade command</p>
<p>This will apply all the pending<a id="_idIndexMarker569"/> migrations to your database<a id="_idIndexMarker570"/> schema. From this point on, you can continue to generate new migrations as needed using the <code>flask db </code><code>migrate</code> command.</p>
<p class="callout-heading">Note</p>
<p class="callout">To summarize the commands needed for Alembic migrations, follow these steps:</p>
<p class="callout"><strong class="bold">pip </strong><strong class="bold">install flask-migrate</strong></p>
<p class="callout"><strong class="bold">flask </strong><strong class="bold">db init</strong></p>
<p class="callout"><strong class="bold">flask db migrate -m “first migration message </strong><strong class="bold">speakers model”</strong></p>
<p class="callout"><strong class="bold">flask </strong><strong class="bold">db upgrade</strong></p>
<p>Alembic is a database migration tool for SQLAlchemy that helps keep the database schema in sync with the application’s data model. When using Alembic, you define changes to the data model in a series of migrations, which are Python scripts that modify the database schema.</p>
<p>These migrations are stored in a migration directory, and each migration is associated with a specific version of the schema. When you run a migration, Alembic compares the current state of the database schema to the target state defined in the migration. It then generates a set of SQL statements to modify the database schema to match the target state.</p>
<p>These SQL statements<a id="_idIndexMarker571"/> are executed in a transaction, which ensures<a id="_idIndexMarker572"/> that the database schema is modified in a consistent manner. With the use of Alembic to manage database migrations, you can ensure that the database schema remains in sync with the application’s data model as it evolves over time. This can help prevent data inconsistencies and other issues that can arise when the database schema and data model become out of sync.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor185"/>Summary</h1>
<p>In this chapter, we extensively discussed SQL and relational data modeling for the web. A relational database helps us with the design of a database as a group of relations. We also discussed relationships that can exist in a database, such as one-to-one, one-to-many, and many-to-many relationships, allowing us to logically group relations in the database and enforce data referential integrity.</p>
<p>Additionally, we examined how to set up PostgreSQL. We shed light on the basics of SQLAlchemy and its associated database adapters and how they are used in Flask application development. We discussed data model design, with the <em class="italic">Bizza</em> project as a use case. Finally, we discussed how a Flask app can communicate with the database and migration in Flask to keep track of changes in a database.</p>
<p>In the next chapter, we will extensively discuss the API in backend development and how you can use the Flask framework to implement API design.</p>
</div>
</body></html>