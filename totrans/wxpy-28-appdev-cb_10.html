<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Creating Components and Extending Functionality</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Customizing the<code class="literal"> ArtProvider</code></li><li class="listitem" style="list-style-type: disc">Adding controls to a<code class="literal"> StatusBar</code></li><li class="listitem" style="list-style-type: disc">Making a tool window</li><li class="listitem" style="list-style-type: disc">Creating a<code class="literal"> SearchBar</code></li><li class="listitem" style="list-style-type: disc">Working with<code class="literal"> ListCtrl</code> mixins</li><li class="listitem" style="list-style-type: disc"><code class="literal">StyledTextCtrl</code> custom highlighting</li><li class="listitem" style="list-style-type: disc">Creating a custom control</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Introduction</h1></div></div></div><p>Once you've been working with wxPython for a while, you may find that you need some functionality or behavior that is not provided by default with the common controls. So in order to get this, you need some level of customization, or even the creation of a completely new type of control may become necessary in order to provide the interface that your application and users need.</p><p>There is a fair amount of flexibility built into many controls to change their behavior through the use of their style flags. In this chapter however, we will explore some object-oriented approaches for creating new controls as well as extending the functionality of some of the standard controls through inheritance. So let's get going and jump into some recipes.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Customizing the ArtProvider</h1></div></div></div><p>The<code class="literal"> ArtProvider</code> is a singleton object that can be used by any component that wants to display system theme provided bitmaps. In wxPython 2.8, only the GTK (Linux) port has a native implementation of this object, so other platforms use the icons that are built into wxPython. These built-in icons are a bit dated and out-of-place looking to say the least. This recipe shows how to create a custom<code class="literal"> ArtProvider</code> to handle the display of custom icons on Windows and OS X while still retaining the native system theme icons on Linux.<a id="id363" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec01"/>How to do it...</h2></div></div></div><p>Here we define our custom<code class="literal"> ArtProvider</code> implementation, which just requires us to override the<code class="literal"> CreateBitmap</code> method, which is used to load our custom icons:<a id="id364" class="indexterm"/>
</p><div><pre class="programlisting">class TangoArtProvider(wx.ArtProvider):
    def __init__(self):
        super(TangoArtProvider, self).__init__()

        # Attributes
        self.bmps = [bmp.replace('.png', '')
                     for bmp in os.listdir('tango')
                     if bmp.endswith('.png')]

    def CreateBitmap(self, id,
                     client=wx.ART_OTHER,
                     size=wx.DefaultSize):

        # Return NullBitmap on GTK to allow
        # the default artprovider to get the
        # system theme bitmap.
        if wx.Platform == '__WXGTK__':
            return wx.NullBitmap

        # Non GTK Platform get custom resource
        # when one is available.
        bmp = wx.NullBitmap
        if client == wx.ART_MENU or size == (16,16):
            if id in self.bmps:
                path = os.path.join('tango', id+'.png')
                bmp = wx.Bitmap(path)
        else:
            # TODO add support for other bitmap sizes
            pass

        return bmp

</pre></div><p>Then all that we need to do in order to use the custom<code class="literal"> TangoArtProvider</code> in an application is to push it onto the<code class="literal"> ArtProvider</code> stack:</p><div><pre class="programlisting">class ArtProviderApp(wx.App):
    def OnInit(self):
        # Push our custom ArtProvider on to
        # the provider stack.
        wx.ArtProvider.PushProvider(TangoArtProvider())
        title = “Tango ArtProvider"
        self.frame = ArtProviderFrame(None,
                                      title=title)
        self.frame.Show()
        return True

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec02"/>How it works...</h2></div></div></div><p>The<code class="literal"> ArtProvider</code> singleton maintains a stack of<code class="literal"> ArtProvider</code> objects that are chained together. When calling<code class="literal"> GetBitmap</code> on the<code class="literal"> ArtProvider</code>, it will first ask the one at the top of the stack for the requested<code class="literal"> Bitmap</code>. If that one returns<code class="literal"> NullBitmap</code>, it will ask the next one, and so on and so forth until either the<code class="literal"> Bitmap</code> is found or the bottom of the stack is reached.<a id="id365" class="indexterm"/>
</p><p>All that needs to be done to create a custom<code class="literal"> ArtProvider</code> is to create a subclass that overrides the<code class="literal"> CreateBitmap</code> method. Our<code class="literal"> TangoArtProvider</code> overrides this method and provides a small set of icons from the free Tango (<a class="ulink" href="http://tango.freedesktop.org">http://tango.freedesktop.org</a>) icon set. We simply have a folder with some PNG images in it that we map to some of the wxPython<code class="literal"> ART_*</code> IDs and then load them from disk into a<code class="literal"> Bitmap</code> when requested.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec03"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Creating Singletons</em> recipe in<a class="link" href="ch09.html" title="Chapter 9. Design Approaches and Techniques"> Chapter 9</a>,<em> Design Approaches and Techniques</em> for an explanation of what singletons, such as the<code class="literal"> ArtProvider</code>, are.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec03"/>Adding controls to a StatusBar</h1></div></div></div><p>The<code class="literal"> StatusBar</code> is a common component found in many applications for the display of short information messages at the bottom of the main windows content area. The standard<code class="literal"> StatusBar</code> supports the display of multiple status text fields. This recipe shows how to create an advanced<code class="literal"> StatusBar</code> that has a<code class="literal"> Gauge</code> built-in to it in order to show progress during long-running tasks. Just as a sneak peak of what we are going to create, take a look at the following screenshot to see the<code class="literal"> ProgressStatusBar</code> in action:<a id="id366" class="indexterm"/>
</p><div><img src="img/1780_10_01.jpg" alt="Adding controls to a StatusBar"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec04"/>How to do it...</h2></div></div></div><p>First, we will create our<code class="literal"> ProgressStatusBar</code> class by creating a subclass of<code class="literal"> StatusBar</code>. In the constructor, we create the<code class="literal"> Gauge</code> for showing the progress and a<code class="literal"> Timer</code> to use for updating the<code class="literal"> Gauge:</code>
<a id="id367" class="indexterm"/>
</p><div><pre class="programlisting">class ProgressStatusBar(wx.StatusBar):
    """Custom StatusBar with a built-in progress bar"""
    def __init__(self, parent, id_=wx.ID_ANY,
                 style=wx.SB_FLAT,
                 name="ProgressStatusBar"):
        super(ProgressStatusBar, self).__init__(parent,
                                                id_,
                                                style,
                                                name)
  
        # Attributes
        self._changed = False   # position has changed ?
        self.busy = False       # Bar in busy mode ?
        self.timer = wx.Timer(self)
        self.prog = wx.Gauge(self, style=wx.GA_HORIZONTAL)
        self.prog.Hide() # Hide on init

        # Layout
        self.SetFieldsCount(2)
        self.SetStatusWidths([-1, 155])

        # Event Handlers
        self.Bind(wx.EVT_IDLE, 
                  lambda evt: self.__Reposition())
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.Bind(wx.EVT_SIZE, self.OnSize)

    def __del__(self):
        if self.timer.IsRunning():
            self.timer.Stop()

</pre></div><p>The following helper method is used to make sure that the<code class="literal"> Gauge</code> control is repositioned into the right-most status field when its<code class="literal"> Frame</code> changes position or size:<a id="id368" class="indexterm"/>
</p><div><pre class="programlisting">    def __Reposition(self):
        """Repositions the gauge as necessary"""
        if self._changed:
            lfield = self.GetFieldsCount() - 1
            rect = self.GetFieldRect(lfield)
            prog_pos = (rect.x + 2, rect.y + 2)
            self.prog.SetPosition(prog_pos)
            prog_size = (rect.width - 8, rect.height - 4)
            self.prog.SetSize(prog_size)
        self._changed = False

    def OnSize(self, evt):
        self._changed = True
        self.__Reposition()
        evt.Skip()

</pre></div><p>The<code class="literal"> Timer</code> event handler is used for handling when the<code class="literal"> Gauge</code> is being used in indeterminate mode to pulse the<code class="literal"> Gauge:</code>
</p><div><pre class="programlisting">    def OnTimer(self, evt):
        if not self.prog.IsShown():
            self.Stop()

        if self.busy:
            # In busy (indeterminate) mode
            self.prog.Pulse()

</pre></div><p>Starting here with the<code class="literal"> Run</code> method, we have added some public methods for manipulating the<code class="literal"> StatusBar's Gauge</code> from user code.</p><div><pre class="programlisting">    def Run(self, rate=100):
        if not self.timer.IsRunning():
            self.timer.Start(rate)

    def GetProgress(self):
        return self.prog.GetValue()

    def SetProgress(self, val):
        if not self.prog.IsShown():
            self.ShowProgress(True)

        # Check if we are finished
        if val == self.prog.GetRange():
            self.prog.SetValue(0)
            self.ShowProgress(False)
        else:
            self.prog.SetValue(val)

    def SetRange(self, val):
        if val != self.prog.GetRange():
            self.prog.SetRange(val)

    def ShowProgress(self, show=True):
        self.__Reposition()
        self.prog.Show(show)

    def StartBusy(self, rate=100):
        self.busy = True
        self.__Reposition()
        self.ShowProgress(True)
        if not self.timer.IsRunning():
            self.timer.Start(rate)

    def StopBusy(self):
        self.timer.Stop()
        self.ShowProgress(False)
        self.prog.SetValue(0)   # Reset progress value
        self.busy = False

    def IsBusy(self):
        """Is the gauge busy?"""
        return self.busy

</pre></div><p>See the sample code that accompanies this chapter for a sample application of the<code class="literal"> ProgressStatusBar</code> in action.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec05"/>How it works...</h2></div></div></div><p>The main trick to this recipe is the need to manually maintain the size and position of the<code class="literal"> Gauge</code> control so that it stays in the same relative place on the<code class="literal"> StatusBar</code>, regardless of how the window is moved or resized. We handled this with our<code class="literal"> __Reposition</code> method that simply positions and sizes the<code class="literal"> Gauge</code> based on the right-most field in the<code class="literal"> StatusBar</code>. Then we just call this method whenever we hide or show the Gauge, or when the window is resized, and during<code class="literal"> OnIdle</code> as necessary.<a id="id369" class="indexterm"/>
</p><p>The<code class="literal"> ProgressStatusBar</code> class supports two modes of operation for the progress gauge. The<code class="literal"> Gauge</code> can either be shown in busy mode (indeterminate) or in incremental mode. In busy mode, we just start and run a<code class="literal"> Timer</code> to<code class="literal"> Pulse</code> the<code class="literal"> Gauge</code> in the event handler. In incremental mode, the<code class="literal"> Gauge's</code> range is first set with<code class="literal"> SetRange</code> and then its progress is updated incrementally by the application as necessary by calling<code class="literal"> SetProgress</code>.<a id="id370" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec06"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Creating a custom SplashScreen</em> recipe in Chapter 5,<em> Providing Information and Alerting Users</em> for another example of using the Gauge control and Timers.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Making a tool window</h1></div></div></div><p>A<code class="literal"> ToolWindow</code> is a little floating window that often functions like a<code class="literal"> ToolBar</code> by having many different tool icons on it that can be clicked to initiate various actions. These types of windows are often seen in paint applications for holding pallets and other tools. This recipe shows how to create a simple<code class="literal"> ToolWindow</code> class.<a id="id371" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec07"/>How to do it...</h2></div></div></div><p>First let's define the base<code class="literal"> ToolWindow</code> class by deriving from<code class="literal"> MiniFrame</code> so that it will be a small, floating, top-level window:<a id="id372" class="indexterm"/>
</p><div><pre class="programlisting">import wx
import wx.lib.pubsub as pubsub

# message data will be tool id
MSG_TOOL_CLICKED = ('toolwin', 'clicked')

class ToolWindow(wx.MiniFrame):
    def __init__(self, parent, rows=1, columns=0, title=''):
        style = wx.CAPTION|wx.SYSTEM_MENU|\
                wx.SIMPLE_BORDER|wx.CLOSE_BOX
        super(ToolWindow, self).__init__(parent,
                                         title=title,
                                         style=style)

        # Attributes
        self.panel = ToolPanel(self, rows, columns)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)

    def AddTool(self, id, bmp, helplbl=''):
        """Add a tool to the window"""
        self.panel.AddTool(id, bmp, helplbl)
        self.Fit()

</pre></div><p>The<code class="literal"> ToolPanel</code> class acts as the container and manager for the tools that are added to the<code class="literal"> ToolWindow:</code>
<a id="id373" class="indexterm"/>
</p><div><pre class="programlisting">class ToolPanel(wx.Panel):
    """Panel to hold the tools"""
    def __init__(self, parent, rows, columns):
        super(ToolPanel, self).__init__(parent)

        # Attributes
        self.sizer = wx.FlexGridSizer(rows, columns, 5, 5)

        # Setup
        self.SetSizer(self.sizer)

        # Event Handlers
        self.Bind(wx.EVT_BUTTON, self.OnButton)

</pre></div><p>The<code class="literal"> AddTool</code> method takes the passed in ID and Bitmap and creates a<code class="literal"> BitmapButton</code> to use as the tool, and then simply adds this to the sizer's layout:</p><div><pre class="programlisting">    def AddTool(self, id, bmp, helplbl=''):
        tool = wx.BitmapButton(self, id, bmp)
        tool.SetToolTipString(helplbl)
        self.sizer.Add(tool)
        self.Layout()

</pre></div><p>The<code class="literal"> OnButton</code> handler catches all button clicks in the<code class="literal"> Panel</code> and then publishes a notification to all observers that have subscribed to tool messages:</p><div><pre class="programlisting">    def OnButton(self, event):
        """Notify clients when tool is clicked"""
        pubsub.Publisher.sendMessage(MSG_TOOL_CLICKED,
                                     event.GetId())

</pre></div><p>See the example code that accompanies this chapter for a sample text editor application that uses<code class="literal"> ToolWindow</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec08"/>How it works...</h2></div></div></div><p>Now that we have seen the code, let's take a quick walkthrough so we can see how it all works together.</p><p>Our<code class="literal"> ToolWindow</code> class is composed of a<code class="literal"> MiniFrame</code> and a<code class="literal"> Panel</code> that will have<code class="literal"> BitmapButtons</code> added to it when the client code calls its<code class="literal"> AddTool</code> method. The<code class="literal"> ToolWindow</code> has two arguments,<code class="literal"> rows</code> and<code class="literal"> columns</code>, that can specify the dimensions to use when laying out the tools in the<code class="literal"> ToolPanel's FlexGridSizer</code>. In order to ensure that the<code class="literal"> ToolWindow</code> is the correct size and that all of its tools are visible, it is necessary to call<code class="literal"> Layout</code> in the<code class="literal"> ToolPanel's AddTool</code> method, and then call<code class="literal"> Fit</code> on the<code class="literal"> ToolWindow</code> to ensure that the layout is recalculated and that the window is resized to best fit its contents.<a id="id374" class="indexterm"/>
</p><p>When a tool is clicked on the<code class="literal"> ToolWindow</code>, the event handler for the button simply uses<code class="literal"> pubsub</code> to send a message containing the tool's ID to any observers of the<code class="literal"> MSG_TOOL_CLICKED</code> topic. This method of notification was chosen because this way, if the application has multiple windows, they can all share the same<code class="literal"> ToolWindow</code> instead of each creating their own instance of it.<a id="id375" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec09"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Implementing an observer pattern</em> recipe in<a class="link" href="ch09.html" title="Chapter 9. Design Approaches and Techniques"> Chapter 9</a>,<em> Design Approaches and Techniques</em> for an in-depth discussion about using the observer pattern.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec05"/>Creating a SearchBar</h1></div></div></div><p>Search bars have become a fairly familiar component in many applications as an alternative to showing a<code class="literal"> FindDialog</code> that can cover part of the screen, obscuring the search area. There is no built-in control in wxPython that implements this functionality, so this recipe shows how to create a simple<code class="literal"> SearchBar</code> control.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec10"/>How to do it...</h2></div></div></div><p>Our<code class="literal"> SearchBar</code> control will be a composite control composed of a<code class="literal"> Panel</code> as the base, with a<code class="literal"> SearchCtrl</code> on it to allow for the search text to be entered:<a id="id376" class="indexterm"/>
</p><div><pre class="programlisting">class SearchBar(wx.Panel):
    def __init__(self, parent):
        style = wx.BORDER_RAISED
        super(SearchBar, self).__init__(parent,
                                        style=style)

        # Attributes
        self.search = wx.SearchCtrl(self,
                                    size=(250, -1),
                                    style=wx.TE_PROCESS_ENTER)
        self.lastfind = ''

        # Layout
        self.__DoLayout()

        # Event Handlers
        if wx.Platform in ['__WXMSW__', '__WXGTK__']:
            # Workaround for composite control on msw/gtk
            for child in self.search.GetChildren():
                if isinstance(child, wx.TextCtrl):
                    child.Bind(wx.EVT_KEY_UP, self.OnEnter)
                    break
        else:
            self.search.Bind(wx.EVT_KEY_UP, self.OnEnter)
        self.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.OnCancel)

    def __DoLayout(self):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.search, 0, wx.ALL, 2)
        self.SetSizer(sizer)

</pre></div><p>Here, in<code class="literal"> OnCancel</code>, we handle the cancel button event of the<code class="literal"> SearchCtrl</code> in order to clear the current search text and hide the cancel button:<a id="id377" class="indexterm"/>
</p><div><pre class="programlisting">    def OnCancel(self, event):
        self.search.SetValue("")
        self.search.ShowCancelButton(False)

</pre></div><p>
<code class="literal">OnEnter</code> will handle the keyboard events generated by the<code class="literal"> SearchCtrl</code>. We use it to see when the user has pressed the return key to initiate a search. We do this by creating a<code class="literal"> FindDialogEvent</code> to allow clients to bind to<code class="literal"> EVT_FIND</code> and handle the searching:</p><div><pre class="programlisting">    def OnEnter(self, event):
        """Send a search event"""
        code = event.GetKeyCode()
        val = self.search.GetValue()
        if code == wx.WXK_RETURN and val:
            if val == self.lastfind:
                etype = wx.wxEVT_COMMAND_FIND
            else:
                etype = wx.wxEVT_COMMAND_FIND_NEXT
            fevent = wx.FindDialogEvent(etype)
            fevent.SetFindString(val)
            self.ProcessEvent(fevent)
            self.lastfind = val
        else:
            show = bool(val)
            self.search.ShowCancelButton(show)

</pre></div><p>Running the example application that accompanies this recipe will result in a window like the following being shown:</p><div><img src="img/1780_10_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec11"/>How it works...</h2></div></div></div><p>This recipe shows how to make a very basic composite control. The<code class="literal"> SearchBar</code> is just a simple<code class="literal"> Panel</code> that has a<code class="literal"> SearchCtrl</code> on it. To use it in a<code class="literal"> Frame</code>, all that needs to be done is to create a vertical<code class="literal"> BoxSizer</code> and add the<code class="literal"> SearchBar</code> to this, so that it is positioned below or above the main content area in which the searches will take place. The Frame can then respond to the events that the<code class="literal"> SearchBar</code> emits. We had to do a few things in order to support the sending of a find event when the user presses the<em> Return</em> key in the<code class="literal"> SearchCtrl</code>. So let's take a look at that now.<a id="id378" class="indexterm"/>
</p><p>In the<code class="literal"> SearchBar's</code> constructor we had to define some special case code for Windows and Linux to be able to bind our<code class="literal"> EVT_KEY_UP</code> handler. This was necessary to work around a bug where the<code class="literal"> KeyEvents</code> don't propagate properly due to the<code class="literal"> SearchControl</code> being a composite control on those two platforms. On Macintosh, the<code class="literal"> SearchCtrl</code> is a native widget so the event binding works normally. Next, in our<code class="literal"> OnEnter</code> event handler, we check the value of the text in the control and generate either an<code class="literal"> EVT_FIND</code> or<code class="literal"> EVT_FIND_NEXT</code> event depending on the context of the search. Since these are command events, calling<code class="literal"> self.ProcessEvent</code> will start the processing of our<code class="literal"> FIND</code> event in the event handler chain allowing it to propagate until it is handled.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec12"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Understanding event propagation</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Responding to Events"> Chapter 2</a>,<em> Responding to Events</em> for a discussion of how events work.</li><li class="listitem" style="list-style-type: disc">See the<em> Using a BoxSizer</em> recipe in<a class="link" href="ch07.html" title="Chapter 7. Window Layout and Design"> Chapter 7</a>,<em> Window Layout and Design</em> for an explanation of how to use BoxSizers to perform window layout control.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Working with ListCtrl mixins</h1></div></div></div><p>Like the<code class="literal"> TreeCtrl</code>, there are a number of mixin classes available to extend the functionality of the standard<code class="literal"> ListCtrl</code>. This recipe provides an introduction to using the<code class="literal"> CheckListCtrlMixin, ListRowHighlighter</code>, and<code class="literal"> ListCtrlAutoWidthMixin</code> mixin classes to create a<code class="literal"> ListCtrl</code> that allows the selection of multiple items by using<code class="literal"> CheckBoxes</code>.<a id="id379" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec13"/>How to do it...</h2></div></div></div><p>Here, we will define our base<code class="literal"> CheckListCtrl</code> class that uses three mixin classes to customize the control's look and feel, as well as add checkboxes:</p><div><pre class="programlisting">import wx
import wx.lib.mixins.listctrl as listmix

class CheckListCtrl(wx.ListCtrl,
                    listmix.CheckListCtrlMixin,
                    listmix.ListRowHighlighter,
                    listmix.ListCtrlAutoWidthMixin):
    def __init__(self, *args, **kwargs):
        wx.ListCtrl.__init__(self, *args, **kwargs)
        listmix.CheckListCtrlMixin.__init__(self)
        listmix.ListRowHighlighter.__init__(self)
        listmix.ListCtrlAutoWidthMixin.__init__(self)

        # Attributes
        self._observers = list()

</pre></div><p>Here, we override the<code class="literal"> CheckListCtlrMixin's OnCheckItem</code> method and implement an observer interface to notify clients when a<code class="literal"> CheckBox</code> in the list is toggled:</p><div><pre class="programlisting">    def OnCheckItem(self, index, flag):
        """Overrides CheckListCtrlMixin.OnCheckItem 
        callback"""
        # Notify observers that a checkbox was 
        # checked/unchecked
        for observer in self._observers:
            observer(index, flag)

</pre></div><p>All that's remaining is to add a<code class="literal"> GetItems</code> method to return the list of checked items, and another method to allow clients to register themselves as observers of when items are checked in the control:</p><div><pre class="programlisting">    def GetItems(self, checked=True):
        """Gets a list of all the (un)checked items"""
        indexes = list()
        for index in range(self.GetItemCount()):
            if self.IsChecked(index) == checked:
                indexes.append(index)
        return indexes

    def RegisterObserver(self, callback):
        """Register OnCheckItem callback
        @param callaback: callable(index, checked)
        """
        self._observers.append(callback)

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec14"/>How it works...</h2></div></div></div><p>In this recipe, we created a general use base class,<code class="literal"> CheckListCtrl</code>, that will have the following extended features. It will have a<code class="literal"> CheckBox</code> on each row in column 0, alternate rows will have their backgrounds highlighted, and the rightmost column of the<code class="literal"> ListCtrl</code> will automatically be sized to fill the remaining space in the control. Each of these features are provided by the<code class="literal"> CheckListCtrlMixin, ListRowHighlighter</code>, and<code class="literal"> ListCtrlAutoWidthMixin</code> classes respectively.<a id="id380" class="indexterm"/>
</p><p>The<code class="literal"> CheckListCtrlMixin</code> provides an overridable method,<code class="literal"> OnCheckItem</code>, that will be called when one of the<code class="literal"> CheckBoxes</code> in the<code class="literal"> ListCtrl</code> is clicked on. We overrode this method and added a way for client code to register observer callback methods with the control. In this way, if any client code that uses this control wants to be notified when a<code class="literal"> CheckBox</code> is toggled, they can register their own observer methods.<a id="id381" class="indexterm"/>
</p><p>The last part of our<code class="literal"> CheckListCtrl</code> class is the<code class="literal"> GetItems</code> method that was added to make it easy to get a list of the indexes of all the checked or unchecked items in the control. Please see the sample code that accompanies this topic for a sample application that uses this new control:</p><div><img src="img/1780_10_03.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec15"/>There's more...</h2></div></div></div><p>The<code class="literal"> wx.lib.mixins.listctrl</code> module provides a couple more mixin classes for the<code class="literal"> ListCtrl</code>. Here is a quick reference to these other classes:<a id="id382" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mixin classes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ColumnSorterMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Helps handle the sorting of the items in the control when a column header is clicked on.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TextEditMixin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Makes it possible to edit the text in any column of a multi-column<code class="literal"> ListCtrl</code>.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec16"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Listing data with a ListCtrl</em> recipe in<a class="link" href="ch04.html" title="Chapter 4. Advanced Building Blocks of a User Interface"> Chapter 4</a>,<em> Advanced Building Blocks of a User Interface</em> for another example of using the<code class="literal"> ListCtrl</code>.</li><li class="listitem" style="list-style-type: disc">See the<em> Implementing an observer pattern</em> recipe in<a class="link" href="ch09.html" title="Chapter 9. Design Approaches and Techniques"> Chapter 9</a>,<em> Design Approaches and Techniques</em> for a discussion of using the observer pattern.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec07"/>StyledTextCtrl custom highlighting</h1></div></div></div><p>As discussed in the<em> StyledTextCtrl using lexers</em> section of Chapter 4,<em> Advanced Building Blocks of a User Interface</em>, the<code class="literal"> StyledTextCtrl</code> is a powerful source code editing component that has support for syntax-highlighting many different types of source code. However, if you find that you need to support some highlighting in your application that the<code class="literal"> StyledTextCtrl</code> doesn't have a built-in lexer for, you might think that you are out of luck. This isn't the case, though. Custom lexers can be added through the use of the special container lexer. This recipe shows how to write and use a custom lexer that does some simple highlighting.<a id="id383" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec17"/>How to do it...</h2></div></div></div><p>As a part of this recipe, we will create a simple little framework that can be extended to do other kinds of highlighting. Let's start with the<code class="literal"> BaseLexer</code> class, which defines a single method interface for handling the<code class="literal"> EVT_STC_STYLENEEDED</code> event that is generated by the<code class="literal"> StyledTextCtrl:</code>
</p><div><pre class="programlisting">import wx
import wx.stc

class BaseLexer(object):
    """Defines simple interface for custom lexer objects"""
    def __init__(self):
        super(BaseLexer, self).__init__()

    def StyleText(self, event):
        raise NotImplementedError

</pre></div><p>Next we have our example implementation of the<code class="literal"> VowelLexer</code>, which will provide text styling for all vowels in a document:</p><div><pre class="programlisting">class VowelLexer(BaseLexer):
    """Simple lexer to highlight vowels"""
    # Define some style IDs
    STC_STYLE_VOWEL_DEFAULT, \
    STC_STYLE_VOWEL_KW = range(2)
    def __init__(self):
        super(VowelLexer, self).__init__()
        
        # Attributes
        self.vowels = [ord(char) for char in "aeiouAEIOU"] 
</pre></div><p>The<code class="literal"> StyleText</code> method is what our custom<code class="literal"> StyledTextCtrl</code> will delegate to in its<code class="literal"> EVT_STC_STYLENEEDED</code> event handler. The<code class="literal"> VowelLexer</code> supports two different styles: one for its default style and another one for vowels.<a id="id384" class="indexterm"/>
</p><div><pre class="programlisting">    def StyleText(self, event):
        """Handle the EVT_STC_STYLENEEDED event"""
        stc = event.GetEventObject()
        # Last correctly styled character
        last_styled_pos = stc.GetEndStyled()
        # Get styling range for this call
        line = stc.LineFromPosition(last_styled_pos)
        start_pos = stc.PositionFromLine(line)
        end_pos = event.GetPosition()
        # Walk the line and find all the vowels to style
        # Note: little inefficient doing one char at a time
        #       but just to illustrate the process.
        while start_pos &lt; end_pos:
            stc.StartStyling(start_pos, 0x1f)
            char = stc.GetCharAt(start_pos)
            if char in self.vowels:
                # Set Vowel Keyword style
                style = VowelLexer.STC_STYLE_VOWEL_KW
            else:
                # Set Default style
                style = VowelLexer.STC_STYLE_VOWEL_DEFAULT
            # Set the styling byte information for 1 char from
            # current styling position (start_pos) with the
            # given style.
            stc.SetStyling(1, style)
            start_pos += 1

</pre></div><p>The<code class="literal"> CustomSTC</code> class will provide the framework for using<code class="literal"> BaseLexer-derived</code> classes to customize the highlighting of the text in the control:</p><div><pre class="programlisting">class CustomSTC(wx.stc.StyledTextCtrl):
    def __init__(self, *args, **kwargs):
        super(CustomSTC, self).__init__(*args, **kwargs)

        # Attributes
        self.custlex = None

        # Event Handlers
        self.Bind(wx.stc.EVT_STC_STYLENEEDED, self.OnStyle)

    def OnStyle(self, event):
        # Delegate to custom lexer object if one exists
        if self.custlex:
            self.custlex.StyleText(event)
        else:
            event.Skip()

    def SetLexer(self, lexerid, lexer=None):
        """Overrides StyledTextCtrl.SetLexer
        Adds optional param to pass in custom container
        lexer object.
        """
        self.custlex = lexer
        super(CustomSTC, self).SetLexer(lexerid)

</pre></div><p>Included with the sample code that accompanies this chapter is a simple application that uses the custom<code class="literal"> VowelLexer</code> class defined above.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec18"/>How it works...</h2></div></div></div><p>In this recipe, we first built a little framework for creating custom lexers for the<code class="literal"> StyledTextCtrl</code>. Starting with our<code class="literal"> BaseLexer</code> class, we defined a simple interface for objects that will delegate the task of handling<code class="literal"> EVT_STC_STYLENEEDED</code>. Next, we created the<code class="literal"> VowelLexer</code> class, which is a simple subclass of<code class="literal"> BaseLexer</code> that will highlight vowels in the text of a document. Applying styling in the<code class="literal"> StyledTextCtrl</code> involves three basic steps. First, you need to call<code class="literal"> StartStyling</code> to indicate the position in the buffer you wish to start styling text, then you need to determine what style byte to set, and finally you need to call<code class="literal"> SetStyling</code> to set how many characters from the start position to style with the given style.<a id="id385" class="indexterm"/>
</p><p>Now in order for the<code class="literal"> StyledTextCtrl</code> to make use of these lexers, we needed to do a couple things that we have encapsulated in the<code class="literal"> CustomSTC</code> class. The<code class="literal"> StyledTextCtrl</code> needs to bind to<code class="literal"> EVT_STC_STYLENEEDED</code> and set the<code class="literal"> STC_LEX_CONTAINER</code> lexer. The<code class="literal"> StyledTextCtrl</code> will generate<code class="literal"> EVT_STC_STYLEDNEEDED</code> when the container lexer is the current lexer and when it detects that some of the text in the buffer may need to be restyled due to changes in its contents. To handle this in our<code class="literal"> CustomSTC</code> class, we simply delegate the event to the current lexer object that was set by the call to our overridden<code class="literal"> SetLexer</code> method.<a id="id386" class="indexterm"/>
</p><p>Finally, we have a super-simple sample application that shows how our<code class="literal"> CustomSTC</code> and<code class="literal"> VowelLexer</code> can be used in an application. First, we needed to set up the styling by calling<code class="literal"> SetStyleSpec</code> to set which colors will be applied for our lexer's two-style bytes. The<code class="literal"> STC_STYLE_VOWEL_DEFAULT</code> will be styled with plain black text, and<code class="literal"> STC_STYLE_VOWEL_KW</code> will be styled with red text. Then, all is left is to call<code class="literal"> SetLexer</code> to set the<code class="literal"> STC_LEX_CONTAINER</code> lexer and create an instance of our<code class="literal"> VowelLexer</code> for the control to use. So give it a run and see that as you type into the buffer, all vowels should be colored red.<a id="id387" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec19"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> StyledTextCtrl using lexers</em> recipe in<a class="link" href="ch04.html" title="Chapter 4. Advanced Building Blocks of a User Interface"> Chapter 4</a>,<em> Advanced Building Blocks of a User Interface</em> for another example of using the<code class="literal"> StyleTextCtrl</code>.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec08"/>Creating a custom control</h1></div></div></div><p>At some point, you may need to invent an entirely new control to fit some specific requirement of your application. So in this recipe we will take a look at some techniques for creating a new control completely from scratch. We will create a custom<code class="literal"> CheckBox</code> control that has its label below the<code class="literal"> CheckBox</code>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec20"/>How to do it...</h2></div></div></div><p>To get started, we will define the constructor of the<code class="literal"> CustomCheckBox</code> control as a subclass of<code class="literal"> PyControl</code>. In the constructor, we bind to a number of events that will let us define the behavior of the control:<a id="id388" class="indexterm"/>
</p><div><pre class="programlisting">class CustomCheckBox(wx.PyControl):
    """Custom CheckBox implementation where label is
    below the CheckBox.
    """
    def __init__(self, parent, id_=wx.ID_ANY, label=""):
        style = wx.BORDER_NONE
        super(CustomCheckBox, self).__init__(parent,
                                             id_,
                                             style=style)

        # Attributes
        self.InheritAttributes()
        self._hstate = 0
        self._checked = False
        self._ldown = False
        self.SetLabel(label)

        # Event Handlers
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_ENTER_WINDOW,
                  lambda event:
                  self._SetState(wx.CONTROL_CURRENT))
        self.Bind(wx.EVT_LEAVE_WINDOW,
                  lambda event: self._SetState(0))

</pre></div><p>Next, we have this helper method to help manage what state the control is in with regards to the mouse:<a id="id389" class="indexterm"/>
</p><div><pre class="programlisting">    def _SetState(self, state):
        if self._hstate != state:
            if state == 0:
                self._ldown = False
            self._hstate = state
            self.Refresh()

    #-- Implementation --#

</pre></div><p>This is a virtual override of the<code class="literal"> PyControl's DoGetBestSize</code> method to control what the size of the control is:</p><div><pre class="programlisting">    def DoGetBestSize(self):
        lblsz = self.GetTextExtent(self.GetLabel())
        width = max(lblsz[0], 16) + 4 # 2px padding l/r
        height = lblsz[1] + 16 + 6
        best_sz = wx.Size(width, height)
        self.CacheBestSize(best_sz)
        return best_sz

    #-- Event Handlers --#

</pre></div><p>Next, we focus on the event handlers that will define the behavior of the control. First, in<code class="literal"> OnPaint</code>, we do the drawing that gives the control its appearance:</p><div><pre class="programlisting">    def OnPaint(self, event):
        dc = wx.AutoBufferedPaintDCFactory(self)
        gc = wx.GCDC(dc)
        renderer = wx.RendererNative.Get()

        # Setup GCDC
        rect = self.GetClientRect()
        bcolour = self.GetBackgroundColour()
        brush = wx.Brush(bcolour)
        gc.SetBackground(brush)
        gc.Clear()

        # Center checkbox
        cb_x = (rect.width - 16) / 2
        cb_y = 2 # padding from top
        cb_rect = wx.Rect(cb_x, cb_y, 16, 16)

        # Draw the checkbox
        state = 0
        if self._checked:
            state = wx.CONTROL_CHECKED
        if not self.IsEnabled():
            state |= wx.CONTROL_DISABLED
        renderer.DrawCheckBox(self, dc, cb_rect,
                              state|self._hstate)

        # Draw the label
        lbl_rect = wx.Rect(0, cb_rect.bottom, rect.width,
                           rect.height - cb_rect.height)
        gc.DrawLabel(self.GetLabel(),
                     lbl_rect,
                     wx.ALIGN_CENTER)

    def OnErase(self, event):
        pass # do nothing

</pre></div><p>The next two event handlers manage the mouse click state in the control to toggle the<code class="literal"> CheckBox</code> state:<a id="id390" class="indexterm"/>
</p><div><pre class="programlisting">    def OnLeftDown(self, event):
        self._ldown = True
        event.Skip()

    def OnLeftUp(self, event):
        if self._ldown:
            self._ldown = False
            self._checked = not self._checked
            self.Refresh()
            # Generate EVT_CHECKBOX event
            etype = wx.wxEVT_COMMAND_CHECKBOX_CLICKED
            chevent = wx.CommandEvent(etype, self.GetId())
            chevent.SetEventObject(self)
            self.ProcessEvent(chevent)
        event.Skip()

</pre></div><p>Last but not least, we define a couple of methods to implement part of the<code class="literal"> wx.CheckBox</code> interface:</p><div><pre class="programlisting">    #---- Public Api ----#

    def SetValue(self, state):
        self._checked = state
        self.Refresh()

    def GetValue(self):
        return self._checked

    def IsChecked(self):
        return self.GetValue()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec21"/>How it works...</h2></div></div></div><p>This was a fairly simple control to implement, but it is a good example of some of the approaches to take when creating your own custom control. So let's break down each of the important parts and see how they affect the way in which the control works.<a id="id391" class="indexterm"/>
</p><p>First, in the constructor, we define three attributes to manage the state of the control:</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal"> self._hstate:</code> To hold the current highlight state of the control.</li><li class="listitem"><code class="literal"> self._checked:</code> To hold the<code class="literal"> CheckBox</code> state.</li></ol></div><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal"> self._ldown:</code> To hold when the left mouse button was clicked down in the control.</li></ol></div><p>Next, we<code class="literal"> Bind</code> to the events that are necessary to draw the control and implement its behavior. We made use of two paint events and four different mouse events. First, let's take a look at the mouse event handlers that are used to implement the control's behavior.</p><p>In<code class="literal"> OnLeftDown</code>, we simply set our<code class="literal"> self._ldown</code> flag to<code class="literal"> True</code> in order to indicate that the down-click action was initiated in this window and not elsewhere. Then, in the<code class="literal"> OnLeftUp</code> handler, if the<code class="literal"> self._ldown</code> flag is<code class="literal"> True</code>, we toggle the<code class="literal"> self._checked</code> flag to reflect the new<code class="literal"> CheckBox</code> state, and then call<code class="literal"> Refresh</code>. Calling<code class="literal"> Refresh</code> will cause an<code class="literal"> EVT_PAINT</code> event to be generated so that we can redraw the control in its new state with our<code class="literal"> OnPaint</code> handler. After this, we also generate an<code class="literal"> EVT_CHECKBOX</code> event in order to inform the application that the<code class="literal"> CheckBox</code> state has changed. The remaining two mouse events are used to update the control's highlight state when the mouse enters or leaves the controls area.</p><p>
<code class="literal">OnPaint</code> is where we draw the control and give it its appearance. We start in<code class="literal"> OnPaint</code> by creating our drawing contexts and setting up the background. Next, we calculate the position to draw the<code class="literal"> CheckBox</code> within the control's rectangle and use<code class="literal"> RendererNative</code> to draw the<code class="literal"> CheckBox</code> according to the control's current state. Then, all that is left is to draw the label below the<code class="literal"> CheckBox</code> using our<code class="literal"> GCDC's DrawLabel</code> method.<a id="id392" class="indexterm"/>
</p><p>To finish off the control, we added some methods to implement part of the regular interface for the<code class="literal"> CheckBox</code> so that the application code using this control can get and set the<code class="literal"> CheckBox</code> state:</p><div><img src="img/1780_10_04.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec22"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> for a discussion about overriding virtual methods.</li><li class="listitem" style="list-style-type: disc">See the Understanding event propagation recipe in<a class="link" href="ch02.html" title="Chapter 2. Responding to Events"> Chapter 2</a>,<em> Responding to Events</em> for more information on working with events.</li><li class="listitem" style="list-style-type: disc">See the<em> Drawing with RendererNative</em> recipe in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em> for another example of using<code class="literal"> RendererNative</code> for drawing native-looking controls.</li><li class="listitem" style="list-style-type: disc">See the<em> Reducing flicker in drawing routines</em> recipe in<a class="link" href="ch08.html" title="Chapter 8. Drawing to the Screen"> Chapter 8</a>,<em> Drawing to the Screen</em> for an explanation of how to reduce flicker in drawing routines.</li></ul></div></div></div></div>
</body></html>