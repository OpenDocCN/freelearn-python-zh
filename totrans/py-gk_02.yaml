- en: '*Chapter 1*: Optimal Python Development Life Cycle'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：最优Python开发生命周期'
- en: Keeping in mind your prior experience with Python, we have skipped the introductory
    details of the Python language in this chapter. First, we will have a short discussion
    of the broader open source Python community and its specific culture. That introduction
    is important, as this culture is reflected in code being written and shared by
    the Python community. Then, we will present the different phases of a typical
    Python project. Next, we will look at different ways of strategizing the development
    of a typical Python project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你之前对Python的经验，我们在本章中跳过了Python语言的入门细节。首先，我们将简要讨论更广泛的Python开源社区及其特定的文化。这个介绍很重要，因为这种文化体现在Python社区编写的和共享的代码中。然后，我们将介绍典型Python项目的不同阶段。接下来，我们将探讨制定典型Python项目开发策略的不同方法。
- en: Moving on, we will explore different ways of documenting the Python code. Later,
    we will look into various options of developing an effective naming scheme that
    can greatly help improve the maintenance of the code. We will also look into various
    options for using source control for Python projects, including situations where
    developers are mainly using Jupyter notebooks for development. Finally, we explore
    the best practices to deploy the code for use, once it is developed and tested.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨不同的方法来记录Python代码。稍后，我们将研究各种有效的命名方案选项，这可以极大地帮助提高代码的维护性。我们还将探讨在Python项目中使用源控制的各种选项，包括开发者主要使用Jupyter笔记本进行开发的情况。最后，我们将探讨一旦开发并测试后，如何部署代码以供使用的最佳实践。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Python culture and community
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文化和社区
- en: Different phases of a Python project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python项目的不同阶段
- en: Strategizing the development process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定开发策略
- en: Effectively documenting Python code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地记录Python代码
- en: Developing an effective naming scheme
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定有效的命名方案
- en: Exploring choices for source control
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索源控制的选择
- en: Understanding strategies for deploying the code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部署代码的策略
- en: Python development environments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python开发环境
- en: This chapter will help you understand the life cycle of a typical Python project
    and its phases so that you can fully utilize the power of Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你了解典型Python项目的生命周期及其各个阶段，以便你能够充分利用Python的强大功能。
- en: Python culture and community
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python文化和社区
- en: Python is an interpreted high-level language that was originally developed by
    Guido van Rossum in 1991\. The Python community is special in the sense that it
    pays close attention to how the code is written. For that, since the early days
    of Python, the Python community has created and maintained a particular flavor
    in its design philosophy. Today, Python is used in a wide variety of industries,
    ranging from education to medicine. But regardless of the industry in which it
    is used, the particular culture of the vibrant Python community is usually seen
    to be part and parcel of Python projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种由Guido van Rossum于1991年最初开发的解释型高级语言。Python社区的特殊之处在于它非常关注代码的编写方式。为此，自Python的早期以来，Python社区在其设计哲学中创造并维护了一种特定的风格。如今，Python被广泛应用于各种行业，从教育到医学。但无论在哪个行业中使用，充满活力的Python社区的独特文化通常被视为Python项目的组成部分。
- en: In particular, the Python community wants us to write simple code and avoid
    complexity wherever possible. In fact, there is an adjective, *Pythonic*, which
    means there are multiple ways to accomplish a certain task but there is a preferred
    way as per the Python community conventions and as per the founding philosophy
    of the language. Python nerds try their best to create artifacts that are as Pythonic
    as possible. Obviously, *unpythonic code* means that we are not good coders in
    the eyes of these nerds. In this book, we will try to go as Pythonic as possible
    as we can in our code and design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是Python社区希望我们编写简洁的代码，并在可能的情况下避免复杂性。事实上，有一个形容词，*Pythonic*，意味着完成某个任务有多种方法，但根据Python社区的传统和语言的基础哲学，有一种首选的方法。Python爱好者们尽力创造尽可能符合Pythonic的成果。显然，*非Pythonic代码*意味着在这些爱好者眼中，我们并不是好的程序员。在这本书中，我们将尽力使我们的代码和设计尽可能符合Pythonic。
- en: And there is something official about being Pythonic as well. Tim Peters has
    concisely written the philosophy of Python in a short document, *The Zen of Python*.
    We know that Python is said to be one of the easiest languages to read, and *The
    Zen of Python* wants to keep it that way. It expects Python to be explicit through
    good documentation and as clean and clear as possible. We can read *The Zen of
    Python* ourselves, as explained next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Pythonic还有一些官方的规定。Tim Peters将Python的哲学简洁地写在一个简短的文档中，名为《Python之禅》。我们知道Python被认为是最容易阅读的语言之一，而《Python之禅》希望保持这种风格。它期望Python通过良好的文档保持清晰和简洁。我们可以自己阅读《Python之禅》，如下所述。
- en: 'In order to read *The Zen of Python*, open up a Python console and run the
    `import this` command, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阅读《Python之禅》，请打开Python控制台并运行`import this`命令，如下截图所示：
- en: '![Figure 1.1 – The Zen of Python'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – Python之禅'
- en: '](img/B17189_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17189_01_01.jpg](img/B17189_01_01.jpg)'
- en: Figure 1.1 – The Zen of Python
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Python之禅
- en: '*The Zen of Python* seems to be a cryptic text discovered in an old Egyptian
    tomb. Although it is deliberately written in this casual cryptic way, there is
    a deeper meaning to each line of text. Actually, look closer—it can be used as
    a guideline to code in Python. We will refer to different lines from *The Zen
    of Python* throughout the book. Let''s first look into some excerpts from it,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python之禅》似乎是一篇在古老的埃及墓穴中发现的神秘文本。尽管它是故意以这种随意的神秘方式写成的，但每行文字都有更深的意义。实际上，仔细看看--它可以作为在Python中编码的指南。本书将参考《Python之禅》的不同行。让我们首先看看它的一些摘录，如下所示：
- en: '**Beautiful is better than ugly**: It is important to write code that is well-written,
    readable, and self-explanatory. Not only should it work—it should be beautifully
    written. While coding, we should avoid using shortcuts in favor of a style that
    is self-explanatory.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**美观比丑陋好**：编写易于阅读、易于理解且自我解释的代码很重要。不仅应该能工作，而且应该写得美观。在编码时，我们应该避免使用捷径，而应该选择自我解释的风格。'
- en: '**Simple is better than complex**: We should not unnecessarily complicate things.
    Whenever facing a choice, we should prefer the simpler solution. Nerdy, unnecessary,
    and complicated ways of writing code are discouraged. Even when it adds some more
    lines to the source code, simpler remains better than the complex alternative.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单比复杂好**：我们不应该无谓地使事情复杂化。面对选择时，我们应该选择更简单的解决方案。反对那些笨拙的、不必要的和复杂的编码方式。即使这会增加一些源代码的行数，简单仍然比复杂的替代方案更好。'
- en: '**There should be one-- and preferably only one --obvious way to do it**: In
    broader terms, for a given problem there should be one possible best solution.
    We should strive to discover this. As we iterate through the design to improve
    it, regardless of our approach, our solution is expected to evolve and converge
    toward that preferable solution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该只有一个--最好是只有一个--明显的做法**：从更广泛的角度来看，对于给定的问题，应该有一个可能的最佳解决方案。我们应该努力发现这个解决方案。在我们迭代设计以改进它时，无论我们的方法如何，我们的解决方案都应预期会发展和收敛到那个更可取的解决方案。'
- en: '**Now is better than never**: Instead of waiting for perfection, let''s start
    solving the given problem using the information, assumptions, skills, tools, and
    infrastructure we have. Through the process of iteration, we will keep improving
    the solution. Let''s keep things moving instead of idling. Do not slack while
    waiting for the perfect time. Chances are that the perfect time will never come.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现在比永远好**：与其等待完美，不如利用我们已有的信息、假设、技能、工具和基础设施开始解决给定的问题。通过迭代过程，我们将不断改进解决方案。让我们保持前进，而不是停滞不前。在等待完美的时机时不要放松。可能性很大，完美的时机永远不会到来。'
- en: '**Explicit is better than implicit**: The code should be as self-explanatory
    as possible. This should be reflected in the choice of variable names, the class,
    and the function design, as well as in the overall **end-to-end** (**E2E**) architecture.
    It is better to err on the side of caution. Always make it more explicit whenever
    facing a choice.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明确比隐晦好**：代码应该尽可能自我解释。这应该体现在变量名、类和函数设计的选择上，以及整体**端到端**（**E2E**）架构中。在面临选择时，最好谨慎行事。总是使它更加明确。'
- en: '**Flat is better than nested**: A nested structure is concise but also creates
    confusion. Prefer a flat structure wherever possible.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扁平比嵌套好**：嵌套结构简洁，但也会造成混淆。尽可能选择扁平结构。'
- en: Different phases of a Python project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python项目的不同阶段
- en: 'Before we discuss the optimal development life cycle, let''s start by identifying
    the different phases of a Python project. Each phase can be thought of as a group
    of activities that are similar in nature, as illustrated in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论最佳开发生命周期之前，让我们首先确定Python项目的不同阶段。每个阶段可以被视为一组性质相似的活动，如下面的图所示：
- en: '![Figure 1.2 – Various phases of a Python project'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – Python项目的各个阶段]'
- en: '](img/B17189_01_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_01_02.jpg]'
- en: Figure 1.2 – Various phases of a Python project
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – Python项目的各个阶段
- en: 'The various phases of a typical Python project are outlined here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 典型Python项目的各个阶段如下概述：
- en: '**Requirement analysis**: This phase is about collecting the requirements from
    all key stakeholders and then analyzing them to understand *what* needs to be
    done and later think about the *how* part of it. The stakeholders can be our actual
    users of the software or business owners. It is important to collect the requirements
    in as much detail as possible. Wherever possible, requirements should be fully
    laid out, understood, and discussed with the end user and stakeholders before
    starting the design and development.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求分析**：这个阶段是关于从所有关键利益相关者那里收集需求，然后分析它们以了解需要做什么，并随后考虑如何去做。利益相关者可以是我们的软件的实际用户或业务所有者。尽可能详细地收集需求是很重要的。在可能的情况下，需求应在开始设计和开发之前，与最终用户和利益相关者充分展开、理解和讨论。'
- en: An important point is to ensure that the requirement-analysis phase should be
    kept out of the iterative loop of the design, development, and testing phases.
    Requirement analysis should be fully conducted and complete before moving on to
    the next phases. The requirements should include both **functional requirements**
    (**FRs**) and **non-functional requirements** (**NFRs**). FRs should be grouped
    into modules. Within each module, the requirements should be numbered in an effort
    to map them as closely as possible with the code modules.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个重要的要点是确保需求分析阶段不应包含在设计、开发和测试阶段的迭代循环中。需求分析应该在进入下一阶段之前完全进行并完成。需求应包括**功能性需求**（**FRs**）和**非功能性需求**（**NFRs**）。FRs应分组到模块中。在每个模块内，需求应编号，以便尽可能紧密地与代码模块对应。
- en: '**Design**: Design is our technical response to the requirements as laid out
    in the requirement phase. In the design phase, we figure out the *how* part of
    the equation. It is a creative process where we use our experience and skills
    to come up with the right set and structure of modules and the interactions between
    them in the most efficient and optimal way.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：设计是我们对需求阶段中提出的技术的响应。在设计阶段，我们确定等式中的“如何”部分。这是一个创造性的过程，我们利用我们的经验和技能，以最有效和最优化的方式提出正确的模块集和结构，以及它们之间的交互。'
- en: Note that coming up with the right design is an important part of a Python project.
    Any missteps in the design phase will be much more expensive to correct than missteps
    in later phases. By some measure, it takes 20 times more effort to change the
    design and implement the design changes in the subsequent phases (for example,
    coding phase), as compared to a similar degree of changes if they happen in the
    coding phase—for example, the inability to correctly identify classes or figure
    out the right data and compute the dimension of the project will have a major
    impact as compared to a mistake when implementing a function. Also, because coming
    up with the right design is a conceptual process, mistakes may not be obvious
    and cannot be caught by testing. On the other hand, errors in the coding will
    be caught by a well-thought-out exception-handling system.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，提出正确的设计是Python项目的一个重要部分。在设计阶段犯的任何错误，其纠正成本将远高于后续阶段的错误。在某些程度上，改变设计和在后续阶段（例如编码阶段）实施设计变更所需的努力是编码阶段发生类似程度变更的20倍（例如，无法正确识别类或确定正确的数据和计算项目的维度将产生重大影响，与实现函数时的错误相比）。此外，因为提出正确的设计是一个概念过程，错误可能不明显，无法通过测试来捕捉。另一方面，编码中的错误将通过精心设计的异常处理系统被捕捉到。
- en: 'In the design phase, we perform the following activities:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设计阶段，我们执行以下活动：
- en: a) We design the structure of the code and identify the modules within the code.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 我们设计代码的结构并确定代码中的模块。
- en: b) We decide the fundamental approach and decide whether we should be using
    functional programming, OOP, or a hybrid approach.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 我们决定基本方法，并决定是否应该使用函数式编程、面向对象编程或混合方法。
- en: c) We also identify the classes and functions and choose the names of these
    higher-level components.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 我们还识别出类和函数，并选择这些较高层次组件的名称。
- en: We also produce higher-level documentation.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还生成较高层次的文档。
- en: '**Coding**: This is the phase where we will implement the design using Python.
    We start by implementing the higher-level abstractions, components, and modules
    identified by the design first, followed by the detailed coding. We will keep
    a discussion about the coding phase to a minimum in this section as we will discuss
    it extensively throughout the book.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码**：这是我们将使用Python实现设计的阶段。我们首先实现设计中所识别的较高层次的抽象、组件和模块，然后进行详细编码。在本节中，我们将尽量减少对编码阶段的讨论，因为我们在整本书中会对其进行详细讨论。'
- en: '**Testing**: Testing is the process of verifying our code.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：测试是验证我们代码的过程。'
- en: '**Deployment**: Once thoroughly tested, we need to hand over the solution to
    the end user. The end user should not see the details of our design, coding, or
    testing. Deployment is the process of providing a solution to the end user that
    can be used to solve the problem as detailed in the requirements. For example,
    if we are working to develop a **machine learning** (**ML**) project to predict
    rainfall in Ottawa, the deployment is about figuring out how to provide a usable
    solution to the end user.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：一旦彻底测试，我们需要将解决方案交给最终用户。最终用户不应看到我们的设计、编码或测试的细节。部署是将解决方案提供给最终用户的过程，该解决方案可以用来解决需求中详细说明的问题。例如，如果我们正在开发一个预测渥太华降雨的机器学习（ML）项目，部署就是找出如何向最终用户提供一个可用的解决方案。'
- en: Having understood what the different phases of a project are, we will move on
    to see how we can strategize the overall process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了项目的不同阶段之后，我们将继续探讨如何制定整体过程。
- en: Strategizing the development process
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定开发过程策略
- en: 'Strategizing the development process is about planning each of the phases and
    looking into the process flow from one phase to another. To strategize the development
    process, we need to first answer the following questions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 制定开发过程策略是关于规划每个阶段，并查看从一个阶段到另一个阶段的过程流程。为了制定开发过程策略，我们首先需要回答以下问题：
- en: Are we looking for a minimal design approach and going straight to the coding
    phase with little design?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否寻求最小化设计方法，并直接进入编码阶段，而设计较少？
- en: Do we want **test-driven development** (**TDD**), whereby we first create tests
    using the requirements and then code them?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否希望采用**测试驱动开发**（**TDD**），即首先使用需求创建测试，然后编写代码？
- en: Do we want to create a **minimum viable product** (**MVP**) first and iteratively
    evolve the solution?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是希望首先创建一个**最小可行产品**（**MVP**）并迭代地完善解决方案吗？
- en: What is the strategy for validating NFRs such as security and performance?
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证NFRs（如安全性和性能）的策略是什么？
- en: Are we looking for a single-node development, or do we want to develop and deploy
    on the cluster or in the cloud?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是寻求单节点开发，还是希望在集群或云端进行开发和部署？
- en: What are the volume, velocity, and variety of our **input and output** (**I/O**)
    data? Is it a **Hadoop distributed file system** (**HDFS**) or **Simple Storage
    Service** (**S3**) file-based structure, or a **Structured Query Language** (**SQL**)
    or NoSQL database? Is the data on-premises or in the cloud?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入和输出的数据量、速度和种类是什么？是**Hadoop分布式文件系统**（**HDFS**）或**简单存储服务**（**S3**）基于文件的架构，还是**结构化查询语言**（**SQL**）或NoSQL数据库？数据是在本地还是云端？
- en: Are we working on specialized use cases such as ML with specific requirements
    for creating data pipelines, testing models, and deploying and maintaining them?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否在处理特定的用例，例如具有创建数据管道、测试模型、部署和维护特定要求的机器学习（ML）？
- en: Based on the answers to these questions, we can strategize the steps for our
    development process. In more recent times, it is always preferred to use iterative
    development processes in one form or another. The concept of MVP as a starting
    goal is also popular. We will discuss these in the next subsections, along with
    the domains' specific development needs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些问题的答案，我们可以为我们的开发过程制定策略。在最近的时间里，总是更倾向于以某种形式使用迭代开发过程。将MVP作为起始目标的概念也很流行。我们将在下一小节中讨论这些内容，以及特定领域的开发需求。
- en: Iterating through the phases
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历各个阶段
- en: Modern software development philosophy is based on short iterative cycles of
    design, development, and testing. The traditional waterfall model that was used
    in code development is long dead. Selecting the right granularity, emphasis, and
    frequency of these phases depends on the nature of the project and our choice
    of code development strategy. If we want to choose a code development strategy
    with minimum design and want to go straight to coding, then the design phase is
    thin. But even starting the code straight away will require some thought in terms
    of the design of modules that will eventually be implemented.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件开发哲学基于设计、开发和测试的短迭代周期。在代码开发中曾经使用的传统瀑布模型已经死去。选择这些阶段的正确粒度、重点和频率取决于项目的性质和我们的代码开发策略选择。如果我们想选择一个设计最少、直接进入编码的代码开发策略，那么设计阶段就非常薄。但即使直接开始编码，也需要对最终将实现的设计模块进行一些思考。
- en: No matter what strategy we choose, there is an inherent iterative relationship
    between the design, development, and testing phases. We initially start with the
    design phase, implement it in the coding phase, and then validate it by testing
    it. Once we have flagged the deficiencies, we need to go back to the drawing board
    by revisiting the design phase.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择什么策略，设计和开发、测试阶段之间都存在固有的迭代关系。我们最初从设计阶段开始，将其在编码阶段实现，然后通过测试来验证它。一旦我们发现了缺陷，我们就需要通过重新访问设计阶段回到起点。
- en: Aiming for MVP first
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先追求最小可行产品 (MVP)
- en: Sometimes, we select a small subject of the most important requirements to first
    implement the MVP with the aim of iteratively improving it. In an iterative process,
    we design, code, and test, until we create a final product that can be deployed
    and used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会选择最重要的需求的一个小主题，首先实现 MVP，目的是迭代地改进它。在迭代过程中，我们设计、编码和测试，直到我们创建一个可以部署和使用的最终产品。
- en: Now, let's talk about how we will implement the solution of some specialized
    domains in Python.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈我们将如何用 Python 实现一些特定领域的解决方案。
- en: Strategizing development for specialized domains
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为特定领域制定开发策略
- en: 'Python is currently being used for a wide variety of scenarios. Let''s look
    into the following five important use cases to see how we can strategize the development
    process for each of them according to their specific needs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 目前被用于各种场景。让我们看看以下五个重要的用例，看看我们如何根据它们的具体需求制定每个用例的开发策略：
- en: ML
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习
- en: Cloud computing and cluster computing
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算和集群计算
- en: Systems programming
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统编程
- en: Networking programming
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程
- en: Serverless computing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器计算
- en: We will discuss each of them in the following sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各节中讨论每个部分。
- en: ML
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机器学习
- en: Over the years, Python has become the most common language used for implementing
    ML algorithms. ML projects need to have a well-structured environment. Python
    has an extensive collection of high-quality libraries that are available for use
    for ML.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python 已经成为实现机器学习算法最常用的语言。机器学习项目需要一个结构良好的环境。Python 拥有一系列高质量库，这些库可用于机器学习。
- en: 'For a typical ML project, there is a **Cross-Industry Standard Process for
    Data Mining** (**CRISP-DM**) life cycle that specifies various phases of an ML
    project. A CRISP-DM life cycle looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的机器学习项目，有一个 **数据挖掘跨行业标准流程** (**CRISP-DM**) 生命周期，它规定了机器学习项目的各个阶段。CRISP-DM
    生命周期看起来是这样的：
- en: '![Figure 1.3 – A CRISP-DM life cycle'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – CRISP-DM 生命周期'
- en: '](img/B17189_01_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_01_03.jpg)'
- en: Figure 1.3 – A CRISP-DM life cycle
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – CRISP-DM 生命周期
- en: 'For ML projects, designing and implementing data pipelines is estimated to
    be almost 70% of the development effort. While designing data processing pipelines,
    we should keep in mind that the pipelines will ideally have these characteristics:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机器学习项目，设计和实现数据管道预计占开发工作的 70% 左右。在设计数据处理管道时，我们应该记住，理想情况下，管道将具有以下特征：
- en: They should be scalable.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该是可扩展的。
- en: They should be reusable as far as possible.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，它们应该是可重用的。
- en: They should process both streaming and batch data by conforming to **Apache
    Beam** standards.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们应该通过遵循 **Apache Beam** 标准来处理流式和批量数据。
- en: They should mostly be a concatenation of fit and transform functions, as we
    will discuss in [*Chapter 6*](B17189_06_Final_PG_ePub.xhtml#_idTextAnchor188),
    *Advanced Tips and Tricks in Python*.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该主要是 fit 和 transform 函数的连接，正如我们将在 [*第 6 章*](B17189_06_Final_PG_ePub.xhtml#_idTextAnchor188)
    中讨论的，*Python 高级技巧与窍门*。
- en: Also, an important part of the testing phase for ML projects is the model evaluation.
    We need to figure out which of the performance metrics is the best one to quantify
    the performance of the model according to the requirement of the problem, nature
    of the data, and type of algorithm being implemented. Are we looking at accuracy,
    precision, recall, F1 score, or a combination of these performance metrics? Model
    evaluation is an important part of the testing process and needs to be conducted
    in addition to the standard testing done in other software projects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，机器学习项目测试阶段的一个重要部分是模型评估。我们需要确定根据问题的需求、数据的性质和所实现的算法类型，哪个性能指标是最好的来量化模型的性能。我们是关注准确度、精确度、召回率、F1
    分数，还是这些性能指标的组合？模型评估是测试过程中的一个重要部分，并且需要在其他软件项目中进行的标准测试之外进行。
- en: Cloud computing and cluster computing
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云计算和集群计算
- en: Cloud computing and cluster computing add additional complexity to the underlying
    infrastructure. Cloud service providers offer services that need specialized libraries.
    The architecture of Python, which starts with bare-minimum core packages and the
    ability to import any further package, makes it well suited for cloud computing.
    The platform independence offered by a Python environment is critical for cloud
    and cluster computing. **Python** is the language of choice for **Amazon Web Services**
    (**AWS**), Windows Azure, and Google Cloud Platform (GCP).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算和集群计算给底层基础设施增加了额外的复杂性。云服务提供商提供需要专用库的服务。Python 的架构从最基本的核心包开始，并具有导入任何其他包的能力，这使得它非常适合云计算。Python
    环境提供的平台独立性对于云计算和集群计算至关重要。**Python** 是 **Amazon Web Services** (**AWS**), Windows
    Azure 和 Google Cloud Platform (GCP) 的首选语言。
- en: Cloud computing and cluster computing projects have separate development, testing,
    and production environments. It is important to keep the development and production
    environments in sync.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算和集群计算项目有独立的开发、测试和生产环境。保持开发和生产环境同步非常重要。
- en: When using **infrastructure-as-a-service** (**IaaS**), Docker containers can
    help a lot, and it is recommended to use them. Once we are using the Docker container,
    it does not matter where we are running the code as the code will have exactly
    the same environment and dependencies.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **基础设施即服务** (**IaaS**) 时，Docker 容器可以大有帮助，并且建议使用它们。一旦我们使用 Docker 容器，代码在哪里运行就无关紧要了，因为代码将具有完全相同的环境和依赖项。
- en: Systems programming
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统编程
- en: Python has interfaces to operating system services. Its core libraries have
    **Portable Operating System Interface** (**POSIX**) bindings that allow developers
    to create so-called shell tools, which can be used for system administration and
    various utilities. Shell tools written in Python are compatible across various
    platforms. The same tool can be used in Linux, Windows, and macOS without any
    change, making them quite powerful and maintainable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有操作系统服务的接口。其核心库有 **可移植操作系统接口** (**POSIX**) 绑定，允许开发者创建所谓的 shell 工具，这些工具可用于系统管理和各种实用程序。用
    Python 编写的 shell 工具可以在各种平台上兼容。相同的工具可以在 Linux、Windows 和 macOS 上使用，无需任何更改，这使得它们非常强大且易于维护。
- en: 'For example, a shell tool that copies a complete directory developed and tested
    in Linux can run unchanged in Windows. Python''s support for systems programming
    includes the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个在 Linux 上开发和测试的完整目录的 shell 工具可以在 Windows 上无需更改地运行。Python 对系统编程的支持包括以下内容：
- en: Defining environment variables
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义环境变量
- en: Support for files, sockets, pipes, processes, and multiple threads
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持文件、套接字、管道、进程和多线程
- en: Ability to specify a **regular expression** (**regex**) for pattern matching
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够指定用于模式匹配的 **正则表达式** (**regex**)
- en: Ability to provide command-line arguments
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够提供命令行参数
- en: Support for standard stream interfaces, shell-command launchers, and filename
    expansion
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持标准流接口、shell 命令启动器和文件名扩展
- en: Ability to zip file utilities
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够压缩文件实用工具
- en: Ability to parse **Extensible Markup Language** (**XML**) and **JavaScript Object
    Notation** (**JSON**) files
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够解析 **可扩展标记语言** (**XML**) 和 **JavaScript 对象表示法** (**JSON**) 文件
- en: When using Python for system development, the deployment phase is minimal and
    may be as simple as packaging the code as an executable file. It is important
    to mention that Python is not intended to be used for the development of system-level
    drivers or operating system libraries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Python进行系统开发时，部署阶段是最小的，可能只是将代码打包成可执行文件。重要的是要提到，Python不打算用于系统级驱动程序或操作系统库的开发。
- en: Network programming
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络编程
- en: 'In the digital transformation era where **Information Technology** (**IT**)
    systems are moving quickly toward automation, networks are considered the main
    bottleneck in full-stack automation. The reason for this is the propriety network
    operating systems from different vendors and a lack of openness, but the prerequisites
    of digital transformation are changing this trend and a lot of work is in progress
    to make the network programmable and consumable as a service (**network-as-a-service**,
    or **NaaS**). The real question is: *Can we use Python for network programming?*
    The answer is a big *YES*. In fact, it is one of the most popular languages in
    use for network automation.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字化转型时代，**信息技术**（**IT**）系统正快速向自动化方向发展，网络被认为是全栈自动化的主要瓶颈。其原因是不同供应商的专有网络操作系统以及缺乏开放性，但数字化转型的前提条件正在改变这一趋势，许多工作正在进行中，以使网络可编程并作为服务（**网络即服务**，或**NaaS**）提供。真正的问题是：*我们能否使用Python进行网络编程？*
    答案是肯定的 *YES*。事实上，它是用于网络自动化的最受欢迎的语言之一。
- en: 'Python support for network programming includes the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python对网络编程的支持包括以下内容：
- en: Socket programming including **Transmission Control Protocol** (**TCP**) and
    **User Datagram Protocol** (**UDP**) sockets
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）套接字的套接字编程
- en: Support for client and server communication
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持客户端和服务器通信
- en: Support for port listening and processing data
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持端口监听和处理数据
- en: Executing commands on a remote **Secure Shell** (**SSH**) system
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程**安全外壳**（**SSH**）系统上执行命令
- en: Uploading and downloading files using **Secure Copy Protocol** (**SCP**)/**File
    Transfer Protocol** (**FTP**)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**安全复制协议**（**SCP**）/**文件传输协议**（**FTP**）上传和下载文件
- en: Support for the library for **Simple Network Management Protocol** (**SNMP**)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持用于**简单网络管理协议**（**SNMP**）的库
- en: Support for the **REpresentational State Transfer** (**RESTCONF**) and **Network
    Configuration** (**NETCONF**) protocols for retrieving and updating configuration
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持用于检索和更新配置的**表示状态传输**（**RESTCONF**）和**网络配置**（**NETCONF**）协议
- en: Serverless computing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器计算
- en: Serverless computing is a cloud-based application execution model in which the
    **cloud service providers** (**CSPs**) provide the computer resources and application
    servers to allow developers to deploy and execute the applications without any
    hassle of managing the computing resources and servers themselves. All of the
    major public cloud vendors (Microsoft Azure Serverless Functions, AWS Lambda,
    and **Google Cloud Platform**, or **GCP**) support serverless computing for Python.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是一种基于云的应用程序执行模型，其中云服务提供商（CSPs）提供计算机资源和应用程序服务器，以允许开发者无需管理计算资源和服务器即可部署和执行应用程序。所有主要公共云供应商（Microsoft
    Azure Serverless Functions、AWS Lambda和**谷歌云平台**，或**GCP**）都支持Python的无服务器计算。
- en: We need to understand that there are still servers in a serverless environment,
    but those servers are managed by CSPs. As an application developer, we are not
    responsible for installing and maintaining the servers as well as having no direct
    responsibility for the scalability and performance of the servers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解，在无服务器环境中仍然存在服务器，但这些服务器由云服务提供商（CSPs）管理。作为应用程序开发者，我们不需要负责安装和维护服务器，也没有直接责任于服务器的可扩展性和性能。
- en: 'There are popular serverless libraries and frameworks available for Python.
    These are described next:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，有流行的无服务器库和框架可用。这些将在下面进行描述：
- en: '**Serverless**: The Serverless Framework is an open source framework for serverless
    functions or AWS Lambda services and is written using Node.js. Serverless is the
    first framework developed for building applications on AWS Lambda.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器**：无服务器框架是一个开源框架，用于无服务器函数或AWS Lambda服务，并使用Node.js编写。无服务器是第一个为在AWS Lambda上构建应用程序而开发的框架。'
- en: '**Chalice**: This is a Python serverless microframework developed by AWS. This
    is a default choice for developers who want to quickly spin up and deploy their
    Python applications using AWS Lambda Services, as this enables you to quickly
    spin up and deploy a working serverless application that scales up and down on
    its own as required, using AWS Lambda. Another key feature of Chalice is that
    it provides a utility to simulate your application locally before pushing it to
    the cloud.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chalice**：这是一个由 AWS 开发的 Python 无服务器微框架。这是开发者使用 AWS Lambda 服务快速启动和部署 Python
    应用程序的首选，因为它允许你快速启动和部署一个可自动扩展和缩放的运行服务器，使用 AWS Lambda。Chalice 的另一个关键特性是它提供了一个工具，可以在将应用程序推送到云端之前在本地模拟你的应用程序。'
- en: '**Zappa**: This is more of a deployment tool built into Python and makes the
    deployment of your **Web Server Gateway Interface** (**WSGI**) application easy.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zappa**：这是一个内置在 Python 中的部署工具，使得部署你的 **Web 服务器网关接口（WSGI**） 应用变得简单。'
- en: Now, let's look into effective ways of developing Python code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看开发 Python 代码的有效方法。
- en: Effectively documenting Python code
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效记录 Python 代码
- en: Finding an effective way to document code is always important. The challenge
    is to develop a comprehensive yet simple way to develop Python code. Let's first
    look into Python comments and then docstrings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个有效的方式来记录代码始终很重要。挑战在于开发一种全面而简单的方式来开发 Python 代码。让我们首先看看 Python 注释，然后是文档字符串。
- en: Python comments
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 注释
- en: 'In contrast with a docstring, Python comments are not visible to the runtime
    compiler. They are used as a note to explain the code. Comments start with a `#`
    sign in Python, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与文档字符串相反，Python 注释对运行时编译器不可见。它们用作解释代码的注释。Python 中的注释以 `#` 符号开始，如下面的屏幕截图所示：
- en: '![Figure 1.4 – An example of a comment in Python](img/B17189_01_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Python 中注释的一个示例](img/B17189_01_04.jpg)'
- en: Figure 1.4 – An example of a comment in Python
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Python 中注释的一个示例
- en: Docstring
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档字符串
- en: The main workhorse for documenting the code is the multiline comments block
    called a `"""`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码的主要工具是多行注释块，称为 `"""`）。
- en: 'Here are some general guidelines when creating a docstring:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文档字符串时，以下是一些一般性指南：
- en: A docstring should be placed right after the function or the class definition.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串应放置在函数或类定义之后。
- en: A docstring should be given a one-line summary followed by a more detailed description.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串应提供一个简短的总结，然后是更详细的描述。
- en: Blank spaces should be strategically used to organize the comments but they
    should not be overused. You can use blank lines to organize code, but don't use
    them excessively.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应有策略地使用空白空间来组织注释，但不应过度使用。你可以使用空白行来组织代码，但不要过度使用。
- en: In the following sections, let's take a look at more detailed concepts of docStrings.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，让我们看看文档字符串的更多详细概念。
- en: Docstring styles
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串风格
- en: 'A Python docstring has the following slightly different styles:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文档字符串有以下略微不同的风格：
- en: Google
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google
- en: NumPy/SciPy
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy/SciPy
- en: Epytext
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Epytext
- en: Restructured
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新结构化
- en: Docstring types
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串类型
- en: 'While developing the code, various types of documentation need to be produced,
    including the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，需要产生各种类型的文档，包括以下内容：
- en: Line-by-line commentary
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行内注释
- en: Functional or class-level documentation
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数或类级别文档
- en: Algorithmic details
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法细节
- en: Let's discuss them, one by one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论它们。
- en: Line-by-line commentary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行内注释
- en: 'One simple use of a docstring is to use it to create multiline comments, as
    shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个简单用途是使用它来创建多行注释，如下所示：
- en: '![Figure 1.5 – An example of a line-by-line commentary-type docstring'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – Python 中行内注释类型文档字符串的示例](img/B17189_01_05.jpg)'
- en: '](img/B17189_01_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_01_05.jpg)'
- en: Figure 1.5 – An example of a line-by-line commentary-type docstring
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Python 中行内注释类型文档字符串的示例
- en: Functional or class-level documentation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数或类级别文档
- en: 'A powerful use of a docstring is for functional or class-level documentation.
    If we place the docstring just after the definition of a function or a class,
    Python associates the docstring with the function or a class. This is placed in
    the `__doc__` attribute of that particular function or class. We can print that
    out at runtime by either using the `__doc__` attribute or by using the `help`
    function, as shown in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个强大用途是用于函数或类级别的文档。如果我们将文档字符串放置在函数或类的定义之后，Python 会将文档字符串与该函数或类关联起来。这被放置在该特定函数或类的
    `__doc__` 属性中。我们可以在运行时通过使用 `__doc__` 属性或使用 `help` 函数来打印出来，如下面的示例所示：
- en: '![Figure 1.6 – An example of the help function'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 帮助函数的示例](img/B17189_01_06.jpg)'
- en: '](img/B17189_01_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17189_01_06.jpg)'
- en: Figure 1.6 – An example of the help function
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 帮助函数的示例
- en: 'When using a docstring for documenting classes, the recommended structure is
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文档字符串记录类时，建议的结构如下：
- en: 'A summary: usually a single line'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要：通常是一行
- en: First blank line
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一空行
- en: Any further explanation regarding the docstring
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于文档字符串的任何进一步解释
- en: Second blank line
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二空行
- en: 'An example of using a docstring on the class level is shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了在类级别使用文档字符串的示例：
- en: '![Figure 1.7 – An example of a class-level docstring](img/B17189_01_07.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 类级别文档字符串的示例](img/B17189_01_07.jpg)'
- en: Figure 1.7 – An example of a class-level docstring
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 类级别文档字符串的示例
- en: Algorithmic details
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法细节
- en: More and more often, Python projects use descriptive or predictive analytics
    and other complex logic. The details of the algorithm that is used need to be
    clearly specified with all the assumptions that were made. If an algorithm is
    implemented as a function, then the best place to write the summary of the logic
    of the algorithm is before the signature of the function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的 Python 项目使用描述性或预测性分析以及其他复杂逻辑。所使用的算法的细节需要清楚地指定，包括所有做出的假设。如果一个算法作为函数实现，那么在函数签名之前写算法逻辑的总结是最好的地方。
- en: Developing an effective naming scheme
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发有效的命名方案
- en: If developing and implementing the right logic in code is science, then making
    it pretty and readable is an art. Python developers are famous for paying special
    attention to the naming scheme and bringing *The Zen of Python* into it. Python
    is one of the few languages that have comprehensive guidelines on the naming scheme
    written by Guido van Rossum. They are written in a *PEP 8* document that has a
    complete section on naming conventions, which is followed by many code bases.
    *PEP 8* has naming and style guidelines that are suggested. You can read more
    about it at [https://www.Python.org/dev/peps/pep-0008/](https://www.Python.org/dev/peps/pep-0008/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码中开发和实现正确的逻辑是科学，那么使其美观和可读是艺术。Python 开发者因其特别关注命名方案并将 *Python 的禅意* 带入其中而闻名。Python
    是少数几种由 Guido van Rossum 编写的关于命名方案的全面指南的语言之一。它们写在 *PEP 8* 文档中，该文档有一个关于命名约定的完整部分，许多代码库都遵循它。*PEP
    8* 提供了命名和风格指南的建议。您可以在 [https://www.Python.org/dev/peps/pep-0008/](https://www.Python.org/dev/peps/pep-0008/)
    上了解更多信息。
- en: 'The naming scheme suggested in *PEP 8* can be summarized as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEP 8* 中建议的命名方案可以总结如下：'
- en: In general, all module names should be `all_lower_case`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，所有模块名称都应该使用 `all_lower_case`。
- en: All class names and exception names should be `CamelCase`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类名和异常名应该使用 `CamelCase`。
- en: All global and local variables should be `all_lower_case`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有全局和局部变量都应该使用 `all_lower_case`。
- en: All functions and method names should be `all_lower_case`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有函数和方法名称应该使用 `all_lower_case`。
- en: All constants should be `ALL_UPPER_CASE`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有常量都应该使用 `ALL_UPPER_CASE`。
- en: 'Some guidelines about the structure of the code from *PEP 8* are given here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了一些关于 *PEP 8* 中代码结构的指南：
- en: Indentation is important in Python. Do not use *Tab* for indentation. Instead,
    use four spaces.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中缩进很重要。不要使用 *Tab* 进行缩进。相反，使用四个空格。
- en: Limit nesting to four levels.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制嵌套到四级。
- en: Remember to limit the number of lines to 79 characters. Use the `\` symbol to
    break long lines.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住要限制行数为79个字符。使用 `\` 符号来断开长行。
- en: To make code readable, insert two blank lines to separate functions.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使代码可读，在函数之间插入两个空行来分隔。
- en: Insert a single black line between various logical sections.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的逻辑部分之间插入一个单行。
- en: Remember that *PEP* guidelines are just suggestions that may be customized by
    different teams. Any customized naming scheme should still use *PEP 8* as the
    basic guideline.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*PEP* 指南只是一些建议，可能被不同的团队定制。任何定制的命名方案都应该仍然使用 *PEP 8* 作为基本指南。
- en: Now, let's look in more detail at the naming scheme in the context of various
    Python language structures.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看在 Python 语言结构的上下文中的命名方案。
- en: Methods
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'Method names should use lowercase. The name should consist of a single word
    or more than one word separated by underscores. You can see an example of this
    here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称应使用小写。名称应由一个单词或多个单词组成，单词之间用下划线分隔。您可以在这里看到示例：
- en: '[PRE0]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To make the code readable, the method should preferably be a verb, related to
    the processing that the method is supposed to perform.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码可读，方法最好是一个动词，与该方法应执行的处理相关。
- en: 'If a method is non-public, it should have a leading underscore. Here''s an
    example of this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法是非公共的，它应该有一个前导下划线。以下是一个示例：
- en: '[PRE1]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Dunder** or **magic methods** are methods that have a leading and trailing
    underscore. Examples of Dunder or magic methods are shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**双下划线**或**魔术方法**是具有前导和尾随下划线的方法。双下划线或魔术方法的示例如下所示：'
- en: '`__init__`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`'
- en: '`__add__`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__add__`'
- en: It is never a good idea to use two leading and trailing underscores to name
    a method, and the use of these by developers is discouraged. Such a naming scheme
    is designed for Python methods.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从不使用两个前导和尾随下划线来命名方法是一个好主意，并且开发者被鼓励不要使用这些方法。这种命名方案是为Python方法设计的。
- en: Variables
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Use a lowercase word or words separated by an underscore to represent variables.
    The variables should be nouns that correspond to the entity they are representing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小写单词或由下划线分隔的单词来表示变量。变量应该是名词，与它们所代表的实体相对应。
- en: 'Examples of variables are given here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了变量的示例：
- en: '`x`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`'
- en: '`my_var`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_var`'
- en: The names of private variables should start with an underscore. An example is
    `_my_secret_variable`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 私有变量的名称应该以下划线开头。例如，`_my_secret_variable`。
- en: Boolean variables
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔变量
- en: 'Starting a Boolean variable with `is` or `has` makes it more readable. You
    can see a couple of examples of this here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以`is`或`has`开头布尔变量使其更易读。您可以在以下示例中看到几个这样的例子：
- en: '[PRE2]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Collection variables
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合变量
- en: 'As collections are buckets of variables, it is a good idea to name them in
    a plural format, as illustrated here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是变量的桶，因此最好以复数格式命名它们，如下所示：
- en: '[PRE3]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dictionary variables
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典变量
- en: 'The name of the dictionary is recommended to be as explicit as possible. For
    example, if we have a dictionary of people mapped to the cities they are living
    in, then a dictionary can be created as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的名称建议尽可能明确。例如，如果我们有一个将人映射到他们居住城市的字典，则可以创建如下字典：
- en: '[PRE4]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Constant
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: Python does not have immutable variables. For example, in C++, we can specify
    a `const` keyword to specify that the variable is immutable and is a constant.
    Python relies on naming conventions to specify constants. If the code tries to
    treat a constant as a regular variable, Python will not give an error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有不可变变量。例如，在C++中，我们可以使用`const`关键字来指定变量是不可变的，并且是常量。Python依赖于命名约定来指定常量。如果代码试图将常量作为普通变量处理，Python不会给出错误。
- en: 'For constants, the recommendation is to use uppercase words or words separated
    by an underscore. An example of a constant is given here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常量，建议使用大写单词或由下划线分隔的单词。以下是一个常量的示例：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Classes
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Classes should follow the CamelCase style—in other words, they should start
    with a capital letter. If we need to use more than one word, the words should
    not be separated by an underscore, but each word that is appended should have
    an initial capital letter. Classes should use a noun and should be named in a
    way to best represent the entity the class corresponds to. One way of making the
    code readable is to use classes with suffixes that have something to do with their
    type or nature, such as the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该遵循驼峰式命名风格——换句话说，它们应该以大写字母开头。如果我们需要使用多个单词，单词之间不应使用下划线分隔，但附加的每个单词都应该以大写字母开头。类应该使用名词，并且应该以最能代表类对应实体的方式命名。使代码可读的一种方法是为与它们的类型或性质有关的类使用后缀，如下所示：
- en: '`HadoopEngine`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HadoopEngine`'
- en: '`ParquetType`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParquetType`'
- en: '`TextboxWidget`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextboxWidget`'
- en: 'Here are some points to keep in mind:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的点：
- en: 'There are exception classes that handle errors. Their names should always have
    `Error` as the trailing word. Here''s an example of this:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有异常类处理错误。它们的名称应该始终以`Error`结尾。以下是一个示例：
- en: '[PRE6]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some of Python's built-in classes do not follow this naming guideline.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Python的内置类不遵循此命名指南。
- en: 'To make it more readable, for base or abstract classes, a `Base` or `Abstract`
    prefix can be used. An example could be this:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高可读性，对于基类或抽象类，可以使用`Base`或`Abstract`前缀。以下是一个示例：
- en: '[PRE7]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Packages
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: 'The use of an underscore is not encouraged while naming a package. The name
    should be short and all lowercase. If more than one word needs to be used, the
    additional word or words should also be lowercase. Here''s an example of this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名包时，不建议使用下划线。名称应简短且全部小写。如果需要使用多个单词，附加的单词或词组也应全部小写。以下是一个示例：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modules
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'When naming a module, short and to-the-point names should be used. They need
    to be lowercase, and more than one word will be joined by underscores. Here''s
    an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名模块时，应使用简短、直接的名字。它们需要是小写的，并且多个单词将通过下划线连接。以下是一个示例：
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Import conventions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入约定
- en: 'Over the years, the Python community has developed a convention for aliases
    that are used for commonly used packages. You can see an example of this here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python 社区已经形成了一套用于常用包的别名约定。您可以在以下示例中看到这一点：
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Arguments
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 论点
- en: Arguments are recommended to have a naming convention similar to variables,
    because arguments of a function are, in fact, temporary variables.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 建议参数的命名约定与变量相似，因为函数的参数实际上是一些临时变量。
- en: Useful tools
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的工具
- en: There are a couple of tools that can be used to test how closely your code conforms
    to *PEP 8* guidelines. Let's look into them, one by one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以用来测试您的代码与 *PEP 8* 指南的符合程度。让我们逐一探讨。
- en: Pylint
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: 'Pylint can be installed by running the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令来安装 Pylint：
- en: '[PRE11]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pylint is a source code analyzer that checks the naming convention of the code
    with respect to *PEP 89*. Then, it prints a report. It can be customized to be
    used for other naming conventions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 是一个源代码分析器，它根据 *PEP 89* 检查代码的命名约定，然后打印出报告。它可以定制以用于其他命名约定。
- en: PEP 8
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 8
- en: '*PEP 8* can be installed by running the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令来安装 *PEP 8*：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`pep8` checks the code with respect to *PEP 8*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`pep8` 会根据 *PEP 8* 指南检查代码。'
- en: So far, we have learned about the various naming conventions in Python. Next,
    we will explore different choices for using source control for Python.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 Python 中的各种命名约定。接下来，我们将探讨使用源代码控制进行 Python 开发的不同选择。
- en: Exploring choices for source control
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索源代码控制的选择
- en: 'First, we will see a brief history of source control systems to provide a context.
    Modern source control systems are quite powerful. The evolution of the source
    control systems went through the following stages:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将简要回顾源代码控制系统的历史，以提供背景信息。现代源代码控制系统非常强大。源代码控制系统的演变经历了以下阶段：
- en: '**Stage 1**: The source code was initially started by local source control
    systems that were stored on a hard drive. This local code collection was called
    a local repository.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段**：源代码最初是由存储在硬盘上的本地源代码控制系统启动的。这个本地代码集合被称为本地仓库。'
- en: '**Stage 2**: But using source control locally was not suitable for larger teams.
    This solution eventually evolved into a central server-based repository that was
    shared by the members of the team working on a particular project. It solved the
    problem of code sharing among team members, but it also created an additional
    challenge of locking the files for the multiuser environment.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段**：但本地使用源代码控制对于大型团队来说并不合适。这个解决方案最终演变成一个基于中央服务器的仓库，由特定项目上的团队成员共享。它解决了团队成员之间代码共享的问题，但也为多用户环境中的文件锁定带来了额外的挑战。'
- en: '**Stage 3**: Modern version control repositories such as Git evolved this model
    further. All members of a team now have a full copy of the repository that is
    stored. The members of the team now work offline on the code. They need to connect
    to the repository only when there is a need to share the code.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段**：现代版本控制仓库，如 Git，进一步发展了这一模型。团队的所有成员现在都有一个存储的仓库的完整副本。团队成员现在可以在代码上离线工作。他们只需要在需要共享代码时连接到仓库。'
- en: What does not belong to the source control repository?
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么不属于源代码仓库？
- en: Let's look into what should not be checked into the source control repository.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不应该提交到源代码仓库中的内容。
- en: 'Firstly, anything other than the source code file shouldn''t be checked in.
    The computer-generated files should not be checked into source control. For example,
    let''s assume that we have a Python source file named `main.py`. If we compile
    it, the generated code does not belong to the repository. The compiled code is
    a derived file and should not be checked into source control. There are three
    reasons for this, outlined as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了源代码文件之外，其他任何内容都不应该被提交。计算机生成的文件不应该被提交到源代码控制中。例如，假设我们有一个名为 `main.py` 的 Python
    源代码文件。如果我们编译它，生成的代码不属于仓库。编译后的代码是一个派生文件，不应该被提交到源代码控制中。这里有三个原因，如下所述：
- en: The derived file can be generated by any member of the team once we have the
    source code.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了源代码，团队中的任何成员都可以生成派生文件。
- en: In many cases, the compiled code is much larger than the source code, and adding
    it to the repository will make it slow and sluggish. Also, remember that if there
    are 16 members in the team, then all of them unnecessarily get a copy of that
    generated file, which will unnecessarily slow down the whole system.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多情况下，编译后的代码比源代码大得多，将其添加到仓库会使系统变慢。此外，记住如果团队中有16名成员，那么他们每个人都会不必要地获得该生成文件的副本，这将不必要地减慢整个系统的速度。
- en: Source control systems are designed to store the delta or the changes you have
    made to the source files since your last commit. Files other than the source code
    files are usually binary files. The source control system is most likely unable
    to have a `diff` tool for that, and it will need to store the whole file each
    time it is committed. It will have a negative effect on the performance of the
    source control framework.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统旨在存储自上次提交以来对源文件所做的更改或增量。除了源代码文件之外，其他文件通常是二进制文件。版本控制系统很可能无法为这些文件提供`diff`工具，每次提交时都需要存储整个文件。这将对版本控制框架的性能产生负面影响。
- en: Secondly, anything that is confidential does not belong to the source control.
    This includes API keys and passwords.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，任何机密信息都不应属于源代码控制。这包括API密钥和密码。
- en: For the source repository, GitHub is the preferred choice of the Python community.
    Much of the source control of the famous Python packages also resides on GitHub.
    If the Python code is to be utilized across teams, then the right protocol and
    procedures need to be developed and maintained.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于源代码库，GitHub是Python社区的首选。许多著名的Python包的源代码控制也位于GitHub上。如果Python代码要在多个团队之间使用，那么就需要开发和维护正确的协议和程序。
- en: Understanding strategies for deploying the code
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署代码的策略
- en: For projects where the development team is not the end user, it is important
    to come up with a strategy to deploy the code for the end user. For relatively
    large-scale projects, when there is a well-defined `DEV` and `PROD` environment,
    deploying the code and strategizing it becomes important.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发团队不是最终用户的工程项目，制定一个为最终用户部署代码的策略非常重要。对于相对大规模的项目，当存在明确的`DEV`和`PROD`环境时，部署代码和制定策略变得很重要。
- en: Python is the language of choice for cloud and cluster computing environments
    as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Python是云和集群计算环境的首选语言。
- en: 'Issues related to deploying the code are listed as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 部署代码相关的问题如下列出：
- en: Exactly the same transformations need to happen in `DEV`, `TEST`, and `PROD`
    environments.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`DEV`、`TEST`和`PROD`环境中，需要发生完全相同的转换。
- en: As the code keeps getting updated in the `DEV` environment, how will the changes
    be synced to the `PROD` environment?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码在`DEV`环境中的不断更新，如何将这些更改同步到`PROD`环境？
- en: What type of testing do you plan to do in the `DEV` and `PROD` environments?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划在`DEV`和`PROD`环境中进行哪种类型的测试？
- en: Let's look into two main strategies for deploying the code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看部署代码的两种主要策略。
- en: Batch development
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量开发
- en: This is the traditional development process. We develop the code, compile it,
    and then test it. This process is repeated iteratively until all the requirements
    are met. Then, the developed code is deployed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是传统的开发流程。我们编写代码，编译它，然后测试它。这个过程会迭代重复，直到所有需求都得到满足。然后，开发的代码就会被部署。
- en: Employing continuous integration and continuous delivery
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采用持续集成和持续交付
- en: '**Continuous integration/continuous delivery** (**CI/CD**) in the context of
    Python refers to continuous integration and deployment instead of conducting it
    as a batch process. It helps to create a **development-operations** (**DevOps**)
    environment by bridging the gap between development and operations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的上下文中，**持续集成/持续交付**（**CI/CD**）指的是持续集成和部署，而不是作为批量过程执行。它通过弥合开发和运维之间的差距，有助于创建**开发-运维**（**DevOps**）环境。
- en: '**CI** refers to continuously integrating, building, and testing various modules
    of the code as they are being updated. For a team, this means that the code developed
    individually by each team member is integrated, built, and tested, typically many
    times a day. Once they are tested, the repository in the source control is updated.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI**指的是在代码更新时持续集成、构建和测试代码的各个模块。对于一个团队来说，这意味着每个团队成员独立开发的代码会被集成、构建和测试，通常每天多次。一旦测试通过，源代码控制中的仓库就会被更新。'
- en: An advantage of CI is that problems or bugs are fixed right in the beginning.
    A typical bug fixed on the day it was created takes much less time to resolve
    right away instead of resolving it days, weeks, or months later when it has already
    trickled down to other modules and those affected may have created multilevel
    dependencies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: CI的优势在于问题或错误在初期就被修复。一个典型的错误在它被创建的那天修复，立即解决它所需的时间比几天、几周或几个月后解决它要少得多，那时它已经渗透到其他模块，受影响的成员可能已经创建了多层依赖。
- en: Unlike Java or C++, Python is an interpreted language, which means the built
    code is executable on any target machine with an interpreter. In comparison, the
    compiled code is typically built for one type of target machine and may be developed
    by different members of the team. Once we have figured out which steps need to
    be followed each time a change is made, we can automate it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java或C++不同，Python是一种解释型语言，这意味着构建的代码可以在任何带有解释器的目标机器上执行。相比之下，编译的代码通常为一种目标机器构建，可能由团队的不同成员开发。一旦我们弄清楚每次更改需要遵循哪些步骤，我们就可以自动化它。
- en: As Python code is dependent on external packages, keeping track of their names
    and versions is part of automating the build process. A good practice is to list
    all these packages in a file named `requirements.txt`. The name can be anything,
    but the Python community typically tends to call it `requirements.txt`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python代码依赖于外部包，跟踪它们的名称和版本是自动化构建过程的一部分。一个良好的做法是将所有这些包列在一个名为`requirements.txt`的文件中。名称可以是任何东西，但Python社区通常倾向于将其称为`requirements.txt`。
- en: 'To install the packages, we will execute the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装包，我们将执行以下命令：
- en: '[PRE13]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To create a `requirements` file that represents the packages used in our code,
    we can use the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表示我们代码中使用的包的`requirements`文件，我们可以使用以下命令：
- en: '[PRE14]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The goal of integration is to catch errors and defects early, but it has the
    potential to make the development process unstable. There will be times when a
    member of the team has introduced a major bug, thus *breaking the code*, if other
    team members may have to wait until that bug is resolved. Robust self-testing
    by team members and choosing the right frequency for integration will help to
    resolve the issue. For robust testing, running testing each time a change is made
    should be implemented. This testing process should be eventually completely automated.
    In the case of errors, the build should fail and the team member responsible for
    the defective module should be notified. The team member can choose to first provide
    a quick fix before taking time to resolve and fully test the problem to make sure
    other team members are not blocked.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的目标是尽早捕捉错误和缺陷，但它有可能使开发过程不稳定。有时团队成员可能会引入一个严重的错误，从而*破坏代码*，如果其他团队成员可能必须等待该错误解决，他们可能需要等待。团队成员进行稳健的自我测试和选择适当的集成频率将有助于解决问题。为了进行稳健的测试，每次更改时都应该运行测试。这个过程最终应该完全自动化。在出现错误的情况下，构建应该失败，并且应该通知负责有缺陷模块的团队成员。该团队成员可以选择在花费时间解决和全面测试问题之前先提供一个快速修复，以确保其他团队成员不会受阻。
- en: Once the code is built and tested, we can choose to update the deployed code
    as well. That will implement the **CD** part. If we choose to have a complete
    CI/CD process, it means that each time a change is made, it is built and tested
    and the changes are reflected in the deployed code. If managed properly, the end
    user will benefit from having a constantly evolving solution. In some use cases,
    each CI/CD cycle may be an iterative move from MVP to a full solution. In other
    use cases, we are trying to capture and formulate a fast-changing real-world problem,
    discarding obsolete assumptions, and incorporating new information. An example
    is the pattern analysis of the COVID-19 situation, which is changing by the hour.
    Also, new information is coming at a rapid pace, and any use case related to it
    may benefit from CI/CD, whereby developers are constantly updating their solutions
    based on new emerging facts and information.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码构建和测试完成，我们可以选择更新部署的代码。这将实现**CD**部分。如果我们选择拥有完整的CI/CD流程，这意味着每次进行更改时，都会进行构建和测试，并且更改会反映在部署的代码中。如果管理得当，最终用户将受益于不断演变的解决方案。在某些用例中，每个CI/CD周期可能是一个从MVP到完整解决方案的迭代移动。在其他用例中，我们试图捕捉和制定快速变化的现实世界问题，摒弃过时的假设，并纳入新信息。一个例子是对COVID-19形势的图案分析，它每小时都在变化。此外，新信息正在以极快的速度涌现，与其相关的任何用例都可能从CI/CD中受益，其中开发者不断根据新出现的事实和信息更新他们的解决方案。
- en: Next, we will discuss commonly used development environments for Python.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 Python 常用的开发环境。
- en: Python development environments
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 开发环境
- en: Text editors are a tempting choice for editing Python code. But for any medium-to-large-sized
    project, we have to seriously consider Python **integrated development environments**
    (**IDEs**), which are very helpful for writing, debugging, and troubleshooting
    the code using the version control and facilitating ease of deployments. There
    are many IDEs available, mostly free, on the market. In this section, we will
    review a few of them. Note that we will not try to rank them in any order but
    will emphasize the value each of them brings, and it is up to the reader to make
    the best choice based on their past experience, project requirements, and the
    complexity of their projects.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器是编辑 Python 代码的诱人选择。但对于任何中等或大型项目，我们必须认真考虑 Python **集成开发环境** （**IDEs**），这对于使用版本控制编写、调试和故障排除代码以及简化部署非常有帮助。市场上有很多
    IDE，大多数都是免费的。在本节中，我们将回顾其中的一些。请注意，我们不会尝试按任何顺序对它们进行排名，而是强调每个 IDE 带来的价值，读者可以根据自己的以往经验、项目需求和项目的复杂性来做出最佳选择。
- en: IDLE
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDLE
- en: '**Integrated Development and Learning Environment** (**IDLE**) is a default
    editor that comes with Python and is available for all main platforms (Windows,
    macOS, and Linux). It is free and is a decent IDE for beginners for learning purposes.
    It is not recommended for advanced programming.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发和学习环境** （**IDLE**）是 Python 的默认编辑器，适用于所有主要平台（Windows、macOS 和 Linux）。它是免费的，对于学习目的而言是一个不错的
    IDE。它不推荐用于高级编程。'
- en: Sublime Text
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sublime Text
- en: '**Sublime Text** is another popular code editor and can be used for multiple
    languages. It is free for evaluation purposes only. It is also available for all
    main platforms (Windows, macOS, and Linux). It comes with basic Python support
    but with its powerful extensions framework, we can customize it to make a full
    development environment that needs extra skills and time. Integration with a version
    control system such as Git or **Subversion** (**SVN**) is possible with plugins
    but may not expose full version control features.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sublime Text** 是另一个流行的代码编辑器，支持多种语言。它仅用于评估目的且免费。它也适用于所有主要平台（Windows、macOS
    和 Linux）。它提供了基本的 Python 支持，但凭借其强大的扩展框架，我们可以自定义它以创建一个需要额外技能和时间才能构建的完整开发环境。通过插件可以实现与版本控制系统（如
    Git 或 **Subversion** （**SVN**））的集成，但可能不会完全暴露版本控制功能。'
- en: '**Atom** is another popular editor that is also in the same category as Sublime
    Text. It is free.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Atom** 是另一个流行的编辑器，与 Sublime Text 同属一类。它是免费的。'
- en: PyCharm
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm
- en: '**PyCharm** is one of the best Python IDE editors available for Python programming
    and it is available for Windows, macOS, and Linux. It is a complete IDE tailored
    for Python programming, which helps programmers with code completion, debugging,
    refactoring, smart search, access to popular database servers, integration with
    version control systems, and many more features. The IDE provides a plugin platform
    for developers to extend the base functionalities as needed. PyCharm is available
    in the following formats:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyCharm** 是适用于 Python 编程的最好的 Python IDE 编辑器之一，适用于 Windows、macOS 和 Linux。它是一个专为
    Python 编程定制的完整 IDE，帮助程序员完成代码、调试、重构、智能搜索、访问流行的数据库服务器、与版本控制系统集成以及更多功能。IDE 为开发者提供了一个插件平台，以便根据需要扩展基本功能。PyCharm
    可以下列格式提供：'
- en: Community version, which is free and comes for pure Python development
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区版，免费且适用于纯Python开发
- en: Professional version, which is not free and comes with support for web development
    such as **HyperText Markup Language** (**HTML**), JavaScript, and SQL
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业版，不免费，并支持网页开发，如 **超文本标记语言** （**HTML**）、JavaScript 和 SQL
- en: Visual Studio Code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '**Visual Studio Code** (**VS Code**) is an open source environment developed
    by Microsoft. For Windows, VS Code is the best Python IDE. It does not come with
    a Python development environment by default. The Python extensions for VS Code
    can make it a Python development environment.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** （**VS Code**）是由微软开发的开源环境。对于 Windows，VS Code 是最好的 Python
    IDE。它默认不包含 Python 开发环境。VS Code 的 Python 扩展可以使它成为一个 Python 开发环境。'
- en: It is lightweight and full of powerful features. It is free and is also available
    for macOS and Linux. It comes with powerful features such as code completion,
    debugging, refactoring, searching, accessing database servers, version control
    system integration, and much more.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它轻量且功能强大。它是免费的，也适用于 macOS 和 Linux。它包含诸如代码补全、调试、重构、搜索、访问数据库服务器、版本控制系统集成等功能。
- en: PyDev
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyDev
- en: If you are using or have used Eclipse, you may like to consider PyDev, which
    is a third-party editor for Eclipse. It is in the category of one of the best
    Python IDEs and can also be used for Jython and IronPython. It is free. As PyDev
    is just a plugin on top of Eclipse, it is available for all major platforms, such
    as Eclipse. This IDE comes with all the bells and whistles of Eclipse, and on
    top of that, it streamlines integration with Django, unit testing, and **Google
    App Engine** (**GAE**).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过或正在使用 Eclipse，您可能会考虑 PyDev，这是一个 Eclipse 的第三方编辑器。它属于最佳 Python IDE 之一，也可以用于
    Jython 和 IronPython。它是免费的。由于 PyDev 只是 Eclipse 上的一个插件，因此它适用于所有主要平台，如 Eclipse。这个
    IDE 拥有 Eclipse 的所有功能，并且在此基础上，它简化了与 Django、单元测试和 **Google App Engine**（**GAE**）的集成。
- en: Spyder
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spyder
- en: If you are planning to use Python for data science and ML, you may want to consider
    **Spyder** as your IDE. Spyder is written in Python. This IDE offers tools for
    full editing, debugging, interactive execution, deep inspection, and advanced
    visualization capabilities. Additionally, it supports integration with Matplotlib,
    SciPy, NumPy, Pandas, Cython, IPython, and SymPy to make it a default IDE for
    data scientists.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用 Python 进行数据科学和机器学习，您可能希望考虑将 **Spyder** 作为您的 IDE。Spyder 是用 Python 编写的。这个
    IDE 提供了完整的编辑、调试、交互式执行、深度检查和高级可视化功能。此外，它支持与 Matplotlib、SciPy、NumPy、Pandas、Cython、IPython
    和 SymPy 集成，使其成为数据科学家的默认 IDE。
- en: Based on the review of different IDEs in this section, we can recommend PyCharm
    and PyDev for professional application developers. But if you are more into data
    science and ML, Spyder is surely worth exploring.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本节对不同 IDE 的回顾，我们可以推荐 PyCharm 和 PyDev 给专业应用程序开发者。但如果您更倾向于数据科学和机器学习，Spyder 确实值得探索。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we laid down the groundwork for the advanced Python concepts
    discussed in the later chapters of this book. We started by presenting the flavor,
    guidance, and ambience of a Python project. We started the technical discussion
    by first identifying different phases of the Python project and then exploring
    different ways of optimizing it based on the use cases we are working on. For
    a terse language such as Python, good-quality documentation goes a long way to
    make the code readable and explicit.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为本书中后续章节讨论的高级 Python 概念奠定了基础。我们首先介绍了 Python 项目的风味、指导和环境。我们通过首先确定 Python
    项目的不同阶段，然后根据我们正在处理的使用案例探索不同的优化方式开始了技术讨论。对于像 Python 这样简洁的语言，高质量的文档对于使代码可读和明确大有裨益。
- en: We also looked into various ways of documenting the Python code. Next, we investigated
    the recommended ways of creating documentation in Python. We also studied the
    naming schemes that can help us in making code more readable. Next, we looked
    into the different ways we can use source control. We also figured out what are
    the different ways of deploying Python code. Finally, we reviewed a few development
    environments for Python to help you choose a development environment based on
    the background they have and the type of project you are going to work on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了记录 Python 代码的各种方法。接下来，我们调查了在 Python 中创建文档的推荐方法。我们还研究了可以帮助我们使代码更易读的命名方案。接下来，我们探讨了我们可以使用的不同源代码控制方法。我们还弄清楚了部署
    Python 代码的不同方式。最后，我们回顾了几种 Python 开发环境，以帮助您根据他们的背景和您将要工作的项目类型选择开发环境。
- en: The topics we covered in this chapter are beneficial for anyone who is starting
    a new project involving Python. These discussions help to make the strategy and
    design decision of a new project promptly and efficiently. In the next chapter,
    we will investigate how we can modularize the code of a Python project.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题对任何开始新项目涉及 Python 的人来说都有益。这些讨论有助于迅速有效地制定新项目的策略和设计决策。在下一章中，我们将探讨如何模块化
    Python 项目的代码。
- en: Questions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is *The Zen of Python*?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *Python 的禅宗*？
- en: In Python, what sort of documentation is available at runtime?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 中，运行时可以提供哪些类型的文档？
- en: What is a CRISP-DM life cycle?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 CRISP-DM 生命周期？
- en: Further reading
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Modern Python Cookbook – Second Edition*, by *Steven F. Lott*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《现代Python食谱 第二版》*，作者 *Steven F. Lott*'
- en: '*Python Programming Blueprints*, by *Daniel Furtado*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python编程蓝图》*，作者 *Daniel Furtado*'
- en: '*Secret Recipes of the Python Ninja*, by *Cody Jackson*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python忍者秘籍》*，作者 *Cody Jackson*'
- en: Answers
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A collection of 19 guidelines written by Tim Peters that apply to the design
    of Python projects.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tim Peters 编写的19条指南的集合，适用于Python项目的开发设计。
- en: As opposed to regular comments, docstrings are available at runtime to the compiler.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与常规注释不同，文档字符串在编译时对编译器是可用的。
- en: '**CRISP-DM** stands for **Cross-Industry Standard Process for Data Mining**.
    It applies to a Python project life cycle in the ML domain and identifies different
    phases of a project.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CRISP-DM** 代表 **跨行业数据挖掘标准流程**。它适用于ML领域的Python项目生命周期，并确定了项目的不同阶段。'
