<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Objects in Depth"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Objects in Depth</h1></div></div></div><p>In this chapter, we will dive into Python objects. Objects are the building blocks of the language. They may represent or abstract a real entity. We will be more interested in factors affecting such behavior. This will help us understand and appreciate the language in a better way. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Object characteristics</li><li class="listitem" style="list-style-type: disc">Calling objects</li><li class="listitem" style="list-style-type: disc">How objects are created</li><li class="listitem" style="list-style-type: disc">Playing with attributes</li></ul></div><div class="section" title="Understanding objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding objects</h1></div></div></div><p>
<span class="strong"><strong>Key 1: Objects are language's abstraction for data. Identity, value, and type are characteristic of them.</strong></span>
</p><p>All data and items that <a id="id0" class="indexterm"/>we work on in a program are objects, such as numbers, strings, classes, instances, and modules. They possess some qualities that are similar to real things as all of them are uniquely identifiable just like humans are identifiable by their DNA. They have a type that defines what kind of object it is, and the properties that it supports, just like humans of type cobbler support repairing shoes, and blacksmiths support making metal items. They possess some value, such as strength, money, knowledge, and beauty do for humans.</p><p>Name is just a means to identify an object in a namespace similar to how it is used to identify a person in a group.</p><div class="section" title="Identity"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Identity</h2></div></div></div><p>In Python, every object has a unique <a id="id1" class="indexterm"/>identity. We can get this identity by passing an object to built-in ID function ID (object).This returns the memory address of the object in CPython.</p><p>Interpreter can reuse some objects so that the total number of objects remains low. For example, integers and strings can be reused in the following manner:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; i = "asdf"
&gt;&gt;&gt; j = "asdf"
&gt;&gt;&gt; id(i) == id(j)
True
&gt;&gt;&gt; i = 10000000000000000000000000000000
&gt;&gt;&gt; j = 10000000000000000000000000000000
&gt;&gt;&gt; id(j) == id(i) #cpython 3.5 reuses integers till 256
False
&gt;&gt;&gt; i = 4
&gt;&gt;&gt; j = 4
&gt;&gt;&gt; id(i) == id(j)
True
&gt;&gt;&gt; class Kls:
...     pass
... 
&gt;&gt;&gt; k = Kls()
&gt;&gt;&gt; j = Kls()
&gt;&gt;&gt; id(k) == id(j) #always different as id gives memory address
False</pre></div><p>This is also a reason that addition of two strings is a third new string, and, hence, it is best to use the StringIO module to work with a buffer, or use the join attribute of strings:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; # bad
... print('a' + ' ' + 'simple' + ' ' + 'sentence' +  ' ' + '')
a simple sentence
&gt;&gt;&gt; #good
... print(' '.join(['a','simple','sentence','.']))
a simple sentence .</pre></div></div><div class="section" title="Value"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Value</h2></div></div></div><p>
<span class="strong"><strong>Key 2: Immutability is the inability to change an object's value.</strong></span>
</p><p>The value of the object is<a id="id2" class="indexterm"/> the data that is stored in it. Data in an object can be stored as numbers, strings, or references to other objects. Strings, and integers are objects themselves. Hence, for objects that are not implemented in C (or core objects), it is a reference to other objects, and we perceive value as the group value of the referenced object. Let's take an example of an object <span class="strong"><strong>iC</strong></span> instance of the C class with the <code class="literal">str</code> and <code class="literal">lst</code> attributes, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/B04885_01_01.jpg" alt="Value"/></div><p>The code snippet to create this object will be as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     def __init__(self, arg1, arg2):
...         self.str = arg1
...         self.lst = arg2
... 
&gt;&gt;&gt; iC = C("arun",[1,2])
&gt;&gt;&gt; iC.str
'arun'
&gt;&gt;&gt; iC.lst
[1, 2]
&gt;&gt;&gt; iC.lst.append(4)
&gt;&gt;&gt; iC.lst
[1, 2, 4]</pre></div><p>Then, when we modify <span class="strong"><strong>iC</strong></span>, we are either changing the objects references via attributes, or we are changing the references themselves and not the object <span class="strong"><strong>iC</strong></span>. This is important in <a id="id3" class="indexterm"/>understanding immutable objects because being immutable means not being able to change references. Hence, we can change mutable objects that are referenced by immutable objects. For example, lists inside tuple can be changed because the referenced objects are changing, not the references.</p></div><div class="section" title="Type"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Type</h2></div></div></div><p>
<span class="strong"><strong>Key 3: Type is instance's class.</strong></span>
</p><p>An object's type<a id="id4" class="indexterm"/> tells us about the operations and functionality that the object supports, and it may also define the possible values for objects of that type. For example, your pet may be of type <code class="literal">dog</code> (an instance of the <code class="literal">dog</code> class) or cat (an instance of the <code class="literal">cat</code> class). If it is of type dog, it can bark; and if it is type cat, it can meow. Both are a type of animal (<code class="literal">cat</code> and <code class="literal">dog</code> inherit from the <code class="literal">animal</code> class).</p><p>An object's class provides a type to it. Interpreter gets the object's class by checking its <code class="literal">__class__</code> attribute. So, we can change an object's type by changing its <code class="literal">__class__</code> attribute:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; k = []
&gt;&gt;&gt; k.__class__
&lt;class 'list'&gt;
&gt;&gt;&gt; type(k)
&lt;class 'list'&gt;
# type is instance's class
&gt;&gt;&gt; class M:
...     def __init__(self,d):
...         self.d = d
...     def square(self):
...         return self.d * self.d
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; class N:
...     def __init__(self,d):
...         self.d = d
...     def cube(self):
...         return self.d * self.d * self.d
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; m = M(4)
&gt;&gt;&gt; type(m)  #type is its class
&lt;class '__main__.M'&gt;
&gt;&gt;&gt; m.square()  #square defined in class M
16
&gt;&gt;&gt; m.__class__ = N # now type should change
&gt;&gt;&gt; m.cube()        # cube in class N
64
&gt;&gt;&gt; type(m)
&lt;class '__main__.N'&gt; # yes type is changed</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>This will <a id="id5" class="indexterm"/>not work for built-in, compiled classes as it works only for class objects defined on runtime.</p></div></div></div></div></div>
<div class="section" title="Making calls to objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Making calls to objects</h1></div></div></div><p>
<span class="strong"><strong>Key 4: All objects can be made callable.</strong></span>
</p><p>To reuse and <a id="id6" class="indexterm"/>group code for some task, we group it in the functions classes, and then call it with different inputs. The objects that have a <code class="literal">__call__</code> attribute are callable and <code class="literal">__call__</code> is the entry point. For the C class, <code class="literal">tp_call</code> is checked in its structure:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def func(): # a function
...     print("adf")
... 
&gt;&gt;&gt; func()
adf
&gt;&gt;&gt; func.__call__() #implicit call method
adf
&gt;&gt;&gt; func.__class__.__call__(func)
adf
&gt;&gt;&gt; func.__call__
&lt;method-wrapper '__call__' of function object at 0x7ff7d9f24ea0&gt;
&gt;&gt;&gt; class C: #a callable class
...     def __call__(self):
...         print("adf")
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c()
adf
&gt;&gt;&gt; c.__call__() #implicit passing of self
adf
&gt;&gt;&gt; c.__class__.__call__(c) #explicit passing of self
adf
&gt;&gt;&gt; callable(lambda x:x+1)  #testing whether object is callable or not
True
&gt;&gt;&gt; isinstance(lambda x:x+1, collections.Callable) #testing whether object is callable or not
True</pre></div><p>Methods in classes<a id="id7" class="indexterm"/> are similar to functions, except that they are called with an implicit instance as a first argument. The functions are exposed as methods when they are accessed from the instance. The function is wrapped in a method class and returned. The method class stores instances in <code class="literal">__self__</code> and function in <code class="literal">__func__</code>, and its <code class="literal">__call__</code> method calls <code class="literal">__func__</code> with first argument as <code class="literal">__self__</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class D:
...     pass
... 
&gt;&gt;&gt; class C:
...     def do(self,):
...             print("do run",self)
... 
&gt;&gt;&gt; def doo(obj):
...     print("doo run",obj)
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; d = D()
&gt;&gt;&gt; doo(c)
doo run &lt;__main__.C object at 0x7fcf543625c0&gt;
&gt;&gt;&gt; doo(d)
doo run &lt;__main__.D object at 0x7fcf54362400&gt;
&gt;&gt;&gt; # we do not need to pass object in case of C class do method
... 
&gt;&gt;&gt; c.do() #implicit pass of c object to do method
do run &lt;__main__.C object at 0x7fcf543625c0&gt;
&gt;&gt;&gt; C.doo = doo
&gt;&gt;&gt; c.doo()
doo run &lt;__main__.C object at 0x7fcf543625c0&gt;
&gt;&gt;&gt; C.doo()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: doo() missing 1 required positional argument: 'obj'
&gt;&gt;&gt; C.do()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: do() missing 1 required positional argument: 'self'
&gt;&gt;&gt; C.do(c)
do run &lt;__main__.C object at 0x7fcf543625c0&gt;
&gt;&gt;&gt; C.do(d)
do run &lt;__main__.D object at 0x7fcf54362400&gt;
&gt;&gt;&gt; c.do.__func__(d) #we called real function this way
do run &lt;__main__.D object at 0x7fcf54362400&gt;</pre></div><p>Using this logic, we <a id="id8" class="indexterm"/>can also collect methods that are needed from other classes in the current class, like the following code, instead of multiple inheritances if data attributes do not clash. This will result in two dictionary lookups for an attribute search: one for instance, and one for class.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; #in library
... class PrintVals:
...     def __init__(self, endl):
...         self.endl = endl
...         
...     def print_D8(self, data):
...         print("{0} {1} {2}".format(data[0],data[1],self.endl))
... 
&gt;&gt;&gt; class PrintKVals: #from in2 library
...     def __init__(self, knm):
...         self.knm = knm
...     
...     def print_D8(self, data):
...         print("{2}:{0} {1}".format(data[0],data[1],self.knm))
...
&gt;&gt;&gt; class CollectPrint:
...     
...     def __init__(self, endl):
...         self.endl = endl
...         self.knm = "[k]"
...     
...     print_D8 = PrintVals.print_D8
...     print_D8K = PrintKVals.print_D8
... 
&gt;&gt;&gt; c = CollectPrint("}")
&gt;&gt;&gt; c.print_D8([1,2])
1 2 }
&gt;&gt;&gt; c.print_D8K([1,2])
[k]:1 2</pre></div><p>When we call classes, we are calling its type, that is <code class="literal">metaclass</code>, with class as a first argument to give us a new instance:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Meta(type):
...     def __call__(*args):
...         print("meta call",args)
... 
&gt;&gt;&gt; class C(metaclass=Meta):
...     pass
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; c = C()
meta call (&lt;class '__main__.C'&gt;,)
&gt;&gt;&gt; c = C.__class__.__call__(C)
meta call (&lt;class '__main__.C'&gt;,)</pre></div><p>Similarly, when <a id="id9" class="indexterm"/>we call instances, we are calling their type, that is class, with instance as first argument:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     def __call__(*args):
...         print("C call",args)
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c()
C call (&lt;__main__.C object at 0x7f5d70c2bb38&gt;,)
&gt;&gt;&gt; c.__class__.__call__(c)
C call (&lt;__main__.C object at 0x7f5d70c2bb38&gt;,)</pre></div></div>
<div class="section" title="How objects are created"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>How objects are created</h1></div></div></div><p>Objects other <a id="id10" class="indexterm"/>than built-in types or compiled module classes are created at runtime. Objects can be classes, instances, functions, and so on. We call an object's type to give us a new instance; or put in another way, we call a <code class="literal">type</code> class to give us an instance of that type.</p><div class="section" title="Creation of function objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Creation of function objects</h2></div></div></div><p>
<span class="strong"><strong>Key 5: Create function on runtime.</strong></span>
</p><p>Let's first take a look at how function objects can be created. This will broaden our view. This <a id="id11" class="indexterm"/>process is <a id="id12" class="indexterm"/>done by interpreter behind the scenes when it sees a <code class="literal">def</code> keyword. It compiles the code, which is shown as follows, and passes the code name arguments to the function class that returns an object:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; function_class = (lambda x:x).__class__
&gt;&gt;&gt; function_class
&lt;class 'function'&gt;
&gt;&gt;&gt; def foo():
...     print("hello world")
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; def myprint(*args,**kwargs):
...     print("this is my print")
...     print(*args,**kwargs)
... 
&gt;&gt;&gt; newfunc1 = function_class(foo.__code__, {'print':myprint})
&gt;&gt;&gt; newfunc1()
this is my print
hello world
&gt;&gt;&gt; newfunc2 = function_class(compile("print('asdf')","filename","single"),{'print':print})
&gt;&gt;&gt; newfunc2()
asdf</pre></div></div><div class="section" title="Creation of instances"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Creation of instances</h2></div></div></div><p>
<span class="strong"><strong>Key 6: Process flow for instance creation.</strong></span>
</p><p>We call class <a id="id13" class="indexterm"/>to get a <a id="id14" class="indexterm"/>new instance. We saw from the making calls to objects section that when we call class, it calls its metaclass <code class="literal">__call__</code> method to get a new instance. It is the responsibility of <code class="literal">__call__</code> to return a new object that is properly initialized. It is able to call class's <code class="literal">__new__</code>, and <code class="literal">__init__</code> because class is passed as first argument, and instance is created by this function itself:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Meta(type):
...     def __call__(*args):
...         print("meta call ",args)
...         return None
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; class C(metaclass=Meta):
...     def __init__(*args):
...         print("C init not called",args)
... 
&gt;&gt;&gt; c = C() #init will not get called 
meta call  (&lt;class '__main__.C'&gt;,)
&gt;&gt;&gt; print(c)
None
&gt;&gt;&gt;</pre></div><p>To enable developer access to both functionalities, creating new object, and initializing new object, in class itself; <code class="literal">__call__</code> calls the <code class="literal">__new__</code> class to return a new object and <code class="literal">__init__</code> to initialize it. The full flow can be visualized as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Meta(type):
...     def __call__(*args):
...         print("meta call ,class object :",args)
...         class_object = args[0]
...         if '__new__' in class_object.__dict__:
...             new_method = getattr(class_object,'__new__',None)
...             instance = new_method(class_object)
...         else:
...             instance = object.__new__(class_object)
...         if '__init__' in class_object.__dict__:
...             init_method =  getattr(class_object,'__init__',None)
...             init_method(instance,*args[1:])
...         return instance
...
&gt;&gt;&gt; class C(metaclass=Meta):
...     def __init__(instance_object, *args):
...         print("class init",args)
...     def __new__(*args):
...         print("class new",args)
...         return object.__new__(*args)
...
&gt;&gt;&gt; class D(metaclass=Meta):
...     pass
...
&gt;&gt;&gt; c=C(1,2)
meta call ,class object : (&lt;class '__main__.C'&gt;, 1, 2)
class new (&lt;class '__main__.C'&gt;,)
class init (1, 2)
&gt;&gt;&gt; d = D(1,2)
meta call ,class object : (&lt;class '__main__.D'&gt;, 1, 2)
&gt;&gt;&gt;</pre></div><p>Take a <a id="id15" class="indexterm"/>look at<a id="id16" class="indexterm"/> the following diagram:</p><div class="mediaobject"><img src="graphics/B04885_01_02.jpg" alt="Creation of instances"/></div></div><div class="section" title="Creation of class objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Creation of class objects</h2></div></div></div><p>
<span class="strong"><strong>Key 7: Process flow for class creation.</strong></span>
</p><p>There are three<a id="id17" class="indexterm"/> ways in <a id="id18" class="indexterm"/>which we can create classes. One is to simply define the class. The second one is to use the built-in <code class="literal">__build_class__</code> function, and the third is to use the <code class="literal">new_class</code> method of <code class="literal">type</code> module. Method one uses two, method two uses method three internally. When interpreter sees a class keyword, it collects the name, bases, and metaclass that is defined for the class. It will call the <code class="literal">__build_class__</code> built-in function with function (with the code object of the class), name of the class, base classes, metaclass that is defined, and so on:</p><div class="informalexample"><pre class="programlisting">__build_class__(func, name, *bases, metaclass=None, **kwds) -&gt; class</pre></div><p>This function returns the class. This will call the <code class="literal">__prepare__</code> class method of metaclass to get a mapping data structure to use as a namespace. The class body will be evaluated, and local variables will be stored in this mapping data structure. Metaclass's type will be called with this namespace dictionary, bases, and class name. It will in turn call the <code class="literal">__new__</code> and <code class="literal">__init__</code> methods of metaclass. Metaclass can change attributes passed to its method:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; function_class = (lambda x:x).__class__
&gt;&gt;&gt; M = __build_class__(function_class(
...                         compile("def __init__(self,):\n    print('adf')",
...                                 '&lt;stdin&gt;',
...                                 'exec'),
...                         {'print':print}
...                         ),
...                     'MyCls')
&gt;&gt;&gt; m = M()
adf
&gt;&gt;&gt; print(M,m)
&lt;class '__main__.MyCls'&gt; &lt;__main__.MyCls object at 0x0088B430&gt;
&gt;&gt;&gt;</pre></div><p>Take a look <a id="id19" class="indexterm"/>at the<a id="id20" class="indexterm"/> following diagram:</p><div class="mediaobject"><img src="graphics/B04885_01_03.jpg" alt="Creation of class objects"/></div></div></div>
<div class="section" title="Playing with attributes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Playing with attributes</h1></div></div></div><p>
<span class="strong"><strong>Key 8: Which attribute will be used.</strong></span>
</p><p>Attributes are <a id="id21" class="indexterm"/>values that are associated with an object that can be referenced by name using dotted expressions. It is important to understand how attributes of an object are found. The following is the sequence that is used to <a id="id22" class="indexterm"/>search an attribute:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If an attribute is a special method, and it exists in the object's type (or bases), return it, for example: <code class="literal">__call__</code>, <code class="literal">__str__</code>, and <code class="literal">__init__</code>. When these methods are searched, their behavior is only in the instance's type:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     def __str__(self,):
...             return 'Class String'
...     def do(self):
...             return 'Class method'
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; print(c)
Class String
&gt;&gt;&gt; print(c.do())
Class method
&gt;&gt;&gt; def strf(*args):
...     return 'Instance String',args
... 
&gt;&gt;&gt; def doo(*args):
...     return 'Instance Method'
... 
&gt;&gt;&gt; c.do = doo
&gt;&gt;&gt; c.__str__ = strf
&gt;&gt;&gt; print(c)
Class String
&gt;&gt;&gt; print(c.do())
Instance Method</pre></div></li><li class="listitem">If an object's type has a <code class="literal">__getattribute__</code> attribute, then this method is invoked to get the attribute whether this attribute is present or not. It is the total responsibility of <code class="literal">__getattribute__</code> to get the attribute. As shown in the following code snippet, even if the do method is present, it is not found as <code class="literal">getattribute</code> didn't return any attribute:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     def do(self):
...             print("asdf")
...     def __getattribute__(self,attr):
...             raise AttributeError('object has no attribute "%s"'%attr)
... 
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.do()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in __getattribute__
AttributeError: object has no attribute "do"
&gt;&gt;&gt; </pre></div></li><li class="listitem">Search in object's type <code class="literal">__dict__</code> to find the attribute. If it is present, and it is data descriptor, return it:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Desc:
...     def __init__(self, i):
...             self.i = i
...     def __get__(self, obj, objtype):
...             return self.i
...     def __set__(self,obj, value):
...             self.i = value
...
&gt;&gt;&gt; class C:
...     attx = Desc(23)
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.attx
23
&gt;&gt;&gt; c.__dict__['attx'] = 1234
&gt;&gt;&gt; c.attx
23
&gt;&gt;&gt; C.attx = 12
&gt;&gt;&gt; c.attx
1234</pre></div></li><li class="listitem">Search in object's <code class="literal">__dict__</code> type (and if this object is class, search bases <code class="literal">__dict__</code> as well) to find<a id="id23" class="indexterm"/> the attribute. If the attribute is descriptor, return the result.</li><li class="listitem">Search in object's type<code class="literal">__dict__</code> to find the attribute. If the attribute is found, return it. If it is non-data descriptor, return its result, and check in other bases using the same logic:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Desc:
...     def __init__(self, i):
...             self.i = i
...     def __get__(self, obj, objtype):
...             return self.i
...
&gt;&gt;&gt; class C:
...     attx = Desc(23)
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.attx
23
&gt;&gt;&gt; c.__dict__['attx'] = 34
&gt;&gt;&gt; c.attx
34</pre></div></li><li class="listitem">If object type's <code class="literal">__getattr__</code> is <a id="id24" class="indexterm"/>defined, check whether it can give us the attribute:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     def __getattr__(self, key):
...             return key+'_#'
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.asdf
'asdf_#'</pre></div></li><li class="listitem">Raise <code class="literal">AttributeError</code>.</li></ol></div><div class="section" title="Descriptors"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Descriptors</h2></div></div></div><p>
<span class="strong"><strong>Key 9: Making custom behavior attributes.</strong></span>
</p><p>Any attribute of a <a id="id25" class="indexterm"/>class, which is an object defining any of these methods, acts as a <a id="id26" class="indexterm"/>descriptor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__get__(self, obj, type=None) --&gt; value</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__set__(self, obj, value) --&gt; None</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__delete__(self, obj) --&gt; None</code></li></ul></div><p>When an attribute is searched in an object first, it is searched in its dictionary then its type's (base class's) dictionary. If found, object has one of these methods defined and that method is invoked instead. Let's assume that b is an instance of the <code class="literal">B</code> class, then the following will happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Invocation through class is type<code class="literal">.__getattribute__()</code> transforming to <code class="literal">B.__dict__['x'].__get__(None, B)</code></li><li class="listitem" style="list-style-type: disc">Invocation through instance is object <code class="literal">.__getattribute__() --&gt; type(b).__dict__['x'].__get__(b, type(b))</code></li></ul></div><p>Objects with only <code class="literal">__get__</code> are non-data descriptors, and objects that include <code class="literal">__set__</code> / <code class="literal">__del__</code> are data descriptors. Data descriptors take precedence over instance <a id="id27" class="indexterm"/>attributes, whereas<a id="id28" class="indexterm"/> non-data descriptors do not.</p></div><div class="section" title="Class, static, and instance methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Class, static, and instance methods</h2></div></div></div><p>
<span class="strong"><strong>Key 10: Implementing class method and static method.</strong></span>
</p><p>Class, static, and<a id="id29" class="indexterm"/> instance methods <a id="id30" class="indexterm"/>are all implementable using descriptors. We can understand<a id="id31" class="indexterm"/> descriptors <a id="id32" class="indexterm"/>and these <a id="id33" class="indexterm"/>methods <a id="id34" class="indexterm"/>in one go:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Class methods are methods that always get class as their first argument and they can be executed without any instance of class.</li><li class="listitem" style="list-style-type: disc">Static methods are methods that do not get any implicit objects as first argument when executed via class or instance.</li><li class="listitem" style="list-style-type: disc">Instance methods get instances when called via instance but no implicit argument when called via class.</li></ul></div><p>A sample code usage of these methods is as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class C:
...     @staticmethod
...     def sdo(*args):
...             print(args)
...     @classmethod
...     def cdo(*args):
...             print(args)
...     def do(*args):
...             print(args)
...
&gt;&gt;&gt; ic = C()
# staticmethod called through class: no implicit argument is passed
&gt;&gt;&gt; C.sdo(1,2)
(1, 2)
# staticmethod called through instance:no implicit argument is passed
&gt;&gt;&gt; ic.sdo(1,2)(1, 2)
# classmethod called through instance: first argument implicitly class
&gt;&gt;&gt; ic.cdo(1,2)
(&lt;class '__main__.C'&gt;, 1, 2)
# classmethod called through class: first argument implicitly class
&gt;&gt;&gt; C.cdo(1,2)
(&lt;class '__main__.C'&gt;, 1, 2)
# instancemethod called through instance: first argument implicitly instance
&gt;&gt;&gt; ic.do(1,2)
(&lt;__main__.C object at 0x00DC9E30&gt;, 1, 2)
#instancemethod called through class: no implicit argument, acts like static method.
&gt;&gt;&gt; C.do(1,2)
(1, 2)</pre></div><p>They can be <a id="id35" class="indexterm"/>understood <a id="id36" class="indexterm"/>and <a id="id37" class="indexterm"/>implemented<a id="id38" class="indexterm"/> using <a id="id39" class="indexterm"/>descriptors <a id="id40" class="indexterm"/>easily as follows:</p><div class="informalexample"><pre class="programlisting">from functools import partial
&gt;&gt;&gt; class my_instancemethod:
...     def __init__(self, f):
...         # we store reference to function in instance
...         # for future reference
...         self.f = f
...     def __get__(self, obj, objtype):
...         # obj is None when called from class
...         # objtype is always present
...         if obj is not None:
...             return partial(self.f,obj)
...         else: # called from class
...             return self.f
...
&gt;&gt;&gt; class my_classmethod:
...     def __init__(self, f):
...         self.f = f
...     def __get__(self, obj, objtype):
...         # we pass objtype i.e class object
...         # when called from instance or class
...         return partial(self.f,objtype)
...
&gt;&gt;&gt; class my_staticmethod:
...     def __init__(self, f):
...         self.f = f
...     def __get__(self, obj, objtype):
...         # we do not pass anything
...         # for both conditions
...         return self.f
...
&gt;&gt;&gt; class C:
...     @my_instancemethod
...     def ido(*args):
...         print("imethod",args)
...     @my_classmethod
...     def cdo(*args):
...         print("cmethod",args)
...     @my_staticmethod
...     def sdo(*args):
...         print("smethod",args)
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.ido(1,2)
imethod (&lt;__main__.C object at 0x00D7CBD0&gt;, 1, 2)
&gt;&gt;&gt; C.ido(1,2)
imethod (1, 2)
&gt;&gt;&gt; c.cdo(1,2)
cmethod (&lt;class '__main__.C'&gt;, 1, 2)
&gt;&gt;&gt; C.cdo(1,2)
cmethod (&lt;class '__main__.C'&gt;, 1, 2)
&gt;&gt;&gt; c.sdo(1,2)
smethod (1, 2)
&gt;&gt;&gt; C.sdo(1,2)
smethod (1, 2)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, we dived into how objects work in the Python language, how are they connected, and how are they called. Descriptors and instance creation are very important topics as they give us a picture of how system works. We also dived into how attributes are looked up for objects.</p><p>Now, we are all prepared to learn how to use language constructs to their maximum potential. In the next chapter, we will also discover utilities that are extremely helpful in elegantly finishing a project.</p></div></body></html>