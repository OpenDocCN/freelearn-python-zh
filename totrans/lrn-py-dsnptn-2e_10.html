<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;The State Design Pattern" id="2C9D01-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. The State Design Pattern</h1></div></div></div><p class="calibre6">In this chapter, we will cover the State design pattern. Like the Command or Template design patterns, State pattern falls under the hood of Behavioral patterns. You will be introduced to the State design pattern, and we will discuss how it is used in software application development. We will work with a sample use case, a real-world scenario, and implement this in Python v3.5. </p><p class="calibre6">We will briefly cover these topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Introduction to the State design pattern</li><li class="listitem">The State design pattern and its UML diagram</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">State pattern: advantages and disadvantages</li></ul></div><p class="calibre6">At the end of this chapter, you will appreciate the application and context of the State design pattern.</p></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;The State Design Pattern" id="2C9D01-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="Defining the State design pattern"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec73" class="calibre1"/>Defining the State design pattern</h1></div></div></div><p class="calibre6">Behavioral <a id="id253" class="calibre1"/>patterns focus on the responsibilities that an object has. They deal with the interaction among objects to achieve larger functionality. The State design pattern is a Behavioral design pattern, which is also sometimes <a id="id254" class="calibre1"/>referred to as an <span class="strong"><strong class="calibre7">objects for states</strong></span> pattern. In this pattern, an object can encapsulate multiple behaviors based on its internal state. A State pattern is also considered as a way for an object to change its behavior at runtime.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre6">Changing behavior at runtime is something that Python excels at!</p></div><p class="calibre6">For example, consider the case of a simple radio. A radio has AM/FM (a toggle switch) channels and a scan button to scan across multiple FM/AM channels. When a user switches on the radio, the base state of the radio is already set (say, it is set to FM). On clicking the Scan button, the radio gets tuned to multiple valid FM frequencies or channels. When the base State is now changed to AM, the scan button helps the user to tune into multiple AM channels. Hence, based on the base state (AM/FM) of the radio, the scan<a id="id255" class="calibre1"/> button's behavior dynamically changes when tuning into AM or FM channels.</p><p class="calibre6">Thus, the State pattern allows an object to change its behavior when its internal state changes. It will appear as though the object itself has changed its class. The State design pattern is used to develop Finite State Machines and helps to accommodate State Transaction Actions.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;The State Design Pattern" id="2C9D01-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="Defining the State design pattern">
<div class="book" title="Understanding the State design pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec48" class="calibre1"/>Understanding the State design pattern</h2></div></div></div><p class="calibre6">The State <a id="id256" class="calibre1"/>design patterns works with the help of three main participants:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">State</code>: This is<a id="id257" class="calibre1"/> considered to be an interface that encapsulates the object's behavior. This behavior is associated with the state of the object.</li><li class="listitem"><code class="email">ConcreteState</code>: This is<a id="id258" class="calibre1"/> a subclass that implements the <code class="email">State</code> interface. <code class="email">ConcreteState</code> implements the actual behavior associated with the object's particular state.</li><li class="listitem"><code class="email">Context</code>: This<a id="id259" class="calibre1"/> defines the interface of interest to clients. <code class="email">Context</code> also maintains an instance of the <code class="email">ConcreteState</code> subclass that internally defines the implementation of the object's particular state.</li></ul></div><p class="calibre6">Let's take a look at the structural code implementation of the State design pattern with these three participants. In this code implementation, we define a <code class="email">State</code> interface that has a <code class="email">Handle()</code> abstract method. The <code class="email">ConcreteState</code> classes, <code class="email">ConcreteStateA</code> and <code class="email">ConcreteStateB</code>, implement the State interface and, thus, define the <code class="email">Handle()</code> methods specific to the <code class="email">ConcreteState</code> classes. So, when the <code class="email">Context</code> class is set for a state, the <code class="email">Handle()</code> method of this state's <code class="email">ConcreteClass</code> gets called. In the following example, since <code class="email">Context</code> is set to <code class="email">stateA</code>, the <code class="email">ConcreteStateA.Handle()</code> method gets called and prints <code class="email">ConcreteStateA</code>:</p><div class="informalexample"><pre class="programlisting">from abc import abstractmethod, ABCMeta

class State(metaclass=ABCMeta):
    
    @abstractmethod
    def Handle(self):
        pass


class ConcreteStateB(State):
    def Handle(self):
        print("ConcreteStateB")


class ConcreteStateA(State):
    def Handle(self):
        print("ConcreteStateA")


class Context(State):
    
    def __init__(self):
        self.state = None
    
    def getState(self):
        return self.state
    
    def setState(self, state):
        self.state = state
    
    def Handle(self):
        self.state.Handle()


context = Context()
stateA = ConcreteStateA()
stateB = ConcreteStateB()

context.setState(stateA)
context.Handle()</pre></div><p class="calibre6">We<a id="id260" class="calibre1"/> will see the following output:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Understanding the State design pattern" class="calibre14"/></div><p class="calibre15"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;The State Design Pattern" id="2C9D01-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="Defining the State design pattern">
<div class="book" title="Understanding the State design pattern with a UML diagram"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec49" class="calibre1"/>Understanding the State design pattern with a UML diagram</h2></div></div></div><p class="calibre6">As we <a id="id261" class="calibre1"/>saw in the previous section, there are three main participants in the UML diagram: <code class="email">State</code>, <code class="email">ConcreteState</code>, and <code class="email">Context</code>. In this section, we will try to manifest them on a UML class diagram.</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Understanding the State design pattern with a UML diagram" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">Let's understand the elements of UML diagram in detail:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">State</code>: This is an interface that defines the <code class="email">Handle()</code> abstract method. The <code class="email">Handle()</code> method needs to be implemented by <code class="email">ConcreteState</code>.</li><li class="listitem"><code class="email">ConcreteState</code>: In this UML diagram, we have defined two <code class="email">ConcreteClasses</code>: <code class="email">ConcreteStateA</code>, and <code class="email">ConcreteStateB</code>. These implement the <code class="email">Handle()</code> method and define the actual action to be taken based on the <code class="email">State</code> change.</li><li class="listitem"><code class="email">Context</code>: This is a class that accepts the client's request. It also maintains a reference to the object's current state. Based on the request, the concrete behavior gets called.</li></ul></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="A simple example of the State design pattern" id="2D7TI1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec74" class="calibre1"/>A simple example of the State design pattern</h1></div></div></div><p class="calibre6">Let's<a id="id262" class="calibre1"/> understand all three participants with a simple example. Say, we want to implement a TV remote with a simple button to perform on/off actions. If the TV is on, the remote button will switch off the TV and vice versa. In this case, the <code class="email">State</code> interface will define the method (say, <code class="email">doThis()</code>) to perform actions such as switching on/off the TV. We also need to define <code class="email">ConcreteClass</code> for different states. In this example, we have two major states, <code class="email">StartState</code> and <code class="email">StopState</code>, which indicate when the TV is switched on and the state in which the TV is switched off, respectively. </p><p class="calibre6">For this scenario, the <code class="email">TVContext</code> class will implement the <code class="email">State</code> interface and keep a reference to the current state. Based on the request, <code class="email">TVContext</code> forwards the request to <code class="email">ConcreteState</code>, which implements the actual behavior (for a given state) and performs the necessary action. So, in this case, the base state is <code class="email">StartState</code> (as defined earlier) and the request received by <a id="id263" class="calibre1"/>the <code class="email">TVContext</code> class is to switch Off the TV. <code class="email">TVContext</code> class understands the need and accordingly forwards the request to <code class="email">StopState</code> concrete class which inturn calls the <code class="email">doThis()</code> method to actually switch off the TV:</p><div class="informalexample"><pre class="programlisting">from abc import abstractmethod, ABCMeta

class State(metaclass=ABCMeta):
    
    @abstractmethod
    def doThis(self):
        pass


class StartState (State):
    def doThis(self):
        print("TV Switching ON..")


class StopState (State):
    def doThis(self):
        print("TV Switching OFF..")


class TVContext(State):
    
    def __init__(self):
        self.state = None
    
    def getState(self):
        return self.state
    
    def setState(self, state):
        self.state = state
    
    def doThis(self):
        self.state.doThis()


context = TVContext()
context.getState()
start = StartState()
stop = StopState()

context.setState(stop)
context.doThis()</pre></div><p class="calibre6">Here is the output for the preceding code:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="A simple example of the State design pattern" class="calibre14"/></div><p class="calibre15"> </p></div>

<div class="book" title="A simple example of the State design pattern" id="2D7TI1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="The State design pattern with v3.5 implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec50" class="calibre1"/>The State design pattern with v3.5 implementation</h2></div></div></div><p class="calibre6">Let's<a id="id264" class="calibre1"/> now take a look at a real-world use case for the State design pattern. Think of a computer system (desktop/laptop). It can have multiple states such as <code class="email">On</code>, <code class="email">Off</code>, <code class="email">Suspend</code>, or <code class="email">Hibernate</code>. Now, if we want to manifest these states with the help of State design pattern, how will we do it?</p><p class="calibre6">Say, we start with the <code class="email">ComputerState</code> interface:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The state should define two attributes, which are <code class="email">name</code> and <code class="email">allowed</code>. The <code class="email">name</code> attribute represents the state of the object, and <code class="email">allowed</code> is a list that defines the state's object, which it is allowed to get into.</li><li class="listitem">The state must define a <code class="email">switch()</code> method, which will actually change the state of the object (in this case, the computer).</li></ul></div><p class="calibre6">Let's take a look at the code implementation of the <code class="email">ComputerState</code> interface:</p><div class="informalexample"><pre class="programlisting">class ComputerState(object):
    name = "state"
    allowed = []
    
    def switch(self, state):
        if state.name in self.allowed:
            print('Current:',self,' =&gt; switched to new state',state.name)
            self.__class__ = state
        else:
            print('Current:',self,' =&gt; switching to',state.name,'not possible.')
    
    def __str__(self):
        return self.name</pre></div><p class="calibre6">Let's now take a look at <code class="email">ConcreteState</code>, which implements the <code class="email">State</code> interface. We will define four states:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">On</code>: This switches <span class="strong"><em class="calibre13">on</em></span> the computer. The allowed states here are <code class="email">Off</code>, <code class="email">Suspend</code>, and <code class="email">Hibernate</code>.</li><li class="listitem"><code class="email">Off</code>: This switches <span class="strong"><em class="calibre13">off</em></span> the computer. The allowed state here is just <code class="email">On</code>.</li><li class="listitem"><code class="email">Hibernate</code>: This state puts the computer in the <span class="strong"><em class="calibre13">hibernate</em></span> mode. The computer can only get switched on when it's in this state.</li><li class="listitem"><code class="email">Suspend</code>: This state <span class="strong"><em class="calibre13">suspends</em></span> the computer, and once the computer is suspended, it can be switched on.</li></ul></div><p class="calibre6">Let's now <a id="id265" class="calibre1"/>take a look at the code:</p><div class="informalexample"><pre class="programlisting">class Off(ComputerState):
    name = "off"
    allowed = ['on']

class On(ComputerState):
    name = "on"
    allowed = ['off','suspend','hibernate']

class Suspend(ComputerState):
    name = "suspend"
    allowed = ['on']

class Hibernate(ComputerState):
    name = "hibernate"
    allowed = ['on']</pre></div><p class="calibre6">Now, we explore the context class (<code class="email">Computer</code>). The context does two main things:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">__init__()</code>: This method defines the base state of the computer</li><li class="listitem"><code class="email">change()</code>: This method will change the state of the object, and the actual change in behavior is implemented by the <code class="email">ConcreteState</code> classes (<code class="email">on</code>, <code class="email">off</code>, <code class="email">suspend</code>, and <code class="email">hibernate</code>)</li></ul></div><p class="calibre6">Here is the implementation of the preceding methods:</p><div class="informalexample"><pre class="programlisting">class Computer(object):
    def __init__(self, model='HP'):
        self.model = model
        self.state = Off()
    
    def change(self, state):
        self.state.switch(state)</pre></div><p class="calibre6">The following is the code for the client. We create the object of the <code class="email">Computer</code> class (<code class="email">Context</code>) and pass a state to it. The state can be either of these: <code class="email">On</code>, <code class="email">Off</code>, <code class="email">Suspend</code>, and <code class="email">Hibernate</code>. Based on the new state, the context calls its <code class="email">change(state)</code> method, which eventually switches the actual state of the computer:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    comp = Computer()
    # Switch on
    comp.change(On)
    # Switch off
    comp.change(Off)
    
    # Switch on again
    comp.change(On)
    # Suspend
    comp.change(Suspend)
    # Try to hibernate - cannot!
    comp.change(Hibernate)
    # switch on back
    comp.change(On)
    # Finally off
    comp.change(Off)</pre></div><p class="calibre6">Now, we <a id="id266" class="calibre1"/>can observe the following output:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="The State design pattern with v3.5 implementation" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">
<code class="email">__class__</code> is a built-in attribute of every class. It is a reference to the class. For instance, <code class="email">self.__class__.__name__</code> represents the name of the class.  In this example, we use <code class="email">__class__ attribute</code> of Python to change the <code class="email">State</code>. So, when we pass the state to the <code class="email">change()</code> method, the class of the objects gets dynamically changed at runtime. The <code class="email">comp.change(On)</code> code, changes the object state to <code class="email">On</code> and subsequently to different states like <code class="email">Suspend</code>, <code class="email">Hibernate</code>, and <code class="email">Off</code>.</p></div></div>
<div class="book" title="Advantages/disadvantages of the State pattern" id="2E6E41-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec75" class="calibre1"/>Advantages/disadvantages of the State pattern</h1></div></div></div><p class="calibre6">Here<a id="id267" class="calibre1"/> are the benefits of the State design pattern:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In the State design pattern, an object's behavior is the result of the function of its state, and the behavior gets changed at runtime depending on the state. This removes the dependency on the if/else or switch/case conditional logic. For example, in the TV remote scenario, we could have also implemented the behavior by simply writing one class and method that will ask for a parameter and perform an action (switch the TV on/off) with an <code class="email">if</code>/<code class="email">else</code> block.</li><li class="listitem">With State pattern, the benefits of implementing polymorphic behavior are evident, and it is also easier to add states to support additional behavior.</li><li class="listitem">The<a id="id268" class="calibre1"/> State design pattern also improves <span class="strong"><strong class="calibre7">Cohesion</strong></span> since state-specific behaviors are aggregated into the <code class="email">ConcreteState</code> classes, which are placed in one location in the code.</li><li class="listitem">With the <a id="id269" class="calibre1"/>State design pattern, it is very easy to add a behavior by just adding one more <code class="email">ConcreteState</code> class. State pattern thus improves the flexibility to extend the behavior of the application and overall improves code maintenance.</li></ul></div><p class="calibre6">We have seen the advantages of state patterns. However, they also have a few pitfalls:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre7">Class Explosion</strong></span>: Since every state needs to be defined with the help of <code class="email">ConcreteState</code>, there is a chance that we might end up writing many more classes with a small functionality. Consider the case of finite state machines—if there are many states but each state is not too different from another state, we'd still need to write them as separate <code class="email">ConcreteState</code> classes. This increases the amount of code we need to write, and it becomes difficult to review the structure of a state machine.</li><li class="listitem">With the introduction of every new behavior (even though adding behavior is just adding one more <code class="email">ConcreteState</code>), the <code class="email">Context</code> class needs to be updated to deal with each behavior. This makes the <code class="email">Context</code> behavior more brittle with every new behavior.</li></ul></div></div>
<div class="book" title="Summary" id="2F4UM1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec76" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">To summarize what we've learned so far, in State design patterns, the object's behavior is decided based on its state. The state of the object can be changed at runtime. Python's ability to change behavior at runtime makes it very easy to apply and implement the State design pattern. The State pattern also gives us control over deciding the states that objects can take up such as those in the computer example that we saw earlier in the chapter. The <code class="email">Context</code> class provides an easier interface for clients, and <code class="email">ConcreteState</code> makes sure it is easy to add behaviors to the objects. Thus, the State pattern improves cohesion, flexibility to extend, and removes redundant code blocks. We academically studied the pattern in the form of a UML diagram and learned about the implementation aspects of the State pattern with help of the Python v3.5 code implementation. We also took a look at the few pitfalls you might encounter when it comes to the State pattern, and the code which can significantly increase when it comes to adding more states or behaviors. I hope you had a nice time going through this chapter!</p></div></body></html>