["```py\ndef factorial(n):\n    # test for a base case\n    if n == 0:\n        return 1\n    else:\n    # make a calculation and a recursive call\n        return n*factorial(n-1) \nprint(factorial(4)) \n```", "```py\n24 \n```", "```py\ndef binary_search(arr, start, end, key):\n    while start <= end:  \n        mid = start + (end - start)/2\n        if arr[mid] == key:  \n            return mid  \n        elif arr[mid] < key:  \n            start = mid + 1  \n        else:  \n            end = mid - 1  \n    return -1  \narr = [4, 6, 9, 13, 14, 18, 21, 24, 38] \nx = 13\nresult = binary_search(arr, 0, len(arr)-1, x)  \nprint(result) \n```", "```py\ndef merge_sort(unsorted_list): \n    if len(unsorted_list) == 1: \n        return unsorted_list\n    mid_point = int(len(unsorted_list)/2)\n    first_half = unsorted_list[:mid_point] \n    second_half = unsorted_list[mid_point:] \n    half_a = merge_sort(first_half) \n    half_b = merge_sort(second_half) \n    return merge(half_a, half_b) \n```", "```py\n first_half = unsorted_list[:mid_point] \n    second_half = unsorted_list[mid_point:] \n```", "```py\n half_a = merge_sort(first_half)\n    half_b = merge_sort(second_half) \n```", "```py\ndef merge(first_sublist, second_sublist): \n    i = j = 0\n    merged_list = []\n    while i < len(first_sublist) and j < len(second_sublist):\n        if first_sublist[i] < second_sublist[j]:\n            merged_list.append(first_sublist[i]) \n            i += 1 \n        else:\n            merged_list.append(second_sublist[j]) \n            j += 1\n    while i < len(first_sublist): \n        merged_list.append(first_sublist[i]) \n        i += 1 \n    while j < len(second_sublist):\n        merged_list.append(second_sublist[j]) \n        j += 1\n    return merged_list \n```", "```py\n while i < len(first_sublist) and j < len(second_sublist): \n        if first_sublist[i] < second_sublist[j]: \n            merged_list.append(first_sublist[i]) \n            i += 1 \n        else: \n            merged_list.append(second_sublist[j]) \n            j += 1 \n```", "```py\na= [11, 12, 7, 41, 61, 13, 16, 14] \nprint(merge_sort(a)) \n```", "```py\n[7, 11, 12, 14, 16, 41, 61] \n```", "```py\nfunc(0) = 1 \nfunc(1) = 1  \nfunc(n) = func(n-1) + func(n-2) for n>1 \n```", "```py\n 1 1 2 3 5 \n```", "```py\ndef fib(n):   \n     if n <= 1:   \n        return 1   \n     else:  \n        return fib(n-1) + fib(n-2)  \nfor i in range(5):\n    print(fib(i)) \n```", "```py\n1\n1\n2\n3\n5 \n```", "```py\ndef dyna_fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1  \n    if lookup[n] is not None:\n        return lookup[n]\n\n    lookup[n] = dyna_fib(n-1) + dyna_fib(n-2)\n    return lookup[n]\nlookup = [None]*(1000)\n\nfor i in range(6): \n    print(dyna_fib(i)) \n```", "```py\n0\n1\n1\n2\n3\n5 \n```", "```py\n if lookup[n] is not None:\n        return lookup[n] \n```", "```py\nlookup[n] = dyna_fib(n-1) + dyna_fib(n-2) \n```", "```py\n lookup = [None]*(1000) \n```", "```py\n `graph = dict()` \n `graph['A'] = {'B': 5, 'D': 9, 'E': 2}` \n `graph['B'] = {'A': 5, 'C': 2}` \n `graph['C'] = {'B': 2, 'D': 3}` \n `graph['D'] = {'A': 9, 'F': 2, 'C': 3}` \n `graph['E'] = {'A': 2, 'F': 3}` \n `graph['F'] = {'E': 3, 'D': 2}` \n```", "```py\n table = { \n    'A': [0, None], \n    'B': [float(\"inf\"), None], \n    'C': [float(\"inf\"), None], \n    'D': [float(\"inf\"), None], \n    'E': [float(\"inf\"), None], \n    'F': [float(\"inf\"), None], \n} \n```", "```py\nDISTANCE = 0 \nPREVIOUS_NODE = 1 \nINFINITY = float('inf') \n```", "```py\ndef get_shortest_distance(table, vertex): \n    shortest_distance = table[vertex][DISTANCE] \n    return shortest_distance \n```", "```py\ndef set_shortest_distance(table, vertex, new_distance): \n    table[vertex][DISTANCE] = new_distance \n```", "```py\ndef set_previous_node(table, vertex, previous_node): \n    table[vertex][PREVIOUS_NODE] = previous_node \n```", "```py\ndef get_distance(graph, first_vertex, second_vertex): \n    return graph[first_vertex][second_vertex] \n```", "```py\n def get_next_node(table, visited_nodes): \n        unvisited_nodes = list(set(table.keys()).difference(set(visited_nodes))) \n        assumed_min = table[unvisited_nodes[0]][DISTANCE] \n        min_vertex = unvisited_nodes[0] \n        for node in unvisited_nodes: \n            if table[node][DISTANCE] < assumed_min: \n                assumed_min = table[node][DISTANCE] \n                min_vertex = node \n        return min_vertex \n```", "```py\ndef find_shortest_path(graph, table, origin): \n    visited_nodes = [] \n    current_node = origin \n    starting_node = origin \n    while True: \n        adjacent_nodes = graph[current_node] \n        if set(adjacent_nodes).issubset(set(visited_nodes)): \n            # Nothing here to do. All adjacent nodes have been visited. \n            pass \n        else: \n            unvisited_nodes = \n                set(adjacent_nodes).difference(set(visited_nodes)) \n            for vertex in unvisited_nodes: \n                distance_from_starting_node = \n                    get_shortest_distance(table, vertex) \n                if distance_from_starting_node == INFINITY and \n                   current_node == starting_node: \n                    total_distance = get_distance(graph, vertex, \n                                                  current_node) \n                else: \n                    total_distance = get_shortest_distance (table, \n                    current_node) + get_distance(graph, current_node, \n                                                 vertex) \n                if total_distance < distance_from_starting_node: \n                    set_shortest_distance(table, vertex, \n                                          total_distance) \n                    set_previous_node(table, vertex, current_node) \n        visited_nodes.append(current_node)\n        #print(visited_nodes)\n        if len(visited_nodes) == len(table.keys()): \n            break \n        current_node = get_next_node(table,visited_nodes) \n      return (table) \n```", "```py\n distance_from_starting_node = get_shortest_distance(table, vertex) \n```", "```py\n if distance_from_starting_node == INFINITY and current_node == starting_node: \n         total_distance = get_distance(graph, vertex, current_node) \n```", "```py\n total_distance = get_distance(graph, vertex, current_node) \n```", "```py\n if total_distance < distance_from_starting_node: \n        set_shortest_distance(table, vertex, total_distance)\n        set_previous_node(table, vertex, current_node) \n```", "```py\n visited_nodes.append(current_node) \n```", "```py\nshortest_distance_table = find_shortest_path(graph, table, 'A') \nfor k in sorted(shortest_distance_table): \n     print(\"{} - {}\".format(k,shortest_distance_table[k])) \n```", "```py\nA - [0, None]\nB - [5, 'A']\nC - [7, 'B']\nD - [7, 'F']\nE - [2, 'A']\nF - [5, 'E'] \n```"]