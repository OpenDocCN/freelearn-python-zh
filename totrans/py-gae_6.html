<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using Channels to Implement a Real-time Application</h1></div></div></div><p>Web applications use the request/response message exchange pattern to communicate with the server. The communication flow always starts from the client (usually a web browser), initiating a request and a server that provides a response and closes the connection immediately after. This means that if we need to get information from a server as soon as they are available, our client has to actively and repeatedly request for them using a polling strategy, which is a simple but often ineffective solution. In fact, if the poll interval is short, we need to perform a lot of requests, which consumes time and bandwidth and overloads the server; on the other hand, if the poll interval is long, we cannot consider the delivery of the information as real time anymore.</p><p>Real-time interaction between clients and servers is a requirement for a large set of web applications such as collaborative editors, online multiplayer games, or instant messaging software. In general, anytime a client needs to get information that is not systematic or predictable, similar to how it is when interacting with human users, we better go real time.</p><p>If our <a id="id371" class="indexterm"/>application runs on App Engine, we can use the <strong>Channel</strong> API to create an apparently persistent connection between the browsers that access the application and Google servers; this connection can be used at any time to send messages to the connected clients nearly in real time, without having to take care of the underlying communication mechanisms.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The technology behind the Channel API</li><li class="listitem" style="list-style-type: disc">How to implement the server part of a real-time application</li><li class="listitem" style="list-style-type: disc">How to implement the client part of a real-time application with JavaScript</li><li class="listitem" style="list-style-type: disc">How to deal with a client's disconnection</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Understanding how the Channel API works</h1></div></div></div><p>The<a id="id372" class="indexterm"/> Channel API basically consists of the following elements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Channel</strong>: This is a one-way communication path between the server and a JavaScript <a id="id373" class="indexterm"/>client. There is exactly one channel for each client and the server uses it to dispatch messages.</li><li class="listitem" style="list-style-type: disc"><strong>Client ID</strong>: This is a string that identifies individual JavaScript clients on the server. We<a id="id374" class="indexterm"/> can specify any string as the Client ID, for example, the identifier of the current user.</li><li class="listitem" style="list-style-type: disc"><strong>JavaScript client</strong>: The client is responsible for connecting to a specific channel, listening<a id="id375" class="indexterm"/> to updates on the channel itself, and sending messages to the server via HTTP requests.</li><li class="listitem" style="list-style-type: disc"><strong>Server</strong>: The server is responsible for creating channels for each JavaScript<a id="id376" class="indexterm"/> client connected, providing access tokens to authenticate connections, receiving messages from the client via HTTP requests, and sending updates through the channels.</li></ul></div><p>The first step for using the Channel API is delivering the JavaScript client to our users and building the code into the web pages served by the application. After the browser receives and executes the client code, the following occurs:</p><div><ol class="orderedlist arabic"><li class="listitem">The JavaScript client asks the server with an HTTP request for a token to open a channel providing its own Client ID.</li><li class="listitem">The server creates a channel and assigns a token to it; the token is sent back to the client.</li><li class="listitem">The JavaScript client uses the token to connect to the channel.</li></ol></div><p>Once the client is connected to the channel, the server can push messages through the channel with the JavaScript client handling them in real time, as shown in the following screenshot:</p><div><img src="img/8194OS_06_01.jpg" alt="Understanding how the Channel API works"/></div><p>We have<a id="id377" class="indexterm"/> to keep in mind two important limitations when we design an application that makes use of the Channel API:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Only one client at a time can connect to a channel using a given Client ID; we cannot share the same channel among multiple clients.</li><li class="listitem" style="list-style-type: disc">A JavaScript client can connect only to one channel for each page; if we want to send and receive multiple types of data from the server (for example, data regarding different parts of the page), we need to multiplex them so that all the information can flow through the same channel.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Making our application real time</h1></div></div></div><p>To <a id="id378" class="indexterm"/>show how to use the Channel API, we will add a small feature to our Notes application. If we open the main page in a browser, there is no way for us to realize that a new note was created until we refresh the page. As a note can be created using the inbound e-mail service, it'd be nice to immediately see the change in our browser.</p><p>We are going to implement this feature using the Channel API: when we visit the main page, our application will open a channel, which will wait for new notes to be created. We will<a id="id379" class="indexterm"/> keep things as simple as possible for the scope of this book, and to avoid writing too much JavaScript code, we won't modify the <strong>Document Object Model</strong> (<strong>DOM</strong>)<a id="id380" class="indexterm"/> of the page; we will only show a dialog that suggests to refresh the page to see new content as soon as new notes are added.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Implementing the server</h1></div></div></div><p>We will <a id="id381" class="indexterm"/>start by adding the Python code needed to handle channels on the server side. We expect the JavaScript client will make an HTTP <code class="literal">GET</code> request to request a channel, so we add a request handler that will create a channel and return a token in the JSON format to access it. We first import the modules needed at the top of our <code class="literal">main.py</code> module:</p><div><pre class="programlisting">from google.appengine.api import channel
from utils import get_notification_client_id
import json</pre></div><p>Then, we add the code for the request handler:</p><div><pre class="programlisting">class GetTokenHandler(webapp2.RequestHandler):
    def get(self):
        user = users.get_current_user()
        if user is None:
            self.abort(401)

        client_id = get_notification_client_id(user)
        token = channel.create_channel(client_id, 60)

        self.response.headers['Content-Type'] = 'application/json'
        self.response.write(json.dumps({'token': token}))</pre></div><p>We first check that the user is logged in and return an <strong>HTTP 401: Unauthorized error</strong> page if this is not the case. Then, we create a Client ID for the current JavaScript client using a <code class="literal">get_notification_client_id()</code> method that generates a string that composes the identifier of the <code class="literal">user</code> instance we pass to it together with an arbitrary prefix:</p><div><pre class="programlisting">def get_notification_client_id(user):
    return 'notify-' + user.user_id()</pre></div><p>We can add the preceding code to the <code class="literal">utils.py</code> module for convenience.</p><p>Back to the <code class="literal">GetTokenHandler</code> code; after we get a Client ID for the client, we can proceed to creating the channel by calling the <code class="literal">create_channel()</code> method and passing the identifier as the first argument. The second parameter we pass to the function is the time<a id="id382" class="indexterm"/>out for the channel expressed in minutes; when a channel expires, an error is raised to the JavaScript client and the channel is closed. The default value when we do not specify that parameter is 2 hours, after which the client can ask for a new channel. We then set the <code class="literal">Content-Type</code> header for the response to the <code class="literal">application/json</code> parameter and finally write the token in the response body.</p><p>We finally map the <code class="literal">GetTokenHandler</code> handler to the <code class="literal">/notify_token</code> URL in our <code class="literal">main.py</code> module:</p><div><pre class="programlisting">app = webapp2.WSGIApplication([
    (r'/', MainHandler),
    (r'/media/(?P&lt;file_name&gt;[\w.]{0,256})', MediaHandler),
    (r'/shrink', ShrinkHandler),
    (r'/shrink_all', ShrinkCronJob),
    (r'/toggle/(?P&lt;note_key&gt;[\w\-]+)/(?P&lt;item_index&gt;\d+)', ToggleHandler),
    (r'/_ah/mail/create@book-123456\.appspotmail\.com', CreateNoteHandler),
    (r'/notify_token', GetTokenHandler),
], debug=True)</pre></div><p>We can check whether the endpoint is working properly by visiting the <code class="literal">http://localhost:8080/notify_token</code> URL with the local development server running. We should see something like this in the browser window:</p><div><img src="img/8194OS_06_02.jpg" alt="Implementing the server"/></div><p>The<a id="id383" class="indexterm"/> last part of the work we need to do on the server side is actually using the channels we create to send messages to our users. In particular, we want to notify a user as soon as a new note is created using the inbound e-mail service. So, we are going to add some code to the <code class="literal">CreateNoteHandler</code> handler, modifying the code of the <code class="literal">receive()</code> method as follows:</p><div><pre class="programlisting">def receive(self, mail_message):
    email_pattern = re.compile(r'([\w\-\.]+@(\w[\w\-]+\.)+[\w\-]+)')
    match = email_pattern.findall(mail_message.sender)
    email_addr = match[0][0] if match else ''

    try:
        user = users.User(email_addr)
        user = self._reload_user(user)
    except users.UserNotFoundError:
        return self.error(403)

    title = mail_message.subject
    content = ''
    for content_t, body in mail_message.bodies('text/plain'):
        content += body.decode()

    attachments = getattr(mail_message, 'attachments', None)

    self._create_note(user, title, content, attachments)
    channel.send_message(get_notification_client_id(user),
                        json.dumps("A new note was created! "
                                   "Refresh the page to see it."))</pre></div><p>After a note is actually created, we use the <code class="literal">send_message()</code> method from the channel module to send a message to a particular client. To get the Client ID of the recipient, we use the <code class="literal">get_notification_client_id()</code> method as we did before during channel creation. The <a id="id384" class="indexterm"/>second parameter we pass to the <code class="literal">send_message()</code> method is the string that represents the message we want to send to our client; in this case, we will show some simple text on a dialog in the browser as soon as the message is delivered. In a real-world scenario, we would use a more complex message than a plain string, adding some more data to let JavaScript clients identify the type and the destination of the message; this is very useful if we have to multiplex the channel to carry different information for different consumers.</p><p>We have now completed all the required work on the server, so we can move to the client side and write the JavaScript code we need to interact with the Channel API.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec34"/>The JavaScript code for clients</h2></div></div></div><p>App<a id="id385" class="indexterm"/> Engine provides a small JavaScript library<a id="id386" class="indexterm"/> that simplifies some operations needed to manage the socket connection for a channel, so the first thing we need to do before proceeding is include this code in our HTML pages. The JavaScript code must be included within the <code class="literal">&lt;body&gt;&lt;/body&gt;</code> tags, and we will put it just before the closing tag so that its execution will not slow down the page-rendering process.</p><p>In our <code class="literal">main.html</code> template file, we add the following:</p><div><pre class="programlisting">  &lt;!-- Javascript here --&gt;
  &lt;script type="text/javascript" src="img/jsapi"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The JavaScript code will be served by App Engine, both in the local development environment and in production, at the <code class="literal">/_ah/channel/jsapi</code> URL.</p><p>The <a id="id387" class="indexterm"/>code required to provide the logic for the JavaScript <a id="id388" class="indexterm"/>client will be added in a file called <code class="literal">client.js</code> that we will store in the <code class="literal">static/js/</code> path relative to the application root folder. In this manner, the file will be uploaded to App Engine servers together with the other static assets during the deployment process.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>We will write our JavaScript code inside a type of closure known as an <strong>Immediately-Invoked Function Expression</strong> (<strong>IIFE</strong>), which<a id="id389" class="indexterm"/> is nothing more than a self-invoked anonymous function executed in the context of the <code class="literal">window</code> parameter as follows:</p><div><pre class="programlisting">
<strong>(function(window){</strong>
<strong>    "use strict";    </strong>
<strong>    </strong>
<strong>    var a = 'foo';</strong>
<strong>    </strong>
<strong>    function private(){</strong>
<strong>        // do something</strong>
<strong>    }   </strong>
<strong>    </strong>
<strong>})(this);</strong>
</pre></div><p>This is a common JavaScript expression most useful when attempting to preserve the global namespace; in fact, any variable declared within the function's body will be local to the closure but will still live throughout runtime.</p></div></div><p>Once we have created our <code class="literal">client.js</code> file, we need to include it within the HTML pages served by our Notes application. In the <code class="literal">main.html</code> file, we add the following:</p><div><pre class="programlisting"> &lt;!-- Javascript here --&gt;
 &lt;script type="text/javascript" src="img/jsapi"&gt;&lt;/script&gt;
 &lt;script type="text/javascript" src="img/client.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The order of the <code class="literal">&lt;script&gt;</code> tags is important because the JavaScript client must be available before executing our code.</p><p>Thanks to the functionalities provided by the JavaScript client library, we do not need to write much code. First of all, we need to retrieve the channel token from our backend, so we add the following to the <code class="literal">client.js</code> file:</p><div><pre class="programlisting">(function (window) {
  "use strict";
  
  // get channel token from the backend and connect
  var init = function() {
    var tokenReq = new XMLHttpRequest();
    tokenReq.onload = function () {

      var token = JSON.parse(this.responseText).token;
      console.log(token);

    };
    tokenReq.open("get", "/notify_token", true);
    tokenReq.send();
  };

  init();

}(this));</pre></div><p>Here, we <a id="id390" class="indexterm"/>declare a function named <code class="literal">init</code> that will<a id="id391" class="indexterm"/> perform an <strong>XMLHttpRequest</strong> (<strong>XHR</strong>) request to our <a id="id392" class="indexterm"/>backend in order to retrieve the token and will then print its value on JavaScript Console.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Logging information on JavaScript Console is nonstandard, and it won't work for every user; this largely depends on the browser in use. For example, to enable JavaScript Console on Google Chrome, we need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to the <strong>View</strong> menu.</li><li class="listitem">Select <strong>Developer.</strong></li><li class="listitem">Click on <strong>JavaScript Console</strong>.</li></ol></div></div></div><p>The first instruction on the function body creates an <code class="literal">XMLHttpRequest</code> object that we will use to perform an HTTP <code class="literal">GET</code> request to our backend. Before firing the request, we set the <code class="literal">onload</code> callback to an anonymous function that will be executed once the response is correctly retrieved with no errors from the server. The callback function parses the text in the response body into a <code class="literal">json</code> object and logs it on JavaScript Console immediately after. After defining the callback, we initialize the request that calls the <code class="literal">open()</code> method on the <code class="literal">XMLHttpRequest</code> object and specify the HTTP method we want to use, the URL we want to reach, and a Boolean flag that represents whether we want to perform the request asynchronously or not. Later, we actually perform the request that calls the <code class="literal">send()</code> method. We then call the <code class="literal">init()</code> function itself so that it is executed the first time we visit the page and the script is loaded.</p><p>To check whether everything is working fine, we can start the local development server and point the browser to the main page after enabling JavaScript Console in our browser. If the<a id="id393" class="indexterm"/> request completed successfully, we should<a id="id394" class="indexterm"/> see the log message that contains the token on the console, as shown in the following screenshot:</p><div><img src="img/8194OS_06_03.jpg" alt="The JavaScript code for clients"/></div><p>We can now use the token retrieved from the backend to open a channel. In the <code class="literal">client.js</code> file, we modify the code as follows:</p><div><pre class="programlisting">(function (window) {
  "use strict";

  // create a channel and connect the socket
  var setupChannel = function(token) {
    var channel = new goog.appengine.Channel(token);
    var socket = channel.open();

    socket.onopen = function() {
      console.log('Channel opened!');
    };

    socket.onclose = function() {
      console.log('goodbye');
    };
  };

  // get channel token from the backend and connect
  var init = function() {
    var tokenReq = new XMLHttpRequest();
    tokenReq.onload = function () {

      var token = JSON.parse(this.responseText).token;
      setupChannel(token);

    };
    tokenReq.open("get", "/notify_token", true);
    tokenReq.send();
  };

  init();

}(this));</pre></div><p>We first <a id="id395" class="indexterm"/>add a function called <code class="literal">setupChannel()</code> that takes a valid token as its only parameter. Using the JavaScript client code<a id="id396" class="indexterm"/> from App Engine, we then create a <code class="literal">goog.appengine.Channel</code> object passing the token to the constructor. We then call the <code class="literal">open</code> method that returns a <code class="literal">goog.appengine.Socket</code> object for the channel. The socket object keeps track of the connection status and exposes several callback functions with which we can perform operations in response to channel activities. For the moment, we only provide callbacks for the <code class="literal">onopen</code> and <code class="literal">onclose</code> socket events, logging a message on JavaScript Console. Notice that we changed the <code class="literal">init()</code> function so that it now calls the <code class="literal">setupChannel()</code> function instead of simply logging a message into JavaScript Console.</p><p>To test whether the callbacks work properly or not, we can set a very short timeout for the channels when we create them in the backend so that we can see what happens when a channel expires in a reasonable amount of time. In the <code class="literal">main.py</code> module, we change the call to the <code class="literal">create_channel()</code> function in the <code class="literal">get()</code> method of the <code class="literal">GetTokenHandler</code> class in this way:</p><div><pre class="programlisting">token = channel.create_channel(client_id, 1)</pre></div><p>Now, if we open the main page of the Notes application in the browser with JavaScript Console open, we should see something similar to the following screenshot after 1 minute:</p><div><img src="img/8194OS_06_04.jpg" alt="The JavaScript code for clients"/></div><p>As we <a id="id397" class="indexterm"/>can see, the channel is opened and after 1 minute it <a id="id398" class="indexterm"/>expires, causing an error in the JavaScript client and finally calling the callback we set to be called for the <code class="literal">onclose</code> event of the socket object.</p><p>To deal with expiring channels, we can add a callback for the <code class="literal">onerror</code> event of the socket object. In our <code class="literal">client.js</code> file, we add the following:</p><div><pre class="programlisting">    socket.onopen = function() {
      console.log('Channel opened!');
    };

    socket.onerror = function(err) {
      // reconnect on timeout
      if (err.code == 401) {
        init();
      }
    };

    socket.onclose = function() {
      console.log('goodbye');
    };</pre></div><p>The callback we added is executed when an error occurs in the channel management. The callback <a id="id399" class="indexterm"/>receives an object as a parameter that contains<a id="id400" class="indexterm"/> the error message and the error code. If we receive an <strong>HTTP 401 error</strong> page, we assume that the channel expired and we call the <code class="literal">init</code> function to create and set up a new channel. This time, if we hit the main page and wait for 1 minute, we can see something like the following screenshot:</p><div><img src="img/8194OS_06_05.jpg" alt="The JavaScript code for clients"/></div><p>As we can see, after the channel has expired, a new one is immediately created; depending on how we use the channel, this can be completely transparent for our users.</p><p>Now, we can proceed to adding the code to handle messages pushed by the server through the channel. We have to provide a callback for the <code class="literal">onmessage</code> event of the <code class="literal">goog.appengine.Socket</code> class. When the socket receives a message, the callback is invoked<a id="id401" class="indexterm"/> and a parameter is passed: the message <a id="id402" class="indexterm"/>object. The <code class="literal">data</code> field of this object contains the string passed to the <code class="literal">send_message()</code> method on the server. We then add the following code to the <code class="literal">client.js</code> file:</p><div><pre class="programlisting">    socket.onopen = function() {
      console.log('Channel opened!');
    };

    socket.onmessage = function (msg) {
      window.alert(msg.data);
    };

    socket.onerror = function(err) {
      // reconnect on timeout
      if (err.code == 401) {
        init();
      }
    };</pre></div><p>As soon as a message arrives, we open a dialog on the browser using the <code class="literal">alert()</code> method of the <code class="literal">window</code> object. The dialog displays the string contained in the <code class="literal">data</code> field of the message object, stating that a new note was created and we should refresh the page to see the updated list.</p><p>To see the code in action, we can point the browser to the main page of the Notes application; then, using the local development console, we can simulate an inbound e-mail as we did in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <em>Storing and Processing Users' Data</em>.</p><p>As soon as the e-mail is received and the new note created, we should see something like this in our browser:</p><div><img src="img/8194OS_06_06.jpg" alt="The JavaScript code for clients"/></div><p>We <a id="id403" class="indexterm"/>are assuming that the only messages that arrive through<a id="id404" class="indexterm"/> the channel involve the creation of a new note, but we can send more structured data from the server; the callback function can then implement more complex logic to distinguish the content of the message and perform different operations according to this.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Tracking connections and disconnections</h1></div></div></div><p>An <a id="id405" class="indexterm"/>App Engine application is responsible for the creation of channels<a id="id406" class="indexterm"/> and the transmission of the token, but it doesn't know whether the JavaScript client is connected or not. For example, our Notes application sends a message upon the creation of a new note through the inbound e-mail service, but on the other side, the JavaScript client might or might not receive it. In some contexts, this is not an issue, but there are several use cases where an App Engine application needs to know when a client connects or disconnects from a channel.</p><p>To enable channel notifications, we first need to enable <strong>inbound Channel presence service</strong>. To do this, we have to change our <code class="literal">app.yaml</code> configuration file by adding the following code:</p><div><pre class="programlisting">inbound_services:
- mail
- channel_presence</pre></div><p>Now<a id="id407" class="indexterm"/> that the <code class="literal">presence</code> service is enabled, our Notes application<a id="id408" class="indexterm"/> will receive HTTP <code class="literal">POST</code> requests to the following URLs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">/_ah/channel/connected/</code> URL: When a JavaScript client has connected to the channel and can receive messages</li><li class="listitem" style="list-style-type: disc">The <code class="literal">/_ah/channel/disconnected/</code> URL: When a client has disconnected from the channel</li></ul></div><p>To see how the service works, we can add two handlers to the <code class="literal">main.py</code> module:</p><div><pre class="programlisting">class ClientConnectedHandler(webapp2.RequestHandler):
    def post(self):
        logging.info('{} has connected'.format(self.request.get('from')))

class ClientDisconnectedHandler(webapp2.RequestHandler):
    def post(self):
        logging.info('{} has disconnected'.format(self.request.get('from')))</pre></div><p>Each handler receives the <code class="literal">from</code> field into the <code class="literal">POST</code> request body. The field contains the Client ID of the client that has connected or disconnected from the channel. We can check out the application logs to see when the notifications take place.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we learned the differences between an application that uses the standard request/response exchange pattern to get data from a server and a real-time application, where the clients are persistently connected to the server and receive data as soon as it's available. Using the Channel API, we saw how easy it can be to implement a real-time web application when it runs on App Engine.</p><p>By adding a new feature to our Notes application, we should now have an idea of the features offered by the Channel API and what we can do to get the most out of its components.</p><p>We first implemented the server part, managing channel creation and message sending. Then, we moved to the client side, where we managed to implement the logic needed to interact with a channel by writing just a few lines of JavaScript code.</p><p>The Notes application is almost complete now and we have enough familiarity with Google Cloud Platform that we can stand to break it up and start over by using another Python web framework instead of webapp2. In the next chapter, we will re-implement Notes using Django.</p></div></body></html>