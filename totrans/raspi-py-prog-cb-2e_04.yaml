- en: Chapter 4. Creating Games and Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 创建游戏和图形
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using IDLE3 to debug your programs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IDLE3 调试你的程序
- en: Drawing lines using a mouse on a Tkinter Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标在 Tkinter Canvas 上绘制线条
- en: Creating a bat and ball game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个棒球游戏
- en: Creating an overhead scrolling game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个滚动游戏
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Games are often a great way to explore and extend your programming skills as
    they present an inherent motivating force to modify and improve your creation,
    add new features, and create new challenges. They are also great for sharing your
    ideas with others, even if they aren't interested in programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常是一个探索和扩展编程技能的绝佳方式，因为它们提供了一个内在的激励因素来修改和改进你的创作，添加新功能，并创造新的挑战。它们也非常适合与他人分享你的想法，即使他们不感兴趣编程。
- en: This chapter focuses on using the Tkinter Canvas widget to create and display
    objects on screen for the user to interact with. Using these techniques, a wide
    variety of games and applications can be created that are limited only by your
    own creativity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用 Tkinter Canvas 小部件在屏幕上创建和显示对象，以便用户与之交互。使用这些技术，可以创建各种游戏和应用，其限制仅取决于你自己的创造力。
- en: We also take a quick look at using the debugger built into IDLE, a valuable
    tool for testing and developing your programs without the need to write extensive
    test code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地看看如何使用内置在 IDLE 中的调试器，这是一个在无需编写大量测试代码的情况下测试和开发程序的有用工具。
- en: The first example demonstrates how we can monitor and make use of the mouse
    to create objects and draw directly on the `Canvas` widget. Next, we create a
    bat and ball game, which shows how the positions of objects can be controlled
    and how interactions between them can be detected and responded to. Finally, we
    take things a little further and use Tkinter to place our own graphics onto the
    `Canvas` widget to create an overhead view treasure hunt game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例演示了我们可以如何监控和使用鼠标来创建对象并在 `Canvas` 小部件上直接绘制。接下来，我们创建一个棒球游戏，展示了如何控制对象的位姿以及如何检测和响应它们之间的交互。最后，我们更进一步，使用
    Tkinter 将我们自己的图形放置在 `Canvas` 小部件上，以创建一个俯视图寻宝游戏。
- en: Using IDLE3 to debug your programs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDLE3 调试你的程序
- en: A key aspect of programming is being able to test and debug your code, and a
    useful tool to achieve this is a debugger. The IDLE editor (make sure you use
    IDLE3 to support the Python 3 code we use in this book) includes a basic debugger.
    It allows you to step through your code, observe the values of local and global
    variables, and set breakpoints.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个关键方面是能够测试和调试你的代码，而一个有用的工具就是调试器。IDLE 编辑器（确保你使用 IDLE3 以支持本书中使用的 Python 3
    代码）包括一个基本的调试器。它允许你逐步执行你的代码，观察局部和全局变量的值，并设置断点。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To enable the debugger, start IDLE3 and select **Debugger** from the **Debug**
    menu; it will open up the following window (if you are currently running some
    code, you will need to stop it first):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用调试器，请启动 IDLE3 并从 **调试** 菜单中选择 **调试器**；它将打开以下窗口（如果你当前正在运行某些代码，你需要先停止它）：
- en: '![How to do it…](img/6623OT_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/6623OT_04_01.jpg)'
- en: The IDLE3 debugger window
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE3 调试器窗口
- en: 'Open up the code you want to test (via **File** | **Open…**) and try running
    it (*F5*). You will find that the code will not start, since the debugger has
    automatically stopped at the first line. The following screenshot shows the debugger
    has stopped on the first line of code in `filehandler.py`, which is `line 3: import
    os`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '打开你想要测试的代码（通过 **文件** | **打开…**），然后尝试运行它（*F5*）。你会发现代码不会启动，因为调试器已经自动在第一行停止。以下截图显示调试器已经停止在
    `filehandler.py` 代码的第一行，即 `line 3: import os`：'
- en: '![How to do it…](img/6623OT_04_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/6623OT_04_02.jpg)'
- en: The IDLE3 debugger at the start of the code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始时的 IDLE3 调试器
- en: How it works…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The control buttons shown in the following screenshot allow you to run and/or
    jump through the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示的控制按钮允许你运行和/或跳过代码：
- en: '![How it works…](img/6623OT_04_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/6623OT_04_03.jpg)'
- en: Debugger controls
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器控制
- en: 'The functions of the control buttons are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制按钮的功能如下：
- en: '**Go**: This button will execute the code as normal.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续**：此按钮将正常执行代码。'
- en: '**Step**: This button will execute the line of code one step at a time and
    then stop again. If a function is called, it will enter that function and allow
    you to step through that too.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：此按钮将逐行执行代码，然后再次停止。如果调用了一个函数，它将进入该函数，并允许你逐步执行该函数。'
- en: '**Over**: This button is like the **Step** command, but if there is a function
    call, it will execute the whole function and stop at the following line.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过**：此按钮类似于**步骤**命令，但如果存在函数调用，它将执行整个函数，并在下一行停止。'
- en: '**Out**: This button will keep executing the code until it has completed the
    function it is currently in, continuing until you come out of the function.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：此按钮将执行代码，直到它完成当前函数，继续执行直到你退出函数。'
- en: '**Quit**: This button ends the program immediately.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出**：此按钮会立即结束程序。'
- en: 'In addition to the previously mentioned controls, you can **Set Breakpoint**
    and **Clear Breakpoint** directly within the code. A breakpoint is a marker that
    you can insert in the code (by right-clicking on the editor window), which the
    debugger will always break on (stop at) when it is reached, as shown in the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的控制选项外，你可以在代码中直接**设置断点**和**清除断点**。断点是一个可以在代码中插入的标记（通过在编辑器窗口中右键单击），当调试器到达该标记时，它将始终中断（停止）如以下截图所示：
- en: '![How it works…](img/6623OT_04_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_04_04.jpg)'
- en: Set and clear breakpoints directly in your code
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中直接设置和清除断点
- en: The checkboxes (on the right-hand side of the control buttons) allow you to
    choose what information to display when you step through the code or when the
    debugger stops somewhere due to a breakpoint. **Stack** is shown in the main window,
    which is similar to what you would see if the program hit an unhandled exception.
    The **Stack** option shows all the function calls made to get to the current position
    in the code, right up to the line it has stopped at. The **Source** option highlights
    the line of code currently being executed and, in some cases, the code inside
    the imported modules too (if they are non-compiled libraries).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框（在控制按钮的右侧）允许你在遍历代码或调试器由于断点而停止时选择要显示的信息。**堆栈**显示在主窗口中，类似于程序遇到未处理的异常时你会看到的情况。**堆栈**选项显示了到达代码当前位置所进行的所有函数调用，直到它停止的行。**源代码**选项突出显示当前正在执行的代码行，在某些情况下，还包括导入模块中的代码（如果它们是非编译库）。
- en: You can also select whether to display **Locals** and/or **Globals**. By default,
    the **Source** and **Globals** options are usually disabled as they can make the
    process quite slow if there is a lot of data to display.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择是否显示**局部**和/或**全局**。默认情况下，**源代码**和**全局**选项通常被禁用，因为如果有很多数据要显示，它们可能会使过程变得相当缓慢。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python uses the concept of local and global variables to define the scope (where
    and when the variables are valid). Global variables are defined at the top level
    of the file and are visible from any point in the code after it has been defined.
    However, in order to alter its value from anywhere other than the top level, Python
    requires you to use the global keyword first. Without the global keyword, you
    will create a local copy with the same name (the value of which will be lost when
    you exit the function). Local variables are defined when you create a variable
    within a function; once outside of the function, the variable is destroyed and
    is not visible anymore.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用局部和全局变量的概念来定义作用域（变量在哪里以及何时有效）。全局变量在文件的顶层定义，并且在其定义之后代码的任何位置都可以看到。然而，为了从除了顶层以外的任何地方改变其值，Python
    需要你首先使用 global 关键字。如果没有使用 global 关键字，你将创建一个具有相同名称的局部副本（当退出函数时，其值将丢失）。局部变量是在你在一个函数内创建变量时定义的；一旦超出函数范围，该变量就会被销毁，并且不再可见。
- en: 'Below **Stack** data are the **Locals**, in this case `aPhoto`, `filename`,
    and `self`. Then (if enabled), we have all the global values that are currently
    valid providing useful details about the status of the program (`DATE = 1`, `DEBUG
    = True`, `FOLDERSONLY = True`, and so on):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在**堆栈**数据下方是**局部**变量，在这种情况下是 `aPhoto`、`filename` 和 `self`。然后（如果启用），我们有所有当前有效的全局值，提供了关于程序状态的详细信息（`DATE
    = 1`、`DEBUG = True`、`FOLDERSONLY = True` 等）：
- en: '![How it works…](img/6623OT_04_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_04_05.jpg)'
- en: The Stack, Locals, and Globals options within the debugger
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器中的“堆栈”、“局部”和“全局”选项
- en: The debugger isn't particularly advanced, as it does not allow you to expand
    complex objects such as the `photohandler.Photo` object to see what data it contains.
    However, if required, you can adjust your code and assign the data you want to
    observe to some temporary variables during testing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器并不特别先进，因为它不允许你展开复杂对象，例如 `photohandler.Photo` 对象，以查看它包含的数据。然而，如果需要，你可以在测试期间调整你的代码，并将你想要观察的数据分配给一些临时变量。
- en: It is worth learning how to use the debugger as it is a much easier way to track
    down particular problems and check whether or not things are functioning as you
    expect them to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用调试器是值得的，因为它是一种更容易追踪特定问题并检查事物是否按预期工作的方式。
- en: Drawing lines using a mouse on Tkinter Canvas
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tkinter画布上使用鼠标绘制线条
- en: 'The Tkinter Canvas widget provides an area to create and draw objects on. The
    following script demonstrates how to use mouse events to interact with Tkinter.
    By detecting the mouse clicks, we can use Tkinter to draw a line that follows
    the movement of the mouse:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter Canvas小部件提供了一个区域来创建和绘制对象。以下脚本演示了如何使用鼠标事件与Tkinter交互。通过检测鼠标点击，我们可以使用Tkinter绘制一条跟随鼠标移动的线条：
- en: '![Drawing lines using a mouse on Tkinter Canvas](img/6623OT_04_06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![在Tkinter画布上使用鼠标绘制线条](img/6623OT_04_06.jpg)'
- en: A simple drawing application using Tkinter
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tkinter的简单绘图应用程序
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As before, we need to have Tkinter installed and either the Raspbian desktop
    running (`startx` from the command line) or an SSH session with X11 Forwarding
    and an X server running (see [Chapter 1](ch01.html "Chapter 1. Getting Started
    with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi Computer*).
    We will also need a mouse connected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要安装Tkinter，并且要么运行Raspbian桌面（通过命令行执行`startx`），要么有一个带有X11转发和运行X服务器的SSH会话（参见[第1章](ch01.html
    "第1章. 使用Raspberry Pi计算机入门")，*使用Raspberry Pi计算机入门*）。我们还需要连接一个鼠标。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create the following script, `painting.py`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`painting.py`：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Python code creates a Tkinter window that contains a `Canvas` object called
    `the_canvas`. We use the `bind` function here, which will bind a specific event
    that occurs on this widget (`the_canvas`) to a specific action or key press. In
    this case, we bind the `<Motion>` function of the mouse plus the click and release
    of the first mouse button (`<ButtonPress-1>` and `<ButtonRelease-1>`). Each of
    these events are then used to call the `mouse1press()`, `mouse1release()`, and
    `mousemove()` functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码创建了一个包含名为`the_canvas`的`Canvas`对象的Tkinter窗口。在这里我们使用`bind`函数，它将特定事件（在这个小部件`the_canvas`上发生的事件）绑定到特定动作或按键。在这种情况下，我们将鼠标的`<Motion>`函数以及第一个鼠标按钮的点击和释放（`<ButtonPress-1>`和`<ButtonRelease-1>`）绑定。然后，这些事件被用来调用`mouse1press()`、`mouse1release()`和`mousemove()`函数。
- en: The logic here is as follows. We track the status of the mouse button using
    the `mouse1press()` and `mouse1release()` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑如下。我们使用`mouse1press()`和`mouse1release()`函数跟踪鼠标按钮的状态。
- en: If the mouse has been clicked, the `mousemove()` function will check to see
    whether we are drawing a new line (we set new coordinates for this) or continuing
    an old one (we draw a line from the previous coordinates to the coordinates of
    the current event that has triggered `mousemove()`). We just need to ensure that
    we reset to the `newline` command whenever the mouse button is released to reset
    the start position of the line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标已被点击，`mousemove()`函数将检查我们是否在绘制一条新线（我们为此设置了新坐标）或者继续一条旧线（我们从上一个坐标绘制一条线到触发`mousemove()`的当前事件的坐标）。我们只需要确保每次鼠标按钮释放时都重置到`newline`命令，以重置线的起始位置。
- en: Creating a bat and ball game
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建棒球游戏
- en: A classic bat and ball game can be created using the drawing tools of canvas
    and by detecting the collisions of the objects. The user will be able to control
    the green paddle using the left and right cursor keys to aim the ball at the bricks
    and hit them until they have all been destroyed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用画布的绘图工具和检测对象的碰撞来创建一个经典的棒球游戏。用户将能够通过使用左右光标键来控制绿色挡板，瞄准砖块并击打它们，直到所有砖块都被摧毁。
- en: '![Creating a bat and ball game](img/6623OT_04_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![创建棒球游戏](img/6623OT_04_07.jpg)'
- en: Control the bat to aim the ball at the bricks
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制挡板以瞄准砖块
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This example requires graphical output, so you must have a screen and keyboard
    attached to the Raspberry Pi or use X11 Forwarding and X server if connected remotely
    from another computer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要图形输出，因此您必须将屏幕和键盘连接到Raspberry Pi，或者如果从另一台计算机远程连接，则必须使用X11转发和X服务器。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Create the following script, `bouncingball.py`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`bouncingball.py`。
- en: 'First, import the `tkinter` and `time` modules, and define constants for the
    game graphics:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`tkinter`和`time`模块，并定义游戏图形的常量：
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create functions for closing the program, moving the paddle right and
    left, and for calculating the direction of the ball:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建用于关闭程序、移动挡板左右和计算球的方向的函数：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set up the `tkinter` window and define the canvas:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `tkinter` 窗口并定义画布：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the borders, `ball`, and `paddle` objects to the canvas:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边框、`ball` 和 `paddle` 对象添加到画布中：
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Draw all the bricks and set up the ball and paddle positions:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制所有砖块并设置球和挡板的位置：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the main loop for the game to check for collisions and handle the movement
    of the paddle and ball:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建游戏的主循环以检查碰撞和处理挡板和球的移动：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We create a Tkinter application that is 640 x 480 pixels and bind the `<Right>`
    and `<Left>` cursor keys to the `move_right()` and `move_left()` functions. We
    use `root.protocol('WM_DELETE_WINDOW', close)` to detect when the window is closed
    so that we can cleanly exit the program (via `close()`, which sets `RUNNING` to
    `False`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 640 x 480 像素的 Tkinter 应用程序，并将 `<Right>` 和 `<Left>` 光标键绑定到 `move_right()`
    和 `move_left()` 函数。我们使用 `root.protocol('WM_DELETE_WINDOW', close)` 来检测窗口何时关闭，以便我们可以干净地退出程序（通过
    `close()`，它将 `RUNNING` 设置为 `False`）。
- en: 'We then add a `Canvas` widget to the application that will hold all our objects.
    We create the following objects: `top`, `left`, `right`, and `bottom`. These make
    up our bounding sides for our game area. The canvas coordinates are `0,0` in the
    top-left corner and `640,480` in the bottom-right corner, so the start and end
    coordinates can be determined for each side (using `canv.create_line(xStart, yStart,
    xEnd, yEnd)`).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一个 `Canvas` 小部件添加到应用程序中，该小部件将包含所有我们的对象。我们创建了以下对象：`top`、`left`、`right`
    和 `bottom`。这些构成了我们游戏区域的边界侧。画布坐标在左上角为 `0,0`，在右下角为 `640,480`，因此可以确定每一边的起始和结束坐标（使用
    `canv.create_line(xStart, yStart, xEnd, yEnd)`）。
- en: '![How it works…](img/6623OT_04_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_04_08.jpg)'
- en: The coordinates of the Canvas widget
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 小部件的坐标
- en: You can also add multiple `tags` to the objects; `tags` are often useful for
    defining specific actions or behaviors of objects. For instance, they allow for
    different types of event to occur when specific objects or bricks are hit. We
    see more uses of `tags` in the next example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以给对象添加多个 `tags`；`tags` 通常很有用，可以定义对象的特定动作或行为。例如，它们允许在特定对象或砖块被击中时发生不同类型的事件。我们将在下一个示例中看到
    `tags` 的更多用法。
- en: Next, we define the ball and paddle objects, which are added using `canv.create_rectangle()`.
    This requires two sets of coordinates that define the opposite corners of the
    Incorrect image, should be the following image with the 4x16 bricks on objects
    (in this case, the top-left and bottom-right corners).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义球和挡板对象，这些对象是通过 `canv.create_rectangle()` 添加的。这需要两组坐标，定义了不正确的图像的相对角，应该是以下图像，其中包含
    4x16 块砖的对象（在这种情况下，是左上角和右下角）。
- en: '![How it works…](img/6623OT_04_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_04_09.jpg)'
- en: A tkinter rectangle is defined by the coordinates of the two corners.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 矩形由两个角坐标定义。
- en: Finally, we can create the bricks!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建砖块！
- en: 'We want our bricks to be 40 x 20 pixels wide so we can fit 16 bricks across
    our game area of 640 pixels (in four rows). We can create a list of brick objects
    with their positions defined automatically, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望砖块宽度为 40 x 20 像素，这样我们可以在 640 像素的游戏区域（分为四行）中放置 16 块砖。我们可以创建一个砖块对象列表，其位置自动定义，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A brick-like effect is provided by making the bricks slightly smaller (`-2`)
    to create a small gap.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使砖块略微缩小（`-2`）以创建一个小间隙，提供了类似砖块的效果。
- en: '![How it works…](img/6623OT_04_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_04_10.jpg)'
- en: Four rows of 16 bricks are generated at the top of Canvas
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Canvas 顶部生成 16 块砖的 4 行。
- en: We now set the default settings before starting the main control loop. The movement
    of the ball will be governed by `delta_x` and `delta_y`, which are added to or
    subtracted from the ball's previous position in each cycle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在开始主控制循环之前设置默认设置。球的移动将由 `delta_x` 和 `delta_y` 控制，这两个值在每个周期中加到或从球的当前位置中减去。
- en: Next, we set the starting position of the ball and use the `canv.move()` function
    to move the ball by that amount. The `move()` function will add `100` to the `x`
    and `y` coordinates of the ball object, which was originally created at position
    `0,0`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置球的开局位置，并使用 `canv.move()` 函数移动球这个距离。`move()` 函数将 `100` 添加到球对象的 `x` 和
    `y` 坐标中，该球最初在位置 `0,0` 创建。
- en: Now that everything is set up, the main loop can run; this will check that the
    ball has not hit anything (using the `canv.find_overlapping()` function), make
    any adjustments to the `delta_x` or `delta_y` values, and then apply them to move
    the ball to the next location.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，主循环可以运行；这将检查球是否没有碰到任何东西（使用 `canv.find_overlapping()` 函数），对 `delta_x`
    或 `delta_y` 的值进行任何调整，然后将它们应用到移动球到下一个位置。
- en: The sign of `delta_x` and `delta_y` determines the direction of the ball. Positive
    values will make the ball travel diagonally downwards and towards the right, while
    `-delta_x` will make it travel towards the left, either downwards or upwards depending
    on whether `delta_y` is positive or negative.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`delta_x` 和 `delta_y` 的符号决定了球的方向。正值会使球斜向下向右移动，而 `-delta_x` 将使其向左移动，具体是向下还是向上取决于
    `delta_y` 是正还是负。'
- en: After the ball has been moved, we use `canv.update()` to redraw any changes
    made to the display, and `time.sleep()` allows a small delay before checking and
    moving the ball again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 球移动后，我们使用 `canv.update()` 重新绘制对显示所做的任何更改，而 `time.sleep()` 允许在再次检查和移动球之前有一个小的延迟。
- en: Object collisions are detected using the `canv.find_overlapping()` function.
    This returns a list of canvas objects that are found to be overlapping the bounds
    of a rectangle defined by the supplied coordinates. For example, in the case of
    the square ball, are any of the coordinates of the canvas objects within the space
    the ball is occupying?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `canv.find_overlapping()` 函数检测物体碰撞。这个函数返回一个列表，其中包含找到重叠由提供的坐标定义的矩形边界的画布对象。例如，在正方形球的情况下，画布对象的任何坐标是否在球占据的空间内？
- en: '![How it works…](img/6623OT_04_11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_04_11.jpg)'
- en: The objects are checked to detect if they overlap each other
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查物体以检测它们是否重叠
- en: If the ball is found to be overlapping another object, such as the walls, the
    paddle, or one or more of the bricks, we need to determine which direction the
    ball should next travel in. Since we are using the coordinates of the ball as
    the area within which to check, the ball will always be listed so that we ignore
    them when we check the list of objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现球与另一个物体重叠，例如墙壁、球拍或一个或多个砖块，我们需要确定球接下来应该向哪个方向移动。由于我们使用球的坐标作为检查的区域，球将始终被列出，因此我们在检查对象列表时忽略它们。
- en: We use the `dir_changed` flag to ensure that if we hit two bricks at the same
    time, we do not change direction twice before we move the ball. Otherwise, this
    would cause the ball to continue moving in the same direction even though it has
    collided with the bricks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `dir_changed` 标志来确保如果我们同时击中两个砖块，我们在移动球之前不会改变方向两次。否则，这会导致球即使在碰撞到砖块后仍然继续以相同方向移动。
- en: So if the ball is overlapping something else, we can call `determineDir()` with
    the coordinates of the ball and the object to work out what the new direction
    should be.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果球与另一个物体重叠，我们可以使用球和物体的坐标调用 `determineDir()` 来确定新的方向应该是什么。
- en: 'When the ball collides with something, we want the ball to bounce off it; fortunately,
    this is easy to simulate as we just need to change the sign of either `delta_x`
    or `delta_y` depending on whether we have hit something on the sides or the top/bottom.
    If the ball hits the bottom of another object, it means we were travelling upwards
    and should now travel downwards. However, we will continue to travel in the same
    direction on the `x` axis (be it left or right or just up). This can be seen from
    the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当球与物体碰撞时，我们希望球从其上弹回；幸运的是，这很容易模拟，因为我们只需要根据我们是否击中了侧面或顶部/底部来改变 `delta_x` 或 `delta_y`
    的符号。如果球击中了另一个物体的底部，这意味着我们正在向上移动，现在应该向下移动。然而，我们将在 `x` 轴上继续以相同方向移动（无论是向左、向右还是向上）。这可以从以下代码中看出：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `determineDir()` function looks at the coordinates of the ball and the
    object, and looks for a match between either the left and right `x` coordinates
    or the top and bottom `y` coordinates. This is enough to say whether the collision
    is on the sides or top/bottom, and we can set the `delta_x` or `delta_y` signs
    accordingly, as can be seen in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`determineDir()` 函数查看球和物体的坐标，并寻找左和右 `x` 坐标或上和下 `y` 坐标之间的匹配。这足以判断碰撞是在侧面还是顶部/底部，我们可以相应地设置
    `delta_x` 或 `delta_y` 的符号，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we can determine if we have hit a brick by checking whether the overlapping
    object ID is between the first and last ID bricks. If it was a brick, we can remove
    it using `canv.delete()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过检查重叠的对象ID是否在第一个和最后一个砖块ID之间来确定是否击中了一块砖。如果是砖块，我们可以使用`canv.delete()`来移除它。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python allows the index values to wrap around rather than access the invalid
    memory, so an index value of `-1` will provide us with the last item in the list.
    We use this to reference the last brick as `brick [-1]`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许索引值环绕而不是访问无效的内存，因此索引值`-1`将为我们提供列表中的最后一个项目。我们使用它来引用最后一个砖块作为`brick [-1]`。
- en: We also check to see whether the object being overlapped is the bottom line
    (in which case, the player has missed the ball with the paddle), so a short message
    is displayed briefly. We reset the position of the `ball` and `delta_x`/`delta_y`
    values. The `canv.update()` function ensures that the display is refreshed with
    the message before it is deleted (3 seconds later).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查被重叠的对象是否是底部行（在这种情况下，玩家用挡板错过了球），因此会短暂显示一条简短的消息。我们重置`ball`和`delta_x`/`delta_y`值的位置。`canv.update()`函数确保在删除消息之前（3秒后）刷新显示。
- en: Finally, the ball is moved by the `delta_x`/`delta_y` distance and the display
    is updated. A small delay is added here to reduce the rate of updates and the
    CPU time used. Otherwise, you will find that your Raspberry Pi will become unresponsive
    if it is spending 100 percent of its effort running the program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，球通过`delta_x`/`delta_y`距离移动，并且显示更新。这里添加了小的延迟以减少更新速率和CPU使用时间。否则，你会发现如果你的树莓派将100%的精力用于运行程序，它将变得无响应。
- en: When the user presses the cursor keys, the `move_right()` and `move_left()`
    functions are called. They check the position of the paddle object, and if the
    paddle is not at the edge, the paddle will be moved accordingly. If the ball hits
    the paddle, the collision detection will ensure that the ball bounces off, just
    as if it has hit one of the bricks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下光标键时，会调用`move_right()`和`move_left()`函数。它们检查挡板对象的位置，如果挡板不在边缘，挡板将相应移动。如果球击中挡板，碰撞检测将确保球反弹，就像它击中了一块砖一样。
- en: You can extend this game further by adding a score for each block destroyed,
    allowing the player a finite number of lives that are lost when they miss the
    ball, and even writing some code to read in new brick layouts.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加每个被摧毁的块的分数来进一步扩展这个游戏，允许玩家有限的生命，当玩家错过球时生命会丢失，甚至可以编写一些代码来读取新的砖块布局。
- en: Creating an overhead scrolling game
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建俯视滚动游戏
- en: By using objects and images in our programs, we can create many types of 2D
    graphical games.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的程序中使用对象和图像，我们可以创建许多类型的2D图形游戏。
- en: In this recipe, we will create a treasure hunt game where the player is trying
    to find buried treasure (by pressing *Enter* to dig for it). Each time the treasure
    has not been found, the player is given a clue to how far away the treasure is;
    they can then use the cursor keys to move around and search until they find it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个寻宝游戏，玩家试图找到隐藏的宝藏（通过按*Enter*键挖掘）。每次宝藏未被找到时，玩家都会得到关于宝藏距离的线索；然后他们可以使用光标键四处移动并搜索，直到找到它。
- en: '![Creating an overhead scrolling game](img/6623OT_04_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建俯视滚动游戏](img/6623OT_04_12.jpg)'
- en: Dig for treasure in your own overhead scrolling game!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的俯视滚动游戏中挖掘宝藏！
- en: Although this is a basic concept for a game, it could easily be extended to
    include multiple layouts, traps, and enemies to avoid, perhaps even additional
    tools or puzzles to solve. With a few adjustments to the graphics, the character
    could be exploring a dungeon, a spaceship, or hopping through the clouds collecting
    rainbows!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个游戏的基本概念，但它可以很容易地扩展以包括多个布局、陷阱和需要避免的敌人，甚至可能包括额外的工具或需要解决的谜题。通过一些图形调整，角色可以探索地牢、太空船，或者跳跃在云层中收集彩虹！
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following example uses a number of images; these are available as part of
    the book's resources. You will need to place the nine images in the same directory
    as the Python script.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了许多图像；这些图像作为本书的资源的一部分提供。您需要将九个图像放置在与Python脚本相同的目录中。
- en: The required image files can be seen in the code bundle of this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的图像文件可以在本章的代码包中看到。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following script, `scroller.py`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本，`scroller.py`：
- en: 'Begin by importing the required libraries and parameters:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入所需的库和参数：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Provide functions to handle the movement of the player:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供处理玩家移动的功能：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add functions to check how far the player is from the hidden gold:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加检查玩家距离隐藏黄金有多远的功能：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add functions to help find a location to hide the gold in:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加帮助找到隐藏黄金位置的功能：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the Tkinter application window and bind the keyboard events:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Tkinter应用程序窗口并绑定键盘事件：
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize all the game objects (the background tiles, the player, the walls,
    and the gold):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化所有游戏对象（背景瓦片、玩家、墙壁和黄金）：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, start the `mainloop()` command to allow Tkinter to monitor for events:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动`mainloop()`命令以允许Tkinter监控事件：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: As before, we create a new Tkinter application that contains a `Canvas` widget
    so that we can add all of the game objects. We ensure that we bind the right,
    left, up, down and *Enter* keys, which will be our controls in the game.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们创建一个新的Tkinter应用程序，其中包含一个`Canvas`小部件，这样我们就可以添加所有的游戏对象。我们确保我们绑定了右键、左键、上键、下键和*Enter*键，这些将在游戏中作为我们的控制键。
- en: First, we place our background image (`bg.gif`) onto the `Canvas` widget. We
    calculate the number of images we can fit along the length and width to tile the
    whole canvas space, and locate them using suitable coordinates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将背景图像（`bg.gif`）放置在`Canvas`小部件上。我们计算可以沿长度和宽度放置多少图像以铺满整个画布空间，并使用合适的坐标定位它们。
- en: Next, we create the player image (by creating `playImg`, a list of Tkinter image
    objects for each direction the player can turn in) and place it on the canvas.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建玩家图像（通过创建`playImg`，一个玩家可以转向的每个方向的Tkinter图像对象列表）并将其放置在画布上。
- en: We now create the walls, the positions of which are defined by the `wallPosH`
    and `wallPosV` lists. These could be defined using the exact coordinates, perhaps
    even read from a file to provide an easy method to load different layouts for
    levels if required. By iterating through the lists, the horizontal and vertical
    wall images are put in position on the canvas.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建墙壁，其位置由`wallPosH`和`wallPosV`列表定义。这些可以使用精确坐标定义，也许甚至可以从文件中读取以提供一种简单的方法来加载不同级别的布局。通过遍历列表，水平墙和垂直墙图像被放置在画布上。
- en: To complete the layout, we just need to hide the gold somewhere. Using the `hideGold()`
    function, we randomly determine a suitable place to locate the gold. Within `findLocationForGold()`,
    we use `randint(0,value)` to create a pseudo-random number (it is not totally
    random but good enough for this use) between `0` and `value`. In our case, the
    value we want is between `0` and the edge of our canvas space minus the size of
    the gold image and any `bg_offset` that has been applied to the canvas. This ensures
    it is not beyond the edge of the screen. We then check the potential location
    using the `find_overlapping()` function to see whether any objects with `wall`
    or `player` tags are in the way. If so, we pick a new location. Otherwise, we
    place the gold on the canvas but with the `state="hidden"` value, which will hide
    it from view.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成布局，我们只需将黄金隐藏在某个地方。使用`hideGold()`函数，我们随机确定一个合适的地点来定位黄金。在`findLocationForGold()`中，我们使用`randint(0,value)`创建一个伪随机数（它不是完全随机的，但对于这个用途已经足够好了），介于`0`和`value`之间。在我们的例子中，我们想要的值介于`0`和画布空间边缘减去黄金图像的大小以及任何已应用于画布的`bg_offset`之间。这确保它不会超出屏幕边缘。然后我们使用`find_overlapping()`函数检查潜在位置，看看是否有带有`wall`或`player`标记的对象挡在路上。如果是这样，我们选择一个新的位置。否则，我们在画布上放置黄金，但使用`state="hidden"`值，这将使其从视图中隐藏。
- en: We then create `checkImg` (a Tkinter image) and use it while checking for gold
    to mark the area we have checked. Finally, we just wait for the user to press
    one of the keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建`checkImg`（一个Tkinter图像）并在检查黄金时使用它来标记我们检查的区域。最后，我们只需等待用户按下任一键。
- en: The character will move around the screen whenever one of the cursor keys is
    pressed. The player's movement is determined by the `movePlayer()` function; it
    will first check whether the player is trying to move into a wall, then determine
    (within the `makeMove()` function) if the player is at the edge of the display
    or canvas space.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下任一光标键时，角色将在屏幕上移动。玩家的移动由`movePlayer()`函数确定；它将首先检查玩家是否试图移动到墙壁中，然后在`makeMove()`函数中确定玩家是否在显示或画布空间的边缘。
- en: '![How it works…](img/6623OT_04_13.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/6623OT_04_13.jpg)'
- en: Every time a cursor key is pressed, we use the logic shown in the diagram to
    determine what to do
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每当按下光标键时，我们使用图中所示的逻辑来确定要做什么
- en: 'The `foundWall()` function works out whether the player will hit a wall by
    checking for any objects with `wall` tags within the area being covered by the
    player image, plus a little extra for the area that the player will be moving
    to next. The following diagram shows how the `olCoords` coordinates are determined:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`foundWall()`函数通过检查玩家图像覆盖区域内的任何带有`wall`标签的对象，以及玩家将要移动到的区域的一点点额外空间，来确定玩家是否会撞到墙。以下图表显示了如何确定`olCoords`坐标：'
- en: '![How it works…](img/6623OT_04_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_04_14.jpg)'
- en: The coordinates to check for objects that overlap (olCoords) are calculated
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 检查重叠对象（olCoords）的坐标被计算
- en: The `makeMove()` function checks if the player will be moving to the edge of
    the display (as defined by `DIS_LIMITS`) and whether they are at the edge of the
    canvas space (as defined by `SPACE_LIMITS`). Within the display, the player can
    be moved in the direction of the cursor, or all the objects tagged with `bg` within
    the canvas space are moved in the opposite direction, simulating scrolling behind
    the player. This is done by the `moveBackground()` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMove()`函数检查玩家是否会移动到显示的边缘（由`DIS_LIMITS`定义），以及他们是否位于画布空间的边缘（由`SPACE_LIMITS`定义）。在显示区域内，玩家可以朝光标方向移动，或者画布空间内所有带有`bg`标签的对象朝相反方向移动，模拟在玩家后面滚动。这是通过`moveBackground()`函数完成的。'
- en: When the player presses *Enter*, we'll want to check for gold in the current
    location. Using the `measureTo()` function, the position of the player and the
    gold are compared (the distance between the `x` and `y` coordinates of each is
    calculated).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下*Enter*键时，我们将想要检查当前位置是否有金子。使用`measureTo()`函数，比较玩家和金子的位置（计算每个`x`和`y`坐标之间的距离）。
- en: '![How it works…](img/6623OT_04_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_04_15.jpg)'
- en: The distance between the player and the gold is calculated
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家与金子之间的距离被计算
- en: The result is scaled to provide a rough indication of how far away the player
    is from the gold. If the distance is greater than zero, we display how far away
    the player is from the gold and leave a cross to show where we have checked. If
    the player has found the gold, we display a message saying so and set `newGame`
    to `True`. The next time the player presses *Enter*, the places marked with a
    cross are removed and the gold is relocated somewhere new.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被缩放以提供一个大致的指示，说明玩家距离金子有多远。如果距离大于零，我们显示玩家距离金子的距离，并留下一个十字来显示我们检查的位置。如果玩家找到了金子，我们将显示一条消息说明这一点，并将`newGame`设置为`True`。下次玩家按下*Enter*键时，带有十字标记的位置将被移除，金子将被重新放置在新的位置。
- en: With the gold hidden again, the player is ready to start again!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次隐藏了金子后，玩家准备再次开始！
