- en: Chapter 4. Creating Games and Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using IDLE3 to debug your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines using a mouse on a Tkinter Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bat and ball game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an overhead scrolling game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games are often a great way to explore and extend your programming skills as
    they present an inherent motivating force to modify and improve your creation,
    add new features, and create new challenges. They are also great for sharing your
    ideas with others, even if they aren't interested in programming.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on using the Tkinter Canvas widget to create and display
    objects on screen for the user to interact with. Using these techniques, a wide
    variety of games and applications can be created that are limited only by your
    own creativity.
  prefs: []
  type: TYPE_NORMAL
- en: We also take a quick look at using the debugger built into IDLE, a valuable
    tool for testing and developing your programs without the need to write extensive
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: The first example demonstrates how we can monitor and make use of the mouse
    to create objects and draw directly on the `Canvas` widget. Next, we create a
    bat and ball game, which shows how the positions of objects can be controlled
    and how interactions between them can be detected and responded to. Finally, we
    take things a little further and use Tkinter to place our own graphics onto the
    `Canvas` widget to create an overhead view treasure hunt game.
  prefs: []
  type: TYPE_NORMAL
- en: Using IDLE3 to debug your programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key aspect of programming is being able to test and debug your code, and a
    useful tool to achieve this is a debugger. The IDLE editor (make sure you use
    IDLE3 to support the Python 3 code we use in this book) includes a basic debugger.
    It allows you to step through your code, observe the values of local and global
    variables, and set breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the debugger, start IDLE3 and select **Debugger** from the **Debug**
    menu; it will open up the following window (if you are currently running some
    code, you will need to stop it first):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6623OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IDLE3 debugger window
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the code you want to test (via **File** | **Open…**) and try running
    it (*F5*). You will find that the code will not start, since the debugger has
    automatically stopped at the first line. The following screenshot shows the debugger
    has stopped on the first line of code in `filehandler.py`, which is `line 3: import
    os`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6623OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IDLE3 debugger at the start of the code
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The control buttons shown in the following screenshot allow you to run and/or
    jump through the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugger controls
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions of the control buttons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Go**: This button will execute the code as normal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step**: This button will execute the line of code one step at a time and
    then stop again. If a function is called, it will enter that function and allow
    you to step through that too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Over**: This button is like the **Step** command, but if there is a function
    call, it will execute the whole function and stop at the following line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Out**: This button will keep executing the code until it has completed the
    function it is currently in, continuing until you come out of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quit**: This button ends the program immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the previously mentioned controls, you can **Set Breakpoint**
    and **Clear Breakpoint** directly within the code. A breakpoint is a marker that
    you can insert in the code (by right-clicking on the editor window), which the
    debugger will always break on (stop at) when it is reached, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Set and clear breakpoints directly in your code
  prefs: []
  type: TYPE_NORMAL
- en: The checkboxes (on the right-hand side of the control buttons) allow you to
    choose what information to display when you step through the code or when the
    debugger stops somewhere due to a breakpoint. **Stack** is shown in the main window,
    which is similar to what you would see if the program hit an unhandled exception.
    The **Stack** option shows all the function calls made to get to the current position
    in the code, right up to the line it has stopped at. The **Source** option highlights
    the line of code currently being executed and, in some cases, the code inside
    the imported modules too (if they are non-compiled libraries).
  prefs: []
  type: TYPE_NORMAL
- en: You can also select whether to display **Locals** and/or **Globals**. By default,
    the **Source** and **Globals** options are usually disabled as they can make the
    process quite slow if there is a lot of data to display.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python uses the concept of local and global variables to define the scope (where
    and when the variables are valid). Global variables are defined at the top level
    of the file and are visible from any point in the code after it has been defined.
    However, in order to alter its value from anywhere other than the top level, Python
    requires you to use the global keyword first. Without the global keyword, you
    will create a local copy with the same name (the value of which will be lost when
    you exit the function). Local variables are defined when you create a variable
    within a function; once outside of the function, the variable is destroyed and
    is not visible anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below **Stack** data are the **Locals**, in this case `aPhoto`, `filename`,
    and `self`. Then (if enabled), we have all the global values that are currently
    valid providing useful details about the status of the program (`DATE = 1`, `DEBUG
    = True`, `FOLDERSONLY = True`, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Stack, Locals, and Globals options within the debugger
  prefs: []
  type: TYPE_NORMAL
- en: The debugger isn't particularly advanced, as it does not allow you to expand
    complex objects such as the `photohandler.Photo` object to see what data it contains.
    However, if required, you can adjust your code and assign the data you want to
    observe to some temporary variables during testing.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth learning how to use the debugger as it is a much easier way to track
    down particular problems and check whether or not things are functioning as you
    expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines using a mouse on Tkinter Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Tkinter Canvas widget provides an area to create and draw objects on. The
    following script demonstrates how to use mouse events to interact with Tkinter.
    By detecting the mouse clicks, we can use Tkinter to draw a line that follows
    the movement of the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing lines using a mouse on Tkinter Canvas](img/6623OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple drawing application using Tkinter
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, we need to have Tkinter installed and either the Raspbian desktop
    running (`startx` from the command line) or an SSH session with X11 Forwarding
    and an X server running (see [Chapter 1](ch01.html "Chapter 1. Getting Started
    with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi Computer*).
    We will also need a mouse connected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following script, `painting.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python code creates a Tkinter window that contains a `Canvas` object called
    `the_canvas`. We use the `bind` function here, which will bind a specific event
    that occurs on this widget (`the_canvas`) to a specific action or key press. In
    this case, we bind the `<Motion>` function of the mouse plus the click and release
    of the first mouse button (`<ButtonPress-1>` and `<ButtonRelease-1>`). Each of
    these events are then used to call the `mouse1press()`, `mouse1release()`, and
    `mousemove()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The logic here is as follows. We track the status of the mouse button using
    the `mouse1press()` and `mouse1release()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: If the mouse has been clicked, the `mousemove()` function will check to see
    whether we are drawing a new line (we set new coordinates for this) or continuing
    an old one (we draw a line from the previous coordinates to the coordinates of
    the current event that has triggered `mousemove()`). We just need to ensure that
    we reset to the `newline` command whenever the mouse button is released to reset
    the start position of the line.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bat and ball game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic bat and ball game can be created using the drawing tools of canvas
    and by detecting the collisions of the objects. The user will be able to control
    the green paddle using the left and right cursor keys to aim the ball at the bricks
    and hit them until they have all been destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a bat and ball game](img/6623OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Control the bat to aim the ball at the bricks
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example requires graphical output, so you must have a screen and keyboard
    attached to the Raspberry Pi or use X11 Forwarding and X server if connected remotely
    from another computer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the following script, `bouncingball.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `tkinter` and `time` modules, and define constants for the
    game graphics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create functions for closing the program, moving the paddle right and
    left, and for calculating the direction of the ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the `tkinter` window and define the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the borders, `ball`, and `paddle` objects to the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw all the bricks and set up the ball and paddle positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the main loop for the game to check for collisions and handle the movement
    of the paddle and ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a Tkinter application that is 640 x 480 pixels and bind the `<Right>`
    and `<Left>` cursor keys to the `move_right()` and `move_left()` functions. We
    use `root.protocol('WM_DELETE_WINDOW', close)` to detect when the window is closed
    so that we can cleanly exit the program (via `close()`, which sets `RUNNING` to
    `False`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a `Canvas` widget to the application that will hold all our objects.
    We create the following objects: `top`, `left`, `right`, and `bottom`. These make
    up our bounding sides for our game area. The canvas coordinates are `0,0` in the
    top-left corner and `640,480` in the bottom-right corner, so the start and end
    coordinates can be determined for each side (using `canv.create_line(xStart, yStart,
    xEnd, yEnd)`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The coordinates of the Canvas widget
  prefs: []
  type: TYPE_NORMAL
- en: You can also add multiple `tags` to the objects; `tags` are often useful for
    defining specific actions or behaviors of objects. For instance, they allow for
    different types of event to occur when specific objects or bricks are hit. We
    see more uses of `tags` in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the ball and paddle objects, which are added using `canv.create_rectangle()`.
    This requires two sets of coordinates that define the opposite corners of the
    Incorrect image, should be the following image with the 4x16 bricks on objects
    (in this case, the top-left and bottom-right corners).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A tkinter rectangle is defined by the coordinates of the two corners.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can create the bricks!
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our bricks to be 40 x 20 pixels wide so we can fit 16 bricks across
    our game area of 640 pixels (in four rows). We can create a list of brick objects
    with their positions defined automatically, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A brick-like effect is provided by making the bricks slightly smaller (`-2`)
    to create a small gap.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Four rows of 16 bricks are generated at the top of Canvas
  prefs: []
  type: TYPE_NORMAL
- en: We now set the default settings before starting the main control loop. The movement
    of the ball will be governed by `delta_x` and `delta_y`, which are added to or
    subtracted from the ball's previous position in each cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the starting position of the ball and use the `canv.move()` function
    to move the ball by that amount. The `move()` function will add `100` to the `x`
    and `y` coordinates of the ball object, which was originally created at position
    `0,0`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is set up, the main loop can run; this will check that the
    ball has not hit anything (using the `canv.find_overlapping()` function), make
    any adjustments to the `delta_x` or `delta_y` values, and then apply them to move
    the ball to the next location.
  prefs: []
  type: TYPE_NORMAL
- en: The sign of `delta_x` and `delta_y` determines the direction of the ball. Positive
    values will make the ball travel diagonally downwards and towards the right, while
    `-delta_x` will make it travel towards the left, either downwards or upwards depending
    on whether `delta_y` is positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: After the ball has been moved, we use `canv.update()` to redraw any changes
    made to the display, and `time.sleep()` allows a small delay before checking and
    moving the ball again.
  prefs: []
  type: TYPE_NORMAL
- en: Object collisions are detected using the `canv.find_overlapping()` function.
    This returns a list of canvas objects that are found to be overlapping the bounds
    of a rectangle defined by the supplied coordinates. For example, in the case of
    the square ball, are any of the coordinates of the canvas objects within the space
    the ball is occupying?
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The objects are checked to detect if they overlap each other
  prefs: []
  type: TYPE_NORMAL
- en: If the ball is found to be overlapping another object, such as the walls, the
    paddle, or one or more of the bricks, we need to determine which direction the
    ball should next travel in. Since we are using the coordinates of the ball as
    the area within which to check, the ball will always be listed so that we ignore
    them when we check the list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `dir_changed` flag to ensure that if we hit two bricks at the same
    time, we do not change direction twice before we move the ball. Otherwise, this
    would cause the ball to continue moving in the same direction even though it has
    collided with the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: So if the ball is overlapping something else, we can call `determineDir()` with
    the coordinates of the ball and the object to work out what the new direction
    should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the ball collides with something, we want the ball to bounce off it; fortunately,
    this is easy to simulate as we just need to change the sign of either `delta_x`
    or `delta_y` depending on whether we have hit something on the sides or the top/bottom.
    If the ball hits the bottom of another object, it means we were travelling upwards
    and should now travel downwards. However, we will continue to travel in the same
    direction on the `x` axis (be it left or right or just up). This can be seen from
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `determineDir()` function looks at the coordinates of the ball and the
    object, and looks for a match between either the left and right `x` coordinates
    or the top and bottom `y` coordinates. This is enough to say whether the collision
    is on the sides or top/bottom, and we can set the `delta_x` or `delta_y` signs
    accordingly, as can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can determine if we have hit a brick by checking whether the overlapping
    object ID is between the first and last ID bricks. If it was a brick, we can remove
    it using `canv.delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python allows the index values to wrap around rather than access the invalid
    memory, so an index value of `-1` will provide us with the last item in the list.
    We use this to reference the last brick as `brick [-1]`.
  prefs: []
  type: TYPE_NORMAL
- en: We also check to see whether the object being overlapped is the bottom line
    (in which case, the player has missed the ball with the paddle), so a short message
    is displayed briefly. We reset the position of the `ball` and `delta_x`/`delta_y`
    values. The `canv.update()` function ensures that the display is refreshed with
    the message before it is deleted (3 seconds later).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the ball is moved by the `delta_x`/`delta_y` distance and the display
    is updated. A small delay is added here to reduce the rate of updates and the
    CPU time used. Otherwise, you will find that your Raspberry Pi will become unresponsive
    if it is spending 100 percent of its effort running the program.
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses the cursor keys, the `move_right()` and `move_left()`
    functions are called. They check the position of the paddle object, and if the
    paddle is not at the edge, the paddle will be moved accordingly. If the ball hits
    the paddle, the collision detection will ensure that the ball bounces off, just
    as if it has hit one of the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend this game further by adding a score for each block destroyed,
    allowing the player a finite number of lives that are lost when they miss the
    ball, and even writing some code to read in new brick layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an overhead scrolling game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using objects and images in our programs, we can create many types of 2D
    graphical games.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a treasure hunt game where the player is trying
    to find buried treasure (by pressing *Enter* to dig for it). Each time the treasure
    has not been found, the player is given a clue to how far away the treasure is;
    they can then use the cursor keys to move around and search until they find it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an overhead scrolling game](img/6623OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dig for treasure in your own overhead scrolling game!
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a basic concept for a game, it could easily be extended to
    include multiple layouts, traps, and enemies to avoid, perhaps even additional
    tools or puzzles to solve. With a few adjustments to the graphics, the character
    could be exploring a dungeon, a spaceship, or hopping through the clouds collecting
    rainbows!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example uses a number of images; these are available as part of
    the book's resources. You will need to place the nine images in the same directory
    as the Python script.
  prefs: []
  type: TYPE_NORMAL
- en: The required image files can be seen in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following script, `scroller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by importing the required libraries and parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide functions to handle the movement of the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add functions to check how far the player is from the hidden gold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add functions to help find a location to hide the gold in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the Tkinter application window and bind the keyboard events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize all the game objects (the background tiles, the player, the walls,
    and the gold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, start the `mainloop()` command to allow Tkinter to monitor for events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, we create a new Tkinter application that contains a `Canvas` widget
    so that we can add all of the game objects. We ensure that we bind the right,
    left, up, down and *Enter* keys, which will be our controls in the game.
  prefs: []
  type: TYPE_NORMAL
- en: First, we place our background image (`bg.gif`) onto the `Canvas` widget. We
    calculate the number of images we can fit along the length and width to tile the
    whole canvas space, and locate them using suitable coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the player image (by creating `playImg`, a list of Tkinter image
    objects for each direction the player can turn in) and place it on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We now create the walls, the positions of which are defined by the `wallPosH`
    and `wallPosV` lists. These could be defined using the exact coordinates, perhaps
    even read from a file to provide an easy method to load different layouts for
    levels if required. By iterating through the lists, the horizontal and vertical
    wall images are put in position on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the layout, we just need to hide the gold somewhere. Using the `hideGold()`
    function, we randomly determine a suitable place to locate the gold. Within `findLocationForGold()`,
    we use `randint(0,value)` to create a pseudo-random number (it is not totally
    random but good enough for this use) between `0` and `value`. In our case, the
    value we want is between `0` and the edge of our canvas space minus the size of
    the gold image and any `bg_offset` that has been applied to the canvas. This ensures
    it is not beyond the edge of the screen. We then check the potential location
    using the `find_overlapping()` function to see whether any objects with `wall`
    or `player` tags are in the way. If so, we pick a new location. Otherwise, we
    place the gold on the canvas but with the `state="hidden"` value, which will hide
    it from view.
  prefs: []
  type: TYPE_NORMAL
- en: We then create `checkImg` (a Tkinter image) and use it while checking for gold
    to mark the area we have checked. Finally, we just wait for the user to press
    one of the keys.
  prefs: []
  type: TYPE_NORMAL
- en: The character will move around the screen whenever one of the cursor keys is
    pressed. The player's movement is determined by the `movePlayer()` function; it
    will first check whether the player is trying to move into a wall, then determine
    (within the `makeMove()` function) if the player is at the edge of the display
    or canvas space.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every time a cursor key is pressed, we use the logic shown in the diagram to
    determine what to do
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foundWall()` function works out whether the player will hit a wall by
    checking for any objects with `wall` tags within the area being covered by the
    player image, plus a little extra for the area that the player will be moving
    to next. The following diagram shows how the `olCoords` coordinates are determined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The coordinates to check for objects that overlap (olCoords) are calculated
  prefs: []
  type: TYPE_NORMAL
- en: The `makeMove()` function checks if the player will be moving to the edge of
    the display (as defined by `DIS_LIMITS`) and whether they are at the edge of the
    canvas space (as defined by `SPACE_LIMITS`). Within the display, the player can
    be moved in the direction of the cursor, or all the objects tagged with `bg` within
    the canvas space are moved in the opposite direction, simulating scrolling behind
    the player. This is done by the `moveBackground()` function.
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses *Enter*, we'll want to check for gold in the current
    location. Using the `measureTo()` function, the position of the player and the
    gold are compared (the distance between the `x` and `y` coordinates of each is
    calculated).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623OT_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The distance between the player and the gold is calculated
  prefs: []
  type: TYPE_NORMAL
- en: The result is scaled to provide a rough indication of how far away the player
    is from the gold. If the distance is greater than zero, we display how far away
    the player is from the gold and leave a cross to show where we have checked. If
    the player has found the gold, we display a message saying so and set `newGame`
    to `True`. The next time the player presses *Enter*, the places marked with a
    cross are removed and the gold is relocated somewhere new.
  prefs: []
  type: TYPE_NORMAL
- en: With the gold hidden again, the player is ready to start again!
  prefs: []
  type: TYPE_NORMAL
