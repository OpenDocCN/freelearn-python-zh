- en: Chapter 6. Drawing an Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。绘制应用程序
- en: We are now on to developing our last major Tkinter application. In this project,
    we will develop a drawing application, making extensive use of the Tkinter Canvas
    widget while applying everything else that we have learned so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在开发我们的最后一个主要Tkinter应用程序。在这个项目中，我们将开发一个绘图应用程序，广泛使用Tkinter Canvas小部件，并应用我们迄今为止所学的一切。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: Our drawing program will enable the user to draw basic shapes such as lines,
    circles, rectangles, and polygons. It will also let the user draw with the brush
    tool using different colors that can be chosen from the color palette.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的绘图程序将使用户能够绘制基本形状，如线条、圆圈、矩形和多边形。它还将允许用户使用画笔工具以不同的颜色绘制，这些颜色可以从调色板中选择。
- en: 'In its final form, our drawing program will look like the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形式中，我们的绘图程序将看起来像以下截图：
- en: '![Mission Briefing](img/7941_06_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_06_01.jpg)'
- en: Why Is It Awesome?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: While the application itself is rudimentary, it is sufficient to demonstrate
    some important aspects related to GUI programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用程序本身很简单，但它足以展示与GUI编程相关的一些重要方面。
- en: This project aims to drive home two important lessons. First, we will experience
    the power of the Canvas widget. Second, we will learn how to develop higher-level
    custom GUI frameworks for our applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目旨在强调两个重要的教训。首先，我们将体验Canvas小部件的力量。其次，我们将学习如何为我们的应用程序开发高级自定义GUI框架。
- en: As we shall see, custom GUI frameworks enable us to develop programs rapidly
    with minimal amount of code repetition.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，自定义GUI框架使我们能够用最少的代码重复快速开发程序。
- en: By the end of this project, you should not only be in a position to extend this
    application to add many more features, but you should also be able to take up
    and implement GUI projects of increasing complexity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个项目结束时，你不仅应该能够扩展这个应用程序以添加更多功能，还应该能够承担并实现越来越复杂的GUI项目。
- en: Your Hotshot Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的热手目标
- en: 'The key learning objectives for this project can be outlined as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的关键学习目标可以概述如下：
- en: Learning to build custom GUI frameworks for rapid application development
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建用于快速应用程序开发的自定义GUI框架
- en: Writing small unit tests for our code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的代码编写小的单元测试
- en: Understanding how to use inheritance in our projects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在我们的项目中使用继承
- en: Getting to know of other Tkinter modules, such as `tkColorChooser`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解其他Tkinter模块，例如`tkColorChooser`
- en: Creating and manipulating items on the Canvas widget
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas小部件上创建和操作项目
- en: Working with the tk ComboBox widget
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tk ComboBox小部件
- en: Getting to know the available `winfo` methods
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的`winfo`方法
- en: Working with mouse events on the Canvas widget
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas小部件上处理鼠标事件
- en: Reinforcing things that we have learned in previous projects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巩固我们在以前项目中学习到的内容
- en: Mission Checklist
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: 'If you have developed the game of chess, you might have installed the **Python
    Imaging Library** (**PIL**) to render PNG files. This is the only external dependency
    for our program. If you haven''t already done so, download and install PIL from:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经开发了棋盘游戏，你可能已经安装了**Python Imaging Library**（**PIL**）来渲染PNG文件。这是我们程序的唯一外部依赖。如果你还没有这样做，请从以下链接下载并安装PIL：
- en: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
- en: 'If you are working on windows x64 (64 bit) or MacOSX machine, you may instead
    need to install and work with Pillow, which is a replacement for PIL available
    at:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Windows x64（64位）或MacOSX机器，你可能需要安装并使用Pillow，它是PIL的替代品，可在以下链接找到：
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
- en: 'After you have installed the package, go to your Python interactive prompt
    and type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，转到你的Python交互式提示符并输入：
- en: '`>>from PIL import ImageTk`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>from PIL import ImageTk`'
- en: If this executes without any error messages, you are ready to make our drawing
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个程序没有错误信息执行，你就准备好制作我们的绘图应用程序了。
- en: Developing a bare bone GUI framework
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个裸骨GUI框架
- en: One of the most important lessons aimed in this project is to learn to develop
    custom GUI frameworks. Tkinter in itself is a GUI framework. However, the kind
    of framework we intend to build here is a higher-level framework, built on top
    of Tkinter to suit our custom programming needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，最重要的教训之一是学习如何开发自定义GUI框架。Tkinter本身就是一个GUI框架。然而，我们打算在这里构建的框架是一个更高级的框架，它建立在Tkinter之上，以满足我们的自定义编程需求。
- en: We will not develop a full-blown framework. Rather, we will develop only a small
    segment of it to give you a flavor of building a custom framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会开发一个完整的框架。相反，我们只会开发其中的一小部分，以便让你了解构建自定义框架的感觉。
- en: Prepare for Lift Off
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: So why do we need another framework on top of Tkinter?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们需要在Tkinter之上再构建一个框架呢？
- en: Consider a large program which has say 10 different menus, each menu having
    say 10 menu items. We will have to then write 100 lines of code simply to display
    these 100 menu items.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个拥有10个不同菜单的大程序，每个菜单有10个菜单项。我们可能需要编写100行代码仅仅是为了显示这100个菜单项。
- en: You not only need to make each widget by hand, but also have to link each of
    them manually to other commands besides having to set tons of options for each
    of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅需要手动制作每个小部件，而且还需要将它们手动链接到其他命令，同时还需要为每个小部件设置大量的选项。
- en: If we keep doing this for all our widgets, our GUI programming becomes an exercise
    in typing. Every extra line of code that you write adds to the program complexity,
    in a sense that it becomes more difficult for someone else to read, maintain,
    modify, and/or debug the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对所有的小部件都这样做，我们的GUI编程就变成了打字练习。你写的每一行额外的代码都会增加程序的复杂性，从某种意义上说，它变得对其他人来说更难阅读、维护、修改和/或调试代码。
- en: This is where developing a custom framework comes to our aid. Let's see what
    it means.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开发自定义框架如何帮助我们。让我们看看这意味着什么。
- en: Assume that we anticipate that our drawing program will have a large number
    of menu items. Now we know how to add menu and menu items. Each new menu item
    would take at least one line of code to display.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们预计我们的绘图程序将有大量的菜单项。现在我们知道如何添加菜单和菜单项。每个新的菜单项至少需要一行代码来显示。
- en: To avoid writing so many lines of code, let's first make a framework to address
    this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写这么多行代码，让我们首先构建一个框架来解决这个问题。
- en: To ease the process of menu creation, we will write a piece of code that takes
    menu items listed as a tuple, and converts it to an equivalent menu code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化菜单创建的过程，我们将编写一段代码，它接受作为元组的菜单项列表，并将其转换为等效的菜单代码。
- en: 'So given a tuple as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以给定以下元组：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: should produce the corresponding menu items, where the first item of the string
    (before dash (`-`)) represents the menu button, and each subsequent part of string
    separated by commas represents one menu item, its accelerator key, and the attached
    command callback. The position of ampersand symbol (`&`) represents the position
    of the shortcut key to be underlined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应该生成相应的菜单项，其中字符串的第一个项目（在破折号`-`之前）代表菜单按钮，字符串的每个后续部分，由逗号分隔，代表一个菜单项、其加速键和附加的命令回调。符号`&`的位置代表要下划线的快捷键的位置。
- en: We also need to take care of adding separators between our menu items. To add
    a separator, we would add the string `Sep` at positions where it is required.
    More precisely, the string `Sep` must be capitalized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注意在菜单项之间添加分隔符。要添加分隔符，我们会在需要的位置添加字符串`Sep`。更精确地说，字符串`Sep`必须是大写的。
- en: 'In short, passing this tuple through our method should produce a GUI, as shown
    in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通过我们的方法传递这个元组应该生成一个GUI，如下面的截图所示：
- en: '![Prepare for Lift Off](img/7941_06_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_06_02.jpg)'
- en: To extend our menu items, all we would need to do is to extend the preceding
    tuple and simultaneously adding the corresponding command callback method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的菜单项，我们只需要扩展前面的元组，并同时添加相应的命令回调方法。
- en: Engage Thrusters
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the GUI framework class
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建GUI框架类
- en: 'We build our framework in a file named `framework.py`, where we define a new
    class named `GUIFramework` as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为`framework.py`的文件中构建我们的框架，其中我们定义了一个名为`GUIFramework`的新类，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Step 2 – creating menu builder
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 创建菜单构建器
- en: 'The two methods of `GUIFramework` that are used to create menu builder are
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`GUIFramework`中用于创建菜单构建器的两种方法如下：'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The description of the code is listed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: The method, `build_menu`, operates on a tuple by the name `self.menubar`, which
    must specify all desired menu and menu items in the exact format, as previously
    discussed.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_menu`方法通过名为`self.menubar`的元组进行操作，必须指定所有所需的菜单和菜单项，格式必须与之前讨论的完全一致。'
- en: It iterates through each item in the tuple, splitting the item based on `-`delimiter,
    building the top-menu button for each item left to the `-` delimiter.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历元组中的每个项目，根据`-`分隔符拆分项目，为`-`分隔符左侧的每个项目构建顶级菜单按钮。
- en: It then splits the second part of the string based on `,`(comma) delimiter.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它根据`,`（逗号）分隔符拆分字符串的第二部分。
- en: It then iterates through this second part, creating menu items for each of the
    parts, adding the accelerator key, command callback, and underline key using another
    method, `__add_menu_command`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它遍历这个第二部分，为每个部分创建菜单项，使用另一个方法`__add_menu_command`添加加速键、命令回调和下划线键。
- en: The `__add_menu_command` method iterates through the string and adds a separator
    if it finds the string `Sep`. If not, it next searches for ampersand (`&`) in
    the string. If it finds one, it calculates its index position and assigns it to
    the underline variable. It then replaces ampersand value with an empty string,
    because we do not want to display the ampersand in our menu item.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__add_menu_command`方法遍历字符串，如果找到字符串`Sep`，则添加分隔符。如果没有找到，它将在字符串中搜索`&`符号。如果找到，它将计算其索引位置并将其分配给下划线变量。然后它将`&`值替换为空字符串，因为我们不希望在菜单项中显示`&`符号。'
- en: If ampersand is not found in a string, the code assigns `None` to the underline
    variable.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串中没有找到`&`符号，代码将`None`赋值给下划线变量。
- en: Finally, the code adds command callback, accelerator key, and underline value
    to the menu item.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，代码将命令回调、加速键和下划线值添加到菜单项中。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The logic that we used to define the menu builder is a completely arbitrary
    representation. We could have as well used a dictionary or a list. We could also
    have a separate logic altogether to represent our menu items, as long as it served
    the purpose of generating the menu items for us.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们用来定义菜单构建器的逻辑是完全任意的表示。我们也可以使用字典或列表。我们也可以有完全不同的逻辑来表示我们的菜单项，只要它能够为我们生成菜单项。
- en: Step 3 – testing our new framework
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 测试我们的新框架
- en: Finally, we add a `TestThisFramework` class to our file to test if our framework
    in general and our `build_menu` method in particular, works as expected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在文件中添加一个`TestThisFramework`类来测试我们的框架是否按预期工作，特别是我们的`build_menu`方法。
- en: 'The code for the `TestThisFramework` class is as follows(*framework.py*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestThisFramework`类的代码如下（*framework.py*）：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is listed as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Our `TestThisFramework` class inherits from the `GUIFramework` class, thus being
    in a position to use the `build_menu` method defined in the parent class.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`TestThisFramework`类继承自`GUIFramework`类，因此可以调用父类中定义的`build_menu`方法。
- en: It then adds a list of menu items, `menuitems`, and calls the method, `build_menu()`.
    It is important that the tuple be defined by the name, `menuitems`, because our
    `build_menu()` method is structured in the parent `GUIFramework` class to build
    menu only on the tuples named `menuitems`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它添加一个菜单项列表`menuitems`并调用`build_menu()`方法。重要的是元组必须由名称`menuitems`定义，因为我们的`build_menu()`方法在父`GUIFramework`类中结构化，仅构建名为`menuitems`的元组上的菜单。
- en: The test class also adds dummy commands to handle command callbacks for each
    of the menu items.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类还添加了虚拟命令来处理每个菜单项的命令回调。
- en: Running this test builds menu items as specified in the tuple. Try extending
    the tuple to add more menu items, and the framework will successfully include
    those items in the menu.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行此测试将根据元组中指定的内容构建菜单项。尝试扩展元组以添加更多菜单项，框架将成功将这些项包含在菜单中。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Like we added code to generate menus for us, we could have added similar code
    for other widgets that we foresee to be repeatedly used in our program. But we
    will leave the framework development there itself and proceed to developing our
    drawing application.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像我们添加了生成菜单的代码一样，我们也可以为其他我们预见将在程序中重复使用的控件添加类似的代码。但我们将框架开发留在这里，并继续开发我们的绘图应用程序。
- en: Developing a framework for smaller programs may be overkill, but they are invaluable
    assets for longer programs. Hopefully, you should now be able to appreciate the
    benefits of writing your own custom frameworks for larger programs.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为较小的程序开发框架可能是过度设计，但它们对于较长的程序是无价之宝。希望你现在应该能够欣赏为大型程序编写自定义框架的好处。
- en: Objective Complete – Mini Debriefing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: Now that we have our `build_menu` ready, we can extend it to add as many menu
    items as required without having to write repetitive and similar code for each
    of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`build_menu`，我们可以扩展它以添加所需的任何菜单项，而无需为每个项编写重复且类似的代码。
- en: This ends our first iteration, where we laid the foundations for our custom
    GUI framework. We will not extend the framework further, but hopefully, you should
    now be in a position to extend it for other widgets, if required.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们的第一次迭代结束，我们为自定义GUI框架奠定了基础。我们不会进一步扩展框架，但希望您现在应该能够根据需要扩展它以用于其他小部件。
- en: Classified Intel
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类智能
- en: In this section, you also saw how our `TestThisFramework` class inherited features
    from our `GUIFramework` class. This is the first time we have used inheritance
    in our program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您也看到了我们的`TestThisFramework`类如何从我们的`GUIFramework`类继承特性。这是我们第一次在我们的程序中使用继承。
- en: So far, we have always passed objects created as classes as arguments to other
    classes, and then used them using the`.`(dot) notation. This is named **composition**
    .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是将作为类创建的对象传递给其他类作为参数，然后使用`.`（点）符号来使用它们。这被称为**组合**。
- en: With inheritance, we do not need to access methods of another class using the
    dot notation. We can use the methods of a superclass in the subclass as though
    they belong to the subclass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，我们不需要使用点符号来访问另一个类的成员方法。我们可以在子类中使用超类的方法，就像它们属于子类一样。
- en: Inheritance brings in the advantage of dynamic binding and polymorphism.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 继承带来了动态绑定和多态的优势。
- en: Dynamic binding means the method to be invoked is decided at runtime, thus providing
    greater flexibility to design of our code. Polymorphism implies that variables
    of a superclass hold a reference to an object created from itself or from any
    of its subclasses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定意味着要调用的方法是在运行时决定的，从而为我们的代码设计提供了更大的灵活性。多态意味着超类变量持有从自身或其任何子类创建的对象的引用。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inheritance is fit for situations where the object of the subclass is of the
    same type as the superclass. In our example, menu items will remain the same whether
    you define them from the superclass or from the subclass. We, therefore, defined
    it in our superclass and inherited it in our subclass.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 继承适用于子类对象与超类对象类型相同的情况。在我们的例子中，无论您是从超类还是从子类定义菜单项，菜单项都将保持不变。因此，我们在超类中定义了它，并在子类中继承了它。
- en: If, however, the object needs to appear or behave differently depending on an
    object's condition or state, composition is preferable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对象需要根据对象的条件或状态以不同的方式出现或表现，则组合更可取。
- en: Structuring our drawing program
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的绘图程序
- en: 'Let''s now get down to setting the basic structure for our drawing program.
    We want to achieve a structure, as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来设置绘图程序的基本结构。我们希望达到的结构，如下面的截图所示：
- en: '![Structuring our drawing program](img/7941_06_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![构建我们的绘图程序](img/7941_06_03.jpg)'
- en: The structure here primarily consists of a top menu, which inherits from the
    GUI framework `build_menu` method that we created in the last iteration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的结构主要包含一个顶部菜单，它继承自我们在上一次迭代中创建的GUI框架`build_menu`方法。
- en: In addition, we create a top-bar frame towards the top(marked in yellow) with
    a method, `create_top_bar()`, and a toolbar frame to the left (marked with dark
    grey background) with `create_tool_bar()`. We also create a Canvas widget on the
    right side using the `create_drawing_canvas()` method, which is to serve as our
    drawing area.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在顶部创建了一个带有`create_top_bar()`方法的顶部栏框架（用黄色标记），以及一个带有`create_tool_bar()`的左侧工具栏框架（用深灰色背景标记）。我们还使用`create_drawing_canvas()`方法在右侧创建了一个Canvas小部件，它将作为我们的绘图区域。
- en: We will not be reproducing the code for making the frames and canvas area, because
    we have done similar things in our previous projects and you should be comfortable
    making them by now. However, you can check the actual code in the file, *6.01.py*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会重新生成创建框架和画布区域的代码，因为我们已经在以前的项目中做过类似的事情，并且您现在应该能够轻松地完成它们。然而，您可以在文件*6.01.py*中查看实际的代码。
- en: Engage Thrusters
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – importing framework
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 – 导入框架
- en: 'The first thing to note here is that we import our previously created framework
    module here and inherit its property in our main class, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的第一点是，我们在这里导入之前创建的框架模块，并在主类中继承其属性，如下所示：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This enables us to use the `build_menu` method that we had defined in the framework
    as though it belongs to the child class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够像它属于子类一样使用我们在框架中定义的 `build_menu` 方法。
- en: 'Step 2: building the top menu'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：构建顶部菜单
- en: 'Next, we define the actual menu items to build the top menu in a method defined
    `create_menu`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义实际的菜单项以在 `create_menu` 方法中构建顶部菜单，如下所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The description of the code is listed as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: 'This actually creates three menu buttons: **File**, **Edit**, and **About**,
    adding menu items to each of them as per preceding provided tuple.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这实际上创建了三个菜单按钮：**文件**、**编辑**和**关于**，并将前一个提供的元组中的菜单项添加到每个按钮中。
- en: Creating the menu also necessitates the creation of their associated command
    callbacks again, as defined in the preceding tuple. Accordingly, we create the
    methods associated with these command callbacks.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单也需要再次创建它们相关的命令回调，如前一个元组中定义的那样。因此，我们创建了与这些命令回调相关的方法。
- en: We will not reproduce the code for functionalities, such as `new_file`, `open_file`,
    `close`, `undo`, and `about`, because we have done similar coding in our previous
    projects. However, let's take a look at the undo and save operations.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将不会重现 `new_file`、`open_file`、`close`、`undo` 和 `about` 等功能的代码，因为我们已经在之前的项目中进行了类似的编码。然而，让我们看看撤销和保存操作。
- en: Step 3 – undo operation on the Canvas widget
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 在 Canvas 小部件上执行撤销操作
- en: Recall that the Tkinter text widget has built-in support for unlimited undo/redo
    functionality. The Canvas widget, however, does not have this built-in feature.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Tkinter 文本小部件具有内置的无限制撤销/重做功能。然而，Canvas 小部件没有这个内置功能。
- en: 'Here, we implement a very basic undo operation, which lets us delete the last
    drawn item on the canvas as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现了一个非常基本的撤销操作，允许我们删除画布上最后绘制的项目，如下所示：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the code is listed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The Canvas widget provides a `widget.delete(items)` method that deletes a given
    item from the canvas.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas 小部件提供了一个 `widget.delete(items)` 方法，可以从画布中删除指定的项目。
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, once you delete a canvas item, it is gone forever. You cannot restore
    it unless you have implemented a method which stores all the configurable options
    for that item before deleting.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，一旦您删除了画布项目，它就永远消失了。除非您在删除之前实现了存储该项目所有可配置选项的方法，否则您无法恢复它。
- en: While it is possible to implement fully-featured undo/redo operation by storing
    all configurations for an item being deleted in an undo stack, we will not implement
    it here, because it would be a deviation from our core topic.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然可以通过存储要删除的项目所有配置来实施完整的撤销/重做操作，但我们不会在这里实施它，因为这会偏离我们的核心主题。
- en: Step 4 – saving canvas objects
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 保存画布对象
- en: 'Tkinter lets you save canvas objects as a postscript file using the command
    `postscript()`, as follows (see *code 6.01.py*):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 允许您使用 `postscript()` 命令将画布对象保存为 postscript 文件，如下所示（参见 *代码 6.01.py*）：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note, however, that this command does not include the images and embedded widgets
    on the canvas.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，此命令不包括画布上的图像和嵌入的小部件。
- en: Step 5 – creating buttons in the left tool bar
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 在左侧工具栏中创建按钮
- en: 'Having coded command callbacks for all our menu items, let''s now create buttons
    on the left toolbar. As per our original plan, we will need eight buttons on the
    toolbar. For now, let''s show the button text as `0` through `7` as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在为所有我们的菜单项编码了命令回调之后，我们现在将在左侧工具栏上创建按钮。根据我们的原始计划，我们需要在工具栏上放置八个按钮。目前，让我们将按钮文本显示为
    `0` 到 `7`，如下所示：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This creates eight buttons, arranging them in two columns depending on whether
    the button number is odd or even.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了八个按钮，根据按钮编号是奇数还是偶数将它们排列成两列。
- en: Step 6 – adding command callback to buttons
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6 步 – 将命令回调添加到按钮
- en: 'All buttons are attached to the same command callback, `selected_tool_bar_item`,
    which takes the button number as its argument. The callback method will be taken
    forward in the next iteration. However, for now, let''s simply define the callback
    to print the number of the button that is clicked on, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有按钮都连接到同一个命令回调 `selected_tool_bar_item`，它将按钮编号作为其参数。回调方法将在下一次迭代中继续。然而，现在让我们简单地定义回调以打印被点击的按钮编号，如下所示：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Step 7 – creating color palettes and color selection dialog
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7 步 – 创建调色板和颜色选择对话框
- en: Lastly, let's create two color palettes to keep track of two colors named background
    and foreground color.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建两个调色板来跟踪两个名为背景色和前景色的颜色。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Tkinter provides a `tkColorChooser` module that pops up a color chooser dialog.
    When a user selects a color and clicks the **OK** button, the module returns a
    tuple of the form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter提供了一个`tkColorChooser`模块，该模块弹出颜色选择对话框。当用户选择一种颜色并点击**确定**按钮时，该模块返回一个元组，其形式如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first element of the returned tuple is itself a tuple specifying the RGB
    coordinates for the given color, while the second element is the hexadecimal color
    code for the selected color.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组的第一个元素本身是一个元组，指定了给定颜色的RGB坐标，而第二个元素是所选颜色的十六进制颜色代码。
- en: 'The idea here is that clicking on a palette should open a color chooser. When
    a user selects a given color, it should update the foreground and background color
    attributes of the object, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是点击调色板应该打开一个颜色选择器。当用户选择一个给定的颜色时，它应该更新对象的背景色和前景色属性，如下面的截图所示：
- en: '![Step 7 – creating color palettes and color selection dialog](img/7941_06_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![第7步 – 创建颜色调色板和颜色选择对话框](img/7941_06_04.jpg)'
- en: 'The code to achieve this functionality is as follows(see *code 6.01.py*):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能所需的代码如下（见 *code 6.01.py*）：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The description of the code is listed as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We add two different tags to each of the square pieces, and then use the `tag_bind`
    command to bind them to the click of mouse button over them. Take a note of the
    difference between widget-level binding(`widget.bind`) and the item-specific binding
    using the `tag_bind` method
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个正方形部分添加两个不同的标签，然后使用`tag_bind`命令将它们绑定到鼠标按钮的点击事件上。请注意widget级绑定（`widget.bind`）和使用`tag_bind`方法的项特定绑定的区别
- en: To create the color palettes, we first create a Canvas widget within the toolbar
    frame. Within this canvas, we create two square areas using `canvas.create_rectangle`
    and bind them to a single mouse click event to call `set_background_color` and
    `set_foreground_color` respectively.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建颜色调色板，我们首先在工具栏框架内创建一个Canvas小部件。在这个画布内，我们使用`canvas.create_rectangle`创建两个正方形区域，并将它们绑定到单个鼠标点击事件，分别调用`set_background_color`和`set_foreground_color`。
- en: Step 8 – setting color of background and foreground palette
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步 – 设置背景和前景调色板的颜色
- en: 'Color of the background and foreground palette can be set as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 背景和前景调色板的颜色可以设置如下：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Step 9 – displaying x and y coordinates of mouse movement
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步 – 显示鼠标移动的x和y坐标
- en: 'Finally, we add a static label to our toolbar frame to track the x and y coordinates
    of mouse movement. The actual tracking function will be created later but let''s
    reserve the space by putting a static label for now, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在工具栏框架中添加了一个静态标签来跟踪鼠标移动的x和y坐标。实际的跟踪功能将在以后创建，但现在让我们通过放置一个静态标签来预留空间，如下所示：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Objective Complete – Mini Debriefing
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our second iteration. In this iteration, we set the basic structure
    for our drawing program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第二次迭代。在这个迭代中，我们为我们的绘图程序设置了基本结构。
- en: Importantly, we saw how to inherit features from our previously created framework
    to create menu items with minimal coding.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们看到了如何从先前创建的框架中继承功能，以最小化编码创建菜单项。
- en: We also added the color selection dialog using the `tkColorChooser` module,
    which sets in two attributes, `self.background` and `self.foreground`, to be used
    application-wide.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了颜色选择对话框，使用`tkColorChooser`模块，该模块设置了两个属性`self.background`和`self.foreground`，以供应用程序范围使用。
- en: Handling mouse events
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理鼠标事件
- en: Before we let the user draw on the canvas, we need to bind the canvas event
    to mouse movements and mouse click.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让用户在画布上绘制之前，我们需要将画布事件绑定到鼠标移动和鼠标点击。
- en: Drawing or adding any item on to the Canvas widget first requires that we know
    the coordinates of the location where the item is to be placed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布小部件上绘制或添加任何项目之前，我们首先需要知道项目放置位置的坐标。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Canvas widget uses two coordinate systems to track positions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件使用两个坐标系来跟踪位置：
- en: '**Window coordinate system**: Coordinate as expressed in relation to root window'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口坐标系**：坐标表示为相对于根窗口的关系'
- en: '**Canvas coordinate system**: Coordinate as expressed as position of item within
    the canvas'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布坐标系**：坐标表示为画布内项目的位置'
- en: 'You can convert from window coordinates to canvas coordinates using the `canvasx`
    and `canvasy` methods as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`canvasx`和`canvasy`方法将窗口坐标转换为画布坐标，如下所示：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Engage Thrusters
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – binding mouse down, mouse motion, and mouse release over the canvas
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 在画布上绑定鼠标按下、鼠标移动和鼠标释放
- en: Drawing any item on the canvas would begin when the user clicks the mouse button.
    The drawing needs to continue till the mouse is moved with the button pressed
    and up to the time the mouse button is released.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制任何项目都将从用户点击鼠标按钮开始。绘制需要一直持续到鼠标移动且按钮被按下，直到鼠标按钮被释放。
- en: Thus, we need to track the position of initial mouse down event. This is to
    be followed by tracking the mouse movement while the button is clicked on, up
    to the final button release event.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要跟踪初始鼠标按下事件的位置。这将随后跟踪鼠标在按钮按下时的移动，直到最终的按钮释放事件。
- en: 'Accordingly, we add the following widget binding to our canvas (see *code 6.02.py*):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在画布上添加了以下小部件绑定（见*代码6.02.py*）：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Step 2 – calculating coordinates of mouse movement
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 计算鼠标移动的坐标
- en: Having bound the mouse click, mouse movement, and mouse release events, it's
    now time to define their corresponding callback methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定了鼠标点击、鼠标移动和鼠标释放事件后，现在需要定义它们对应的回调方法。
- en: 'In particular, we want the `mouse_down` method to give us the x and y coordinates
    for the first mouse click event, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们希望`mouse_down`方法给我们提供第一次鼠标点击事件的x和y坐标，如下所示：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want to keep updating the `lastx` and `lasty` coordinates up till the mouse
    stops moving, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望持续更新`lastx`和`lasty`坐标，直到鼠标停止移动，如下所示：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `mouse_up` method should make the final update to our `lastx` and `lasty`
    coordinates, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`mouse_up`方法应该对`lastx`和`lasty`坐标进行最后的更新，如下所示：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The description of the code is listed as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `mouse_down` method simply initializes the values of `startx`, `starty`,
    `lastx`, and `lasty` to the coordinates of the mouse click position.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouse_down`方法简单地将`startx`、`starty`、`lastx`和`lasty`的值初始化为鼠标点击位置的坐标。'
- en: The `mouse_down_motion` method changes the value of `lastx` and `lasty` as the
    mouse motion keeps happening.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouse_down_motion`方法在鼠标移动发生时改变`lastx`和`lasty`的值。'
- en: Finally, the `mouse_up` method sets the value of `lastx` and `lasty` as coordinates
    of the point where the mouse button is released.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`mouse_up`方法将`lastx`和`lasty`的值设置为鼠标按钮释放点的坐标。
- en: 'Thus, using the three events: `mouse_down`, `mouse_down_motion`, and `mouse_up`,
    we manage to get the coordinates for starting point, coordinates for points through
    which the mouse pointer traverses, and the coordinates for the end point.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，使用三个事件：`mouse_down`、`mouse_down_motion`和`mouse_up`，我们成功地得到了起点坐标、鼠标指针穿越的点的坐标以及终点坐标。
- en: Now we can use these values to place any item on the canvas at the given coordinates.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些值在给定的坐标上放置画布上的任何项目。
- en: Step 3 – updating the current mouse position label in the left tool bar
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 更新左侧工具栏中的当前鼠标位置标签
- en: 'In addition, we would also like to track the motion of the mouse over the canvas,
    even when the mouse button is not clicked down. We need to track this to update
    the current mouse position in the left toolbar. This is simple, as shown in the
    following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想跟踪鼠标在画布上的移动，即使鼠标按钮没有被按下。我们需要跟踪这一点以更新左侧工具栏中的当前鼠标位置。这很简单，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code will ensure that any mouse movement over the canvas updates the label
    in the left toolbar with the current position of mouse.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将确保任何在画布上移动的鼠标都会更新左侧工具栏中的当前鼠标位置标签。
- en: Objective Complete – Mini Debriefing
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: Now our Canvas widget has become responsive to mouse movements and mouse clicks.
    Every time we click the mouse button over the canvas and drag the mouse pointer
    to a new place, the values of `startx`, `starty`, `lastx` and `lasty` get updated
    to reflect the coordinates for the mouse movement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Canvas小部件已经对鼠标移动和鼠标点击做出了响应。每次我们在画布上点击鼠标按钮并拖动鼠标指针到新的位置时，`startx`、`starty`、`lastx`和`lasty`的值都会更新，以反映鼠标移动的坐标。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Together, these coordinates constitute what is called the bounding box for
    an item. In fact, if there are items on a canvas, you can retrieve the coordinates
    for any given item using the API:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标共同构成了一个项目的边界框。实际上，如果画布上有项目，你可以使用API检索任何给定项目的坐标：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This returns the coordinates as a four-item tuple.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含四个元素的坐标元组。
- en: If the item name is not specified, this method returns the bounding box for
    all elements on the canvas.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定项目名称，此方法将返回画布上所有元素的边界框。
- en: Now that we have the coordinates available, we can think of drawing items on
    the canvas. We do some drawing in the next iteration.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了坐标，我们可以考虑在画布上绘制项目。我们将在下一次迭代中进行一些绘制。
- en: Drawing items on the canvas
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上绘制项目
- en: 'Let''s now draw some items on the canvas. The Canvas widget natively supports
    drawing the following items:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在在画布上绘制一些项目。Canvas小部件原生支持绘制以下项目：
- en: '| Item | Code for adding the item |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 添加项目的代码 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Arc | `w.create_arc( bbox, **options)` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 弧线 | `w.create_arc( bbox, **options)` |'
- en: '| Bitmap | `w.create_bitmap( bbox, **options)` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 位图 | `w.create_bitmap( bbox, **options)` |'
- en: '| Image | `w.create_image( bbox, **options)` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 图像 | `w.create_image( bbox, **options)` |'
- en: '| Line | `w.create_line( bbox, **options)` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 线 | `w.create_line( bbox, **options)` |'
- en: '| Oval | `w.create_oval( bbox, **options)` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 椭圆 | `w.create_oval( bbox, **options)` |'
- en: '| Polygon | `w.create_ploygon( bbox, **options)` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 多边形 | `w.create_polygon( bbox, **options)` |'
- en: '| Rectangle | `w.create_rectangle( bbox, **options)` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 矩形 | `w.create_rectangle( bbox, **options)` |'
- en: '| Text | `w.create_text( bbox, **options)` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 文本 | `w.create_text( bbox, **options)` |'
- en: '| Window | `w.create_window( bbox, **options)` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 窗口 | `w.create_window( bbox, **options)` |'
- en: 'Let us add the ability to draw lines, rectangles, and ovals to our drawing
    program. We will also add a brush stroke feature to our program, as shown in the
    following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加绘制线条、矩形和椭圆的能力到我们的绘图程序中。我们还将添加一个画笔描边功能到我们的程序中，如下面的截图所示：
- en: '![Drawing items on the canvas](img/7941_06_05.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![在画布上绘制项目](img/7941_06_05.jpg)'
- en: Engage Thrusters
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating a tuple of methods
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建方法元组
- en: 'We first create a tuple of methods that we intend to define here as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个方法元组，如下所示：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Doing so ensures that we do not have to call each method explicitly from our
    code. We can instead use the index of the tuple to retrieve the method name and
    call it dynamically using:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以确保我们不需要从代码中显式调用每个方法。我们可以使用元组的索引来检索方法名称，并通过以下方式动态调用它：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This makes sense here, because we would eventually add more features to our
    drawing program by simply extending our `all_toolbar_functions`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里是有意义的，因为我们最终将通过扩展我们的`all_toolbar_functions`来简单地添加更多功能到我们的绘图程序中。
- en: Step 2 – add icons to our toolbar buttons
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 为工具栏按钮添加图标
- en: Our next task here is to add icons on the left toolbar for drawing these items.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是给左侧工具栏添加绘制这些项目的图标。
- en: We add the icons to our `icons` folder. We also ensure to rename each icon file
    to the name of the method called by it. This naming again helps in calling the
    methods dynamically, and this style of programming is what you could call programming
    using **conventions over configuration**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图标添加到`icons`文件夹中。我们还确保将每个图标文件重命名为它调用的方法的名称。这种命名再次有助于动态调用方法，这种编程风格可以称为**约定优于配置**的编程。
- en: 'Our current `create_tool_bar_buttons()`method creates eight buttons using a
    for loop. However, we will now modify our `create_tool_bar_buttons()`method to
    use the `enumerate()` method to loop overall items in our `all_toolbar_functions`
    tuple to add icons for each of the methods, as follows (see *code 6.03.py*):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`create_tool_bar_buttons()`方法使用for循环创建了八个按钮。然而，我们现在将修改我们的`create_tool_bar_buttons()`方法，使用`enumerate()`方法遍历`all_toolbar_functions`元组中的所有项，为每个方法添加图标，如下所示（见*code
    6.03.py*）：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Step 3 – keeping a tab on currently selected button
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 跟踪当前选定的按钮
- en: 'Next, we modify the method, `selected_tool_bar_item(i)`; the only purpose of
    which is to keep a tab on the currently selected button. Having this information,
    we can later call the associated method from `all_toolbar_functions` by using
    this index, as follows (see *code 6.03.py*):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改`selected_tool_bar_item(i)`方法；它的唯一目的是跟踪当前选定的按钮。有了这个信息，我们可以稍后通过使用此索引从`all_toolbar_functions`调用相关方法，如下所示（见*code
    6.03.py*）：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Step 4 – code for drawing line, rectangle, and oval shapes
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 绘制线条、矩形和椭圆形状的代码
- en: Now is the time to code the methods to draw these basic shapes. Note that this
    will not automatically create the drawings. Eventually, these methods will have
    to be called from somewhere to actually make the drawings. We will do that in
    step 6.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写绘制这些基本形状的方法了。请注意，这不会自动创建绘图。最终，这些方法必须从某处调用以实际进行绘图。我们将在第6步中这样做。
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Step 5 – code for drawing in continuous stroke
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 连续绘制代码
- en: Drawing in a continuous stroke is similar to drawing lines, but the fresh lines
    are redrawn after every small change in coordinates. In the current state of things,
    the value of `lastx` and `lasty` are only updated when the mouse button is released.
    But here we need to update the value of `lastx` and `lasty`, not on mouse release,
    but on mouse motion. To achieve this, we bind the mouse motion to a newly defined
    method `draw_brush_update_xy`, which updates the x and y coordinate in every subsequent
    loop turn.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 连续绘制与绘制线条类似，但新线条会在坐标的每次小变化后重新绘制。在当前的状态下，`lastx` 和 `lasty` 的值仅在鼠标按钮释放时更新。但在这里，我们需要在鼠标移动时更新
    `lastx` 和 `lasty` 的值。为了实现这一点，我们将鼠标移动绑定到一个新定义的方法 `draw_brush_update_xy`，该方法在每次后续循环迭代中更新
    x 和 y 坐标。
- en: Earlier, we had bound mouse down motion to another method named `mouse_down_motion`.
    For drawing continuous stroke, we will now bind it to a method named `draw_brush_update_xy`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们将鼠标按下移动绑定到了另一个名为 `mouse_down_motion` 的方法。为了绘制连续的笔触，我们现在将其绑定到名为 `draw_brush_update_xy`
    的方法。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding an event binding to more than one method wipes away the previous binding,
    whereby the new binding replaces any existing binding. Thus, when you exit out
    of the `draw_brush` loop, you need to rebind the event back to the `mouse_down_motion`
    method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将事件绑定添加到多个方法中会清除之前的绑定，新的绑定将替换任何现有的绑定。因此，当你退出 `draw_brush` 循环时，你需要重新绑定事件到 `mouse_down_motion`
    方法。
- en: 'Alternatively, you can use `add="+"` as an additional argument to keep more
    than one binding to the same event as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `add="+"` 作为额外的参数来保持对同一事件的多个绑定，如下所示：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Thus, we create a loop where the `draw_brush` method calls another method,
    `draw_brush_update_xy`, on successive mouse motions to update the x and y coordinates
    as follows (see *code 6.03.py*):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个循环，其中 `draw_brush` 方法在连续的鼠标移动中调用另一个方法 `draw_brush_update_xy` 来更新 x
    和 y 坐标，如下所示（见 *代码 6.03.py*）：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the Draw Brush button is unselected, we break out of the loop and rebind
    the mouse motion back to the canvas `mouse_down_motion`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“绘制画笔”按钮未选中，我们将退出循环并将鼠标移动重新绑定到画布的 `mouse_down_motion`。
- en: Step 6 – executing code dynamically
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 动态执行代码
- en: We have planned to execute methods dynamically, based on index from the names
    of methods given in a tuple named `all_toolbar_functions`. However, the names
    are stored as strings, and we just cannot take a piece of string and expect Python
    to evaluate it. In order to that, we will use Python's built-in `getattr()`method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划根据名为 `all_toolbar_functions` 的元组中给出的方法名称的索引动态执行方法。然而，这些名称被存储为字符串，我们无法仅取字符串的一部分并期望
    Python 评估它。为了做到这一点，我们将使用 Python 的内置 `getattr()` 方法。
- en: 'We now define a method that takes a string and makes it suitable for execution
    as a method, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义了一个方法，该方法接受一个字符串并将其转换为适合执行的方法，如下所示：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Step 7 – doing the actual drawing
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步 – 进行实际绘图
- en: Having defined methods to draw line, rectangle, oval, and brush strokes, we
    need to call them from somewhere for the drawing to happen. Intuitively, the drawings
    must begin on the first mouse down movement and the drawing must be deleted and
    redrawn up till the mouse button release.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了绘制线条、矩形、椭圆和画笔笔触的方法后，我们需要从某处调用它们以进行绘图。直观上，绘图必须从第一次鼠标按下开始，并且绘图必须在鼠标按钮释放之前被删除并重新绘制。
- en: 'Accordingly, these methods must be called from our `mouse_down_motion` method.
    We, therefore, modify our `mouse_down_motion` and `mouse_up` methods to do this,
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些方法必须从我们的 `mouse_down_motion` 方法中调用。因此，我们修改了 `mouse_down_motion` 和 `mouse_up`
    方法来完成这项工作，如下所示：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Objective Complete – Mini Debriefing
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简要回顾
- en: This completes our objective for the iteration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本次迭代的任务。
- en: We began by creating a tuple of method names so as to be able to call a method
    dynamically by specifying its index in the tuple.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个方法名称的元组，以便能够通过指定元组中的索引动态调用方法。
- en: We then added icons for our toolbar buttons. We then associated a button click
    to a method that keeps tab on currently selected button by assigning its index
    to the variable, `self.selected_toolbar_func_index`. We then defined methods to
    draw line, rectangle, and oval shapes on our canvas. We also showed how to utilize
    the ability to draw lines to draw in continuous strokes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为工具栏按钮添加了图标。然后，我们将按钮点击与一个方法关联起来，该方法通过将索引分配给变量 `self.selected_toolbar_func_index`
    来跟踪当前选定的按钮。然后我们定义了在画布上绘制线条、矩形和椭圆形状的方法。我们还展示了如何利用绘制线条的能力进行连续绘制。
- en: Finally, we called all the draw methods from `mouse_down_motion` and `mouse_release`
    method to do the actual drawing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从 `mouse_down_motion` 和 `mouse_release` 方法中调用了所有绘图方法来进行实际的绘图。
- en: A user can now draw basic shapes, such as lines, rectangles, ovals, and brush
    strokes on to the canvas. The shapes are drawn in the currently set foreground
    color.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以在画布上绘制基本形状，例如线条、矩形、椭圆形和笔触。这些形状将以当前设置的背景色绘制。
- en: Setting the options toolbar at the top
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置顶部选项工具栏
- en: Although our program can draw basic shapes, these shapes are currently filled
    with the foreground color and the outline of the shape is done in black.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的程序可以绘制基本形状，但这些形状目前填充的是前景色，形状的轮廓是用黑色完成的。
- en: The Canvas widget lets you specify the fill color, outline color, and border
    width for most of the shapes as its configurable options.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件允许您指定大多数形状的填充颜色、轮廓颜色和边框宽度作为其可配置选项。
- en: In addition to these, the Canvas widget also has several other configurable
    options for many of these basic shapes. For instance, for a line, you can specify
    if it will have an arrow head shape at the end or if it will be dashed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Canvas小部件还有许多其他基本形状的可配置选项。例如，对于线条，您可以指定它是否在末端有箭头形状，或者是否为虚线。
- en: 'Let''s accordingly modify our program to allow the user to select configurable
    options for each of the four basic shapes, as shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们相应地修改我们的程序，以便用户可以为四种基本形状中的每一种选择可配置的选项，如下面的截图所示：
- en: '![Setting the options toolbar at the top](img/7941_06_06.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![设置顶部选项工具栏](img/7941_06_06.jpg)'
- en: Engage Thrusters
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – showing the selected button icon at the top
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 在顶部显示所选按钮图标
- en: Let's start with a simple thing first. When a user clicks on a button in the
    left toolbar, the top frame should display the text **Selected Tool:** followed
    by the icon representation for the selected button.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从简单的事情开始。当用户在左侧工具栏中点击按钮时，顶部框架应显示文本 **所选工具：** 然后是所选按钮的图标表示。
- en: 'Because this event must occur on click of any button, we modify our `selected_tool_bar_item`
    method to include a call to two methods, as highlighted in the following code
    (see *code 6.04.py*):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个事件必须在任何按钮的点击时发生，所以我们修改了 `selected_tool_bar_item` 方法，包括对两个方法的调用，如下面的代码所示（见
    *code 6.04.py*）：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The description of the code is listed as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `remove_options_from_topbar` method ensures that when a new button is clicked,
    options for the previous button are deleted. The `show_selected_tool_icon_in_topbar`
    method actually displays the icon for the currently selected button.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_options_from_topbar` 方法确保当点击新的按钮时，删除之前按钮的选项。`show_selected_tool_icon_in_topbar`
    方法实际上显示了当前所选按钮的图标。'
- en: Note
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`widget.winfo_children()` returns a list of all children for a given widget,
    in their stacking order from bottom to top.'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`widget.winfo_children()` 返回给定小部件的所有子小部件列表，按照从下到上的堆叠顺序。'
- en: You can extract a lot of window-related information using one of the many `winfo`
    methods. For a complete list of the `winfo` methods, refer to the *The basic widget
    methods* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用许多 `winfo` 方法中的任何一个来提取大量与窗口相关的信息。有关 `winfo` 方法的完整列表，请参阅[附录B](apb.html "附录 B. 快速参考表")中的
    *基本小部件方法* 部分，*快速参考表*。
- en: Alternatively, each widget has also its own children attribute, which is a dictionary
    where the keys are the IDs and the values are the widgets. So if the order is
    not relevant, this is the same as `widget.children.values()`.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，每个小部件也有自己的子属性，它是一个字典，键是ID，值是小部件。所以如果顺序不重要，这和 `widget.children.values()` 是一样的。
- en: Step 2 – adding the Combobox widget to let user select different fill options
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 添加Combobox小部件以让用户选择不同的填充选项
- en: 'Next, we need to define the selection combobox for a user to select options
    for fill, outline, width, arrow, and dash. We will use ttk Combobox to allow the
    user to make a selection, and as such, we import it into our current file, as
    follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个选择组合框，让用户可以选择填充、轮廓、宽度、箭头和虚线的选项。我们将使用 ttk Combobox 允许用户进行选择，因此我们将其导入到当前文件中，如下所示：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will not reproduce the entire code here. However, for each of the preceding
    options, we define two methods: one that displays the combobox and the other sets
    the value of the current selection made by the user.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会复制整个代码。然而，对于上述每个选项，我们定义了两个方法：一个用于显示组合框，另一个用于设置用户当前选择的值。
- en: 'Thus, we set the following two definitions for fill option, as follows (see
    *code 6.04.py*):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为填充选项设置了以下两个定义，如下所示（见 *代码 6.04.py*）：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We similarly define other pair of methods for each of the sets, namely (see
    *code 6.04.py*):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式为每个集合定义其他方法对，即（见 *代码 6.04.py*）：
- en: '`outline_options_combobox:set_outline`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outline_options_combobox:set_outline`'
- en: '`width_options_combobox:set_width`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width_options_combobox:set_width`'
- en: '`arrow_options_combobox:set_arrow`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrow_options_combobox:set_arrow`'
- en: '`dash_options_combobox:set_dash`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dash_options_combobox:set_dash`'
- en: Step 3 – modifying draw methods to add configurable options
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步 – 修改绘图方法以添加可配置选项
- en: 'Now that we have ways to set different values for fill, outline, arrow, and
    dash configurable options, let''s modify our drawing code to include these in
    the actual drawing, as follows (see *code 6.04.py*):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设置填充、轮廓、箭头和虚线可配置选项不同值的方法，让我们修改我们的绘图代码，以包括实际的绘图，如下所示（见 *代码 6.04.py*）：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Having defined all these methods, it is now time to call them from somewhere.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了所有这些方法后，现在是时候从某处调用它们了。
- en: 'While the fill combobox would be applicable to all the four basic shapes, the
    arrow option would only be applicable to drawing lines. Because there will be
    a different set of comboboxes for different selections, we define the following
    methods (see *code 6.04.py*):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然填充组合框适用于所有四个基本形状，但箭头选项仅适用于绘制线条。因为将会有不同选择的组合框集，我们定义以下方法（见 *代码 6.04.py*）：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, these methods have to be called from somewhere, depending on the selection
    made. So we modify our `selected_tool_bar_item` method to call a method dynamically,
    named by appending the string `_options` to the name of selected method as follows
    (see *code 6.04.py*):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些方法必须从某处调用，这取决于所做的选择。因此，我们修改了 `selected_tool_bar_item` 方法，以动态调用一个方法，方法名是通过在所选方法名称后附加字符串
    `_options` 来命名的，如下所示（见 *代码 6.04.py*）：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Objective Complete – Mini Debriefing
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: The program user can now select from the various options provided for each of
    the toolbar buttons (see *code 6.04.py*).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 程序用户现在可以从为每个工具栏按钮提供的各种选项中进行选择（见 *代码 6.04.py*）。
- en: More importantly, we saw some of the configuration options available for items
    drawn on the Tkinter Canvas widget. We were also introduced to the `winfo` methods.
    These methods can be used to extract a lot of data about a widget and are a useful
    tool to have when programming a GUI application in Tkinter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们看到了在 Tkinter Canvas 小部件上绘制的项目可用的配置选项。我们还介绍了 `winfo` 方法。这些方法可以用来提取有关小部件的大量数据，当在
    Tkinter 中编程 GUI 应用程序时，这是一个有用的工具。
- en: Adding some more features
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多功能
- en: 'Next in line, let''s add a few more features to our drawing program. In particular,
    we will add the ability to delete objects from the canvas, add a paint bucket,
    the ability to move items up and down the stack, and the ability to drag items
    on the canvas, as shown in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向我们的绘图程序添加一些更多功能。特别是，我们将添加从画布中删除对象的能力，添加一个油漆桶，以及移动项目上下堆叠的能力，以及拖动画布上项目的能力，如下面的截图所示：
- en: '![Adding some more features](img/7941_06_07.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![添加更多功能](img/7941_06_07.jpg)'
- en: Engage Thrusters
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – extending our methods tuple
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 – 扩展我们的方法元组
- en: 'As a first thing, let us extend our `all_toolbar_functions` method to make
    provisions for the new methods that we will define here, as follows (see *code
    6.05.py*):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扩展我们的 `all_toolbar_functions` 方法，为我们将在此定义的新方法提供便利，如下所示（见 *代码 6.05.py*）：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As usual, we have added icons to the `icon` folder by the same name as the method
    that would handle it. The buttons are automatically displayed in our left toolbar
    merely by adding new methods to this tuple and by adding corresponding icons to
    our `icon` folder because of the way we have designed the `create_tool_bar_buttons`
    method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们通过添加与处理该功能的方法同名的方法到 `icon` 文件夹中，为 `icon` 文件夹添加了图标。通过向这个元组添加新方法，并添加相应的图标到我们的
    `icon` 文件夹，由于我们设计的 `create_tool_bar_buttons` 方法，按钮会自动显示在我们的左侧工具栏中。
- en: Step 2 – targeting a given item on the canvas
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 – 定位画布上的特定项目
- en: Before define the methods for handling the new features, let's pause and think
    about the kind of work we need to do here.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义处理新功能的方法之前，让我们暂停一下，思考一下这里需要做的工作。
- en: The operations that we want to do now are slightly different from their predecessors.
    Earlier, we were creating items on the canvas. Now we have to target items already
    present on the canvas.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要执行的操作与其前辈略有不同。以前，我们在画布上创建项目。现在我们必须针对画布上已经存在的项目。
- en: The items that need to be targeted are the ones on which the user clicks on
    with his or her mouse.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 需要被针对的项目是用户用鼠标点击的项目。
- en: 'We, therefore, need to identify the item on which mouse has been clicked before
    we can do any modification to the item itself. To do that, we modify our `mouse_down`
    method as follows (see *code 6.05.py*):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们对项目本身进行任何修改之前，我们需要先识别鼠标点击的项目。为此，我们修改了我们的 `mouse_down` 方法，如下所示（见 *code
    6.05.py*）：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The description of the code is listed as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This small modification to the `mouse_down` method means that if any of the
    last four buttons are clicked, the code locates the item located closest to the
    click position and assigns it to our newly defined attribute, `selected_object`,
    which stands for the current selected object.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个对 `mouse_down` 方法的微小修改意味着，如果点击了最后四个按钮中的任何一个，代码会定位到点击位置最近的项目，并将其分配给我们的新定义属性
    `selected_object`，代表当前选中的对象。
- en: If there are no items on the canvas, the entire canvas is set to the `selected_obj``ect`
    attribute.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果画布上没有项目，整个画布被设置为 `selected_obj``ect` 属性。
- en: Note
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The canvas method has a method named: `find_closest(x, y, halo=None, start=None)`.'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 画布方法有一个名为：`find_closest(x, y, halo=None, start=None)` 的方法。
- en: It returns the identifier for item closest to the given position on the canvas.
    This means that if there is only one item on the canvas, it will be selected regardless
    of how near or how far you click from it.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回画布上给定位置最近项目的标识符。这意味着，如果画布上只有一个项目，无论你点击得有多近或多远，它都会被选中。
- en: If on the other hand, you want that objects only within a certain distance are
    selected, the Canvas widget provides an alternate implementation named `find_overlapping`.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果另一方面，你只想选择一定距离内的对象，Canvas小部件提供了一个名为 `find_overlapping` 的替代实现。
- en: You will, however, have to place a small rectangle centered on the position
    to use this.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，你必须放置一个位于该位置中心的小矩形才能使用这个功能。
- en: Now that we have a hold on the item to be manipulated, we can proceed to do
    whatever we want to do with the item.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了要操作的项目，我们可以继续进行我们想要对项目做的任何操作。
- en: Step 3 – deleting items from the canvas
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 从画布中删除项目
- en: 'The first method to delete items from canvas is `delete_object`, which simply
    deletes the selected item. So our `delete_object` method is defined as follows
    (see *code 6.05.py*):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从画布中删除项目的第一个方法是 `delete_object`，它简单地删除所选项目。因此，我们的 `delete_object` 方法定义如下（见 *code
    6.05.py*）：
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, because our earlier code needed that for every method for which we define
    an options method, we define the method, `delete_object_options`, here. However,
    because we do not want to display anything in the option bar at the top, we simply
    ignore it with a pass statement, as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们的早期代码需要为每个我们定义选项方法的函数，所以我们在这里定义了 `delete_object_options` 方法。然而，因为我们不想在顶部的选项栏中显示任何内容，所以我们简单地使用
    pass 语句忽略它，如下所示：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Step 4 – paint bucket feature
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 画桶功能
- en: Next, we code our `fill_object` method, which acts somewhat like a paint bucket
    in common drawing programs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写 `fill_object` 方法，它在常规绘图程序中类似于画桶。
- en: 'This again is simple. You simply need to fill the color on the background of
    the selected item. If there is no item on the canvas, it simply fills the color
    on to the entire canvas, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样很简单。你只需要在所选项目的背景上填充颜色。如果没有项目在画布上，它将简单地填充整个画布，如下所示：
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And here, we want to let the user choose the fill color for the paint bucket.
    Hence, we call our previously defined method, `fill_options_combobox`, from within
    our `fill_object_options` method.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，我们希望让用户选择画桶的填充颜色。因此，我们在 `fill_object_options` 方法中调用我们之前定义的方法 `fill_options_combobox`。
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Step 5 – moving items on top of each other
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 将项目移动到彼此之上
- en: Let's now define the methods for the next button. The button marked with a small
    hand icon can be used to raise items on top of others.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义下一个按钮的方法。带有小手图标标记的按钮可以用来将项目置于其他项目之上。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you draw multiple items on the canvas, the items are placed in a stack.
    By default, new items get added on top of items previously drawn on the canvas.
    You can, however, change the stacking order using: `canvas.tag_raise(item)`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在画布上绘制多个项目时，项目会被放置在一个堆栈中。默认情况下，新项目会被添加到之前绘制在画布上的项目之上。然而，你可以使用：`canvas.tag_raise(item)`
    来改变堆叠顺序。
- en: If multiple items match, they are all moved, with their relative order preserved.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个项目匹配，它们都会移动，同时保持它们的相对顺序。
- en: However, this method will not change the stacking order for any new window item
    that you draw within the canvas.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此方法不会更改画布内绘制的任何新窗口项目的堆叠顺序。
- en: Then there are `find_above` and `find_below` methods that you can use to find
    items above or below an item in the canvas stacking order.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有`find_above`和`find_below`方法，你可以使用它们在画布堆叠顺序中查找位于项目上方或下方的项目。
- en: In addition, there is a `find_all` method that returns a tuple containing identifiers
    for all items on the canvas.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`find_all`方法，它返回一个包含画布上所有项目标识符的元组。
- en: 'Accordingly, the code for moving items to the top of stack is as follows (see
    *code 6.05.py*):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将项目移动到堆叠顶部的代码如下（见*code 6.05.py*）：
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Step 6 – dragging items on the canvas
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 在画布上拖动项目
- en: Finally, let's add drag-and-drop feature for items on the canvas. The ability
    to drag an item on the canvas requires that after selection of the object to be
    dragged, we recalculate the x and y coordinates for mouse movement, and move the
    object to the new coordinates provided by the mouse movement at small intervals.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为画布上的项目添加拖放功能。在画布上拖动一个项目的能力要求在选择了要拖动的对象之后，我们重新计算鼠标移动的x和y坐标，并在小间隔内将对象移动到鼠标移动提供的新坐标。
- en: In many ways the concept here is similar to one that we used for defining our
    paint brush.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这里的理念与我们用来定义画笔的概念相似。
- en: The idea is to call our `drag_items` method after every small mouse movement
    using another method, `drag_item_update_xy`, which recalculates x and y coordinates
    after small mouse motion, moving the item to the newly calculated coordinates
    every time.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在每次小鼠标移动后使用另一个方法`drag_item_update_xy`调用我们的`drag_items`方法，该方法在小鼠标移动后重新计算x和y坐标，每次移动项目到新计算的坐标。
- en: 'Then, we have a condition check, which breaks out of this loop if any other
    button is selected from the toolbar, as follows (see *code 6.05.py*):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个条件检查，如果从工具栏中选择其他按钮，则跳出此循环，如下所示（见*code 6.05.py*）：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Canvas widget provides a method: `canvas.move(item, dx, dy)`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件提供了一个方法：`canvas.move(item, dx, dy)`。
- en: The preceding method moves any matching item by a horizontal and vertical offset
    (`dx` and `dy`).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法通过水平和垂直偏移（`dx`和`dy`）移动任何匹配的项目。
- en: Objective Complete – Mini Debriefing
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: 'This brings us to the end of this iteration. We have now successfully added
    four new features to our drawing program, namely: `delete_object`, `fill_object`,
    `move_to_top`, and `drag_item`.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这一迭代。现在我们已经成功地为我们的绘图程序添加了四个新功能，即：`delete_object`、`fill_object`、`move_to_top`和`drag_item`。
- en: In the process, we saw some of the methods provided by the Canvas widget for
    item manipulation. We also saw the strategy that one might adopt when working
    on existing items on the Canvas widget.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们看到了Canvas小部件提供的用于项目操作的一些方法。我们还看到了在Canvas小部件上处理现有项目时可能采用的战略。
- en: Classified Intel
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: In this program, we extensively used the item identifier ID to target a particular
    item on the canvas. Recall that item identifier is the unique integer ID returned
    by the canvas method that creates the object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们广泛使用了项目标识符ID来定位画布上的特定项目。回想一下，项目标识符是创建对象时由Canvas方法返回的唯一整数ID。
- en: 'So, for instance, when you create an oval item on your canvas, it returns an
    integer ID after creating the object. This is referred to its item identifier
    or the item handle, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你创建画布上的椭圆项目时，创建对象后会返回一个整数ID。这被称为项目标识符或项目句柄，如下所示：
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now you can act upon this oval using the handle, my_item_identifier.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用句柄my_item_identifier对这个椭圆进行操作。
- en: However, this is not the only method by which you can identify an item on the
    canvas. Additionally, you can add tags to items, and then use these tags to identify
    the object for manipulation.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一可以识别画布上项目的方法。此外，你可以给项目添加标签，然后使用这些标签来识别用于操作的对象。
- en: Working with item tags
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理项目标签
- en: Let's now look at some of the common operations involved in working with Canvas
    tags.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看在处理Canvas标签时涉及的一些常见操作。
- en: Adding a tag
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加标签
- en: 'To add a tag to an item, you specify the tag (which is a string) as its configurable
    option either at the time of creating the object or later using the `itemconfig`
    method, or add them using the `addtag_withtag` method, as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个项目添加标签，你可以在创建对象时或之后使用`itemconfig`方法指定标签（这是一个字符串）作为其配置选项，或者使用`addtag_withtag`方法添加它们，如下所示：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The same tag can be applied to more than one item on the canvas.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个标签可以应用于画布上的多个项目。
- en: 'You can add multiple tags to an item together by passing in the tags as a tuple
    of strings, as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递标签作为字符串元组来一起给一个项目添加多个标签，如下所示：
- en: '[PRE46]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tip
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using tags to identify items to be manipulated is especially useful when you
    need to manipulate more than one item at one time, or if you want to manipulate
    items based on certain conditionals.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签来识别要操作的项目特别有用，当你需要同时操作多个项目，或者你想根据某些条件操作项目时。
- en: Retrieving tags
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取标签
- en: 'To get all tags associated with a specific item handle, use `gettags` as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与特定项目句柄相关联的所有标签，请使用以下`gettags`：
- en: '[PRE47]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This returns a tuple of all tags associated with that item handle, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回与该项目句柄相关联的所有标签的元组，如下所示：
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Getting items with a given tag
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取具有特定标签的项目
- en: 'To get the item handles for all items having a given tag, use `find_withtag`
    as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有具有给定标签的项目句柄，请使用以下`find_withtag`：
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This returns the item handles for all items as a tuple.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有项目的项目句柄作为元组。
- en: Built-in tags
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置标签
- en: 'The canvas widget provides two built-in tags:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 画布小部件提供了两个内置标签：
- en: 'ALL or all: It matches all items on the canvas'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALL或all：匹配画布上的所有项目
- en: 'CURRENT or current: It returns the item under the mouse pointer, if any'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CURRENT或current：如果有，则返回鼠标指针下的项目
- en: Mission Accomplished
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: There you have your own drawing program! You can easily extend it to add many
    more features.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就有了自己的绘图程序！你可以轻松扩展它以添加更多功能。
- en: 'Here''s a quick summary of things we have seen in this project:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本项目所见内容的快速总结：
- en: Building custom GUI frameworks for rapid application development
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于快速应用开发的自定义GUI框架
- en: Understanding how to use inheritance in our projects
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在我们的项目中使用继承
- en: Getting to know the `tkColoChooser` module
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`tkColoChooser`模块
- en: Learning to create and manipulate items on the Canvas widget
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在画布小部件上创建和操作项目
- en: Working with the tk ComboBox widget
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与tk ComboBox小部件一起工作
- en: Getting to know the available `winfo` methods
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的`winfo`方法
- en: Working with mouse events on the Canvas widget
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布小部件上处理鼠标事件
- en: Reinforcing things that we have learned in previous projects
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巩固我们在以前项目中学习到的内容
- en: A Hotshot Challenge
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热身挑战
- en: 'Add the following features to your drawing program:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下功能添加到你的绘图程序中：
- en: The accelerator keys don't work for our menu items because we have not bound
    them to key events. Bind the menu-item accelerator keys to their associated command
    callback.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速键对我们的菜单项不起作用，因为我们尚未将它们绑定到键事件。将菜单项的加速键绑定到它们相关的命令回调。
- en: Create an Eraser button and add its associated features.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个橡皮擦按钮并添加其相关功能。
- en: We have not implemented drawing of some other basic shapes, such as arc and
    polygons, even though the Canvas widget provides for methods to draw them. Add
    the ability to draw arcs and polygons to the drawing program.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们尚未实现绘制一些其他基本形状，例如弧和多边形，尽管画布小部件提供了绘制它们的方法。将绘制弧和多边形的能力添加到绘图程序中。
- en: Create a new toolbar on the right side. Utilizing the stacking order for canvas
    items, display each item as a separate layer in the toolbar.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧创建一个新的工具栏。利用画布项的堆叠顺序，将每个项目作为工具栏中的单独一层显示。
- en: Go through all the available Canvas widget options in your IDE by using Python's
    interactive help feature. Try adding more features to the program utilizing one
    or more of the options.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Python的交互式帮助功能遍历你IDE中所有可用的画布小部件选项。尝试通过利用一个或多个选项来添加更多功能到程序中。
- en: We have already included the ability to add images to our program by navigating
    to **File** | **Open**. Add a few menu items to manipulate those images. Using
    some imaging library, add image manipulation features, such as color adjustment,
    brightness, contrast, grayscale, and other facilities for image manipulation provided
    by the imaging library that you choose to use.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经通过导航到**文件** | **打开**来包含了将图像添加到程序中的能力。添加一些菜单项来操作这些图像。使用某些图像库，添加图像处理功能，例如颜色调整、亮度、对比度、灰度以及其他由你选择的图像库提供的图像处理功能。
- en: The Canvas widget is often used to draw custom widgets. Make a Progress Meter
    widget using the Canvas widget. Attach it to some function and run it to see that
    the oval should get filled with some color as the function progresses. You can
    use the fill option of the Canvas widget to show increase in progress.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布小部件通常用于绘制自定义小部件。使用画布小部件制作一个进度条小部件。将其附加到某个函数上并运行，以查看随着函数的进行，椭圆形应该被某种颜色填充。你可以使用画布小部件的填充选项来显示进度增加。
