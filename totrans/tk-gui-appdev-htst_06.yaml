- en: Chapter 6. Drawing an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now on to developing our last major Tkinter application. In this project,
    we will develop a drawing application, making extensive use of the Tkinter Canvas
    widget while applying everything else that we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our drawing program will enable the user to draw basic shapes such as lines,
    circles, rectangles, and polygons. It will also let the user draw with the brush
    tool using different colors that can be chosen from the color palette.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its final form, our drawing program will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the application itself is rudimentary, it is sufficient to demonstrate
    some important aspects related to GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: This project aims to drive home two important lessons. First, we will experience
    the power of the Canvas widget. Second, we will learn how to develop higher-level
    custom GUI frameworks for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we shall see, custom GUI frameworks enable us to develop programs rapidly
    with minimal amount of code repetition.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this project, you should not only be in a position to extend this
    application to add many more features, but you should also be able to take up
    and implement GUI projects of increasing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key learning objectives for this project can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to build custom GUI frameworks for rapid application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing small unit tests for our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use inheritance in our projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know of other Tkinter modules, such as `tkColorChooser`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and manipulating items on the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the tk ComboBox widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the available `winfo` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with mouse events on the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinforcing things that we have learned in previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission Checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have developed the game of chess, you might have installed the **Python
    Imaging Library** (**PIL**) to render PNG files. This is the only external dependency
    for our program. If you haven''t already done so, download and install PIL from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working on windows x64 (64 bit) or MacOSX machine, you may instead
    need to install and work with Pillow, which is a replacement for PIL available
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed the package, go to your Python interactive prompt
    and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>from PIL import ImageTk`'
  prefs: []
  type: TYPE_NORMAL
- en: If this executes without any error messages, you are ready to make our drawing
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a bare bone GUI framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important lessons aimed in this project is to learn to develop
    custom GUI frameworks. Tkinter in itself is a GUI framework. However, the kind
    of framework we intend to build here is a higher-level framework, built on top
    of Tkinter to suit our custom programming needs.
  prefs: []
  type: TYPE_NORMAL
- en: We will not develop a full-blown framework. Rather, we will develop only a small
    segment of it to give you a flavor of building a custom framework.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So why do we need another framework on top of Tkinter?
  prefs: []
  type: TYPE_NORMAL
- en: Consider a large program which has say 10 different menus, each menu having
    say 10 menu items. We will have to then write 100 lines of code simply to display
    these 100 menu items.
  prefs: []
  type: TYPE_NORMAL
- en: You not only need to make each widget by hand, but also have to link each of
    them manually to other commands besides having to set tons of options for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: If we keep doing this for all our widgets, our GUI programming becomes an exercise
    in typing. Every extra line of code that you write adds to the program complexity,
    in a sense that it becomes more difficult for someone else to read, maintain,
    modify, and/or debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: This is where developing a custom framework comes to our aid. Let's see what
    it means.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we anticipate that our drawing program will have a large number
    of menu items. Now we know how to add menu and menu items. Each new menu item
    would take at least one line of code to display.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid writing so many lines of code, let's first make a framework to address
    this.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the process of menu creation, we will write a piece of code that takes
    menu items listed as a tuple, and converts it to an equivalent menu code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So given a tuple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: should produce the corresponding menu items, where the first item of the string
    (before dash (`-`)) represents the menu button, and each subsequent part of string
    separated by commas represents one menu item, its accelerator key, and the attached
    command callback. The position of ampersand symbol (`&`) represents the position
    of the shortcut key to be underlined.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to take care of adding separators between our menu items. To add
    a separator, we would add the string `Sep` at positions where it is required.
    More precisely, the string `Sep` must be capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, passing this tuple through our method should produce a GUI, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To extend our menu items, all we would need to do is to extend the preceding
    tuple and simultaneously adding the corresponding command callback method.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the GUI framework class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We build our framework in a file named `framework.py`, where we define a new
    class named `GUIFramework` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – creating menu builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The two methods of `GUIFramework` that are used to create menu builder are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method, `build_menu`, operates on a tuple by the name `self.menubar`, which
    must specify all desired menu and menu items in the exact format, as previously
    discussed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It iterates through each item in the tuple, splitting the item based on `-`delimiter,
    building the top-menu button for each item left to the `-` delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then splits the second part of the string based on `,`(comma) delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through this second part, creating menu items for each of the
    parts, adding the accelerator key, command callback, and underline key using another
    method, `__add_menu_command`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__add_menu_command` method iterates through the string and adds a separator
    if it finds the string `Sep`. If not, it next searches for ampersand (`&`) in
    the string. If it finds one, it calculates its index position and assigns it to
    the underline variable. It then replaces ampersand value with an empty string,
    because we do not want to display the ampersand in our menu item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If ampersand is not found in a string, the code assigns `None` to the underline
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the code adds command callback, accelerator key, and underline value
    to the menu item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The logic that we used to define the menu builder is a completely arbitrary
    representation. We could have as well used a dictionary or a list. We could also
    have a separate logic altogether to represent our menu items, as long as it served
    the purpose of generating the menu items for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step 3 – testing our new framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we add a `TestThisFramework` class to our file to test if our framework
    in general and our `build_menu` method in particular, works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `TestThisFramework` class is as follows(*framework.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `TestThisFramework` class inherits from the `GUIFramework` class, thus being
    in a position to use the `build_menu` method defined in the parent class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then adds a list of menu items, `menuitems`, and calls the method, `build_menu()`.
    It is important that the tuple be defined by the name, `menuitems`, because our
    `build_menu()` method is structured in the parent `GUIFramework` class to build
    menu only on the tuples named `menuitems`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test class also adds dummy commands to handle command callbacks for each
    of the menu items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running this test builds menu items as specified in the tuple. Try extending
    the tuple to add more menu items, and the framework will successfully include
    those items in the menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Like we added code to generate menus for us, we could have added similar code
    for other widgets that we foresee to be repeatedly used in our program. But we
    will leave the framework development there itself and proceed to developing our
    drawing application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing a framework for smaller programs may be overkill, but they are invaluable
    assets for longer programs. Hopefully, you should now be able to appreciate the
    benefits of writing your own custom frameworks for larger programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our `build_menu` ready, we can extend it to add as many menu
    items as required without having to write repetitive and similar code for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: This ends our first iteration, where we laid the foundations for our custom
    GUI framework. We will not extend the framework further, but hopefully, you should
    now be in a position to extend it for other widgets, if required.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you also saw how our `TestThisFramework` class inherited features
    from our `GUIFramework` class. This is the first time we have used inheritance
    in our program.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have always passed objects created as classes as arguments to other
    classes, and then used them using the`.`(dot) notation. This is named **composition**
    .
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, we do not need to access methods of another class using the
    dot notation. We can use the methods of a superclass in the subclass as though
    they belong to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance brings in the advantage of dynamic binding and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic binding means the method to be invoked is decided at runtime, thus providing
    greater flexibility to design of our code. Polymorphism implies that variables
    of a superclass hold a reference to an object created from itself or from any
    of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is fit for situations where the object of the subclass is of the
    same type as the superclass. In our example, menu items will remain the same whether
    you define them from the superclass or from the subclass. We, therefore, defined
    it in our superclass and inherited it in our subclass.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the object needs to appear or behave differently depending on an
    object's condition or state, composition is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our drawing program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now get down to setting the basic structure for our drawing program.
    We want to achieve a structure, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring our drawing program](img/7941_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The structure here primarily consists of a top menu, which inherits from the
    GUI framework `build_menu` method that we created in the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we create a top-bar frame towards the top(marked in yellow) with
    a method, `create_top_bar()`, and a toolbar frame to the left (marked with dark
    grey background) with `create_tool_bar()`. We also create a Canvas widget on the
    right side using the `create_drawing_canvas()` method, which is to serve as our
    drawing area.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be reproducing the code for making the frames and canvas area, because
    we have done similar things in our previous projects and you should be comfortable
    making them by now. However, you can check the actual code in the file, *6.01.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – importing framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing to note here is that we import our previously created framework
    module here and inherit its property in our main class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to use the `build_menu` method that we had defined in the framework
    as though it belongs to the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: building the top menu'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we define the actual menu items to build the top menu in a method defined
    `create_menu`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This actually creates three menu buttons: **File**, **Edit**, and **About**,
    adding menu items to each of them as per preceding provided tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the menu also necessitates the creation of their associated command
    callbacks again, as defined in the preceding tuple. Accordingly, we create the
    methods associated with these command callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not reproduce the code for functionalities, such as `new_file`, `open_file`,
    `close`, `undo`, and `about`, because we have done similar coding in our previous
    projects. However, let's take a look at the undo and save operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – undo operation on the Canvas widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that the Tkinter text widget has built-in support for unlimited undo/redo
    functionality. The Canvas widget, however, does not have this built-in feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we implement a very basic undo operation, which lets us delete the last
    drawn item on the canvas as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget provides a `widget.delete(items)` method that deletes a given
    item from the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: However, once you delete a canvas item, it is gone forever. You cannot restore
    it unless you have implemented a method which stores all the configurable options
    for that item before deleting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While it is possible to implement fully-featured undo/redo operation by storing
    all configurations for an item being deleted in an undo stack, we will not implement
    it here, because it would be a deviation from our core topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step 4 – saving canvas objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tkinter lets you save canvas objects as a postscript file using the command
    `postscript()`, as follows (see *code 6.01.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that this command does not include the images and embedded widgets
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – creating buttons in the left tool bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having coded command callbacks for all our menu items, let''s now create buttons
    on the left toolbar. As per our original plan, we will need eight buttons on the
    toolbar. For now, let''s show the button text as `0` through `7` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This creates eight buttons, arranging them in two columns depending on whether
    the button number is odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – adding command callback to buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All buttons are attached to the same command callback, `selected_tool_bar_item`,
    which takes the button number as its argument. The callback method will be taken
    forward in the next iteration. However, for now, let''s simply define the callback
    to print the number of the button that is clicked on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 – creating color palettes and color selection dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly, let's create two color palettes to keep track of two colors named background
    and foreground color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tkinter provides a `tkColorChooser` module that pops up a color chooser dialog.
    When a user selects a color and clicks the **OK** button, the module returns a
    tuple of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first element of the returned tuple is itself a tuple specifying the RGB
    coordinates for the given color, while the second element is the hexadecimal color
    code for the selected color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is that clicking on a palette should open a color chooser. When
    a user selects a given color, it should update the foreground and background color
    attributes of the object, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 7 – creating color palettes and color selection dialog](img/7941_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to achieve this functionality is as follows(see *code 6.01.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add two different tags to each of the square pieces, and then use the `tag_bind`
    command to bind them to the click of mouse button over them. Take a note of the
    difference between widget-level binding(`widget.bind`) and the item-specific binding
    using the `tag_bind` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create the color palettes, we first create a Canvas widget within the toolbar
    frame. Within this canvas, we create two square areas using `canvas.create_rectangle`
    and bind them to a single mouse click event to call `set_background_color` and
    `set_foreground_color` respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 8 – setting color of background and foreground palette
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Color of the background and foreground palette can be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Step 9 – displaying x and y coordinates of mouse movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we add a static label to our toolbar frame to track the x and y coordinates
    of mouse movement. The actual tracking function will be created later but let''s
    reserve the space by putting a static label for now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our second iteration. In this iteration, we set the basic structure
    for our drawing program.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, we saw how to inherit features from our previously created framework
    to create menu items with minimal coding.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the color selection dialog using the `tkColorChooser` module,
    which sets in two attributes, `self.background` and `self.foreground`, to be used
    application-wide.
  prefs: []
  type: TYPE_NORMAL
- en: Handling mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we let the user draw on the canvas, we need to bind the canvas event
    to mouse movements and mouse click.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing or adding any item on to the Canvas widget first requires that we know
    the coordinates of the location where the item is to be placed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Canvas widget uses two coordinate systems to track positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Window coordinate system**: Coordinate as expressed in relation to root window'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas coordinate system**: Coordinate as expressed as position of item within
    the canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert from window coordinates to canvas coordinates using the `canvasx`
    and `canvasy` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – binding mouse down, mouse motion, and mouse release over the canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing any item on the canvas would begin when the user clicks the mouse button.
    The drawing needs to continue till the mouse is moved with the button pressed
    and up to the time the mouse button is released.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we need to track the position of initial mouse down event. This is to
    be followed by tracking the mouse movement while the button is clicked on, up
    to the final button release event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we add the following widget binding to our canvas (see *code 6.02.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – calculating coordinates of mouse movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having bound the mouse click, mouse movement, and mouse release events, it's
    now time to define their corresponding callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we want the `mouse_down` method to give us the x and y coordinates
    for the first mouse click event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to keep updating the `lastx` and `lasty` coordinates up till the mouse
    stops moving, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `mouse_up` method should make the final update to our `lastx` and `lasty`
    coordinates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mouse_down` method simply initializes the values of `startx`, `starty`,
    `lastx`, and `lasty` to the coordinates of the mouse click position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mouse_down_motion` method changes the value of `lastx` and `lasty` as the
    mouse motion keeps happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `mouse_up` method sets the value of `lastx` and `lasty` as coordinates
    of the point where the mouse button is released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, using the three events: `mouse_down`, `mouse_down_motion`, and `mouse_up`,
    we manage to get the coordinates for starting point, coordinates for points through
    which the mouse pointer traverses, and the coordinates for the end point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can use these values to place any item on the canvas at the given coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – updating the current mouse position label in the left tool bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition, we would also like to track the motion of the mouse over the canvas,
    even when the mouse button is not clicked down. We need to track this to update
    the current mouse position in the left toolbar. This is simple, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code will ensure that any mouse movement over the canvas updates the label
    in the left toolbar with the current position of mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now our Canvas widget has become responsive to mouse movements and mouse clicks.
    Every time we click the mouse button over the canvas and drag the mouse pointer
    to a new place, the values of `startx`, `starty`, `lastx` and `lasty` get updated
    to reflect the coordinates for the mouse movement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Together, these coordinates constitute what is called the bounding box for
    an item. In fact, if there are items on a canvas, you can retrieve the coordinates
    for any given item using the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This returns the coordinates as a four-item tuple.
  prefs: []
  type: TYPE_NORMAL
- en: If the item name is not specified, this method returns the bounding box for
    all elements on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the coordinates available, we can think of drawing items on
    the canvas. We do some drawing in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing items on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now draw some items on the canvas. The Canvas widget natively supports
    drawing the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Item | Code for adding the item |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arc | `w.create_arc( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Bitmap | `w.create_bitmap( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Image | `w.create_image( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Line | `w.create_line( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Oval | `w.create_oval( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Polygon | `w.create_ploygon( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Rectangle | `w.create_rectangle( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Text | `w.create_text( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: '| Window | `w.create_window( bbox, **options)` |'
  prefs: []
  type: TYPE_TB
- en: 'Let us add the ability to draw lines, rectangles, and ovals to our drawing
    program. We will also add a brush stroke feature to our program, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing items on the canvas](img/7941_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating a tuple of methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first create a tuple of methods that we intend to define here as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so ensures that we do not have to call each method explicitly from our
    code. We can instead use the index of the tuple to retrieve the method name and
    call it dynamically using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense here, because we would eventually add more features to our
    drawing program by simply extending our `all_toolbar_functions`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – add icons to our toolbar buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next task here is to add icons on the left toolbar for drawing these items.
  prefs: []
  type: TYPE_NORMAL
- en: We add the icons to our `icons` folder. We also ensure to rename each icon file
    to the name of the method called by it. This naming again helps in calling the
    methods dynamically, and this style of programming is what you could call programming
    using **conventions over configuration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current `create_tool_bar_buttons()`method creates eight buttons using a
    for loop. However, we will now modify our `create_tool_bar_buttons()`method to
    use the `enumerate()` method to loop overall items in our `all_toolbar_functions`
    tuple to add icons for each of the methods, as follows (see *code 6.03.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – keeping a tab on currently selected button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we modify the method, `selected_tool_bar_item(i)`; the only purpose of
    which is to keep a tab on the currently selected button. Having this information,
    we can later call the associated method from `all_toolbar_functions` by using
    this index, as follows (see *code 6.03.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – code for drawing line, rectangle, and oval shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now is the time to code the methods to draw these basic shapes. Note that this
    will not automatically create the drawings. Eventually, these methods will have
    to be called from somewhere to actually make the drawings. We will do that in
    step 6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – code for drawing in continuous stroke
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing in a continuous stroke is similar to drawing lines, but the fresh lines
    are redrawn after every small change in coordinates. In the current state of things,
    the value of `lastx` and `lasty` are only updated when the mouse button is released.
    But here we need to update the value of `lastx` and `lasty`, not on mouse release,
    but on mouse motion. To achieve this, we bind the mouse motion to a newly defined
    method `draw_brush_update_xy`, which updates the x and y coordinate in every subsequent
    loop turn.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we had bound mouse down motion to another method named `mouse_down_motion`.
    For drawing continuous stroke, we will now bind it to a method named `draw_brush_update_xy`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an event binding to more than one method wipes away the previous binding,
    whereby the new binding replaces any existing binding. Thus, when you exit out
    of the `draw_brush` loop, you need to rebind the event back to the `mouse_down_motion`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `add="+"` as an additional argument to keep more
    than one binding to the same event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we create a loop where the `draw_brush` method calls another method,
    `draw_brush_update_xy`, on successive mouse motions to update the x and y coordinates
    as follows (see *code 6.03.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the Draw Brush button is unselected, we break out of the loop and rebind
    the mouse motion back to the canvas `mouse_down_motion`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – executing code dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have planned to execute methods dynamically, based on index from the names
    of methods given in a tuple named `all_toolbar_functions`. However, the names
    are stored as strings, and we just cannot take a piece of string and expect Python
    to evaluate it. In order to that, we will use Python's built-in `getattr()`method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define a method that takes a string and makes it suitable for execution
    as a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 – doing the actual drawing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having defined methods to draw line, rectangle, oval, and brush strokes, we
    need to call them from somewhere for the drawing to happen. Intuitively, the drawings
    must begin on the first mouse down movement and the drawing must be deleted and
    redrawn up till the mouse button release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, these methods must be called from our `mouse_down_motion` method.
    We, therefore, modify our `mouse_down_motion` and `mouse_up` methods to do this,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our objective for the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: We began by creating a tuple of method names so as to be able to call a method
    dynamically by specifying its index in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: We then added icons for our toolbar buttons. We then associated a button click
    to a method that keeps tab on currently selected button by assigning its index
    to the variable, `self.selected_toolbar_func_index`. We then defined methods to
    draw line, rectangle, and oval shapes on our canvas. We also showed how to utilize
    the ability to draw lines to draw in continuous strokes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we called all the draw methods from `mouse_down_motion` and `mouse_release`
    method to do the actual drawing.
  prefs: []
  type: TYPE_NORMAL
- en: A user can now draw basic shapes, such as lines, rectangles, ovals, and brush
    strokes on to the canvas. The shapes are drawn in the currently set foreground
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the options toolbar at the top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although our program can draw basic shapes, these shapes are currently filled
    with the foreground color and the outline of the shape is done in black.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget lets you specify the fill color, outline color, and border
    width for most of the shapes as its configurable options.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, the Canvas widget also has several other configurable
    options for many of these basic shapes. For instance, for a line, you can specify
    if it will have an arrow head shape at the end or if it will be dashed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s accordingly modify our program to allow the user to select configurable
    options for each of the four basic shapes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the options toolbar at the top](img/7941_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – showing the selected button icon at the top
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with a simple thing first. When a user clicks on a button in the
    left toolbar, the top frame should display the text **Selected Tool:** followed
    by the icon representation for the selected button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this event must occur on click of any button, we modify our `selected_tool_bar_item`
    method to include a call to two methods, as highlighted in the following code
    (see *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `remove_options_from_topbar` method ensures that when a new button is clicked,
    options for the previous button are deleted. The `show_selected_tool_icon_in_topbar`
    method actually displays the icon for the currently selected button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`widget.winfo_children()` returns a list of all children for a given widget,
    in their stacking order from bottom to top.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can extract a lot of window-related information using one of the many `winfo`
    methods. For a complete list of the `winfo` methods, refer to the *The basic widget
    methods* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, each widget has also its own children attribute, which is a dictionary
    where the keys are the IDs and the values are the widgets. So if the order is
    not relevant, this is the same as `widget.children.values()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step 2 – adding the Combobox widget to let user select different fill options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to define the selection combobox for a user to select options
    for fill, outline, width, arrow, and dash. We will use ttk Combobox to allow the
    user to make a selection, and as such, we import it into our current file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not reproduce the entire code here. However, for each of the preceding
    options, we define two methods: one that displays the combobox and the other sets
    the value of the current selection made by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we set the following two definitions for fill option, as follows (see
    *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We similarly define other pair of methods for each of the sets, namely (see
    *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`outline_options_combobox:set_outline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width_options_combobox:set_width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrow_options_combobox:set_arrow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dash_options_combobox:set_dash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – modifying draw methods to add configurable options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have ways to set different values for fill, outline, arrow, and
    dash configurable options, let''s modify our drawing code to include these in
    the actual drawing, as follows (see *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Having defined all these methods, it is now time to call them from somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the fill combobox would be applicable to all the four basic shapes, the
    arrow option would only be applicable to drawing lines. Because there will be
    a different set of comboboxes for different selections, we define the following
    methods (see *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, these methods have to be called from somewhere, depending on the selection
    made. So we modify our `selected_tool_bar_item` method to call a method dynamically,
    named by appending the string `_options` to the name of selected method as follows
    (see *code 6.04.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program user can now select from the various options provided for each of
    the toolbar buttons (see *code 6.04.py*).
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we saw some of the configuration options available for items
    drawn on the Tkinter Canvas widget. We were also introduced to the `winfo` methods.
    These methods can be used to extract a lot of data about a widget and are a useful
    tool to have when programming a GUI application in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some more features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next in line, let''s add a few more features to our drawing program. In particular,
    we will add the ability to delete objects from the canvas, add a paint bucket,
    the ability to move items up and down the stack, and the ability to drag items
    on the canvas, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some more features](img/7941_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – extending our methods tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a first thing, let us extend our `all_toolbar_functions` method to make
    provisions for the new methods that we will define here, as follows (see *code
    6.05.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we have added icons to the `icon` folder by the same name as the method
    that would handle it. The buttons are automatically displayed in our left toolbar
    merely by adding new methods to this tuple and by adding corresponding icons to
    our `icon` folder because of the way we have designed the `create_tool_bar_buttons`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – targeting a given item on the canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before define the methods for handling the new features, let's pause and think
    about the kind of work we need to do here.
  prefs: []
  type: TYPE_NORMAL
- en: The operations that we want to do now are slightly different from their predecessors.
    Earlier, we were creating items on the canvas. Now we have to target items already
    present on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The items that need to be targeted are the ones on which the user clicks on
    with his or her mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, need to identify the item on which mouse has been clicked before
    we can do any modification to the item itself. To do that, we modify our `mouse_down`
    method as follows (see *code 6.05.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This small modification to the `mouse_down` method means that if any of the
    last four buttons are clicked, the code locates the item located closest to the
    click position and assigns it to our newly defined attribute, `selected_object`,
    which stands for the current selected object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no items on the canvas, the entire canvas is set to the `selected_obj``ect`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The canvas method has a method named: `find_closest(x, y, halo=None, start=None)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It returns the identifier for item closest to the given position on the canvas.
    This means that if there is only one item on the canvas, it will be selected regardless
    of how near or how far you click from it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If on the other hand, you want that objects only within a certain distance are
    selected, the Canvas widget provides an alternate implementation named `find_overlapping`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will, however, have to place a small rectangle centered on the position
    to use this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a hold on the item to be manipulated, we can proceed to do
    whatever we want to do with the item.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deleting items from the canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method to delete items from canvas is `delete_object`, which simply
    deletes the selected item. So our `delete_object` method is defined as follows
    (see *code 6.05.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And, because our earlier code needed that for every method for which we define
    an options method, we define the method, `delete_object_options`, here. However,
    because we do not want to display anything in the option bar at the top, we simply
    ignore it with a pass statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – paint bucket feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we code our `fill_object` method, which acts somewhat like a paint bucket
    in common drawing programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This again is simple. You simply need to fill the color on the background of
    the selected item. If there is no item on the canvas, it simply fills the color
    on to the entire canvas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And here, we want to let the user choose the fill color for the paint bucket.
    Hence, we call our previously defined method, `fill_options_combobox`, from within
    our `fill_object_options` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – moving items on top of each other
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now define the methods for the next button. The button marked with a small
    hand icon can be used to raise items on top of others.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you draw multiple items on the canvas, the items are placed in a stack.
    By default, new items get added on top of items previously drawn on the canvas.
    You can, however, change the stacking order using: `canvas.tag_raise(item)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If multiple items match, they are all moved, with their relative order preserved.
  prefs: []
  type: TYPE_NORMAL
- en: However, this method will not change the stacking order for any new window item
    that you draw within the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are `find_above` and `find_below` methods that you can use to find
    items above or below an item in the canvas stacking order.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there is a `find_all` method that returns a tuple containing identifiers
    for all items on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code for moving items to the top of stack is as follows (see
    *code 6.05.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Step 6 – dragging items on the canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's add drag-and-drop feature for items on the canvas. The ability
    to drag an item on the canvas requires that after selection of the object to be
    dragged, we recalculate the x and y coordinates for mouse movement, and move the
    object to the new coordinates provided by the mouse movement at small intervals.
  prefs: []
  type: TYPE_NORMAL
- en: In many ways the concept here is similar to one that we used for defining our
    paint brush.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to call our `drag_items` method after every small mouse movement
    using another method, `drag_item_update_xy`, which recalculates x and y coordinates
    after small mouse motion, moving the item to the newly calculated coordinates
    every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a condition check, which breaks out of this loop if any other
    button is selected from the toolbar, as follows (see *code 6.05.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Canvas widget provides a method: `canvas.move(item, dx, dy)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method moves any matching item by a horizontal and vertical offset
    (`dx` and `dy`).
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This brings us to the end of this iteration. We have now successfully added
    four new features to our drawing program, namely: `delete_object`, `fill_object`,
    `move_to_top`, and `drag_item`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we saw some of the methods provided by the Canvas widget for
    item manipulation. We also saw the strategy that one might adopt when working
    on existing items on the Canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this program, we extensively used the item identifier ID to target a particular
    item on the canvas. Recall that item identifier is the unique integer ID returned
    by the canvas method that creates the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, when you create an oval item on your canvas, it returns an
    integer ID after creating the object. This is referred to its item identifier
    or the item handle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now you can act upon this oval using the handle, my_item_identifier.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not the only method by which you can identify an item on the
    canvas. Additionally, you can add tags to items, and then use these tags to identify
    the object for manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with item tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's now look at some of the common operations involved in working with Canvas
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a tag to an item, you specify the tag (which is a string) as its configurable
    option either at the time of creating the object or later using the `itemconfig`
    method, or add them using the `addtag_withtag` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The same tag can be applied to more than one item on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add multiple tags to an item together by passing in the tags as a tuple
    of strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using tags to identify items to be manipulated is especially useful when you
    need to manipulate more than one item at one time, or if you want to manipulate
    items based on certain conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get all tags associated with a specific item handle, use `gettags` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a tuple of all tags associated with that item handle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Getting items with a given tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the item handles for all items having a given tag, use `find_withtag`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This returns the item handles for all items as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The canvas widget provides two built-in tags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ALL or all: It matches all items on the canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CURRENT or current: It returns the item under the mouse pointer, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There you have your own drawing program! You can easily extend it to add many
    more features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick summary of things we have seen in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Building custom GUI frameworks for rapid application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use inheritance in our projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the `tkColoChooser` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to create and manipulate items on the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the tk ComboBox widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the available `winfo` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with mouse events on the Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinforcing things that we have learned in previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following features to your drawing program:'
  prefs: []
  type: TYPE_NORMAL
- en: The accelerator keys don't work for our menu items because we have not bound
    them to key events. Bind the menu-item accelerator keys to their associated command
    callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an Eraser button and add its associated features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have not implemented drawing of some other basic shapes, such as arc and
    polygons, even though the Canvas widget provides for methods to draw them. Add
    the ability to draw arcs and polygons to the drawing program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new toolbar on the right side. Utilizing the stacking order for canvas
    items, display each item as a separate layer in the toolbar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go through all the available Canvas widget options in your IDE by using Python's
    interactive help feature. Try adding more features to the program utilizing one
    or more of the options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already included the ability to add images to our program by navigating
    to **File** | **Open**. Add a few menu items to manipulate those images. Using
    some imaging library, add image manipulation features, such as color adjustment,
    brightness, contrast, grayscale, and other facilities for image manipulation provided
    by the imaging library that you choose to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Canvas widget is often used to draw custom widgets. Make a Progress Meter
    widget using the Canvas widget. Attach it to some function and run it to see that
    the oval should get filled with some color as the function progresses. You can
    use the fill option of the Canvas widget to show increase in progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
