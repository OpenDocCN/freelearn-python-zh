<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Cross-browser Testing</h1></div></div></div><p>Selenium supports cross-browser testing on multiple browser and operating system combinations. This is a <a id="id405" class="indexterm"/>very useful feature for testing web applications on various browser and operating system combinations to certify that the app is cross-browser compatible and to make sure that users do not experience problems with their choice of browsers or operating systems. Selenium WebDriver offers an ability to run tests on remote machines or distribute them against a number of operating systems and browsers running on remote machines or the cloud. So far, you have learned how to create and run tests on a local machine with various browser drivers installed as shown in the following diagram:</p><div><img src="img/3506OS_06_01.jpg" alt="Cross-browser Testing"/></div><p>In this chapter, you will learn how to run these tests on a remote machine and then how to scale and run tests in a distributed architecture on multiple browser and operating system combinations for cross-browser testing. This saves a great amount of effort and time spent in cross-browser testing. We will cover the following aspects in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Downloading and using the Selenium standalone server</li><li class="listitem" style="list-style-type: disc">How to use the <code class="literal">Remote</code> class to run tests on the Selenium standalone server</li><li class="listitem" style="list-style-type: disc">Running tests on the Selenium standalone server</li><li class="listitem" style="list-style-type: disc">Adding nodes to the Selenium standalone server to create a grid for distributed execution</li><li class="listitem" style="list-style-type: disc">Running tests in the grid against multiple browser and operating system combinations</li><li class="listitem" style="list-style-type: disc">Running tests in a cloud with Sauce Labs and BrowserStack</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>The Selenium standalone server</h1></div></div></div><p>The Selenium <a id="id406" class="indexterm"/>standalone server is a component of Selenium that provides the ability to run tests on remote machines. We need to use the <code class="literal">RemoteWebDriver</code> class to connect to the Selenium standalone server to run tests on a remote machine. The <a id="id407" class="indexterm"/>
<code class="literal">RemoteWebDriver</code> class listens to Selenium commands coming from test scripts using the <code class="literal">RemoteWebDriver</code> class on a designated port. Based on the configuration provided by the <code class="literal">RemoteWebDriver</code> class, the Selenium server will launch the specified browser and forward the commands to the browser. It supports almost all the browsers and mobile platforms with Appium. The following diagram shows the architecture of the Selenium server running tests on remote machines configured with different types of browsers:</p><div><img src="img/3506OS_06_02.jpg" alt="The Selenium standalone server"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Downloading the Selenium standalone server</h2></div></div></div><p>The Selenium <a id="id408" class="indexterm"/>standalone server is available in a <a id="id409" class="indexterm"/>bundled JAR format for download at <a class="ulink" href="http://docs.seleniumhq.org/download/">http://docs.seleniumhq.org/download/</a> in the <em>Selenium Server (formerly the Selenium RC Server)</em> section. While writing this book, Selenium server Version 2.41.0 was available for download. You can simply copy the Selenium standalone server JAR file on a remote machine and start the server.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>The Selenium standalone server is a self-contained server written in Java. It requires a Java Runtime Environment (JRE) to be installed on the machine where it is run. Please make sure you have installed JRE 6 or onwards on the remote machine where you intend to run the Selenium standalone server.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Launching the Selenium standalone server</h2></div></div></div><p>The Selenium <a id="id410" class="indexterm"/>standalone server can be launched in various modes or roles. In this section, we will launch it in a standalone mode. We can launch the server with the following command on the remote machine's command line from the directory where the server's JAR file is kept. In this example, it is launched on a Windows 8 machine by using the following command line:</p><div><pre class="programlisting">
<strong>java –jar selenium-server-standalone-2.41.0.jar</strong>
</pre></div><p>By default, Selenium server will start listening on port <code class="literal">4444</code> at <code class="literal">http://&lt;remote-machine-ip&gt;:4444</code>. It is possible to change the port through the command-line option while starting the server. When the server is launched, you will see the following output on the command line:</p><div><img src="img/3506OS_06_03.jpg" alt="Launching the Selenium standalone server"/></div><p>The Selenium server will be launched as an HTTP server on the remote machine and we can launch and see the server in a browser window. Launch the browser and navigate to <code class="literal">http://&lt;remote-machine-ip&gt;:4444/wd/hub/static/resource/hub.html</code>. This will display the following page in the browser window:</p><div><img src="img/3506OS_06_04.jpg" alt="Launching the Selenium standalone server"/></div><p>Now that we have <a id="id411" class="indexterm"/>the Selenium server up and running, it is time to create and run a test that we can run on the server.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Running a test on the Selenium standalone server</h1></div></div></div><p>To run a test on <a id="id412" class="indexterm"/>Selenium server, we need to use <code class="literal">RemoteWebDriver</code>. The <code class="literal">Remote</code> class in the Selenium Python binding acts like a client and <a id="id413" class="indexterm"/>communicates with the Selenium server to run the tests on a remote machine. We need to use this class to instruct the Selenium server as to what configurations are needed to run a test on a remote machine and commands to run on selected browsers.</p><p>In addition to the <code class="literal">Remote</code> class, we need to set <code class="literal">desired_capabilities</code>, that is the browser, operating system, and any other configuration that we want to communicate to the Selenium standalone server to run the test. In this example, we will specify a platform and browser name as the desired capabilities required to run the test:</p><div><pre class="programlisting">desired_caps = {}
desired_caps['platform'] = 'WINDOWS'
desired_caps['browserName'] = 'firefox'</pre></div><p>Next, we will create an instance of the <code class="literal">Remote</code> class and pass <code class="literal">desired_capabilities</code>. When the script is executed, it will connect to the Selenium server and request the server to set up a Firefox browser running on Windows to run the test:</p><div><pre class="programlisting">self.driver = webdriver.Remote('http://192.168.1.103:4444/wd/hub', desired_caps)</pre></div><p>Let's implement a search test that we created earlier and use the <code class="literal">Remote</code> class instead of the Firefox driver in the following way:</p><div><pre class="programlisting">import unittest
from selenium import webdriver


class SearchProducts(unittest.TestCase):
    def setUp(self):

        desired_caps = {}
        desired_caps['platform'] = 'WINDOWS'
        desired_caps['browserName'] = 'firefox'

        self.driver = \
            webdriver.Remote('http://192.168.1.102:4444/wd/hub',desired_caps)
        self.driver.get('http://demo.magentocommerce.com/')
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

    def testSearchByCategory(self):

        # get the search textbox
        self.search_field = self.driver.find_element_by_name('q')
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys('phones')
        self.search_field.submit()

        # get all the anchor elements which have product names # displayed currently on result page using # find_elements_by_xpath method
        products = self.driver\
            .find_elements_by_xpath('//h2[@class=\'product-name\']/a')

        # check count of products shown in results
        self.assertEqual(2, len(products))

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    unittest.main()</pre></div><p>When this test is <a id="id414" class="indexterm"/>executed, you can see the console <a id="id415" class="indexterm"/>of the Selenium server. It shows the interaction between the test and the server as shown in the following screenshot. It shows which command has been executed and its status:</p><div><img src="img/3506OS_06_05.jpg" alt="Running a test on the Selenium standalone server"/></div><p>You can also <a id="id416" class="indexterm"/>navigate to <code class="literal">http://&lt;remote-machine-ip&gt;:4444/wd/hub/static/resource/hub.html</code>, which displays a new <a id="id417" class="indexterm"/>session being created. If you hover over the capabilities link, it displays the capabilities being used to run the tests, as shown in the following screenshot:</p><div><img src="img/3506OS_06_06.jpg" alt="Running a test on the Selenium standalone server"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Adding support for Internet Explorer</h2></div></div></div><p>Firefox <a id="id418" class="indexterm"/>support is bundled with the Selenium server; however, for running tests on <strong>Internet Explorer</strong> (<strong>IE</strong>), we need to specify the path of the IE driver executable while starting the Selenium server. This is done by specifying the executable path to the <code class="literal">wedriver.ie.driver</code> option in the command line as shown:</p><div><pre class="programlisting">
<strong>java -Dwebdriver.ie.driver="C:\SeDrivers\IEDriverServer.exe" -jar selenium-server-standalone-2.41.0.jar</strong>
</pre></div><p>By providing <a id="id419" class="indexterm"/>the path of the IE driver, Selenium server will now launch and support IE for testing on the remote machine.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Adding support for Chrome</h2></div></div></div><p>Similar to the <a id="id420" class="indexterm"/>IE driver <a id="id421" class="indexterm"/>executable, we need to mention the Chrome driver on the remote machine to support testing on Chrome. This is done by specifying the Chrome driver path in the <code class="literal">webdriver.chrome.driver</code> option as shown in following command line:</p><div><pre class="programlisting">
<strong>java -Dwebdriver.ie.driver="C:\SeDrivers\IEDriverServer.exe" -Dwebdriver.chrome.driver="C:\SeDrivers\chromedriver.exe" -jar selenium-server-standalone-2.41.0.jar</strong>
</pre></div><p>The Selenium <a id="id422" class="indexterm"/>server will now support running tests on both the Internet Explorer and Chrome on the remote machine.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Selenium Grid</h1></div></div></div><p>Selenium Grid lets us <a id="id423" class="indexterm"/>distribute our tests across multiple physical or virtual machines in order to run tests in a distributed fashion or run them in parallel. This helps in getting a faster and more accurate feedback by cutting down the time required for running tests and speeding up cross-browser testing. We can use our existing infrastructure of virtual machines in a cloud to set up the Grid.</p><p>Selenium Grid enables us to run multiple tests in parallel, on multiple nodes or clients, in a heterogeneous environment where we can have a mixture of browser and operating system support. It makes all these nodes appear as a single instance and transparently distributes tests on the underlying infrastructure as shown in the following diagram:</p><div><img src="img/3506OS_06_07.jpg" alt="Selenium Grid"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Launching Selenium server as a hub</h2></div></div></div><p>We need to <a id="id424" class="indexterm"/>set up Selenium server as a <a id="id425" class="indexterm"/>hub to run the tests in a distributed fashion. The <a id="id426" class="indexterm"/>hub will provide all the available configurations or capabilities to tests.</p><p>The slave machines, also called as nodes, connect to the hub. Tests will use JSON wire protocol using the <code class="literal">Remote</code> class to communicate with the hub to execute the Selenium commands. You can find more about JSON wire protocol at <a class="ulink" href="https://code.google.com/p/selenium/wiki/JsonWireProtocol">https://code.google.com/p/selenium/wiki/JsonWireProtocol</a>.</p><p>The hub acts as the central point that will receive the commands from tests and distribute them to the appropriate node or to the node matching the capabilities required by the test. Let's set up a Selenium server as a Grid and then add nodes with different browser and operating system combinations.</p><p>We can start the Selenium standalone server as a hub (also known as a Grid server) with additional arguments to the command that we used to start the server in earlier sections.</p><p>Create a <a id="id427" class="indexterm"/>new command/terminal window and navigate to the location where the Selenium server JAR is located. Start the server as a hub by typing the following command:</p><div><pre class="programlisting">
<strong>java -jar selenium-server-standalone-2.25.0.jar -port 4444 -role hub</strong>
</pre></div><p>We need to <a id="id428" class="indexterm"/>use the <code class="literal">–role</code> argument with the value <code class="literal">hub</code> to start the server as hub or Grid server.</p><p>In this <a id="id429" class="indexterm"/>example, the server is started on a Windows machine. It starts with the following information printed on the console:</p><div><img src="img/3506OS_06_08.jpg" alt="Launching Selenium server as a hub"/></div><p>When we start the Selenium server as hub, it starts as a Grid server. We can see the Grid console in the browser as shown in the following screenshot:</p><div><img src="img/3506OS_06_09.jpg" alt="Launching Selenium server as a hub"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Adding nodes</h2></div></div></div><p>Now that we <a id="id430" class="indexterm"/>have our Selenium server started as a Grid server, let's add a few <a id="id431" class="indexterm"/>node configurations to the server.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec17"/>Adding an IE node</h3></div></div></div><p>Let's begin with a <a id="id432" class="indexterm"/>node that provides Internet Explorer capabilities running on Windows. Open a new command prompt or a terminal window and navigate to the <a id="id433" class="indexterm"/>location where the Selenium server JAR is located. To launch a node and add it to the Grid, type the following command:</p><div><pre class="programlisting">
<strong>java -Dwebdriver.ie.driver="C:\SeDrivers\IEDriverServer.exe" -jar selenium-server-standalone-2.41.0.jar -role webdriver -browser "browserName=internet explorer,version=10,maxinstance=1,platform=WINDOWS" -hubHost 192.168.1.103 –port 5555</strong>
</pre></div><p>To add the node to the Grid, we need to use the <code class="literal">–role</code> argument and pass <code class="literal">webdriver</code> as a value. We also need to pass the browser configuration for the node. This is passed through the <code class="literal">–browser</code> argument. In this example, we passed <code class="literal">browserName</code> as <code class="literal">internet explorer</code>, <code class="literal">version</code> as <code class="literal">10</code>, <code class="literal">maxinstance</code> as <code class="literal">1</code>, and <code class="literal">platform</code> as <code class="literal">WINDOWS</code>. The <code class="literal">maxinstance</code> value tells the Grid how many concurrent instances of the browser will be supported by the node.</p><p>To connect the node to the hub or Grid server, we need to specify the <code class="literal">–hubHost</code> argument with the hostname or IP address of the Grid server. Lastly, we need to specify the port on which the node will be running.</p><p>When we run the preceding command and the node is launched, the following configuration will appear on the Grid console:</p><div><img src="img/3506OS_06_10.jpg" alt="Adding an IE node"/></div><p>Alternatively, a node <a id="id434" class="indexterm"/>can be added by creating a configuration file in JSON format <a id="id435" class="indexterm"/>and then using the following code:</p><div><pre class="programlisting">{
  "class": "org.openqa.grid.common.RegistrationRequest",
  "capabilities": [
   {
   "seleniumProtocol": "WebDriver",
   "browserName": "internet explorer",
   "version": "10",
   "maxInstances": 1,
   "platform" : "WINDOWS"
   }
  ],
  "configuration": {
   "port": 5555,
   "register": true,
   "host": "192.168.1.103",
   "proxy": "org.openqa.grid.selenium.proxy.
   DefaultRemoteProxy",
   "maxSession": 2,
   "hubHost": "192.168.1.100",
   "role": "webdriver",
   "registerCycle": 5000,
   "hub": "http://192.168.1.100:4444/grid/register",
   "hubPort": 4444,
   "remoteHost": "http://192.168.1.102:5555"
  }
}</pre></div><p>We can now <a id="id436" class="indexterm"/>pass the <code class="literal">selenium-node-win-ie10.cfg.json</code> configuration file <a id="id437" class="indexterm"/>through command-line arguments as follows:</p><div><pre class="programlisting">
<strong>java -Dwebdriver.ie.driver="C:\SeDrivers\IEDriverServer.exe"-jar selenium-server-standalone-2.41.0.jar -role webdriver -nodeConfig selenium-node-win-ie10.cfg.json</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec18"/>Adding a Firefox node</h3></div></div></div><p>To add a <a id="id438" class="indexterm"/>Firefox node, open a new command prompt or terminal window and navigate to the location where the Selenium server JAR is located. To launch and add a <a id="id439" class="indexterm"/>node to the Grid, type the following command:</p><div><pre class="programlisting">
<strong>java -jar selenium-server-standalone-2.41.0.jar -role webdriver -browser "browserName=firefox,version=27,maxinstance=2,platform=WINDOWS" -hubHost localhost –port 6666</strong>
</pre></div><p>In this example, we set <code class="literal">maxinstance</code> to <code class="literal">2</code>. This tells Grid that this node will support two instances of Firefox. Once the node has started, the following configuration will appear in Grid console:</p><div><img src="img/3506OS_06_11.jpg" alt="Adding a Firefox node"/></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec19"/>Adding a Chrome node</h3></div></div></div><p>To add <a id="id440" class="indexterm"/>Chrome node, open a new command prompt or terminal window and navigate to the location where the Selenium server JAR is located. To launch and <a id="id441" class="indexterm"/>add the node to the Grid, type following command:</p><div><pre class="programlisting">
<strong>java -Dwebdriver.chrome.driver="C:\SeDrivers\chromedriver.exe" -jar selenium-server-standalone-2.41.0.jar -role webdriver -browser "browserName=chrome,version=35,maxinstance=2,platform=WINDOWS" -hubHost localhost -port 7777</strong>
</pre></div><p>Once the node <a id="id442" class="indexterm"/>has started, the following configuration will <a id="id443" class="indexterm"/>appear in the Grid console:</p><div><img src="img/3506OS_06_12.jpg" alt="Adding a Chrome node"/></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Mac OS X with Safari</h1></div></div></div><p>We added IE, Firefox, and Chrome instances from a Windows machine, now let's add a Safari node <a id="id444" class="indexterm"/>from a Mac OS. Open a new terminal window and <a id="id445" class="indexterm"/>navigate to the location where the Selenium server JAR is <a id="id446" class="indexterm"/>located. To launch and add the node to the Grid type the following command:</p><div><pre class="programlisting">
<strong>java -jar selenium-server-standalone-2.41.0.jar -role webdriver -browser "browserName=safari,version=7,maxinstance=1,platform=MAC" -hubHost 192.168.1.104 -port 8888</strong>
</pre></div><p>Once the node has started, the following configuration will appear on the Grid console:</p><div><img src="img/3506OS_06_13.jpg" alt="Mac OS X with Safari"/></div><p>Now, we have <a id="id447" class="indexterm"/>our Selenium Grid set up, let's try running tests on <a id="id448" class="indexterm"/>this Grid.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Running tests in Grid</h1></div></div></div><p>Running tests in <a id="id449" class="indexterm"/>Grid and with different combinations of browsers and operating systems will need a few tweaks to the tests that we created earlier. We specified hardcoded browser and platform names in the desired capabilities. If we hardcode the <a id="id450" class="indexterm"/>values, then we will end up having a separate script for each combination. To avoid this and use a single test that will work on all the combinations, we need to parameterize the browser and platform values passed to the desired capabilities class as given in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We will pass the browser and platform to the tests from the command line. For example, if we want to run test on the Windows and Chrome combination we will run the script through the command line in the following way:<div><pre class="programlisting">
<strong>python grid_test.py WINDOWS chrome</strong>
</pre></div></li><li class="listitem">If we want to run tests on Safari on Mac, we can use following command:<div><pre class="programlisting">
<strong>python grid_test.py MAC safari</strong>
</pre></div></li><li class="listitem">To implement this, we need to add two global attributes, <code class="literal">PLATFORM</code> and <code class="literal">BROWSER</code>, to the test class in the following way. We will set a default value in case values are not supplied from the command line:<div><pre class="programlisting">class SearchProducts(unittest.TestCase):

    PLATFORM = 'WINDOWS'
    BROWSER = 'firefox'</pre></div></li><li class="listitem">Next we <a id="id451" class="indexterm"/>need to parameterize the desired capabilities in the <code class="literal">setUp()</code> method as shown in the following code:<div><pre class="programlisting">desired_caps = {}
desired_caps['platform'] = self.PLATFORM
desired_caps['browserName'] = self.BROWSER</pre></div></li><li class="listitem">Finally, we need to read the arguments passed to the script and assign the values to the <code class="literal">PLATFORM</code> and <code class="literal">BROWSER</code> attributes in the following way:<div><pre class="programlisting">if __name__ == '__main__':
    if len(sys.argv) &gt; 1:
        SearchProducts.BROWSER = sys.argv.pop()
        SearchProducts.PLATFORM = sys.argv.pop()
    unittest.main()</pre></div></li><li class="listitem">That's it. Our test is now ready to handle any given combination. Here is the complete code <a id="id452" class="indexterm"/>with the previous changes:<div><pre class="programlisting">import sys
import unittest
from selenium import webdriver

class SearchProducts(unittest.TestCase):

    PLATFORM = 'WINDOWS'
    BROWSER = 'firefox'

    def setUp(self):

        desired_caps = {}
        desired_caps['platform'] = self.PLATFORM
        desired_caps['browserName'] = self.BROWSER

        self.driver = \
            webdriver.Remote('http://192.168.1.104:4444/wd/hub',desired_caps)
        self.driver.get('http://demo.magentocommerce.com/')
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()
    def testSearchByCategory(self):

        # get the search textbox
        self.search_field = self.driver.find_element_by_name('q')
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys('phones')
        self.search_field.submit()

        # get all the anchor elements which have product names # displayed currently on result page using # find_elements_by_xpath method
        products = self.driver.\
            find_elements_by_xpath('//h2[@class=\'product-name\']/a')

        # check count of products shown in results
        self.assertEqual(2, len(products))

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    if len(sys.argv) &gt; 1:
        SearchProducts.BROWSER = sys.argv.pop()
        SearchProducts.PLATFORM = sys.argv.pop()
    unittest.main(verbosity=2)</pre></div></li><li class="listitem">To run the test, open a new command prompt or terminal window and navigate to the location of the script. Type the following command and you will see that the <a id="id453" class="indexterm"/>Grid will connect the node matching with <a id="id454" class="indexterm"/>the given platform and browser and execute the test on that node:<div><pre class="programlisting">
<strong>python grid_test.py MAC safari</strong>
</pre></div></li></ol></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Running tests in a cloud</h1></div></div></div><p>We set up a local <a id="id455" class="indexterm"/>grid in the previous steps to run the tests for cross-browser testing. This requires setting up physical or virtual machines with different browsers and operating systems. There are costs and efforts needed to get the required hardware, software, and support to run the test lab. You also need to put in efforts to keep this <a id="id456" class="indexterm"/>infrastructure updated with the latest versions and patches, and so on. Not everybody can afford these costs and efforts.</p><p>Instead of investing and setting up a cross-browser test lab, you can easily outsource a virtual test lab to a third-party cloud provider. Sauce Labs and BrowserStack are leading cloud-based cross-browser testing cloud providers. Both of these have support for over 400 different browser and operating system configurations including mobile and tablet devices and support running Selenium WebDriver tests in their cloud.</p><p>In this section, we will set up and run a test in Sauce Labs cloud. The steps are similar if you want to run tests with BrowserStack.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Using Sauce Labs</h2></div></div></div><p>Let's <a id="id457" class="indexterm"/>set up and run a test with Sauce Labs using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">You need a free Sauce Labs account to begin with. Register for a free account on <a id="id458" class="indexterm"/>Sauce Labs at <a class="ulink" href="https://saucelabs.com/">https://saucelabs.com/</a> and get the username and access key. Sauce Labs provides <a id="id459" class="indexterm"/>all the required hardware and software infrastructure to run your tests in the cloud.</li><li class="listitem">You can get the access key from the Sauce Labs dashboard after login as shown:<div><img src="img/3506OS_06_14.jpg" alt="Using Sauce Labs"/></div></li><li class="listitem">Let's <a id="id460" class="indexterm"/>modify the test we created earlier to run with Grid and add steps to run this test on Sauce Labs cloud.</li><li class="listitem">We need to add the Sauce username and access key to the test and change the Grid address to Sauce's Grid address passing the username and access key as shown in the <a id="id461" class="indexterm"/>following code:<div><pre class="programlisting">import sys
import unittest
from selenium import webdriver


class SearchProducts(unittest.TestCase):

    PLATFORM = 'WINDOWS'
    BROWSER = 'phantomjs'
    <strong>SAUCE_USERNAME = 'upgundecha'</strong>
    <strong>SUACE_KEY = 'c6e7132c-ae27-4217-b6fa-3cf7df0a7281'</strong>

    def setUp(self):

        desired_caps = {}
        desired_caps['platform'] = self.PLATFORM
        desired_caps['browserName'] = self.BROWSER

        <strong>sauce_string = self.SAUCE_USERNAME + ':' + self.SUACE_KEY</strong>

        <strong>self.driver = \</strong>
            <strong>webdriver.Remote('http://' + sauce_string + '@ondemand.saucelabs.com:80/wd/hub', desired_caps)</strong>
        self.driver.get('http://demo.magentocommerce.com/')
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

    def testSearchByCategory(self):

        # get the search textbox
        self.search_field = self.driver.find_element_by_name('q')
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys('phones')
        self.search_field.submit()

        # get all the anchor elements which have product names # displayed currently on result page using # find_elements_by_xpath method
        products = self.driver.\
            find_elements_by_xpath('//h2[@class=\'product-name\']/a')

        # check count of products shown in results
        self.assertEqual(2, len(products))

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    if len(sys.argv) &gt; 1:
        SearchProducts.BROWSER = sys.argv.pop()
        SearchProducts.PLATFORM = sys.argv.pop()
    unittest.main(verbosity=2)</pre></div></li><li class="listitem">To run the test, open a new command prompt or terminal window and navigate to the <a id="id462" class="indexterm"/>location of the script. Type <a id="id463" class="indexterm"/>following command:<div><pre class="programlisting">
<strong>python sauce_test.py "OS X 10.9" "Safari"</strong>
</pre></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>You can get a list of Platforms supported on Sauce Labs at <a class="ulink" href="https://saucelabs.com/platforms">https://saucelabs.com/platforms</a>.</p></div></div><p>While running the test, it will connect to Sauce Lab's grid server and request for the desired operating system and browser configuration. Sauce assigns a virtual machine for our test to run on the given configuration.</p></li><li class="listitem">We can monitor this run on Sauce dashboard as shown in the following screenshot:<div><img src="img/3506OS_06_15.jpg" alt="Using Sauce Labs"/></div></li></ol></div><p>We can further drill down on the Sauce session and see exactly what happened during the run. It provides a lot of details including the Selenium commands, screenshots, Selenium logs, and video of <a id="id464" class="indexterm"/>the execution as shown in the following <a id="id465" class="indexterm"/>screenshot:</p><div><img src="img/3506OS_06_16.jpg" alt="Using Sauce Labs"/></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>You can also test the application securely hosted on the internal servers by using the Sauce Connect <a id="id466" class="indexterm"/>utility that creates a secure tunnel between your machine and the Sauce cloud.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, you learned how to run tests on remote machines with the Selenium standalone server. The Selenium standalone server enables us to run tests on remote machines for testing our application against a combination of browsers and operating systems for cross-browser testing. This increases coverage for testing and making sure applications run on the desired combinations.</p><p>We then looked at setting up Selenium Grid to run tests in a distributed architecture. Selenium Grid removes complexity in performing cross-browser testing by providing a transparent execution against multiple machines. It also brings down the time to run the tests.</p><p>We also looked at using a cloud-based, cross-browser testing provider. We executed a test on Sauce Labs. This offers all the necessary test infrastructure to run the tests on hundreds of different combinations with minimal costs.</p><p>In the next chapter, you will learn how to test mobile applications using Appium and Selenium WebDriver, using some of the concepts you learned in this chapter. Appium supports testing native, hybrid, and web mobile applications on iOS and Android. We will set up Appium and run tests against the mobile version of the sample application.</p></div></div>
</body></html>