<html><head></head><body>
<section id="chapter-2-introducing-essential-functional-concepts" class="level2 chapterHead" data-number="0.6">&#13;
<h2 class="chapterHead" data-number="0.6"><span class="titlemark"> 2</span><br/>&#13;
<span id="x1-340002"/>Introducing Essential Functional Concepts</h2>&#13;
<p>Most of the features of functional programming are already part of the Python language. Our goal in writing functional Python is to shift our focus away from imperative (procedural or object-oriented) techniques as much as possible.</p>&#13;
<p>We’ll look at the following functional programming topics:</p>&#13;
<ul>&#13;
<li><p>In Python, functions are first-class objects.</p></li>&#13;
<li><p>We can use and create higher-order functions.</p></li>&#13;
<li><p>We can create pure functions very easily.</p></li>&#13;
<li><p>We can work with immutable data.</p></li>&#13;
<li><p>In a limited way, we can create functions that have non-strict evaluation of sub-expressions. Python generally evaluates expressions strictly. As we’ll see later, a few operators are non-strict.</p></li>&#13;
<li><p>We can design functions that exploit eager versus lazy evaluation.</p></li>&#13;
<li><p>We can use recursion instead of an explicit loop state.</p></li>&#13;
<li><p>We have a type system that can apply to functions and objects.</p></li>&#13;
</ul>&#13;
<p>This expands on the concepts from the first chapter: firstly, that purely functional programming avoids the complexities of an explicit state maintained through variable assignments; and secondly, that Python is not a purely functional language.</p>&#13;
<p>Because Python is not a purely functional language, we’ll focus on those features that are indisputably important in functional programming. We’ll start by looking at functions as first-class Python objects, with properties and methods of their own. <span id="x1-34001r27"/></p>&#13;
<section id="functions-as-first-class-objects" class="level3 sectionHead" data-number="0.6.1">&#13;
<h3 class="sectionHead" data-number="0.6.1"><span class="titlemark">2.1 </span> <span id="x1-350001"/>Functions as first-class objects</h3>&#13;
<p>Functional programming is often succinct and expressive. One way to achieve this is by providing functions as arguments and return values for other functions. We’ll look at numerous examples of manipulating functions.</p>&#13;
<p>For this to work, functions<span id="dx1-35001"/> must be first-class objects in the runtime environment. In programming languages such as C, a function is not a runtime object; because the compiled C code generally lacks internal attributes and methods, there’s little runtime introspection that can be performed on a function. In Python, however, functions are objects that are created (usually) by <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statements and can be manipulated by other Python functions. We can also create a function as a callable object or by assigning a lambda object to a variable.</p>&#13;
<p>Here’s how a function definition creates an object with attributes:</p>&#13;
<div id="tcolobox-16" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; def example(a, b, **kw): &#13;
...     return a*b &#13;
... &#13;
&gt;&gt;&gt; type(example) &#13;
&lt;class ’function’&gt; &#13;
&gt;&gt;&gt; example.__code__.co_varnames &#13;
(’a’, ’b’, ’kw’) &#13;
&gt;&gt;&gt; example.__code__.co_argcount &#13;
2</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve created an object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">example</code></span></span>, that is of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">function</code></span></span> class. This object has numerous attributes. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__code__</code></span></span> attribute of the function<span id="dx1-35012"/> object has attributes of its own. The implementation details aren’t important. What is important is functions are first-class objects and can be manipulated like all other objects. The example shows the values of two of the many attributes of a function object. <span id="x1-35013r34"/></p>&#13;
<section id="pure-functions" class="level4 subsectionHead" data-number="0.6.1.1">&#13;
<h4 class="subsectionHead" data-number="0.6.1.1"><span class="titlemark">2.1.1 </span> <span id="x1-360001"/>Pure functions</h4>&#13;
<p>A function<span id="dx1-36001"/> free from the confusion created by side effects is often more expressive than a function that also updates state elsewhere in an application. Using pure functions can also allow some optimizations by changing evaluation order. The big win, however, stems from pure functions being conceptually simpler and much easier to test.</p>&#13;
<p>To write a pure<span id="dx1-36002"/> function in Python, we have to write local-only code. This means we have to avoid <span class="obeylines-h"><span class="verb"><code class="inlineCode">global</code></span></span> statements. We need to avoid entanglements with objects that have hidden state; often, this means avoiding input and output operations. We need to look closely at any use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">nonlocal</code></span></span>, also. While assigning to a non-local variable is a side effect, the state change is confined to a nested function definition. Avoiding global variables and file operations is an easy standard to meet. Pure functions are a common feature of Python programs.</p>&#13;
<div id="tcolobox-17" class="infobox note">&#13;
&#13;
&#13;
<p>There isn’t a built-in tool to <span class="cmti-10x-x-109">guarantee </span>a Python function is free from side effects. For folks interested in the details, a tool<span id="dx1-36003"/> like <span class="obeylines-h"><span class="verb"><code class="inlineCode">mr-proper</code></span></span>, <a href="https://pypi.org/project/mr-proper/" class="url">https://pypi.org/project/mr-proper/</a>, can be used to confirm that a function is pure.</p>&#13;
&#13;
</div>&#13;
<p>A Python lambda is often used to create a very small, pure function. It’s possible for a lambda object to perform input or output or use an impure function. A bit of code inspection is still helpful to remove any doubts.</p>&#13;
<p>Here’s a function created by assigning a lambda object to a variable:</p>&#13;
<div id="tcolobox-18" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; mersenne = lambda x: 2 ** x - 1 &#13;
&gt;&gt;&gt; mersenne(17) &#13;
131071</code></pre>&#13;
&#13;
</div>&#13;
<p>We created a pure function<span id="dx1-36008"/> using <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code></span></span> and assigned this to the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">mersenne</code></span></span>. This is a callable object with a single parameter, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, that returns a single value.</p>&#13;
<p>The following example shows an impure function defined as a lambda object:</p>&#13;
<div id="tcolobox-19" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; default_zip = lambda row: row.setdefault(’ZIP’, ’00000’)</code></pre>&#13;
&#13;
</div>&#13;
<p>This function has the potential to update a dictionary in the event the key, <span class="obeylines-h"><span class="verb"><code class="inlineCode">’ZIP’</code></span></span>, is not present. There are two cases, as shown in the following example:</p>&#13;
<div id="tcolobox-20" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; r_0 = {’CITY’: ’Vaca Key’} &#13;
&gt;&gt;&gt; default_zip(r_0) &#13;
’00000’ &#13;
&gt;&gt;&gt; r_0 &#13;
{’CITY’: ’Vaca Key’, ’ZIP’: ’00000’} &#13;
 &#13;
&gt;&gt;&gt; r_1 = {’CITY’: ’Asheville’, ’ZIP’: 27891} &#13;
&gt;&gt;&gt; default_zip(r_1) &#13;
27891</code></pre>&#13;
&#13;
</div>&#13;
<p>In the first case, the dictionary object <span class="obeylines-h"><span class="verb"><code class="inlineCode">r_0</code></span></span> does not have the key, <span class="obeylines-h"><span class="verb"><code class="inlineCode">’ZIP’</code></span></span>. The dictionary object is updated by the lambda object. This is a consequence of using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">setdefault()</code></span></span> method of a dictionary.</p>&#13;
<p>In the second case, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">r_1</code></span></span> object contains the key, <span class="obeylines-h"><span class="verb"><code class="inlineCode">’ZIP’</code></span></span>. There’s no update to the dictionary. The side effect depends on the state of the object prior to the function, making the function potentially more difficult to understand. <span id="x1-36023r39"/></p>&#13;
</section>&#13;
<section id="higher-order-functions" class="level4 subsectionHead" data-number="0.6.1.2">&#13;
<h4 class="subsectionHead" data-number="0.6.1.2"><span class="titlemark">2.1.2 </span> <span id="x1-370002"/>Higher-order functions</h4>&#13;
<p>We can achieve expressive, succinct programs<span id="dx1-37001"/> using higher-order functions. These are functions that accept a function<span id="dx1-37002"/> as an argument or return a function as a value. We can use higher-order functions as a way to create composite functions from simpler functions.</p>&#13;
<p>Consider the Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function. We can provide a function as an argument and modify how the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function behaves.</p>&#13;
<p>Here’s some data we might want to process:</p>&#13;
<div id="tcolobox-21" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; year_cheese = [(2000, 29.87), (2001, 30.12), &#13;
...     (2002, 30.6), (2003, 30.66), (2004, 31.33), &#13;
...     (2005, 32.62), (2006, 32.73), (2007, 33.5), &#13;
...     (2008, 32.84), (2009, 33.02), (2010, 32.92)]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function, as follows:</p>&#13;
<div id="tcolobox-22" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; max(year_cheese) &#13;
(2010, 32.92)</code></pre>&#13;
&#13;
</div>&#13;
<p>The default behavior is to simply compare each tuple in the sequence. This will return the tuple with the largest value on position zero of each tuple.</p>&#13;
<p>Since the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function is a higher-order function, we can provide another function as an argument. In this case, we’ll use a lambda as the function; this is used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function, as follows:</p>&#13;
<div id="tcolobox-23" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; max(year_cheese, key=lambda yc: yc[1]) &#13;
(2007, 33.5)</code></pre>&#13;
&#13;
</div>&#13;
<p>In this example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function applies the supplied lambda and returns the tuple with the largest value in position one of each tuple.</p>&#13;
<p>Python provides a rich collection of higher-order functions. We’ll see examples of each of Python’s higher-order functions in later chapters, primarily in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>. We’ll also see how we can easily write our own higher-order functions. <span id="x1-37014r38"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="immutable-data" class="level3 sectionHead" data-number="0.6.2">&#13;
<h3 class="sectionHead" data-number="0.6.2"><span class="titlemark">2.2 </span> <span id="x1-380002"/>Immutable data</h3>&#13;
<p>Since we’re not using variables to track the state of a computation, our focus needs to stay on immutable<span id="dx1-38001"/> objects. We can make extensive use of tuples, <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuples</code></span></span>, and frozen <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> to provide more complex data structures that are also immutable. We’ll look at these class definitions in detail in <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>.</p>&#13;
<p>The idea of immutable objects is not foreign to Python. Strings and tuples are two widely-used immutable objects. There can be a performance advantage to using immutable tuples instead of more complex mutable objects. In some cases, the benefits come from rethinking the algorithm to avoid the costs of object mutation.</p>&#13;
<p>As an example, here’s a common design pattern that works well with immutable objects: the <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrapper()</code></span></span> function. A list of tuples is a fairly common data structure. We will often process this list of tuples in one of the two following ways:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Using higher-order functions</span>: As shown<span id="dx1-38002"/> earlier, we provided a lambda as an argument to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function: <span class="obeylines-h"><span class="verb"><code class="inlineCode">max(year_cheese,</code><code class="inlineCode"> key=lambda</code><code class="inlineCode"> yc:</code><code class="inlineCode"> yc[1])</code></span></span>.</p></li>&#13;
<li><p><span class="keyWord">Using the wrap-process-unwrap pattern</span>: In a functional<span id="dx1-38003"/> context, we can implement this with code that follows an <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap(structure)))</code></span></span> pattern.</p></li>&#13;
</ul>&#13;
<p>For example, look at the following command snippet:</p>&#13;
<div id="tcolobox-24" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; max(map(lambda yc: (yc[1], yc), year_cheese))[1] &#13;
(2007, 33.5)</code></pre>&#13;
&#13;
</div>&#13;
<p>This fits the three-part pattern of wrapping a data structure, finding the maximum of the wrapped structures, and then unwrapping the structure.</p>&#13;
<p>The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(lambda</code><code class="inlineCode"> yc:</code><code class="inlineCode"> (yc[1],</code><code class="inlineCode"> yc),</code><code class="inlineCode"> year_cheese)</code></span></span> will transform each item into a two-tuple with a key followed by the original item. In this example, the comparison key value is the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">yc[1]</code></span></span>.</p>&#13;
<p>The processing is done using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function. Since each piece of the source data has been simplified to a new two-tuple, the higher-order function features of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function aren’t required. To make this work, the comparison value was taken from position one of the source record and placed first into the two-tuple. The default behavior of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function uses the first item in each two-tuple to locate the largest value.</p>&#13;
<p>Finally, we unwrap<span id="dx1-38007"/> using the subscript expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1]</code></span></span>. This will pick the second element of the two-tuple selected by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function.</p>&#13;
<p>This kind of wrap-and-unwrap is so common that some languages have special functions with names like <span class="obeylines-h"><span class="verb"><code class="inlineCode">fst()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd()</code></span></span> that we can use as function prefixes instead of a syntactic suffix of <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0]</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1]</code></span></span>. We can use this idea to modify our wrap-process-unwrap example, as follows:</p>&#13;
<div id="tcolobox-25" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; snd = lambda x: x[1] &#13;
&gt;&gt;&gt; snd(max(map(lambda yc: (yc[1], yc), year_cheese))) &#13;
(2007, 33.5)</code></pre>&#13;
&#13;
</div>&#13;
<p>Here, a lambda is used to define the <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd()</code></span></span> function to pick the second item from a tuple. This provides an easier-to-read version of <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap()))</code></span></span>. As with the previous example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(lambda...</code><code class="inlineCode"> ,</code><code class="inlineCode"> year_cheese)</code></span></span> expression is used to wrap our raw data items, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function does the processing. Finally, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">snd()</code></span></span> function extracts the second item from the tuple.</p>&#13;
<p>This can be simplified by using <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> or a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span>. In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, we’ll look at these two alternatives.</p>&#13;
<p>We will—as a general design principle—avoid class definitions. It can seem like anathema to avoid objects<span id="dx1-38012"/> in an <span class="keyWord">Object</span>-<span class="keyWord">Oriented Programming </span>(<span class="keyWord">OOP</span>) language, but we note that functional programming doesn’t depend on stateful objects. When we use class definitions, we’ll avoid designs that update attribute values.</p>&#13;
<p>There are a number of good reasons for using immutable objects. We can, for example, use an object as a named collection of attribute values. Additionally, callable objects can provide some optimizations, like the caching of computed results. Caching is important because Python doesn’t have an optimizing compiler. Another reason for using class definitions is to provide a namespace for closely related functions. <span id="x1-38013r41"/></p>&#13;
</section>&#13;
<section id="strict-and-non-strict-evaluation" class="level3 sectionHead" data-number="0.6.3">&#13;
<h3 class="sectionHead" data-number="0.6.3"><span class="titlemark">2.3 </span> <span id="x1-390003"/>Strict and non-strict evaluation</h3>&#13;
<p>Functional programming’s efficiency stems, in part, from being able to defer a computation until it’s required. There are two similar concepts<span id="dx1-39001"/> for avoiding computation. These are:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Strictness</span>: Python operators are generally strict and evaluate all sub-expressions from left to right. This means an expression like <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(a)+f(b)+f(c)</code></span></span> is evaluated as if it was <span class="obeylines-h"><span class="verb"><code class="inlineCode">(f(a)+f(b))+f(c)</code></span></span>. An optimizing compiler might avoid strict ordering to improve performance. Python doesn’t optimize and code is mostly strict. We’ll look at cases where Python is not strict below.</p></li>&#13;
<li><p><span class="keyWord">Eagerness </span>and <span class="keyWord">laziness</span>: Python operators are generally eager and evaluate all sub-expressions to compute the final answer. This means <span class="obeylines-h"><span class="verb"><code class="inlineCode">(3-3)</code><code class="inlineCode"> *</code><code class="inlineCode"> f(d)</code></span></span> is fully evaluated even though the first part of the multiplication—the <span class="obeylines-h"><span class="verb"><code class="inlineCode">(3-3)</code></span></span> sub-expression—is always zero, meaning the result is always zero, no matter what value is computed by the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(d)</code></span></span>. Generator expressions are an example of Python doing lazy evaluation. We’ll look at an example of this in the next section, <a href="#x1-400004"><span class="cmti-10x-x-109">Lazy and eager evaluation</span></a>.</p></li>&#13;
</ul>&#13;
<p>In Python, the logical expression operators <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">or</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">if-else</code></span></span> are all non-strict. We sometimes call them <span class="keyWord">short-circuit </span>operators<span id="dx1-39002"/> because they don’t need to evaluate all arguments to determine the resulting value.</p>&#13;
<p>The following command snippet shows the <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span> operator’s non-strict<span id="dx1-39003"/> feature:</p>&#13;
<div id="tcolobox-26" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; 0 and print("right") &#13;
0 &#13;
 &#13;
&gt;&gt;&gt; True and print("right") &#13;
right</code></pre>&#13;
&#13;
</div>&#13;
<p>When we execute the first of the preceding command snippets, the left-hand side of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span> operator<span id="dx1-39010"/> is equivalent to <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>; the right-hand side is not evaluated. In the second example, when the left-hand side is equivalent to <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>, the right-hand side is evaluated.</p>&#13;
<p>Other parts of Python are strict. Outside the logical operators, an expression is evaluated strictly from left to right. A sequence of statement lines is also evaluated strictly in order. Literal lists and tuples require strict evaluation. When a class is created, the methods are defined in a strict order. <span id="x1-39011r42"/></p>&#13;
</section>&#13;
<section id="lazy-and-eager-evaluation" class="level3 sectionHead" data-number="0.6.4">&#13;
<h3 class="sectionHead" data-number="0.6.4"><span class="titlemark">2.4 </span> <span id="x1-400004"/>Lazy and eager evaluation</h3>&#13;
<p>Python’s generator expressions and generator functions<span id="dx1-40001"/> are lazy. These expressions don’t create all possible results immediately. It’s difficult to see this without explicitly logging the details of a calculation. Here is an example of the version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function that has the side effect of showing the numbers it creates:</p>&#13;
<pre id="listing-17" class="lstlisting"><code>from collections.abc import Iterator &#13;
def numbers(stop: int) -&gt; Iterator[int]: &#13;
    for i in range(stop): &#13;
        print(f"{i=}") &#13;
        yield i</code></pre>&#13;
<p>To provide some debugging hints, this function prints each value as the value is yielded. If this function were eager<span id="dx1-40007"/>, evaluating <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers(1024)</code></span></span> would take the time (and storage) to create all 1,024 numbers. Since the <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers()</code></span></span> function is lazy, it only creates a number as it is requested.</p>&#13;
<p>We can use this noisy <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers()</code></span></span> function in a way that will show lazy evaluation. We’ll write a function that evaluates some, but not all, of the values from this iterator:</p>&#13;
<pre id="listing-18" class="lstlisting"><code>def sum_to(limit: int) -&gt; int: &#13;
    sum: int = 0 &#13;
    for i in numbers(1_024): &#13;
        if i == limit: break &#13;
        sum += i &#13;
    return sum</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum_to()</code></span></span> function<span id="dx1-40014"/> has type hints to show that it should accept an integer value for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> parameter and return an integer<span id="dx1-40015"/> result. This function<span id="dx1-40016"/> will not evaluate the entire result of the values produced by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers()</code></span></span> function. It will break after only consuming a few values from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers()</code></span></span> function. We can see this consumption of values in the following log:</p>&#13;
<div id="tcolobox-27" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sum_to(5) &#13;
i=0 &#13;
i=1 &#13;
i=2 &#13;
i=3 &#13;
i=4 &#13;
i=5 &#13;
10</code></pre>&#13;
&#13;
</div>&#13;
<p>As we’ll see later, Python generator functions have some properties that make them a little awkward for simple functional programming. Specifically, a generator can only be used once in Python. We have to be cautious with how we use the lazy Python generator expressions. <span id="x1-40026r43"/></p>&#13;
</section>&#13;
<section id="recursion-instead-of-an-explicit-loop-state" class="level3 sectionHead" data-number="0.6.5">&#13;
<h3 class="sectionHead" data-number="0.6.5"><span class="titlemark">2.5 </span> <span id="x1-410005"/>Recursion instead of an explicit loop state</h3>&#13;
<p>Functional programs don’t rely on loops and the associated overhead of tracking the state of loops. Instead, functional programs try to rely on the much simpler approach of recursive functions. In some languages, the programs are written as recursions, but <span class="keyWord">Tail-Call Optimization </span>(<span class="keyWord">TCO</span>) in the compiler changes them to loops. We’ll introduce some recursion<span id="dx1-41001"/> here and examine it closely in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>.</p>&#13;
<p>We’ll look at an iteration to test whether a number is a prime number. Here’s a definition<span id="dx1-41002"/> from <a href="https://mathworld.wolfram.com/PrimeNumber.html" class="url">https://mathworld.wolfram.com/PrimeNumber.html</a>: “A prime number ... is a positive integer <span class="italic">p &gt; </span>1 that has no positive integer divisors other than 1 and <span class="italic">p </span>itself.” We can create a naive and poorly performing algorithm to determine whether a number has any factors between 2 and the number. This is called<span id="dx1-41003"/> the <span class="cmti-10x-x-109">Trial Division </span>algorithm. It has the advantage of simplicity; it works acceptably for solving some of the <span class="keyWord">Project Euler</span> problems. Read up on <span class="keyWord">Miller-Rabin</span><span id="dx1-41004"/> primality tests for a much better algorithm.</p>&#13;
<p>We’ll use the term <span class="cmti-10x-x-109">coprime </span>to mean<span id="dx1-41005"/> that two numbers have only 1 as their common factor. The numbers 2 and 3, for example, are coprime. The numbers 6 and 9, however, are not coprime because they have 3 as a common factor.</p>&#13;
<p>If we want to know whether a number, <span class="italic">n</span>, is prime, we actually ask this: is the number <span class="italic">n </span>coprime to all prime numbers, <span class="italic">p</span>, such that <span class="italic">p</span><sup><span class="cmr-8">2</span></sup> <span class="italic">&lt; n</span>? We can simplify this using all integers, <span class="italic">i</span>, such that 2 <span class="cmsy-10x-x-109">≤ </span><span class="italic">i</span><sup><span class="cmr-8">2</span></sup> <span class="italic">&lt; n</span>. The simplification does more work, but is much easier to implement.</p>&#13;
<p>Sometimes, it helps to formalize this as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file16.jpg" class="math-display" alt="prime(n) = ∀x[2 ≤ x &lt; √n-+ 1 ∧ n ⁄≡ 0 mod x ] "/>&#13;
</div>&#13;
<p>The expression<span id="dx1-41006"/> could look as follows in Python:</p>&#13;
<pre id="listing-19" class="lstlisting"><code>not any( &#13;
    n % p == 0 &#13;
    for p in range(2, int(math.sqrt(n))+1) &#13;
)</code></pre>&#13;
<p>An alternative conversion from mathematical formalism to Python would use <span class="obeylines-h"><span class="verb"><code class="inlineCode">all(n</code><code class="inlineCode"> %</code><code class="inlineCode"> p</code><code class="inlineCode"> !=</code><code class="inlineCode"> 0,</code><code class="inlineCode"> ...)</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> function will stop when it finds the first <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> value. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">not</code><code class="inlineCode"> any()</code></span></span> will stop when it finds the first <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> value. While the results are identical, the performance varies depending on whether or not <span class="obeylines-h"><span class="verb"><code class="inlineCode">p</code></span></span> is a prime number.</p>&#13;
<p>This expression has a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> iteration inside it: it’s not a pure example of stateless functional programming. We can reframe this into a function that works with a collection of values. We can ask whether the number, <span class="italic">n</span>, is coprime within any value in the half-open interval [2<span class="italic">,</span><img src="../Images/file17.jpg" class="sqrt" alt="√ -- n"/> + 1). This uses the symbols [) to show a half-open interval: the lower values are included, and the upper value is not included. This is typical behavior of the Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function. We will also restrict ourselves to the domain of natural numbers. The square root values, for example, are implicitly truncated to integers.</p>&#13;
<p>We can think of the definition of prime as the following:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file18.jpg" class="math-display" alt="prime(n) = coprime (n,[2,√n-+ 1)) "/>&#13;
</div>&#13;
<p>given <span class="italic">n &gt; </span>1. We know <span class="italic">n </span>is prime when it is coprime to all values in the range [2<span class="italic">,</span><img src="../Images/file19.jpg" class="sqrt" alt=" -- √ n"/> + 1).</p>&#13;
<p>While the formal math can feel daunting, this is a search for a coprime in the given range of values. If we find a coprime, the value of <span class="italic">n </span>is not prime. If we fail to find a coprime, then the value of <span class="italic">n </span>must be prime.</p>&#13;
<p>When defining a recursive<span id="dx1-41011"/> search over a range of values, the base case can be the empty range. Searching the empty range means no values can be found. Searching a non-empty range is handled recursively by processing one value combined with a range that’s narrower by the one value processed. We could formalize it as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file20.jpg" class="math-display" alt=" ( |||| True if a = b, { coprime (n,[a,b)) = | ( ) the range is empty |||( (n ⁄≡ 0 mod a )∧ coprime n, [a + 1,b) if a &lt; b "/>&#13;
</div>&#13;
<p>In the case where the range is non-empty, one value, <span class="italic">a</span>, is checked to see if it is coprime with <span class="italic">n</span>; then, the remaining values in the range [<span class="italic">a </span>+ 1<span class="italic">,b</span>) are checked. This expression can be confirmed by providing concrete examples of the two cases, which are given as follows:</p>&#13;
<ul>&#13;
<li><p>If the range is empty, <span class="italic">a </span>= <span class="italic">b</span>, we evaluated something like this:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file21.jpg" class="math-display" alt=" ( ) coprime 131073,[363,363) "/>&#13;
</div>&#13;
<p>The range contains no values, so the return is <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>. This is analogous to computing the sum of an empty list: the sum is zero.</p></li>&#13;
<li><p>If the range is not empty, we evaluated something like this:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file22.jpg" class="math-display" alt=" ( ) coprime 131073,[2,363) "/>&#13;
</div>&#13;
<p>This decomposes into evaluating:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file23.jpg" class="math-display" alt=" ( ) (131073 ⁄≡ 0 mod 2)∧ coprime 131073,[3,363) "/>&#13;
</div>&#13;
<p>For this example, we can see that the first clause is <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>, and we’ll evaluate the second clause recursively. Compare this with evaluating coprime<span class="bigg"><img src="../Images/file24.jpg" class="left" data-align="middle" alt="("/></span>16<span class="italic">,</span><img src="../Images/file25.jpg" class="left" data-align="middle" alt="[2,5)"/><span class="bigg"><img src="../Images/file26.jpg" class="left" data-align="middle" alt=")"/></span>. The value of 16≢0 mod 2 would be <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>; the values of 16 and 2 are not coprime. The evaluation of coprime<span class="bigg"><img src="../Images/file27.jpg" class="left" data-align="middle" alt="("/></span>131073<span class="italic">,</span><img src="../Images/file28.jpg" class="left" data-align="middle" alt="[3,363)"/><span class="bigg"><img src="../Images/file29.jpg" class="left" data-align="middle" alt=")"/></span> becomes irrelevant, since we know the 16 is composite.</p></li>&#13;
</ul>&#13;
<p>As an exercise for the reader, this recursion<span id="dx1-41012"/> can be redefined to count down instead of up, using [<span class="italic">a,b</span><span class="cmsy-10x-x-109">− </span>1) in the second case. Try this revision to see what, if any, changes are required.</p>&#13;
<div id="tcolobox-28" class="packt_tip">&#13;
&#13;
&#13;
<p>Some folks like to define the empty interval as <span class="italic">a </span><span class="cmsy-10x-x-109">≥ </span><span class="italic">b </span>instead of <span class="italic">a </span>= <span class="italic">b</span>. The extra <span class="italic">&gt; </span>condition is needless, since <span class="italic">a </span>is incremented by 1 and we can easily guarantee that <span class="italic">a </span><span class="cmsy-10x-x-109">≤ </span><span class="italic">b</span>, initially. There’s no way for <span class="italic">a </span>to somehow magically leap past <span class="italic">b </span>through some error in the function; we don’t need to over-specify the rules for an empty interval.</p>&#13;
&#13;
</div>&#13;
<p>Here is a Python code snippet that implements this definition of prime:</p>&#13;
<pre id="listing-20" class="lstlisting"><code>def isprimer(n: int) -&gt; bool: &#13;
    def iscoprime(k: int, a: int, b: int) -&gt; bool: &#13;
        """Is k coprime with a value in the given range?""" &#13;
        if a == b: return True &#13;
        return (k % a != 0) and iscoprime(k, a+1, b) &#13;
    return iscoprime(n, 2, int(math.sqrt(n)) + 1)</code></pre>&#13;
<p>This shows a recursive definition of an <span class="obeylines-h"><span class="verb"><code class="inlineCode">iscoprime()</code></span></span> function. The function expects an <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span> value for all three parameters. The type hints claim it will return a <span class="obeylines-h"><span class="verb"><code class="inlineCode">bool</code></span></span> result.</p>&#13;
<p>The recursion base case is implemented as <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code><code class="inlineCode"> ==</code><code class="inlineCode"> b</code></span></span>. When this is true, the range of values from <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span> to one less than <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span> is empty. Because the recursive evaluation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">iscoprime()</code></span></span> is the tail end of the function, this is an example of <span class="keyWord">tail</span> <span class="keyWord">recursion</span><span id="dx1-41019"/>.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">iscoprime()</code></span></span> function is embedded in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprimer()</code></span></span> function. The outer function serves to establish the boundary condition for the range of values that will be searched.</p>&#13;
<p>What’s important in this example is that the two cases of this recursive function follow the mathematical definition in a direct way. Making the range of values an explicit argument to the internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">iscoprime()</code></span></span> function allows us to call the function recursively with argument values that reflect a steadily shrinking interval.</p>&#13;
<p>While recursion<span id="dx1-41020"/> is often succinct and expressive, we have to be cautious about using it in Python. There are two problems that can arise:</p>&#13;
<ul>&#13;
<li><p>Python imposes a recursion limit to detect recursive functions with improperly defined base cases.</p></li>&#13;
<li><p>Python does not have a compiler that does <span class="keyWord">Tail-Call Optimization</span> (<span class="keyWord">TCO</span>) for us.</p></li>&#13;
</ul>&#13;
<p>The default recursion limit is 1,000, which is adequate for many algorithms. It’s possible to change this with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sys.setrecursionlimit()</code></span></span> function. It’s not wise to raise this arbitrarily since it might lead to exceeding the OS memory limitations and crashing the Python runtime.</p>&#13;
<p>If we try a recursive <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprimer()</code></span></span> function on a prime number <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> over 1,000,000, we’ll run afoul of the recursion limit. (Folks using IPython have a higher default limit on the size of the stack; try <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprimer(9_000_011)</code></span></span> to see the problem.)</p>&#13;
<p>Some functional programming languages can optimize these “tail call” recursive functions. An optimizing compiler will transform the recursive evaluation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iscoprime(k,</code><code class="inlineCode"> a+1,</code><code class="inlineCode"> b)</code></span></span> expression into a low-overhead <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. The optimization tends to make debugging optimized programs more difficult. Python doesn’t perform this optimization. Performance and memory are sacrificed for clarity and simplicity. This also means we are forced to do the optimization manually.</p>&#13;
<p>This is the subject of <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>. We’ll look at several examples of doing manual TCO. <span id="x1-41021r44"/></p>&#13;
</section>&#13;
<section id="functional-type-systems" class="level3 sectionHead" data-number="0.6.6">&#13;
<h3 class="sectionHead" data-number="0.6.6"><span class="titlemark">2.6 </span> <span id="x1-420006"/>Functional type systems</h3>&#13;
<p>Some functional<span id="dx1-42001"/> programming languages, such as <span class="keyWord">Haskell</span><span id="dx1-42002"/> and <span class="keyWord">Scala</span>,<span id="dx1-42003"/> are statically compiled, and depend on declared types for functions and their arguments. To provide the kind of flexibility Python already has, these languages have sophisticated type-matching rules allowing a generic function to work for a variety of related types.</p>&#13;
<p>In object-oriented Python, we often use the class inheritance hierarchy instead of sophisticated function type matching. We rely on Python to dispatch an operator to a proper method based on simple name-matching rules.</p>&#13;
<p>Python’s built-in ”duck typing” rules offer a great deal of type flexibility. The more complex type matching rules for a compiled functional language aren’t relevant. It’s common to define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.Protocol</code></span></span> to specify the features an object must have. The actual class hierarchy doesn’t matter; what matters is the presence of the appropriate methods and attributes.</p>&#13;
<p>Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement<span id="dx1-42004"/> offers a number of structure and type matching capabilities. Because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement has so many alternatives, we’ll return to it several times. For now, we’ll provide an introductory example to show the core syntax.</p>&#13;
<p>Here’s an example that relies on literal<span id="dx1-42005"/> matching, wildcard matching with <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span>, and guard conditions:</p>&#13;
<pre id="listing-21" class="lstlisting"><code>import math &#13;
def isprimem(n: int) -&gt; bool: &#13;
    match n: &#13;
        case _ if n &lt; 2: &#13;
            prime = False &#13;
        case 2: &#13;
            prime = True &#13;
        case _ if n % 2 == 0: &#13;
            prime = False &#13;
        case _: &#13;
            for i in range(3, 1 + int(math.sqrt(n)), 2): &#13;
                if n % i == 0: &#13;
                    # Stop as soon as we know... &#13;
                    return False &#13;
            prime = True &#13;
    return prime</code></pre>&#13;
<p>When working<span id="dx1-42022"/> with a single data type, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement is not dramatically simpler than an <span class="obeylines-h"><span class="verb"><code class="inlineCode">if-elif</code></span></span> chain. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">case</code><code class="inlineCode"> _</code></span></span> blocks use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span> pattern, which matches anything without binding any variables. Some of these are followed by additional guards, for example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code><code class="inlineCode"> n</code><code class="inlineCode"> &lt;</code><code class="inlineCode"> 2</code></span></span>, to provide a more nuanced decision to these cases.</p>&#13;
<p>The final <span class="obeylines-h"><span class="verb"><code class="inlineCode">case</code><code class="inlineCode"> _:</code></span></span> matches any possible<span id="dx1-42023"/> value not matched by any of the prior <span class="obeylines-h"><span class="verb"><code class="inlineCode">case</code></span></span> blocks. It is analogous to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">else:</code></span></span> clause in an <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statement.</p>&#13;
<p>The single <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code></span></span> statement at the end is expected by <span class="keyWord">mypy</span>. We could rewrite this to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code></span></span> statements for each case. While it would work properly, without a single, clear <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code></span></span> it’s difficult for the <span class="keyWord">mypy</span><span id="dx1-42024"/> tool to confirm that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement truly covers all possible conditions.</p>&#13;
<p>As we look at other examples, we’ll see more of the power of the pattern and type matching capabilities. This example matches literal values of a single type. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement can do quite a bit more. In later chapters, we’ll see the distinction between type hints, checked by a tool like <span class="keyWord">mypy</span>, and type matching that can be done by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement. <span id="x1-42025r45"/></p>&#13;
</section>&#13;
<section id="familiar-territory" class="level3 sectionHead" data-number="0.6.7">&#13;
<h3 class="sectionHead" data-number="0.6.7"><span class="titlemark">2.7 </span> <span id="x1-430007"/>Familiar territory</h3>&#13;
<p>One of the ideas that emerges from the previous list of topics is that many functional programming constructs are already present in Python. Indeed, elements of functional programming are already a very typical and common part of OOP.</p>&#13;
<p>As a very specific example, a fluent <span class="keyWord">Application Program Interface</span> (<span class="keyWord">API</span>)<span id="dx1-43001"/> is a very clear example of functional programming. If we take time to create a class with <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code><code class="inlineCode"> self</code></span></span> in each method, we can use it as follows:</p>&#13;
<pre id="listing-22" class="lstlisting"><code>some_object.foo().bar().yet_more()</code></pre>&#13;
<p>We can just as easily write several closely related functions that work as follows:</p>&#13;
<pre id="listing-23" class="lstlisting"><code>yet_more(bar(foo(some_object)))</code></pre>&#13;
<p>We’ve switched the syntax from traditional object-oriented suffix notation to a more functional prefix notation. Python uses both notations freely, often using a prefix version of a special method name. For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function is generally implemented by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__len__()</code></span></span> class special method.</p>&#13;
<p>Of course, the implementation of the preceding class might involve a highly stateful object. Even then, a small change in viewpoint may reveal a functional approach that can lead to more succinct or more expressive programming.</p>&#13;
<p>The point is not that imperative programming is broken in some way, or that functional programming offers a vastly superior technology. The point is that functional programming leads to a change in viewpoint that can, in many cases, be helpful for designing succinct, expressive programs. <span id="x1-43004r46"/></p>&#13;
</section>&#13;
<section id="learning-some-advanced-concepts" class="level3 sectionHead" data-number="0.6.8">&#13;
<h3 class="sectionHead" data-number="0.6.8"><span class="titlemark">2.8 </span> <span id="x1-440008"/>Learning some advanced concepts</h3>&#13;
<p>We will set some more advanced concepts aside for consideration in later chapters. These concepts are part of the implementation of a purely functional language. Since Python isn’t purely functional, our hybrid approach won’t require deep consideration of these topics.</p>&#13;
<p>We will identify these here for the benefit of readers who already know a functional language such as <span class="keyWord">Haskell </span>and are learning Python. The underlying concerns are present in all programming languages, but we’ll tackle them differently in Python. In many cases, we can and will drop into imperative programming rather than use a strictly functional approach.</p>&#13;
<p>The topics are as follows:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Referential transparency</span>: When looking<span id="dx1-44001"/> at lazy evaluation and the various kinds of optimizations that are possible in a compiled language, the idea of multiple routes to the same object is important. In Python, this isn’t as important because there aren’t any relevant compile-time optimizations.</p></li>&#13;
<li><p><span class="keyWord">Currying</span>: The type systems<span id="dx1-44002"/> will employ currying to reduce multiple-argument functions to single-argument functions. We’ll look at currying in some depth in <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design</span> <span class="cmti-10x-x-109">Techniques</span></a>.</p></li>&#13;
<li><p><span class="keyWord">Monads</span>: These are purely functional<span id="dx1-44003"/> constructs that allow us to structure a sequential pipeline of processing in a flexible way. In some cases, we’ll resort to imperative Python to achieve the same end. We’ll also leverage the elegant PyMonad<span id="dx1-44004"/> library for this. We’ll defer this until <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 13</span></a>, <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">The PyMonad Library</span></a>.</p></li>&#13;
</ul>&#13;
<p><span id="x1-44005r47"/></p>&#13;
</section>&#13;
<section id="summary-1" class="level3 sectionHead" data-number="0.6.9">&#13;
<h3 class="sectionHead" data-number="0.6.9"><span class="titlemark">2.9 </span> <span id="x1-450009"/>Summary</h3>&#13;
<p>In this chapter, we’ve identified a number of features that characterize the functional programming paradigm. We started with first-class and higher-order functions. The idea is that a function can be an argument to a function or the result of a function. When functions become the object of additional programming, we can write some extremely flexible and generic algorithms.</p>&#13;
<p>The idea of immutable data is sometimes odd in an imperative and object-oriented programming language such as Python. When we start to focus on functional programming, however, we see a number of ways that state changes can be confusing or unhelpful. Using immutable objects can be a helpful simplification.</p>&#13;
<p>Python focuses on strict evaluation: all sub-expressions are evaluated from left to right through the statement. Python, however, does perform some non-strict evaluation. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">or</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">and</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span>-<span class="obeylines-h"><span class="verb"><code class="inlineCode">else</code></span></span> logical operators are non-strict: all sub-expressions are not necessarily evaluated.</p>&#13;
<p>Generator functions can be described as lazy. While Python is generally eager, and evaluates all sub-expressions a soon as possible, we can leverage generator functions to create lazy evaluation. With lazy evaluation, a computation is not performed until it’s needed.</p>&#13;
<p>While functional programming relies on recursion instead of the explicit loop state, Python imposes some limitations here. Because of the stack limitation and the lack of an optimizing compiler, we’re forced to manually optimize recursive functions. We’ll return to this topic in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and</span> <span class="cmti-10x-x-109">Reductions</span></a>.</p>&#13;
<p>Although many functional languages have sophisticated type systems, we’ll rely on Python’s dynamic type resolution. In some cases, this means we’ll have to write manual coercion for various types.</p>&#13;
<p>In the next chapter, we’ll look at the core concepts of pure functions and how these fit in with Python’s built-in data structures. Given this foundation, we can look at the higher-order functions available in Python and how we can define our own higher-order functions. <span id="x1-45001r48"/></p>&#13;
</section>&#13;
<section id="exercises-1" class="level3 sectionHead" data-number="0.6.10">&#13;
<h3 class="sectionHead" data-number="0.6.10"><span class="titlemark">2.10 </span> <span id="x1-4600010"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-46001r40"/></p>&#13;
<section id="apply-map-to-a-sequence-of-values" class="level4 subsectionHead" data-number="0.6.10.1">&#13;
<h4 class="subsectionHead" data-number="0.6.10.1"><span class="titlemark">2.10.1 </span> <span id="x1-470001"/>Apply map() to a sequence of values</h4>&#13;
<p>Some analysis has revealed a consistent measurement error in a device. The machine’s revolutions per minute (RPM) as displayed on the tachometer are consistently incorrect. (Gathering the true RPM involves some heroic engineering effort, but is not a sustainable way to manage the machine.)</p>&#13;
<p>The result is a model that translates observed, <span class="italic">o</span>, to actual, <span class="italic">a</span>:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file30.jpg" class="math-display" alt="a = f (o) = 0.9× o − 90 "/>&#13;
</div>&#13;
<p>The machine can only operate in the range of 800 to 2,500 RPM. Until the tachometer can be replaced with one that’s properly calibrated, we need a table of values from observed RPM to actual RPM. This can be printed and laminated and put near the machine to help gauge fuel consumption and workload.</p>&#13;
<p>Because the tachometer can only be read to the nearest 100 RPM, the table only needs to show values like 800, 900, 1000, 1100, ..., 2500.</p>&#13;
<p>The output should be something like the following:</p>&#13;
<div id="tcolobox-29" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>Observed  Actual &#13;
     800     630 &#13;
     900     720 &#13;
etc.</code></pre>&#13;
&#13;
</div>&#13;
<p>In order to provide a flexible solution, it helps to create the following two separate functions:</p>&#13;
<ul>&#13;
<li><p>A function to implement the model, which computes the actual value from the observation</p></li>&#13;
<li><p>A function to display the table of values produced from the results of the model function</p></li>&#13;
</ul>&#13;
<p>These two–separate–functions will be used as part of the recalibration effort for the piece of equipment.</p>&#13;
<p>Test cases for the model can be isolated from test cases for the table of values, allowing new models to be used as more data is gathered.</p>&#13;
<p>While it is the topic of a later chapter, and has only been mentioned here, use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> is encouraged, but not required. <span id="x1-47006r50"/></p>&#13;
</section>&#13;
<section id="function-vs.-lambda-design-question" class="level4 subsectionHead" data-number="0.6.10.2">&#13;
<h4 class="subsectionHead" data-number="0.6.10.2"><span class="titlemark">2.10.2 </span> <span id="x1-480002"/>Function vs. lambda design question</h4>&#13;
<p>The model in the <a href="#x1-470001"><span class="cmti-10x-x-109">Apply map() to a sequence of values</span></a> problem is a small function, only about one line of code. Here are three different ways this can be written:</p>&#13;
<ul>&#13;
<li><p>As a proper <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> function.</p></li>&#13;
<li><p>As a lambda object.</p></li>&#13;
<li><p>As a class definition that implements the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__call__()</code></span></span> method.</p></li>&#13;
</ul>&#13;
<p>Create all three implementations. Compare and contrast them with respect to ease of understanding. Defend one as being ideal by (a) providing some criteria for software quality and (b) showing how the implementation meets those criteria. <span id="x1-48001r51"/></p>&#13;
</section>&#13;
<section id="optimize-a-recursion" class="level4 subsectionHead" data-number="0.6.10.3">&#13;
<h4 class="subsectionHead" data-number="0.6.10.3"><span class="titlemark">2.10.3 </span> <span id="x1-490003"/>Optimize a recursion</h4>&#13;
<p>See <a href="#x1-410005"><span class="cmti-10x-x-109">Recursion instead of an explicit loop state</span></a> earlier in this chapter.</p>&#13;
<p>As an exercise for the reader, this recursion can be redefined to count down instead of up, using [<span class="italic">a,b </span><span class="cmsy-10x-x-109">− </span>1) in the second case. Implement this change to see what, if any, changes are required. Measure the performance to see if there is any performance consequence.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-2" class="level3 likesectionHead" data-number="0.6.11">&#13;
<h3 class="likesectionHead" data-number="0.6.11"><span id="x1-500003"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-50001r37"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>