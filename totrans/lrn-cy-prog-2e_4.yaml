- en: Chapter 4. Debugging Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Cython programs compile down to their native code, we cannot use the Python
    debugger to step through your code. We can, however, use GDB. **GNU Project Debugger**
    (**GDB**) is a cross platform debugger. Python plugin support was added in version
    7.0, which was used to add the Cython support into `gdb` as a simple script; this
    means that you can seamlessly step through the C/C++ code into Cython and back
    again.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to language binding, it's good practice to keep interfaces as
    simple as possible. This will make debugging much simpler until you are happy
    with your bindings in terms of resource management or stability. I will iterate
    over some GDB and caveats examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using GFB with Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython caveats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GDB with Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To debug Cython, you need GDB >= 7.0\. On Mac OS X Xcode, build tools have
    moved to LLVM and lldb as respective debuggers. You can install `gdb` using homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the Python debugger since the Cython code is compiled down to
    C/C++. Therefore, when debugging without the Cython plugin, you will be stepping
    through the generated C/C++ code, which won't be helpful as it won't understand
    the context of the Cython program.
  prefs: []
  type: TYPE_NORMAL
- en: Running cygdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cygdb is installed as a part of Cython and is a wrapper over GDB (it invokes
    GDB with arguments to set up the Cython plugin). Before you can debug the Cython
    code, we need to generate the debugging information. Just like C/C++, we need
    to specify compiler options to generated debuggable code we can pass `–gdb` when
    invoking the Cython compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start debugging on Debian, you need to install the Python debug
    information package and GDB as it is not installed with `build-essential`. To
    install these, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have GDB and the debug information generated, you can start the
    Cython debugger with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re familiar with GDB, you can simply use all of the normal `gdb`
    commands. However, the whole point of `cygdb` is that we can use Cython commands,
    which we will see in use here with an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tab autocomplete `cy break`, you will see a list of symbols to which
    you can set a Cython break point. Next, we need to get the program running and
    continue to our break points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(gdb) cy break func**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the break point set, we need to run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have hit the declaration of the `func` function, we can continue
    and do some introspection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `globals` command will show any of the global identifiers in the scope
    of the current frame, so we can see the `func` function and `classobj foobar`.
    We can inspect further by listing the code and step code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also step the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get fairly neat listings even from classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even see the backtrace of the current Python state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The help can be found by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I think you have got the idea! It's worth playing around, checking the help,
    and trying these for yourself to get the feel of debugging with cygdb. To get
    a good feel, you really need to practice with GDB and get comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: Cython caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some caveats worth noting while mixing C and the Python code when
    it comes to Cython. It's a good idea to refer to these when building something
    to be production ready.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that in the previous code examples, we were able to cast
    the `void *` pointer from `malloc` to our extension types using `malloc`. Cython
    supports some more advanced type checking as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In basic type casting, Cython supports `<type?>` for type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will do some type checking and throw an error if the type that is being
    cast is not a subclass of `char *`. So, in this case, it will pass; however, if
    you were to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an error (at runtime):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, this can add some more type safety to your Cython APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Dereference operator (*)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Cython, we don''t have a dereference operator. For example, if you are passing
    a C array and length to a function, you can use pointer arithmetic to iterate
    and access elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Cython, we have to be a little more explicit by accessing element zero.
    Then, we increment the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing really fancy here. You simply have to use `x[0]` if you want
    to dereference `int *x`.
  prefs: []
  type: TYPE_NORMAL
- en: Python exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another topic to look at is what happens if your Cython code propagates an
    exception to your C code. In the next chapter, we will cover how C++ native exceptions
    interact with Python, but we do not have this in C. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply raises an exception back to C and gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a warning was printed and no exception handling had occurred,
    so the program continues onto something else. This is because the plain `cdef`
    functions that do not return Python objects have no way for exceptions to be handled;
    and thus, a simple warning message is printed. If we want to control the behavior
    for C programs, we need to declare the exception on the Cython function prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three forms for doing this. First, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the function throw an exception on the function returning `-1` at
    any point. This also causes the exception to be propagated to the caller; so,
    in Cython, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the *maybe* exception (as I would like to think of it), which
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that it may or may not be an error. Cython generates a call to `PyErr_Occurred`
    to perform verification from the C API. Lastly, we can use the wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This then makes it always call `PyErr_Occurred`, which you can check via `PyErr_PrintEx`
    or via others at [http://docs.python.org/2/c-api/exceptions.html](http://docs.python.org/2/c-api/exceptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function pointer declarations can also handle this in their prototype.
    Just make sure that the return type matches the exception type, which must be
    an enum, float, pointer-type, or constant expression; if this is not the case,
    you will get a confusing compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython has more support for the C style `for` loops, and it can also perform
    further optimizations on the `range` function depending on how the iterator is
    declared. Generally, in Python, you simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine on PyObjects since they understand iterators, but C types do not
    have any of these abstractions. You need to do pointer arithmetic on your array
    types to access indexes. So, for example, first we can do the following with the
    `range` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the range function is used on C types, such as the following example that
    uses `cdef int i`, it is optimized for real C array access. There are several
    other forms we can use. We could translate the loop into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a lot more like a normal Python `for` loop performing the iteration
    assigning `i`, the index data. There is also one last form that Cython introduces
    using the `for .. from` syntax. This looks like a real `for` loop from C, and
    we can now write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also introduce the step size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These extra `for` loop constructs are particularly useful when working a lot
    with C types because they do not understand extra Python constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you try and use `bool` in Cython, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you need to use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you compile it, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You need to make sure you're compiling with a C++ compiler as `bool` is a native
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Const keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython doesn''t understand the `const` keyword pre Cython 0.18, but we can
    work around this with the following typedefs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `const` keyword as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you're using Cython greater than or equal to 0.18, you can use `const` just
    as you would from C.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Cython inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython does not handle multiple `.pyx` files. So, Cython has another keyword
    and convention—`.pxi`. This is an extra include file that works just as C includes.
    All other Cython files get pulled into one file to make one Cython compilation.
    For this, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It's important to remember that this works as a C include and will put in place
    the code from the file to the point of the include.
  prefs: []
  type: TYPE_NORMAL
- en: Struct initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When declaring `struct,` you cannot do normal C initialization as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, you manually specify the fields more verbosely. So, when using structs,
    you should ensure to use memset or set each element explicitly before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Calling into pure Python modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can always call into some pure Python code (non-Cythoned), but you should
    always beware and use Python `disutils` to make sure the module is installed correctly
    outside of the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, we have seen some basic debugging using the cygdb wrapper. More importantly,
    we have examined some caveats and features of Cython. In the next chapter, we
    will see how we can bind C++ code and work with C++ constructs, such as templates
    and the STL library, in particular, directly from Cython. We will also see how
    the GIL can affect working with code in Cython and C/C++.
  prefs: []
  type: TYPE_NORMAL
