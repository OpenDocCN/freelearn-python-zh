- en: Chapter 4. Debugging Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 调试Cython
- en: Since Cython programs compile down to their native code, we cannot use the Python
    debugger to step through your code. We can, however, use GDB. **GNU Project Debugger**
    (**GDB**) is a cross platform debugger. Python plugin support was added in version
    7.0, which was used to add the Cython support into `gdb` as a simple script; this
    means that you can seamlessly step through the C/C++ code into Cython and back
    again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cython程序编译成原生代码，我们无法使用Python调试器逐步执行代码。然而，我们可以使用GDB。**GNU项目调试器**（**GDB**）是一个跨平台调试器。Python插件支持从版本7.0开始添加，这被用来将Cython支持添加到`gdb`中作为一个简单的脚本；这意味着你可以无缝地在C/C++代码和Cython之间逐步执行。
- en: When it comes to language binding, it's good practice to keep interfaces as
    simple as possible. This will make debugging much simpler until you are happy
    with your bindings in terms of resource management or stability. I will iterate
    over some GDB and caveats examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到语言绑定时，保持接口尽可能简单是一个好的做法。这将使调试变得简单，直到你对资源管理或稳定性方面的绑定满意。我将迭代一些GDB和注意事项的例子。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using GFB with Cython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GFB与Cython
- en: Cython caveats
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython注意事项
- en: Using GDB with Cython
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB与Cython
- en: 'To debug Cython, you need GDB >= 7.0\. On Mac OS X Xcode, build tools have
    moved to LLVM and lldb as respective debuggers. You can install `gdb` using homebrew:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试Cython，你需要GDB >= 7.0。在Mac OS X Xcode中，构建工具已移动到LLVM和lldb作为相应的调试器。你可以使用homebrew安装`gdb`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We cannot use the Python debugger since the Cython code is compiled down to
    C/C++. Therefore, when debugging without the Cython plugin, you will be stepping
    through the generated C/C++ code, which won't be helpful as it won't understand
    the context of the Cython program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cython代码编译成C/C++，我们无法使用Python调试器。因此，在没有Cython插件的情况下调试时，你将逐步执行生成的C/C++代码，这不会很有帮助，因为它不会理解Cython程序的环境。
- en: Running cygdb
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行cygdb
- en: 'Cygdb is installed as a part of Cython and is a wrapper over GDB (it invokes
    GDB with arguments to set up the Cython plugin). Before you can debug the Cython
    code, we need to generate the debugging information. Just like C/C++, we need
    to specify compiler options to generated debuggable code we can pass `–gdb` when
    invoking the Cython compiler:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Cygdb作为Cython的一部分安装，并且是GDB的包装器（它通过传递参数调用GDB以设置Cython插件）。在您能够调试Cython代码之前，我们需要生成调试信息。就像C/C++一样，我们需要指定编译器选项以生成可调试的代码，我们可以在调用Cython编译器时传递`–gdb`：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you start debugging on Debian, you need to install the Python debug
    information package and GDB as it is not installed with `build-essential`. To
    install these, run the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始在Debian上调试之前，您需要安装Python调试信息包和GDB，因为它们不是与`build-essential`一起安装的。要安装这些，请运行以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that you have GDB and the debug information generated, you can start the
    Cython debugger with this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了GDB和生成的调试信息，你可以使用以下命令启动Cython调试器：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you''re familiar with GDB, you can simply use all of the normal `gdb`
    commands. However, the whole point of `cygdb` is that we can use Cython commands,
    which we will see in use here with an explanation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了GDB，你就可以简单地使用所有的正常`gdb`命令。然而，`cygdb`的全部目的在于我们可以使用Cython命令，我们将在下面使用并解释：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you tab autocomplete `cy break`, you will see a list of symbols to which
    you can set a Cython break point. Next, we need to get the program running and
    continue to our break points as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Tab键自动完成`cy break`，你会看到一个可以设置Cython断点的符号列表。接下来，我们需要运行程序并继续到我们的断点，如下所示：
- en: '**(gdb) cy break func**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**(gdb) cy break func**'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have the break point set, we need to run the program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了断点，我们需要运行程序：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have hit the declaration of the `func` function, we can continue
    and do some introspection as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了`func`函数的声明，我们可以继续并做一些内省，如下所示：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `globals` command will show any of the global identifiers in the scope
    of the current frame, so we can see the `func` function and `classobj foobar`.
    We can inspect further by listing the code and step code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`globals`命令将显示当前帧作用域中的任何全局标识符，因此我们可以看到`func`函数和`classobj foobar`。我们可以通过列出代码和逐步执行代码来进一步检查：'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also step the code as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按照以下方式逐步执行代码：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can get fairly neat listings even from classes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以从类中获得相当整洁的列表：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can even see the backtrace of the current Python state:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以看到当前Python状态的后退跟踪：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The help can be found by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助信息可以通过运行以下命令找到：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I think you have got the idea! It's worth playing around, checking the help,
    and trying these for yourself to get the feel of debugging with cygdb. To get
    a good feel, you really need to practice with GDB and get comfortable with it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了！尝试一下，查看帮助文档，并亲自尝试这些，以获得使用 cygdb 进行调试的感觉。为了获得良好的感觉，你真的需要通过 GDB 练习并熟悉它。
- en: Cython caveats
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 注意事项
- en: There are some caveats worth noting while mixing C and the Python code when
    it comes to Cython. It's a good idea to refer to these when building something
    to be production ready.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合 C 和 Python 代码时，Cython 有一些需要注意的注意事项。在构建生产就绪的产品时，参考这些注意事项是个好主意。
- en: Type checking
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'You may have noticed that in the previous code examples, we were able to cast
    the `void *` pointer from `malloc` to our extension types using `malloc`. Cython
    supports some more advanced type checking as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的代码示例中，我们能够使用 `malloc` 将 `void *` 指针转换为我们的扩展类型，使用 `malloc`。Cython
    支持一些更高级的类型检查，如下所示：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In basic type casting, Cython supports `<type?>` for type checking:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本类型转换中，Cython 支持 `<type?>` 用于类型检查：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will do some type checking and throw an error if the type that is being
    cast is not a subclass of `char *`. So, in this case, it will pass; however, if
    you were to do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将进行类型检查，如果被转换的类型不是 `char *` 的子类，则会抛出错误。所以，在这种情况下，它会通过；然而，如果你要这样做：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will return an error (at runtime):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行时返回一个错误：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, this can add some more type safety to your Cython APIs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这可以为你的 Cython API 增加更多的类型安全性。
- en: Dereference operator (*)
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取引用运算符 (*)
- en: 'In Cython, we don''t have a dereference operator. For example, if you are passing
    a C array and length to a function, you can use pointer arithmetic to iterate
    and access elements of the array:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，我们没有取引用运算符。例如，如果你要将 C 数组和长度传递给一个函数，你可以使用指针算术来迭代和访问数组的元素：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Cython, we have to be a little more explicit by accessing element zero.
    Then, we increment the pointer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，我们必须通过访问元素零来稍微明确一些。然后，我们增加指针：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing really fancy here. You simply have to use `x[0]` if you want
    to dereference `int *x`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么特别之处。如果你想取消引用 `int *x`，你只需使用 `x[0]`。
- en: Python exceptions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 异常
- en: 'Another topic to look at is what happens if your Cython code propagates an
    exception to your C code. In the next chapter, we will cover how C++ native exceptions
    interact with Python, but we do not have this in C. Consider the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要关注的话题是，如果你的 Cython 代码将异常传播到 C 代码中会发生什么。在下一章中，我们将介绍 C++ 原生异常如何与 Python 交互，但在
    C 中我们没有这个。考虑以下代码：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This simply raises an exception back to C and gives the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将异常返回到 C，并给出以下内容：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, a warning was printed and no exception handling had occurred,
    so the program continues onto something else. This is because the plain `cdef`
    functions that do not return Python objects have no way for exceptions to be handled;
    and thus, a simple warning message is printed. If we want to control the behavior
    for C programs, we need to declare the exception on the Cython function prototype.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，打印了一个警告，但没有发生异常处理，所以程序继续执行其他操作。这是因为不返回 Python 对象的简单 `cdef` 函数没有处理异常的方法；因此，打印了一个简单的警告消息。如果我们想控制
    C 程序的行为，我们需要在 Cython 函数原型中声明异常。
- en: 'There are three forms for doing this. First, we can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种形式可以做到这一点。首先，我们可以这样做：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This makes the function throw an exception on the function returning `-1` at
    any point. This also causes the exception to be propagated to the caller; so,
    in Cython, we can do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数在返回 `-1` 时抛出异常。这也导致异常被传播到调用者；因此，在 Cython 中，我们可以这样做：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also use the *maybe* exception (as I would like to think of it), which
    looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 *maybe* 异常（正如我希望称呼它），其形式如下：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means that it may or may not be an error. Cython generates a call to `PyErr_Occurred`
    to perform verification from the C API. Lastly, we can use the wildcard:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它可能是一个错误，也可能不是。Cython 从 C API 生成对 `PyErr_Occurred` 的调用以执行验证。最后，我们可以使用通配符：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This then makes it always call `PyErr_Occurred`, which you can check via `PyErr_PrintEx`
    or via others at [http://docs.python.org/2/c-api/exceptions.html](http://docs.python.org/2/c-api/exceptions.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得它总是调用 `PyErr_Occurred`，你可以通过 `PyErr_PrintEx` 或其他方式在 [http://docs.python.org/2/c-api/exceptions.html](http://docs.python.org/2/c-api/exceptions.html)
    检查。
- en: Note that the function pointer declarations can also handle this in their prototype.
    Just make sure that the return type matches the exception type, which must be
    an enum, float, pointer-type, or constant expression; if this is not the case,
    you will get a confusing compilation error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数指针声明也可以在它们的原型中处理这个问题。只需确保返回类型与异常类型匹配，该类型必须是枚举、浮点、指针类型或常量表达式；如果不是这种情况，你将得到一个令人困惑的编译错误。
- en: C/C++ iterators
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C/C++ 迭代器
- en: 'Cython has more support for the C style `for` loops, and it can also perform
    further optimizations on the `range` function depending on how the iterator is
    declared. Generally, in Python, you simply do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 对 C 风格的 `for` 循环有更多支持，并且它还可以根据迭代器的声明方式对 `range` 函数进行进一步的优化。通常，在 Python
    中，你只需做以下操作：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is fine on PyObjects since they understand iterators, but C types do not
    have any of these abstractions. You need to do pointer arithmetic on your array
    types to access indexes. So, for example, first we can do the following with the
    `range` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 PyObjects 上是可行的，因为它们理解迭代器，但 C 类型没有这些抽象。你需要对你的数组类型进行指针运算以访问索引。例如，我们首先可以使用
    `range` 函数做以下操作：
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the range function is used on C types, such as the following example that
    uses `cdef int i`, it is optimized for real C array access. There are several
    other forms we can use. We could translate the loop into the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C 类型上使用范围函数时，例如以下使用 `cdef int i` 的示例，它针对实际的 C 数组访问进行了优化。我们还可以使用其他几种形式。我们可以将循环转换为以下形式：
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This looks a lot more like a normal Python `for` loop performing the iteration
    assigning `i`, the index data. There is also one last form that Cython introduces
    using the `for .. from` syntax. This looks like a real `for` loop from C, and
    we can now write:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更像是一个正常的 Python `for` 循环执行迭代，分配 `i`，索引数据。还有一个 Cython 引入的最后一个形式，使用 `for ..
    from` 语法。这看起来像真正的 C `for` 循环，我们现在可以写：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also introduce the step size:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以引入步长：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These extra `for` loop constructs are particularly useful when working a lot
    with C types because they do not understand extra Python constructs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的 `for` 循环结构在处理大量 C 类型时特别有用，因为它们不理解额外的 Python 结构。
- en: Boolean error
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔错误
- en: 'When you try and use `bool` in Cython, you will get the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试在 Cython 中使用 `bool` 时，你会得到以下结果：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, you need to use this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要使用这个：
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you compile it, you get the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译它时，你会得到以下结果：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You need to make sure you're compiling with a C++ compiler as `bool` is a native
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你使用的是 C++ 编译器进行编译，因为 `bool` 是一个原生类型。
- en: Const keyword
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Const 关键字
- en: 'Cython doesn''t understand the `const` keyword pre Cython 0.18, but we can
    work around this with the following typedefs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 在 0.18 之前不理解 `const` 关键字，但我们可以通过以下 typedefs 来解决这个问题：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can use the `const` keyword as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像以下这样使用 `const` 关键字：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you're using Cython greater than or equal to 0.18, you can use `const` just
    as you would from C.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Cython 0.18 或更高版本，你可以像从 C 那样使用 `const`。
- en: Multiple Cython inputs
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个 Cython 输入
- en: 'Cython does not handle multiple `.pyx` files. So, Cython has another keyword
    and convention—`.pxi`. This is an extra include file that works just as C includes.
    All other Cython files get pulled into one file to make one Cython compilation.
    For this, you need to do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 不处理多个 `.pyx` 文件。因此，Cython 有另一个关键字和约定——`.pxi`。这是一个额外的包含文件，它就像 C 包含文件一样工作。所有其他
    Cython 文件都会被拉入一个文件，以创建一个 Cython 编译。为此，你需要做以下操作：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's important to remember that this works as a C include and will put in place
    the code from the file to the point of the include.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这作为一个 C 包含文件工作，并将从文件中包含代码到包含点的代码放入。
- en: Struct initialization
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体初始化
- en: 'When declaring `struct,` you cannot do normal C initialization as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明 `struct` 时，你不能像以下这样进行正常的 C 初始化：
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You need to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做以下操作：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, you manually specify the fields more verbosely. So, when using structs,
    you should ensure to use memset or set each element explicitly before using it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你手动更详细地指定字段。所以，当使用结构体时，你应该确保在使用之前使用 memset 或显式设置每个元素。
- en: Calling into pure Python modules
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用纯 Python 模块
- en: You can always call into some pure Python code (non-Cythoned), but you should
    always beware and use Python `disutils` to make sure the module is installed correctly
    outside of the development environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以调用一些纯 Python 代码（非 Cython），但你应该始终保持警惕，并使用 Python `disutils` 确保模块在开发环境之外正确安装。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Overall, we have seen some basic debugging using the cygdb wrapper. More importantly,
    we have examined some caveats and features of Cython. In the next chapter, we
    will see how we can bind C++ code and work with C++ constructs, such as templates
    and the STL library, in particular, directly from Cython. We will also see how
    the GIL can affect working with code in Cython and C/C++.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们已经看到了使用cygdb包装器进行的一些基本调试。更重要的是，我们检查了一些Cython的注意事项和特性。在下一章中，我们将看到如何从Cython直接绑定C++代码以及如何与C++构造工作，例如模板和STL库，特别是。我们还将看到GIL如何影响在Cython和C/C++中与代码的工作。
