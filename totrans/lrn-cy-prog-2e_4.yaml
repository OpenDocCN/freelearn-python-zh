- en: Chapter 4. Debugging Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Cython programs compile down to their native code, we cannot use the Python
    debugger to step through your code. We can, however, use GDB. **GNU Project Debugger**
    (**GDB**) is a cross platform debugger. Python plugin support was added in version
    7.0, which was used to add the Cython support into `gdb` as a simple script; this
    means that you can seamlessly step through the C/C++ code into Cython and back
    again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to language binding, it's good practice to keep interfaces as
    simple as possible. This will make debugging much simpler until you are happy
    with your bindings in terms of resource management or stability. I will iterate
    over some GDB and caveats examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using GFB with Cython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython caveats
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GDB with Cython
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To debug Cython, you need GDB >= 7.0\. On Mac OS X Xcode, build tools have
    moved to LLVM and lldb as respective debuggers. You can install `gdb` using homebrew:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We cannot use the Python debugger since the Cython code is compiled down to
    C/C++. Therefore, when debugging without the Cython plugin, you will be stepping
    through the generated C/C++ code, which won't be helpful as it won't understand
    the context of the Cython program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Running cygdb
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cygdb is installed as a part of Cython and is a wrapper over GDB (it invokes
    GDB with arguments to set up the Cython plugin). Before you can debug the Cython
    code, we need to generate the debugging information. Just like C/C++, we need
    to specify compiler options to generated debuggable code we can pass `–gdb` when
    invoking the Cython compiler:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start debugging on Debian, you need to install the Python debug
    information package and GDB as it is not installed with `build-essential`. To
    install these, run the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that you have GDB and the debug information generated, you can start the
    Cython debugger with this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you''re familiar with GDB, you can simply use all of the normal `gdb`
    commands. However, the whole point of `cygdb` is that we can use Cython commands,
    which we will see in use here with an explanation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you tab autocomplete `cy break`, you will see a list of symbols to which
    you can set a Cython break point. Next, we need to get the program running and
    continue to our break points as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**(gdb) cy break func**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have the break point set, we need to run the program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have hit the declaration of the `func` function, we can continue
    and do some introspection as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `globals` command will show any of the global identifiers in the scope
    of the current frame, so we can see the `func` function and `classobj foobar`.
    We can inspect further by listing the code and step code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also step the code as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can get fairly neat listings even from classes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can even see the backtrace of the current Python state:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The help can be found by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I think you have got the idea! It's worth playing around, checking the help,
    and trying these for yourself to get the feel of debugging with cygdb. To get
    a good feel, you really need to practice with GDB and get comfortable with it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Cython caveats
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some caveats worth noting while mixing C and the Python code when
    it comes to Cython. It's a good idea to refer to these when building something
    to be production ready.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that in the previous code examples, we were able to cast
    the `void *` pointer from `malloc` to our extension types using `malloc`. Cython
    supports some more advanced type checking as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In basic type casting, Cython supports `<type?>` for type checking:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will do some type checking and throw an error if the type that is being
    cast is not a subclass of `char *`. So, in this case, it will pass; however, if
    you were to do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will return an error (at runtime):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, this can add some more type safety to your Cython APIs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Dereference operator (*)
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Cython, we don''t have a dereference operator. For example, if you are passing
    a C array and length to a function, you can use pointer arithmetic to iterate
    and access elements of the array:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Cython, we have to be a little more explicit by accessing element zero.
    Then, we increment the pointer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing really fancy here. You simply have to use `x[0]` if you want
    to dereference `int *x`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Python exceptions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another topic to look at is what happens if your Cython code propagates an
    exception to your C code. In the next chapter, we will cover how C++ native exceptions
    interact with Python, but we do not have this in C. Consider the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This simply raises an exception back to C and gives the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, a warning was printed and no exception handling had occurred,
    so the program continues onto something else. This is because the plain `cdef`
    functions that do not return Python objects have no way for exceptions to be handled;
    and thus, a simple warning message is printed. If we want to control the behavior
    for C programs, we need to declare the exception on the Cython function prototype.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three forms for doing this. First, we can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This makes the function throw an exception on the function returning `-1` at
    any point. This also causes the exception to be propagated to the caller; so,
    in Cython, we can do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also use the *maybe* exception (as I would like to think of it), which
    looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This means that it may or may not be an error. Cython generates a call to `PyErr_Occurred`
    to perform verification from the C API. Lastly, we can use the wildcard:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This then makes it always call `PyErr_Occurred`, which you can check via `PyErr_PrintEx`
    or via others at [http://docs.python.org/2/c-api/exceptions.html](http://docs.python.org/2/c-api/exceptions.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function pointer declarations can also handle this in their prototype.
    Just make sure that the return type matches the exception type, which must be
    an enum, float, pointer-type, or constant expression; if this is not the case,
    you will get a confusing compilation error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ iterators
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython has more support for the C style `for` loops, and it can also perform
    further optimizations on the `range` function depending on how the iterator is
    declared. Generally, in Python, you simply do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is fine on PyObjects since they understand iterators, but C types do not
    have any of these abstractions. You need to do pointer arithmetic on your array
    types to access indexes. So, for example, first we can do the following with the
    `range` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the range function is used on C types, such as the following example that
    uses `cdef int i`, it is optimized for real C array access. There are several
    other forms we can use. We could translate the loop into the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This looks a lot more like a normal Python `for` loop performing the iteration
    assigning `i`, the index data. There is also one last form that Cython introduces
    using the `for .. from` syntax. This looks like a real `for` loop from C, and
    we can now write:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also introduce the step size:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These extra `for` loop constructs are particularly useful when working a lot
    with C types because they do not understand extra Python constructs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Boolean error
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you try and use `bool` in Cython, you will get the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, you need to use this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you compile it, you get the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You need to make sure you're compiling with a C++ compiler as `bool` is a native
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Const keyword
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython doesn''t understand the `const` keyword pre Cython 0.18, but we can
    work around this with the following typedefs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can use the `const` keyword as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you're using Cython greater than or equal to 0.18, you can use `const` just
    as you would from C.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Cython inputs
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cython does not handle multiple `.pyx` files. So, Cython has another keyword
    and convention—`.pxi`. This is an extra include file that works just as C includes.
    All other Cython files get pulled into one file to make one Cython compilation.
    For this, you need to do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's important to remember that this works as a C include and will put in place
    the code from the file to the point of the include.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Struct initialization
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When declaring `struct,` you cannot do normal C initialization as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You need to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, you manually specify the fields more verbosely. So, when using structs,
    you should ensure to use memset or set each element explicitly before using it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Calling into pure Python modules
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can always call into some pure Python code (non-Cythoned), but you should
    always beware and use Python `disutils` to make sure the module is installed correctly
    outside of the development environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, we have seen some basic debugging using the cygdb wrapper. More importantly,
    we have examined some caveats and features of Cython. In the next chapter, we
    will see how we can bind C++ code and work with C++ constructs, such as templates
    and the STL library, in particular, directly from Cython. We will also see how
    the GIL can affect working with code in Cython and C/C++.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们已经看到了使用cygdb包装器进行的一些基本调试。更重要的是，我们检查了一些Cython的注意事项和特性。在下一章中，我们将看到如何从Cython直接绑定C++代码以及如何与C++构造工作，例如模板和STL库，特别是。我们还将看到GIL如何影响在Cython和C/C++中与代码的工作。
