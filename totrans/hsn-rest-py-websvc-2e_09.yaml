- en: Developing RESTful APIs with Pyramid 1.10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with Pyramid 1.10 to create a RESTful Web API
    that performs CRUD operations on a simple data source. We will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a simple data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the virtual environment with Pyramid 1.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new Pyramid project based on a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a dictionary as a repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Marshmallow schema to validate, serialize, and deserialize the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with view callables and view configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and configure view handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the API with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a simple data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A surfer who won dozens of international surfing competitions became a surfing
    coach and wants to build a new tool to help surfers train for the Olympic Games.
    The development team that works with the surfing coach has years of experience
    working with the Pyramid web framework, and therefore, he wants us to build a
    simple RESTful API with Pyramid to work with the data provided by an IoT board
    connected to multiple sensors in the surfboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each IoT board will provide the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**: Many wearable wireless sensors embedded in each surfer''s wetsuit
    and other sensors included in the surfboard will provide data, and the IoT board
    will perform a real-time analysis to indicate ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the virtual environment with Pyramid 1.10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml), *Developing RESTful
    APIs and Microservices with Flask 1.0.2*, we learned that, throughout this book,
    we were going to work with the lightweight virtual environments that were introduced
    and improved on in Python 3.4\. Now, we will follow many steps to create a new
    lightweight virtual environment to work with Pyramid 1.10\. It is highly recommended
    to read the section named *Working with lightweight virtual environments* in [Chapter
    1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),Â *Developing RESTful APIs and Microservices
    with Flask 1.0.2*, if you don't have experience with lightweight virtual environments
    in modern Python. This chapter includes all the detailed explanations about the
    effects of the steps we are going to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands assume that you have Python 3.6.6 installed on Linux,
    macOS, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to select the target folder or directory for our lightweight
    virtual environment. The following is the path we will use in the example for
    Linux and macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The target folder for the virtual environment will be the `HillarPythonREST2/Pyramid01`
    folder within our home directory. For example, if our home directory in macOS
    or Linux is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/HillarPythonREST2/Pyramid01`.
    You can replace the specified path with your desired path in each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the path we will use in the example for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The target folder for the virtual environment will be the `HillarPythonREST2\Pyramid01`
    folder within our user profile folder. For example, if our user profile folder
    is `C:\Users\gaston`, the virtual environment will be created within `C:\Users\gaston\HillarPythonREST2\Pyramid01`.
    Of course, you can replace the specified path with your desired path in each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows PowerShell, the previous path would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to use the `-m` option followed by the `venv` module name and
    the desired path to make Python run this module as a script and create a virtual
    environment at the specified path. The instructions are different depending on
    the platform in which we are creating the virtual environment. Thus, make sure
    you follow the instructions for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal in Linux or macOS and execute the following command to create
    a virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, execute the following command in the Command Prompt to create a
    virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to work with Windows PowerShell, execute the following command
    to create a virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands don't produce any output. Now that we have created a virtual
    environment, we will run a platform-specific script to activate it. After we activate
    the virtual environment, we will install packages that will only be available
    in this virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use the `fish` shell, run the following command
    to activate the virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the Command
    Prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have script
    execution enabled in Windows PowerShell to be able to run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After you activate the virtual environment, the command prompt will display
    the virtual environment's root folder name, enclosed in parenthesis as a prefix
    of the default prompt, to remind us that we are working in the virtual environment.
    In this case, we will see (`Pyramid01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Pyramid01`.
  prefs: []
  type: TYPE_NORMAL
- en: We have followed the necessary steps to create and activate a virtual environment.
    Now, we will create a `requirements.txt` file to specify the set of packages that
    our application requires to be installed on any supported platform. This way,
    it will be extremely easy to repeat the installation of the specified packages
    with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to create a new text file named `requirements.txt`
    within the root folder for the recently created virtual environment. The following
    lines show the contents for the file that declares the packages and the versions
    that our API requires. The code file for the sample is included in the `restful_python_2_11_01`
    folder, in the `Pyramid01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the `requirements.txt` file indicates the package and the version
    that needs to be installed. In this case, we are working with exact versions by
    using the `==` operator because we want to make sure that the specified version
    is installed. The following table summarizes the packages and the version numbers
    that we specified as requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `pyramid` | 1.10.1 |'
  prefs: []
  type: TYPE_TB
- en: '| `cookiecutter` | 1.6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `httpie` | 1.0.2 |'
  prefs: []
  type: TYPE_TB
- en: The `cookiecutter` package installs a command-line utility that makes it possible
    to create Pyramid projects from project templates. We will use this utility to
    create a basic Pyramid 1.10 project and then make the necessary changes to build
    our RESTful API without writing all the code from scratch. Notice that we will
    install additional packages later by specifying additional required packages in
    the Pyramid `setup.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the root folder for the virtual environment: `Pyramid01`. In macOS or
    Linux, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows Command Prompt, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows PowerShell, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the packages and the versions explained in the previous table with `pip` by using
    the recently created `requirements.txt` file. Make sure you are located in the
    folder that contains the `requirements.txt` file before running the command (`Pyramid01`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that `pyramid`, `cookiecutter`,
    `httpie`, and their dependencies have been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Pyramid project based on a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will generate a Pyramid project by using an app template, also known
    as **scaffold**. Notice that you need Git installed on your development computer
    to use the next command. You can visit the following web page for more information
    about Git: [https://git-scm.com](https://git-scm.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to use `cookiecutter` to generate a new project based
    on the `pyramid-cookiecutter-starter` template. We use the `--checkout 1.10-branch`
    option to use a specific branch that makes sure that the template is compatible
    with Pyramid 1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The command will ask you for the project's name. Enter `metrics` and press *Enter*.
    You will see a ...
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a simple `SurfboardMetricModel` class that we will use to
    represent metrics. Remember that we won't be persisting the model in any database
    or file, and therefore, in this case, our class will just provide the required
    attributes and no mapping information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `models` subfolder within the `metrics/metrics` folder. Then,
    create a new `metrics.py` file in the `metrics/metrics/models` subfolder. The
    following lines show the code that declares the necessary imports that we will
    require for many classes. This will then create a `SurfboardMetricModel` class
    in this file. The code file for the sample is included in the `restful_python_2_09_01`
    folder, in the `Pyramid01/metrics/metrics/models/metrics.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SurfboardMetricModel` class just declares a constructor; that is, the
    `__init__` method. This method receives many arguments and uses them to initialize
    the attributes with the same names: `status`, `speed_in_mph`, `altitude_in_feet`,
    and `water_temperature_in_f`. The `id` attribute is set to `0`. We will automatically
    increment the identifier for each new surfboard metric generated with an API call.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a dictionary as a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a `SurfboardMetricManager` class that we will use to persist
    the `SurfboardMetricModel` instances in an in-memory dictionary. Our API methods
    will call methods for the `SurfboardMetricManager` class to retrieve, insert,
    and delete `SurfboardMetricModel` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `metrics.py` file in the `metrics/metrics/models` subfolder. Add
    the following lines to declare the `SurfboardMetricManager` class. The code file
    for the sample is included in the `restful_python_2_09_01` folder, in the `Pyramid01/metrics/metrics/models/metrics.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Marshmallow schema to validate, serialize, and deserialize the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a simple Marshmallow schema that we will use to validate,
    serialize, and deserialize the previously declared `SurfboardMetricModel` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `metrics.py` file in the `metrics/metrics/models` subfolder. Add
    the following lines to declare `SurferStatus Enum` and the `SurfboardMetricSchema`
    class. The code file for the sample is included in the `restful_python_2_09_01`
    folder, in the `Pyramid01/metrics/metrics/models/metrics.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, the code declares the `SurferStatus Enum` that we will use to map description
    to an integer for the surfer status. We want the users of the API to be able to
    specify the status as a string that matches one of the `Enum` descriptions. For
    example, if the user wants to create a new metric with its status set to `SurferStatus.PADDLING`,
    they should use `'PADDLING'` as the value for the status key in the provided JSON
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code declares the `SurfboardMetricSchema` class as a subclass of the
    `marshmallow.Schema` class. We declare the attributes that represent fields as
    instances of the appropriate classes declared in the `marshmallow.fields` module.
    Whenever we specify the `True` value for the `dump_only` argument, it means that
    we want the field to be read-only. For example, we won't be able to provide a
    value for the `id` field in the schema. The value for this field will be automatically
    generated by the `SurfboardMetricManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `SurfboardMetricSchema` class declares the `status` attribute as an instance
    of the `marshmallow_enum.EnumField` class. The `enum` argument is set to `SurferStatus`
    to specify that only the members of this `Enum` will be considered valid values.
    As a result of this setting, only a string that matches the descriptions in `SurferStatus
    Enum` will be accepted as a valid value for this field during deserialization.
    In addition, whenever this field is serialized, the string representation of the
    `Enum` description will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `speed_in_mph`, `altitude_in_feet`, and `water_temperature_in_f` attributes
    are instances of the `fields.Integer` class, with the `required` argument set
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with view callables and view configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our RESTful API won't be using the two modules included in the `metrics/metrics/views`
    subfolder that was generated by the app template. Thus, we must delete the `metrics/metrics/views/default.py`
    and `metrics/metrics/views/notfound.py` files.
  prefs: []
  type: TYPE_NORMAL
- en: Pyramid uses view callables as the main building blocks for a RESTful API. Whenever
    a request arrives, Pyramid finds and invokes the appropriate view callable to
    process the request and return an appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: View callables are callable Python objects such as functions, classes, or instances
    that implement a `__call__` method. Any view callable receives an argument named
    `request` that will provide the `pyramid.request.Request` instance that represents
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and configuring view handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the function that we want to be executed for each
    combination of HTTP verb and scope, and the route name that identifies each resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Route name | Function |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of metrics | `''metrics''` | `metrics_collection` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Metric | `''metric''` | `metric` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of metrics | `''metrics''` | `metrics_collection` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Metric | `''metrics''` | `metric` |'
  prefs: []
  type: TYPE_TB
- en: We must make the necessary resource routing configurations to call the appropriate
    functions, pass them all the necessary arguments by defining the appropriate routes,
    and match the appropriate view callable with the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will check how the application template we used configures and returns
    a Pyramid WSGI application that will run our RESTful API. The following lines
    show the code for the `__init__.py` file within the `metrics/metrics` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have already removed the usage of the `jinja2` template, and therefore remove
    the highlighted line from the previous code. The code file for the sample is included
    in the `restful_python_2_09_01` folder, in the `Pyramid01/metrics/metrics/__init__.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a `main` function that creates a `pyramid.config.Configurator`
    instance named `config`, with the `settings` received as an argument. The `main`
    function calls the `config.include` method with `'.routes'` as an argument to
    include the configuration callable that accepts a single argument named `config`
    from the `routes` module. This callable will receive the instance of `Configurator`
    in the `config` argument and will be able to call its methods to perform the appropriate
    configuration for routes. We will replace the existing code for the `routes` module
    after we finish analyzing the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the `config.scan` method to scan the Python packages and
    subpackages for callables that have specific decorator objects that perform configurations,
    such as the functions that we declared with the `@view.config` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `config.make_wsgi_app` method to commit any pending
    configuration statements and return the Pyramid WSGI application that represent
    the committed configuration state. This way, Pyramid completes with the configuration
    process and launches the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `routes.py` file within the `metrics/metrics` folder and
    replace the existing code with the following lines. The code file for the sample
    is included in the `restful_python_2_09_01` folder, in the `Pyramid01/metrics/metrics/routes.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code defines an `includeme` function which receives the previously explained
    `pyramid.config.Configurator` instances in the `config` argument. First, the code
    calls the `config.add_route` method twice to associate the route named `'metrics'`
    with the `'/metrics/'` pattern and the route named `'metric'` with the `'metrics/{id:\d+}/'`
    pattern. Notice that the semicolon (`:`) after `id` is followed by a regular expression
    that makes sure that `id` is only composed of digits.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the `config.add_view` method twice to specify the view
    callable `metrics_collection` as the function that must be called when the route
    name is equal to `'metrics'` and the view callable `metric` as the function that
    must be called when the route name is equal to `'metric'`. In both cases, the
    `config.add_view` method specifies that we want to use `'json'` as the renderer
    for the responses.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the API with command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `metrics/development.ini` file is a settings file that defines the Pyramid
    app and server configuration for the development environment. As happens in most
    `.ini` files, the configuration settings are organized in sections. For example,
    the `[server:main]` section specifies the value for the listen setting as `localhost:6543`
    to make the `waitress` server `listen` on port `6543` and bind it to the localhost
    address.
  prefs: []
  type: TYPE_NORMAL
- en: This file was included when we created a new app based on a template. Open the
    `metrics/development.ini` file and locate the following line that specifies the
    `bool` value for the `pyramid.debug_routematch` setting. The code file for the
    sample is included in the `restful_python_2_09_01 ...`
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: In Pyramid, view callables are which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python objects such as functions, classes, or instances that implement a `__call__`
    method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes that inherit from the `pyramid.views.Callable` superclass
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Instances of the `pyramid.views.Callable` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `request` argument that any view callable receives represents an HTTP request,
    and is an instance of which of the following classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pyramid.web.Request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pyramid.request.Request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pyramid.callable.Request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following attributes allows us to specify the status code for the
    response in a `pyramid.response.Response` instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`status`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_status_code`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`status_code`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following classes, declared in the `pyramid.httpexceptions` module,
    represent an HTTP `201 Created` status code for a response?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HTTP_201_Created`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HTTP_Created`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HTTPCreated`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following attributes allows us to specify the response body for
    a JSON response in a `pyramid.response.Response` instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`json_body`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`body`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`body_as_json`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with a simple data source
    with Pyramid 1.10\. We defined the requirements for our API and understood the
    tasks performed by each HTTP method. We set up a virtual environment with Pyramid,
    built a new application from an existing template, and added additional required
    packages to the Pyramid application.
  prefs: []
  type: TYPE_NORMAL
- en: We created a class that represented a surfboard metric, and additional classes
    to make it possible to generate a simple data source to allow us to focus on specific
    Pyramid features to build a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: We then created a Marshmallow schema to validate, serialize, and deserialize
    the metric model. Then, we started working with view callable functions to process
    specific HTTP ...
  prefs: []
  type: TYPE_NORMAL
