- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introduction to Algorithm Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法设计简介
- en: The objective of this chapter is to understand the principles of designing algorithms,
    and the importance of analyzing algorithms in solving real-world problems. Given
    input data, an algorithm is a step-by-step set of instructions that should be
    executed in sequence to solve a given problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解算法设计的原理，以及在解决现实世界问题中分析算法的重要性。给定输入数据，算法是一系列按顺序执行的指令，用于解决给定的问题。
- en: In this chapter, we will also learn how to compare different algorithms and
    determine the best algorithm for the given use-case. There can be many possible
    correct solutions for a given problem, for example, we can have several algorithms
    for the problem of sorting *n* numeric values. So, there is no one algorithm to
    solve any real-world problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将学习如何比较不同的算法，并确定给定用例的最佳算法。对于给定的问题，可能有多种可能的正确解决方案，例如，对于排序*n*个数值的问题，我们可以有几种算法。因此，没有一种算法可以解决任何现实世界的问题。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Introducing algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的介绍
- en: Performance analysis of an algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法性能分析
- en: Asymptotic notation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐近符号
- en: Amortized analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源化分析
- en: Choosing complexity classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择复杂度类别
- en: Computing the running time complexity of an algorithm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算算法的运行时间复杂度
- en: Introducing algorithms
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的介绍
- en: An algorithm is a sequence of steps that should be followed in order to complete
    a given task/problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是一系列应按顺序遵循的步骤，以完成给定的任务/问题。
- en: It is a well-defined procedure that takes input data, processes it, and produces
    the desired output. A representation of this is shown in *Figure 2.1*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个定义良好的过程，它接受输入数据，处理它，并产生所需的输出。*图2.1*展示了这一过程的表示。
- en: '![](img/B17217_02_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_02_01.png)'
- en: 'Figure 2.1: Introduction to algorithms'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：算法介绍
- en: 'Summarized below are some important reasons for studying algorithms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些研究算法的重要理由的总结：
- en: Essential for computer science and engineering
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学与工程的基本要素
- en: Important in many other domains (such as computational biology, economics, ecology,
    communications, ecology, physics, and so on)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多其他领域（如计算生物学、经济学、生态学、通信、物理学等）都很重要
- en: They play a role in technology innovation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在技术创新中扮演着角色
- en: They improve problem-solving and analytical thinking
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了解决问题的能力和分析思维能力
- en: 'There are two aspects that are of prime importance in solving a given problem.
    Firstly, we need an efficient mechanism to store, manage, and retrieve data, which
    is required to solve a problem (this comes under data structures); secondly, we
    require an efficient algorithm that is a finite set of instructions to solve that
    problem. Thus, the study of data structures and algorithms is key to solving any
    problem using computer programs. An efficient algorithm should have the following
    characteristics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决给定问题时，有两个方面非常重要。首先，我们需要一个有效的机制来存储、管理和检索数据，这是解决问题所必需的（这属于数据结构）；其次，我们需要一个有效的算法，它是一组有限的指令，用于解决问题。因此，数据结构和算法的研究对于使用计算机程序解决任何问题都是关键。一个有效的算法应具有以下特点：
- en: It should be as specific as possible
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应尽可能具体
- en: It should have each instruction properly defined
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条指令都应有明确的定义
- en: There should not be any ambiguous instructions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应有任何含糊不清的指令
- en: All the instructions of the algorithm should be executable in a finite amount
    of time and in a finite number of steps
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的所有指令应在有限的时间内和有限步骤内可执行
- en: It should have clear input and output to solve the problem
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应有清晰的输入和输出以解决问题
- en: Each instruction of the algorithm should be integral in solving the given problem
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的每一条指令都应完整地解决给定的问题
- en: 'Consider an example of an algorithm (an analogy) to complete a task in our
    daily lives; let us take the example of preparing a cup of tea. The algorithm
    to prepare a cup of tea can include the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们日常生活中完成一项任务的算法（一个类比）为例，让我们以准备一杯茶为例。准备一杯茶的算法可以包括以下步骤：
- en: Pour water into the pan
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把水倒入锅中
- en: Put the pan on the stove and light the stove
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把锅放在炉子上并点燃炉子
- en: Add crushed ginger to the warming water
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在温热的水中加入捣碎的姜
- en: Add tea leaves to the pan
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在锅中加入茶叶
- en: Add milk
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入牛奶
- en: When it starts boiling, add sugar to it
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它开始沸腾时，加入糖
- en: After 2-3 minutes, the tea can be served
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2-3分钟后，茶可以上桌
- en: The above procedure is one of the possible ways to prepare tea. In the same
    way, the solution to a real-world problem can be converted into an algorithm,
    which can be developed into computer software using a programming language. Since
    it is possible to have several solutions for a given problem, it should be as
    efficient as possible when it is to be implemented using software. Given a problem,
    there may be more than one correct algorithm, defined as the one that produces
    exactly the desired output for all valid input values. The costs of executing
    different algorithms may be different; it may be measured in terms of the time
    required to run the algorithm on a computer system and the memory space required
    for it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序是准备茶的一种可能方法。同样，现实世界问题的解决方案可以转化为算法，这些算法可以使用编程语言开发成计算机软件。由于对于给定的问题可能有多个解决方案，因此当它需要用软件实现时，应该尽可能高效。给定一个问题，可能有多个正确的算法，定义为对所有有效输入值产生精确期望输出的算法。执行不同算法的成本可能不同；它可能以在计算机系统上运行算法所需的时间和所需的内存空间来衡量。
- en: 'There are primarily two things that one should keep in mind while designing
    an efficient algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计高效算法时，应该主要注意以下两点：
- en: The algorithm should be correct and should produce the results as expected for
    all valid input values
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法应该是正确的，并且对于所有有效输入值应该产生预期的结果
- en: The algorithm should be optimal in the sense that it should be executed on the
    computer within the desired time limit, in line with an optimal memory space requirement
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法应该在计算机上以期望的时间限制和最优的内存空间要求执行
- en: Performance analysis of the algorithm is very important for deciding the best
    solution for a given problem. If the performance of an algorithm is within the
    desired time and space requirements, it is optimal. One of the most popular and
    common methods of estimating the performance of an algorithm is through analyzing
    its complexity. Analysis of the algorithm helps us to determine which one is most
    efficient in terms of the time and space consumed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的性能分析对于决定给定问题的最佳解决方案非常重要。如果一个算法的性能在期望的时间和空间要求范围内，那么它是最优的。估计算法性能最流行和常见的方法之一是通过分析其复杂性。算法分析帮助我们确定在时间和空间消耗方面哪个算法最有效。
- en: Performance analysis of an algorithm
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的性能分析
- en: The performance of an algorithm is generally measured by the size of its input
    data, *n*, and the time and the memory space used by the algorithm. The time required
    is measured by the key operations to be performed by the algorithm (such as comparison
    operations), where key operations are instructions that take a significant amount
    of time during execution. Whereas the space requirement of an algorithm is measured
    by the memory needed to store the variables, constants, and instructions during
    the execution of the program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的性能通常是通过其输入数据的大小，*n*，以及算法使用的时间和内存空间来衡量的。所需的时间是通过算法需要执行的关键操作（如比较操作）来衡量的，其中关键操作是在执行过程中占用大量时间的指令。而算法的空间需求是通过在程序执行过程中存储变量、常量和指令所需的内存来衡量的。
- en: Time complexity
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间复杂度
- en: The time complexity of the algorithm is the amount of time that an algorithm
    will take to execute on a computer system to produce the output. The aim of analyzing
    the time complexity of the algorithm is to determine, for a given problem and
    more than one algorithm, which one of the algorithms is the most efficient with
    respect to the time required to execute. The running time required by an algorithm
    depends on the input size; as the input size, *n*, increases, the runtime also
    increases. Input size is measured as the number of items in the input, for example,
    the input size for a sorting algorithm will be the number of items in the input.
    So, a sorting algorithm will have an increased runtime to sort a list of input
    size 5,000 than that of a list of input size 50.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的时间复杂度是指算法在计算机系统上执行以产生输出所需的时间量。分析算法时间复杂度的目的是确定，对于给定的问题和多个算法，哪个算法在执行所需的时间方面是最有效的。算法所需的运行时间取决于输入大小；随着输入大小，*n*，的增加，运行时间也会增加。输入大小是输入中项目数量的度量，例如，排序算法的输入大小将是输入中的项目数量。因此，排序算法在排序大小为5,000的输入列表时所需的运行时间将大于排序大小为50的输入列表时的运行时间。
- en: The runtime of an algorithm for a specific input depends on the key operations
    to be executed in the algorithm. For example, the key operation for a sorting
    algorithm is a comparison operation that will take up most of the runtime, compared
    to assignment or any other operation. Ideally, these key operations should not
    depend upon the hardware, the operating system, or the programming language being
    used to implement the algorithm.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定输入的算法运行时间取决于算法中要执行的关键操作。例如，排序算法的关键操作是比较操作，它将占用大部分运行时间，与赋值或其他操作相比。理想情况下，这些关键操作不应依赖于硬件、操作系统或用于实现算法的编程语言。
- en: 'A constant amount of time is required to execute each line of code; however,
    each line may take a different amount of time to execute. In order to understand
    the running time required for an algorithm, consider the below code as an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行每行代码需要恒定的时间；然而，每行代码的执行时间可能不同。为了理解算法所需的运行时间，以下代码作为示例：
- en: '| **Code** | **Time required (Cost)** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **所需时间（成本）** |'
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Here, in statement 1 of the above example, if the condition is true then `"data"`
    will be printed, and if the condition is not true then the `for` loop will execute
    `n` times. The time required by the algorithm depends on the time required for
    each statement, and how many times a statement is executed. The running time of
    the algorithm is the sum of time required by all the statements. For the above
    code, assume statement 1 takes `c1` amount of time, statement 2 takes `c2` amount
    of time, and so on. So, if the *i*^(th) statement takes a constant amount of time
    *c*[i]and if the *i*^(th) statement is executed `n` times, then it will take *c*[i]*n*
    time. The total running time `T(n)` of the algorithm for a given value of *n*
    (assuming the value of *n* is not zero or three) will be as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例的第1条语句中，如果条件为真，则打印`"data"`，如果条件不为真，则`for`循环将执行`n`次。算法所需的时间取决于每个语句所需的时间以及语句执行的次数。算法的运行时间是所有语句所需时间的总和。对于上述代码，假设第1条语句需要`c1`时间，第2条语句需要`c2`时间，依此类推。因此，如果第*i*条语句需要恒定的时间*c*[i]，并且如果第*i*条语句执行了`n`次，那么它将需要*c*[i]*n*时间。对于给定的*n*值（假设*n*不为零或三）的算法的总运行时间`T(n)`如下。
- en: '*T*(*n*) = *c*[1] + *c*[3] + *c*[4] x *n* + *c*[5] x *n*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*n*) = *c*[1] + *c*[3] + *c*[4] x *n* + *c*[5] x *n*'
- en: If the value of `n` is equal to zero or three, then the time required by the
    algorithm will be as follows.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`的值等于零或三，那么算法所需的时间如下。
- en: '*T*(*n*) = *c*[1] + *c*[2]'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*n*) = *c*[1] + *c*[2]'
- en: Therefore, the running time required for an algorithm also depends upon what
    input is given in addition to the size of the input given. For the given example,
    the best case will be when the input is either zero or three, and in that case,
    the running time of the algorithm will be constant. In the worst case, the value
    of `n` is not equal to zero or three, then, the running time of the algorithm
    can be represented as *a* x *n* + *b*. Here, the values of `a` and `b` are constants
    that depend on the statement costs, and the constant times are not considered
    in the final time complexity. In the worst case, the runtime required by the algorithm
    is a linear function of *n*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法所需的运行时间不仅取决于输入的大小，还取决于输入的内容。对于给定的例子，最佳情况是输入为零或三，在这种情况下，算法的运行时间将是常数。在最坏的情况下，`n`的值不等于零或三，那么，算法的运行时间可以表示为
    *a* x *n* + *b*。在这里，`a`和`b`的值是依赖于语句成本的常数，并且常数时间不计入最终的时间复杂度。在最坏的情况下，算法所需的运行时间是`n`的线性函数。
- en: 'Let us consider another example, linear search:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，线性搜索：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output in this instance will be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，输出结果如下：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **worst-case running time** of the algorithm is the upper-bound complexity;
    it is the maximum runtime required for an algorithm to execute for any given input.
    The worst-case time complexity is very useful in that it guarantees that for any
    input data, the runtime required will not take more time as compared to the worst-case
    running time. For example, in the linear search problem, the worst case occurs
    when the element to be searched is found in the last comparison or not found in
    the list. In this case, the running time required will linearly depend upon the
    length of the list, whereas, in the best case, the search element will be found
    in the first comparison.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的**最坏运行时间**是上界复杂度；它是算法对任何给定输入执行所需的最大运行时间。最坏情况的时间复杂度非常有用，因为它保证了对于任何输入数据，所需的运行时间不会比最坏运行时间长。例如，在线性搜索问题中，最坏情况发生在要搜索的元素在最后一次比较中找到或未在列表中找到。在这种情况下，所需的运行时间将线性依赖于列表的长度，而在最佳情况下，搜索元素将在第一次比较中找到。
- en: The **average-case running time** is the average running time required for an
    algorithm to execute. In this analysis, we compute the average over the running
    time for all possible input values. Generally, probabilistic analysis is used
    to analyze the average-case running time of an algorithm, which is computed by
    averaging the cost over the distribution of all the possible inputs. For example,
    in the linear search, the number of comparisons at all positions would be 1 if
    the element to be searched was found at the 0^(th) index; and similarly, the number
    of comparisons would be 2, 3, and so forth, up to `n`, respectively, for elements
    found at the `1, 2, 3, … (`*n*`-1)` index positions. Thus, the average-case running
    time will be as follows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均运行时间**是算法执行所需的平均运行时间。在这个分析中，我们计算所有可能输入值的运行时间的平均值。通常，概率分析用于分析算法的平均运行时间，这是通过对所有可能输入的分布的平均成本来计算的。例如，在线性搜索中，如果要搜索的元素在0^(th)索引处找到，则所有位置的比较次数将为1；同样，对于在`1,
    2, 3, … (`*n*`-1)`索引位置找到的元素，比较次数将分别为2，3，等等，直到`n`。因此，平均运行时间将如下所示。'
- en: '![](img/B17217_02_001.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_001.png)'
- en: For average-case, the running time required is also linearly dependent upon
    the value of *n*. However, in most real-world applications, worst-case analysis
    is mostly used, since it gives a guarantee that the running time will not take
    any longer than the worst-case running time of the algorithm for any input value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平均情况，所需的运行时间也线性依赖于*n*的值。然而，在大多数实际应用中，最坏情况分析主要使用，因为它保证了对于任何输入值，运行时间不会比算法的最坏运行时间长。
- en: '**Best-case running time** is the minimum time needed for an algorithm to run;
    it is the lower bound on the running time required for an algorithm; in the example
    above, the input data is organized in such a way that it takes its minimum running
    time to execute the given algorithm.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳运行时间**是算法运行所需的最短时间；它是算法运行时间的下界；在上面的例子中，输入数据以这种方式组织，使得执行给定算法所需的最短运行时间。'
- en: Space complexity
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间复杂度
- en: The space complexity of the algorithm estimates the memory requirement to execute
    it on a computer to produce the output as a function of input data. The memory
    space requirement of an algorithm is one of the criteria used to decide how efficient
    it is. While executing the algorithm on the computer system, storage of the input
    is required, along with intermediate and temporary data in data structures, which
    are stored in the memory of the computer. In order to write a programming solution
    for any problem, some memory is required for storing variables, program instructions,
    and executing the program on the computer. The space complexity of an algorithm
    is the amount of memory required for executing and producing the result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的空间复杂度估计了在计算机上执行它以产生输出所需的内存需求，这取决于输入数据。算法的内存空间需求是决定其效率的几个标准之一。在计算机系统上执行算法时，需要存储输入，以及数据结构中的中间和临时数据，这些数据存储在计算机的内存中。为了编写任何问题的编程解决方案，需要一些内存来存储变量、程序指令以及在计算机上执行程序。算法的空间复杂度是执行和产生结果所需的内存量。
- en: For computing the space complexity, consider the following example, in which,
    given a list of integer values, the function returns the square value of the corresponding
    integer number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算空间复杂度，考虑以下示例，其中，给定一个整数值的列表，该函数返回相应整数的平方值。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the code is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出为：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above code, the algorithm will require allocating memory for the number
    of items in the input list. Say the number of elements in the input is `n`, then
    the space requirement increases with the input size, therefore, the space complexity
    of the algorithm becomes `O(n)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，算法将需要为输入列表中的项目数量分配内存。假设输入中的元素数量为 `n`，那么随着输入大小的增加，空间需求也会增加，因此，算法的空间复杂度变为
    `O(n)`。
- en: Given two algorithms to solve a given problem, with all other requirements being
    equal, then the algorithm that requires less memory can be considered more efficient.
    For example, suppose there are two search algorithms, one has `O(n)` and another
    algorithm has `O(nlogn)` space complexity. The first algorithm is the better algorithm
    as compared to the second with respect to the space requirements. Space complexity
    analysis is important to understand the efficiency of an algorithm, especially
    for applications where the memory space requirement is high.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个算法来解决给定的问题，在其他所有要求相同的情况下，需要较少内存的算法可以被认为是更有效的。例如，假设有两个搜索算法，一个具有 `O(n)` 的空间复杂度，另一个算法具有
    `O(nlogn)` 的空间复杂度。第一个算法在空间需求方面比第二个算法更好。空间复杂度分析对于理解算法的效率很重要，尤其是在内存空间需求高的应用中。
- en: When the input size becomes large enough, the order of growth also becomes important.
    In such situations, we study the asymptotic efficiency of algorithms. Generally,
    algorithms that are asymptotically efficient are considered to be better algorithms
    for large-size inputs. In the next section, we will study asymptotic notation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入大小足够大时，增长顺序也变得很重要。在这种情况下，我们研究算法的渐近效率。通常，渐近效率高的算法被认为是适用于大型输入的更好算法。在下一节中，我们将研究渐近符号。
- en: Asymptotic notation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐近符号
- en: To analyze the time complexity of an algorithm, the rate of growth (order of
    growth) is very important when the input size is large. When the input size becomes
    large, we only consider the higher-order terms and ignore the insignificant terms.
    In asymptotic analysis, we analyze the efficiency of algorithms for large input
    sizes considering the higher order of growth and ignoring the multiplicative constants
    and lower-order terms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析算法的时间复杂度，当输入大小很大时，增长速率（增长顺序）非常重要。当输入大小变得很大时，我们只考虑高阶项，忽略不重要的项。在渐近分析中，我们考虑高阶增长，忽略乘法常数和低阶项，来分析大输入大小下算法的效率。
- en: 'We compare two algorithms with respect to input size rather than the actual
    runtime and measure how the time taken increases with an increased input size.
    The algorithm which is more efficient asymptotically is generally considered a
    better algorithm as compared to the other algorithm. The following asymptotic
    notations are commonly used to calculate the running time complexity of an algorithm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较两个算法，根据输入大小而不是实际运行时间，并测量随着输入大小的增加所花费的时间如何增加。在渐近效率方面更有效的算法通常被认为比其他算法更好。以下渐近符号通常用于计算算法的运行时间复杂度：
- en: 'θ notation: It denotes the worst-case running time complexity with a tight
    bound.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: θ 符号：它表示具有紧界的最坏情况运行时间复杂度。
- en: 'Ο notation: It denotes the worst-case running time complexity with an upper
    bound, which ensures that the function never grows faster than the upper bound.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ο 符号：它表示具有上界的最坏情况运行时间复杂度，这确保了函数的增长永远不会超过上界。
- en: 'Ω notation: It denotes the lower bound of an algorithm’s running time. It measures
    the best amount of time to execute the algorithm.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ω 符号：它表示算法运行时间的下界。它衡量执行算法的最佳时间。
- en: Theta notation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Theta 符号
- en: 'The following function characterizes the worst-case running time for the first
    example discussed in the *Time complexity* section:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数描述了在*时间复杂度*部分讨论的第一个示例的最坏情况运行时间：
- en: '*T*(*n*) = *c*[1] + *c*[3] x *n* + *c*[5] x *n*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*n*) = *c*[1] + *c*[3] x *n* + *c*[5] x *n*'
- en: Here, for a large input size, the worst-case running time will be `ϴ(n)` (pronounced
    as theta of `n`). We usually consider one algorithm to be more efficient than
    another if its worst-case running time has a lower order of growth. Due to constant
    factors and lower-order terms, an algorithm whose running time has a higher order
    of growth might take less time for small inputs than an algorithm whose running
    time has a lower order of growth. For example, once the input size `n` becomes
    large enough, the merge sort algorithm performs better as compared to insertion
    sort with worst-case running times of `ϴ(logn)` and `` ϴ(n²`)` `` respectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于大的输入规模，最坏情况下的运行时间将是 `ϴ(n)`（读作 theta of `n`）。我们通常认为如果一个算法的最坏情况运行时间具有更低的增长阶，那么它比另一个算法更高效。由于常数因子和低阶项，一个运行时间具有更高增长阶的算法可能在小输入上比一个运行时间具有更低增长阶的算法花费更少的时间。例如，一旦输入规模
    `n` 足够大，归并排序算法的性能比插入排序更好，分别具有最坏情况运行时间 `ϴ(logn)` 和 `ϴ(n²)`。
- en: Theta notation (`ϴ`) denotes the worst-case running time for an algorithm with
    a tight bound. For a given function *F*(*n*), the asymptotic worst-case running
    time complexity can be defined as follows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Theta 符号 (`ϴ`) 表示具有紧界的算法的最坏情况运行时间。对于给定的函数 *F*(*n*)，渐近最坏情况运行时间复杂度可以定义为以下内容。
- en: '![](img/B17217_02_002.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_002.png)'
- en: 'iff there exists constants *n*[0], *c*[1], and *c*[2] such that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当且仅当存在常数 *n*[0]、*c*[1] 和 *c*[2] 使得：
- en: '![](img/B17217_02_003.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_003.png)'
- en: The function *T*(*n*) belongs to a set of functions *ϴ*(*F*(*n*)) if there exists
    positive constants *c*[1] and c[2] such that the value of *T*(*n*) always lies
    in between *c*[1]*F*(*n*) and *c*[2]*F*(*n*) for all large values of *n*. If this
    condition is true, then we say *F*(*n*) is asymptotically tight bound for *T*(*n*).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在正常数 *c*[1] 和 c[2]，使得对于所有大的 *n* 值，*T*(*n*) 的值始终介于 *c*[1]*F*(*n*) 和 *c*[2]*F*(*n*)
    之间，那么函数 *T*(*n*) 属于函数集合 *ϴ*(*F*(*n*))。如果这个条件成立，那么我们说 *F*(*n*) 是 *T*(*n*) 的渐近紧界。
- en: '*Figure 2.2* shows the graphic example of the theta notation (*ϴ*). It can
    be observed from the figure that the value of *T*(*n*) always lies in between
    *c*[1]*F*(*n*) and *c*[2]*F*(*n*) for values of n greater than *n*[0].'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2* 展示了 theta 符号的图形示例（*ϴ*）。从图中可以观察到，对于大于 *n*[0] 的 n 值，*T*(*n*) 的值始终介于 *c*[1]*F*(*n*)
    和 *c*[2]*F*(*n*) 之间。'
- en: '![](img/B17217_02_02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_02.png)'
- en: 'Figure 2.2: Graphical example of theta notation (ϴ)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：theta 符号（ϴ）的图形示例
- en: 'Let us consider an example to understand what should be the worst case running
    time complexity with the formal definition of theta notation for a given function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，以了解给定函数的正式 theta 符号定义下应该具有的最坏情况运行时间复杂度：
- en: '![](img/B17217_02_004.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_004.png)'
- en: In order to determine the time complexity with the *ϴ* notation definition,
    we have to first identify the constants c[1], c[2], n[0] such that
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定使用 *ϴ* 符号定义的时间复杂度，我们首先需要识别常数 c[1]、c[2]、n[0]，使得
- en: '![](img/B17217_02_005.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_005.png)'
- en: 'Dividing by n² will produce:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除以 n² 将产生：
- en: '![](img/B17217_02_006.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_006.png)'
- en: By choosing c[1] = 1, c[2] = 2, and n[0] = 1, the following condition can satisfy
    the definition of theta notation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 c[1] = 1，c[2] = 2，和 n[0] = 1，以下条件可以满足 theta 符号的定义。
- en: '![](img/B17217_02_007.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_007.png)'
- en: 'That gives:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出：
- en: '![](img/B17217_02_008.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_008.png)'
- en: 'Consider another example to find out the asymptotically tight bound (`ϴ`) for
    another function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个例子，找出另一个函数的渐近紧界（`ϴ`）：
- en: '![](img/B17217_02_009.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_009.png)'
- en: 'In order to identify the constants c[1], c[2], and n[0], such that they satisfy
    the condition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别满足以下条件的常数 c[1]、c[2] 和 n[0]：
- en: '![](img/B17217_02_010.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_010.png)'
- en: 'By choosing c[1] = 1/5, c[2] =1, and n[0] = 1, the following condition can
    satisfy the definition of theta notation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 c[1] = 1/5，c[2] = 1，和 n[0] = 1，以下条件可以满足 theta 符号的定义：
- en: '![](img/B17217_02_011.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_011.png)'
- en: '![](img/B17217_02_012.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_012.png)'
- en: 'So, the following is true:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是真的：
- en: '![](img/B17217_02_013.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_013.png)'
- en: It shows that the given function has the complexity of `ϴ`(n²) as per the definition
    of theta notation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明根据 theta 符号的定义，给定的函数具有 `ϴ`(n²) 的复杂度。
- en: So, the theta notation provides a tight bound for the time complexity of an
    algorithm. In the next section, we will discuss Big O notation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，theta 符号提供了算法时间复杂度的紧界。在下一节中，我们将讨论 Big O 符号。
- en: Big O notation
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Big O 符号
- en: 'We have seen that the theta notation is asymptotically bound from the upper
    and lower sides of the function whereas the Big O notation characterizes the worst-case
    running time complexity, which is only the asymptotic upper bound of the function.
    Big O notation is defined as follows. Given a function *F*(*n*), the *T*(*n*)
    is a Big O of function *F*(*n*), and we define this as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，theta 符号从函数的上侧和下侧渐近地有界，而大 O 符号描述的是最坏情况下的运行时间复杂度，这仅仅是函数的渐近上界。大 O 符号定义为：给定一个函数
    *F*(*n*)，*T*(*n*) 是函数 *F*(*n*) 的大 O 符号，我们将其定义为以下内容：
- en: '*T*(*n*) = O(*F*(*n*))'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*n*) = O(*F*(*n*))'
- en: 'iff there exists constants n[0] and *c* such that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在常数 n[0] 和 *c* 使得：
- en: '![](img/B17217_02_014.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_02_014.png)'
- en: In Big O notation, a constant multiple of *F*(*n*) is an asymptotic upper bound
    on *T*(*n*), and the positive constants n[0] and *c* should be in such a way that
    all values of `n` greater than n[0] always lie on or below function *c***F*(*n*).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大 O 符号中，*F*(*n*) 的常数倍是 *T*(*n*) 的渐近上界，并且正的常数 n[0] 和 *c* 应该以这样的方式，即所有大于 n[0]
    的 `n` 的值始终位于或低于函数 *c***F*(*n*)。
- en: Moreover, we only care what happens at higher values of *n*. The variable n[0]
    represents the threshold below which the rate of growth is not important. The
    plot shown in *Figure 2.3* shows a graphical representation of function *T*(*n*)
    with a varying value of `n`. We can see that *T*(*n*) = n² + 500 = O(n²), with
    *c* = 2 and n[0] being approximately `23`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只关心在 *n* 的较高值时发生的情况。变量 n[0] 代表增长率不再重要的阈值。*图 2.3* 展示了函数 *T*(*n*) 随 *n* 变化的图形表示。我们可以看到
    *T*(*n*) = n² + 500 = O(n²)，其中 *c* = 2，n[0] 大约是 `23`。
- en: '![](img/B17217_02_03.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_02_03.png)'
- en: 'Figure 2.3: Graphical example of O notation'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：O 符号的图形示例
- en: In O notation, *O*(*F*(*n*)) is really a set of functions that includes all
    functions with the same or smaller rates of growth than *F*(*n*). For example,
    *O*(n²) also includes *O*(*n*), *O*(log *n*), and so on. However, Big O notation
    should characterize a function as closely as possible, for example, it is true
    that function *F*(*n*) = 2n³+2n²+5 is O(n⁴), however, it is more accurate that
    *F*(*n*) is *O*(n³).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 O 符号中，*O*(*F*(*n*)) 实际上是一组函数，包括所有与 *F*(*n*) 具有相同或更小增长率的函数。例如，*O*(n²) 也包括 *O*(*n*)，*O*(log
    *n*)，等等。然而，大 O 符号应尽可能准确地描述一个函数，例如，函数 *F*(*n*) = 2n³+2n²+5 是 O(n⁴)，然而，更准确的是 *F*(*n*)
    是 *O*(n³)。
- en: In the following table, we list the most common growth rates in order from lowest
    to highest.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，我们按从低到高的顺序列出最常见的增长率。
- en: '| **Time Complexity** | **Name** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **时间复杂度** | **名称** |'
- en: '| `O(1)` | Constant |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `O(1)` | 常数 |'
- en: '| `O(logn)` | Logarithmic |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `O(logn)` | 对数 |'
- en: '| `O(n)` | Linear |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `O(n)` | 线性 |'
- en: '| `O(nlogn)` | Linear-logarithmic |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `O(nlogn)` | 线性对数 |'
- en: '| `O(n2)` | Quadratic |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `O(n2)` | 二次 |'
- en: '| `O(n3)` | Cubic |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `O(n3)` | 三次 |'
- en: '| `O(2n)` | Exponential |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `O(2n)` | 指数 |'
- en: 'Table 2.1: Runtime complexity of different functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：不同函数的运行时间复杂度
- en: 'Using Big O notation, the running time of an algorithm can be computed by analyzing
    the structure of the algorithm. For example, a double nested loop in an algorithm
    will have an upper bound on the worst-case running time of O(n²), since the values
    of `i` and `j` will be at most *n*, and both the loops will run n² times as shown
    in the below example code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大 O 符号，可以通过分析算法的结构来计算算法的运行时间。例如，算法中的双层循环将具有 O(n²) 的最坏情况运行时间上界，因为 `i` 和 `j`
    的值最多为 *n*，并且两个循环都将运行 n² 次，如下面的示例代码所示：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let us consider a few examples in order to compute the upper bound of a function
    using the O-notation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个例子，以便使用 O 符号计算函数的上界：
- en: 'Find the upper bound for the function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求该函数的上界：
- en: T(n) = 2n + 7
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T(n) = 2n + 7
- en: '**Solution**: Using O notation, the condition for the upper bound is:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：使用 O 符号，上界的条件是：'
- en: '*T*(*n*) <= *c* * *F*(*n*)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*T*(*n*) <= *c* * *F*(*n*)'
- en: This condition holds true for all values of n > 7 and *c*=3.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于所有 n > 7 和 *c*=3 的值，此条件成立。
- en: '*2n + 7 <= 3n* This is true for all values of n, with *c*=3, n[0]=7'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*2n + 7 <= 3n* 这对所有 n 的值都成立，其中 *c*=3，n[0]=7'
- en: '*T(n) = 2n+7 = O(n)*'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*T(n) = 2n+7 = O(n)*'
- en: Find F(n) for functions *T(n) =2n+5 such that T(n) = O(F(n))*.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于函数 *T(n) =2n+5，找到满足 T(n) = O(F(n)) 的 F(n)。
- en: '**Solution**: Using O notation, the condition for the upper bound is *T(n)
    <=c * F(n)*.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解决方案**：使用 O 符号，上界的条件是 *T(n) <=c * F(n)*。'
- en: Since, 2n+5 ≤ 3n, for all n ≥ 5.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 2n+5 ≤ 3n，对所有 n ≥ 5 成立。
- en: The condition is true for *c*=3, n[0]=5.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 *c*=3，n[0]=5 时，该条件成立。
- en: '*2n + 5 ≤ O(n)*'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*2n + 5 ≤ O(n)*'
- en: '*F(n) = n*'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*F(n) = n*'
- en: Find F(n) for the function *T(n) = n*² *+n, such that T(n) = O(F(n))*.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到函数 *T(n) = n² +n* 的 F(n)，使得 T(n) = O(F(n))。
- en: '**Solution**: Using O notation, since, *n*²*+ n ≤ 2n*²*, for all n ≥ 1 (with
    c = 2, n*[0]*=2)*'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：使用 O 符号，因为，*n*²*+ n ≤ 2n*²*，对于所有 n ≥ 1（c = 2，n*[0]*=2）*'
- en: n²+ n ≤ O(n²)
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n²+ n ≤ O(n²)
- en: F(n) = n²
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: F(n) = n²
- en: Prove that f(n) =2n³ - 6n ≠ O(n²).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 f(n) =2n³ - 6n ≠ O(n²)。
- en: '**Solution**: Clearly, 2n³-6n ≥ n², for n ≥ 2\. So it cannot be true that 2n³
    - 6n ≠ O(n²).'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：显然，2n³-6n ≥ n²，对于 n ≥ 2\. 所以，2n³ - 6n ≠ O(n²) 不成立。'
- en: 'Prove that: 20n²+2n+5 = O(n²).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明：20n²+2n+5 = O(n²)。
- en: '**Solution**: It is clear that:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：显然：'
- en: 20n² + 2n + 5 <= 21n² for all n > 4 (let c = 21 and n[0] = 4)
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 20n² + 2n + 5 <= 21n² 对于所有 n > 4（取 c = 21 和 n[0] = 4）
- en: n² > 2n + 5 for all n > 4
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于所有 n > 4，n² > 2n + 5。
- en: So, the complexity is O(n²).
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，复杂度为 O(n²)。
- en: So, Big-O notation provides an upper bound on a function, which ensures that
    the function never grows faster than the upper-bounded function. In the next section,
    we will discuss Omega notation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Big-O 符号提供了一个函数的上界，这确保了函数的增长速度永远不会超过上界函数。在下一节中，我们将讨论 Omega 符号。
- en: Omega notation
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Omega 符号
- en: Omega notation (Ω) describes an asymptotic lower bound on algorithms, similar
    to the way in which Big O notation describes an upper bound. Omega notation computes
    the best-case runtime complexity of the algorithm. The Ω notation (*Ω*(*F*(*n*))
    is pronounced as omega of F of n), is a set of functions in such a way that there
    are positive constants n[0] and c such that for all values of n greater than n[0],
    *T*(*n*) always lies on or above a function to *c***F*(*n*).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Omega 符号 (Ω) 描述了算法的渐近下界，类似于 Big O 符号描述上界的方式。Omega 符号计算算法的最佳运行时间复杂度。Ω 符号 (*Ω*(*F*(*n*))
    读作 omega of F of n)，是一组函数，使得存在正的常数 n[0] 和 c，对于所有 n > n[0] 的值，*T*(*n*) 总是位于或高于函数
    *c***F*(*n*)。
- en: '*T*(*n*) = *Ω* (*F*(*n*))'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(*n*) = *Ω* (*F*(*n*))'
- en: 'Iff constants n[0] and c are present, then:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在常数 n[0] 和 c，那么：
- en: '![](img/B17217_02_015.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_02_015.png)'
- en: '*Figure 2.4* shows the graphical representation of the omega (Ω) notation.
    It can be observed from the figure that the value of *T*(*n*) always lies above
    cF(n) for values of *n* greater than n[0].'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.4* 展示了 omega (Ω) 符号的图形表示。从图中可以观察到，对于 n > n[0] 的值，*T*(*n*) 总是位于 cF(n) 之上。'
- en: '![](img/B17217_02_04.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_02_04.png)'
- en: 'Figure 2.4: The graphical representation of Ω notation'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：Ω 符号的图形表示
- en: If the running time of an algorithm is *Ω*(*F*(*n*)), it means that the running
    time of the algorithm is at least a constant multiplier of *F*(*n*) for sufficiently
    large values of input size (n). The Ω notation gives a lower bound on the best-case
    running time complexity of a given algorithm. It means that the running time for
    a given algorithm will be at least *F*(*n*) without depending upon the input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的运行时间是 *Ω*(*F*(*n*))，这意味着对于足够大的输入大小（n）的值，算法的运行时间至少是 *F*(*n*) 的一个常数倍。Ω 符号给出了给定算法最佳运行时间复杂度的下界。这意味着给定算法的运行时间至少是
    *F*(*n*)，而不依赖于输入。
- en: 'In order to understand the Ω notation and how to compute the lower bound on
    the best-case runtime complexity of an algorithm:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Omega 符号以及如何计算算法最佳运行时间复杂度的下界：
- en: Find *F*(*n*) for the function *T*(*n*) =2n² +3 such that *T*(*n*) = *Ω*(*F*(*n*)).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到函数 *T*(*n*) =2n² +3 的 *F*(*n*)，使得 *T*(*n*) = *Ω*(*F*(*n*)).
- en: '**Solution**: Using the Ω notation, the condition for the lower bound is:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：使用 Omega 符号，下界条件为：'
- en: c*F(n) ≤ T(n)
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c*F(n) ≤ T(n)
- en: This condition holds true for all values of n greater than 0, and c=1.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 找到函数 *T(n) = n² +n* 的 F(n)，使得 T(n) = O(F(n))。
- en: 0 ≤ cn² ≤ 2n² +3, for all n ≥ 0
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 ≤ cn² ≤ 2n² +3, 对于所有 n ≥ 0
- en: 2n² +3 = Ω(n²)
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2n² +3 = Ω(n²)
- en: F(n)=n²
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: F(n)=n²
- en: Find the lower bound for T(n) = 3n².
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 T(n) = 3n² 的下界。
- en: '**Solution**: Using the Ω notation, the condition for the lower bound is:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：使用 Omega 符号，下界条件为：'
- en: c*F(n) ≤ T(n)
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c*F(n) ≤ T(n)
- en: Consider 0 ≤ cn² ≤ 3n². The condition for Ω notation holds true for all values
    of n greater than 1, and c=2.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑 0 ≤ cn² ≤ 3n²。对于所有 n > 1 的值，以及 c=2，Ω 符号的条件成立。
- en: cn² ≤ 3n² (for c = 2 and n[0] = 1)
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cn² ≤ 3n² (对于 c = 2 和 n[0] = 1)
- en: 3n² = Ω(n²)
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3n² = Ω(n²)
- en: Prove that 3n = Ω(n).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明 3n = Ω(n)。
- en: '**Solution**: Using the Ω notation, the condition for the lower bound is:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解法**：使用 Omega 符号，下界条件为：'
- en: c*F(n) ≤ T(n)
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c*F(n) ≤ T(n)
- en: Consider 0 ≤ c*n≤ 3n. The condition for Ω notation holds true for all values
    of n greater than 1, and c=1.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑 0 ≤ c*n≤ 3n。对于所有 n > 1 的值，以及 c=1，Ω 符号的条件成立。
- en: cn² ≤ 3n² ( for c = 2 and n[0] = 1)
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑 0 ≤ c*n≤ 3n。对于所有 n > 1 的值，以及 c=1，Ω 符号的条件成立。
- en: 3n = Ω(n)
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3n = Ω(n)
- en: The Ω notation is used to describe that at least a certain amount of running
    time will be taken by an algorithm for a large input size. In the next section,
    we will discuss amortized analysis.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ω符号用于描述算法对于大输入大小至少需要一定量的运行时间。在下一节中，我们将讨论摊销分析。
- en: Amortized analysis
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摊销分析
- en: In the amortized analysis of an algorithm, we average the time required to execute
    a sequence of operations with all the operations of the algorithm. This is called
    amortized analysis. Amortized analysis is important when we are not interested
    in the time complexity of individual operations but we are interested in the average
    runtime of sequences of operations. In an algorithm, each operation requires a
    different amount of time to execute. Certain operations require significant amounts
    of time and resources while some operations are not costly at all. In amortized
    analysis, we analyze algorithms considering both the costly and less costly operations
    in order to analyze all the sequences of operations. So, an amortized analysis
    is the average performance of each operation in the worst case considering the
    cost of the complete sequence of all the operations. Amortized analysis is different
    from average-case analysis since the distribution of the input values is not considered.
    An amortized analysis gives the average performance of each operation in the worst
    case.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的摊销分析中，我们平均计算执行一系列操作所需的时间与算法中所有操作的时间。这被称为摊销分析。当我们对单个操作的时间复杂度不感兴趣，而关注一系列操作的平均运行时间时，摊销分析就很重要。在算法中，每个操作执行所需的时间是不同的。某些操作需要大量的时间和资源，而有些操作则几乎不耗费成本。在摊销分析中，我们考虑了成本高昂和成本较低的操作，以便分析所有操作序列。因此，摊销分析是考虑所有操作序列的完整成本的平均性能。摊销分析与平均情况分析不同，因为不考虑输入值的分布。摊销分析给出了每个操作在最坏情况下的平均性能。
- en: 'There are three commonly used methods for amortized analysis:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 摊销分析有三种常用的方法：
- en: '**Aggregate analysis**. In aggregate analysis, the amortized cost is the average
    cost of all the sequences of operations. For a given sequence of n operations,
    the amortized cost of each operation can be computed by dividing the upper bound
    on the total cost of n operations with n.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合分析**。在聚合分析中，摊销成本是所有操作序列的平均成本。对于给定的n个操作序列，每个操作的摊销成本可以通过将n个操作的总成本的上界除以n来计算。'
- en: '**The accounting method**. In the accounting method, we assign an amortized
    cost to each operation, which may be different than their actual cost. In this,
    we impose an extra charge on early operations in the sequence and save “credit
    cost,” which is used to pay expensive operations later in the sequence.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会计方法**。在会计方法中，我们为每个操作分配一个摊销成本，这可能与它们的实际成本不同。在这里，我们对序列中的早期操作征收额外费用，并保存“信用成本”，这些成本用于支付序列中后面的昂贵操作。'
- en: '**The potential method**. The potential method is like the accounting method.
    We determine the amortized cost of each operation and impose an extra charge to
    early operations that may be used later in the sequence. Unlike the accounting
    method, the potential method accumulates the overcharged credit as “potential
    energy” of the data structure as a whole instead of storing credit for individual
    operations.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**势方法**。势方法类似于会计方法。我们确定每个操作的摊销成本，并对可能在未来序列中使用的早期操作征收额外费用。与会计方法不同，势方法将超额收费的信用积累为数据结构整体的“势能”，而不是为单个操作存储信用。'
- en: In this section, we had an overview of amortized analysis. Now we will discuss
    how to compute the complexity of different functions with examples in the next
    section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了摊销分析。现在我们将讨论如何通过下一节的示例计算不同函数的复杂性。
- en: Composing complexity classes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成复杂度类
- en: Normally, we need to find the total running time of complex operations and algorithms.
    It turns out that we can combine the complexity classes of simple operations to
    find the complexity class of more complex, combined operations. The goal is to
    analyze the combined statements in a function or method to understand the total
    time complexity of executing several operations. The simplest way to combine two
    complexity classes is to add them. This occurs when we have two sequential operations.
    For example, consider the two operations of inserting an element into a list and
    then sorting that list. Assuming that inserting an item occurs in O(n) time, and
    sorting in O(nlogn) time, then we can write the total time complexity as O(n +
    nlogn); that is, we bring the two functions inside the O(…), as per Big O computation.
    Considering only the highest-order term, the final worst-case complexity becomes
    O(nlogn).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要找到复杂操作和算法的总运行时间。结果证明，我们可以通过组合简单操作的复杂度类来找到更复杂、组合操作的复杂度类。目标是分析函数或方法中的组合语句，以了解执行多个操作的总时间复杂度。将两个复杂度类组合的最简单方法是相加。这发生在我们有两个顺序操作时。例如，考虑将一个元素插入列表并排序该列表的两个操作。假设插入项的时间复杂度为O(n)，排序的时间复杂度为O(nlogn)，那么我们可以将总时间复杂度写为O(n
    + nlogn)；即，我们按照大O计算的规则，将两个函数放入O(…）内。只考虑最高阶项，最终的复杂度变为O(nlogn)。
- en: 'If we repeat an operation, for example in a `while` loop, then we multiply
    the complexity class by the number of times the operation is carried out. If an
    operation with time complexity O(*f*(*n*)) is repeated O(*n*) times, then we multiply
    the two complexities: O(*f*(*n*) * O(*n*)) = O(*nf*(*n*)). For example, suppose
    the function *f*(*n*) has a time complexity of O(*n*²) and it is executed *n*
    times in a `for` loop, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复一个操作，例如在`while`循环中，那么我们将复杂度类乘以操作执行的次数。如果一个具有时间复杂度O(*f*(*n*))的操作重复O(*n*)次，那么我们将两个复杂度相乘：O(*f*(*n*)
    * O(*n*)) = O(*nf*(*n*))。例如，假设函数*f*(*n*)的时间复杂度为O(*n*²)，并在`for`循环中执行*n*次，如下所示：
- en: '[PRE7]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The time complexity of the above code then becomes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的时间复杂度变为：
- en: O(*n*²) x O(*n*) = O(*n* x *n*²) = O(*n*³)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: O(*n*²) x O(*n*) = O(*n* x *n*²) = O(*n*³)
- en: 'Here, we are multiplying the time complexity of the inner function by the number
    of times this function executes. The runtime of a loop is at most the runtime
    of the statements inside the loop multiplied by the number of iterations. A single
    nested loop, that is, one loop nested inside another loop, will run *n*² times,
    such as in the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将内函数的时间复杂度乘以该函数执行的次数。循环的运行时间最多是循环内语句的运行时间乘以迭代次数。一个单层嵌套循环，即一个循环嵌套在另一个循环中，将运行*n*²次，如下例所示：
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If each execution of the statements takes constant time, *c*, i.e. O(1), executed
    *n* x *n* times, we can express the running time as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个语句的执行时间都是常数时间，即O(1)，执行*n* x *n*次，我们可以将运行时间表示如下：
- en: '*c* x *n* x *n* = *c* x *n*² = O(*n*²)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* x *n* x *n* = *c* x *n*² = O(*n*²)'
- en: 'For consecutive statements within nested loops, we add the time complexities
    of each statement and multiply by the number of times the statement is executed—as
    in the following code, for example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套循环中的连续语句，我们将每个语句的时间复杂度相加，并乘以该语句执行的次数——例如，以下代码中的情况：
- en: '[PRE9]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be written as: *c*¹*n + c*² **n*² *= O(n*²*)*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以写成：*c*¹*n + c*² **n*² *= O(n*²*)*。
- en: 'We can define (base 2) logarithmic complexity, reducing the size of the problem
    by half, in constant time. For example, consider the following snippet of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义（以2为底）对数复杂度，通过在常数时间内减半问题的大小。例如，考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that `i` is doubling in each iteration. If we run this code with n =
    10, we see that it prints out four numbers: 2, 4, 8, and 16\. If we double n,
    we see it prints out five numbers. With each subsequent doubling of n, the number
    of iterations is only increased by 1\. If we assume that the loop has k iterations,
    then the value of n will be 2^n. We can write this as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`i`在每次迭代中都在翻倍。如果我们用n = 10运行此代码，我们会看到它打印出四个数字：2、4、8和16。如果我们加倍n，我们会看到它打印出五个数字。随着n的后续翻倍，迭代次数仅增加1。如果我们假设循环有k次迭代，那么n的值将是2^n。我们可以这样写：
- en: '![](img/B17217_02_016.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_016.png)'
- en: '![](img/B17217_02_017.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_017.png)'
- en: '![](img/B17217_02_018.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_02_018.png)'
- en: From this, the worst-case runtime complexity of the above code is equal to O(log(n)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结果来看，上述代码的最坏情况运行时间复杂度等于O(log(n))。
- en: In this section, we have seen examples to compute the running time complexity
    of different functions. In the next section, we will take examples to understand
    how to compute the running time complexity of an algorithm.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了计算不同函数的运行时间复杂度的例子。在下一节中，我们将通过例子了解如何计算算法的运行时间复杂度。
- en: Computing the running time complexity of an algorithm
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算算法的运行时间复杂度
- en: 'To analyze an algorithm with respect to the best-, worst-, and average-case
    runtime of the algorithm, it is not always possible to compute these for every
    given function or algorithm. However, it is always important to know the upper-bound
    worst-case runtime complexity of an algorithm in practical situations; therefore,
    we focus on computing the upper-bound Big O notation to compute the worst-case
    runtime complexity of an algorithm:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据算法的最佳、最坏和平均运行时间来分析算法，并不总是可能为每个给定的函数或算法计算这些值。然而，在实际情况中，了解算法的上界最坏运行时间复杂度总是很重要的；因此，我们专注于计算上界大
    O 符号以计算算法的最坏运行时间复杂度：
- en: 'Find the worst-case runtime complexity of the following Python snippet:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的最坏运行时间复杂度：
- en: '[PRE11]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Solution**: The runtime for a loop, in general, takes the time taken by all
    statements in the loop, multiplied by the number of iterations. Here, total runtime
    is defined as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：一般来说，循环的运行时间等于循环中所有语句的执行时间乘以迭代次数。在这里，总运行时间定义为以下：'
- en: T(n) = constant time (c) * n = c*n = O(n)
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T(n) = 常数时间 (c) * n = c*n = O(n)
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE12]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Solution**: O(n²). The `print` statement will be executed n² times, n times
    for the inner loop, and, for each iteration of the outer loop, the inner loop
    will be executed.'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：O(n²)。`print` 语句将被执行 n² 次，内循环执行 n 次，对于外循环的每一次迭代，内循环都会被执行。'
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE13]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Solution**: The worst-case complexity will be O(n) since the `print` statement
    will run *n* times because the inner loop executes only once due to a `break`
    statement.'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：最坏情况下的复杂度将是 O(n)，因为 `print` 语句将运行 *n* 次，因为内循环由于 `break` 语句只执行一次。'
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE14]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Solution**: Here, the `print` statements will execute *n* times in the first
    loop and *n*² times for the second nested loop. Here, the total time required
    is defined as the following:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：在这里，`print` 语句将在第一个循环中执行 *n* 次，在第二个嵌套循环中将执行 *n*² 次。这里，所需的总时间定义为以下：'
- en: T(n) = constant time (c[1]) * n + c[2]*n*n
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T(n) = 常数时间 (c[1]) * n + c[2]*n*n
- en: c[1] n + c[2] n² = O(n²)
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c[1] n + c[2] n² = O(n²)
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE15]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Solution**: O(n). Here, the worst-case runtime complexity will be the time
    required for the execution of all the statements; that is, the time required for
    the execution of the `if-else` conditions, and the `for` loop. The time required
    is defined as the following:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：O(n)。在这里，最坏情况下的运行时间复杂度将是执行所有语句所需的时间；即执行 `if-else` 条件和 `for` 循环所需的时间。所需的时间定义为以下：'
- en: T(n) = c[1] + c[2] n = O(n)
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T(n) = c[1] + c[2] n = O(n)
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE16]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Solution**: O(![](img/Eqn_02_notation4.png)). The loop will terminate based
    on the value of `i`; the loop will iterate based on the condition:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：O(![](img/Eqn_02_notation4.png))。循环将根据 `i` 的值终止；循环将根据以下条件迭代：'
- en: '![](img/Eqn_02_notation5.png)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Eqn_02_notation5.png)'
- en: T(n) = O(![](img/Eqn_02_notation41.png))
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T(n) = O(![](img/Eqn_02_notation41.png))
- en: 'Find the time complexity of the following Python snippet:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 段落的复杂度：
- en: '[PRE17]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Solution**: Here, the outer loop will execute n/2 times, the middle loop
    will also run n/2 times, and the innermost loop will run for log(n) time. So,
    the total running time complexity will be O(n*n*logn):'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**解答**：在这里，外循环将执行 n/2 次，中间循环也将执行 n/2 次，最内层循环将运行 log(n) 时间。因此，总的运行时间复杂度将是 O(n*n*logn)：'
- en: O(n²logn)
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: O(n²logn)
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we have looked at an overview of algorithm design. The study
    of algorithms is important because it trains us to think very specifically about
    certain problems. It is conducive to increasing our problem-solving abilities
    by isolating the components of a problem and defining the relationships between
    them. In this chapter, we discussed different methods for analyzing algorithms
    and comparing algorithms. We also discussed asymptotic notations, namely: Big
    Ο, Ω, and θ notation.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了算法设计。算法的研究很重要，因为它训练我们非常具体地思考某些问题。通过隔离问题的组成部分并定义它们之间的关系，这有助于提高我们的解决问题的能力。在本章中，我们讨论了分析算法和比较算法的不同方法。我们还讨论了渐近符号，即：大O、Ω和θ符号。
- en: In the next chapter, we will discuss algorithm design techniques and strategies.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论算法设计技术和策略。
- en: Exercises
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Find the time complexity of the following Python snippets:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出以下 Python 碎片的复杂度：
- en: '[PRE18]'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Join our community on Discord
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
