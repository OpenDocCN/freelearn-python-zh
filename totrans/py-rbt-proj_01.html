<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Robotics 101</h1>
                </header>
            
            <article>
                
<p>Hello world! As soon as we say the word robot, thoughts of science fiction start to surround us. We may recall the cartoon serial <em>The Jetsons</em> or think of the movie <em>Terminator</em>. But, as a matter of fact, robots as a species do not belong to science fiction anymore. They are as real as they can get. Look around you and point out any object; it probably wouldn't have been made without a robot. The modern era has been shaped by robots.</p>
<p>But then, you can also take a step back and think, wait a minute, aren't the things he is talking about called machines and not robots? Well, yes, you are very correct, yet very mistaken at the same time. It is cartoons and science fiction that have imparted an image of a human-like robot that is called a <strong>robot</strong>. But robots are much more than that.</p>
<p>Unfortunately, we do not have a concrete, universally agreed definition of robots, but, as I like to say, <em>Any machine capable of performing physical as well as intellectual tasks can be called a robot.</em></p>
<p>Now, you may say that, according to my definition, even an automatic washing machine can be called a robot. Well, technically, yes, and why should we not call it a robot? Think of the things it is doing for you and what kind of automation has been adapted over the years. After you feed in the type of cloth it automatically washes, rinses, and dries as you would have done yourself in the 19th century. The point I am trying to make is that there is a huge variation of robots that we can think of, which can radically change the way we live. We need to think with a wider perspective—not just limit robot to look as a human adaption in form of humanoid robots.</p>
<p>We live in the golden era of robotics and automation in which the development of new products is as simple as it can get. What a decade back might have taken a team of engineers, can now be done by a person sitting in bedroom in just a few minutes, thanks to the open source world. At the very same time, there is hardware horsepower available to you by which you can literally build a super computer in your own home with just a few hundred dollars. We are surrounded by problems, some simple and others complex, which are waiting to be solved. The only missing chain in the whole process is you: an innovative mind that has the capability to exploit these technologies to solve the world's problems.</p>
<p>To make your mind capable of doing so, we will be starting of by understanding the roots and the basics of robotics. The goal of this book is not only to make the projects that are mentioned in the book but to make you understand how to exploit the resources to build your dream projects.</p>
<p>Finally, I would like to congratulate you on entering this amazing and futuristic field at the correct time. I always tell my students a rule, which I would like to share with you as well:</p>
<ul>
<li>First is a scientist</li>
<li>Second is a researcher</li>
<li>Third is an engineer</li>
<li>Fourth is a technician</li>
<li>Last is a mechanic</li>
</ul>
<p>What it means is that the earlier in the life cycle you enter any field, the higher in the hierarchy you can get. The later you come, the harder it is to climb to the top.</p>
<p>Enough talking—now let's get straight to business! We will cover the following topics in this chapter:</p>
<ul>
<li>The hardware arsenal</li>
<li>Setting up Raspberry Pi</li>
<li>Programming</li>
<li>Playing with voltage</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The hardware arsenal</h1>
                </header>
            
            <article>
                
<p>Talking of robots, there are a few basic tangible components that they are made up of, which are as follows:</p>
<ul>
<li><span>Computing Unit</span></li>
<li>Sensors</li>
<li>Actuators</li>
<li>Chassis</li>
<li>Power source</li>
</ul>
<p>Firstly, we will be discussing the microcontroller and, during the course of book, we will be discussing the rest of the tangible components in detail as and when required.</p>
<p>Whenever you have been to buy a laptop or a computer, you must have heard the word microprocessor. This is the primary unit that has to make all the decisions. I call it the <em>king</em>, but what is a king without an empire? For the king to work, he needs some <span><span>subordinates that can do the things for him</span></span>, the same way in which the microprocessor needs a few subordinates such as RAM, storage, I/O devices, and so on. Now, the problem is that when we put in all these things the overall unit gets expensive and bulky. But, as we know, subsequently weight and size are very important factors when it comes to robots, so we cannot afford to have a big bulky piece of system running a robot.</p>
<p>Hence, we made something called a SoC. Now, this is a one man show as this small chip, has all the necessary systems for it to work inside that small little chipset itself. So, now you don't need to add RAM or storage or any other thing for it to work. These small microcontrollers can get really powerful but a downside is, once a manufacturer has made an SoC, thereafter no changes can be done to it. The size of storage, RAM, or the I/O cannot be changed. But we generally can live with these limitations as when programming the robots, you might not be using the entire juice of the microcontroller until the time you are running some serious artificial intelligence or machine-learning code.</p>
<p>One such great piece of hardware is Raspberry Pi. Yes, it sounds very tasty, but there is so much more to it. This is a super small yet extremely powerful microcontroller. It is often referred to as a prototyping board because of the fact that it is used by roboticists everywhere to bring out their ideas and to make them a reality in a quick time span. It is available all across the globe and is extremely cheap. You can literally stream HD movies, surf the internet, and do much more on just a $10 device. I can't think of something as ludicrous as this. It is fairly easy to use and you can use Python to program it. </p>
<p>So, basically, it ticks all our boxes. This will be the primary weapon we will be using throughout the book.</p>
<p>So let me introduce you to Raspberry Pi! This is what it looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a0b482f0-c349-48ca-973a-190a05d01fb0.png" style="width:33.33em;height:22.83em;"/></div>
<p>There are various models of Raspberry Pi available on the market. But we will be using Raspberry Pi Zero W; this will cost you around $10 and it is easier to purchase than a Big Mac burger. Do make sure you buy the Raspberry Pi Zero with a W, which supposedly stands for wireless capabilities such as Wi-Fi and Bluetooth. There are a few more things that you will have to order or arrange for it to work. Here is a list of items:</p>
<ul>
<li>Micro USB to standard USB adapter</li>
<li>Keyboard</li>
<li>Mouse</li>
<li>Micro SD memory card, 16 or 32 GB</li>
<li>Micro SD card reader</li>
<li>Micro USB power adapter (2 amp or more)</li>
<li>Micro HDMI to HDMI port</li>
<li>Breadboard</li>
<li>Bunch of jumper wires (male to male, male to female, and female to female)</li>
<li>3V LEDs</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1ef2195d-b8fc-47c6-a201-a77c7bfd7a76.png" style="width:27.50em;height:19.67em;"/></div>
<p>As you will instantly make out from the image, there is a micro HDMI port onboard, over which you can hook up your HD monitor or a TV screen. Second there is a micro SD card slot. This will be the primary storage device for this computer. Other than that, you will also find two USB sockets and a camera bus. You may think this is it, but the best is yet to come. Raspberry Pi has something called <strong>GPIO</strong>, which stands for <strong>general purpose input/output</strong>. These are disguised as small 40 through-hole ports on one corner of the Raspberry Pi; this is what makes it super special.</p>
<p>Now, conventionally you would attach things to your computer that are compatible with it. So, hooking up a mouse, keyboard or a joystick is as easy as inserting a USB port, but what if you need to connect your computer to your light bulbs or your air-conditioner? Exactly, you can't. That's where GPIO comes in to save the day. These are pins which are very useful when it comes to robotics, as these can be used to connect various components such as sensors/motors. The beauty of these pins is that they can be used as either input or output based on what we program them for. So, as we will later see, each of these pins can be defined in the program to be either input or output based on our needs.</p>
<p>Now, out of these 40 pins, 26 are GPIO. The rest of the pins are generic power or ground ports. There are two more ports called <strong>ID EEPROM</strong> which at this point of time we do not require:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/40b46d85-543e-4c57-9314-796e12d6ca43.png" style="width:52.50em;height:16.17em;"/></div>
<p>As you can see, Raspberry Pi is capable of giving us two types of power supply: 3.3V and 5V. These basically cater for most of our purposes.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up Raspberry Pi</h1>
                </header>
            
            <article>
                
<p>We will talk about the GPIO and other things to do with Raspberry Pi in a while. Firstly, we will understand how to set up this board for the first time.</p>
<p>The first thing you need to do is to make sure that the operating system of Raspberry Pi is ready. I am assuming that you are using a Windows PC, but if you are doing it on another OS as well, then there will not be much of a difference.</p>
<p>To install the OS, start your PC and follow these steps:</p>
<ol>
<li>Go to <a href="http://www.raspberrypi.org">www.raspberrypi.org</a> and click on <span class="packt_screen">DOWNLOADS</span></li>
<li>Now click on <span class="packt_screen">RASPBIAN</span>, you will see the following two options:
<ul>
<li><span class="packt_screen">RASPBIAN STRETCH WITH DESKTOP</span></li>
<li><span class="packt_screen">RASPBIAN STRETCH LITE</span></li>
</ul>
</li>
<li>We will be downloading <span class="packt_screen">RASPBIAN STRETCH WITH DESKTOP</span>; this will give us the GUI interface for Raspberry Pi</li>
<li>After downloading, unzip the package into a folder</li>
</ol>
<p>Now we need to copy it to the memory card of Raspberry Pi. The memory card over which you need to copy must be formatted by low level formatting. There are basically two types of formatting. one which simply erases the index the other one which we know as low level formatting is the one in which we remove all the data from both the index and their physical memory location. There would be a button to toggle a low level format. Make sure it is clicked before you format your memory card for this function.  I would recommend using the SD card formatter by <a href="http://www.sdcard.org">www.sdcard.org</a>. Now open the formatter and you simply have to format it using the 32 KB option.</p>
<div class="packt_infobox">Find more details and more up-to-date information here: <a href="https://www.raspberrypi.org/documentation/installation/installing-images/README.md">https://www.raspberrypi.org/documentation/installation/installing-images/README.md</a>.</div>
<p>Once done, you have to copy the image onto the SD card. The easiest way to do that is by using WinDisk Imager. You can download it online without any problems. Then simply select the image and the location on your SD card and start copying the image.</p>
<p>This could take a few minutes. After it is done, your SD will be ready. Plug it into Raspberry Pi and we will be ready to power it up. But before you power it up, plug in your monitor using the Micro HDMI to HDMI wire, connect the keyboard and mouse to Raspberry Pi using the Micro USB, and power it up by using the Micro USB adapter to standard USB adapter. Now, use the other USB port on Raspberry Pi to power it up using the micro USB power adapter.</p>
<p>Once you start it up, you will see a boot-up screen and within a few seconds you will be able to see the desktop. So, finally, our Raspberry Pi is up and running.</p>
<p>Go ahead and explore a few options, surf the internet, look at some cat videos on YouTube, and get yourself familiar with this mighty device.</p>
<p>By now, you must already be appreciating the power of Raspberry Pi. It may be slightly slower than your average computer. But, come on, this thing costs just $10!</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's program</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will get you familiar with Python and how you can use the GPIOs on this device. To do this, go ahead and click on the Raspberry icon in the top left-hand corner. You will see the Python console 3.0. There could be an older version of Python as well. We will be using the newer version in this book.</p>
<p>Once the window opens, you will see the playground where you would be doing the coding. So now we are ready to write the first code for Python Robotics. Now let's see how it's done.</p>
<p>The first thing we will write is:</p>
<p><img src="Images/5ee664a7-351f-4b9c-bbca-c5557b1e4b10.png" style="width:43.50em;height:22.58em;"/></p>
<p>Almost all of the time when we start writing a program, we will start by writing the preceding line. Now, before we understand what it does, we need to understand libraries. Often while we are writing code, we will have to write the code again and again in multiple places. This takes a lot of time and certainly is not cool!</p>
<p>So, to solve this problem, we created functions. A function is a miniature program that we might think would be used over and over again. In this miniature program itself, we also mention what it would be called.</p>
<p>Let's say that there is a code in which we need to multiply two numbers again and again. So, what we do is we write the code once and make it a function. We also name this function <kbd>Multiply</kbd>.</p>
<p>So now, whenever we need to multiply two numbers, we don't have to write its code again; rather, we simply have to call the function to do it for us instead of writing the code to multiply. The problem is, how do we tell which number has to be multiplied?</p>
<p>There is a solution to that as well. As you might see later, whenever a function is called we put opening and closing brackets after it, such as <kbd>multiply()</kbd>.</p>
<p>If the brackets are empty that means no user input has been given. If, for example, we have to multiply <kbd>2</kbd> and <kbd>3</kbd> we simply write <kbd>Multiply(2,3)</kbd>.</p>
<p>We are giving the input as <kbd>2</kbd> and <kbd>3</kbd>. The position of the input in the brackets is also important as the position in the brackets will define where in the program it will go.</p>
<p>Now, let's say you make functions such as:</p>
<ul>
<li>Add</li>
<li>Subtract</li>
<li>Multiply</li>
<li>Divide</li>
</ul>
<p>Say you stack them together. Then the pile of functions grouped together will be called a library. These libraries can have hundreds of functions. There are some functions which are already in the Python language so that the job is made simpler for the programmers. Others can be defined as open source or developed by you at your convenience.</p>
<p>Now, getting back to the point. We are calling the library <kbd>RPi.GPIO</kbd>; this is a library defined by Raspberry Pi. This will have functions that will make your life easier when it comes to programming Raspberry Pi. So, in the program, once we call the library, all the functions are at your disposal and ready to be used.</p>
<p>In the next line, we write <kbd>Import.time</kbd>. As you must have guessed, this is used to import a library time. What it does we will learn shortly.</p>
<p>The next line of code would be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/04d103ee-4ac2-428e-b240-2ca07db3a80c.png" style="width:31.42em;height:11.42em;"/></div>
<p>Before we understand what it does, let's learn a bit more about GPIOs. These pins are hard numbered according to their physical positions in Raspberry Pi. However, we can change the numbering of the pins in the software for our understanding and convenience. But in this code, we will not be playing around with this and will set it do the default set by Broadcom, which is the manufacturer of the microcontroller of Raspberry Pi.</p>
<p>This line uses a function of the <kbd>RPi.GPIO</kbd> library called <kbd>setmode</kbd>. What this function does is that it sets the pin configuration of the <kbd>setmode</kbd> to (<kbd>GPIO.BCM</kbd>)—<kbd>BCM</kbd> is further a function of <kbd>GPIO</kbd>.</p>
<p>Now we can use the base pin configuration. Further to this, a specialty of the GPIO pins is that it can be used both as input and output. But the only condition is that we have to specify whether it has to be used as input or output in the program itself. It cannot do both functions at the same time. Here is how it is done:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8fc5f7fb-b56d-404c-b9e5-6f38d322e7af.png" style="width:40.25em;height:16.08em;"/></div>
<p>The next line of code will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ca124df5-bb63-41f3-9ec2-79831c3de69d.png" style="width:43.00em;height:17.00em;"/></div>
<p>Again, we are using a function of the library <kbd>GPIO</kbd> called <kbd>output</kbd>. What this does is that it sets up a specific pin of the board in a state which we want. So, here we have mentioned that the pin number <kbd>23</kbd> has to be set high. Just for the sake of clarity, high means on and low means off.</p>
<p>The next line of code will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/fa89f23f-8885-4930-904a-fc5963aabb32.png" style="width:42.33em;height:17.50em;"/></div>
<p>In this line, we are using a function from the library time. The function sleep basically freezes the state of all the GPIO pins. So, for example, if the pin <kbd>23</kbd> is high then it will remain high until the <kbd>time</kbd> the function <kbd>sleep</kbd> is executed. In the function <kbd>sleep</kbd>, we have defined the value as <kbd>3</kbd> seconds. </p>
<p>Hence, for 3 seconds, the pin state of Raspberry Pi will remain as it was before this line of code.</p>
<p>Finally, the last line of the code will be:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9bdfa216-7f84-4710-b216-5d5255de8cc0.png" style="width:35.83em;height:16.42em;"/></div>
<p>This will be a common sight after every program. This function of the GPIO library will reset the state of every pin that has been used in the program—the state of all the pins will be low. Remember, it will only affect the pins that are used in the program and not any other pins. So, for example, we have used the pin <kbd>23</kbd> in the program, so it will only affect pin <kbd>23</kbd> and not any other pin in Raspberry Pi.</p>
<p>Finally, your program will look something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/52d7dbc0-17c5-4852-ab00-a6ad17c14f6d.png" style="width:17.67em;height:17.42em;"/></div>
<p>Now, one thing that you must remember is that whatever code we are writing will be executed one line after the other. So, let's say we keep <kbd>import RPI.GPIO as GPIO</kbd> at the bottom, then the whole program will not work. Why? Because as soon as it goes to <kbd>GPIO.setmode(GPIO.BCM)</kbd> it will not understand what <kbd>GPIO</kbd> is, neither will it understand what <kbd>setmode</kbd> is. Hence, we always import the libraries as soon as we start writing the code.</p>
<p>Now, working on the same concept, it will execute the program in the following way:</p>
<ul>
<li class="mce-root"><span><kbd>GPIO.out(23,GPIO.High)</kbd>: It will turn pin <kbd>23</kbd> high/on</span></li>
<li><span><kbd>time.sleep(3)</kbd>: It will wait for 3 seconds while pin is still high</span></li>
<li><kbd>GPIO.cleanup()</kbd>: <span>Finally, it will </span>set<span> the state of the pin <kbd>23</kbd> to low</span></li>
</ul>
<p>Now, to see whether the program is working, let's attach some hardware to check whether what we have written is actually happening.</p>
<div class="packt_infobox">I am assuming that readers are already aware of how breadboard is used. If you are not familiar with it, just go ahead and google it. It will take 5 minutes to understand. It is super easy and will come in handy.</div>
<p>Now go ahead and connect the LED on breadboard, then connect the ground of the LED to the ground pin in Raspberry Pi, and set the positive/VCC to pin number <kbd>23</kbd> (refer the pin diagram).</p>
<p>You can also refer to the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a489f447-7e48-4843-a88e-aee2c71abb39.png" style="width:23.67em;height:34.25em;"/></div>
<p>Once you are done, go ahead run the code and see what happens!</p>
<p>The LED will glow for 3 seconds and then turn back off again, exactly as we expected it to do. Now let's just play around with the code and do a slight modification. This time, we will add a few more lines marked in bold:</p>
<pre>import RPi.GPIO as GPIO<br/>from time<br/>import sleep<br/>GPIO.setmode(GPIO.BOARD)<br/>GPIO.setup(23, GPIO.OUT)<br/><strong>while True:</strong><br/><strong>  for i in range(3):</strong><br/>  GPIO.output(23, GPIO.HIGH)<br/>sleep(.5)<br/>GPIO.output(23, GPIO.LOW)<br/>sleep(.5)<br/>sleep(1)<br/>GPIO.cleanup()</pre>
<p>Before understanding what's inside the code, you will notice that not every line is aligned, they have been intended. What does this mean ? <br/>
<br/>
A line indented together with other lines of code is called a block. So for example if you have a statement such as </p>
<pre><strong>while True:</strong><br/><strong>  for i in range(3):</strong><br/>  GPIO.output(23, GPIO.HIGH)<br/>sleep(.5)<br/>GPIO.output(23, GPIO.LOW)<br/>sleep(.5)<br/>sleep(1)<br/>GPIO.cleanup()</pre>
<p>Now in this line lets see how the code will run.</p>
<ul>
<li>A while true loop would run, this will run the code that is inside it i.e. </li>
</ul>
<pre style="padding-left: 60px"><strong>for i in range(3):</strong><br/>  GPIO.output(23, GPIO.HIGH)<br/>sleep(.5)<br/>GPIO.output(23, GPIO.LOW)<br/>sleep(.5)<br/>sleep(1)</pre>
<ul>
<li>Thereafter the code <kbd>for I in range (3):</kbd> would run. It will run the code inside the for loop until the value of <kbd>I</kbd> is in range, Hence the code below would run. </li>
</ul>
<pre style="padding-left: 60px">GPIO.output(23, GPIO.HIGH)<br/>sleep(.5)<br/>GPIO.output(23, GPIO.LOW)<br/>sleep(.5)</pre>
<p>The above code can be referred to a block of code, which is inside the <kbd>for</kbd> loop. The block of code can be made by indenting the code. </p>
<p>Now, let's see what it does. <kbd>While True</kbd> is a loop, it will run the <kbd>for</kbd> loop inside it again and again until the time the condition is not false. The condition we are using here is:</p>
<pre>for i in range(3):</pre>
<p>The maximum range is <kbd>3</kbd> and every time the statement runs it increments the value of the <kbd>i</kbd> by <kbd>+1</kbd>. So it basically acts as a counter. Let's see what the program will actually do.</p>
<p>It will check for the value of <kbd>i</kbd> and increment it by <kbd>1</kbd> thereafter. As the code progresses, it will glow the LED high for 0.5 seconds and then shut it off for 0.5 seconds. And then it will wait for 1 second. This will repeat until the while loop is false, as in the value of <kbd>i</kbd> becomes greater than <kbd>3</kbd> where it would get out of the program and terminate. Run the program and see if it actually happens.</p>
<p>By now, you understand how easy the programming is in Raspberry Pi. To go a step further, we will make another program and make some changes to the hardware.</p>
<p>We will be connecting five more LEDs from <span>pin numbers 7 through to 12. We w</span>ill make them switch on and off in a pattern.</p>
<p>Once connected, we will write the code as follows:</p>
<pre>import RPi.GPIO as GPIO<br/>from time<br/>import sleep<br/>GPIO.setmode(GPIO.BOARD)<br/>GPIO.setup(7, GPIO.OUT)<br/>GPIO.setup(8, GPIO.OUTPUT)<br/>GPIO.setup(9, GPIO.OUTPUT)<br/>GPIO.setup(10, GPIO.OUTPUT)<br/>GPIO.setup(11, GPIO.OUTPUT)<br/>while True:<br/>  for i in range(7, 12):<br/>  GPIO.output(i, GPIO.HIGH)<br/>sleep(1)<br/>GPIO.cleanup()</pre>
<p>Now the code is fairly simple. Let's see what it means:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6019e3ef-2d79-43cc-9116-b0ae31bcfd98.png" style="width:46.17em;height:19.25em;"/></div>
<p>Before I tell you something more about the code, let's go ahead and run it.</p>
<p>When you run it, you will understand that as per the statement it is addressing the pins one by one and switching them to high after every 1 second.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Playing with voltage</h1>
                </header>
            
            <article>
                
<p>So far so good! But did you notice one thing? We have been using Raspberry Pi as a switch—simply switching the various components on and off. But what if we need to vary the intensity of the LEDs that we have just programmed? Is it possible? The answer is no. But we can still get it done somehow!</p>
<p>Let's see how. Computers work in binary which means that they can represent either <kbd>0</kbd> or <kbd>1</kbd>. This is because of the fact that the primary computing unit in any system is based on a transistor which can either be on or off representing <kbd>0</kbd> or <kbd>1</kbd>. So, if we see this technically, computers are only capable of switching due to the binary architecture. However, there is a trick. This trick is called <strong>pulse width modulation</strong> (<strong>PWM</strong>).</p>
<p>Now, before I explain any of it in detail, let's go ahead plug in an LED on pin number <kbd>18</kbd>, then copy this code into Raspberry Pi and run it:</p>
<pre>import RPi.GPIO as GPIO<br/>import time                             <br/>GPIO.setmode(GPIO.BCM)       <br/>GPIO.setup(18,GPIO.OUT)         <br/><br/>pwm= GPIO.PWM(18,1)<br/>duty_cycle = 50<br/>pwm.start(duty_cycle)<br/><br/>time.sleep(10)<br/><br/>GPIO.cleanup()</pre>
<p>What did you notice? The LED will be blinking at once a second. Now let's tweak it a bit and change the <span><span><kbd>PWM(18,1)</kbd> to <kbd>PWM(18,5)</kbd>. </span></span>Let's run and see what happens.</p>
<p>You will have noticed that it is now blinking five times in a second. So the number <kbd>5</kbd> is basically representing the frequency as the LED is now flickering five times in a second. Now, again, rewrite the code and increase <kbd>5</kbd> to <kbd>50</kbd>. Once you increase it to <kbd>50</kbd>, it switches the LED on and off 50 times in a second or at 50 Hertz. So, it appears to you as if it is always on. </p>
<p>Now comes the interesting part. Go over to your code and change <kbd>duty_cycle = 50</kbd> to <kbd>duty_cycle = 10</kbd>.</p>
<p>What did you notice? You must have seen that the LED is now glowing way lower in intensity. In fact, it will be half of what it originally was. </p>
<p>Let's see what is actually happening:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d096bb71-0cd9-4ef1-b876-e4dea3f58085.png"/></div>
<p>As you can make out from the diagram, the function is basically creating a pulse, the characteristics of which we are changing. The first characteristic is the frequency, the pulses generated in a second. In the code line <kbd>pwm= GPIO.PWM(18,1)</kbd> , we are basically telling the microcontroller to generate one pulse every second on pin number <kbd>1</kbd>. In the second line, duty cycle is a percent value. It determines for how much percent of the time the pulse will be high. For the rest of the time of the pulse the output of the pin will be off. So, for the following code, the below bulleted points would be the characteristics:</p>
<pre>pwm= GPIO.PWM(18,1)<br/>duty_cycle = 50</pre>
<ul>
<li>Time/width of every pulse is 1 second</li>
<li>Percent of time it would on is 50%</li>
<li>Percent of time it would be off is 50%</li>
<li>Time it would be on is 0.5 seconds</li>
<li>Time it would be off is 0.5 seconds</li>
</ul>
<p>When we increase the frequency more than 50 hertz then it is very hard for the human eye to make out if it is actually switching on or off. Theoretically, for 50% of the time the pin will remain high, and for the rest of the time it will be low. So, if we take an average then we can easily say that the overall voltage would be half of the original. Using this method, we can modulate the voltage output of any pin as per our requirements.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Now you must have understood how the GPIOs can be used as output and how, by applying conditions, we can change their behaviors.</p>
<p>In the next chapter, we will understand how these pins can be used as input as well. So come back, and see you there!</p>


            </article>

            
        </section>
    </div></body></html>