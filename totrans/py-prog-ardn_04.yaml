- en: Chapter 4. Diving into Python-Arduino Prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the completion of the first project, you successfully started Python-Arduino
    interfacing. We also interfaced multiple hardware components, that is, motion
    sensor and LEDs with Arduino via digital pins. During the project, you learned
    more about the Firmata protocol while utilizing simple Python methods that helped
    you to establish a connection between your Arduino board and the Python program.
    When you are working on complex projects, you need more than basic methods to
    implement the different features that are required by the projects and their associated
    electronics components. This chapter is designed to give you a comprehensive experience
    of interfacing so that you can start working on hard problems from the next chapter
    onwards. We have described various interfacing protocols at the Python-Arduino
    and Arduino-to-components levels. This chapter also includes practical examples
    for these protocols with appropriate code and circuit diagrams. In this chapter,
    we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed description of various `pyFirmata` methods to port Arduino functionalities
    into Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python-Arduino interfacing examples using Firmata for basic electronic components
    such as the potentiometer, the buzzer, the DC motor, and the servomotor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the **inter-integrated circuit** (**I2C**) protocol and prototyping
    examples for the I2C components such as the temperature sensor (TMP102) and the
    light sensor (BH1750)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just for a moment, let's step back and look at the project that we built in
    the previous chapter. The project had a very simple goal and we were able to develop
    it quite comfortably. However, the project is certainly not ready to be a consumer
    product since it doesn't have significant functionalities and most importantly,
    it is not a robust product that can be repeatedly produced as it is. What you
    can tell about your current project is that it is a DIY project for personal use
    or just a model that can be developed further to be a great product.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you are looking to develop a commercial product or just a DIY project
    that is really robust and scalable, you must consider starting it by making a
    model first. At this stage, you need to envision the product with the required
    features that need to be developed and the number of components that are required
    to deploy these features. Prototyping is basically a rapid way to create a working
    model of your envisioned idea before developing it into a fully functional project
    or product. The proof of concept prototype that is developed during this prototyping
    process lets you to identify the feasibility of your idea, and in some cases,
    it helps you to explore the potential of your project. The prototyping or functional
    model-making process is essential for any industry and not just for electronics.
  prefs: []
  type: TYPE_NORMAL
- en: In the electronics domain, prototyping can be used at the very first stage of
    interfacing components to a computer, instead of directly spending a significant
    amount of resources for the schematic design, PCB manufacturing, and developing
    the complete code base. This stage helps you to identify major flaws in your circuit
    design and check the mutual compatibility of the selected components.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Arduino and the existing software support around Arduino have really
    simplified electronics' prototyping. In the upcoming sections, we will go through
    various helper functions and interfacing exercises to help you proceed with your
    own projects. These examples or templates are designed in such a fashion that
    they can be used as a blueprint for larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into these prototyping examples, let''s understand two different
    abstractions of interfacing that we are going to explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfacing Arduino with Python**: We have learned the easiest method of
    Python-Arduino interfacing using the Firmata protocol. On the Arduino board, the
    Firmata protocol is implemented using the **StandardFirmata** firmware, while
    on the Python end, we used the Firmata libraries, `pyFirmata` or `pyMata`, for
    Python. Another Python-Arduino interfacing method includes the use of simple but
    nonstandard serial commands using the custom Arduino sketch and the `pySerial`
    library in the Python program. It is also possible to use a computer network to
    establish communication between Python and Arduino, which is covered later in
    the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfacing electronic components with Arduino**: The second interfacing
    abstraction is associated with Arduino and the physical components. As we already
    did, various electronics components can be simply interfaced with the Arduino
    board using digital or analog pins. These components deal with either digital
    or analog signals. A few digital pins on the Arduino board support PWM communication
    for specific hardware devices. The other alternative interfacing methods include
    I2C and **serial peripheral interface** (**SPI**) communication. The I2C method
    is comprehensively explained in the final section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with pyFirmata methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pyFirmata` package provides useful methods to bridge the gap between Python
    and Arduino's Firmata protocol. Although these methods are described with specific
    examples, you can use them in various different ways. This section also provides
    a detailed description of a few additional methods that were not used in the previous
    project and lists the missing features.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Arduino board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up your Arduino board in a Python program using `pyFirmata`, you need
    to specifically follow the steps that we have covered. We have distributed the
    entire code that is required for the setup process into small code snippets in
    each step. While writing your code, you will have to carefully use the code snippets
    that are appropriate for your application. You can always refer to the example
    Python files containing the complete code. Before we go ahead, let''s first make
    sure that your Arduino board is equipped with the latest version of the **StandardFirmata**
    program and is connected to your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the Arduino board that is being utilized, start by importing
    the appropriate `pyFirmata` classes to the Python code. Currently, the inbuilt
    `pyFirmata` classes only support the Arduino Uno and Arduino Mega boards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of Arduino Mega, use the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start executing any methods that are associated with handling pins,
    you need to properly set up the Arduino board. To perform this task, we have to
    first identify the USB port to which the Arduino board is connected and assign
    this location to a variable in the form of a string object. For Mac OS X, the
    port string should approximately look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Windows, use the following string structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of the Linux operating system, use the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The port's location might be different according to your computer configuration.
    You can identify the correct location of your Arduino USB port by using the Arduino
    IDE, as described in [Chapter 2](ch02.html "Chapter 2. Working with the Firmata
    Protocol and the pySerial Library"), *Working with the Firmata Protocol and the
    pySerial Library*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have imported the Arduino class and assigned the port to a variable
    object, it''s time to engage Arduino with `pyFirmata` and associate this relationship
    to another variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, for Arduino Mega, use this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The synchronization between the Arduino board and `pyFirmata` requires some
    time. Adding sleep time between the preceding assignment and the next set of instructions
    can help to avoid any issues that are related to serial port buffering. The easiest
    way to add sleep time is to use the inbuilt Python method, `sleep(time)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `sleep()` method takes seconds as the parameter and a floating-point number
    can be used to provide the specific sleep time. For example, for 200 milliseconds,
    it will be `sleep(0.2)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you have successfully synchronized your Arduino Uno or Arduino
    Mega board to the computer using `pyFirmata`. What if you want to use a different
    variant (other than Arduino Uno or ArduinoMega) of the Arduino board?
  prefs: []
  type: TYPE_NORMAL
- en: 'Any board layout in `pyFirmata` is defined as a dictionary object. The following
    is a sample of the dictionary object for the Arduino board:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For your variant of the Arduino board, you have to first create a custom dictionary
    object. To create this object, you need to know the hardware layout of your board.
    For example, an Arduino Nano board has a layout similar to a regular Arduino board,
    but it has eight instead of six analog ports. Therefore, the preceding dictionary
    object can be customized as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you have already synchronized the Arduino board earlier, modify the layout
    of the board using the `setup_layout(layout)` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will modify the default layout of the synchronized Arduino board
    to the Arduino Nano layout or any other variant for which you have customized
    the dictionary object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring Arduino pins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your Arduino board is synchronized, it is time to configure the digital
    and analog pins that are going to be used as part of your program. Arduino board
    has digital I/O pins and analog input pins that can be utilized to perform various
    operations. As we already know, some of these digital pins are also capable of
    PWM.
  prefs: []
  type: TYPE_NORMAL
- en: The direct method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now before we start writing or reading any data to these pins, we have to first
    assign modes to these pins. In the Arduino sketch-based approach that we used
    in the previous chapter, we used the `pinMode` function, that is, `pinMode(11,
    INPUT)` for this operation. Similarly, in `pyFirmata`, this assignment operation
    is performed using the `mode` method on the board object as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `pyFirmata` library includes classes for the `INPUT` and `OUTPUT` modes,
    which are required to be imported before you utilized them. The preceding example
    shows the delegation of digital pin 13 as an output and the analog pin 0 as an
    input. The mode method is performed on the variable assigned to the configured
    Arduino board using the `digital[]` and `analog[]` array index assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pyFirmata` library also supports additional modes such as `PWM` and `SERVO`.
    The `PWM` mode is used to get analog results from digital pins, while the `SERVO`
    mode helps a digital pin to set the angle of the shaft between 0 to 180 degrees.
    The `PWM` and `SERVO` modes are explained with detailed examples later in this
    chapter. If you are using any of these modes, import their appropriate classes
    from the `pyFirmata` library. Once these classes are imported from the `pyFirmata`
    package, the modes for the appropriate pins can be assigned using the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In electronics, PWM is a signal modulation technique that is greatly used to
    provide controlled amount of power to components. While dealing with digital signals,
    the PWM technique is used to obtain analog results by utilizing square waves and
    controlling the width of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, the digital pins of the Arduino board can only have two
    states, 5V (HIGH) and 0V (LOW). One can generate square pulses by controlling
    the switching pattern between HIGH and LOW and thus generate the pulse. By changing
    the width of these pulses, you can simulate any voltage between 0V and 5V. As
    you can see in the following diagram, we have a square wave with 25 percent width
    of the duty cycle. It means that we are simulating 0.25 * 5V = 1.25V for the period
    of that duty cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The direct method](img/5938OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Arduino language supports PWM using the `analogWrite()` function, where
    the voltage range between 0V and 5V is linearly scaled for values between 0 and
    255\. For example, 50 percent duty cycle (simulation of 2.5V) translates to a
    value of 127, which can be coded in Arduino as `analogWrite(13,127)`. Here, the
    number `13` represents the digital pin that supports PWM on the Arduino Uno board.
    Similarly, a 20 percent duty cycle (1V) translates to `analogWrite(13,64)`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning pin modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The direct method of configuring pins is mostly used for a single line of execution
    calls. In a project containing a large code and complex logic, it is convenient
    to assign a pin with its role to a variable object. With an assignment like this,
    you can later utilize the assigned variable throughout the program for various
    actions, instead of calling the direct method every time you need to use that
    pin. In `pyFirmata`, this assignment can be performed using the `get_pin(pin_def)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `get_pin()` method lets you assign pin modes using the `pin_def` string
    parameter, `'d:13:o'`. The three components of `pin_def` are pin type, pin number,
    and pin mode separated by a colon (`:`) operator. The pin types (analog and digital)
    are denoted with `a` and `d` respectively. The `get_pin()` method supports three
    modes, `i` for input, `o` for output, and `p` for PWM. In the previous code sample,
    `'d:13:o'` specifies the digital pin 13 as an output. In another example, if you
    want to set up the analog pin 1 as an input, the parameter string will be `'a:1:i'`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you have configured your Arduino pins, it''s time to start performing actions
    using them. Two different types of methods are supported while working with pins:
    reporting methods and I/O operation methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Reporting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When pins get configured in a program as analog input pins, they start sending
    input values to the serial port. If the program does not utilize this incoming
    data, the data starts getting buffered at the serial port and quickly overflows.
    The `pyFirmata` library provides the reporting and iterator methods to deal with
    this phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enable_reporting()` method is used to set the input pin to start reporting.
    This method needs to be utilized before performing a reading operation on the
    pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the reading operation is complete, the pin can be set to disable reporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we assumed that you had already set up the Arduino
    board and configured the mode of the analog pin 3 as `INPUT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pyFirmata` library also provides the `Iterator()` class to read and handle
    data over the serial port. While working with analog pins, we recommend that you
    start an iterator thread in the main loop to update the pin value to the latest
    one. If the iterator method is not used, the buffered data might overflow your
    serial port. This class is defined in the `util` module of the `pyFirmata` package
    and needs to be imported before it is utilized in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Manual operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have configured the Arduino pins to suitable modes and their reporting
    characteristic, we can start monitoring them. The `pyFirmata` library provides
    the `write()` and `read()` methods for the configured pins.
  prefs: []
  type: TYPE_NORMAL
- en: The write() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `write()` method is used to write a value to the pin. If the pin''s mode
    is set to `OUTPUT`, the value parameter is a Boolean, that is, `0` or `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have used an alternative method of assigning the pin''s mode, you can
    use the `write()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the PWM signal, the Arduino accepts a value between 0 and 255
    that represents the length of the duty cycle between 0 and 100 percent. The `pyFirmata`
    library provides a simplified method to deal with the PWM values as instead of
    values between 0 and 255, you can just provide a float value between 0 and 1.0\.
    For example, if you want a 50 percent duty cycle (2.5V analog value), you can
    specify `0.5` with the `write()` method. The `pyFirmata` library will take care
    of the translation and send the appropriate value, that is, `127`, to the Arduino
    board via the Firmata protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for the indirect method of assignment, you can use some code similar
    to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using the `SERVO` mode, you need to provide the value in degrees
    between 0 and 180\. Unfortunately, the `SERVO` mode is only applicable for direct
    assignment of the pins and will be available in future for indirect assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The read() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `read()` method provides an output value at the specified Arduino pin.
    When the `Iterator()` class is being used, the value received using this method
    is the latest updated value at the serial port. When you read a digital pin, you
    can get only one of the two inputs, `HIGH` or `LOW`, which will translate to `1`
    or `0` in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The analog pins of Arduino linearly translate the input voltages between 0 and
    +5V to 0 and 1023\. However, in `pyFirmata`, the values between 0 and +5V are
    linearly translated into the float values of 0 and 1.0\. For example, if the voltage
    at the analog pin is 1V, an Arduino program will measure a value somewhere around
    204, but you will receive the float value as 0.2 while using pyFirmata's `read()`
    method in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Additional functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the method that has already been described, the `pyFirmata` library
    also provides some utility functions for additional customization, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`servo_config(pin,min_pulse=544,max_pulse=2400,angle=0)`: This method helps
    to set up the `SERVO` mode with further customization such as the minimum pulse
    value, maximum pulse value, and starting angle. One can set the initial angle
    of the servomotor using the `angle` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pass_time(seconds)`: This method provides a functionality similar to that
    found in the default Python''s default method `sleep()` that is provided by the
    `time` module. However, the `pass_time` function provides a non-blocking timeout
    in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_firmata_version()`: This function returns a tuple that contains the version
    of the Firmata protocol from the Arduino board:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`exit()`: We recommend that you disconnect the Arduino board from `pyFirmata`
    once you have completed running your code. This will free the serial port, which
    can be then utilized by other programs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upcoming functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pyFirmata` library is currently under development and it continuously
    receives updates to add and improve various methods. Although most of the native
    Arduino methods are available in the `pyFirmata` library via the Firmata protocol,
    there are few functions that are still missing or under development and they are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pulseIn`/`pulseOut`: These native Arduino functions wait for the Arduino pin
    to achieve the specified value. The waiting period is returned in microseconds.
    This method is widely used by Ping (ultrasonic distance measurement) sensors.
    Implementation of this method using `pyFirmata` requires major changes to the
    standard Firmata protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shiftIn`/`shiftOut`: These functions shift a byte of data in or out, one bit
    at a time. The `pyFirmata` library lacks supports for these functions and can
    be implemented using the various Python programming tricks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototyping templates using Firmata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this section is to provide prototyping templates while also explaining
    various Python methods and programming techniques. It tries to cover some of the
    most popular sensors with coding examples that are used by DIY Arduino projects.
    This section is designed to utilize the Firmata protocol to implement these Python
    programs. It also includes various Python programming paradigms such as working
    with indefinite loops, creating custom functions, working with random numbers,
    acquiring manual inputs from prompt, and so on. These prototyping templates are
    designed in such a way that they can be easily included in large projects or they
    can be blueprints for a larger project that can be developed around them. You
    learned about the `pyFirmata` package comprehensively in the previous section
    and we will only utilize those `pyFirmata` functions in the upcoming examples.
    An alternative Python library that supports the Firmata protocol is covered later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Potentiometer – continuous observation from an analog input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A potentiometer is a variable resistor that can be controlled using a knob.
    It has three terminals out of which two of them are Vref and ground, while the
    third one provides a variable output. The output of the potentiometer varies between
    the supplied voltages, according to the position of the knob. In Arduino, you
    can connect the potentiometer with +5V and the ground pins of the board to provide
    the supply voltage. When the variable terminal is interfaced with the Arduino
    analog input, this voltage values translates between 0 and 1023 respectively.
    In the case of `pyFirmata`, the value of the analog observation translates between
    0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: This coding template containing the potentiometer can be applied to projects
    in which external manual control to a system is required. The potentiometer output
    that translates to the analog input of Arduino can be used to control an actuator
    such as a motor or an LED. In some cases, the input can also be used to control
    the flow of the program by applying its values to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect the output of the potentiometer to analog pin A0 as shown in the following
    diagram. Complete the circuit by connecting Vref and the ground terminals of the
    potentiometers to +5V and the ground of the Arduino board respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connections](img/5938OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assuming that you already have the **StandardFirmata** firmware uploaded to
    the Arduino board, you are required to run a Python code on your computer to complete
    its interfacing with the potentiometer. A Python code template with the name `potentiometer.py`
    to help you get started with this example is located in the code bundle of this
    book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Let''s open this file to understand the program. As you can see, we are using
    the `pyFirmata` library with other Python modules such as `time` and `os`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second step of the program, we are initializing the Arduino board and
    starting the `Iterator()` function over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the board has been initialized, we need to assign a role to the analog
    pin, `0`, as it is going to be used as an input pin. We are using the `get_pin()`
    method to assign a role to the analog pin, `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as part of the main program, we need to continuously monitor the output
    of the potentiometer at the pin, `a0`, that we just defined. We are using the
    `while` statement to create an indefinite loop for the script that will read and
    print the analog input. The problem with this indefinite `while` loop is that
    the program will not close properly when it is interrupted and it will not release
    the board by executing the `board.exit()` method. To avoid this, we will use another
    control statement from the Python programming paradigm, called `try/except`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using this statement, the program will keep running the `while` loop until the
    keyboard interruption occurs, which is *Ctrl* + *C*, and the program will execute
    the script under the `except` statement. This includes releasing the board using
    `board.exit()` and existing the program using the `os._exit()` method. In summary,
    the program will keep printing the output of the potentiometer until someone presses
    *Ctrl* + *C* to interrupt the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `try/except` statement provides a very efficient way to capture exceptions
    in Python. It is advisable to utilize this statement throughout the development
    process to cleverly debug your programs. You can learn about Python errors and
    exceptions from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/reference/compound_stmts.html#try](https://docs.python.org/2/reference/compound_stmts.html#try)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/tutorial/errors.html](https://docs.python.org/2/tutorial/errors.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buzzer – generating sound alarm pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital buzzer sensors are used in various applications that require alarm notifications.
    These sensors produce sound when they are supplied with a digital `HIGH` value
    (that is, +5V), which can be provided by using Arduino digital pins. Similar to
    the LED example in the previous chapter, they are very easy to interface with
    Arduino. However, rather than performing a simple digital output, we are implementing
    Python programming tricks to generate different sound patterns and produce various
    sound effects. The same code template can be also used to produce different LED
    blink patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An analog digital buzzer can be found at [http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634](http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634).
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As displayed in the following circuit diagram, connect the VCC and the ground
    of the sensor board to 5V and the ground pin of the Arduino board respectively.
    Connect the signal pin of the sensor to the digital pin 2 via the 220-ohm resistor.
    You can use any digital pin to connect the buzzer. Just make sure that you update
    the Python code to reflect the pin that you have selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connections](img/5938OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the code example, two different sound patterns are generated using arrays
    of time delays. To perform these actions, we are going to implement a custom Python
    function that will take the pin number, the recurrence time, and the pattern number
    as input. Before we jump to explain the code, let''s open the program file, `buzzerPattern.py`,
    from the code folder. In the beginning of the code, you can find the Python function,
    `buzzerPattern()` that will be called from the main program with appropriate options.
    As this function is the core of the entire program, let''s try to understand it.
    The function contains two hardcoded pattern arrays, `pattern1` and `pattern2`.
    Each contains the on and off time for the buzzer for a second, which is the duty
    cycle of the pattern. For example, in `pattern1`, `0.8` represents the time the
    buzzer needs to be on and `0.2` represents the opposite. The function will repeat
    this buzzer pattern for `recurrence` times that is specified by the function argument.
    Once the `for` loop with the value of `recurrence` is started, the function will
    check for the pattern number from the function argument and execute the pattern.
    We are using the `flag` variable to alternatively use elements of the `pattern`
    array to control the buzzer. Once the entire recurrence loop is complete, we will
    turn off the buzzer completely again, if it is on, and safely disengage the board
    using the `exit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to change the time delays or implement a totally different pattern,
    you can play around with the `pattern` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the program is relatively simple as it contains code
    for importing libraries and initializing the Arduino board. Once the board is
    initialized, we will execute the `buzzerPattern()` function with the input argument,
    `(2, 10, 1)`. This argument will ask the function to play `pattern1` 10 times
    on the pin number 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: DC motor – controlling motor speed using PWM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DC motors are widely used in robotics applications. They are available in a
    wide range of voltage specifications, depending upon the application. In this
    example, we are utilizing a 5V DC motor because we want to supply the power using
    the Arduino board itself. As the Arduino digital pin can only have two states,
    that is, `HIGH` (+5V) or `LOW` (0V), it is impossible to control the speed of
    the motor using just the `OUTPUT` mode. As a solution, we are going to implement
    the `PWM` mode via digital pins that are capable of supporting PWM. While using
    `pyFirmata`, pins configured with the `PWM` mode take any float input values between
    0 and 1.0, which represent 0V and 5V respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Depending upon the load, DC motors can sometimes draw large amounts of current
    and harm the Arduino board. To avoid any damage to the Arduino board due to any
    large accidental current draw, we will use a transistor as a switch, which only
    uses a small amount of current to control the large amount of current in the DC
    motor. To complete the circuit connection as displayed in the following diagram,
    you will need an NPN transistor (TIP120, N2222, or a similar one), one diode (1N4001
    or similar one) and a 220-ohm resistor with your DC motor. Connect the base of
    the transistor to the digital pin 3 that also supports the PWM mode. Connect the
    remaining components as displayed in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connections](img/5938OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about transistor terminals (collector, emitter, and base)
    and to associate transistor pins with their respective terminals, you can refer
    to their datasheets or the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Transistor](http://en.wikipedia.org/wiki/Transistor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.onsemi.com/pub/Collateral/TIP120-D.PDF](http://www.onsemi.com/pub/Collateral/TIP120-D.PDF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf](http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python recipe with the name `dcMotorPWM.py` for a DC motor is located in
    the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Open the Python file to further understand the usage of PWM to control the speed
    of the DC motor. The custom function, `dcMotorControl()`, takes motor speed and
    time duration as input parameters as described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the previous examples, we are using a similar code to import the
    necessary library and initialize the Arduino board. After initialization, we are
    assigning the mode of the digital pin 3 as `PWM`, which can be seen from the utilization
    of the `get_pin(''d:3:p'')` method. This code reflects the indirect mode of pin
    mode assignment that we learned in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of collecting manual inputs from the user, we are running a combination
    of the `try/except` statement (to release the board on exit) and the `while` statement
    (to obtain continuous inputs from the user). The code template introduces the
    `input()` method to obtain custom values (motor speed and duration to run the
    motor) from Python''s interactive terminal. Once these values are obtained from
    the user, the program calls the `dcMotorControl()` function to perform the motor
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: LED – controlling LED brightness using PWM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous template, we controlled the speed of DC motor using PWM. One
    can also control the brightness of the LED using the same method. Instead of asking
    the user to input brightness, we are going to use the Python module `random` in
    this template. We will use this module to generate a random number between 1 and
    100, which will be later used to write that value on the pin and randomly change
    the brightness of the LED. This `randint()` function is a really useful feature
    provided by the `random` module and it is widely used in testing prototypes by
    rapidly sending random signals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `randint()` function takes the `randint(startValue, endValue)` syntax and
    returns the random integer between the range established by `startValue` and `endValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like we used in the previous chapter''s project, we will need a pull-up resistor
    to connect the LED with the Arduino pin. As displayed in the following diagram,
    simply connect the anode of the LED (longer leg) to the digital pin 11 via one
    220-ohm resistor and connect the cathode (shorter leg) to the ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connections](img/5938OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note that the digital pin 11 on Arduino Uno is also capable
    of performing PWM along with digital pins 3, 5, 6, 9, and 10.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python code with the title `ledBrightnessPWM.py` for this exercise is located
    in the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Open the file to explore the code. As you can see in this code template, a float
    value between 0 and 1.0 is randomly selected before passing it to the PWM pin.
    This method generates random LED brightness for a given amount of time. This practice
    can be used to generate random input samples for various other testing projects.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the first few lines of the code import the necessary libraries
    and initialize the board. Although the board variable, `/dev/cu.usbmodemfa1311`,
    is selected for Mac OS X, you can use your operating system's specific variable
    name in the following code snippet. You can obtain more information about choosing
    this variable name from the *Setting up the Arduino board* section at the beginning
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are utilizing the direct method of pin mode assignment.
    As you can see in the following code snippet, the digital pin 11 is being assigned
    to the `PWM` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pin mode is assigned, the program will run a loop using the `for`
    statement while randomly generating an integer number between 0 and 100, and then
    send the appropriate PWM value to the pin according to the generated number. With
    the execution of this, you will be able to see the LED randomly changing its brightness
    for approximately 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with the loop, you need to safely disengage the Arduino board
    after turning off the LED one last time. It is a good practice to turn off the
    LED or any connected sensor at the end of the program before exiting the board,
    to prevent any sensor from running accidentally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to homogenously glow the LED instead of randomly changing its brightness,
    replace the code in the `for` loop with the following code snippet. Here, we are
    changing the PWM input to the incrementing variable, `i`, instead of the random
    variable, `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Servomotor – moving the motor to a certain angle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servomotors are widely used electronic components in applications such as pan-tilt
    camera control, robotic arms, mobile robot movements, and so on where precise
    movement of the motor shaft is required. This precise control of the motor shaft
    is possible because of the position sensing decoder, which is an integral part
    of the servomotor assembly. A standard servomotor allows the angle of the shaft
    to be set between 0 and 180 degrees. The `pyFirmata` library provides the `SERVO`
    mode that can be implemented on every digital pin. This prototyping exercise provides
    a template and guidelines to interface a servomotor with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Typically, a servomotor has wires that are color-coded red, black, and yellow
    respectively to connect with the power, ground, and signal of the Arduino board.
    Connect the power and the ground of the servomotor to 5V and the ground of the
    Arduino board. As displayed in the following diagram, connect the yellow signal
    wire to the digital pin 13:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connections](img/5938OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to use any other digital pin, make sure that you change the pin
    number in the Python program in the next section. Once you have made the appropriate
    connections, let's move on to the Python program.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python file consisting of this code is named `servoCustomAngle.py` and
    is located in the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/19610](https://www.packtpub.com/books/content/support/19610).
    Open this file in your Python editor. Like other examples, the starting section
    of the program contains the code to import the libraries and set up the Arduino
    board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have Python ready to communicate with the Arduino board, let''s
    configure the digital pin that is going to be used to connect the servomotor to
    the Arduino board. We will complete this task by setting the `mode` of pin 13
    to `SERVO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setServoAngle(pin,angle)` custom function takes the pins on which the
    servomotor is connected and the custom angle as input parameters. This function
    can be used as a part of various large projects that involve servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main logic of this template, we want to incrementally move the motor
    shaft in one direction until it achieves the maximum achievable angle (180 degrees)
    and then move it back to the original position with the same incremental speed.
    In the `while` loop, we will ask the user to provide input to continue this routine,
    which will be captured using the `raw_input()` function. The user can enter the
    character `y` to continue this routine or enter any other character to abort the
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: While working with all these prototyping examples, we used the direct communication
    method by using digital and analog pins to connect the sensors with Arduino. Now,
    let's get familiar with another widely used communication method between Arduino
    and the sensors, which is called I2C communication.
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping with the I2C protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, sensors or actuators were directly communicating with
    Arduino via digital, analog, or PWM pins. These methods are utilized by a large
    number of basic, low-level sensors and you will be widely using them in your future
    Arduino projects. Beside these methods, there is a wide variety of popular sensors
    that are based on **integrated circuit** (**IC**), which require different ways
    of communication. These IC-based advanced sensors utilize I2C- or SPI bus-based
    methods to communicate with the microcontroller. As we are going to use I2C-based
    sensors in the upcoming projects, the section will only cover the I2C protocol
    and practical example to understand the protocol in a better way. Once you understand
    the fundamentals of the I2C protocol, you can learn the SPI protocol very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about SPI protocol and the supported Arduino SPI library
    from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://arduino.cc/en/Reference/SPI](http://arduino.cc/en/Reference/SPI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/](http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In 1982, the Philips company needed to find out a simple and efficient way
    to establish communication between a microcontroller and the peripheral chips
    on TV sets, which led to the development of the I2C communication protocol. The
    I2C protocol connects the microcontroller or the CPU to a large number of low-speed
    peripheral devices using just two wires. Examples of such peripheral devices or
    sensors include I/O devices, A/D converters, D/A converters, EEPROM, and many
    similar devices. I2C uses the concept of master-slave devices, where the microcontroller
    is the master and the peripherals are the slave devices. The following diagram
    shows an example of the I2C communication bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototyping with the I2C protocol](img/5938OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As displayed in the preceding diagram, the master device contains two bidirectional
    lines: **Serial Data Line** (**SDA**) and **Serial Clock Line** (**SCL**). In
    the case of Arduino Uno, the analog pins 4 and 5 provide interfaces for SDA and
    SCL. It is important to note that these pin configurations will change with different
    variants of the Arduino board. The peripheral sensors that are working as slaves
    connect to these lines, which are also supported by the pull resistors. The master
    device is responsible for generating the clock signal on the SCL and initializing
    communication with the slaves. The slave devices receive the clock and respond
    to the commands sent by the master device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of the slave devices is not important as the master device communicates
    with the slaves using their part address. To initialize the communication, the
    master sends one of the following types of message on the bus with the specific
    part address:'
  prefs: []
  type: TYPE_NORMAL
- en: A single message in which data is written on the slave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single message in which data is read from the slave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple messages in which first data is requested from the slave and then the
    received data is read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To support I2C protocol in Arduino programming, the Arduino IDE comes equipped
    with a default library called `Wire`. This library can be imported to your Arduino
    sketch by adding the following line of code at the beginning of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize I2C communication, the `Wire` library uses a combination of the
    following functions to write data on the slave device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These slave devices are differentiated using unique part addresses. As you can
    see in the preceding example, `0x48` is the part address of a connected slave
    device.
  prefs: []
  type: TYPE_NORMAL
- en: The `Wire` library also provides the `Wire.read()` and `Wire.requestFrom()`
    functions to read and request data from the slave devices. These functions are
    explained in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about the I2C protocol and the `Wire` library from the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.instructables.com/id/I2C-between-Arduinos/](http://www.instructables.com/id/I2C-between-Arduinos/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://arduino.cc/en/reference/wire](http://arduino.cc/en/reference/wire)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino examples for I2C interfacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to practice prototyping exercises for the I2C protocol, let's utilize
    two popular I2C sensors that detect temperature and ambient light in the environment.
    As the first step towards understanding I2C messaging, we will work with Arduino
    sketches for I2C interfacing, and later, we will develop similar functionalities
    using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino coding for the TMP102 temperature sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TMP102 is one of the widely used digital sensors to measure ambient temperature.
    TMP102 provides better resolution and accuracy compared to traditional analog
    temperature sensors such as LM35 or TMP36\. The following is an image of TMP102:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino coding for the TMP102 temperature sensor](img/5938OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous image shows a breakout board with the available pins for the TMP102
    sensor. Please keep in mind that the TMP102 sensor that you obtain might have
    a different pin layout compared to the one displayed in the image. It is always
    advisable to check the datasheet of your sensor breakout board before making any
    connections. As you can see in the image, the TMP102 sensor supports the I2C protocol
    and is equipped with SDA and SCL pins. Connect analog pins 4 and 5 of your Arduino
    Uno board to the SDA and SCL pins of the TMP102 sensor. Also, connect +5V and
    the ground as displayed in the following diagram. In this example, we are using
    the Arduino Uno board as the master and TMP102 as the slave peripheral, where
    the part address of TMP102 is `0x48` in hex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino coding for the TMP102 temperature sensor](img/5938OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can obtain the TMP102 sensor breakout board from SparkFun Electronics at
    [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931).
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet of this board can be obtained at [https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, connect your Arduino board to your computer using a USB cable and create
    a new sketch in the Arduino IDE using the following code snippet. Once you have
    selected the appropriate serial port and type of board in the Arduino IDE, upload
    and run the code. If all the steps are performed as described, on execution, you
    will be able to see the temperature reading in **Celsius** and **Fahrenheit**
    in the **Serial Monitor** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `Wire.requestFrom(partAddress,2)` function
    requests two bytes from the slave TMP102\. The slave sends data bytes to the master,
    which get captured by the `Wire.read()` function and are stored as two different
    bits: **most significant bit** (**MSB**) and **least significant bit** (**LSB**).
    These bytes are converted into an integer value, which is then converted into
    the actual Celsius reading by multiplying the incremental fraction of the TMP102
    sensor that is obtained from the datasheet. TMP102 is one of the easiest I2C sensors
    to interface with Arduino as the sensor values can be obtained via a simple I2C
    request method.'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino coding for the BH1750 light sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BH1750 is a digital light sensor that measures the amount of visible light
    in a given area. Although various DIY projects utilize simple photocells as a
    cheap alternative, the BH1750 sensor is known for higher resolution and accuracy
    in a wide range of applications. The ambient light, also called luminous flux
    or lux, is measured in unit lumen. The BH1750 sensor supports I2C communication
    with part address `0x23`, with `0x5C` as the secondary address if you are using
    multiple BH1750 sensors. The following is an image of a typical breakout board
    consisting of BH1750:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino coding for the BH1750 light sensor](img/5938OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the SDA and SCL pins of the BH1750 breakout board to analog pins 4
    and 5 of the Arduino Uno board, as displayed in the following circuit diagram.
    Also, complete the +5V and ground connections as displayed in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino coding for the BH1750 light sensor](img/5938OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous example, we used functions from the `Wire` library to complete
    the I2C communication. Although `BH1750` is a simple and convenient I2C sensor,
    in the case of a sensor with multiple measurement capabilities, it is not convenient
    to code directly using the `Wire` library. In this situation, you can use sensor-specific
    Arduino libraries that are developed by the manufacturer or the open source community.
    For `BH1750`, we will demonstrate the use of such a library to assist the I2C
    coding. Before we can use this library, we will have to import it to the Arduino
    IDE. It is really important to know the process of importing libraries to your
    Arduino IDE as you will be repeating this process to install other libraries in
    future. Execute the following steps to import the `BH1750` library to your Arduino
    IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and extract [Chapter 7](ch07.html "Chapter 7. The Midterm Project –
    a Portable DIY Thermostat"), *The Midterm Project – a Portable DIY Thermostat*,
    code examples in a folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Arduino IDE and navigate to **Sketch** | **Import Library…** | **Add
    Library…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are asked for a directory, go to the `BH1750` folder in the downloaded
    file and click on **Select**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check if your library is installed, navigate to **Sketch** | **Import Library…**
    and look for **BH1750** in the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, restart the Arduino IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an Arduino IDE with version 1.0.4 or an older version, you
    might not be able to find the **Import Library…** option from the menu. In this
    case, you need to follow the tutorial at [http://arduino.cc/en/Guide/Libraries](http://arduino.cc/en/Guide/Libraries).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `BH1750` library has a method to directly obtain ambient light values. Let's
    test this library using a built-in code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'After restarting your Arduino IDE, navigate to **File** | **Examples** | **BH1750**
    and open the **BH1750test** Arduino sketch. This should open the following code
    snippet in the Arduino IDE. Set up an appropriate serial port and upload the code
    to your Arduino board. Once the code is executed, you will be able to check the
    luminous flux (`lux`) values using the serial monitor of the Arduino IDE. Make
    sure that the serial monitor is configured to 9600 baud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, we have imported the `BH1750`
    library by including `BH1750.h` file with `Wire.h`. This library provides the
    `readLightLevel()` function, which will fetch the ambient light value from the
    sensor and provide it as an integer. As the Arduino code runs in a loop with a
    delay of 1000 milliseconds, the `lux` values will be fetched from the sensor and
    sent to the serial port every second. You can observe these values in the **Serial
    Monitor** window.
  prefs: []
  type: TYPE_NORMAL
- en: PyMata for quick I2C prototyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been using `pyFirmata` as our default Python library to interface the
    Firmata protocol. The `pyFirmata` library is a very useful Python library to get
    started with the Firmata protocol, as it provides many simple and effective methods
    to define the Firmata ports and their roles. Due to these reasons, we extensively
    used `pyFirmata` for rapid prototyping in the previous section. Although `pyFirmata`
    supports analog, digital, PWM, and SERVO modes with easy-to-use methods, it provides
    limited support to the I2C protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to use a different Python Firmata library called
    `PyMata` to get familiar with Python-based prototyping of I2C sensors. The `PyMata`
    library supports regular Firmata methods and also provides full support for the
    I2C messaging protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyMata` can be easily installed using Setuptools, which we used in the previous
    chapters to install other Python libraries. We are assuming that you already have
    Setuptools and `pip` on your computer. Let''s start performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `PyMata` on a Windows computer, execute the following command in
    the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Linux or Mac OS X, use the following command in the terminal
    to install the `PyMata` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything is set up properly, this process will complete without any error.
    You can confirm `PyMata` by opening Python''s interactive prompt and importing
    `PyMata`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the execution of the preceding command fails, you need to check the installation
    process for any error. Resolve the error and repeat the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interfacing TMP102 using PyMata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to utilize `PyMata` functionalities, you will need your Arduino board
    to be equipped with the standard firmata firmware just like the `pyFirmata` library.
    Before we proceed to explain the `PyMata` functions, let''s first run the following
    code snippet. Connect your TMP102 temperature sensor as explained in the previous
    section. Using the Arduino IDE, navigate to **File** | **Examples** | **Firmata**
    and upload the standard Firmata sketch from there to your Arduino board. Now,
    create a Python executable file using the following code snippet. Change the value
    of port (`COM5`), if needed, to an appropriate port name as required by your operating
    system. Finally, run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: On the execution of the preceding code snippet, you will be able to see the
    temperature reading in Fahrenheit and Celsius. As you can see from the inline
    comments in the code, the first step to utilize Arduino using `PyMata` is to initialize
    the port using the `PyMata` constructor. `PyMata` supports the configuration of
    I2C pins via the `i2c_config()` function. `PyMata` also supports simultaneous
    reading and writing operations via the `i2c_read()` and `i2c_write()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing BH1750 using PyMata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case of BH1750, the previous `PyMata` code snippet can be utilized with
    minor modifications to obtain ambient light sensor data. As the first change,
    you want to replace the part address of TMP102 (`0x48`) with the one of BH1750
    (`0x23`) in the following code snippet. You will also have to convert the raw
    values received from the sensor into the `lux` value using the given formula.
    After these modifications, run the following program from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: On running the preceding code snippet, you will be able to see the ambient light
    sensor reading in `lux` at the terminal. This process can be used in a large number
    of I2C devices to read the registered information. In complex I2C devices, you
    will have to follow their datasheet or examples to organize the read and write
    commands of the I2C.
  prefs: []
  type: TYPE_NORMAL
- en: Useful pySerial commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard Firmata protocol and Python''s Firmata libraries are very useful
    for testing or quick prototyping of the I2C sensors. Although they have many advantages,
    Firmata-based projects face the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delay in real-time execution**: Firmata-based approaches require a series
    of serial communication messages to receive and send data, which adds additional
    delay and reduces the speed of execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unwanted space**: The Firmata protocol contains a large amount of additional
    code to support various other Arduino functions. In a well-defined project, you
    don''t really need the complete set of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited support**: Although a version of Firmata includes I2C support, it
    is quite difficult to implement complex I2C functions without adding delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, you can always use Firmata-based approaches to quickly prototype
    your projects, but when you are working on production-level or advanced projects,
    you can use alternative methods. In these scenarios, you can use custom Arduino
    code that is supported by Python's serial library, `pySerial`, to enable communication
    for very specific functionalities. In this section, we are going to cover a few
    helpful `pySerial` methods that you can use if you have to utilize the library
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with the serial port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have connected your Arduino to a USB port of your computer, you can
    open the port in your Python code using the `Serial` class as displayed in the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In addition to port name and baud rate, you can also specify a number of serial
    port parameters such as `timeout`, `bytesize`, `parity`, `stopbits`, and so on
    using `Serial()`. It is necessary to initialize the serial port before executing
    any other command from the `pySerial` library.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a line from the port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the serial port is opened, you can start reading the port using `readline()`.
    The `readline()` function requires the timeout to be specified while initializing
    the port, otherwise the code can terminate with an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `readline()` function will process each line from the port that is terminated
    with the end line character `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: Flushing the port to avoid buffer overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While working with `pySerial`, it is necessary to flush the input buffer to
    avoid buffer overflow and maintain real-time operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If the port's baud rate is high and the processing of the input data is slow,
    buffer overflow may occur, reducing the speed of execution and making the experience
    sluggish.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is a good coding practice to close the serial port once the process is complete.
    This practice can eliminate the port-blocking problem once the Python code is
    terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned important methods that are required to successfully
    interface the Arduino board with Python. You were also introduced to various prototyping
    code templates with practical applications. These prototyping templates helped
    us to learn new Python programing paradigms and Firmata methods. Later in the
    chapter, we dived further into prototyping by learning more about the different
    ways of establishing communication between sensors and the Arduino board. Although
    we covered a vast amount of programming concepts with these prototyping examples,
    the goal of the chapter was to make you familiar with the interfacing problems
    and provide quick recipes for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We are assuming that by now you are comfortable testing your sensors or project
    prototypes using Python and Arduino. It's time to start working towards creating
    your applications that have complex Python features such as user controls, charts,
    and plots. In the next chapter, we are going to develop custom graphical user
    interfaces (GUIs) for your Python-Arduino projects.
  prefs: []
  type: TYPE_NORMAL
