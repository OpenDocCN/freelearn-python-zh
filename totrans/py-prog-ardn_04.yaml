- en: Chapter 4. Diving into Python-Arduino Prototyping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：深入Python-Arduino原型设计
- en: 'On the completion of the first project, you successfully started Python-Arduino
    interfacing. We also interfaced multiple hardware components, that is, motion
    sensor and LEDs with Arduino via digital pins. During the project, you learned
    more about the Firmata protocol while utilizing simple Python methods that helped
    you to establish a connection between your Arduino board and the Python program.
    When you are working on complex projects, you need more than basic methods to
    implement the different features that are required by the projects and their associated
    electronics components. This chapter is designed to give you a comprehensive experience
    of interfacing so that you can start working on hard problems from the next chapter
    onwards. We have described various interfacing protocols at the Python-Arduino
    and Arduino-to-components levels. This chapter also includes practical examples
    for these protocols with appropriate code and circuit diagrams. In this chapter,
    we are going to cover the following main topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成第一个项目后，你成功开始了Python-Arduino接口。我们还通过数字引脚将多个硬件组件（即运动传感器和LED）与Arduino接口。在项目过程中，你通过使用简单的Python方法学习了更多关于Firmata协议的知识，这些方法帮助你建立Arduino板与Python程序之间的连接。当你处理复杂项目时，你需要比基本方法更多的东西来实现项目及其相关电子组件所需的不同功能。本章旨在为你提供全面的接口体验，以便你从下一章开始着手解决难题。我们描述了Python-Arduino和Arduino到组件级别的各种接口协议。本章还包括了这些协议的实践示例，包括适当的代码和电路图。在本章中，我们将涵盖以下主要主题：
- en: Introduction to Prototyping
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型设计简介
- en: Detailed description of various `pyFirmata` methods to port Arduino functionalities
    into Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细描述将Arduino功能导入Python的`pyFirmata`方法的介绍
- en: Python-Arduino interfacing examples using Firmata for basic electronic components
    such as the potentiometer, the buzzer, the DC motor, and the servomotor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Firmata进行Python-Arduino接口的示例，包括电位计、蜂鸣器、直流电机和伺服电机等基本电子元件
- en: Introduction to the **inter-integrated circuit** (**I2C**) protocol and prototyping
    examples for the I2C components such as the temperature sensor (TMP102) and the
    light sensor (BH1750)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互连集成电路**（**I2C**）协议简介及I2C组件（如温度传感器（TMP102）和光传感器（BH1750））的原型设计示例'
- en: Prototyping
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计
- en: Just for a moment, let's step back and look at the project that we built in
    the previous chapter. The project had a very simple goal and we were able to develop
    it quite comfortably. However, the project is certainly not ready to be a consumer
    product since it doesn't have significant functionalities and most importantly,
    it is not a robust product that can be repeatedly produced as it is. What you
    can tell about your current project is that it is a DIY project for personal use
    or just a model that can be developed further to be a great product.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就让我们暂时回顾一下上一章中我们构建的项目。这个项目目标非常简单，我们能够相当轻松地完成它。然而，这个项目显然还没有准备好成为一款消费产品，因为它缺乏显著的功能，最重要的是，它不是一个可以重复生产的稳健产品。关于你当前的项目，你可以知道的是，它是一个个人使用的DIY项目，或者只是一个可以进一步开发成为优秀产品的模型。
- en: Now, if you are looking to develop a commercial product or just a DIY project
    that is really robust and scalable, you must consider starting it by making a
    model first. At this stage, you need to envision the product with the required
    features that need to be developed and the number of components that are required
    to deploy these features. Prototyping is basically a rapid way to create a working
    model of your envisioned idea before developing it into a fully functional project
    or product. The proof of concept prototype that is developed during this prototyping
    process lets you to identify the feasibility of your idea, and in some cases,
    it helps you to explore the potential of your project. The prototyping or functional
    model-making process is essential for any industry and not just for electronics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你打算开发一款商业产品或者一个真正稳健且可扩展的DIY项目，你必须考虑首先制作一个模型。在这个阶段，你需要设想产品所需的功能以及部署这些功能所需的组件数量。原型设计基本上是一种快速创建你设想中的想法的工作模型的方法，在将其开发成完整功能的项目或产品之前。在原型设计过程中开发的证明概念原型让你能够确定你想法的可行性，在某些情况下，它还帮助你探索项目的潜力。原型设计或功能模型制作过程对于任何行业都是至关重要的，而不仅仅是电子行业。
- en: In the electronics domain, prototyping can be used at the very first stage of
    interfacing components to a computer, instead of directly spending a significant
    amount of resources for the schematic design, PCB manufacturing, and developing
    the complete code base. This stage helps you to identify major flaws in your circuit
    design and check the mutual compatibility of the selected components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子领域，原型设计可以在将组件与计算机接口的第一个阶段使用，而不是直接投入大量资源进行原理图设计、PCB 制造和开发完整的代码库。这一阶段有助于你识别电路设计中的主要缺陷，并检查所选组件的相互兼容性。
- en: Fortunately, Arduino and the existing software support around Arduino have really
    simplified electronics' prototyping. In the upcoming sections, we will go through
    various helper functions and interfacing exercises to help you proceed with your
    own projects. These examples or templates are designed in such a fashion that
    they can be used as a blueprint for larger projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Arduino 及其周围的现有软件支持极大地简化了电子原型设计。在接下来的章节中，我们将介绍各种辅助函数和接口练习，以帮助你进行自己的项目。这些示例或模板设计得如此之好，以至于它们可以用作更大项目的蓝图。
- en: 'Before diving into these prototyping examples, let''s understand two different
    abstractions of interfacing that we are going to explore in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究这些原型设计示例之前，让我们了解我们将在本章中探索的两个不同的接口抽象：
- en: '**Interfacing Arduino with Python**: We have learned the easiest method of
    Python-Arduino interfacing using the Firmata protocol. On the Arduino board, the
    Firmata protocol is implemented using the **StandardFirmata** firmware, while
    on the Python end, we used the Firmata libraries, `pyFirmata` or `pyMata`, for
    Python. Another Python-Arduino interfacing method includes the use of simple but
    nonstandard serial commands using the custom Arduino sketch and the `pySerial`
    library in the Python program. It is also possible to use a computer network to
    establish communication between Python and Arduino, which is covered later in
    the book.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 Arduino 与 Python 接口**：我们已经学习了使用 Firmata 协议进行 Python-Arduino 接口的最简单方法。在
    Arduino 板上，Firmata 协议是通过 **StandardFirmata** 固件实现的，而在 Python 端，我们使用了 Firmata 库，即
    `pyFirmata` 或 `pyMata`。另一种 Python-Arduino 接口方法包括在 Python 程序中使用自定义 Arduino 脚本和
    `pySerial` 库的简单但非标准的串行命令。使用计算机网络在 Python 和 Arduino 之间建立通信也是可能的，这在本书的后续部分将进行介绍。'
- en: '**Interfacing electronic components with Arduino**: The second interfacing
    abstraction is associated with Arduino and the physical components. As we already
    did, various electronics components can be simply interfaced with the Arduino
    board using digital or analog pins. These components deal with either digital
    or analog signals. A few digital pins on the Arduino board support PWM communication
    for specific hardware devices. The other alternative interfacing methods include
    I2C and **serial peripheral interface** (**SPI**) communication. The I2C method
    is comprehensively explained in the final section of this chapter.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将电子组件与 Arduino 接口**：第二个接口抽象与 Arduino 和物理组件相关。正如我们已经做的那样，各种电子组件可以通过数字或模拟引脚简单地与
    Arduino 板接口。这些组件处理数字或模拟信号。Arduino 板上的一些数字引脚支持特定硬件设备的 PWM 通信。其他替代接口方法包括 I2C 和 **串行外设接口**（**SPI**）通信。I2C
    方法在本章的最后部分进行了全面解释。'
- en: Working with pyFirmata methods
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pyFirmata 方法
- en: The `pyFirmata` package provides useful methods to bridge the gap between Python
    and Arduino's Firmata protocol. Although these methods are described with specific
    examples, you can use them in various different ways. This section also provides
    a detailed description of a few additional methods that were not used in the previous
    project and lists the missing features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyFirmata` 包提供了有用的方法来弥合 Python 和 Arduino 的 Firmata 协议之间的差距。尽管这些方法是用具体的例子描述的，但你也可以以各种不同的方式使用它们。本节还详细描述了一些在先前项目中未使用的方法，并列出了缺失的功能。'
- en: Setting up the Arduino board
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Arduino 板
- en: 'To set up your Arduino board in a Python program using `pyFirmata`, you need
    to specifically follow the steps that we have covered. We have distributed the
    entire code that is required for the setup process into small code snippets in
    each step. While writing your code, you will have to carefully use the code snippets
    that are appropriate for your application. You can always refer to the example
    Python files containing the complete code. Before we go ahead, let''s first make
    sure that your Arduino board is equipped with the latest version of the **StandardFirmata**
    program and is connected to your computer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python程序中使用`pyFirmata`设置你的Arduino板，你需要特别遵循我们已覆盖的步骤。我们将整个设置过程所需的代码分散到每个步骤中的小代码片段中。在编写代码时，你必须仔细使用适合你应用场景的代码片段。你总是可以参考包含完整代码的示例Python文件。在我们继续之前，首先确保你的Arduino板安装了最新版本的**StandardFirmata**程序，并且已经连接到你的电脑：
- en: 'Depending upon the Arduino board that is being utilized, start by importing
    the appropriate `pyFirmata` classes to the Python code. Currently, the inbuilt
    `pyFirmata` classes only support the Arduino Uno and Arduino Mega boards:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据所使用的Arduino板，首先将适当的`pyFirmata`类导入到Python代码中。目前，内置的`pyFirmata`类仅支持Arduino Uno和Arduino
    Mega板：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the case of Arduino Mega, use the following line of code:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Arduino Mega的情况下，使用以下代码行：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we start executing any methods that are associated with handling pins,
    you need to properly set up the Arduino board. To perform this task, we have to
    first identify the USB port to which the Arduino board is connected and assign
    this location to a variable in the form of a string object. For Mac OS X, the
    port string should approximately look like this:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始执行与处理引脚相关的任何方法之前，你需要正确设置Arduino板。要执行此任务，我们首先需要识别Arduino板连接的USB端口，并将此位置以字符串对象的形式分配给一个变量。对于Mac
    OS X，端口字符串应大致如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Windows, use the following string structure:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Windows系统，使用以下字符串结构：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the case of the Linux operating system, use the following line of code:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux操作系统的案例中，使用以下代码行：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The port's location might be different according to your computer configuration.
    You can identify the correct location of your Arduino USB port by using the Arduino
    IDE, as described in [Chapter 2](ch02.html "Chapter 2. Working with the Firmata
    Protocol and the pySerial Library"), *Working with the Firmata Protocol and the
    pySerial Library*.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 端口的位置可能会根据你的电脑配置而有所不同。你可以通过Arduino IDE，如[第2章](ch02.html "第2章. 使用Firmata协议和pySerial库")中所述，使用以下方法来识别你的Arduino
    USB端口的正确位置：*使用Firmata协议和pySerial库*。
- en: 'Once you have imported the Arduino class and assigned the port to a variable
    object, it''s time to engage Arduino with `pyFirmata` and associate this relationship
    to another variable:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你导入了Arduino类并将端口分配给一个变量对象，就是时候将Arduino与`pyFirmata`结合并关联到另一个变量上了：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, for Arduino Mega, use this:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，对于Arduino Mega，使用这个：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The synchronization between the Arduino board and `pyFirmata` requires some
    time. Adding sleep time between the preceding assignment and the next set of instructions
    can help to avoid any issues that are related to serial port buffering. The easiest
    way to add sleep time is to use the inbuilt Python method, `sleep(time)`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Arduino板与`pyFirmata`之间的同步需要一些时间。在先前的赋值和下一组指令之间添加睡眠时间可以帮助避免与串行端口缓冲相关的问题。添加睡眠时间最简单的方法是使用内置的Python方法`sleep(time)`：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `sleep()` method takes seconds as the parameter and a floating-point number
    can be used to provide the specific sleep time. For example, for 200 milliseconds,
    it will be `sleep(0.2)`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sleep()`方法接受秒作为参数，可以使用浮点数来提供特定的睡眠时间。例如，对于200毫秒，将是`sleep(0.2)`。'
- en: At this point, you have successfully synchronized your Arduino Uno or Arduino
    Mega board to the computer using `pyFirmata`. What if you want to use a different
    variant (other than Arduino Uno or ArduinoMega) of the Arduino board?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功使用`pyFirmata`将Arduino Uno或Arduino Mega板同步到电脑上。如果你想使用Arduino板的其它变体（除了Arduino
    Uno或Arduino Mega）怎么办？
- en: 'Any board layout in `pyFirmata` is defined as a dictionary object. The following
    is a sample of the dictionary object for the Arduino board:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`pyFirmata`中，任何板布局都被定义为字典对象。以下是一个Arduino板字典对象的示例：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For your variant of the Arduino board, you have to first create a custom dictionary
    object. To create this object, you need to know the hardware layout of your board.
    For example, an Arduino Nano board has a layout similar to a regular Arduino board,
    but it has eight instead of six analog ports. Therefore, the preceding dictionary
    object can be customized as follows:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您的Arduino板变体，您必须首先创建一个自定义字典对象。要创建此对象，您需要了解您的板硬件布局。例如，Arduino Nano板的布局类似于常规Arduino板，但它有八个而不是六个模拟端口。因此，前面的字典对象可以定制如下：
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you have already synchronized the Arduino board earlier, modify the layout
    of the board using the `setup_layout(layout)` method:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您之前已经同步了Arduino板，请使用`setup_layout(layout)`方法修改板的布局：
- en: '[PRE10]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will modify the default layout of the synchronized Arduino board
    to the Arduino Nano layout or any other variant for which you have customized
    the dictionary object.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将修改同步的Arduino板的默认布局为Arduino Nano布局或任何其他您已定制的字典对象变体。
- en: Configuring Arduino pins
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Arduino引脚
- en: Once your Arduino board is synchronized, it is time to configure the digital
    and analog pins that are going to be used as part of your program. Arduino board
    has digital I/O pins and analog input pins that can be utilized to perform various
    operations. As we already know, some of these digital pins are also capable of
    PWM.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的Arduino板同步完成，就是时候配置将要作为程序一部分使用的数字和模拟引脚了。Arduino板具有数字I/O引脚和模拟输入引脚，可以用于执行各种操作。正如我们所知，其中一些数字引脚也具备PWM功能。
- en: The direct method
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接方法
- en: 'Now before we start writing or reading any data to these pins, we have to first
    assign modes to these pins. In the Arduino sketch-based approach that we used
    in the previous chapter, we used the `pinMode` function, that is, `pinMode(11,
    INPUT)` for this operation. Similarly, in `pyFirmata`, this assignment operation
    is performed using the `mode` method on the board object as shown in the following
    code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向这些引脚写入或读取任何数据之前，我们必须首先将这些引脚的模式分配好。在上一章中我们使用的基于Arduino草图的方法中，我们使用了`pinMode`函数，即`pinMode(11,
    INPUT)`进行此操作。同样，在`pyFirmata`中，此分配操作是通过在板对象上使用`mode`方法来执行的，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `pyFirmata` library includes classes for the `INPUT` and `OUTPUT` modes,
    which are required to be imported before you utilized them. The preceding example
    shows the delegation of digital pin 13 as an output and the analog pin 0 as an
    input. The mode method is performed on the variable assigned to the configured
    Arduino board using the `digital[]` and `analog[]` array index assignment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyFirmata`库包括用于`INPUT`和`OUTPUT`模式的类，在使用之前需要导入。前面的示例展示了将数字引脚13委托为输出，将模拟引脚0委托为输入。模式方法是在使用`digital[]`和`analog[]`数组索引分配配置的Arduino板变量上执行的。'
- en: 'The `pyFirmata` library also supports additional modes such as `PWM` and `SERVO`.
    The `PWM` mode is used to get analog results from digital pins, while the `SERVO`
    mode helps a digital pin to set the angle of the shaft between 0 to 180 degrees.
    The `PWM` and `SERVO` modes are explained with detailed examples later in this
    chapter. If you are using any of these modes, import their appropriate classes
    from the `pyFirmata` library. Once these classes are imported from the `pyFirmata`
    package, the modes for the appropriate pins can be assigned using the following
    lines of code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyFirmata`库还支持`PWM`和`SERVO`等附加模式。`PWM`模式用于从数字引脚获取模拟结果，而`SERVO`模式帮助数字引脚设置轴的角度在0到180度之间。`PWM`和`SERVO`模式将在本章后面的详细示例中解释。如果您使用这些模式中的任何一个，请从`pyFirmata`库导入相应的类。一旦从`pyFirmata`包中导入了这些类，就可以使用以下代码行为适当的引脚分配模式：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In electronics, PWM is a signal modulation technique that is greatly used to
    provide controlled amount of power to components. While dealing with digital signals,
    the PWM technique is used to obtain analog results by utilizing square waves and
    controlling the width of the signal.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子学中，PWM是一种信号调制技术，广泛用于向组件提供受控的功率。在处理数字信号时，PWM技术通过利用方波和控制信号宽度来获得模拟结果。
- en: 'As we already know, the digital pins of the Arduino board can only have two
    states, 5V (HIGH) and 0V (LOW). One can generate square pulses by controlling
    the switching pattern between HIGH and LOW and thus generate the pulse. By changing
    the width of these pulses, you can simulate any voltage between 0V and 5V. As
    you can see in the following diagram, we have a square wave with 25 percent width
    of the duty cycle. It means that we are simulating 0.25 * 5V = 1.25V for the period
    of that duty cycle:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Arduino板的数字引脚只能有两种状态，5V（高）和0V（低）。通过控制高和低之间的切换模式，可以生成方波脉冲，从而产生脉冲。通过改变这些脉冲的宽度，可以模拟0V到5V之间的任何电压。如图所示，我们有一个占空比为25%的方波。这意味着在占空期的这段时间内，我们正在模拟0.25
    * 5V = 1.25V：
- en: '![The direct method](img/5938OS_04_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![直接方法](img/5938OS_04_06.jpg)'
- en: The Arduino language supports PWM using the `analogWrite()` function, where
    the voltage range between 0V and 5V is linearly scaled for values between 0 and
    255\. For example, 50 percent duty cycle (simulation of 2.5V) translates to a
    value of 127, which can be coded in Arduino as `analogWrite(13,127)`. Here, the
    number `13` represents the digital pin that supports PWM on the Arduino Uno board.
    Similarly, a 20 percent duty cycle (1V) translates to `analogWrite(13,64)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino语言使用`analogWrite()`函数支持PWM，其中0V到5V之间的电压范围以0到255之间的线性比例缩放。例如，50%的占空比（模拟2.5V）转换为值127，可以在Arduino中编码为`analogWrite(13,127)`。在这里，数字`13`代表支持PWM的Arduino
    Uno板上的数字引脚。同样，20%的占空比（1V）转换为`analogWrite(13,64)`。
- en: Assigning pin modes
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配引脚模式
- en: 'The direct method of configuring pins is mostly used for a single line of execution
    calls. In a project containing a large code and complex logic, it is convenient
    to assign a pin with its role to a variable object. With an assignment like this,
    you can later utilize the assigned variable throughout the program for various
    actions, instead of calling the direct method every time you need to use that
    pin. In `pyFirmata`, this assignment can be performed using the `get_pin(pin_def)`
    method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 配置引脚的直接方法主要用于单行执行调用。在一个包含大量代码和复杂逻辑的项目中，将具有特定功能的引脚分配给变量对象是非常方便的。使用这样的赋值，你可以在程序中利用分配的变量执行各种操作，而不是每次需要使用该引脚时都调用直接方法。在`pyFirmata`中，可以使用`get_pin(pin_def)`方法执行此赋值：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `get_pin()` method lets you assign pin modes using the `pin_def` string
    parameter, `'d:13:o'`. The three components of `pin_def` are pin type, pin number,
    and pin mode separated by a colon (`:`) operator. The pin types (analog and digital)
    are denoted with `a` and `d` respectively. The `get_pin()` method supports three
    modes, `i` for input, `o` for output, and `p` for PWM. In the previous code sample,
    `'d:13:o'` specifies the digital pin 13 as an output. In another example, if you
    want to set up the analog pin 1 as an input, the parameter string will be `'a:1:i'`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_pin()`方法允许你使用`pin_def`字符串参数（`''d:13:o''`）分配引脚模式。`pin_def`的三个组成部分是引脚类型、引脚号和引脚模式，由冒号（`:`）运算符分隔。引脚类型（模拟和数字）分别用`a`和`d`表示。`get_pin()`方法支持三种模式，`i`表示输入，`o`表示输出，`p`表示PWM。在之前的代码示例中，`''d:13:o''`指定数字引脚13为输出。在另一个示例中，如果你想将模拟引脚1设置为输入，参数字符串将是`''a:1:i''`。'
- en: Working with pins
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作引脚
- en: 'Now you have configured your Arduino pins, it''s time to start performing actions
    using them. Two different types of methods are supported while working with pins:
    reporting methods and I/O operation methods.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了Arduino引脚，是时候开始使用它们执行操作了。在操作引脚时，支持两种不同类型的方法：报告方法和I/O操作方法。
- en: Reporting data
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 报告数据
- en: When pins get configured in a program as analog input pins, they start sending
    input values to the serial port. If the program does not utilize this incoming
    data, the data starts getting buffered at the serial port and quickly overflows.
    The `pyFirmata` library provides the reporting and iterator methods to deal with
    this phenomenon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当引脚在程序中配置为模拟输入引脚时，它们开始向串行端口发送输入值。如果程序不利用这些传入的数据，数据将开始在串行端口缓冲，并迅速溢出。`pyFirmata`库提供了报告和迭代方法来处理这种现象。
- en: 'The `enable_reporting()` method is used to set the input pin to start reporting.
    This method needs to be utilized before performing a reading operation on the
    pin:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`enable_reporting()`方法将输入引脚设置为开始报告。在执行引脚的读取操作之前，需要使用此方法：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the reading operation is complete, the pin can be set to disable reporting:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 读取操作完成后，可以将引脚设置为禁用报告：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we assumed that you had already set up the Arduino
    board and configured the mode of the analog pin 3 as `INPUT`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们假设你已经设置了 Arduino 板并配置了模拟引脚 3 的模式为 `INPUT`。
- en: 'The `pyFirmata` library also provides the `Iterator()` class to read and handle
    data over the serial port. While working with analog pins, we recommend that you
    start an iterator thread in the main loop to update the pin value to the latest
    one. If the iterator method is not used, the buffered data might overflow your
    serial port. This class is defined in the `util` module of the `pyFirmata` package
    and needs to be imported before it is utilized in the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyFirmata` 库还提供了 `Iterator()` 类来读取和处理串行端口上的数据。当使用模拟引脚时，我们建议你在主循环中启动一个迭代器线程来更新引脚值为最新值。如果不使用迭代器方法，缓冲数据可能会溢出你的串行端口。这个类在
    `pyFirmata` 包的 `util` 模块中定义，并在代码中使用之前需要导入：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Manual operations
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动操作
- en: As we have configured the Arduino pins to suitable modes and their reporting
    characteristic, we can start monitoring them. The `pyFirmata` library provides
    the `write()` and `read()` methods for the configured pins.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经配置了Arduino引脚到合适的模式和它们的报告特性，我们可以开始监控它们。`pyFirmata` 库为配置的引脚提供了 `write()`
    和 `read()` 方法。
- en: The write() method
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: write() 方法
- en: 'The `write()` method is used to write a value to the pin. If the pin''s mode
    is set to `OUTPUT`, the value parameter is a Boolean, that is, `0` or `1`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()` 方法用于向引脚写入一个值。如果引脚的模式设置为 `OUTPUT`，则值参数是一个布尔值，即 `0` 或 `1`：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you have used an alternative method of assigning the pin''s mode, you can
    use the `write()` method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了替代的引脚模式赋值方法，你可以按照以下方式使用 `write()` 方法：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the case of the PWM signal, the Arduino accepts a value between 0 and 255
    that represents the length of the duty cycle between 0 and 100 percent. The `pyFirmata`
    library provides a simplified method to deal with the PWM values as instead of
    values between 0 and 255, you can just provide a float value between 0 and 1.0\.
    For example, if you want a 50 percent duty cycle (2.5V analog value), you can
    specify `0.5` with the `write()` method. The `pyFirmata` library will take care
    of the translation and send the appropriate value, that is, `127`, to the Arduino
    board via the Firmata protocol:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PWM 信号的情况下，Arduino 接受一个介于 0 和 255 之间的值，该值表示 0 到 100 百分比之间的占空期长度。`pyFirmata`
    库提供了一个简化的方法来处理 PWM 值，而不是介于 0 和 255 之间的值，你可以提供一个介于 0 和 1.0 之间的浮点值。例如，如果你想有一个 50
    百分比的占空期（2.5V 的模拟值），你可以使用 `write()` 方法指定 `0.5`。`pyFirmata` 库将负责转换并发送适当的值，即 `127`，通过
    Firmata 协议发送到 Arduino 板：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, for the indirect method of assignment, you can use some code similar
    to the following snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于间接赋值方法，你可以使用一些类似于以下代码片段的代码：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you are using the `SERVO` mode, you need to provide the value in degrees
    between 0 and 180\. Unfortunately, the `SERVO` mode is only applicable for direct
    assignment of the pins and will be available in future for indirect assignments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 `SERVO` 模式，你需要提供介于 0 和 180 度之间的值。不幸的是，`SERVO` 模式仅适用于直接赋值引脚，并且将来将适用于间接赋值：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The read() method
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: read() 方法
- en: 'The `read()` method provides an output value at the specified Arduino pin.
    When the `Iterator()` class is being used, the value received using this method
    is the latest updated value at the serial port. When you read a digital pin, you
    can get only one of the two inputs, `HIGH` or `LOW`, which will translate to `1`
    or `0` in Python:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 方法在指定的 Arduino 引脚上提供一个输出值。当使用 `Iterator()` 类时，使用此方法接收到的值是串行端口上最新更新的值。当你读取一个数字引脚时，你可以得到两个输入之一，`HIGH`
    或 `LOW`，这将在 Python 中转换为 `1` 或 `0`：'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The analog pins of Arduino linearly translate the input voltages between 0 and
    +5V to 0 and 1023\. However, in `pyFirmata`, the values between 0 and +5V are
    linearly translated into the float values of 0 and 1.0\. For example, if the voltage
    at the analog pin is 1V, an Arduino program will measure a value somewhere around
    204, but you will receive the float value as 0.2 while using pyFirmata's `read()`
    method in Python.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 的模拟引脚将 0 到 +5V 之间的输入电压线性转换为 0 到 1023。然而，在 `pyFirmata` 中，0 到 +5V 之间的值被线性转换为
    0 和 1.0 的浮点值。例如，如果模拟引脚上的电压为 1V，Arduino 程序将测量一个大约为 204 的值，但当你使用 Python 中的 pyFirmata
    的 `read()` 方法时，你会收到浮点值 0.2。
- en: Additional functions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他功能
- en: 'Besides the method that has already been described, the `pyFirmata` library
    also provides some utility functions for additional customization, which are as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经描述的方法之外，`pyFirmata`库还提供了一些用于额外定制的实用函数，具体如下：
- en: '`servo_config(pin,min_pulse=544,max_pulse=2400,angle=0)`: This method helps
    to set up the `SERVO` mode with further customization such as the minimum pulse
    value, maximum pulse value, and starting angle. One can set the initial angle
    of the servomotor using the `angle` parameter.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servo_config(pin,min_pulse=544,max_pulse=2400,angle=0)`：此方法有助于设置带有进一步定制的`SERVO`模式，例如最小脉冲值、最大脉冲值和起始角度。可以使用`angle`参数设置伺服电机的初始角度。'
- en: '`pass_time(seconds)`: This method provides a functionality similar to that
    found in the default Python''s default method `sleep()` that is provided by the
    `time` module. However, the `pass_time` function provides a non-blocking timeout
    in seconds.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pass_time(seconds)`：此方法提供与默认Python的`time`模块提供的默认方法`sleep()`类似的功能。然而，`pass_time`函数提供了非阻塞的超时（以秒为单位）。'
- en: '`get_firmata_version()`: This function returns a tuple that contains the version
    of the Firmata protocol from the Arduino board:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_firmata_version()`：此函数返回一个元组，包含Arduino板上Firmata协议的版本：'
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`exit()`: We recommend that you disconnect the Arduino board from `pyFirmata`
    once you have completed running your code. This will free the serial port, which
    can be then utilized by other programs:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit()`：我们建议你在完成代码运行后从`pyFirmata`断开Arduino板。这将释放串行端口，然后可以被其他程序使用：'
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Upcoming functions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即将提供的函数
- en: 'The `pyFirmata` library is currently under development and it continuously
    receives updates to add and improve various methods. Although most of the native
    Arduino methods are available in the `pyFirmata` library via the Firmata protocol,
    there are few functions that are still missing or under development and they are
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyFirmata`库目前正在开发中，并持续接收更新以添加和改进各种方法。尽管大多数本地Arduino方法都通过Firmata协议在`pyFirmata`库中可用，但仍有一些函数尚未提供或正在开发中，具体如下：'
- en: '`pulseIn`/`pulseOut`: These native Arduino functions wait for the Arduino pin
    to achieve the specified value. The waiting period is returned in microseconds.
    This method is widely used by Ping (ultrasonic distance measurement) sensors.
    Implementation of this method using `pyFirmata` requires major changes to the
    standard Firmata protocol.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pulseIn`/`pulseOut`：这些是Arduino的本地函数，等待Arduino引脚达到指定的值。等待时间以微秒为单位返回。这种方法被Ping（超声波距离测量）传感器广泛使用。使用`pyFirmata`实现此方法需要对标准的Firmata协议进行重大更改。'
- en: '`shiftIn`/`shiftOut`: These functions shift a byte of data in or out, one bit
    at a time. The `pyFirmata` library lacks supports for these functions and can
    be implemented using the various Python programming tricks.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shiftIn`/`shiftOut`：这些函数逐位将数据字节移入或移出。`pyFirmata`库缺少对这些函数的支持，可以使用各种Python编程技巧实现。'
- en: Prototyping templates using Firmata
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firmata进行原型模板设计
- en: The goal of this section is to provide prototyping templates while also explaining
    various Python methods and programming techniques. It tries to cover some of the
    most popular sensors with coding examples that are used by DIY Arduino projects.
    This section is designed to utilize the Firmata protocol to implement these Python
    programs. It also includes various Python programming paradigms such as working
    with indefinite loops, creating custom functions, working with random numbers,
    acquiring manual inputs from prompt, and so on. These prototyping templates are
    designed in such a way that they can be easily included in large projects or they
    can be blueprints for a larger project that can be developed around them. You
    learned about the `pyFirmata` package comprehensively in the previous section
    and we will only utilize those `pyFirmata` functions in the upcoming examples.
    An alternative Python library that supports the Firmata protocol is covered later
    in the chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是提供原型模板，同时解释各种Python方法和编程技术。它试图涵盖一些最流行的传感器，并使用DIY Arduino项目中使用的编码示例。本节旨在利用Firmata协议实现这些Python程序。它还包括各种Python编程范式，如处理不定循环、创建自定义函数、处理随机数、从提示符获取手动输入等。这些原型模板设计得易于集成到大型项目中，或者可以作为围绕它们开发的大型项目的蓝图。在前一节中，你已经全面了解了`pyFirmata`包，我们将在接下来的示例中仅使用那些`pyFirmata`函数。本章后面将介绍支持Firmata协议的另一种Python库。
- en: Potentiometer – continuous observation from an analog input
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电位器 – 从模拟输入进行连续观察
- en: A potentiometer is a variable resistor that can be controlled using a knob.
    It has three terminals out of which two of them are Vref and ground, while the
    third one provides a variable output. The output of the potentiometer varies between
    the supplied voltages, according to the position of the knob. In Arduino, you
    can connect the potentiometer with +5V and the ground pins of the board to provide
    the supply voltage. When the variable terminal is interfaced with the Arduino
    analog input, this voltage values translates between 0 and 1023 respectively.
    In the case of `pyFirmata`, the value of the analog observation translates between
    0 and 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 电位器是一个可以通过旋钮控制的变阻器。它有三个端子，其中两个是Vref和地，而第三个提供可变输出。电位器的输出根据旋钮的位置在提供的电压之间变化。在Arduino中，您可以将电位器连接到+5V和板子的地引脚，以提供供电电压。当可变端子与Arduino模拟输入接口时，这些电压值分别转换为0到1023。在`pyFirmata`的情况下，模拟观察的值在0到1之间转换。
- en: This coding template containing the potentiometer can be applied to projects
    in which external manual control to a system is required. The potentiometer output
    that translates to the analog input of Arduino can be used to control an actuator
    such as a motor or an LED. In some cases, the input can also be used to control
    the flow of the program by applying its values to a variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包含电位器的编码模板可以应用于需要外部手动控制系统项目的项目中。电位器的输出可以转换为Arduino的模拟输入，用于控制执行器，如电机或LED。在某些情况下，输入也可以通过将其值应用于变量来控制程序的流程。
- en: Connections
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect the output of the potentiometer to analog pin A0 as shown in the following
    diagram. Complete the circuit by connecting Vref and the ground terminals of the
    potentiometers to +5V and the ground of the Arduino board respectively:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将电位器的输出连接到如图所示的模拟引脚A0。通过将电位器的Vref和地端子分别连接到+5V和Arduino板的地来完成电路：
- en: '![Connections](img/5938OS_04_01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![连接图](img/5938OS_04_01.jpg)'
- en: The Python code
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python代码
- en: 'Assuming that you already have the **StandardFirmata** firmware uploaded to
    the Arduino board, you are required to run a Python code on your computer to complete
    its interfacing with the potentiometer. A Python code template with the name `potentiometer.py`
    to help you get started with this example is located in the code bundle of this
    book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Let''s open this file to understand the program. As you can see, we are using
    the `pyFirmata` library with other Python modules such as `time` and `os`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经将**StandardFirmata**固件上传到Arduino板，您需要在计算机上运行Python代码来完成其与电位器的接口。本书代码包中提供了一个名为`potentiometer.py`的Python代码模板，可以帮助您开始这个示例，该模板可以从[https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961)下载。让我们打开这个文件来了解程序。如您所见，我们正在使用`pyFirmata`库以及其他Python模块，如`time`和`os`：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the second step of the program, we are initializing the Arduino board and
    starting the `Iterator()` function over it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第二步中，我们初始化Arduino板并开始在其上执行`Iterator()`函数：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the board has been initialized, we need to assign a role to the analog
    pin, `0`, as it is going to be used as an input pin. We are using the `get_pin()`
    method to assign a role to the analog pin, `0`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了板子，我们需要为模拟引脚`0`分配一个角色，因为它将被用作输入引脚。我们使用`get_pin()`方法为模拟引脚`0`分配角色：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, as part of the main program, we need to continuously monitor the output
    of the potentiometer at the pin, `a0`, that we just defined. We are using the
    `while` statement to create an indefinite loop for the script that will read and
    print the analog input. The problem with this indefinite `while` loop is that
    the program will not close properly when it is interrupted and it will not release
    the board by executing the `board.exit()` method. To avoid this, we will use another
    control statement from the Python programming paradigm, called `try/except`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为主程序的一部分，我们需要持续监控我们刚刚定义的引脚`a0`上的电位器输出。我们使用`while`语句创建一个不定循环，用于脚本读取和打印模拟输入。这个不定`while`循环的问题在于，当程序被中断时，程序将无法正确关闭，并且它不会通过执行`board.exit()`方法来释放板子。为了避免这种情况，我们将使用Python编程范式中的另一个控制语句，称为`try/except`：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using this statement, the program will keep running the `while` loop until the
    keyboard interruption occurs, which is *Ctrl* + *C*, and the program will execute
    the script under the `except` statement. This includes releasing the board using
    `board.exit()` and existing the program using the `os._exit()` method. In summary,
    the program will keep printing the output of the potentiometer until someone presses
    *Ctrl* + *C* to interrupt the program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此语句，程序将一直运行 `while` 循环，直到发生键盘中断，即 *Ctrl* + *C*，程序将执行 `except` 语句下的脚本。这包括使用
    `board.exit()` 释放板子，以及使用 `os._exit()` 方法退出程序。总之，程序将持续打印电位器的输出，直到有人按下 *Ctrl* +
    *C* 来中断程序。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `try/except` statement provides a very efficient way to capture exceptions
    in Python. It is advisable to utilize this statement throughout the development
    process to cleverly debug your programs. You can learn about Python errors and
    exceptions from the following links:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `try/except` 语句提供了一种非常高效的方式来捕获异常。建议在整个开发过程中使用此语句来巧妙地调试你的程序。你可以从以下链接中了解
    Python 错误和异常：
- en: '[https://docs.python.org/2/reference/compound_stmts.html#try](https://docs.python.org/2/reference/compound_stmts.html#try)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/reference/compound_stmts.html#try](https://docs.python.org/2/reference/compound_stmts.html#try)'
- en: '[https://docs.python.org/2/tutorial/errors.html](https://docs.python.org/2/tutorial/errors.html)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/tutorial/errors.html](https://docs.python.org/2/tutorial/errors.html)'
- en: Buzzer – generating sound alarm pattern
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蜂鸣器 – 生成声音警报模式
- en: Digital buzzer sensors are used in various applications that require alarm notifications.
    These sensors produce sound when they are supplied with a digital `HIGH` value
    (that is, +5V), which can be provided by using Arduino digital pins. Similar to
    the LED example in the previous chapter, they are very easy to interface with
    Arduino. However, rather than performing a simple digital output, we are implementing
    Python programming tricks to generate different sound patterns and produce various
    sound effects. The same code template can be also used to produce different LED
    blink patterns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数字蜂鸣器传感器被用于各种需要警报通知的应用。当它们接收到数字 `HIGH` 值（即 +5V）的供电时，这些传感器会发出声音，这可以通过使用 Arduino
    的数字引脚来实现。类似于前一章中的 LED 示例，它们与 Arduino 的接口非常简单。然而，我们不是执行简单的数字输出，而是实现 Python 编程技巧来生成不同的声音模式和产生各种声音效果。相同的代码模板也可以用来生成不同的
    LED 闪烁模式。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An analog digital buzzer can be found at [http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634](http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634](http://www.amazon.com/Arduino-Compatible-Speaker-arduino-sensors/dp/B0090X0634)
    可以找到模拟数字蜂鸣器。
- en: Connections
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: As displayed in the following circuit diagram, connect the VCC and the ground
    of the sensor board to 5V and the ground pin of the Arduino board respectively.
    Connect the signal pin of the sensor to the digital pin 2 via the 220-ohm resistor.
    You can use any digital pin to connect the buzzer. Just make sure that you update
    the Python code to reflect the pin that you have selected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下电路图所示，将传感器板的 VCC 和地连接到 5V 和 Arduino 板的地引脚。将传感器的信号引脚通过 220 欧姆电阻连接到数字引脚 2。你可以使用任何数字引脚来连接蜂鸣器。只需确保更新
    Python 代码以反映你选择的引脚。
- en: '![Connections](img/5938OS_04_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![连接图](img/5938OS_04_02.jpg)'
- en: The Python code
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 代码
- en: 'In the code example, two different sound patterns are generated using arrays
    of time delays. To perform these actions, we are going to implement a custom Python
    function that will take the pin number, the recurrence time, and the pattern number
    as input. Before we jump to explain the code, let''s open the program file, `buzzerPattern.py`,
    from the code folder. In the beginning of the code, you can find the Python function,
    `buzzerPattern()` that will be called from the main program with appropriate options.
    As this function is the core of the entire program, let''s try to understand it.
    The function contains two hardcoded pattern arrays, `pattern1` and `pattern2`.
    Each contains the on and off time for the buzzer for a second, which is the duty
    cycle of the pattern. For example, in `pattern1`, `0.8` represents the time the
    buzzer needs to be on and `0.2` represents the opposite. The function will repeat
    this buzzer pattern for `recurrence` times that is specified by the function argument.
    Once the `for` loop with the value of `recurrence` is started, the function will
    check for the pattern number from the function argument and execute the pattern.
    We are using the `flag` variable to alternatively use elements of the `pattern`
    array to control the buzzer. Once the entire recurrence loop is complete, we will
    turn off the buzzer completely again, if it is on, and safely disengage the board
    using the `exit()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，使用时间延迟数组生成了两种不同的声音模式。为了执行这些操作，我们将实现一个自定义的Python函数，该函数将接受引脚号、重复时间和模式号作为输入。在我们跳到解释代码之前，让我们打开代码文件夹中的程序文件，`buzzerPattern.py`。在代码的开头，你可以找到将被主程序以适当选项调用的Python函数`buzzerPattern()`。由于这个函数是整个程序的核心，让我们尝试理解它。该函数包含两个硬编码的模式数组，`pattern1`和`pattern2`。每个数组包含一个秒内蜂鸣器的开启和关闭时间，即模式的占空比。例如，在`pattern1`中，`0.8`代表蜂鸣器需要开启的时间，而`0.2`代表相反的情况。函数将重复指定的`recurrence`次该蜂鸣器模式。一旦启动了值为`recurrence`的`for`循环，函数将检查函数参数中的模式号并执行该模式。我们使用`flag`变量交替使用`pattern`数组中的元素来控制蜂鸣器。一旦整个重复循环完成，如果蜂鸣器是开启的，我们将完全关闭蜂鸣器，并使用`exit()`方法安全地断开板：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to change the time delays or implement a totally different pattern,
    you can play around with the `pattern` arrays.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改时间延迟或实现完全不同的模式，你可以对`pattern`数组进行操作。
- en: 'The remaining part of the program is relatively simple as it contains code
    for importing libraries and initializing the Arduino board. Once the board is
    initialized, we will execute the `buzzerPattern()` function with the input argument,
    `(2, 10, 1)`. This argument will ask the function to play `pattern1` 10 times
    on the pin number 2:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分相对简单，因为它包含导入库和初始化Arduino板的代码。一旦板被初始化，我们将使用输入参数`(2, 10, 1)`执行`buzzerPattern()`函数。这个参数将要求函数在引脚号2上播放`pattern1`
    10次：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: DC motor – controlling motor speed using PWM
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直流电机 – 使用PWM控制电机速度
- en: DC motors are widely used in robotics applications. They are available in a
    wide range of voltage specifications, depending upon the application. In this
    example, we are utilizing a 5V DC motor because we want to supply the power using
    the Arduino board itself. As the Arduino digital pin can only have two states,
    that is, `HIGH` (+5V) or `LOW` (0V), it is impossible to control the speed of
    the motor using just the `OUTPUT` mode. As a solution, we are going to implement
    the `PWM` mode via digital pins that are capable of supporting PWM. While using
    `pyFirmata`, pins configured with the `PWM` mode take any float input values between
    0 and 1.0, which represent 0V and 5V respectively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 直流电机在机器人应用中得到了广泛的应用。它们的电压规格范围很广，取决于应用。在这个例子中，我们使用5V直流电机，因为我们想使用Arduino板本身供电。由于Arduino数字引脚只能有两种状态，即`HIGH`（+5V）或`LOW`（0V），仅使用`OUTPUT`模式无法控制电机的速度。作为解决方案，我们将通过支持PWM的数字引脚实现`PWM`模式。在使用`pyFirmata`时，配置为`PWM`模式的引脚可以接受0到1.0之间的任何浮点输入值，分别代表0V和5V。
- en: Connections
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Depending upon the load, DC motors can sometimes draw large amounts of current
    and harm the Arduino board. To avoid any damage to the Arduino board due to any
    large accidental current draw, we will use a transistor as a switch, which only
    uses a small amount of current to control the large amount of current in the DC
    motor. To complete the circuit connection as displayed in the following diagram,
    you will need an NPN transistor (TIP120, N2222, or a similar one), one diode (1N4001
    or similar one) and a 220-ohm resistor with your DC motor. Connect the base of
    the transistor to the digital pin 3 that also supports the PWM mode. Connect the
    remaining components as displayed in the diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据负载，直流电机有时会消耗大量电流，并损害Arduino板。为了避免由于任何意外的大电流消耗而对Arduino板造成损害，我们将使用晶体管作为开关，它只使用少量电流来控制直流电机中的大量电流。为了完成以下图中显示的电路连接，您需要一个NPN晶体管（TIP120、N2222或类似型号），一个二极管（1N4001或类似型号）和一个220欧姆的电阻与您的直流电机连接。将晶体管的基极连接到也支持PWM模式的数字引脚3。将剩余的组件按照图中的显示连接起来：
- en: '![Connections](img/5938OS_04_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![连接图](img/5938OS_04_03.jpg)'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To find out more about transistor terminals (collector, emitter, and base)
    and to associate transistor pins with their respective terminals, you can refer
    to their datasheets or the following websites:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于晶体管端子（集电极、发射极和基极）的信息，以及将晶体管引脚与其相应的端子关联起来，您可以参考它们的规格书或以下网站：
- en: '[http://en.wikipedia.org/wiki/Transistor](http://en.wikipedia.org/wiki/Transistor)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Transistor](http://en.wikipedia.org/wiki/Transistor)'
- en: '[http://www.onsemi.com/pub/Collateral/TIP120-D.PDF](http://www.onsemi.com/pub/Collateral/TIP120-D.PDF)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.onsemi.com/pub/Collateral/TIP120-D.PDF](http://www.onsemi.com/pub/Collateral/TIP120-D.PDF)'
- en: '[http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf](http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf](http://www.mouser.com/ds/2/68/PN2221-2222A-11964.pdf)'
- en: The Python code
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python代码
- en: 'The Python recipe with the name `dcMotorPWM.py` for a DC motor is located in
    the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Open the Python file to further understand the usage of PWM to control the speed
    of the DC motor. The custom function, `dcMotorControl()`, takes motor speed and
    time duration as input parameters as described in the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用于直流电机的Python配方`dcMotorPWM.py`位于本书的代码包中，可以从[https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961)下载。打开Python文件，以进一步了解如何使用PWM控制直流电机的速度。自定义函数`dcMotorControl()`接受电机速度和时间持续时间作为输入参数，如以下代码片段所述：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just like the previous examples, we are using a similar code to import the
    necessary library and initialize the Arduino board. After initialization, we are
    assigning the mode of the digital pin 3 as `PWM`, which can be seen from the utilization
    of the `get_pin(''d:3:p'')` method. This code reflects the indirect mode of pin
    mode assignment that we learned in the previous section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的例子一样，我们使用类似的代码来导入必要的库并初始化Arduino板。初始化后，我们将数字引脚3的模式设置为`PWM`，这可以从`get_pin('d:3:p')`方法的利用中看出。这段代码反映了我们在上一节中学到的间接模式引脚模式分配方式：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As part of collecting manual inputs from the user, we are running a combination
    of the `try/except` statement (to release the board on exit) and the `while` statement
    (to obtain continuous inputs from the user). The code template introduces the
    `input()` method to obtain custom values (motor speed and duration to run the
    motor) from Python''s interactive terminal. Once these values are obtained from
    the user, the program calls the `dcMotorControl()` function to perform the motor
    action:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为从用户收集手动输入的一部分，我们正在运行一个组合的`try/except`语句（在退出时释放板）和`while`语句（从用户获取连续输入）。代码模板引入了`input()`方法，从Python的交互式终端获取自定义值（电机速度和运行电机的持续时间）。一旦从用户那里获取了这些值，程序就会调用`dcMotorControl()`函数来执行电机动作：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: LED – controlling LED brightness using PWM
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LED – 使用PWM控制LED亮度
- en: In the previous template, we controlled the speed of DC motor using PWM. One
    can also control the brightness of the LED using the same method. Instead of asking
    the user to input brightness, we are going to use the Python module `random` in
    this template. We will use this module to generate a random number between 1 and
    100, which will be later used to write that value on the pin and randomly change
    the brightness of the LED. This `randint()` function is a really useful feature
    provided by the `random` module and it is widely used in testing prototypes by
    rapidly sending random signals.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的模板中，我们使用 PWM 控制了直流电机的速度。也可以用同样的方法控制 LED 的亮度。在这个模板中，我们不会要求用户输入亮度，而是将使用 Python
    模块 `random`。我们将使用此模块生成一个介于 1 和 100 之间的随机数，然后将其写入引脚，并随机改变 LED 的亮度。这个 `randint()`
    函数是 `random` 模块提供的非常有用的功能，并且在通过快速发送随机信号测试原型时被广泛使用。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `randint()` function takes the `randint(startValue, endValue)` syntax and
    returns the random integer between the range established by `startValue` and `endValue`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`randint()` 函数采用 `randint(startValue, endValue)` 语法，并返回介于 `startValue` 和 `endValue`
    建立的范围内的随机整数。'
- en: Connections
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Like we used in the previous chapter''s project, we will need a pull-up resistor
    to connect the LED with the Arduino pin. As displayed in the following diagram,
    simply connect the anode of the LED (longer leg) to the digital pin 11 via one
    220-ohm resistor and connect the cathode (shorter leg) to the ground:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在上一章的项目中所用，我们需要一个上拉电阻将 LED 连接到 Arduino 引脚。如图所示，只需将 LED 的阳极（较长的一端）通过一个 220
    欧姆的电阻连接到数字引脚 11，并将阴极（较短的一端）连接到地：
- en: '![Connections](img/5938OS_04_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![连接图](img/5938OS_04_04.jpg)'
- en: It is important to note that the digital pin 11 on Arduino Uno is also capable
    of performing PWM along with digital pins 3, 5, 6, 9, and 10.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Arduino Uno 上的数字引脚 11 也能够与数字引脚 3、5、6、9 和 10 一起执行 PWM。
- en: The Python code
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 代码
- en: The Python code with the title `ledBrightnessPWM.py` for this exercise is located
    in the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    Open the file to explore the code. As you can see in this code template, a float
    value between 0 and 1.0 is randomly selected before passing it to the PWM pin.
    This method generates random LED brightness for a given amount of time. This practice
    can be used to generate random input samples for various other testing projects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的标题为 `ledBrightnessPWM.py` 的 Python 代码位于本书的代码包中，可以从 [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961)
    下载。打开文件以探索代码。正如您在这段代码模板中看到的，在将值传递到 PWM 引脚之前，会随机选择一个介于 0 和 1.0 之间的浮点数。这种方法可以在给定的时间内生成随机
    LED 亮度。这种做法可以用于生成各种其他测试项目的随机输入样本。
- en: As you can see, the first few lines of the code import the necessary libraries
    and initialize the board. Although the board variable, `/dev/cu.usbmodemfa1311`,
    is selected for Mac OS X, you can use your operating system's specific variable
    name in the following code snippet. You can obtain more information about choosing
    this variable name from the *Setting up the Arduino board* section at the beginning
    of this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码的前几行导入了必要的库并初始化了板。尽管板变量 `/dev/cu.usbmodemfa1311` 是为 Mac OS X 选择的，但您可以在以下代码片段中使用您操作系统的特定变量名。您可以从本章开头的
    *设置 Arduino 板* 部分获取有关选择此变量名的更多信息。
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this example, we are utilizing the direct method of pin mode assignment.
    As you can see in the following code snippet, the digital pin 11 is being assigned
    to the `PWM` mode:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用直接方法分配引脚模式。正如您在以下代码片段中看到的，数字引脚 11 被分配到 `PWM` 模式：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the pin mode is assigned, the program will run a loop using the `for`
    statement while randomly generating an integer number between 0 and 100, and then
    send the appropriate PWM value to the pin according to the generated number. With
    the execution of this, you will be able to see the LED randomly changing its brightness
    for approximately 10 seconds:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了引脚模式，程序将使用 `for` 语句运行一个循环，同时随机生成一个介于 0 和 100 之间的整数，然后根据生成的数字向引脚发送适当的 PWM
    值。执行此操作后，您将能够看到 LED 随机改变亮度，大约持续 10 秒：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you are done with the loop, you need to safely disengage the Arduino board
    after turning off the LED one last time. It is a good practice to turn off the
    LED or any connected sensor at the end of the program before exiting the board,
    to prevent any sensor from running accidentally:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成循环后，你需要关闭LED最后一次，然后安全地断开Arduino板。在退出板子之前关闭LED或任何连接的传感器是一个好习惯，以防止任何传感器意外运行：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to homogenously glow the LED instead of randomly changing its brightness,
    replace the code in the `for` loop with the following code snippet. Here, we are
    changing the PWM input to the incrementing variable, `i`, instead of the random
    variable, `r`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要均匀地使LED发光而不是随机改变其亮度，将`for`循环中的代码替换为以下代码片段。在这里，我们将PWM输入更改为递增变量`i`，而不是随机变量`r`：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Servomotor – moving the motor to a certain angle
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伺服电机 – 将电机移动到特定角度
- en: Servomotors are widely used electronic components in applications such as pan-tilt
    camera control, robotic arms, mobile robot movements, and so on where precise
    movement of the motor shaft is required. This precise control of the motor shaft
    is possible because of the position sensing decoder, which is an integral part
    of the servomotor assembly. A standard servomotor allows the angle of the shaft
    to be set between 0 and 180 degrees. The `pyFirmata` library provides the `SERVO`
    mode that can be implemented on every digital pin. This prototyping exercise provides
    a template and guidelines to interface a servomotor with Python.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机是广泛应用于如云台相机控制、机械臂、移动机器人运动等需要精确电机轴运动的电子组件。这种对电机轴的精确控制是由于位置感应解码器，它是伺服电机组件的组成部分。标准伺服电机允许轴的角度在0到180度之间设置。`pyFirmata`库提供了可以在每个数字引脚上实现的`SERVO`模式。这个原型练习提供了一个模板和指南，用于将伺服电机与Python接口。
- en: Connections
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Typically, a servomotor has wires that are color-coded red, black, and yellow
    respectively to connect with the power, ground, and signal of the Arduino board.
    Connect the power and the ground of the servomotor to 5V and the ground of the
    Arduino board. As displayed in the following diagram, connect the yellow signal
    wire to the digital pin 13:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，伺服电机有红色、黑色和黄色的线分别用于连接电源、地线和Arduino板的信号。将伺服电机的电源和地线连接到5V和Arduino板的地线。如图所示，将黄色信号线连接到数字引脚13：
- en: '![Connections](img/5938OS_04_05.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![连接](img/5938OS_04_05.jpg)'
- en: If you want to use any other digital pin, make sure that you change the pin
    number in the Python program in the next section. Once you have made the appropriate
    connections, let's move on to the Python program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用其他任何数字引脚，确保你在下一节的Python程序中更改引脚号。一旦你完成了适当的连接，让我们继续到Python程序。
- en: The Python code
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python代码
- en: 'The Python file consisting of this code is named `servoCustomAngle.py` and
    is located in the code bundle of this book, which can be downloaded from [https://www.packtpub.com/books/content/support/19610](https://www.packtpub.com/books/content/support/19610).
    Open this file in your Python editor. Like other examples, the starting section
    of the program contains the code to import the libraries and set up the Arduino
    board:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此代码的Python文件命名为`servoCustomAngle.py`，位于本书的代码包中，可以从[https://www.packtpub.com/books/content/support/19610](https://www.packtpub.com/books/content/support/19610)下载。在Python编辑器中打开此文件。与其他示例一样，程序的起始部分包含导入库和设置Arduino板的代码：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that you have Python ready to communicate with the Arduino board, let''s
    configure the digital pin that is going to be used to connect the servomotor to
    the Arduino board. We will complete this task by setting the `mode` of pin 13
    to `SERVO`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用Python与Arduino板通信，让我们配置将要用来连接伺服电机的数字引脚。我们将通过将引脚13的`mode`设置为`SERVO`来完成此任务：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `setServoAngle(pin,angle)` custom function takes the pins on which the
    servomotor is connected and the custom angle as input parameters. This function
    can be used as a part of various large projects that involve servos:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`setServoAngle(pin,angle)`自定义函数接受伺服电机连接的引脚和自定义角度作为输入参数。这个函数可以用作涉及伺服电机的大型项目的组成部分：'
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the main logic of this template, we want to incrementally move the motor
    shaft in one direction until it achieves the maximum achievable angle (180 degrees)
    and then move it back to the original position with the same incremental speed.
    In the `while` loop, we will ask the user to provide input to continue this routine,
    which will be captured using the `raw_input()` function. The user can enter the
    character `y` to continue this routine or enter any other character to abort the
    loop:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模板的主要逻辑中，我们希望逐步将电机轴向一个方向移动，直到达到可达到的最大角度（180度），然后以相同的增量速度将其移回原始位置。在`while`循环中，我们将要求用户输入以继续此程序，该输入将通过`raw_input()`函数捕获。用户可以输入字符`y`以继续此程序，或输入任何其他字符以终止循环：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While working with all these prototyping examples, we used the direct communication
    method by using digital and analog pins to connect the sensors with Arduino. Now,
    let's get familiar with another widely used communication method between Arduino
    and the sensors, which is called I2C communication.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理所有这些原型设计示例时，我们使用了通过使用数字和模拟引脚将传感器与Arduino连接的直接通信方法。现在，让我们熟悉另一种在Arduino和传感器之间广泛使用的通信方法，即I2C通信。
- en: Prototyping with the I2C protocol
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I2C协议进行原型设计
- en: In the previous section, sensors or actuators were directly communicating with
    Arduino via digital, analog, or PWM pins. These methods are utilized by a large
    number of basic, low-level sensors and you will be widely using them in your future
    Arduino projects. Beside these methods, there is a wide variety of popular sensors
    that are based on **integrated circuit** (**IC**), which require different ways
    of communication. These IC-based advanced sensors utilize I2C- or SPI bus-based
    methods to communicate with the microcontroller. As we are going to use I2C-based
    sensors in the upcoming projects, the section will only cover the I2C protocol
    and practical example to understand the protocol in a better way. Once you understand
    the fundamentals of the I2C protocol, you can learn the SPI protocol very quickly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，传感器或执行器通过数字、模拟或PWM引脚直接与Arduino通信。这些方法被大量基本、低级传感器使用，你将在未来的Arduino项目中广泛使用它们。除了这些方法之外，还有许多基于**集成电路**（**IC**）的流行传感器，它们需要不同的通信方式。这些基于IC的高级传感器利用I2C或SPI总线方法与微控制器通信。由于我们将在即将到来的项目中使用基于I2C的传感器，本节将仅涵盖I2C协议和实际示例，以便更好地理解该协议。一旦你了解了I2C协议的基础，你就可以非常快速地学习SPI协议。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about SPI protocol and the supported Arduino SPI library
    from the following links:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下链接了解更多关于SPI协议和Arduino支持的SPI库的信息：
- en: '[http://arduino.cc/en/Reference/SPI](http://arduino.cc/en/Reference/SPI)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino SPI参考](http://arduino.cc/en/Reference/SPI)'
- en: '[http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/](http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Arduino控制或测试SPI电机的说明](http://www.instructables.com/id/Using-an-Arduino-to-Control-or-Test-an-SPI-electro/)'
- en: 'In 1982, the Philips company needed to find out a simple and efficient way
    to establish communication between a microcontroller and the peripheral chips
    on TV sets, which led to the development of the I2C communication protocol. The
    I2C protocol connects the microcontroller or the CPU to a large number of low-speed
    peripheral devices using just two wires. Examples of such peripheral devices or
    sensors include I/O devices, A/D converters, D/A converters, EEPROM, and many
    similar devices. I2C uses the concept of master-slave devices, where the microcontroller
    is the master and the peripherals are the slave devices. The following diagram
    shows an example of the I2C communication bus:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 1982年，飞利浦公司需要找到一种简单高效的方法来在微控制器和电视上的外围芯片之间建立通信，这导致了I2C通信协议的开发。I2C协议使用仅两条线将微控制器或CPU连接到大量低速外围设备。此类外围设备或传感器的例子包括I/O设备、A/D转换器、D/A转换器、EEPROM以及许多类似设备。I2C使用主从设备的概念，其中微控制器是主设备，外围设备是从设备。以下图示显示了I2C通信总线的示例：
- en: '![Prototyping with the I2C protocol](img/5938OS_04_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![使用I2C协议进行原型设计](img/5938OS_04_07.jpg)'
- en: 'As displayed in the preceding diagram, the master device contains two bidirectional
    lines: **Serial Data Line** (**SDA**) and **Serial Clock Line** (**SCL**). In
    the case of Arduino Uno, the analog pins 4 and 5 provide interfaces for SDA and
    SCL. It is important to note that these pin configurations will change with different
    variants of the Arduino board. The peripheral sensors that are working as slaves
    connect to these lines, which are also supported by the pull resistors. The master
    device is responsible for generating the clock signal on the SCL and initializing
    communication with the slaves. The slave devices receive the clock and respond
    to the commands sent by the master device.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个图所示，主设备包含两条双向线：**串行数据线**（**SDA**）和**串行时钟线**（**SCL**）。在 Arduino Uno 的情况下，模拟引脚
    4 和 5 提供了 SDA 和 SCL 的接口。需要注意的是，这些引脚配置会随着 Arduino 板的不同版本而改变。作为从设备工作的外围传感器连接到这些线，这些线也由上拉电阻支持。主设备负责在
    SCL 上生成时钟信号，并与从设备初始化通信。从设备接收时钟并响应主设备发送的命令。
- en: 'The order of the slave devices is not important as the master device communicates
    with the slaves using their part address. To initialize the communication, the
    master sends one of the following types of message on the bus with the specific
    part address:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备顺序并不重要，因为主设备通过从设备的部分地址与其通信。为了初始化通信，主设备会在总线上发送以下类型之一的消息，并带有特定的部分地址：
- en: A single message in which data is written on the slave
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从设备上写入数据的单个消息
- en: A single message in which data is read from the slave
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取从设备数据的单个消息
- en: Multiple messages in which first data is requested from the slave and then the
    received data is read
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取从设备数据的多个消息
- en: 'To support I2C protocol in Arduino programming, the Arduino IDE comes equipped
    with a default library called `Wire`. This library can be imported to your Arduino
    sketch by adding the following line of code at the beginning of your program:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Arduino 编程中支持 I2C 协议，Arduino IDE 配备了一个名为 `Wire` 的默认库。您可以通过在程序开头添加以下代码行将此库导入到您的
    Arduino 绘图中：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To initialize I2C communication, the `Wire` library uses a combination of the
    following functions to write data on the slave device:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化 I2C 通信，`Wire` 库使用以下函数的组合在从设备上写入数据：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These slave devices are differentiated using unique part addresses. As you can
    see in the preceding example, `0x48` is the part address of a connected slave
    device.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些从设备使用独特的部分地址进行区分。正如前一个示例中所示，`0x48` 是连接的从设备的部分地址。
- en: The `Wire` library also provides the `Wire.read()` and `Wire.requestFrom()`
    functions to read and request data from the slave devices. These functions are
    explained in detail in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire` 库还提供了 `Wire.read()` 和 `Wire.requestFrom()` 函数来读取和请求从设备的数据。这些函数将在下一节中详细解释。'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the I2C protocol and the `Wire` library from the following
    links:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接中了解更多关于 I2C 协议和 `Wire` 库的信息：
- en: '[http://www.instructables.com/id/I2C-between-Arduinos/](http://www.instructables.com/id/I2C-between-Arduinos/)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino 之间 I2C 通信教程](http://www.instructables.com/id/I2C-between-Arduinos/)'
- en: '[http://arduino.cc/en/reference/wire](http://arduino.cc/en/reference/wire)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Arduino TMP102 温度传感器编码参考](http://arduino.cc/en/reference/wire)'
- en: Arduino examples for I2C interfacing
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino I2C 接口示例
- en: In order to practice prototyping exercises for the I2C protocol, let's utilize
    two popular I2C sensors that detect temperature and ambient light in the environment.
    As the first step towards understanding I2C messaging, we will work with Arduino
    sketches for I2C interfacing, and later, we will develop similar functionalities
    using Python.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习 I2C 协议的原型设计练习，让我们利用两个流行的 I2C 传感器，这些传感器可以检测环境中的温度和光照。作为理解 I2C 消息的第一步，我们将使用
    Arduino 绘图进行 I2C 接口操作，稍后，我们将使用 Python 开发类似的功能。
- en: Arduino coding for the TMP102 temperature sensor
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 TMP102 温度传感器编写的 Arduino 代码
- en: 'TMP102 is one of the widely used digital sensors to measure ambient temperature.
    TMP102 provides better resolution and accuracy compared to traditional analog
    temperature sensors such as LM35 or TMP36\. The following is an image of TMP102:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: TMP102 是广泛使用的数字传感器之一，用于测量环境温度。与传统的模拟温度传感器（如 LM35 或 TMP36）相比，TMP102 提供了更好的分辨率和精度。以下是
    TMP102 的图片：
- en: '![Arduino coding for the TMP102 temperature sensor](img/5938OS_04_08.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino TMP102 温度传感器编码示例](img/5938OS_04_08.jpg)'
- en: 'The previous image shows a breakout board with the available pins for the TMP102
    sensor. Please keep in mind that the TMP102 sensor that you obtain might have
    a different pin layout compared to the one displayed in the image. It is always
    advisable to check the datasheet of your sensor breakout board before making any
    connections. As you can see in the image, the TMP102 sensor supports the I2C protocol
    and is equipped with SDA and SCL pins. Connect analog pins 4 and 5 of your Arduino
    Uno board to the SDA and SCL pins of the TMP102 sensor. Also, connect +5V and
    the ground as displayed in the following diagram. In this example, we are using
    the Arduino Uno board as the master and TMP102 as the slave peripheral, where
    the part address of TMP102 is `0x48` in hex:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片展示了一个带有 TMP102 传感器可用引脚的扩展板。请注意，您获得的 TMP102 传感器可能具有与图片中显示的不同的引脚布局。在连接任何电路之前，始终建议检查您的传感器扩展板的数据表。如图所示，TMP102
    传感器支持 I2C 协议，并配备了 SDA 和 SCL 引脚。将 Arduino Uno 板的模拟引脚 4 和 5 连接到 TMP102 传感器的 SDA
    和 SCL 引脚。此外，按照以下图示连接 +5V 和地线。在这个例子中，我们使用 Arduino Uno 板作为主设备，TMP102 作为从设备外设，其中
    TMP102 的部分地址为十六进制的 `0x48`：
- en: '![Arduino coding for the TMP102 temperature sensor](img/5938OS_04_09.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino 编码用于 TMP102 温度传感器](img/5938OS_04_09.jpg)'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can obtain the TMP102 sensor breakout board from SparkFun Electronics at
    [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 SparkFun Electronics 购买 TMP102 传感器扩展板，链接为[https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)。
- en: The datasheet of this board can be obtained at [https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/tmp102.pdf)获取该板的数据表。
- en: 'Now, connect your Arduino board to your computer using a USB cable and create
    a new sketch in the Arduino IDE using the following code snippet. Once you have
    selected the appropriate serial port and type of board in the Arduino IDE, upload
    and run the code. If all the steps are performed as described, on execution, you
    will be able to see the temperature reading in **Celsius** and **Fahrenheit**
    in the **Serial Monitor** window:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 USB 线将您的 Arduino 板连接到计算机，并在 Arduino IDE 中创建一个新的草图，使用以下代码片段。一旦在 Arduino
    IDE 中选择了适当的串行端口和板类型，上传并运行代码。如果所有步骤都按描述执行，则在执行时，您将在 **串行监视器** 窗口中看到温度读数，以 **摄氏度**
    和 **华氏度** 显示：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code snippet, the `Wire.requestFrom(partAddress,2)` function
    requests two bytes from the slave TMP102\. The slave sends data bytes to the master,
    which get captured by the `Wire.read()` function and are stored as two different
    bits: **most significant bit** (**MSB**) and **least significant bit** (**LSB**).
    These bytes are converted into an integer value, which is then converted into
    the actual Celsius reading by multiplying the incremental fraction of the TMP102
    sensor that is obtained from the datasheet. TMP102 is one of the easiest I2C sensors
    to interface with Arduino as the sensor values can be obtained via a simple I2C
    request method.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Wire.requestFrom(partAddress,2)` 函数从从设备 TMP102 请求两个字节。从设备发送数据字节到主设备，这些字节被
    `Wire.read()` 函数捕获，并存储为两个不同的位：**最高有效位**（**MSB**）和**最低有效位**（**LSB**）。这些字节被转换为整数值，然后通过乘以从数据表中获得的
    TMP102 传感器的增量分数，将其转换为实际的摄氏读数。TMP102 是最容易与 Arduino 接口的 I2C 传感器之一，因为可以通过简单的 I2C
    请求方法获取传感器值。
- en: Arduino coding for the BH1750 light sensor
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino 编码用于 BH1750 光传感器
- en: 'BH1750 is a digital light sensor that measures the amount of visible light
    in a given area. Although various DIY projects utilize simple photocells as a
    cheap alternative, the BH1750 sensor is known for higher resolution and accuracy
    in a wide range of applications. The ambient light, also called luminous flux
    or lux, is measured in unit lumen. The BH1750 sensor supports I2C communication
    with part address `0x23`, with `0x5C` as the secondary address if you are using
    multiple BH1750 sensors. The following is an image of a typical breakout board
    consisting of BH1750:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: BH1750 是一种数字光传感器，用于测量特定区域内的可见光量。尽管各种 DIY 项目使用简单的光敏电阻作为便宜的替代品，但 BH1750 传感器因其高分辨率和精度而广泛应用于各种应用。环境光，也称为光通量或流明，以流明为单位测量。BH1750
    传感器支持使用部分地址 `0x23` 的 I2C 通信，如果您使用多个 BH1750 传感器，则次要地址为 `0x5C`。以下是一个典型的 BH1750 扩展板的图片：
- en: '![Arduino coding for the BH1750 light sensor](img/5938OS_04_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino 编码用于 BH1750 光传感器](img/5938OS_04_10.jpg)'
- en: 'Connect the SDA and SCL pins of the BH1750 breakout board to analog pins 4
    and 5 of the Arduino Uno board, as displayed in the following circuit diagram.
    Also, complete the +5V and ground connections as displayed in the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将BH1750扩展板的SDA和SCL引脚连接到Arduino Uno板的模拟引脚4和5，如以下电路图所示。同时，完成+5V和地线的连接，如以下图所示：
- en: '![Arduino coding for the BH1750 light sensor](img/5938OS_04_11.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![为BH1750光传感器进行Arduino编码](img/5938OS_04_11.jpg)'
- en: 'In the previous example, we used functions from the `Wire` library to complete
    the I2C communication. Although `BH1750` is a simple and convenient I2C sensor,
    in the case of a sensor with multiple measurement capabilities, it is not convenient
    to code directly using the `Wire` library. In this situation, you can use sensor-specific
    Arduino libraries that are developed by the manufacturer or the open source community.
    For `BH1750`, we will demonstrate the use of such a library to assist the I2C
    coding. Before we can use this library, we will have to import it to the Arduino
    IDE. It is really important to know the process of importing libraries to your
    Arduino IDE as you will be repeating this process to install other libraries in
    future. Execute the following steps to import the `BH1750` library to your Arduino
    IDE:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`Wire`库中的函数来完成I2C通信。尽管`BH1750`是一个简单且方便的I2C传感器，但在具有多种测量能力的传感器情况下，直接使用`Wire`库进行编码并不方便。在这种情况下，您可以使用由制造商或开源社区开发的特定于传感器的Arduino库。对于`BH1750`，我们将演示如何使用此类库来辅助I2C编码。在我们能够使用此库之前，我们必须将其导入到Arduino
    IDE中。了解将库导入到Arduino IDE的过程非常重要，因为您将在未来重复此过程来安装其他库。执行以下步骤将`BH1750`库导入到您的Arduino
    IDE中：
- en: Download and extract [Chapter 7](ch07.html "Chapter 7. The Midterm Project –
    a Portable DIY Thermostat"), *The Midterm Project – a Portable DIY Thermostat*,
    code examples in a folder.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压[第7章](ch07.html "第7章。中期项目 – 一个便携式DIY恒温器")，*中期项目 – 一个便携式DIY恒温器*，代码示例在一个文件夹中。
- en: Open the Arduino IDE and navigate to **Sketch** | **Import Library…** | **Add
    Library…**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Arduino IDE并导航到**草图** | **导入库…** | **添加库…**。
- en: When you are asked for a directory, go to the `BH1750` folder in the downloaded
    file and click on **Select**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求选择目录时，请前往下载文件中的`BH1750`文件夹，然后点击**选择**。
- en: To check if your library is installed, navigate to **Sketch** | **Import Library…**
    and look for **BH1750** in the drop-down list.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查您的库是否已安装，导航到**草图** | **导入库…**，并在下拉列表中查找**BH1750**。
- en: Finally, restart the Arduino IDE.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重启Arduino IDE。
- en: Tip
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using an Arduino IDE with version 1.0.4 or an older version, you
    might not be able to find the **Import Library…** option from the menu. In this
    case, you need to follow the tutorial at [http://arduino.cc/en/Guide/Libraries](http://arduino.cc/en/Guide/Libraries).
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用的是版本1.0.4或更早版本的Arduino IDE，您可能无法在菜单中找到**导入库…**选项。在这种情况下，您需要遵循[http://arduino.cc/en/Guide/Libraries](http://arduino.cc/en/Guide/Libraries)上的教程。
- en: The `BH1750` library has a method to directly obtain ambient light values. Let's
    test this library using a built-in code example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BH1750`库有一个直接获取环境光值的方法。让我们使用内置的代码示例来测试这个库。'
- en: 'After restarting your Arduino IDE, navigate to **File** | **Examples** | **BH1750**
    and open the **BH1750test** Arduino sketch. This should open the following code
    snippet in the Arduino IDE. Set up an appropriate serial port and upload the code
    to your Arduino board. Once the code is executed, you will be able to check the
    luminous flux (`lux`) values using the serial monitor of the Arduino IDE. Make
    sure that the serial monitor is configured to 9600 baud:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启Arduino IDE后，导航到**文件** | **示例** | **BH1750**，打开**BH1750test** Arduino草图。这应该在Arduino
    IDE中打开以下代码片段。设置合适的串行端口并将代码上传到您的Arduino板。一旦代码执行，您将能够使用Arduino IDE的串行监视器检查光通量(`lux`)值。请确保串行监视器配置为9600波特率：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see from the preceding code snippet, we have imported the `BH1750`
    library by including `BH1750.h` file with `Wire.h`. This library provides the
    `readLightLevel()` function, which will fetch the ambient light value from the
    sensor and provide it as an integer. As the Arduino code runs in a loop with a
    delay of 1000 milliseconds, the `lux` values will be fetched from the sensor and
    sent to the serial port every second. You can observe these values in the **Serial
    Monitor** window.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们通过包含 `Wire.h` 文件中的 `BH1750.h` 文件来导入 `BH1750` 库。这个库提供了 `readLightLevel()`
    函数，它将从传感器获取环境光值并提供为整数。由于 Arduino 代码以 1000 毫秒的延迟在循环中运行，`lux` 值将每秒从传感器获取并发送到串行端口。您可以在
    **串行监视器** 窗口中观察到这些值。
- en: PyMata for quick I2C prototyping
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyMata 用于快速 I2C 原型设计
- en: We have been using `pyFirmata` as our default Python library to interface the
    Firmata protocol. The `pyFirmata` library is a very useful Python library to get
    started with the Firmata protocol, as it provides many simple and effective methods
    to define the Firmata ports and their roles. Due to these reasons, we extensively
    used `pyFirmata` for rapid prototyping in the previous section. Although `pyFirmata`
    supports analog, digital, PWM, and SERVO modes with easy-to-use methods, it provides
    limited support to the I2C protocol.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用 `pyFirmata` 作为我们的默认 Python 库来接口 Firmata 协议。`pyFirmata` 库是一个非常有用的 Python
    库，用于开始使用 Firmata 协议，因为它提供了许多简单而有效的方法来定义 Firmata 端口及其角色。由于这些原因，我们在前面的部分中广泛使用了 `pyFirmata`
    进行快速原型设计。尽管 `pyFirmata` 支持模拟、数字、PWM 和 SERVO 模式，并提供了易于使用的方法，但它对 I2C 协议的支持有限。
- en: In this section, we are going to use a different Python Firmata library called
    `PyMata` to get familiar with Python-based prototyping of I2C sensors. The `PyMata`
    library supports regular Firmata methods and also provides full support for the
    I2C messaging protocol.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个名为 `PyMata` 的不同 Python Firmata 库来熟悉基于 Python 的 I2C 传感器的原型设计。`PyMata`
    库支持常规的 Firmata 方法，并提供对 I2C 消息协议的全面支持。
- en: '`PyMata` can be easily installed using Setuptools, which we used in the previous
    chapters to install other Python libraries. We are assuming that you already have
    Setuptools and `pip` on your computer. Let''s start performing the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyMata` 可以通过 Setuptools 轻松安装，我们在前面的章节中使用它来安装其他 Python 库。我们假设您已经在计算机上安装了 Setuptools
    和 `pip`。让我们开始执行以下步骤：'
- en: 'To install `PyMata` on a Windows computer, execute the following command in
    the command prompt:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Windows 计算机上安装 `PyMata`，请在命令提示符中执行以下命令：
- en: '[PRE47]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you are using Linux or Mac OS X, use the following command in the terminal
    to install the `PyMata` library:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用 Linux 或 Mac OS X，请在终端中使用以下命令安装 `PyMata` 库：
- en: '[PRE48]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If everything is set up properly, this process will complete without any error.
    You can confirm `PyMata` by opening Python''s interactive prompt and importing
    `PyMata`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切设置正确，此过程将无错误完成。您可以通过在 Python 的交互式提示符中打开并导入 `PyMata` 来确认 `PyMata`：
- en: '[PRE49]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the execution of the preceding command fails, you need to check the installation
    process for any error. Resolve the error and repeat the installation process.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前述命令的执行失败，您需要检查安装过程是否有任何错误。解决错误并重复安装过程。
- en: Interfacing TMP102 using PyMata
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PyMata 接口 TMP102
- en: 'In order to utilize `PyMata` functionalities, you will need your Arduino board
    to be equipped with the standard firmata firmware just like the `pyFirmata` library.
    Before we proceed to explain the `PyMata` functions, let''s first run the following
    code snippet. Connect your TMP102 temperature sensor as explained in the previous
    section. Using the Arduino IDE, navigate to **File** | **Examples** | **Firmata**
    and upload the standard Firmata sketch from there to your Arduino board. Now,
    create a Python executable file using the following code snippet. Change the value
    of port (`COM5`), if needed, to an appropriate port name as required by your operating
    system. Finally, run the program:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用 `PyMata` 的功能，您需要确保您的 Arduino 板安装了标准的 firmata 固件，就像 `pyFirmata` 库一样。在我们继续解释
    `PyMata` 的功能之前，让我们首先运行以下代码片段。按照上一节中的说明连接 TMP102 温度传感器。使用 Arduino IDE，导航到 **文件**
    | **示例** | **Firmata**，并将标准 Firmata 脚本上传到您的 Arduino 板。现在，使用以下代码片段创建一个 Python 可执行文件。如果需要，将端口的值（`COM5`）更改为操作系统所需的适当端口名称。最后，运行程序：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On the execution of the preceding code snippet, you will be able to see the
    temperature reading in Fahrenheit and Celsius. As you can see from the inline
    comments in the code, the first step to utilize Arduino using `PyMata` is to initialize
    the port using the `PyMata` constructor. `PyMata` supports the configuration of
    I2C pins via the `i2c_config()` function. `PyMata` also supports simultaneous
    reading and writing operations via the `i2c_read()` and `i2c_write()` functions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码片段时，你将能够在华氏和摄氏温度下看到温度读数。正如你从代码中的内联注释中可以看到，使用 `PyMata` 初始化端口的第一步是使用 `PyMata`
    构造函数。`PyMata` 通过 `i2c_config()` 函数支持配置 I2C 引脚。`PyMata` 还通过 `i2c_read()` 和 `i2c_write()`
    函数支持同时读写操作。
- en: Interfacing BH1750 using PyMata
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PyMata 接口 BH1750
- en: 'In the case of BH1750, the previous `PyMata` code snippet can be utilized with
    minor modifications to obtain ambient light sensor data. As the first change,
    you want to replace the part address of TMP102 (`0x48`) with the one of BH1750
    (`0x23`) in the following code snippet. You will also have to convert the raw
    values received from the sensor into the `lux` value using the given formula.
    After these modifications, run the following program from the terminal:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 BH1750 来说，前面的 `PyMata` 代码片段经过少量修改后可以用来获取环境光传感器数据。作为第一个更改，你想要将 TMP102 的部分地址（`0x48`）替换为
    BH1750 的地址（`0x23`）在下面的代码片段中。你还需要将传感器接收到的原始值转换为 `lux` 值，使用给定的公式。完成这些修改后，从终端运行以下程序：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On running the preceding code snippet, you will be able to see the ambient light
    sensor reading in `lux` at the terminal. This process can be used in a large number
    of I2C devices to read the registered information. In complex I2C devices, you
    will have to follow their datasheet or examples to organize the read and write
    commands of the I2C.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的代码片段后，你将能够在终端看到环境光传感器的 `lux` 读数。这个过程可以用于大量 I2C 设备来读取注册信息。在复杂的 I2C 设备中，你必须遵循它们的规格书或示例来组织
    I2C 的读写命令。
- en: Useful pySerial commands
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的 pySerial 命令
- en: 'The standard Firmata protocol and Python''s Firmata libraries are very useful
    for testing or quick prototyping of the I2C sensors. Although they have many advantages,
    Firmata-based projects face the following disadvantages:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Firmata 协议和 Python 的 Firmata 库对于测试或快速原型化 I2C 传感器非常有用。尽管它们有很多优点，但基于 Firmata
    的项目面临以下缺点：
- en: '**Delay in real-time execution**: Firmata-based approaches require a series
    of serial communication messages to receive and send data, which adds additional
    delay and reduces the speed of execution.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时执行中的延迟**：基于 Firmata 的方法需要一系列的串行通信消息来接收和发送数据，这增加了额外的延迟并降低了执行速度。'
- en: '**Unwanted space**: The Firmata protocol contains a large amount of additional
    code to support various other Arduino functions. In a well-defined project, you
    don''t really need the complete set of functions.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的空间**：Firmata 协议包含大量额外的代码来支持各种其他 Arduino 功能。在一个定义良好的项目中，你实际上并不需要完整的函数集。'
- en: '**Limited support**: Although a version of Firmata includes I2C support, it
    is quite difficult to implement complex I2C functions without adding delay.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限支持**：尽管 Firmata 的某个版本包括 I2C 支持，但如果不添加延迟，实现复杂的 I2C 函数相当困难。'
- en: In summary, you can always use Firmata-based approaches to quickly prototype
    your projects, but when you are working on production-level or advanced projects,
    you can use alternative methods. In these scenarios, you can use custom Arduino
    code that is supported by Python's serial library, `pySerial`, to enable communication
    for very specific functionalities. In this section, we are going to cover a few
    helpful `pySerial` methods that you can use if you have to utilize the library
    directly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你总是可以使用基于 Firmata 的方法来快速原型化你的项目，但在你从事生产级或高级项目时，你可以使用替代方法。在这些情况下，你可以使用由
    Python 的串行库 `pySerial` 支持的定制 Arduino 代码，以启用非常特定的功能通信。在本节中，我们将介绍一些有用的 `pySerial`
    方法，如果你必须直接使用库的话。
- en: Connecting with the serial port
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到串行端口
- en: 'Once you have connected your Arduino to a USB port of your computer, you can
    open the port in your Python code using the `Serial` class as displayed in the
    following code example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 Arduino 连接到电脑的 USB 端口，你就可以使用 `Serial` 类在 Python 代码中打开端口，如下面的代码示例所示：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In addition to port name and baud rate, you can also specify a number of serial
    port parameters such as `timeout`, `bytesize`, `parity`, `stopbits`, and so on
    using `Serial()`. It is necessary to initialize the serial port before executing
    any other command from the `pySerial` library.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了端口号和波特率之外，你还可以使用`Serial()`指定一系列串行端口参数，如`timeout`、`bytesize`、`parity`、`stopbits`等。在执行`pySerial`库中的任何其他命令之前，必须初始化串行端口。
- en: Reading a line from the port
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从端口读取一行
- en: 'Once the serial port is opened, you can start reading the port using `readline()`.
    The `readline()` function requires the timeout to be specified while initializing
    the port, otherwise the code can terminate with an exception:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦串行端口打开，你可以开始使用`readline()`读取端口。在初始化端口时，`readline()`函数需要指定超时，否则代码可能会因异常而终止：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `readline()` function will process each line from the port that is terminated
    with the end line character `\n`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline()`函数将处理端口中每个以换行符`\n`终止的行。'
- en: Flushing the port to avoid buffer overflow
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除端口以避免缓冲区溢出
- en: 'While working with `pySerial`, it is necessary to flush the input buffer to
    avoid buffer overflow and maintain real-time operations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pySerial`时，有必要清除输入缓冲区以避免缓冲区溢出并保持实时操作：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the port's baud rate is high and the processing of the input data is slow,
    buffer overflow may occur, reducing the speed of execution and making the experience
    sluggish.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口的波特率较高且输入数据处理较慢，可能会发生缓冲区溢出，降低执行速度并使体验变得缓慢。
- en: Closing the port
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭端口
- en: 'It is a good coding practice to close the serial port once the process is complete.
    This practice can eliminate the port-blocking problem once the Python code is
    terminated:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 完成过程后关闭串行端口是一种良好的编码实践。这种做法可以在Python代码终止后消除端口阻塞问题：
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned important methods that are required to successfully
    interface the Arduino board with Python. You were also introduced to various prototyping
    code templates with practical applications. These prototyping templates helped
    us to learn new Python programing paradigms and Firmata methods. Later in the
    chapter, we dived further into prototyping by learning more about the different
    ways of establishing communication between sensors and the Arduino board. Although
    we covered a vast amount of programming concepts with these prototyping examples,
    the goal of the chapter was to make you familiar with the interfacing problems
    and provide quick recipes for your projects.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了成功将Arduino板与Python接口所需的重要方法。你还被介绍了各种具有实际应用的原型代码模板。这些原型模板帮助我们学习新的Python编程范式和Firmata方法。在章节的后面部分，我们进一步深入原型设计，通过学习更多关于传感器与Arduino板之间建立通信的不同方式。尽管我们通过这些原型示例涵盖了大量的编程概念，但本章的目标是让你熟悉接口问题，并为你的项目提供快速解决方案。
- en: We are assuming that by now you are comfortable testing your sensors or project
    prototypes using Python and Arduino. It's time to start working towards creating
    your applications that have complex Python features such as user controls, charts,
    and plots. In the next chapter, we are going to develop custom graphical user
    interfaces (GUIs) for your Python-Arduino projects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '我们假设你现在已经熟悉使用Python和Arduino测试你的传感器或项目原型。现在是时候开始着手创建具有复杂Python功能（如用户控制、图表和绘图）的应用程序了。在下一章中，我们将为你的Python-Arduino项目开发自定义图形用户界面（GUI）。 '
