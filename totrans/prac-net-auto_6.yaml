- en: Continuous Integration for Network Engineers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in previous chapters, now armed with knowledge or a fair understanding
    on creating automation using various techniques, working with Ansible, and understanding
    best practices, we continue our journey to understand how to work on the basics
    of planning an automation project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see some of the tools that help us in working on planning
    our automation projects, and some examples to interact with some increasingly
    complex scenarios related to various devices or network technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the aspects that we will be working on are:'
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with Splunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BGP and routing table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireless client to AP to switchport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone to switchport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WLAN and IPAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful best practices and use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with Splunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Splunk** is one of the most widely used data mining tools. With its data
    mining and digging capabilities, engineers can take actions based upon decisions.
    While it is useful in various aspects, here we will see an example of Splunk being
    used as a Syslog server, with our test router sending a message (as syslog) to
    this server, and how from automation we can query results from Splunk for these
    syslogs and take actions.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an important part of automation, since based upon certain events (alerts
    and syslogs), engineers need to perform automated tasks, like self healing, or
    even triggering emails or using third-party tools to create tickets for various
    teams to work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will see the basic implementation and configuration of Splunk as a
    Syslog server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading and installing Splunk , it can be accessed from the URL `http://localhost:8000/en-US/account/login?return_to=%2Fen-US%2F` as
    we can see in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6189c067-0a4c-4106-975c-4c5bd66d2d42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we login, we create a listener listed to syslogs (in our case we use the
    `TCP` protocol and keep the default port `514` open):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48cc657b-392a-4a50-b50b-72a47dab1d87.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the configuration is done for TCP port `514` on Splunk (listening for syslog
    messages), ensure any local firewall on the server is allowing inbound packets
    to TCP port `514`, and our machine is ready to access syslogs from network devices
    on TCP port `514`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the router to send syslogs. We apply the following commands on the
    router to enable logging (In our case the IP for the Syslog server is `192.168.255.250`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This configures the router to send syslogs to the given IP address on TCP protocol
    over port `514`. Additionally, we are also stating to log only information syslog
    messages on the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, for confirmation we can try to perform a shutdown and no shutdown
    of any interface (`Loopback0` in our case), and see the log using the `show logging`
    command on the router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An important aspect to confirm if the router is sending syslogs is the line
    `tcp port 514, audit disabled, link up`, which confirms that the router is sending
    syslog traffic to the Syslog server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the raw output on Splunk for the syslog that is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f9db7f5d-5a30-444b-a201-d60a95547b3f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in the New Search section we can write queries to fetch the exact
    data that we want. In our case we wanted to see only the log from our router with
    the `Interface Loopback0` down messages, hence we wrote the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see the code from Python that we can write to fetch the same information
    using a script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first section, we query the API of Splunk to fetch the authentication
    session key (or token) to run our queries and get results. Once we have the session
    key (extracted from the XML output), we create a header and using `requests.post`
    we execute our query. The data variable contains our query in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, if we take this in a variable (named `Search`) , and provide
    the result as a value to that variable, it would look like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Additionally we also send another option of `output_mode` as JSON , since we
    want the output in JSON (some other values can be CSV or XML).
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the same will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283d1561-ade0-447d-a192-5d72952d8d63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding output, we are now retrieving and displaying the
    value in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: We will stop our example here, but to enhance this script, this result can now
    become a trigger on which we can add additional methods or logic to decide on
    the trigger for further actions. By this logic, we can have self-healing scripts
    that find out the data (as a trigger), evaluate the trigger (identify it actionable),
    and take actions based upon further logic.
  prefs: []
  type: TYPE_NORMAL
- en: Automation examples on various technology domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the familiarity and understanding of automation with the interaction of
    devices, APIs, controllers, let's see some examples of how to interact with other
    network domain devices and tackle some complex scenarios using automation frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these examples will be a small project in themselves, but will help
    you understand additional ways of performing automation tasks in depth.
  prefs: []
  type: TYPE_NORMAL
- en: BGP and routing table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an example in which we need to configure BGP, validate if a session
    is up, and report the details for the same. In our example, we would take two
    routers (as a prerequisite, both routers are able to ping each other) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebb2b169-6f26-4d3d-bbd7-e562af417b5d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see `R2` and `testrouter` are able to ping each other using an IP address
    of the `FastEthernet0/0` interface of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is a very basic configuration of BGP (in our case, we use the
    **Autonomous System** (**AS**) number `200`). The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b09e0f2-6f5d-40c9-83b2-2cf218026f39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, we push the neighbor config (BGP config) to the router. Once the
    config is pushed, the script waits for 5 seconds and validates the state of BGP
    if it is in the `ESTABLISHED state`. This validation confirms that the config
    that we pushed has all the sessions that are newly configured as established.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s push an incorrect config as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05566bbc-1697-444a-a402-d9d243fe5fb1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding output, now we are pushing the config with an incorrect
    remote (`400` in this case). Of course, since the config is not correct, we get
    a non-established message, which confirms that the config that we pushed was not
    correct. In a similar way, we can push the bulk of the configs by calling the
    methods as many times as we want for each of the remote neighbors to be configured.
    Additionally, sometimes we need to get specific information under certain config
    sections from a running config.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code will give out a list for each section of
    the running config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e49b5a2-ae3e-4771-9e99-8e62aa110650.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding output, we got all the sections of the running config,
    except the exclamation mark `!` that we see in a running config (executing the
    router command `show running-config` on router). The focus of this output is that
    we have a config that is now parsed for each section in running config grouped
    in a single list, or in other words, a specific set of configs meant for a specific
    section (such as an interface or BGP) is grouped in a single list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets enhance this code. As an example, we only want to see what BGP remote
    IPs are configured in our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1e683e7-edb6-4137-a417-79e60ff63dfb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, first we parse the running config and focus on the section which
    has the `router bgp` config. Once we get to that particular list, we parse the
    list and fetch the remote IP using the regex on the specific command that contains
    the string `neighbor`**. **The result values would be the remote IPs under the
    BGP section.
  prefs: []
  type: TYPE_NORMAL
- en: As we are working with BGP, the AS numbers, being an integral part of BGP, need
    to be parsed or validated. Using the preceding strategies, we can get the AS numbers
    for BGP routes/prefixes, but in addition to that, there is a Python library `pyasn` that
    can easily find out AS number information for a given public IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, as mentioned earlier, we need to install the following library before
    we can call it in the code, by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b63d2c78-e58e-4b92-8a4b-f26ab91884a4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, the first method `getfromhostname` is used to fetch information for
    a given hostname. The other method `getfromip`is used to fetch the same information
    by using an IP address instead of any hostname.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cisco switchport for access point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with a multi-device environment, along with routers and switches
    we need to interact with other network gear(s) like wireless devices. This example
    will show how to configure a switch with specific ports to be connected to **Access
    Point** (**AP**) as trunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our test case, assuming the VLANs configured on AP are `vlan 100` and `vlan
    200` for users, and the native VLAN is `vlan 10`, and the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc9a1e3-acd6-4da8-b324-7bab8f33e431.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, the AP needs to be connected to our switchport, which needs to be
    a trunk, with certain access VLANs to be allowed; hence we create two methods,
    the first of which passes router/switch name and the interfaces that needs to
    be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration is successfully pushed on the switch, we execute the
    `validateswitchport` method to validate if the same port is now in trunk mode.
    The output of the `validateswitchport`method spills out the output of the command,
    on which we can further introduce the regex and splits to get any specific information
    we want from that output (such as the `Administrative Mode` or `Operational Mode`).
  prefs: []
  type: TYPE_NORMAL
- en: As an enhancement, we can also use the outputs from the validation method to
    call other methods that would perform some additional configs (if required), based
    on the result that we got earlier. (For example, changing the `Trunking Native
    Mode VLAN` to `20`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the new code with the additional enhancement of changing the native
    VLAN to `20`. The code is as follows**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is explained in two sections as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validating and changing the native VLAN to `20`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d58b4964-2880-4582-bbc9-a508d4beecf7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Revalidating with the new native VLAN number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6d76c4ee-47da-4b36-8e6e-95e316fd34c0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the final validation, now we have a native VLAN 20, instead of
    the earlier `10`. This is also a good troubleshooting technique as in multiple
    scenarios there are requirements of a **what if analysis** (to take decisions
    based upon the evaluation of a certain condition)in which we need to take some
    actions based on the dynamic results received. Since, here in our code we validated
    that the native VLAN needs to be `20`, hence we performed another action to correct
    that earlier config.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cisco switchport for IP Phone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the earlier scenario, where we want a switchport as a trunk port
    for AP, we can configure the switchport to work with IP Phones. An additional
    task for configuring a port to be used as IP Phone is that another end machine
    or data machine can be connected to the IP Phone for data transfer. In other words,
    a single switchport of a Cisco router can act as both a voice and data port when
    used with IP Phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of configuring a switchport to act as an IP Phone port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bae28c5-6d1f-49f4-a7f5-a14a71f984c4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see now, the port configured (`FastEthernet 2/5`) has been assigned a
    `Voice VLAN` of `200` and a data/access VLAN of `100` (from the preceding output,
    notice the line `Access Mode VLAN: 100 (VLAN0100)`. Any IP Phone connecting to
    this port will have access to both the VLANs for its voice and data usage. Again,
    going by previous examples, we can perform additional validations and checks on
    the ports and trigger some actions in case of any incorrect or missing configs.'
  prefs: []
  type: TYPE_NORMAL
- en: Wireless LAN (WLAN)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many vendors that have backend APIs that can be controlled or called
    using Python to perform certain wireless tasks. A commonly used vendor in wireless
    is `Netgear`. Python has a library `pynetgear` that helps us achieve some of the
    automation to control our locally connected devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of fetching the current network devices connected to
    the local wireless Netgear router in our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Netgear` method accepts four arguments in the following order (`routerpassword`,
    `routerip`, `routerusername`, and `routerport`). As we see in the current example,
    the router is reachable using `http://192.168.100.1` with the username `admin`
    and password as `myrouterpassword`. Hence, we call the method with these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we see, the method `get_attached_devices()` returned a list of all the IPs,
    their MAC addresses (hidden in this example), signal (or wireless band being used),
    and the link rate for the connection in Mbps.
  prefs: []
  type: TYPE_NORMAL
- en: We can use similar type of methods to manipulate bandwidth, block any user,
    or perform other tasks that are exposed by the APIs of the specific hardware manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: Access of IP Address Management (IPAM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another requirement in networking is to use the IPAM database for IPAM. It is
    provided by different vendors, and as an example here, we would refer to SolarWind's
    IPAM. SolarWinds is again an industry standard tool for monitoring and performing
    various functionalities on a network, and it has a good set of APIs to interact
    with using its ORION SDK toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can install the library `orionsdk` to achieve interaction with
    SolarWinds. Let''s see an example in which we fetch the next available IP address
    from the IPAM module in SolarWinds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30c86818-98c1-4e5a-9894-a43b9f844821.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in the preceding code, we use the `orionsdk` library to call the
    API for SolarWinds from the `mysolarwindsserver`server.The username and password
    needed for the SolarWinds are passed in script, and we use a simple SQL query
    (which is understandable by SolarWinds) which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This query fetches the next available IP address (denoted by `Status=2` in SolarWinds)
    and prints it. The first print is the raw print and the one in `for` loop; it
    prints out the value in a better understandable format as shown in the preceding
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Example and use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will see a detailed example that is common to most network engineers,
    and how to automate it using Python. Also, we will create it as a web based tool,
    enabling it to run from any environment or machine, using only a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Create a web-based pre and post check tool for validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we will see how we can perform a pre and post check
    on any network maintenance that we do. This is generally required by every network
    engineer while performing activities on production devices to ensure that once
    the maintenance activity is complete, an engineer has not missed out anything
    that could cause an issue later on. It is also required to validate if our changes
    and maintenance have been completed successfully, or if we need to perform additional
    fixes and rollbacks in case of validations that have failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to create and execute the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Create the main HTML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will design a web-based form to select certain show commands that we will
    call for performing checks. These commands, when executed, will act as a precheck;
    once our maintenance activity is complete, we will act again as a postcheck.
  prefs: []
  type: TYPE_NORMAL
- en: Any difference between the same command outputs in precheck or postcheck scenarios
    will be highlighted and the engineer will be in a good position to make decisions
    on calling the maintenance a success or failure, based on the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code (`prepostcheck.html`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the main page on which we select our initial options (set
    of commands and if we need to perform a precheck or a postcheck). The output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/863b56f6-127a-4ea6-8b8a-abf74b0c3f57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Main page
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional JavaScript code in HTML ensures that the `Submit` button will
    not send any data until all the selections are made. There is no point sending
    data which is not completed; for example, if we do not fill out entire fields
    the `Submit` option will not proceed, giving out the message that we see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e02900d3-19d7-47d4-9b71-97a111443d7a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unless all the fields are not filled, hitting the `Submit` button will spill
    out this message and the code will not continue. Additionally, as we see in the
    code, the `Submit` button is tied to the Python script, with `checks.py`as a POST
    method. In other words, the selections we will make will be sent to `checks.py`
    as a POST method.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Create the backend Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s see the back end Python code (`checks.py`)that will accept these
    inputs from HTML form and perform its task. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code accepts input from a web page using the CGI parameter. Various values
    from the web page are parsed into the variables using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have these values, the additional logic is to log in into the given
    device(s) using the `paramiko`library, fetch the output of the show commands,
    and save it in a file under the `logs` folder with the output. An important aspect
    to note here is the way we are constructing the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `fname` is the filename into which we would write the output, but the filename
    is built dynamically with the inputs provided by the maintenance ID, device IP,
    pre/post status, and the time the file was created. This is to ensure that we
    know the device for which we are performing a pre or a post check, and at what
    time the file was created, to ensure we have a correct pre and post check combination.
  prefs: []
  type: TYPE_NORMAL
- en: The function `getoutput()`is invoked from a thread (in a multi-threaded function
    call) to fetch the output and store it in the newly created file. A multi-threading
    process is called, because if we want to perform pre or post checks in multiple
    devices, we can provide a comma separated IP address list in web, and Python script
    will in parallel invoke the show commands on all devices and create multiple pre
    or post check files, based on hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `precheck` file for some commands in our example, where we
    fill in some values and click on the `Submit` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efa052c4-e7e6-4de3-98a0-3b9f6fe93c91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the gathering of data is in progress, the yellow message will be displayed
    to confirm that the back end work is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the task is completed, this is what we see (as returned from the Python
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2af3ce42-fa61-4e0f-8058-70e97e9aaf3e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, the code returns a success, which means that it was able to fetch
    the output of the commands that we want to validate. The filename is dynamically
    created, based on our selection on the main page.
  prefs: []
  type: TYPE_NORMAL
- en: 'A click on the `.txt` filename that is generated as a clickable URL (which
    can be used to reconfirm if we got the correct output of commands we selected
    earlier), shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18397e3a-6a6f-468f-9aef-f3107f155925.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's perform the same steps and create a `postcheck` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We go back to the main page, and keeping the other values the same, we just
    select the radio button to `Postcheck` instead of `Precheck`. Do ensure that we
    select the same set of commands, since a pre and post check only make sense if
    we have the same data to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a73e82-3c55-40ad-97e0-9ab73b353a15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a similar way, once the backend execution completes, we have a `postcheck`
    file created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9322e246-d639-4e98-a754-37296920ef84.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the filename, the timestamp, and the `post`word changes based on our
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Create web server based files for the tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now with the both pre and post check files created, let's create a web framework
    to perform web-based pre/post check for the files. We need to create a web page
    in which our current log files are visible as pre and post files, and we can select
    the `precheck` file and its relevant `postcheck` file for comparison. As we know
    that we cannot use HTML or browser languages to fetch information about any files
    from the server,  we need to use some backed web language to perform this function
    for us. We take advantage of ASP and VB.NET to create the web page to display
    the already created log files for selection and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backend code for `selectfiles.aspx` is as follows (this is to display the
    files from the log directory on a browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The VB.NET backend code, to fill in the values on the preceding `.aspx` page
    `selectfiles.aspx.vb`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code is used to fetch the files from the log directory, and based on their
    filenames, they are divided into either `precheck` files or `postcheck` files.
    Also, the files are ordered in chronological order for easy selection during the
    comparison process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output of this page now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eab88dc-950f-41b1-b457-49a01d201889.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 – Create server based files for pre and post files comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final step is to create a web page that retrieves the text from these files
    and also provides frontend (or a web-based tool) for easy comparison. For our
    purpose, we use a JScript library called `diffview` **. **To call this dependency,
    we need to download `diffview.js`, `difflib.js`, and `diffview.css` which available
    here: [https://github.com/cemerick/jsdifflib, ](https://github.com/cemerick/jsdifflib)and
    copy the files into our web server folder. Once done, in the similar way as accessing
    the files, we would again create a `.aspx` page to get the content of the selected
    files and display it for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code of the main page `comparefiles.aspx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The backend code for the main page, to get the contents of the file (`comparefiles.aspx.vb`),
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this ready, let''s compare the files and see the results. We select the
    pre and post check files and click on `Submit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6402dbab-3ae6-41f6-b6c9-c1666534b465.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next page takes us to the content and comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493e101c-9380-4c06-a801-8a1c2788cbbf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding screenshot, on the left, we have the `precheck` file,
    and on the right, we have the `postcheck` file. Both can be read on the page itself
    through slides on both windows. The bottom window appears when we select either
    `Side by Side Diff` or `Inline Diff`.
  prefs: []
  type: TYPE_NORMAL
- en: On a `Side by Side Diff`, anything that is different will be highlighted. In
    our case it was uptime that was different. For everything else in common, no color
    highlighting will be in place and an engineer can safely assume the same states
    for non highlighted colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the same example with a `Inline Diff` comparison selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf4ec76-401b-438b-bbda-03bd7796af1b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is the same result; different lines are highlighted in different colors to
    confirm the pre and post check differences. With this tool now, an engineer can
    quickly parse through the entire log files, and based on the highlighted differences
    (a mismatch between `precheck` file content and `postcheck` file content), can
    make the decision to call the task a success or a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw various concepts related to the usage of automation
    in daily network scenarios. We got familiar with examples of performing various
    tasks related to additional devices such as wireless AP and IP Phones. Additionally,
    we also got introduced to IPAM of SolarWinds and how to work on the API using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a real-world example of creating a pre and post validation tool
    to help engineers make quick maintenance validation decisions, and also ported
    to the web so that the tool can be used from anywhere, instead of running from
    individual machines with Python installed as a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in our concluding chapter, we will look at some additional aspects
    of SDN to understand better usage and how and where to automate, with respect
    to SDN scenarios.
  prefs: []
  type: TYPE_NORMAL
