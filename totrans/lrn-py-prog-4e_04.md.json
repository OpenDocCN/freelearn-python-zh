["```py\n# data.science.example.py\ndef do_report(data_source):\n    # fetch and prepare data\n    data = fetch_data(data_source)\n    parsed_data = parse_data(data)\n    filtered_data = filter_data(parsed_data)\n    polished_data = polish_data(filtered_data)\n    # run algorithms on data\n    final_data = analyse(polished_data)\n    # create and return report\n    report = Report(final_data)\n    return report \n```", "```py\n# matrix.multiplication.nofunc.py\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\nc = [\n    [sum(i * j for i, j in zip(r, c)) for c in zip(*b)] for r in a\n] \n```", "```py\n# matrix.multiplication.func.py\ndef matrix_mul(a, b):\n    return [\n        [sum(i * j for i, j in zip(r, c)) for c in zip(*b)]\n        for r in a\n    ]\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\nc = matrix_mul(a, b) \n```", "```py\n# vat.nofunc.py\nprice = 100  # GBP, no VAT\nfinal_price1 = price * 1.2\nfinal_price2 = price + price / 5.0\nfinal_price3 = price * (100 + 20) / 100.0\nfinal_price4 = price + price * 0.2 \n```", "```py\n# vat.function.py\ndef calculate_price_with_vat(price, vat):\n    return price * (100 + vat) / 100 \n```", "```py\n# scoping.level.1.py\ndef my_function():\n    test = 1  # this is defined in the local scope of the function\n    print(\"my_function:\", test)\ntest = 0  # this is defined in the global scope\nmy_function()\nprint(\"global:\", test) \n```", "```py\n$ python scoping.level.1.py\nmy_function: 1\nglobal: 0 \n```", "```py\n# scoping.level.2.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        test = 2  # inner scope\n        print(\"inner:\", test)\n    inner()\n    print(\"outer:\", test)\ntest = 0  # global scope\nouter()\nprint(\"global:\", test) \n```", "```py\n$ python scoping.level.2.py\ninner: 2\nouter: 1\nglobal: 0 \n```", "```py\n# scoping.level.2.nonlocal.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        nonlocal test\n        test = 2  # nearest enclosing scope (which is 'outer')\n        print(\"inner:\", test)\n    inner()\n    print(\"outer:\", test)\ntest = 0  # global scope\nouter()\nprint(\"global:\", test) \n```", "```py\n$ python scoping.level.2.nonlocal.py\ninner: 2\nouter: 2\nglobal: 0 \n```", "```py\n# scoping.level.2.global.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        global test\n        test = 2  # global scope\n        print(\"inner:\", test)\n    inner()\n    print(\"outer:\", test)\ntest = 0  # global scope\nouter()\nprint(\"global:\", test) \n```", "```py\n$ python scoping.level.2.global.py\ninner: 2\nouter: 1\nglobal: 2 \n```", "```py\n# key.points.argument.passing.py\nx = 3\ndef func(y):\n    print(y)\nfunc(x)  # prints: 3 \n```", "```py\n# key.points.assignment.py\nx = 3\ndef func(x):\n    x = 7  # defining a local x, not changing the global one\nfunc(x)\nprint(x)  # prints: 3 \n```", "```py\n# key.points.mutable.py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this affects the `x` argument!\nfunc(x)\nprint(x)  # prints: [1, 42, 3] \n```", "```py\n# key.points.mutable.assignment.py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this changes the original `x` argument!\n    x = \"something else\"  # this points x to a new string object\nfunc(x)\nprint(x)  # still prints: [1, 42, 3] \n```", "```py\n# arguments.positional.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(1, 2, 3)  # prints: 1 2 3 \n```", "```py\n# arguments.keyword.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(a=1, c=2, b=3)  # prints: 1 3 2 \n```", "```py\n# arguments.positional.keyword.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(42, b=1, c=2) \n```", "```py\n# arguments.positional.keyword.py\nfunc(b=1, c=2, 42)  # positional arg after keyword args \n```", "```py\n$ python arguments.positional.keyword.py\n  File \"arguments.positional.keyword.py\", line 7\n    func(b=1, c=2, 42)  # positional arg after keyword args\n                     ^\nSyntaxError: positional argument follows keyword argument \n```", "```py\n# arguments.unpack.iterable.py\ndef func(a, b, c):\n    print(a, b, c)\nvalues = (1, 3, -7)\nfunc(*values)  # equivalent to: func(1, 3, -7) \n```", "```py\n# arguments.unpack.dict.py\ndef func(a, b, c):\n    print(a, b, c)\nvalues = {\"b\": 1, \"c\": 2, \"a\": 42}\nfunc(**values)  # equivalent to func(b=1, c=2, a=42) \n```", "```py\n# arguments.combined.py\ndef func(a, b, c, d, e, f):\n    print(a, b, c, d, e, f)\nfunc(1, *(2, 3), f=6, *(4, 5))\nfunc(*(1, 2), e=5, *(3, 4), f=6)\nfunc(1, **{\"b\": 2, \"c\": 3}, d=4, **{\"e\": 5, \"f\": 6})\nfunc(c=3, *(1, 2), **{\"d\": 4}, e=5, **{\"f\": 6}) \n```", "```py\n# arguments.multiple.value.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(2, 3, a=1) \n```", "```py\n$ python arguments.multiple.value.py\nTraceback (most recent call last):\n  File \"arguments.multiple.value.py\", line 5, in <module>\n    func(2, 3, a=1)\nTypeError: func() got multiple values for argument 'a' \n```", "```py\n# parameters.default.py\ndef func(a, b=4, c=88):\n    print(a, b, c)\nfunc(1)  # prints: 1 4 88\nfunc(b=5, a=7, c=9)  # prints: 7 5 9\nfunc(42, c=9)  # prints: 42 4 9\nfunc(42, 43, 44)  # prints: 42, 43, 44 \n```", "```py\n# parameters.variable.positional.py\ndef minimum(*n):\n    # print(type(n))  # n is a tuple\n    if n:  # explained after the code\n        mn = n[0]\n        for value in n[1:]:\n            if value < mn:\n                mn = value\n        print(mn)\nminimum(1, 3, -7, 9)  # n = (1, 3, -7, 9) - prints: -7\nminimum()  # n = () - prints: nothing \n```", "```py\n# parameters.variable.keyword.py\ndef func(**kwargs):\n    print(kwargs)\nfunc(a=1, b=42)  # prints {'a': 1, 'b': 42}\nfunc()  # prints {}\nfunc(a=1, b=46, c=99)  # prints {'a': 1, 'b': 46, 'c': 99} \n```", "```py\n# parameters.variable.db.py\ndef connect(**options):\n    conn_params = {\n        \"host\": options.get(\"host\", \"127.0.0.1\"),\n        \"port\": options.get(\"port\", 5432),\n        \"user\": options.get(\"user\", \"\"),\n        \"pwd\": options.get(\"pwd\", \"\"),\n    }\n    print(conn_params)\n    # we then connect to the db (commented out)\n    # db.connect(**conn_params)\nconnect()\nconnect(host=\"127.0.0.42\", port=5433)\nconnect(port=5431, user=\"fab\", pwd=\"gandalf\") \n```", "```py\n$ python parameters.variable.db.py\n{'host': '127.0.0.1', 'port': 5432, 'user': '', 'pwd': ''}\n{'host': '127.0.0.42', 'port': 5433, 'user': '', 'pwd': ''}\n{'host': '127.0.0.1', 'port': 5431, 'user': 'fab', 'pwd': 'gandalf'} \n```", "```py\n# parameters.positional.only.py\ndef func(a, b, /, c):\n    print(a, b, c)\nfunc(1, 2, 3)  # prints: 1 2 3\nfunc(1, 2, c=3)  # prints 1 2 3 \n```", "```py\nfunc(1, b=2, c=3) \n```", "```py\nTraceback (most recent call last):\n  File \"arguments.positional.only.py\", line 7, in <module>\n    func(1, b=2, c=3)\nTypeError: func() got some positional-only arguments\npassed as keyword arguments: 'b' \n```", "```py\n# parameters.positional.only.optional.py\ndef func(a, b=2, /):\n    print(a, b)\nfunc(4, 5)  # prints 4 5\nfunc(3)  # prints 3 2 \n```", "```py\ndef divmod(a, b, /):\n    \"Emulate the built in divmod() function\"\n    return (a // b, a % b) \n```", "```py\nlen(obj='hello') \n```", "```py\ndef func_name(name, /, **kwargs):\n    print(name)\n    print(kwargs)\nfunc_name(\"Positional-only name\", name=\"Name in **kwargs\")\n# Prints:\n# Positional-only name\n# {'name': 'Name in **kwargs'} \n```", "```py\n# parameters.keyword.only.py\ndef kwo(*a, c):\n    print(a, c)\nkwo(1, 2, 3, c=7)  # prints: (1, 2, 3) 7\nkwo(c=4)  # prints: () 4\n# kwo(1, 2)  # breaks, invalid syntax, with the following error\n# TypeError: kwo() missing 1 required keyword-only argument: 'c'\ndef kwo2(a, b=42, *, c):\n    print(a, b, c)\nkwo2(3, b=7, c=99)  # prints: 3 7 99\nkwo2(3, c=13)  # prints: 3 42 13\n# kwo2(3, 23)  # breaks, invalid syntax, with the following error\n# TypeError: kwo2() missing 1 required keyword-only argument: 'c' \n```", "```py\n# parameters.all.py\ndef func(a, b, c=7, *args, **kwargs):\n    print(\"a, b, c:\", a, b, c)\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\nfunc(1, 2, 3, 5, 7, 9, A=\"a\", B=\"b\") \n```", "```py\n$ python parameters.all.py\na, b, c: 1 2 3\nargs: (5, 7, 9)\nkwargs: {'A': 'a', 'B': 'b'} \n```", "```py\n# parameters.all.pkwonly.py\ndef allparams(a, /, b, c=42, *args, d=256, e, **kwargs):\n    print(\"a, b, c:\", a, b, c)\n    print(\"d, e:\", d, e)\n    print(\"args:\", args)\n    print(\"kwargs:\", kwargs)\nallparams(1, 2, 3, 4, 5, 6, e=7, f=9, g=10) \n```", "```py\n$ python parameters.all.pkwonly.py\na, b, c: 1 2 3\nd, e: 256 7\nargs: (4, 5, 6)\nkwargs: {'f': 9, 'g': 10} \n```", "```py\ndef func_name(positional_only_parameters, /,\n    positional_or_keyword_parameters, *,\n    keyword_only_parameters): \n```", "```py\ndef func_name(p1, p2, /, p_or_kw, *, kw):\ndef func_name(p1, p2=None, /, p_or_kw=None, *, kw):\ndef func_name(p1, p2=None, /, *, kw):\ndef func_name(p1, p2=None, /):\ndef func_name(p1, p2, /, p_or_kw):\ndef func_name(p1, p2, /): \n```", "```py\ndef func_name(p1, p2=None, /, p_or_kw, *, kw):\ndef func_name(p1=None, p2, /, p_or_kw=None, *, kw):\ndef func_name(p1=None, p2, /): \n```", "```py\n# parameters.defaults.mutable.py\ndef func(a=[], b={}):\n    print(a)\n    print(b)\n    print(\"#\" * 12)\n    a.append(len(a))  # this will affect a's default value\n    b[len(a)] = len(a)  # and this will affect b's one\nfunc()\nfunc()\nfunc() \n```", "```py\n$ python parameters.defaults.mutable.py\n[]\n{}\n############\n[0]\n{1: 1}\n############\n[0, 1]\n{1: 1, 2: 2}\n############ \n```", "```py\n# parameters.defaults.mutable.intermediate.call.py\nfunc()\nfunc(a=[1, 2, 3], b={\"B\": 1})\nfunc() \n```", "```py\n$ python parameters.defaults.mutable.intermediate.call.py\n[]\n{}\n############\n[1, 2, 3]\n{'B': 1}\n############\n[0]\n{1: 1}\n############ \n```", "```py\n# parameters.defaults.mutable.no.trap.py\ndef func(a=None):\n    if a is None:\n        a = []\n    # do whatever you want with `a` ... \n```", "```py\n# return.none.py\ndef func():\n    pass\nfunc()  # the return of this call won't be collected. It's lost.\na = func()  # the return of this one instead is collected into `a`\nprint(a)  # prints: None \n```", "```py\n# return.single.value.py\ndef factorial(n):\n    if n in (0, 1):\n        return 1\n    result = n\n    for k in range(2, n):\n        result *= k\n    return result\nf5 = factorial(5)  # f5 = 120 \n```", "```py\nif n == 0 or n == 1:\n    ... \n```", "```py\n# return.single.value.2.py\nfrom functools import reduce\nfrom operator import mul\ndef factorial(n):\n    return reduce(mul, range(1, n + 1), 1)\nf5 = factorial(5)  # f5 = 120 \n```", "```py\n# return.multiple.py\ndef moddiv(a, b):\n    return a // b, a % b\nprint(moddiv(20, 7))  # prints (2, 6) \n```", "```py\n>>> numbers = [4, 1, 7, 5]\n>>> sorted(numbers)  # won't sort the original `numbers` list\n[1, 4, 5, 7]\n>>> numbers  # let's verify\n[4, 1, 7, 5]  # good, untouched\n>>> numbers.sort()  # this will act on the list\n>>> numbers\n[1, 4, 5, 7] \n```", "```py\n1 * 2 * ... * (N-1) * N \n```", "```py\n5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5 \n```", "```py\n# recursive.factorial.py\ndef factorial(n):\n    if n in (0, 1):  # base case\n        return 1\n    return factorial(n - 1) * n  # recursive case \n```", "```py\n# filter.regular.py\ndef is_multiple_of_five(n):\n    return not n % 5\ndef get_multiples_of_five(n):\n    return list(filter(is_multiple_of_five, range(n))) \n```", "```py\n# filter.lambda.py\ndef get_multiples_of_five(n):\n    return list(filter(lambda k: not k % 5, range(n))) \n```", "```py\nfunc_name = lambda [parameter_list]: expression \n```", "```py\ndef func_name([parameter_list]):\n    return expression \n```", "```py\n# lambda.explained.py\n# example 1: adder\ndef adder(a, b):\n    return a + b\n# is equivalent to:\nadder_lambda = lambda a, b: a + b\n# example 2: to uppercase\ndef to_upper(s):\n    return s.upper()\n# is equivalent to:\nto_upper_lambda = lambda s: s.upper() \n```", "```py\n# func.attributes.py\ndef multiplication(a, b=1):\n    \"\"\"Return a multiplied by b.\"\"\"\n    return a * b\nif __name__ == \"__main__\":\n    special_attributes = [\n        \"__doc__\",\n        \"__name__\",\n        \"__qualname__\",\n        \"__module__\",\n        \"__defaults__\",\n        \"__code__\",\n        \"__globals__\",\n        \"__dict__\",\n        \"__closure__\",\n        \"__annotations__\",\n        \"__kwdefaults__\",\n    ]\n    for attribute in special_attributes:\n        print(attribute, \"->\", getattr(multiplication, attribute)) \n```", "```py\n$ python func.attributes.py\n__doc__ -> Return a multiplied by b.\n__name__ -> multiplication\n__qualname__ -> multiplication\n__module__ -> __main__\n__defaults__ -> (1,)\n__code__ -> <code object multiplication at 0x102ce1550,\n             file \"func.attributes.py\", line 2>\n__globals__ -> {... omitted ...}\n__dict__ -> {}\n__closure__ -> None\n__annotations__ -> {}\n__kwdefaults__ -> None \n```", "```py\nif __name__ == \"__main__\": \n```", "```py\n# docstrings.py\ndef square(n):\n    \"\"\"Return the square of a number n.\"\"\"\n    return n**2\ndef get_username(userid):\n    \"\"\"Return the username of a user given their id.\"\"\"\n    return db.get(user_id=userid).username \n```", "```py\ndef connect(host, port, user, password):\n    \"\"\"Connect to a database.\n    Connect to a PostgreSQL database directly, using the given\n    parameters.\n    :param host: The host IP.\n    :param port: The desired port.\n    :param user: The connection username.\n    :param password: The connection password.\n    :return: The connection object.\n    \"\"\"\n    # body of the function here...\n    return connection \n```", "```py\nfrom mymodule import myfunc as better_named_func \n```", "```py\n# imports.py\nfrom datetime import datetime, timezone  # two imports, same line\nfrom unittest.mock import patch  # single import\nimport pytest  # third party library\nfrom core.models import (  # multiline import\n    Exam,\n    Exercise,\n    Solution,\n) \n```", "```py\n├── func_from.py\n├── func_import.py\n├── util\n│   ├── __init__.py\n│   └── funcdef.py \n```", "```py\n# util/funcdef.py\ndef square(n):\n    return n**2\ndef cube(n):\n    return n**3\n# func_import.py\nimport util.funcdef\nprint(util.funcdef.square(10))\nprint(util.funcdef.cube(10))\n# func_from.py\nfrom util.funcdef import square, cube\nprint(square(10))\nprint(cube(10)) \n```", "```py\nfrom .mymodule import myfunc \n```", "```py\n# primes.py\nfrom math import sqrt, ceil\ndef get_primes(n):\n    \"\"\"Calculate a list of primes up to n (included).\"\"\"\n    primelist = []\n    for candidate in range(2, n + 1):\n        is_prime = True\n        root = ceil(sqrt(candidate))  # division limit\n        for prime in primelist:  # we try only the primes\n            if prime > root:  # no need to check any further\n                break\n            if candidate % prime == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primelist.append(candidate)\n    return primelist \n```"]