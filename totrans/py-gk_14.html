<html><head></head><body>
		<div id="_idContainer083">
			<h1 id="_idParaDest-226"><em class="italic"><a id="_idTextAnchor264"/>Chapter 10</em>: Using Python for Web Development and REST API</h1>
			<p>A web application is a type of application that is hosted and run by a <strong class="bold">web server</strong> within an intranet or on the internet and accessed through a web browser on a client device. The use of web browsers as a client interface makes it convenient for users to access the applications from anywhere without installing any additional software on a local machine. This ease of access has contributed to the success and popularity of web applications for more than two decades. The use of web applications varies, from delivering static and dynamic content such as Wikipedia and newspapers, e-commerce, online games, social networking, training, multimedia content, surveys, and blogs, to complex <strong class="bold">Enterprise Resource Planning</strong> (<strong class="bold">ERP</strong>) applications. </p>
			<p>Web applications are multi-tier by nature, typically three-tier applications. The three tiers are a UI, business logic, and database access. Therefore, developing web applications involves interacting with web servers for a UI, an <strong class="bold">application server</strong> for business logic, and database systems for persisting data. In the mobile applications era, the UI may be a mobile app that requires access to the business logic tier via a REST API. The availability of a REST API or any sort of web services interface has become a fundamental requirement for web applications. This chapter discusses how to use Python for building multi-tier web applications. There are several frameworks available in Python to develop web applications, but we selected <strong class="bold">Flask</strong> for our discussion in this chapter because of being feature-rich yet lightweight. Web applications are also termed <em class="italic">web apps</em> to differentiate them from mobile apps that are targeted at small devices. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Learning requirements for web development</li>
				<li>Introducing the Flask framework</li>
				<li>Interacting with databases using Python</li>
				<li>Building a REST API using Python</li>
				<li>Case study: Building a web application using the REST API</li>
			</ul>
			<p>By the end of this chapter, you will be able to use the Flask framework to develop web applications, interact with databases, and build a REST API or web services.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor265"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>Python Flask library 2.x with its extensions installed on top of Python 3.7 or later.</li>
			</ul>
			<p>Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10</a>.</p>
			<p>We will start our discussion with key requirements of developing web applications and a REST API.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor266"/>Learning requirements for web development</h1>
			<p>Developing a web application includes building UI, routing user requests or user actions <a id="_idIndexMarker1091"/>to application endpoints, translating the user input data, writing business logic for user requests, interacting with the data layer to read or write data, and serving the results back to users. All these development components may require different platforms and sometimes even use different programming languages for implementation. In this section, we will understand the components and tools required for web development, starting with web application frameworks or web frameworks.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor267"/>Web frameworks</h2>
			<p>Developing <a id="_idIndexMarker1092"/>web applications from scratch is <a id="_idIndexMarker1093"/>time-consuming and tedious. To make it convenient for web developers, web application frameworks were introduced in the very early days of web development. Web frameworks provide a set of libraries, directory structures, reusable components, and deployment tools. Web frameworks typically follow an architecture that enables developers to build complex applications in less time and in an optimized way. </p>
			<p>There are several web frameworks available for Python: <strong class="bold">Flask</strong> and <strong class="bold">Django</strong> are the most popular. Both frameworks <a id="_idIndexMarker1094"/>are free and open source. Flask is a lightweight framework and comes with standard functionalities that are required to build a web application, but it also allows additional libraries or extensions to use as they are needed. On the other hand, Django is a full stack framework that comes with all features out of the box without requiring additional libraries. Both approaches have merits and demerits, but in the end, we can develop any web application with any of these frameworks.</p>
			<p>Flask is <a id="_idIndexMarker1095"/>considered a better choice if you want to have full control of your application with a choice of using external libraries as they fit. Flask is also a good fit when project <a id="_idIndexMarker1096"/>requirements are changing very frequently. Django is suitable if you want to have all tools and libraries available to you out of the box and you <a id="_idIndexMarker1097"/>want to focus only on implementing the business logic. Django is a good choice for large-scale projects, but can be overkill for simple projects. The learning curve for Django is steep and requires prior experience in web development. If you are staring at web development with Python for the first time, Flask is the way to go. Once you learn Flask, it is easy to adopt the Django framework for the next level of web projects. </p>
			<p>When building <a id="_idIndexMarker1098"/>web applications or any UI applications, we often come across the term <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) design pattern. This is an architectural design pattern that divides an application into three layers:</p>
			<ul>
				<li><strong class="bold">Model</strong>: The model layer <a id="_idIndexMarker1099"/>represents the data that is typically stored in a database.</li>
				<li><strong class="bold">View</strong>: This layer <a id="_idIndexMarker1100"/>is the UI with which users interact.</li>
				<li><strong class="bold">Controller</strong>: The controller layer <a id="_idIndexMarker1101"/>is designed to provide a logic to handle user interactions with the application through UI. For example, a user may want to create a new object or update an existing object. The logic of which UI (view) to present to the user for the create or update request with or without a model (data) is all implemented in the controller layer.</li>
			</ul>
			<p>Flask does not provide direct support for MVC design patterns, but it can be implemented <a id="_idIndexMarker1102"/>through programming. Django provides close enough <a id="_idIndexMarker1103"/>implementation for MVC, but not fully. The controller in the Django framework is managed by Django itself and is not available for writing our own code in it. Django and many other web frameworks for Python follow the <strong class="bold">Model View Template</strong> (<strong class="bold">MVT</strong>) design pattern, which is like MVC except the <a id="_idIndexMarker1104"/>template layer. The template layer in the MVT provides specially formatted templates to produce the expected UI with the capability to insert dynamic contents within HTML. </p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor268"/>User interface</h2>
			<p>A <strong class="bold">UI</strong> is the <a id="_idIndexMarker1105"/>presentation layer of the application, and sometimes it is included as part of the web frameworks. But we are discussing it <a id="_idIndexMarker1106"/>separately here to highlight key technologies and choices available for this layer. First and foremost, the user is <a id="_idIndexMarker1107"/>interacting through a browser in <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) and <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>). We can build <a id="_idIndexMarker1108"/>our interfaces by writing HTML and CSS directly, but it is tedious and not feasible for delivering dynamic content in a timely manner. There are a few technologies available to make our lives easier when building UI: </p>
			<ul>
				<li><strong class="bold">UI framework</strong>: These are mainly HTML and CSS libraries to provide different classes (styles) for building UI. We still need to write or generate core HTML <a id="_idIndexMarker1109"/>parts of UI, but without worrying about how to beautify our web pages. A popular example <a id="_idIndexMarker1110"/>of a UI framework is <strong class="bold">bootstrap</strong>, which is built on top of CSS. It was introduced by Twitter for internal use, but was made open source <a id="_idIndexMarker1111"/>later for anyone to use. <strong class="bold">ReactJS</strong> is another popular option, but this is more a library than a framework and was introduced by Facebook.</li>
				<li><strong class="bold">Template engine</strong>: A template engine is another popular mechanism to produce web content dynamically. A template is more like a definition of the desired <a id="_idIndexMarker1112"/>output that holds static data <a id="_idIndexMarker1113"/>as well as placeholders for dynamic contents. The placeholders are tokenized strings that are replaced by values at runtime. The output can be any format, such as HTML, XML, JSON, or PDF. <strong class="bold">Jinja2</strong> is one <a id="_idIndexMarker1114"/>of the most popular templating engines used with Python, and is also included with the Flask framework. Django comes with its own templating engine.</li>
				<li><strong class="bold">Client-side scripting</strong>: A client-side <a id="_idIndexMarker1115"/>script is a program that is <a id="_idIndexMarker1116"/>downloaded from the web server and is executed by the client web browser. JavaScript is the most popular client-side scripting language. There are many JavaScript libraries available to make web development easier.</li>
			</ul>
			<p>We can use more than one technology to develop web interfaces. In a typical web project, all three are used in different capacities.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor269"/>Web server/application server</h2>
			<p>A web server is <a id="_idIndexMarker1117"/>software that listens to client requests through HTTP and delivers <a id="_idIndexMarker1118"/>content (such as web pages, scripts, images) as per the request type. The web server's fundamental job is to serve only static resources and is not capable of code execution.</p>
			<p>The application server <a id="_idIndexMarker1119"/>is more specific to a programming language. The <a id="_idIndexMarker1120"/>main job of an application server is to provide access to the implementation of a business logic that is written using a programming language such as Python. For many production environments, the web server and application server are bundled as one software for ease of deployment. Flask comes with <a id="_idIndexMarker1121"/>its own built-in web server, named <strong class="bold">Werkzeug</strong>, for the development phase, but this is not recommended for use in <a id="_idIndexMarker1122"/>production. For <a id="_idIndexMarker1123"/>production, we must use other options <a id="_idIndexMarker1124"/>such as <strong class="bold">Gunicorn</strong>, <strong class="bold">uWSGI</strong>, and <strong class="bold">GCP runtime engines</strong>. </p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor270"/>Database</h2>
			<p>This is not <a id="_idIndexMarker1125"/>a mandatory component, but it is almost <a id="_idIndexMarker1126"/>essential for any interactive web application. Python offers several <a id="_idIndexMarker1127"/>libraries to <a id="_idIndexMarker1128"/>access <a id="_idIndexMarker1129"/>commonly used database <a id="_idIndexMarker1130"/>systems, such as <strong class="bold">MySQL</strong>, <strong class="bold">MariaDB</strong>, <strong class="bold">PostgreSQL</strong>, and <strong class="bold">Oracle</strong>. Python also <a id="_idIndexMarker1131"/>comes equipped with a lightweight database server, <strong class="bold">SQLite</strong>.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor271"/>Security</h2>
			<p>Security is <a id="_idIndexMarker1132"/>fundamental for web applications, mainly because the target audience <a id="_idIndexMarker1133"/>is typically internet users, and data privacy is the utmost requirement in such environments. <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) and <a id="_idIndexMarker1134"/>the more recently introduced <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) are the minimum acceptable security standards to secure the transmission <a id="_idIndexMarker1135"/>of data between clients and the server. The transport-level security requirements are typically handled at the web server or sometimes proxy server level. User-level security is the next fundamental requirement, with minimum username and password requirements. User security is application-level security and developers are mainly responsible for designing and implementing it.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor272"/>API</h2>
			<p>The business <a id="_idIndexMarker1136"/>logic layer in web applications can be consumed by additional clients. For example, a mobile <a id="_idIndexMarker1137"/>app can use the same business logic for a limited or same set of features. For <strong class="bold">Business to Business</strong> (<strong class="bold">B2B</strong>) applications, a remote <a id="_idIndexMarker1138"/>application can submit requests to the business logic layer directly. This is all possible if we expose standard interfaces such as a REST API for our business logic layer. In the current era, accessing the business logic layer through an API is a best practice to make the API ready from day one.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor273"/>Documentation</h2>
			<p>Documentation is <a id="_idIndexMarker1139"/>as important as writing <a id="_idIndexMarker1140"/>programming code. This is especially true for APIs. When we say that we have an API for our application, the first question from API consumers is whether you can share API documentation with us. The best way to have API documentation is to use built-in tools that come or possibly integrate with our web framework. <strong class="bold">Swagger</strong> is a <a id="_idIndexMarker1141"/>popular tool that is used to generate documentation <a id="_idIndexMarker1142"/>automatically from the comments that are added at the time of coding.</p>
			<p>Now that <a id="_idIndexMarker1143"/>we have discussed key requirements of web development, we will deep dive into how to develop a web application using Flask in the next section. </p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor274"/>Introducing the Flask framework</h1>
			<p>Flask is a micro web development framework for Python. The term<em class="italic"> micro </em>indicates that the core of <a id="_idIndexMarker1144"/>Flask is lightweight, but with the flexibility of being extensible. A simple example is interacting with a database system. Django comes with libraries required to interact with the most common databases. On the other hand, Flask allows the use of an extension as per the database type or as per the integration approach to achieve the same goal. Another philosophy of Flask is to use <em class="italic">convention over configuration</em>, which means that if we follow standard conventions of web development, we have to do less configuration. This makes Flask the best choice for beginners to learn web development with Python. We selected Flask for our web development, not only because of its ease-of-use capability, but also because it allows us to introduce different concepts in a stepwise approach. </p>
			<p>In this section, we will learn the following aspects of web applications using Flask:</p>
			<ul>
				<li>Building a basic web application with routing</li>
				<li>Handling requests with different HTTP method types</li>
				<li>Rendering static and dynamic contents using Jinja2</li>
				<li>Extracting arguments from an HTTP request</li>
				<li>Interacting with database systems</li>
				<li>Handling errors and exceptions</li>
			</ul>
			<p>Before we start working with code examples to be used in the next sections, Flask 2.x needs to be installed in our virtual environment. We will start with a basic web application using Flask.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor275"/>Building a basic application with routing</h2>
			<p>We have already used Flask to build a sample application for GCP App Engine deployment <a id="_idIndexMarker1145"/>in the last chapter, <em class="italic">Python Programming for the Cloud</em>. We will refresh our knowledge of using Flask to <a id="_idIndexMarker1146"/>develop a simple web application. We will <a id="_idIndexMarker1147"/>start with a code example to understand how a web application is built and how routing works in it. The complete code example is as follows:</p>
			<p class="source-code">#<strong class="bold">app1.py</strong>: routing in a Flask application</p>
			<p class="source-code">from flask import <strong class="bold">Flask</strong></p>
			<p class="source-code"><strong class="bold">app = Flask(__name__)</strong></p>
			<p class="source-code"><strong class="bold">@app.route('/')</strong></p>
			<p class="source-code">def hello():</p>
			<p class="source-code">    return 'Hello World!'</p>
			<p class="source-code"><strong class="bold">@app.route('/greeting')</strong></p>
			<p class="source-code">def greeting():</p>
			<p class="source-code">    return 'Greetings from Flask web app!'</p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    app.run()</p>
			<p>Let's analyze this code example step by step:</p>
			<ol>
				<li><strong class="bold">Initialization</strong>: A Flask application must create an application instance (<strong class="source-inline">app</strong> in our case) as <a id="_idIndexMarker1148"/>a first step. The web server will pass all requests from clients to this application instance using a protocol known as a <strong class="bold">Web Server Gateway Interface </strong>(<strong class="bold">WSGI</strong>). The application instance is created by using the statement <strong class="source-inline">app = Flask(__name__)</strong>.<p>It is <a id="_idIndexMarker1149"/>important to pass the module name as an argument to the <strong class="source-inline">Flask</strong> constructor. The Flask uses this argument to learn the location of the application, which becomes an input to determine the location of other files such as static resources, templates, and images. Using <strong class="source-inline">__name__</strong> is the convention (over configuration) to pass to the <strong class="source-inline">Flask</strong> constructor, and Flask takes care of the rest.</p></li>
				<li><strong class="bold">Route</strong>: Once a <a id="_idIndexMarker1150"/>request arrives at the Flask <strong class="source-inline">app</strong> instance, now it is the responsibility of the instance to execute a certain piece of code to handle the request. This piece of code, which is typically a Python function, is called <strong class="source-inline">handler</strong>. The good <a id="_idIndexMarker1151"/>news is that each request is typically (not all the time) associated with a single URL, which makes it possible to define a mapping between a URL and a Python function. This URL to Python function mapping is called a route. In our code example, we selected a simple approach to define this mapping by using the <strong class="source-inline">route</strong> decorator. For example, the <strong class="source-inline">/hello</strong> URL is mapped to the <strong class="source-inline">hello</strong> function, and the <strong class="source-inline">/greeting</strong> URL is mapped to the <strong class="source-inline">greeting</strong> function. If we prefer to define all routes in one place, we can use <strong class="source-inline">add_url_rule</strong> with the app instance for all route definitions. </li>
				<li><strong class="bold">Handler function</strong>: The handler function after processing the request has to send a <a id="_idIndexMarker1152"/>response back to the client. A response can be a simple string with or without HTML, or it can be a complex web page that can be static or dynamic based on a template. In our code example, we returned a simple string for illustration purposes.</li>
				<li><strong class="bold">Web server</strong>: Flask <a id="_idIndexMarker1153"/>applications come with a development server that can be started with the <strong class="source-inline">app.run()</strong> method, or by using the <strong class="source-inline">flask run</strong> command in a shell. When we start this web server, it looks for an <strong class="source-inline">app.py</strong> or <strong class="source-inline">wsgi.py</strong> module by default, and it will be loaded automatically with the server if we use the <strong class="source-inline">app.py</strong> name for our module file (again, convention over configuration). But if we are using a different name for our module (it is our case), we must set an environment variable, <strong class="source-inline">FLASK_APP = &lt;module name&gt;</strong>, which will be used by the web server to load the module. <p>If you <a id="_idIndexMarker1154"/>have created a Flask project using an IDE such as <strong class="bold">PyCharm Pro</strong>, the environment variable will be set for you as part of project settings. In case <a id="_idIndexMarker1155"/>you are using a command-line shell, you can set the environment variable using the following command as per your operating system:</p><p class="source-code"><strong class="bold">export FLASK_APP= app1.py.   #for macOS and Linux</strong></p><p class="source-code"><strong class="bold">set FLASK_APP = app1.py.     #for MS windows</strong></p><p>When the server starts, it listens for client requests at the URL <strong class="source-inline">http://localhost:5000/</strong> and it is accessible only on your local machine by default. If we want to start the server using a different hostname and port, we can use the following command (or the equivalent Python statement):</p><p class="source-code"><strong class="bold">Flask run --host &lt;ip_address&gt; --port &lt;port_num&gt;</strong></p></li>
				<li><strong class="bold">Web client</strong>: We can <a id="_idIndexMarker1156"/>test our application through a browser by entering the URL in the address bar or by using a <strong class="bold">curl</strong> utility for simple HTTP requests. For our example, we can test our application using the following <strong class="source-inline">curl</strong> commands:<p class="source-code"><strong class="bold">curl -X GET http://localhost:5000/</strong></p><p class="source-code"><strong class="bold">curl -X GET http://localhost:5000/greeting</strong></p></li>
			</ol>
			<p>Now that we have finished our discussion on the fundamentals of a Flask application, we will start exploring topics related to consuming the request and sending a dynamic response back to the clients. </p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor276"/>Handling requests with different HTTP method types</h2>
			<p>HTTP is based on a <strong class="bold">request-response</strong> model between a client and a server. A client (for example, a web browser) can <a id="_idIndexMarker1157"/>send different verbs or, more <a id="_idIndexMarker1158"/>appropriately, call methods to identify the type of request for the server. These methods include <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">HEAD</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">OPTIONS</strong>. <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> are the most frequently used HTTP methods, and so we will cover only these to illustrate our web development concepts. </p>
			<p>But before discussing <a id="_idIndexMarker1159"/>these two methods, it is also important to <a id="_idIndexMarker1160"/>understand the two key components of HTTP, which are <strong class="bold">HTTP request</strong> and <strong class="bold">HTTP response</strong>. An HTTP request is divided into three parts:</p>
			<ul>
				<li><strong class="bold">Request line</strong>: This line <a id="_idIndexMarker1161"/>includes the HTTP method to be used, the URI of the request, and the HTTP protocol (version) to be used:<p class="source-code">GET /home HTTP/1.1</p></li>
				<li><strong class="bold">Header fields</strong>: Headers <a id="_idIndexMarker1162"/>are metadata that provide the information pertaining to the request. Each header entry is provided as a key-value pair, separated by colons (<strong class="source-inline">:</strong>)</li>
				<li><strong class="bold">Body</strong> (optional): This is a <a id="_idIndexMarker1163"/>placeholder where we can add additional data. For a web application, we can send form data with <strong class="source-inline">POST</strong> requests inside the body of the HTTP request. For a REST API, we can send data for <strong class="source-inline">PUT</strong> or <strong class="source-inline">POST</strong> requests within the body. </li>
			</ul>
			<p>When we send an HTTP request to a web server, we will get an HTTP response as a result. The HTTP response will have similar parts to the HTTP request: </p>
			<ul>
				<li><strong class="bold">Status line</strong>: This line <a id="_idIndexMarker1164"/>indicates whether the response is successful or comes with an error. An error code is highlighted in the status line: <p class="source-code">HTTP/1.1 200 OK</p><p>Status code <strong class="source-inline">200</strong> or something in the range of <strong class="source-inline">200-299</strong> indicates success. Error codes are in the range of <strong class="source-inline">400-499</strong> for client-side errors, and in the range of <strong class="source-inline">500-599</strong> for server-side errors. </p></li>
				<li><strong class="bold">Header</strong>: Header fields <a id="_idIndexMarker1165"/>are similar to the HTTP request header fields. </li>
				<li><strong class="bold">Body</strong> (optional): Although <a id="_idIndexMarker1166"/>optional, this is the key part of an HTTP response. This can include HTML pages for web applications or data in any other format. </li>
			</ul>
			<p><strong class="source-inline">GET</strong> is used to send a request for a certain resource identified in the URL with the option to add a <strong class="bold">query string</strong> as part of the URL. The <em class="italic">?</em> is added in the URL to keep the query string <a id="_idIndexMarker1167"/>separate from the base URL. For example, if we search for the word <em class="italic">Python</em> on Google, we will see a URL as follows in the browser:</p>
			<p><a href="https://www.google.com/search?q=Python">https://www.google.com/search?q=Python</a></p>
			<p>In this URL, <strong class="source-inline">q=Python</strong> is a query string. A query string is used to carry data in the form of key-value pairs. This approach of accessing resources is popular because of its simplicity but does have its limitations. The data in a query string is visible in the URL, which <a id="_idIndexMarker1168"/>means we cannot send sensitive information such as a username and password as a query string. The length <a id="_idIndexMarker1169"/>of the query string cannot be more than 255 characters. However, the <strong class="source-inline">GET</strong> method is in use for searching websites such as Google and YAHOO for reasons of simplicity. In the case of the <strong class="source-inline">POST</strong> method, the data is sent via the HTTP request body, which eliminates the limitations of the <strong class="source-inline">GET</strong> method. The data does not appear as part of the URL and there is no limit in terms of the data that we can send to the HTTP server. There is also no limit in terms of the data types supported using the <strong class="source-inline">POST</strong> method.</p>
			<p>Flask provides a few convenient ways to identify whether a request is sent using <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> or is using any other method. In our next code example, we illustrate two approaches; the first approach uses the <strong class="source-inline">route</strong> decorator, with an exact list of the method types expected, and the second approach is using a decorator specific for the HTTP method type, such as the <strong class="source-inline">get</strong> decorator and the <strong class="source-inline">post</strong> decorator. The use of both approaches is illustrated in the next code example, followed by a detailed analysis:</p>
			<p class="source-code">#<strong class="bold">app2.py</strong>: map request with method type</p>
			<p class="source-code">from flask import Flask, <strong class="bold">request</strong></p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code"><strong class="bold">@app.route('/submit', methods=['GET'])</strong></p>
			<p class="source-code">def req_with_get():</p>
			<p class="source-code">    return "Received a get request"</p>
			<p class="source-code"><strong class="bold">@app.post('/submit')</strong></p>
			<p class="source-code">def req_with_post():</p>
			<p class="source-code">    return "Received a post request"</p>
			<p class="source-code"><strong class="bold">@app.route('/submit2', methods = ['GET', 'POST'])</strong></p>
			<p class="source-code">def both_get_post():</p>
			<p class="source-code">    if <strong class="bold">request.method == 'POST'</strong>:</p>
			<p class="source-code">        return "Received a post request 2"</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return "Received a get request 2"</p>
			<p>Let's <a id="_idIndexMarker1170"/>discuss the three route <a id="_idIndexMarker1171"/>definitions and corresponding functions in our sample code one by one:</p>
			<ul>
				<li>In the first route definition (<strong class="source-inline">@app.route('/submit', methods=['GET']))</strong>, we used the <strong class="source-inline">route</strong> decorator for mapping a URL, with requests of the <strong class="source-inline">GET</strong> type to a Python function. With this decorator setting, our Python function will handle requests with the <strong class="source-inline">GET</strong> method just for the <strong class="source-inline">/submit</strong> URL.</li>
				<li>In the second route definition (<strong class="source-inline">@app.post('/submit'))</strong>, we used the <strong class="source-inline">post</strong> decorator and only specify the request URL with it. This is a simplified version of mapping a request with the <strong class="source-inline">POST</strong> method to a Python function. This new setting is equivalent to the first route definition, but with the <strong class="source-inline">POST</strong> method type in a simplified form. We can achieve the same for a <strong class="source-inline">GET</strong> method by using the <strong class="source-inline">get</strong> decorator.</li>
				<li>In the third route definition (<strong class="source-inline">@app.route('/submit2', methods = ['GET', 'POST'])</strong>), we mapped a single URL with requests using both the <strong class="source-inline">POST</strong> and <strong class="source-inline">GET</strong> methods to a single Python function. This is a convenient approach when we are expecting to handle any request method by using a single handler (Python function). Inside the Python function, we used the <strong class="source-inline">method</strong> attribute of the request object to identify whether the request is of the <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> type. Note that the request object is made available to our Flask app by the web server once we import the <strong class="source-inline">request</strong> package into our program. This approach gives flexibility for clients to submit requests using any one of the two methods using the same URL and, as a developer, we mapped them to a single Python function.</li>
			</ul>
			<p>We can <a id="_idIndexMarker1172"/>test this code <a id="_idIndexMarker1173"/>example more conveniently through the <strong class="source-inline">curl</strong> utility because it will not be easy to submit a <strong class="source-inline">POST</strong> request without defining an HTML form. The following <strong class="source-inline">curl</strong> commands can be used to send HTTP requests to our web application:</p>
			<p class="source-code">curl -X GET http://localhost:5000/submit</p>
			<p class="source-code">curl -X POST http://localhost:5000/submit</p>
			<p class="source-code">curl -X GET http://localhost:5000/submit2</p>
			<p class="source-code">curl -X POST http://localhost:5000/submit2</p>
			<p>Next, we will discuss how to render a response from static pages and templates. </p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor277"/>Rendering static and dynamic contents</h2>
			<p>The static contents <a id="_idIndexMarker1174"/>are important for a web <a id="_idIndexMarker1175"/>application as they include CSS and JavaScript files. The static files can be served directly by the web server. Flask can also make this happen if we create a directory called <strong class="source-inline">static</strong> in our project and redirect the client to the static file location. </p>
			<p>Dynamic contents can be created using Python, but it is tedious and requires quite an effort to maintain such a code in Python. The recommended approach is to use a template engine such as <strong class="bold">Jinja2</strong>. Flask comes with a Jinja2 library, so there is no additional library to install, nor do we need to add any additional configuration to set up Jinja2. A sample <a id="_idIndexMarker1176"/>code with two functions, one handling a request for static contents and the other for dynamic contents, is shown next:</p>
			<p class="source-code">#<strong class="bold">app3.py</strong>: rendering static and dynamic contents</p>
			<p class="source-code">from flask import Flask, <strong class="bold">render_template</strong>, <strong class="bold">url_for</strong>, <strong class="bold">redirect</strong></p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code">@app.route('/hello')</p>
			<p class="source-code">def hello():</p>
			<p class="source-code">    hello_url = <strong class="bold">url_for</strong> ('static', filename='app3_s.html')</p>
			<p class="source-code">    return <strong class="bold">redirect</strong>(hello_url)</p>
			<p class="source-code">@app.route('/greeting')</p>
			<p class="source-code">def greeting():</p>
			<p class="source-code">    msg = "Hello from Python"</p>
			<p class="source-code">    return <strong class="bold">render_template</strong>('app3_d.html', <strong class="bold">greeting=msg</strong>)</p>
			<p>For a <a id="_idIndexMarker1177"/>better understanding of this sample <a id="_idIndexMarker1178"/>code, we will highlight the key points:</p>
			<ul>
				<li>We import additional modules from Flask such as <strong class="source-inline">url_for</strong>, <strong class="source-inline">redirect</strong>, and <strong class="source-inline">render_template</strong>. </li>
				<li>For the <strong class="source-inline">/hello</strong> route, we build a URL using the <strong class="source-inline">url_for</strong> function with the <strong class="source-inline">static</strong> directory and the name of the HTML file as arguments. We send the response, which is an instruction to the browser, to redirect the client to the URL of a static file location. The redirect instructions are indicated to the web browser by using a status code in the range of <strong class="source-inline">300-399</strong>, which is automatically set by Flask when we used the <strong class="source-inline">redirect</strong> function.</li>
				<li>For the <strong class="source-inline">/gtreeting</strong> route, we render a Jinja template, <strong class="source-inline">app3_d.html</strong>, using the <strong class="source-inline">render_template</strong> function. We also passed a greeting message string as a value to a variable for the template. The greeting variable will be available to the Jinja template, as shown in the following template excerpt from the <strong class="source-inline">app3_d.html</strong> file:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code"><strong class="bold">{% if greeting %</strong>}</p><p class="source-code">  &lt;h1&gt; <strong class="bold">{{greeting}}</strong>!&lt;/h1&gt;</p><p class="source-code"><strong class="bold">{% endif %}</strong></p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>This is the simplest Jinja template with an <strong class="source-inline">if</strong> statement enclosed by <strong class="source-inline">&lt;% %&gt;</strong>, and the Python variable is included by using the two curly brackets <strong class="source-inline">{{}}</strong> format. We will not <a id="_idIndexMarker1179"/>go into the details <a id="_idIndexMarker1180"/>regarding Jinja2 templates, but we highly recommended that you get familiar with Jinja2 templates through their online documentation (https://jinja.palletsprojects.com/). </p></li>
			</ul>
			<p>This sample web application can be accessed using a web browser and using the <strong class="source-inline">curl</strong> utility. In the next section, we will discuss how to extract parameters from different types of requests.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor278"/>Extracting parameters from an HTTP request</h2>
			<p>Web applications <a id="_idIndexMarker1181"/>are different from websites because they are interactive with users and this is not possible without exchanging data between a client and a server. In this section, we will discuss how to extract data from a request. Depending on the type of HTTP method used, we will adopt a different approach. We will cover the following three types of requests as follows:</p>
			<ul>
				<li>Parameters as part of the request URL</li>
				<li>Parameters as query string with a <strong class="source-inline">GET</strong> request</li>
				<li>Parameters as HTML form data with a <strong class="source-inline">POST</strong> request</li>
			</ul>
			<p>A sample <a id="_idIndexMarker1182"/>code with three different routes to cover the three aforementioned request types is as follows. We are rendering a Jinja template (<strong class="source-inline">app4.html</strong>), which is the same as we used for the <strong class="source-inline">app3_d.html</strong> file, except the variable name is <strong class="source-inline">name</strong> instead of <strong class="source-inline">greeting</strong>:</p>
			<p class="source-code">#<strong class="bold">app4.py</strong>: extracting parameters from different requests</p>
			<p class="source-code">from flask import Flask, request, render_template</p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code">@app.route('/hello')</p>
			<p class="source-code">@app.route('<strong class="bold">/hello/&lt;fname&gt; &lt;lname&gt;'</strong>)</p>
			<p class="source-code">def hello_user(fname=None, lastname=None):</p>
			<p class="source-code">    return render_template('app4.html', <strong class="bold">name=f"{fname}</strong><strong class="bold">{lname}"</strong>)</p>
			<p class="source-code">@<strong class="bold">app.get</strong>('/submit')</p>
			<p class="source-code">def process_get_request_data():</p>
			<p class="source-code">    fname = <strong class="bold">request.args[</strong>'fname'] </p>
			<p class="source-code">    lname = <strong class="bold">request.args.get</strong>('lname', '')</p>
			<p class="source-code">    return render_template('app4.html', <strong class="bold">name=f"{fname}{lname}</strong>")</p>
			<p class="source-code">@<strong class="bold">app.post</strong>('/submit')</p>
			<p class="source-code">def process_post_request_data():</p>
			<p class="source-code">    fname = <strong class="bold">request.form</strong>['fname']</p>
			<p class="source-code">    lname = <strong class="bold">request.form.get</strong>('lname','']</p>
			<p class="source-code">    return render_template('app4.html', <strong class="bold">name=f"{fname}{lname}</strong>")</p>
			<p>Next, we will discuss the parameter extraction approach for each case: </p>
			<ul>
				<li>For the first <a id="_idIndexMarker1183"/>set of routes (<strong class="source-inline">app.route</strong>), we defined a route in a way that any text after <strong class="source-inline">/hello/</strong> is considered parameters with the request. We can set zero or one or two parameters, and our Python function is able to handle any combination and returns the name (which can be empty) to the template as a response. This approach is good for simple cases of parameter passing to the server program. This is a popular choice in REST API development to access a single resource instance.</li>
				<li>For the <a id="_idIndexMarker1184"/>second route (<strong class="source-inline">app.get</strong>), we are extracting query string parameters from the <strong class="source-inline">args</strong> dictionary object. We can fetch the parameter value either by using its name as a dictionary key or by using the <strong class="source-inline">GET</strong> method with the second argument as a default value. We used an empty string as a default value with the <strong class="source-inline">GET</strong> method. We showed both options, but we recommend using the <strong class="source-inline">GET</strong> method if you want to set a default value in case no parameter exists in the request.</li>
				<li>For the <a id="_idIndexMarker1185"/>third route (<strong class="source-inline">app.post</strong>), parameters come as form data as part of the body of the HTTP request and we will be using form dictionary object to extract these parameters. Again, we used the parameter name as a dictionary key and also used the <strong class="source-inline">GET</strong> method for illustration purposes. </li>
				<li>To test these scenarios, we recommend using the <strong class="source-inline">curl</strong> utility, especially for <strong class="source-inline">POST</strong> requests. We tested the application with the following commands:</li>
			</ul>
			<p class="source-code">curl -X GET http://localhost:5000/hello</p>
			<p class="source-code">curl -X GET http://localhost:5000/hello/jo%20so</p>
			<p class="source-code">curl -X GET 'http://localhost:5000/submit?fname=jo&amp;lname=so'</p>
			<p class="source-code">curl -d "fname=jo&amp;lname=so" -X POST http://localhost:5000/submit</p>
			<p>In the next section, we will discuss how to interact with a database in Python.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor279"/>Interacting with database systems</h2>
			<p>A full stack web application requires the persistence of structured data, so knowledge and experience <a id="_idIndexMarker1186"/>of working with a database are prerequisites for web development. Python and Flask can integrate with most SQL or no-SQL database systems. Python itself comes with a lightweight SQLite database with the module name <strong class="source-inline">sqlite3</strong>. We will use SQLite because it does not require setting up a separate database server and works very well for small-scale applications. For production environments, we must use other database systems, such as MySQL or MariaDB, or PostgreSQL. To access and interact with a database system, we will use one of the Flask extensions, <strong class="source-inline">Flask-SQLAlchemy</strong>. The <strong class="source-inline">Flask-SQLAlchemy</strong> extension is <a id="_idIndexMarker1187"/>based on the <strong class="source-inline">SQLAlchemy</strong> library of Python and makes the library available to our web application. The <strong class="source-inline">SQLAlchemy</strong> library provides an <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>), which means it maps our database tables to Python objects. The use of an ORM library not only expedites the development cycle, but also provides the flexibility to switch the underlying database system without changing our code. Therefore, we will recommend using <strong class="source-inline">SQLAlchemy</strong> or a similar library to work with database systems. </p>
			<p>To interact with any database system from our application, we need to create our Flask application instance as usual. The next step is to configure the application instance with the URL for our database location (a file in the case of SQLite3). Once the application instance is created, we will create a <strong class="source-inline">SQLAlchemy</strong> instance by passing it to the application instance. When using a database such as SQLite, we only have to initialize the database the first time. It can be initiated from a Python program, but we will not favor this approach so as to avoid the database reset every time we start our application. It is recommended to initialize the database one time only from a command line using the <strong class="source-inline">SQLAlchemy</strong> instance. We will discuss the exact steps of initializing the database after our code example.</p>
			<p>To illustrate the use of the <strong class="source-inline">SQLAlchemy</strong> library with our web application, we will create a simple application to <em class="italic">add</em>, <em class="italic">list</em>, and <em class="italic">delete</em> student objects from a database table. Here is <a id="_idIndexMarker1188"/>a sample code of the application to initialize the Flask application and the database instance (a <strong class="source-inline">SQLAlchemy</strong> instance) and also to create a <strong class="source-inline">Model</strong> object of the <strong class="source-inline">Student</strong> class:</p>
			<p class="source-code">#<strong class="bold">app5.py (part1)</strong>: interacting with db for create, delete   and list objects</p>
			<p class="source-code">from flask import Flask, request, render_template, redirect</p>
			<p class="source-code">from flask_sqlalchemy import SQLAlchemy</p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code"><strong class="bold">app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///student.db'</strong></p>
			<p class="source-code">app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False</p>
			<p class="source-code"><strong class="bold">db = SQLAlchemy(app)</strong></p>
			<p class="source-code"><strong class="bold">class Student(db.Model)</strong>:</p>
			<p class="source-code">    id = db.Column(db.Integer, primary_key=True)</p>
			<p class="source-code">    name = db.Column(db.String(80), nullable=False)</p>
			<p class="source-code">    grade = db.Column(db.String(20), nullable=True)</p>
			<p class="source-code">   </p>
			<p class="source-code">    def __repr__(self):</p>
			<p class="source-code">        return '&lt;Student %r&gt;' % self.name</p>
			<p>Once we have created the <strong class="source-inline">SQLAlchemy</strong> instance, <strong class="source-inline">db</strong>, we can work with database objects. The beauty of an ORM library such as <strong class="source-inline">SQLAlchemy</strong> is that we can define a database schema, known as a <strong class="bold">model</strong> in ORM terminology, within Python as Python classes. For our <a id="_idIndexMarker1189"/>code example, we created a class, <strong class="source-inline">Student</strong>, which is inherited from a base class, <strong class="source-inline">db.Model</strong>. In this model class, we defined the <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, and <strong class="source-inline">grade</strong> attributes that will correspond to three columns in a database table, <em class="italic">Student</em>, in the <strong class="source-inline">SQLite3</strong> database instance. For each attribute, we defined its data type with the maximum length, whether it has a primary key, and whether it is nullable. These additional attribute definitions are important to configure the database tables in an optimized way. </p>
			<p>In the following code snippet, we will illustrate a Python function, <strong class="source-inline">list_students</strong>, for getting a list <a id="_idIndexMarker1190"/>of student objects from the database. This function is mapped to the <strong class="source-inline">/list</strong> URL of our sample web application and it returns all <strong class="source-inline">Student</strong> objects from the database table by using the <strong class="source-inline">all</strong> method on the <strong class="source-inline">query</strong> instance (an attribute of the <strong class="source-inline">db</strong> instance). Note that the <strong class="source-inline">query</strong> instance and its methods are available from the base class, <strong class="source-inline">db.Model</strong>:</p>
			<p class="source-code">#app5.py (part 2)</p>
			<p class="source-code"><strong class="bold">@app.get('/list')</strong></p>
			<p class="source-code">def list_students():</p>
			<p class="source-code">    student_list = <strong class="bold">Student.query.all</strong>()</p>
			<p class="source-code">    return render_template(<strong class="bold">'app5.html</strong>',         <strong class="bold">students=student_list</strong>)</p>
			<p>In the next code snippet, we will write a function (<strong class="source-inline">add_student</strong>) to add students to the database table. This function is mapped to the <strong class="source-inline">/add</strong> URL and expects the student's name and their grade passed as request parameters using the <strong class="source-inline">GET</strong> method. To add a new object to the database, we will create a new instance of the <strong class="source-inline">Student</strong> class with the requisite attribute values and then use the <strong class="source-inline">db.Session</strong> instance to add to the ORM layer by using the <strong class="source-inline">add</strong> function. The <strong class="source-inline">add</strong> function will not add the instance to the database by itself. We will use the <strong class="source-inline">commit</strong> method to push it to the database table. Once a new student is added to our database table, we redirect control to the <strong class="source-inline">/list</strong> URL. The reason we used a redirect to this URL is that we want to return the latest list of students after adding a new one and to reuse the <strong class="source-inline">list_students</strong> function, which we already implemented. The complete code for the <strong class="source-inline">add_student</strong> function is as follows:</p>
			<p class="source-code">#app5.py(part 3)</p>
			<p class="source-code"><strong class="bold">@app.get('/add')</strong></p>
			<p class="source-code">def add_student():</p>
			<p class="source-code">    fname = request.args['fname']</p>
			<p class="source-code">    lname = request.args.get('lname', '')</p>
			<p class="source-code">    grade = request.args.get('grade','')</p>
			<p class="source-code">    student = <strong class="bold">Student(name=f"{fname} {lname}", grade=grade)</strong></p>
			<p class="source-code">    db.session.<strong class="bold">add</strong>(student)</p>
			<p class="source-code">    db.session.<strong class="bold">commit</strong>()</p>
			<p class="source-code">    return <strong class="bold">redirect("/list")</strong></p>
			<p>In the last part of this code example, we will write a Python function (<strong class="source-inline">delete_student</strong>) to delete <a id="_idIndexMarker1191"/>a student from the database table. This function is mapped to the <strong class="source-inline">/delete&lt;int:id&gt;</strong> URL. Note that we are expecting the client to send the student ID (which we sent with a list of students using the <strong class="source-inline">list</strong> request). To delete a student, first, we query for the exact student instance by using the student ID. This is achieved by using the <strong class="source-inline">filter_by</strong> method on the <strong class="source-inline">query</strong> instance. Once we have the exact <strong class="source-inline">Student</strong> instance, we use the <strong class="source-inline">delete</strong> method of the <strong class="source-inline">db.Session</strong> instance and then commit the changes. As with the <strong class="source-inline">add_student</strong> function, we redirected the client to the <strong class="source-inline">/list</strong> URL to return an up-to-date list of students to our Jinja template:</p>
			<p class="source-code">#app5.py (part 4)</p>
			<p class="source-code"><strong class="bold">@app.get('/delete/&lt;int:id&gt;')</strong></p>
			<p class="source-code">def del_student(id):</p>
			<p class="source-code">    todelete = Student.query.<strong class="bold">filter_by(id=id).first()</strong></p>
			<p class="source-code">    db.session.<strong class="bold">delete</strong>(todelete)</p>
			<p class="source-code">    db.session.<strong class="bold">commit</strong>()</p>
			<p class="source-code">    return <strong class="bold">redirect("/list")</strong></p>
			<p>To show a list of students in a browser, we created a simple Jinja template (<strong class="source-inline">app5.html</strong>). The <strong class="source-inline">app5.html</strong> template file will provide a list of students in a table format. It is important to <a id="_idIndexMarker1192"/>note that we use a Jinja <strong class="source-inline">for</strong> loop to build the HTML table rows dynamically, as shown in the following Jinja template:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;body&gt;</p>
			<p class="source-code">&lt;h2&gt;Students&lt;/h2&gt;</p>
			<p class="source-code">    <strong class="bold">{% if students|length &gt; 0 %}</strong></p>
			<p class="source-code">        &lt;table&gt;</p>
			<p class="source-code">            &lt;thead&gt;</p>
			<p class="source-code">              &lt;tr&gt;</p>
			<p class="source-code">                &lt;th scope="col"&gt;SNo&lt;/th&gt;</p>
			<p class="source-code">                &lt;th scope="col"&gt;name&lt;/th&gt;</p>
			<p class="source-code">                &lt;th scope="col"&gt;grade&lt;/th&gt;</p>
			<p class="source-code">               &lt;/tr&gt;</p>
			<p class="source-code">            &lt;/thead&gt;</p>
			<p class="source-code">            &lt;tbody&gt;</p>
			<p class="source-code">              <strong class="bold">{% for student in students %}</strong></p>
			<p class="source-code">                &lt;tr&gt;</p>
			<p class="source-code">                    &lt;th scope="row"&gt;{{student.id}}&lt;/th&gt;</p>
			<p class="source-code">                    &lt;td&gt;{{student.name}}&lt;/td&gt;</p>
			<p class="source-code">                    &lt;td&gt;{{student.grade}}&lt;/td&gt;</p>
			<p class="source-code">                &lt;/tr&gt;</p>
			<p class="source-code">              <strong class="bold">{% endfor %}</strong></p>
			<p class="source-code">            &lt;/tbody&gt;</p>
			<p class="source-code">        &lt;/table&gt;</p>
			<p class="source-code">    <strong class="bold">{% endif %}</strong></p>
			<p class="source-code">&lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Before starting this application, we should initialize the database schema as a one-time step. This can be done by using a Python program, but we have to make sure the code is executed <a id="_idIndexMarker1193"/>only once or only when the database is not already initialized. A recommended approach is to do this step manually using the Python shell. In the Python shell, we can import the <strong class="source-inline">db</strong> instance from our application module and then use the <strong class="source-inline">db.create_all</strong> method to initialize the database as per the model classes defined in our program. Here are the sample commands to be used for our application for database initialization:</p>
			<p class="source-code">&gt;&gt;&gt; from app5 import db</p>
			<p class="source-code">&gt;&gt;&gt; db.create_all()</p>
			<p>These commands will create a <strong class="source-inline">student.db</strong> file in the same directory where we have our program. To reset the database, we can either delete the <strong class="source-inline">student.db</strong> file and rerun the initialization commands, or we can use the <strong class="source-inline">db.drop_all</strong> method in the Python shell. </p>
			<p>We can test the application using the <strong class="source-inline">curl</strong> utility or through a browser using the following URLs:</p>
			<ul>
				<li><strong class="source-inline">http://localhost:5000/list</strong></li>
				<li><strong class="source-inline">http://localhost:5000/add?fname=John&amp;Lee=asif&amp;grade=9</strong></li>
				<li><strong class="source-inline">http://localhost:5000/delete/&lt;id&gt;</strong></li>
			</ul>
			<p>Next, we will discuss how to handle errors in a Flask-based web application. </p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor280"/>Handling errors and exceptions in web applications</h2>
			<p>In all <a id="_idIndexMarker1194"/>our code examples, we did <a id="_idIndexMarker1195"/>not pay attention to how to deal with situations when a user enters an incorrect URL in their browser or sends a wrong set of arguments to our application. This was not a design intention, but the aim was to focus on the key components of web applications first. The beauty of web frameworks is that they typically support error handling by default. If any error occurs, an appropriate status code is returned automatically. The error codes are well defined <a id="_idIndexMarker1196"/>as part of the HTTP protocol. For example, the error codes from <strong class="source-inline">400</strong><em class="italic"> to </em><strong class="source-inline">499</strong> indicate errors with client requests, and the <a id="_idIndexMarker1197"/>error codes from <strong class="source-inline">500</strong><em class="italic"> to </em><strong class="source-inline">599</strong> indicate problems with the server while executing the request. A few commonly observed errors are summarized next: </p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17189_10_Table_1.jpg" alt="Table 10.1 – A commonly observed HTTP errors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1 – A commonly observed HTTP errors</p>
			<p>A complete list of HTTP status codes and errors is available at <a href="https://httpstatuses.com/">https://httpstatuses.com/</a>. </p>
			<p>The Flask framework also comes with an error handling framework. While handling client requests, if our program breaks, a <strong class="source-inline">500 Internal Server Error</strong> is returned by default. If a client requests a URL that is not mapped to any Python function, Flask will return a <strong class="source-inline">404 Not Found</strong> error to the client. These different error types are implemented as subclasses of the <strong class="source-inline">HTTPException</strong> class, which is part of the Flask library. </p>
			<p>If we want to handle these errors or exceptions with a custom behavior or custom message, we can register our handler with the Flask application. Note that an error handler is a function in Flask that is only triggered when an error occurs, and we can associate a <a id="_idIndexMarker1198"/>specific error or <a id="_idIndexMarker1199"/>generic exception with our handlers. We build a sample code to illustrate the concept at a high level. First, we will illustrate a simple web application with two functions ( <strong class="source-inline">hello</strong> and <strong class="source-inline">greeting</strong>) for handling two URLs, as shown in the following sample code:</p>
			<p class="source-code">#<strong class="bold">app6.py</strong>(part 1): error and exception handling</p>
			<p class="source-code">import json</p>
			<p class="source-code">from flask import Flask, render_template, abort</p>
			<p class="source-code">from werkzeug.exceptions import HTTPException</p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code">@app.route('/')</p>
			<p class="source-code">def hello():</p>
			<p class="source-code">    return 'Hello World!'</p>
			<p class="source-code">@app.route('/greeting')</p>
			<p class="source-code">def greeting():</p>
			<p class="source-code">    x = 10/0</p>
			<p class="source-code">    return 'Greetings from Flask web app!'</p>
			<p>To handle the errors, we will register our handler against the app instance using the <strong class="source-inline">errorHandler</strong> decorator. For our sample code (shown next), we registered a <strong class="source-inline">page_not_found</strong> handler against error code <strong class="source-inline">404</strong> for the Flask application. For error code <strong class="source-inline">500</strong>, we registered an <strong class="source-inline">internal_error</strong> function as an error handler. In the end, we registered <strong class="source-inline">generic_handler</strong> for the <strong class="source-inline">HTTPException</strong> class. This generic handler will catch the <a id="_idIndexMarker1200"/>error or exception <a id="_idIndexMarker1201"/>other than <strong class="source-inline">404</strong> and <strong class="source-inline">500</strong>. A sample code with all three handlers is shown next:</p>
			<p class="source-code">#app6.py(part 2)</p>
			<p class="source-code"><strong class="bold">@app.errorhandler(404)</strong></p>
			<p class="source-code">def page_not_found(error):</p>
			<p class="source-code">    return render_template('error404.html'), 404</p>
			<p class="source-code"><strong class="bold">@app.errorhandler(500)</strong></p>
			<p class="source-code">def internal_error(error):</p>
			<p class="source-code">    return render_template('error500.html'), 500</p>
			<p class="source-code"><strong class="bold">@app.errorhandler(HTTPException)</strong></p>
			<p class="source-code">def generic_handler(error):</p>
			<p class="source-code">    error_detail = json.dumps({</p>
			<p class="source-code">        "code": error.code,</p>
			<p class="source-code">        "name": error.name,</p>
			<p class="source-code">        "description": error.description,</p>
			<p class="source-code">    })</p>
			<p class="source-code">    return render_template('error.html', </p>
			<p class="source-code">        err_msg=error_detail), error.code</p>
			<p>For illustration purposes, we also wrote basic Jinja templates with custom messages; <strong class="source-inline">error404.html</strong>, <strong class="source-inline">error500.html</strong>, and <strong class="source-inline">error.html</strong>. The <strong class="source-inline">error404.html</strong> and <strong class="source-inline">error500.html</strong> templates are using the message that is hardcoded in the template. However, the <strong class="source-inline">error.html</strong> template expects the custom message coming from the web server. To test these sample applications, we will request the following through a browser or the <strong class="source-inline">curl</strong> utility: </p>
			<ul>
				<li><strong class="source-inline">GET http://localhost:5000/</strong>: We will expect a normal response in this case.</li>
				<li><strong class="source-inline">GET http://localhost:5000/hello</strong>: We will expect a <strong class="source-inline">404</strong> error as there is no Python function mapped to this URL and the Flask app will render an <strong class="source-inline">error404.html</strong> template.</li>
				<li><strong class="source-inline">GET http://localhost:5000/greeting</strong>: We will expect a <strong class="source-inline">500</strong> error because we try to divide a number by zero to raise the <strong class="source-inline">ZeroDivisionError</strong> error. Since this is a server-side error (<strong class="source-inline">500</strong>), it will trigger our <strong class="source-inline">interna l_error</strong> handler, which renders a generic <strong class="source-inline">error500.html</strong> template.</li>
				<li><strong class="source-inline">POST http://localhost:5000/</strong>: To emulate the role of a generic handler, we will send a request that triggers an error code other than <strong class="source-inline">404</strong> and <strong class="source-inline">500</strong>. This is easily possible by sending a <strong class="source-inline">POST</strong> request for a URL that is expecting a <strong class="source-inline">GET</strong> request and the <a id="_idIndexMarker1202"/>server will raise a <strong class="source-inline">405</strong> error in this case (for an unsupported HTTP method). We have no error <a id="_idIndexMarker1203"/>handler specific for error code 405 in our application, but we have registered a generic handler with <strong class="source-inline">HTTPException</strong>. This generic handler will handle this error and render a generic <strong class="source-inline">error.html</strong> template. </li>
			</ul>
			<p>This concludes our discussion of using the Flask framework for web application development. Next, we will explore building a REST API using Flask extensions. </p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor281"/>Building a REST API</h1>
			<p><strong class="bold">REST</strong>, or <strong class="bold">ReST</strong>, is an <a id="_idIndexMarker1204"/>acronym for <strong class="bold">Representational State Transfer</strong>, which <a id="_idIndexMarker1205"/>is an architecture for client machines to request information about the resources that exist on a remote machine. <strong class="bold">API</strong> stands for <strong class="bold">Application Programming Interface</strong>, which is a set of rules and protocols <a id="_idIndexMarker1206"/>for interacting with application software running on different machines. The interaction of different software entities is not a new requirement. In the last few decades, there have been many technologies proposed and invented to make software-level interactions seamless and convenient. A few <a id="_idIndexMarker1207"/>noticeable technologies include <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>), <strong class="bold">Remote Method Invocation</strong> (<strong class="bold">RMI</strong>), CORBA, and SOAP web services. These technologies have limitations in terms of being tied to a <a id="_idIndexMarker1208"/>certain programming language (for example, RMI) or tied to a proprietary transport mechanism, or using only a certain type of data format. These limitations have been almost entirely eliminated by the RESTful API, which is commonly known as the REST API.</p>
			<p>The flexibility and simplicity of the HTTP protocol make it a favorable candidate to use as a transport mechanism for a REST API. Another advantage of using HTTP is that it allows several data formats for data exchange (such as text, XML, and JSON) and is not constrained to one format, such as how XML is the only format for SOAP-based APIs. The REST API is <a id="_idIndexMarker1209"/>not tied to any one specific language, which makes it a de facto choice for building APIs for web interactions. An architectural view of a REST API call from a REST client to a REST server using HTTP is shown next:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17189_10_01_New.jpg" alt="Figure 10.1 – REST API interaction between clients and a server &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – REST API interaction between clients and a server </p>
			<p>A REST API relies on HTTP requests and uses its native methods such as <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong>. The use of the HTTP method simplifies the implementation of client-side and server-side software from an API design perspective. A REST API is developed <a id="_idIndexMarker1210"/>keeping in mind the CRUD operations concept. <strong class="bold">CRUD</strong> stands for <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong>. This is where HTTP methods find themselves aligned one on one with the CRUD operations, for example, <strong class="source-inline">GET</strong> for <strong class="source-inline">Read</strong>, <strong class="source-inline">POST</strong> for <strong class="source-inline">Create</strong>, <strong class="source-inline">PUT</strong> for <strong class="source-inline">Update</strong>, and <strong class="source-inline">DELETE</strong> for <strong class="source-inline">Delete</strong> operation.</p>
			<p>When building a REST API with HTTP methods, we must be careful in choosing the correct method based on its idempotency capabilities. An operation is considered idempotent in mathematics if the operation is giving the same results even if it is repeated multiple times. From the rest API design perspective, the <strong class="source-inline">POST</strong> method is not idempotent, which means <a id="_idIndexMarker1211"/>we have to make sure that the API clients are not initiating a <strong class="source-inline">POST</strong> request multiple times for the same set of data. The <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> methods are idempotent, although it is quite possible to get a <strong class="source-inline">404</strong> error code if we try to delete the same resource the second time. However, this is acceptable behavior from an idempotence point of view. </p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor282"/>Using Flask for a REST API</h2>
			<p>A REST API in Python can be built using different libraries and frameworks. The most popular frameworks for building a REST API are Django, Flask (using the <strong class="bold">Flask-RESTful</strong> extension), and <strong class="bold">FastAPI</strong>. Each of <a id="_idIndexMarker1212"/>these frameworks has merits and demerits. Django is a <a id="_idIndexMarker1213"/>suitable choice for building a REST API if the web application is also being built using Django. However, using Django only for API <a id="_idIndexMarker1214"/>development would be overkill. The Flask-RESTful extension works seamlessly with a Flask web application. Both Django and Flask have strong <a id="_idIndexMarker1215"/>community support, which is sometimes an important factor when selecting a library or a framework. FastAPI is considered the best in performance and is a good choice if the goal is only to build a REST API for your application. However, community support for FastAPI is not at the same level as we have for Django and Flask. </p>
			<p>We selected a Flask RESTful extension for REST API development for the continuation of our discussion that we had started for the web application development. Note that we can build a simple web API using just Flask, and we have done this in the previous chapter when we developed a sample web service-based application for Google Cloud deployment. In this section, we will focus on using the REST architectural style in building the API. This means that we will use the HTTP method to perform an operation on a resource that will be represented by a Python object. </p>
			<p class="callout-heading">Important</p>
			<p class="callout">Flask-RESTful support is unique in the way that it provides a convenient way to set the response code and response header as a part of return statements.</p>
			<p>To use Flask <a id="_idIndexMarker1216"/>and the Flask-RESTful extension, we will be required <a id="_idIndexMarker1217"/>to install the Flask-RESTful extension. We can install it in our virtual environment by using the following <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install Flask-RESTful</p>
			<p>Before discussing how to implement a REST API, it is beneficial to get familiar with a few terms and concepts related to API.</p>
			<h3>Resource</h3>
			<p>A resource is a <a id="_idIndexMarker1218"/>key element for a REST API, and this is powered by the Flask-RESTful extension. A resource object is defined by extending our class from the base <strong class="source-inline">Resource</strong> class, which is available from the Flask-RESTful extension library. The base <strong class="source-inline">Resource</strong> class offers several magic functions to assist API development and automatically associates HTTP methods with Python methods defined in our resource object.</p>
			<h3>API endpoint</h3>
			<p>An API endpoint is a point of entry to establish communication between client software and server <a id="_idIndexMarker1219"/>software. In simple terms, an API endpoint is alternative terminology for a URL of a server or service where a program is listening for API requests. With the Flask-RESTful extension, we define an API endpoint by associating a certain URL (or URLs) with a resource object. In Flask implementation, we implement a resource object by extending from the base <strong class="source-inline">Resource</strong> class. </p>
			<h3>Routing</h3>
			<p>The concept <a id="_idIndexMarker1220"/>of routing for API is similar to web application routing in Flask, with the only difference being that in the case of an API, we need to map a <strong class="source-inline">Resource</strong> object to one or more endpoint URLs. </p>
			<h3>Argument parsing</h3>
			<p>The parsing of request arguments for an API is possible by using the query string or HTML form-encoded data. However, this is not a preferred approach because both the query string <a id="_idIndexMarker1221"/>or HTML forms are not meant or designed to be used with an API. The recommended approach is to extract the arguments directly from an HTTP request. To facilitate this, the Flask-RESTful extension offers a special class, <strong class="source-inline">reqparse</strong>. This <strong class="source-inline">reqparse</strong> class is similar to <strong class="source-inline">argparse</strong>, which is a popular choice for parsing command-line arguments.</p>
			<p>Next, we will learn about building a REST API for accessing data from a database system.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor283"/>Developing a REST API for database access</h2>
			<p>To illustrate the use of Flask and the Flask-RESTful extension for building a REST API, we will revise <a id="_idIndexMarker1222"/>our web application (<strong class="source-inline">app5.py</strong>) and will offer access to the <strong class="source-inline">Student</strong> object (a <strong class="source-inline">Resource</strong> object) using the REST architectural style. We are expecting the arguments sent for the <strong class="source-inline">PUT</strong> and <strong class="source-inline">POST</strong> methods inside the request body and the API will send back the response in JSON format. The revised code of <strong class="source-inline">app5.py</strong> with a REST API interface is shown next:</p>
			<p class="source-code"><strong class="bold">#api_app.py: REST API application for student resource</strong></p>
			<p class="source-code">from flask_sqlalchemy import SQLAlchemy</p>
			<p class="source-code">from flask import Flask</p>
			<p class="source-code"><strong class="bold">from flask_restful import Resource, Api, reqparse</strong></p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code"><strong class="bold">api = Api(app)</strong></p>
			<p class="source-code">app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///student.db'</p>
			<p class="source-code">app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False</p>
			<p class="source-code">db = SQLAlchemy(app)</p>
			<p>In the preceding code snippet, we started with the initialization of the Flask application and the database instance. As a next step, we created an API instance using the Flask instance. We achieved this by means of the <strong class="source-inline">api = Api(app)</strong> statement. This API instance is the key to develop the rest of the API application and we will use it. </p>
			<p>Next, we need to configure the <strong class="source-inline">reqparse</strong> instance by registering the argument we are expecting to parse from the HTTP request. In our code example, we registered two arguments of the string type, <strong class="source-inline">name</strong> and <strong class="source-inline">grade</strong>, as shown in the following code snippet:</p>
			<p class="source-code"><strong class="bold">parser = reqparse.RequestParser()</strong></p>
			<p class="source-code"><strong class="bold">parser.add_argument('name', type=str)</strong></p>
			<p class="source-code"><strong class="bold">parser.add_argument('grade', type=str)</strong></p>
			<p>The next step is to create a <strong class="source-inline">Student</strong> model object, which is mostly the same as we did in <strong class="source-inline">app5.py</strong>, except that we will add a <strong class="source-inline">serialize</strong> method to convert our object into JSON format. This is <a id="_idIndexMarker1223"/>an important step in serializing the JSON response before sending it back to the API clients. There are other solutions available to achieve the same, but we selected this option for simplicity reasons. The precise sample code for the creation of a <strong class="source-inline">Student</strong> object is as follows: </p>
			<p class="source-code">class Student(db.Model):</p>
			<p class="source-code">    id = db.Column(db.Integer, primary_key=True)</p>
			<p class="source-code">    name = db.Column(db.String(80), nullable=False)</p>
			<p class="source-code">    grade = db.Column(db.String(20), nullable=True)</p>
			<p class="source-code">    <strong class="bold">def serialize(self):</strong></p>
			<p class="source-code">        return {</p>
			<p class="source-code">            'id': self.id,</p>
			<p class="source-code">            'name': self.name,</p>
			<p class="source-code">            'grade': self.grade</p>
			<p class="source-code">        }</p>
			<p>Next, we created two <strong class="source-inline">Resource</strong> classes to access student database objects. These are <strong class="source-inline">StudentDao</strong> and <strong class="source-inline">StudentListDao</strong>. These are described next:</p>
			<ul>
				<li><strong class="source-inline">StudentDao</strong> offers methods such as <strong class="source-inline">get</strong> and <strong class="source-inline">delete</strong> on the individual resource instance, and these methods are mapped to the <strong class="source-inline">GET</strong> and <strong class="source-inline">DELETE</strong> methods of the HTTP protocol. </li>
				<li><strong class="source-inline">StudentListDao</strong> offers methods such as <strong class="source-inline">get</strong> and <strong class="source-inline">post</strong>. The <strong class="source-inline">GET</strong> method is added to provide a list of all resources of the <strong class="source-inline">Student</strong> type using the <strong class="source-inline">GET</strong> HTTP method, and the <strong class="source-inline">POST</strong> method is included to add a new resource object using the <strong class="source-inline">POST</strong> HTTP method. This is a typical design pattern used to implement CRUD functionality for a web resource. </li>
			</ul>
			<p>As regards methods implemented for <strong class="source-inline">StudentDao</strong> and <strong class="source-inline">StudentListDao</strong> classes, we returned the <a id="_idIndexMarker1224"/>status code and the object itself in a single statement. This is a convenience offered by the Flask-RESTful extension.    </p>
			<p>A sample code for the <strong class="source-inline">StudentDao</strong> class is shown next: </p>
			<p class="source-code"><strong class="bold">class StudentDao(Resource):</strong></p>
			<p class="source-code">    <strong class="bold">def get(self, student_id):</strong></p>
			<p class="source-code">        student = Student.query.filter_by(id=student_id).\</p>
			<p class="source-code">            first_or_404(description='Record with id={} is                 not available'.format(student_id))</p>
			<p class="source-code">        <strong class="bold">return student.serialize()</strong></p>
			<p class="source-code">    <strong class="bold">def delete(self, student_id):</strong></p>
			<p class="source-code">        student = Student.query.filter_by(id=student_id).\</p>
			<p class="source-code">            first_or_404(description='Record with id={} is                 not available'.format(student_id))</p>
			<p class="source-code">        db.session.delete(student)</p>
			<p class="source-code">        db.session.commit()</p>
			<p class="source-code">        <strong class="bold">return '', 204</strong></p>
			<p>A sample code for the <strong class="source-inline">StudentListDao</strong> class is as follows:</p>
			<p class="source-code"><strong class="bold">class StudentListDao(Resource):</strong></p>
			<p class="source-code">    <strong class="bold">def get(self):</strong></p>
			<p class="source-code">        students = Student.query.all()</p>
			<p class="source-code">        <strong class="bold">return [Student.serialize(student) for student in </strong>            <strong class="bold">students]</strong></p>
			<p class="source-code">    <strong class="bold">def post(self):</strong></p>
			<p class="source-code">        <strong class="bold">args = parser.parse_args()</strong></p>
			<p class="source-code">        <strong class="bold">name = args['name']</strong></p>
			<p class="source-code">        <strong class="bold">grade = args['grade']</strong></p>
			<p class="source-code">        student = Student(name=name, grade=grade)</p>
			<p class="source-code">        db.session.add(student)</p>
			<p class="source-code">        db.session.commit()</p>
			<p class="source-code">        <strong class="bold">return student, 200</strong></p>
			<p>For our <strong class="source-inline">post</strong> method of the <strong class="source-inline">StudentListDao</strong> class, we used the <strong class="source-inline">reqparse</strong> parser to extract the <a id="_idIndexMarker1225"/>name and the grade arguments from the request. The rest of the implementation in the <strong class="source-inline">POST</strong> method is the same as we did for the <strong class="source-inline">app5.py</strong> example. </p>
			<p>In the next two lines of our sample API application, we mapped URLs to our <strong class="source-inline">Resource</strong> objects. All requests coming for <strong class="source-inline">/students/&lt;student_id&gt;</strong> will be redirected to the <strong class="source-inline">StudentDao</strong> resource class. Any request coming for <strong class="source-inline">/students</strong> will be redirected to the <strong class="source-inline">StudentListDao</strong> resource class:</p>
			<p class="source-code"><strong class="bold">api.add_resource(StudentDao, '/students/&lt;student_id&gt;')</strong></p>
			<p class="source-code"><strong class="bold">api.add_resource(StudentListDao, '/students')</strong></p>
			<p>Note that we skipped the <strong class="source-inline">PUT</strong> method implementation from the <strong class="source-inline">StudentDao</strong> class, but it is available with the source code provided for this chapter for completeness. For this code example, we did not add error and exception handling to keep the code concise for <a id="_idIndexMarker1226"/>our discussion, but it is highly recommended to have this included in our final implementation. </p>
			<p>In this section, we have covered the base concepts and implementation principles for developing REST APIs that are adequate for anyone to start building a REST API. In the next section, we will extend our knowledge to build a complete web application based on a REST API. </p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor284"/>Case study– Building a web application using the REST API</h1>
			<p>In this chapter, we learned how to build a simple web application using Flask and how to add a REST API <a id="_idIndexMarker1227"/>to a business logic layer using a <a id="_idIndexMarker1228"/>Flask extension. In the real world, web applications are typically three tiers: <em class="italic">web layer</em>, <em class="italic">business logic layer</em>, and <em class="italic">data access layer</em>. With the popularity of mobile apps, the architecture has evolved to have a REST API as a building block for the business layer. This affords the freedom of building web apps and mobile apps using the same business logic layer. Moreover, the same API can be available for B2B interactions with other vendors. This type of architecture is captured in <em class="italic">Figure 10.2</em>:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17189_10_02.jpg" alt="Figure 10.2 – Web/mobile application architecture &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Web/mobile application architecture </p>
			<p>In our case study, we will develop a web application on top of the REST API application that was <a id="_idIndexMarker1229"/>developed for the <strong class="source-inline">Student</strong> model <a id="_idIndexMarker1230"/>object in the previous code example. At a high level, we will have the components in our application as shown here:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17189_10_03.jpg" alt="Figure 10.3 – Sample web application with a REST API as a backend engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Sample web application with a REST API as a backend engine</p>
			<p>We already developed a business logic layer and data access layer (ORM) and exposed the functionality through two API endpoints. This is discussed in the <em class="italic">Using Flask for a REST API</em> section. We will develop a web application part for web access and consume the API offered by the business logic.</p>
			<p>The <strong class="source-inline">webapp.py</strong> web application will be based on Flask. The <strong class="source-inline">webapp.py</strong> application (referred to as <em class="italic">webapp</em> moving forward) will be independent of the <strong class="source-inline">api_app.py</strong> application (referred to as <em class="italic">apiapp</em> moving forward) in the sense that the two applications will be running separately as two Flask instances, ideally on two separate machines. But if we are running the two Flask instances on the same machine for testing purposes, we must use different ports and use the local machine IP address as a host. Flask uses the <em class="italic">127.0.0.1</em> address as a host to run its built-in web server, which may not be allowed for running two instances. The two applications will talk to each other only via a REST API. Additionally, we will develop a few Jinja templates to submit requests for create, update, and delete operations. We will reuse the <strong class="source-inline">api_py.py</strong> application code as is, but we <a id="_idIndexMarker1231"/>will develop the <strong class="source-inline">webapp.py</strong> application <a id="_idIndexMarker1232"/>with features such as listing students, adding a new student, deleting a student, and updating a student's data. We will add Python functions for each feature one by one: </p>
			<ol>
				<li value="1">We will begin with the initialization of the Flask instance as we have done for previous code examples. The sample code is as follows: <p class="source-code">#<strong class="bold">webapp.py</strong>: interacting with business latyer via REST API </p><p class="source-code"># for create, delete and list objects</p><p class="source-code">from flask import Flask, render_template, redirect,   request</p><p class="source-code">import requests, json</p><p class="source-code">app = Flask(__name__)</p></li>
				<li>Next, we will add a <strong class="source-inline">list</strong> function to handle requests with the <strong class="source-inline">/</strong> URL as follows: <p class="source-code"><strong class="bold">@app.get('/')</strong></p><p class="source-code"><strong class="bold">def list():</strong></p><p class="source-code">    response = requests.get('http://localhost:8080         /students')</p><p class="source-code">    data = json.loads(response.text)</p><p class="source-code">    return render_template('main.html', students=data)</p><p>In all our Python functions, we are using the <strong class="source-inline">requests</strong> library to send a REST API request to the <strong class="source-inline">apiapp</strong> application that is hosted on the same machine in our test environment. </p></li>
				<li>Next, we will <a id="_idIndexMarker1233"/>implement an <strong class="source-inline">add</strong> function to process the request for adding a new student to the database. Only the <a id="_idIndexMarker1234"/>request with the <strong class="source-inline">POST</strong> method type is mapped to this Python function. The sample code is as follows: <p class="source-code"><strong class="bold">@app.post('/')</strong></p><p class="source-code"><strong class="bold">def add():</strong></p><p class="source-code">    fname = request.form['fname']</p><p class="source-code">    lname = request.form['lname']</p><p class="source-code">    grade = request.form['grade']</p><p class="source-code">    payload = {'name': f"{fname} {lname}", 'grade':         grade}</p><p class="source-code">    respone = requests.post('http://localhost:8080         /students', data=payload)</p><p class="source-code">    return redirect("/")</p><p>Note that for the post API call to our <strong class="source-inline">apiapp</strong> application, we built the <strong class="source-inline">payload</strong> object and passed it as a <strong class="source-inline">data</strong> attribute to the <strong class="source-inline">POST</strong> method of the <strong class="source-inline">requests</strong> module.</p></li>
				<li>Next, we will add a <strong class="source-inline">DELETE</strong> function to handle a request for deleting an existing student. The request type mapped to this method is expected to provide the student ID as part of the URL.<p class="source-code"><strong class="bold">@app.get('/delete/&lt;int:id&gt;')</strong></p><p class="source-code"><strong class="bold">def delete(id):</strong></p><p class="source-code">    response = requests.delete('http://localhost:8080         /students/'+str(id))</p><p class="source-code">    return redirect("/")</p></li>
				<li>Next, we will add two functions to handle the update feature. One function (<strong class="source-inline">update</strong>) is used to update the data of a student in the same manner as the <strong class="source-inline">post</strong> function does. But before triggering the <strong class="source-inline">update</strong> function, our webapp application <a id="_idIndexMarker1235"/>will offer a form to the <a id="_idIndexMarker1236"/>user with the current data of a <strong class="source-inline">student</strong> object. The second function (<strong class="source-inline">load_student_for_update</strong>) will get a <strong class="source-inline">student</strong> object and send it to a Jinja template for users to edit. The code for both functions is as follows:<p class="source-code"><strong class="bold">@app.post('/update/&lt;int:id&gt;')</strong></p><p class="source-code"><strong class="bold">def update(id):</strong></p><p class="source-code">    fname = request.form['fname']</p><p class="source-code">    lname = request.form['lname']</p><p class="source-code">    grade = request.form['grade']</p><p class="source-code">    payload = {'name' : f"{fname} {lname}",'grade':grade}</p><p class="source-code">    respone = requests.put('http://localhost:8080         /students/' + str(id), data = payload)</p><p class="source-code">    return redirect("/")</p><p class="source-code"><strong class="bold">@app.get('/update/&lt;int:id&gt;')</strong></p><p class="source-code"><strong class="bold">def load_student_for_update(id):</strong></p><p class="source-code">    response = requests.get('http://localhost:8080         /students/'+str(id))</p><p class="source-code">    student = json.loads(response.text)</p><p class="source-code">    fname = student['name'].split()[0]</p><p class="source-code">    lname = student['name'].split()[1]</p><p class="source-code">    return render_template('update.html', fname=fname,         lname=lname, student= student)</p></li>
			</ol>
			<p>The code inside these functions is no different from what we already discussed in relation to <a id="_idIndexMarker1237"/>previous examples. Therefore, we will <a id="_idIndexMarker1238"/>not go into the details of every line of the code, but we will highlight the key points of this web application and its interaction with a REST API application:</p>
			<ul>
				<li>For our web application, we are using two Jinja templates (<strong class="source-inline">main.html</strong> and <strong class="source-inline">update.html</strong>). We are also using a template (we called it <strong class="source-inline">base.html</strong>) that is common to both templates. The <strong class="source-inline">base.html</strong> template is mainly built using the bootstrap UI framework. We will not discuss the details of the Jinja templates and the bootstrap, but we will encourage you to get familiar with both using the references provided at the end of this chapter. The sample Jinja templates with bootstrap code are available with the source code of this chapter.</li>
				<li>The root <strong class="source-inline">/</strong> URL of our web application will launch the main page (<strong class="source-inline">main.html</strong>), which allows us to add a new student and also provides a list of existing students. The following screenshot shows the screenshot of the main page, which will be rendered with our <strong class="source-inline">main.html</strong> template:</li>
			</ul>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17189_10_04.jpg" alt="Figure 10.4 – Main page of the webapp application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Main page of the webapp application</p>
			<ul>
				<li>If we add <a id="_idIndexMarker1239"/>the first and last name of a <a id="_idIndexMarker1240"/>student with a grade and click the <strong class="bold">Submit</strong> button, this will trigger a <strong class="source-inline">POST</strong> request with data of these three input fields. Our webapp application will delegate this request to the <strong class="source-inline">add</strong> function. The <strong class="source-inline">add</strong> function will use the corresponding REST API of the <strong class="source-inline">apiapp</strong> application to add a new student and the <strong class="source-inline">add</strong> function will render the main page again with an updated list of students (including new students).</li>
				<li>On the main webapp page (<strong class="source-inline">main.html</strong>), we added two buttons (<strong class="bold">Update</strong> and <strong class="bold">Delete</strong>) with each student record. On clicking the <strong class="bold">Delete</strong> button, the browser will trigger a <strong class="source-inline">GET</strong> request with the <strong class="source-inline">/delete/&lt;id&gt;</strong> URL. This request will be delegated to the <strong class="source-inline">delete</strong> function. The <strong class="source-inline">delete</strong> function will use the REST API of the <strong class="source-inline">apiapp</strong> application to delete the student from the <strong class="source-inline">SQLite3</strong> database and will render the main page again with an updated list of students.</li>
				<li>Upon clicking the <strong class="bold">Update</strong> button, the browser will trigger a <strong class="source-inline">GET</strong> request with the <strong class="source-inline">/update/&lt;id&gt;</strong> URL. This request will be delegated to the <strong class="source-inline">load_student_for_update</strong> function. This function will first load the student data using the REST API of the <strong class="source-inline">apiapp</strong> application, set the data in the response, and render the <strong class="source-inline">update.html</strong> template. The <strong class="source-inline">update.html</strong> template will show the user an <a id="_idIndexMarker1241"/>HTML form filled with student <a id="_idIndexMarker1242"/>data to allow editing. The form we developed for the update scenario is shown here: </li>
			</ul>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17189_10_05.jpg" alt="Figure 10.5 – A sample form to update a student &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – A sample form to update a student </p>
			<p>After the changes, if a user submits the form by clicking the <strong class="bold">Update</strong> button, the browser will trigger a <strong class="source-inline">POST</strong> request with the <strong class="source-inline">/update/&lt;id&gt;</strong> URL. We have registered the <strong class="source-inline">update</strong> function for this request. The <strong class="source-inline">update</strong> function will extract data from the request and pass it to the REST API of the <strong class="source-inline">apiapp</strong> application. Once the student info is updated, we will render the <strong class="source-inline">main.html</strong> page again with an updated list of students.</p>
			<p>In this chapter, we have omitted the details of pure web technologies such as HTML, Jinja, CSS, and UI frameworks in general. The beauty of web frameworks is that they allow any <a id="_idIndexMarker1243"/>web technologies to be used for customer interfaces, especially if we are building our applications using a REST API. </p>
			<p>This concludes <a id="_idIndexMarker1244"/>our discussion of building web applications and developing a REST API using Flask and its extensions. Web development is not limited to one language or one framework. The core principles and architecture remain the same across web frameworks and languages. The web development principles you learned here will help you to understand any other web framework for Python or any other language. </p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor285"/>Summary</h1>
			<p>In this chapter, we discussed how to use Python and web frameworks such as Flask for developing web applications and a REST API. We started the chapter by analyzing the requirements for web development, which include a web framework, a UI framework, a web server, a database system, API support, security, and documentation. Later, we introduced how to use the Flask framework for building web applications with several code examples. We discussed different request types with different HTTP methods and how to parse the request data with relevant code examples. We also learned about the use of Flask to interact with a database system using an ORM library such as SQLAlchemey. In the latter part of the chapter, we introduced the role of a web API for web applications, mobile applications, and business-to-business applications. We investigated a Flask extension to develop a REST API with a detailed analysis by using a sample API application. In the last section, we discussed a case study of developing a <em class="italic">student</em> web application. The web application is built using two independent applications, both running as Flask applications. One application offers a REST API for the business logic layer on top of a database system. The other application provides a web interface to users and consumes the REST API interface of the first application to provide access to the student resource objects. </p>
			<p>This chapter provides extensive hands-on knowledge of building web applications and a REST API using Flask. The code examples included in this chapter will enable you to start creating web applications and write a REST API. This knowledge is critical for anyone who is seeking a career in web development and working in building a REST API. </p>
			<p>In the next chapter, we will explore how to use Python to develop microservices, a new paradigm of software development. </p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor286"/>Questions</h1>
			<ol>
				<li value="1">What is the purpose of TLS?</li>
				<li>When is Flask a superior choice to the Django framework?</li>
				<li>What are the commonly used HTTP methods?</li>
				<li>What is CRUD and how is it related to a REST API?</li>
				<li>Does a REST API only use JSON as a data format?</li>
			</ol>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor287"/>Further reading</h1>
			<ul>
				<li><em class="italic">Flask Web Development</em>, by Miguel Grinberg</li>
				<li><em class="italic">Advanced Guide to Python 3 Programming</em>, by John Hunt</li>
				<li><em class="italic">REST APIs with Flask and Python</em>, by Jason Myers &amp; Rick Copeland</li>
				<li><em class="italic">Essential SQLAlchemy, 2nd Edition</em>, by Jose Salvatierra</li>
				<li><em class="italic">Bootstrap 4 Quick Start</em>, by Jacob Lett</li>
				<li><em class="italic">Jinja online documentation</em>, available at <a href="https://jinja.palletsprojects.com/">https://jinja.palletsprojects.com/</a><em class="italic"> </em></li>
			</ul>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor288"/>Answers</h1>
			<ol>
				<li value="1">The main purpose of TLS is to provide encryption of data that is exchanged between the two systems on the internet.</li>
				<li>Flask is a better choice for small- to medium-sized applications and especially when the project requirements are expected to change frequently. </li>
				<li><strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>.</li>
				<li><strong class="bold">CRUD</strong> stands for <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> operations in software development. From an API perspective, each CRUD operation is mapped to one of the HTTP methods (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>).</li>
				<li>A REST API can support any string-based format, such as JSON, XML, or HTML. Data format support is more related to HTTP's ability to carry the data as part of the HTTP body element.</li>
			</ol>
		</div>
	</body></html>