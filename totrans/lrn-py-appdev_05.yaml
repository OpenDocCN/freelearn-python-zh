- en: Chapter 5. Unit Testing and Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a quick recap of what you have learned so far. You developed a command-line
    application using the OOP approach, and then learned techniques to make your code
    robust by handling exceptions. You modularized the code, prepared a distribution,
    and released it to a broader audience. Finally, you learned about coding standards
    and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have not paid much attention to testing the application. We relied
    solely on manual testing, where some features were tested by playing the game.
    The task of manual testing becomes increasingly difficult with the complexity
    of the application. Soon you will be overwhelmed, and the bugs will start to creep
    in. While manual testing may not be avoided completely, we need an automated way
    to make sure the features work as expected. In this chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about unittest, the unit testing framework in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write some unit tests for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to use the mock library in unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to measure the effectiveness of unit tests (code coverage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what is code refactoring, why, when, and how to do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Come back to the unit testing discussion after doing some code refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how the chapter is organized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter starts with a game scenario, where a bug slips through to production
    and stays hidden until a user discovers it. This scenario underlines the need
    for automated testing, and then leads into a discussion on unit testing framework
    in Python. You will be introduced to the unittest framework and the mock library
    in Python. The chapter will demonstrate the use of these libraries by writing
    a few unit tests for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Moving ahead, it shows an example where it is difficult to write a unit test
    without refactoring the code first (see *Refactoring preamble*). This is where
    we take a detour, learn the basics of refactoring, refactor the code, and then
    develop the last unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Important housekeeping notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These notes will be useful in case you haven't read the earlier chapters. Otherwise,
    just move on to the next heading. Like every other chapter, this one has its own
    set of Python source files. The source code can be downloaded from the *Packt
    Publishing* website. Just follow the instructions mentioned in this book's *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter that depends on the code developed in the earlier chapters.
    Starting with [Chapter 6](ch06.html "Chapter 6. Design Patterns"), *Design Patterns*,
    we will have independent, simplified examples to demonstrate various concepts.
    That said, everything will be tied back to the same high fantasy theme.
  prefs: []
  type: TYPE_NORMAL
- en: Why test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you play the game developed so far? If not, just try playing it once. During
    the combat with the enemy, the following can be observed. For each attack, either
    Sir Foo or the enemy sustains injuries. This is indicated by the reduced hit points.
    For example, in the sample game output shown next, `Sir Foo` gets hit in the first
    attack turn, whereas the enemy is injured in the next two attack turns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Why test?](img/B05034_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A new feature was requested
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *A user requested an enhancement to the combat scenario:**"During combat,
    the program asks whether you want to continue attacking the enemy. In each attack
    move, one of the warriors, the player or the enemy, gets injured. Can you make
    it more interesting? What if both the warriors escape unhurt sometimes?"* |'
  prefs: []
  type: TYPE_TB
- en: '![A new feature was requested](img/B05034_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *It will benefit you as well Sir Foo! We will go ahead and implement this
    minor enhancement. Despite Sir Foo''s stiff opposition, you rushed to implement
    this new feature.* |'
  prefs: []
  type: TYPE_TB
- en: You implemented this feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that the `gameutils.weighted_random_selection` function randomly selects
    an element from `weighted_list`. The list is populated such that, for approximately
    30% of the time, the unique identifier of `obj1` gets selected, and for the rest
    of the time, the unique identifier representing `obj2` gets chosen. Put another
    way, the chance of Sir Foo (`obj1`) getting injured is approximately 30%, and
    that of the enemy (`obj2`) is nearly 70%.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the likelihood that no one gets hurt, you changed the composition of
    `weighted_list` by adding a new element, `None`. The new chances of injury to
    the warriors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The chances of the enemy (`obj2`) getting hurt are ~ 60%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chances of Sir Foo (`obj1`) getting hurt are ~30%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both escaping unhurt (`None`) are ~ 10%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `weighted_random_selection` function before and after
    the aforementioned change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![You implemented this feature](img/B05034_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That was easy, wasn't it? You played the game once to make sure nothing is broken.
    It looked all fine. Without any delay, you released a new version.
  prefs: []
  type: TYPE_NORMAL
- en: But something wasn't right...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, soon after release, user complaints started pouring in. This was unexpected.
    Your commit introduced a new bug!
  prefs: []
  type: TYPE_NORMAL
- en: '![But something wasn''t right...](img/B05034_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Calm down Sir Foo! You are still in war mode! Relax and take a deep breath.
    We will address this issue soon.* |'
  prefs: []
  type: TYPE_TB
- en: 'So what went wrong? There is no problem with the function you wrote. It is
    behaving as intended. However, you forgot to make some changes to the code that
    calls `weighted_random_selection`. As a result, the following uncaught exception
    is seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![But something wasn''t right...](img/B05034_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The error traceback points to the `AbstractGameUnit.attack` method. This method
    calls the `weighted_random_selection` function to randomly select an injured unit.
    The problem occurs when `injured_unit` is `None`. The trouble-causing line of
    code is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![But something wasn''t right...](img/B05034_05_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It required thorough testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You had done basic testing by running the game once. But then why didn't you
    notice this problem? The chances that the function returns `None` are slim. For
    example, for every 10 calls to the function `weighted_random_selection`, the value
    `None` would be on average returned only once. In this case, the testing you did
    was not enough to reproduce the problem.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one of the scenarios where thorough testing is required. At the
    same time, it is prone to human error because of the random nature of the output.
    If you had some automated means to test this functionality, the bug could have
    been easily avoided.
  prefs: []
  type: TYPE_NORMAL
- en: So let's learn how to create automated tests in Python using the unittest framework.
    After you know how to write a unit test, we will come back and write a unit test
    for the `weighted_random_selection` function that was discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unit testing, you tinker with a code fragment within the application. The
    main task is to verify that this piece of code continues to work as expected throughout
    the life of the application. This is accomplished by writing a test for that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A unit test can be better explained with an example. Consider a trivial function
    that returns the sum of two numbers. In a unit test, you invoke this function
    by passing two numbers as arguments, and then verify the value returned by the
    function is indeed the sum of the given numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There are many frameworks available for writing unit tests. The examples in
    this chapter will be based on the built-in unit testing framework called unittest.
    See the heading *Other unit testing tools*, which gives a very short overview
    of alternative unit testing tools and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Python unittest framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest` module provides the functionality to automate tests. Before we
    implement any tests for our application, let's first start with the terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Basic terminology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Test case**: When you write a unit test, it is referred to as a test case.
    `TestCase` is the superclass for creating different test cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test suite**: When you group together various test cases, it becomes a test
    suite. A test suite may also represent a collection of other test suites. `unittest.TestSuite`
    provides a superclass for creating a suite. The `TestSuite` does not define any
    unit tests, but it just accumulates the tests or other test suites. This is a
    major difference between `TestSuite` and `TestCase`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test fixtures**: These are preparatory methods for the smooth running of
    the unit tests. For example, `TestCase.setUp` is called just before executing
    a test case. It can be used to feed the required data to the test cases. Similarly,
    `TestCase.tearDown` method is called immediately after the test execution. Such
    methods could be used in combination, for instance to start and stop a service
    consumed by a unit test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test runner**: The runner helps execute a test case or a test suite. It also
    provides a way to represent the results after running the tests. For example,
    the results can be displayed on the command line or in some graphical form. The
    basic implementation is provided by the `unittest.TextTestRunner` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests with unittest.TestCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand the basics of constructing and running the tests, let''s write
    a trivial program. Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating tests with unittest.TestCase](img/B05034_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned earlier, the `setUp` and `tearDown` methods are known as fixtures.
    `MyUnitTests.setUp()` is called before executing each test. This allows the initialization
    of some common variables before the test gets executed. The `MyUnitTests.tearDown()`
    method is called after every test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `unittest.main()` program is invoked, the tests defined in the `MyUnitTests`
    class are run one after the other. This program can also accept a test runner
    as an optional argument (not used in this example). By default, the program loads
    and runs only the methods that have names starting with `test`. In the `MyUnitTests`
    class, the tests defined in the `test_1` and `test_2` methods will be executed
    as shown in the following command-line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating tests with unittest.TestCase](img/B05034_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we know how the test cases are executed, let''s review one of the
    methods, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assertEqual` method is a built-in method of the `TestCase` class. It essentially
    checks whether the two input arguments are equal, otherwise an assertion error
    is raised. The test illustrated in the preceding code fragment will pass. Let''s
    review a test that would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, `1+1 != 3`, so we would expect the test to fail, as shown in the
    following command-line output. For a failed test, it also prints the letter `F`
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating tests with unittest.TestCase](img/B05034_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, the `unittest.TestCase` class defines a bunch of convenient methods.
    For example, the `assertTrue` and `assertFalse` methods verify a condition. Another
    method, `assertRaises`, is used to check whether a certain exception is raised
    by the code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling test execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Is there a way to run only selected test cases? One way is to use Python **decorators**
    for the tests you want to ignore. Let''s add this decorator to both the test cases
    from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling test execution](img/B05034_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Essentially, none of the test cases would be run. The output, after running
    the code, indicates that these tests have been skipped. For each skipped test,
    it prints `s` in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling test execution](img/B05034_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two more decorators not covered here, namely `skipIf` and `skipUnless`.
    These decorators are used for the condition-based skipping of the test. See the
    following documentation page for details: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you do expect a few test cases to fail. For example, a test may
    fail due to a difference between a development versus a production environment,
    or due to the presence or absence of expected database content. Such expected
    failures can be tagged with another decorator. We know that `test_2` fails, so
    let''s add the decorator for this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling test execution](img/B05034_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For each anticipated failure, it prints `x` in the output. At the end, it summarizes
    how many tests were expected to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling test execution](img/B05034_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using unittest.TestSuite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the `testsuitedemo.py` file in the supporting code bundle for this
    chapter. The module contains two classes, namely `MyUnitTestA` and `MyUnitTestB`.
    Each of these inherit from `unittest.TestCase`, and define some trivial methods
    as unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy!* we created a separate module for each class. Here, the `testsuitedemo.py`
    module contains two classes. As an exercise, you can put these classes in separate
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets show these classes. For compactness, the code comments
    are omitted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using unittest.TestSuite](img/B05034_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `makeSuite` function of the `unittest` module can be used to create an
    instance of `TestSuite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code will construct a test suite using all the unit tests
    defined in the `MyUnitTestA` class. Only the method names starting with `test*`
    are added to the test suite. In this example, these methods are `test_a2` and
    `test_a1`. The third method, `not_called_by_default`, will not be automatically
    considered as a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Non-test methods (such as `not_called_by_default` in this example), are often
    useful for sharing code between the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to include such methods in the test suite. The code snippet
    that follows shows a function `suite()` defined in this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using unittest.TestSuite](img/B05034_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: This function creates two instances of `TestSuite`, namely `suite_a` and `suite_b`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyUnitTest.not_called_by_default` method is added as a test case in the
    test suite using the `addTest` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function returns a new `TestSuite` object. It takes a Python tuple as an
    argument. In this example, the tuple includes the two instances of `TestSuite`
    created before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last part of this module is the execution code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using unittest.TestSuite](img/B05034_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the `testsuitedemo.py` module produces the following output. Observe
    that it has also executed the test defined in `MyUnitTestB.not_called_by_default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using unittest.TestSuite](img/B05034_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test suites are also very convenient for grouping test cases, depending on their
    runtime. For example, you can group together fast-running tests and slow-running
    tests, and give the test runner script a command-line option to choose which one
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to write some unit tests for the application. We will make a new
    subclass of `unittest.TestCase` to hold all the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a first step, let''s create a new package for holding the test cases. Create
    a new directory called `test` at the same level where you have the rest of the
    code. Next, create two new files inside this `test` directory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a test package](img/B05034_05_47_testdir_structure.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `test_wargame.py` module is where new unit tests will be created. To recognize
    the directory as a Python package, add an empty `__init__.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you haven't already, read [Chapter 3](ch03.html "Chapter 3. Modularize, Package,
    Deploy!"), *Modularize, Package, Deploy!* for details on creating a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new class for unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `test_wargame.py` file can also be found in the supporting code. It has
    all the code to be discussed next. In the following discussion, it is assumed
    that you will code from scratch to an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new subclass of `unittest.TestCase`, and call it `TestWarGame` or
    any name you like. The class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new class for unit testing](img/B05034_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by making the necessary imports. Recall that the `setUp()` fixture
    is called immediately before running the unit tests. Inside `setUp`, instances
    of the `Knight` and `OrcRider` classes are created, and are then used in the unit
    test we are about to write: `test_injured_unit_selection`. As seen before, the
    call to `unittest.main()` will automatically execute methods whose names start
    with `test`. In this example, it will run `test_injured_unit_selection()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can write the same code without using fixtures as well. Simply create the
    required instances inside the test you are writing. As you will see next, the
    `test_injured_unit_selection()` unit test uses the objects created in `setUp()`.
    Alternatively, you can create those instances locally, inside the test, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First unit test – Injured unit selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go back to the scenario we discussed under the section *Why test?* Recall
    that you changed the behavior of the `weighted_random_selection` function so that
    it can also return `None` (nobody injured). This new feature broke the program,
    and the application terminated because of an uncaught exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test we are about to write will verify the original behavior of this function.
    The original behavior was to select either Sir Foo (the `Knight` instance) or
    the enemy (the `OrcRider` instance) as the injured unit. The unit test we are
    about to write will verify exactly that. Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First unit test – Injured unit selection](img/B05034_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this preceding function, the chance of `self.enemy` getting injured is
    approximately 70%, and that of `self.knight` (Sir Foo) is nearly 30%. The top-level
    `for` loop just ensures it is called `100` times to account for the random nature
    of the function return value. `TestCase.assertInstance()` raises an assertion
    error if `injured_unit` is not an instance of `Knight` or `OrcRider`. Let's run
    this test now.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a terminal window, run this test from the top-level `wargame` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`-m` is a built-in command line option in Python. It allows you to run a library
    module as a script. In this case, it will run the `unittest` module as a script.
    The argument `test.test_wargame` represents the file `test/test_wargame.py`. The
    `unittest` script will run the tests defined in this module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the old behavior of `weighted_random_selection` is left unchanged, the test
    will pass. However, if you implement the new behavior where the function could
    also return `None`, it will fail by raising an `AssertionError`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the first unit test](img/B05034_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no need to run the `for` loop `100` times. Just make sure to call the
    function at least 10 times. As an exercise, update the test to verify further
    details. For example, verify that the function returns the `Knight` instance approximately
    30% of the time, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Second unit test – Acquiring the hut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s pick another functionality for testing. This time, it is a method from
    the `Hut` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Second unit test – Acquiring the hut](img/B05034_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this method, what do you think we can test? The method serves the following
    purposes: (a) It updates the occupant information, and (b) It sets the `is_acquired`
    flag to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Redesign exercise**:'
  prefs: []
  type: TYPE_NORMAL
- en: In this application, we assume everything from the context of the player. For
    example, the `is_acquired` flag of the `Hut` instance is from the point of view
    of the player. If it is set to `True`, it means the hut is acquired by the player
    and not the enemy. This is already prone to bugs. Imagine an `OrcRider` instance
    calling this method! You can add assertions to make sure it accepts only the `Knight`
    instance. As an exercise, remove the dependence on the `is_acquired` flag from
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a test, we will ensure that the new occupant is the same object
    as the one passed as an argument to the method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Second unit test – Acquiring the hut](img/B05034_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Good question Sir Foo. Why write this test if the method is already working
    fine? Keep in mind the scenario we discussed earlier. An intentional change in
    the functionality caused us so much trouble. Why wait for such a bug to show up?**Today,
    this code is behaving as expected. The unit test is meant for tomorrow. Imagine
    multiple developers contributing to this application. As a result, more code would
    get added, and someone may inadvertently introduce code that will break the intended
    functionality of this method. In such a scenario, how do you ensure that the fundamental
    behavior remains unchanged? A unit test will notice such changes.**A future requirement
    might even change the fundamental behavior of the method. This was illustrated
    in the scenario under the heading **Why Test?** When that happens, the unit test
    you wrote would obviously fail. You do expect it to fail now, and that would make
    it imperative to update the test to match the new requirement.**In short, a unit
    test will make sure that accidental changes to the code are captured right away,
    and don''t become your nightmare, such as when someone reports a bug and you learn
    the hard way that it was caused by a silly mistake in the code you wrote a few
    months ago.* |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s write a new method in the same class, `TestWarGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Second unit test – Acquiring the hut](img/B05034_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we first create an instance of `Hut`. In the second line,
    this hut is acquired by `self.knight`. The `TestCase.assertIs` checks whether
    the object representing the hut's occupant is the same as `self.knight`, otherwise
    an `AssertionError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Running only the second test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we execute the following command, it would run all the tests defined in
    the `test_wargame.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you just want to run `test_acquire_hut`? Assuming you are already inside
    the `wargame` directory, here is a command to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command-line argument can be read as `package_name.module_name.class_name.method_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output after running this test is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running only the second test](img/B05034_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating individual test modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last unit test we wrote was meant for testing the functionality in the `Hut`
    class. We created this as a method of the `TestWarGame` class in the `test_wargame.py`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to put all the tests for the application inside a single module?
    No! You can, optionally, create individual test modules for each class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For large applications, it is often convenient to have separate test modules
    at the class level or the package level. Choose a strategy that best suits your
    project. If it makes sense, you can also create a test class that clubs together
    some common functionality in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rework the previous example. We will create a new module, `test_hut.py`,
    as a home for a new class, `TestHut`. The source code is also available in the
    supplementary material for this chapter—see `wargame/test/test_hut.py`. Next,
    we will move the `TestWarGame.test_acquire_hut` method into this class. This is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating individual test modules](img/B05034_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The syntax to execute the unit test is similar to the one used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Batch executing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your test directory contains multiple test modules, how do you run all the
    tests at once inside the directory? One option is to write a script listing commands
    to execute the unit tests one after the other. The `unittest` module, however,
    provides a discover option to batch execute the tests on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command-line output shows the batch execution of two test modules
    inside the `test` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Batch executing unit tests](img/B05034_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unit tests using mock library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two tests we wrote earlier were pretty straightforward to implement. Often,
    it is not trivial to write a test for verifying the functionality. The reasons
    could vary. In some scenarios, the code is required to be refactored in order
    to access the functionality you would like to test. In another scenario, the code
    might have dependencies that require you to write a lot more code than necessary.
    It is also possible that the functionality to be tested needs time consuming preparatory
    work such as crunching some numbers. This adds to the total test execution time.
    We will now learn how to write a unit test in such situations using the mock library.
    Before working on the actual code, let's understand what functionality this library
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mock library provides a flexible way to create dummy objects that can be
    used to replace some parts in the program that you are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mock is available in the Python standard library ( v3.3 onwards) as `unittest.mock`.
    If you are using a prior distribution, install it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Visit [https://pypi.python.org/pypi/mock](https://pypi.python.org/pypi/mock)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a mock object, you can focus on the main functionality to be tested without
    worrying much about the things on which this functionality depends. It provides
    a way to decouple the supporting chunks of code from the functionality being tested.
    This can be better explained with an example. Refer to the following cartoon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick introduction to mock](img/B05034_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Imagine you are writing a unit test for a function called `compute()` that does
    a lot of scientific computations. Within this function, you are calling other
    supporting functions that process some data. This is a time-consuming operation.
    If you know what information is being provided by the supporting functions, you
    can define their behavior using mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's mock!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time for some action. Open your Python interpreter, and start writing
    the following code. It is assumed that the mock module is already available. If
    it isn''t, install it using pip, as suggested earlier. First, import the `Mock`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `Mock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The object type and its unique ID can be found as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, type the following code in the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Let''s mock!](img/B05034_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Good observation! Apologies for using your name here...that was unintentional.
    In the developer world, people just love your name! So the question is, would
    it really give an attribute error? Try it yourself!* |'
  prefs: []
  type: TYPE_TB
- en: 'Executing this last line of code will print an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is the interesting part! It did not complain about the missing attribute;
    instead, it created a new mock object. You can access any arbitrary attribute
    of this object as if it was already defined. It will create and return a new `Mock`
    object representing that attribute. Here, `foo` is also called a child mock of
    `mockObj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to make use of this feature. `Mock.mock_calls` can be used to
    track all the calls of a mock object along with its child mocks. The results are
    returned as a Python list. Write the following line of code in the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, it returns an empty Python list, as we have not called the `mockObj` or
    its child mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see how this list gets populated. The `Mock` objects are callable.
    Write the following code to call `mockObj.foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create and call another new child mock like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s invoke `mockObj.mock_calls` one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The returned list now contains two objects, namely `call.foo()` and `call.foo2()`.
    These are the helper objects provided by `unittest.mock.call`.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use this information? When you write a unit test, you can use this
    list to make assertions on which objects are invoked and in what order. To understand
    this concept better, we will write a simple unit test in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mock objects in a unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a unit test for the compute method of a class, `MyClassA`. The
    class is shown next. You can also download the `wargame/test/mockdemo.py` file
    from the supporting code bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Mock objects in a unit test](img/B05034_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a trivial example. The `compute` method depends on the values returned
    by two methods, `foo` and `foo2`. It uses these values to compute and return the
    result. In this example, the methods `foo` and `foo2` are simple.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where the aforementioned methods perform tasks that take
    a very long time. Now, to write a unit test that verifies the functionality of
    the `compute` method, you would need to check the final value of `result`. Naturally,
    it would take a long time to finish because of the time spent in `foo` and `foo2`.
    If you know the expected outcome of these methods, you can simply replace them
    with `Mock` objects in the test. We can do this because `foo` and `foo2` are assumed
    to be the supporting functions, and the main functionality to be tested is the
    value of result.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mock` objects would behave as if they are the original methods, and return
    the output you need. But in reality, we bypass the time consuming computations.
    In this illustration, we already know that `foo` is expected to return a value
    of `100`. The return value of the `foo2` method depends on the input argument
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the compute method, we can easily deduce that the return value of
    `foo2` would be `100 + 200 = 300`. So let''s write a unit test that mocks these
    method calls. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Mock objects in a unit test](img/B05034_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's review the method in the preceding code snippet
  prefs: []
  type: TYPE_NORMAL
- en: The `a.foo` and `a.foo2` methods are now represented by new `Mock` objects,
    `mockObj.foo` and `mockObj.foo2`, respectively. Inside `a.compute()`, the `self.foo()`
    and `self.foo2()` calls are now mocked with these new objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test verifies the value of the parameter result. This is done by calling
    `TestCase.assertEqual`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test also verifies which objects are called and the order in which they
    are called. As seen before, `test_call_list` is used to track all the calls to
    `mockObj` and its child mocks. This list is compared with some reference list
    that stores the expected calling order of the objects. In this example, `reference_call_list`
    stores this information. It expects the `foo` and `foo2` methods be called in
    that order. In future, if someone tweaks this order in `MyClassA.compute`, this
    test would help catch the change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The MagicMock class**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MagicMock` is a subclass of `Mock`. It essentially provides all the functionality
    that you would expect from a `Mock` class. Additionally, it provides default implementation
    for many of the magic methods in Python. A magic method is a special method whose
    name has double underscores as both prefix and suffix. Some examples of magic
    methods include `__init__` , `__iter__`, `__len__`, and so on. In the illustrations,
    you can use `MagicMock` instead of the `Mock` class. For further details, go to
    the following page: [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with patches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the previous heading, we covered some basics of the `Mock` class. The
    mock library provides another important functionality in the form of patch decorators.
    Patching is a mechanism that allows you to change the behavior of an object temporarily
    within a test. This is a broad topic. In this book, we will limit our discussion
    to creating patches using `unittest.mock.patch`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Patches can be invoked in four different ways, namely `patch`, `patch.object`
    , `patch.dict`, and `patch.multiple`. For further information, see the documentation
    at [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` decorator function takes `target` as the required argument, followed
    by a long list of optional arguments. Only one of the optional arguments (`new`)
    is shown here. Refer to the unittest documentation for information on other optional
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, the `target` argument is the thing you would like
    to patch. It can be any function, class method, or an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `target` is imported, and should be represented by a string, which resembles
    a typical `import` statement (without the keyword `import`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you want to patch a method inside a test case, the `target`
    should be represented like so: `pkg.module.myclass.mymethod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If this method is in the same file where you are creating the patch (for example,
    the method and its test are in the same Python file), then `target` should be
    written as: `__main__.myclass.mymethod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Among the optional arguments, we will only discuss and use `new`. The `new`
    argument tells which object would replace the `target`. It can be any class or
    a `Mock` object. This can be better understood with an example. See the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is `target`. It is a method `foo` of `MyClassA`, whose behavior
    needs to be changed temporarily within a test. Put another way, this is the method
    (or `target`) that needs to be patched. The `new` argument specifies the object
    that would replace this method. In other words, the `target` is patched with the
    `new` object. If you do not specify the `new` argument, the `target` would be
    automatically patched with a `MagicMock` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using patch in a unit test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate the use of a `patch` decorator, we will use the example discussed
    under the heading *Using Mock objects in a unit test*. Before reading the following
    discussion, review the `MyClassA.compute` method. It was illustrated in the aforementioned
    heading, and the code can also be found in the file `wargame/test/mockdemo.py`.
    The following is a unit test written for `MyClassA.compute` using patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using patch in a unit test](img/B05034_05_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`patch` is a context processor invoked using the with statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `with` keyword cleans up the resources used after the code execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `MyClassA.foo` gets replaced with a `Mock` object created by the
    optional argument new.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, the call `self.foo()` in `MyClassA.compute()` is replaced with
    `return_value` of this `Mock` object. At runtime, the expression `x = self.foo()`
    becomes `x = 500` without actually invoking the method foo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Would the test in the earlier illustration pass? For that, review the code in
    the `MyClassA.compute` method. The `Mock` object created by the `new` argument
    returns a value of `500`. In the unit test, if the result is not `400`, it raises
    an assertion error. So, this test is expected to fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'What happens if you do not specify the `new` argument? As mentioned earlier,
    `target` would automatically get replaced with a new `MagicMock` object. Here
    is another way you can write the same test. As an exercise, run this test, and
    print `foo_patch.__class__` to find out which class it belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using patch in a unit test](img/B05034_05_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this introduction to the mock library, let's write a unit test for a method
    in our application using the `patch` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Third unit test – The play method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use the mock library to write a unit test for `AttackOfTheOrcs.play`.
    Let''s review the method first. You can also find the source code in the `wargame/attackoftheorcs.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third unit test – The play method](img/B05034_05_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This preceding method does many things. It starts by creating some necessary
    objects such as the player and huts. Then the program runs until all the huts
    are acquired by the player or the player loses the combat. Observe the code closely.
    It depends on a user input for selecting a hut. This is not the only user input
    it needs. The call to the `Knight.acquire_hut` method would again ask the user
    whether to continue the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an automated test, you cannot expect someone to enter the hut number, and
    other inputs to continue the execution. So how do we write a unit test for this
    method? This is where we can use `patch` decorators to mimic the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third unit test – The play method](img/B05034_05_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What should we test here? We should test the overall functioning of the method.
    There are a couple of thing to test here:'
  prefs: []
  type: TYPE_NORMAL
- en: The winning or losing criterion. The player is declared a winner when all the
    huts are acquired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this to happen, the player must also be in good health, meaning the value
    of `player.health_meter` should be greater than zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the winner is declared only when both these conditions are true. Similarly,
    there will be a losing criterion that you can easily determine. For precise control,
    you should also write separate unit tests for individual methods invoked within
    the `play` method. For example, there should be a separate test to verify the
    working of `Knight.acquire_huts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test to verify the overall functionality. This test will use
    `patch` to handle the user input. As before, you can find this test in the `wargame/test/test_wargame.py`
    module. The following code snippet shows the `TestWarGame.test_play` method in
    this module. At the beginning of the module, the mock library is imported like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code in this module will not be discussed here. Review the
    aforementioned file for further details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third unit test – The play method](img/B05034_05_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The important part in the preceding code is `mock.patch`. Our first goal is
    to make sure that the user input is properly handled. Recall that in Python 3,
    the user input is handled by the built-in function `input()`. So, we need to patch
    this function with something that would simulate the user input. In other words,
    replace the `builtins.input` function with the handling function represented by
    the `new` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.hut_selection_counter` attribute is used as a simple counter to simulate
    the user input. The rest of the code implements the logic to verify that the winning
    and losing criteria are honored. The `acquired_hut_list` is generated using list
    comprehension. More on list comprehension later when we talk about the performance
    improvements. The `all` function returns `True` if all the list elements are `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Python 2.7.9, try replacing `builtins.input` with `__builtin__.raw_input`.
    However, this technique does not seem to work well, as it will still prompt you
    while running the test! With Python 3.5, this is not a problem. As said elsewhere,
    before Python 3.3, mock was not a built-in module (`unittest.mock`). So for Python
    2.7.9, you may need to install mock as `pip install mock`, and make appropriate
    changes to the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will review the `user_input_processor` that patches the built-in `input`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third unit test – The play method](img/B05034_05_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It takes user `prompt` as an argument, and returns an answer (user input) to
    that prompt. For example, when prompted to enter the hut number, it increments
    `self.hut_selection_counter` by `1`, and returns the updated value. This attribute
    is initialized to `0` in the `test_play` method. To better understand this code,
    add some `print` statements to these two methods, and execute the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output on executing the test is shown in the following screenshot. Notice
    that it does not print the user prompts such as Continue attack?(y/n) in the command-line
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Third unit test – The play method](img/B05034_05_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Is your code covered?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Is there a way to check how well you are doing as far as testing is concerned?
    How much code is covered by the unit tests? For this, you need a Python package
    called `coverage`. It can be installed using pip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates an executable called `coverage` at the same location
    as your Python installation. In Linux, if Python 3 is installed in `/usr/bin/`,
    `coverage` will be available at the same location as `/use/bin/coverage`. In Windows
    OS, it will be available in the `Scripts` directory, at the same location as `pip.exe`.
    Run the `coverage` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is a combination of two commands separated by `&&` and executed
    one after the other. The first command runs the tests: `coverage run -m test.test_wargame`.
    This is similar to how we run the unit tests. The `run` option runs a Python program,
    and measures the code execution. As noted before, the `-m` option instructs `coverage`
    to consider the next argument as an importable Python module instead of treating
    it as a script. This is why we specify the next argument as `test.test_wargame`
    (just like an `import` statement) instead of writing `test/test_wargame.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second command, `coverage report`, generates the report indicating the
    test coverage. Here is how the coverage report is presented after running this
    command. For ease of illustration, the output pertaining to the execution of the
    test cases (the first command) is not shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Is your code covered?](img/B05034_05_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see a different coverage report, try disabling some tests in `test_wargame.py`,
    and rerun the `coverage` command noted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving import errors, if any
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Read this section only if you encounter any import errors while executing the
    coverage. If you run `coverage` as instructed, you are unlikely to encounter any
    import errors such as no module named `knight`. In other words, run the test from
    the top-level directory `wargame`, and make sure to run it as a module (the `-m`
    option) instead of a script. If you run `coverage` in the following way, you would
    likely see import errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, it is unable to find the right `PATH` for the modules
    from the `wargame` directory. Make sure that both `wargame` and `test` directories
    are in your `sys.path`. One quick and dirty hack is to add the following code
    to `test_wargame.py`. Assuming you are running coverage from within the `test`
    directory, add the following code before the `import` statements, such as `from
    knight import Knight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Other unit testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have exclusively used the built-in `unittest` framework
    for writing the tests. There are several other tools available for unit testing
    that were not discussed. The purpose of this section is only to introduce you
    to the other unit testing tools available out there besides the built-in `unittest`
    module. For instance, there are tools such as nose or pytest that make it easier
    to write the unit tests to a large extent. Let's briefly review some of these
    unit testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a built-in module, which looks for text that resembles Python code
    written in an interpreter. Here is a trivial example that shows a docstring with
    an example usage of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Doctest** identifies such code, and runs it to check if it really does what
    it says. This is quite an effective way to verify the correctness of the code
    examples you write in the documentation and/or in the docstrings. While this is
    very useful, it is worth noting here that the extensive code samples in the docstring
    could be distracting. See [https://docs.python.org/3/library/doctest.html#module-doctest](https://docs.python.org/3/library/doctest.html#module-doctest)
    for further details.'
  prefs: []
  type: TYPE_NORMAL
- en: Nose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nose is a popular third-party tool that simplifies writing and running unit
    tests. Install it using pip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Nose extends `unittest`. One of the advantages of using this tool is it doesn''t
    require you to write tests as inherited class methods of `unittest.TestCase`.
    You can even write tests as separate functions. Let''s write a simple test, and
    run it with `nosetests`. Create the following function in a file called `test_nose.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this test from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. It will run the test. Obviously, this test will pass. As can be
    seen, we did not need to put the test inside the subclass of `unittest.TestCase`.
    The function name needs to contain `test` or `Test`, since we are using the default
    nose configuration. Try renaming the function so that it does not have the word
    `test`. For example, name it `foo_a`. If you run `nosetests` again, it will exclude
    this function. To consider function names that do not have the word `test`, use
    the command-line option `--tests` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See [https://nose.readthedocs.org](https://nose.readthedocs.org) to learn how
    to use nose effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Pytest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pytest is yet another popular tool that simplifies writing unit tests. It can
    be installed using `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the same test we wrote for nose. Let''s save the following code
    in a file, `test_pytest.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding test from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See [http://pytest.org/](http://pytest.org/) to find out more about this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring preamble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write one more unit test for the game. This time we will focus our attention
    on the main class `AttackOfTheOrcs`. When the `play` method is called, the first
    thing it does is to randomly occupy the five huts. We will write a test to verify
    that there are exactly five huts. Another thing to test is that the hut occupant
    must be an instance of the class `AbstractGameUnit`, or should be of the type
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The `_occupy_hut` method has the related code. But this necessitates writing
    a test for a non-public method (or call it protected or private).
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring preamble](img/B05034_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *What you say is right! Although Python does not restrict you from calling
    methods that start with an underscore, we should be nice to others, and try to
    avoid calling such methods.* |'
  prefs: []
  type: TYPE_TB
- en: 'So how do we handle this situation? Here is a list of the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: In the test, create an instance of `AttackOfThOrcs`, and directly call the protected
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform this method into a `public` method (remove the underscore prefix from
    the name).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `play` method, which then calls `_occupy_huts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the `play` method, and wrap the `_occupy_huts` into a `public` method
    that could be tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already have a moral conflict with the first option, as `_occupy_huts` is
    a non-public method. The second option suggests turning it into a `public` method.
    That is possible, but if this method is not supposed to be called from outside
    for any reason, we should avoid such a change. We will keep this option in mind,
    and look for some other alternative.
  prefs: []
  type: TYPE_NORMAL
- en: The third option needs to call the `play` method. We have already done that
    in the last example using the patch decorator. Although possible, it is inefficient
    to run a large block of code for testing a small functionality. Let's leave that
    option aside for now. The fourth option suggests refactoring the code. Let's discuss
    it further.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the simple application that we have developed, there is no harm in changing
    `_occupy_huts` to a `public` method! We could simply rename it `occupy_huts` (no
    underscore prefix), then update the calling code, and happily write a test! In
    fact, renaming is also a form of refactoring that will be covered next. In the
    real world, however, you may not have the luxury to transform a protected method
    to a public one. Keeping this situation in mind, we will refactor the code to
    illustrate one way of making the code test friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Take a detour – Refactor for testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 4 in the previous section needs us to refactor the play method before writing
    the test. This refactoring will improve our ability to write cleaner tests. So
    what is refactoring? How is it performed? The good news is that you have already
    done a form of refactoring in [Chapter 1](ch01.html "Chapter 1. Developing Simple
    Applications"), *Developing Simple Applications* while transforming the initial
    command-line script into a set of functions. Let's take a detour and learn some
    refactoring techniques. We will then come back with the refactored code, and develop
    the final unit test for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already come across the word refactoring in earlier chapters, and might
    have wondered what it means. An explanation is in order.
  prefs: []
  type: TYPE_NORMAL
- en: Just look around. Peep inside your closet or open your desk drawer. On day one,
    everything looks tidy and manageable. The drawer is meant to store all your important
    financial documents. Things begin to accumulate over time, and the drawer is now
    stuffed with not just with financial documents, but anything varying from scribbled
    notes, office documents, to greeting cards. Very soon, you cannot find that important
    document you need right now. You spend a lot of time digging out what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The golden moment finally arrives. You begin the cleanup operation! Several
    things are found to be useless, and are thrown away. A few other things are still
    useful, such as tickets to a football game next week. You move this stuff to a
    different drawer where it really belongs. You also find several papers laying
    around belonging to a single category: house maintenance bills. You put these
    papers together inside a single folder. Finally, with all this rearrangement and
    cleanup, your drawer breathes the new day one!'
  prefs: []
  type: TYPE_NORMAL
- en: What is refactoring?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring is something very similar to your desk drawer. The application code
    is analogous to the drawer filled with documents. As the code evolves, both the
    good and bad stuff creeps in. From outside, the behavior of the drawer remains
    the same. You can still put documents (code) in it, and business goes on as usual.
    In the absence of refactoring, someday it reaches a tipping point, and becomes
    non-accommodating to new documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With refactoring, you make internal changes to your code without affecting its
    external behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Why refactor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The short answer is, do it if you wish your code a long and healthy life! Timely
    refactoring is important to keep the code maintainable and extensible. You could
    rather spend more time working on a cool new feature than burning the midnight
    oil to fix a petty issue—a bug that could have been fixed within minutes had the
    code been properly maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refactoring should be more of a habit than an obligation.
  prefs: []
  type: TYPE_NORMAL
- en: When to refactor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So when do we refactor the code? You have to seek the optimal balance. If you
    realize it too late in the development life cycle, it affects productivity, as
    you would need to spend a considerable amount of time doing the code cleanup.
    Many times, the project deadline makes you turn your back on refactoring. Unfortunately,
    the user-visible part of the software wins over the internal cleanup. You only
    think of the immediate deliverable, and overlook the fact that refactoring will
    only help you deliver the product faster.
  prefs: []
  type: TYPE_NORMAL
- en: One strategy is to review the code at fixed intervals, and allocate some time
    for refactoring. If you are following a **Scrum** methodology, you can devote
    a sprint to some smaller refactoring projects. Such maintenance sprint will pay
    off in the long run. If you are staring at a big legacy code that needs immediate
    refactoring for survival, the required changes could be disruptive. In such situations,
    consider breaking it down into smaller problems, and use the other strategy discussed
    in the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Agile development methodology**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is often tied to a set of non-traditional software development methods
    for managing a project. In this method, you define targets achievable in a short
    time duration. There are regular checkpoints known as sprints or iterations. The
    end of a sprint should result in an incremental and releasable version of the
    product. This is useful in complex projects, where it is tough to plan the complete
    project, or predict what to expect next because of the dynamic nature of the project.
    The methodology adopts an incremental and iterative approach to handle this task.
    For further reading, see the following wiki page: [https://en.wikipedia.org/wiki/Agile_software_development](https://en.wikipedia.org/wiki/Agile_software_development).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scrum**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a product development methodology. It is a framework based on the agile
    development methodology for managing complex systems. It implements an incremental
    and iterative (sprints) strategy for product development. The following is the
    link to the wiki for further details: [https://en.wikipedia.org/wiki/Scrum_(software_development)](https://en.wikipedia.org/wiki/Scrum_(software_development)).'
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy is to take up the refactoring task immediately after a major
    release. The customers just got what they were asking for. In the absence of any
    show-stopper bugs, you would typically find some free work cycles during this
    period. It is a good time for the next release planning and working on code refactoring
    tasks. This will vary from project to project. It depends on how actively the
    application is being developed, its size, architecture, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to refactor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen what refactoring means, let's see how to do it. The first
    task is to identify the piece of trouble-making code, and then restructure it.
    The restructuring should not affect the external behavior of the code. At the
    same time, it should help make the developer's life easy by simplifying the internal
    machinery (the code). We will discuss some of the most commonly performed refactoring
    operations. To help understand these operations, we will use the UML-like representative
    blocks wherever appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** (**UML**) representation. See [http://www.uml.org](http://www.uml.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a developer introducing a new feature in the game *Attack of the Orcs*.
    Each hut has a secret box. Whenever a unit acquires a hut, the contents of the
    box are revealed to the new owner as a print statement. This developer has introduced
    a new method called `showStuff()` in the class `Hut`. However, the name used here
    is not intuitive. It is not clear whether it shows what is inside the box, or
    whether it gives some information about some other stuff in the hut. Renaming
    such methods is one of the simplest forms of code refactoring. You could rename
    it to something verbose, such as `show_box_contents` or `reveal_box_contents`.
    However, make sure you perform the renaming task thoroughly by renaming all the
    method calls as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Coding standards**:'
  prefs: []
  type: TYPE_NORMAL
- en: This example brings forward an interesting topic, the Python coding standards.
    In case you have jumped straight to this chapter, read [Chapter 4](ch04.html "Chapter 4. Documentation
    and Best Practices"), *Documentation and Best Practices* that talks about the
    coding standards! These standards basically provide a coding style guide for Python
    programmers. Following these standards and defining your own guidelines for the
    project would help reduce such renaming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications* we had a single script representing the game. We identified
    pieces of code that could be written as individual functions. The name of each
    function was chosen such that it represented what the function body was supposed
    to do. This is shown in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting](img/B05034_05_31.jpg)![Extracting](img/B05034_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This refactoring operation is called function extraction. Likewise, you can
    group together relevant code fragments to extract a method within a class or extract
    a new class.
  prefs: []
  type: TYPE_NORMAL
- en: Moving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy!* we did yet another type of refactoring operation. Can you guess
    what it was? The application code was contained within a single file. We modularized
    it by moving each class to its own file, and updating the referenced code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a method of Class A, which is used mostly by various features
    in Class B. Depending on the nature of the problem, see if this method better
    fits in Class B than in the existing Class A. If it does, moving this method to
    Class B could be an option.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing down
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a new feature request. This time it is coming from Sir Foo!
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing down](img/B05034_05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Knight` and `OrcRider` are mounted units riding a horse and a wild boar-like
    creature respectively. You introduced a new method, `unmount`, in the superclass
    `AbstractGameUnit`. It gives them the ability to get off the animal they are riding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing down](img/B05034_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, you have now introduced several other imaginary characters in the
    game. For a majority of the characters, the method has become irrelevant. Now
    it makes sense to push down the `unmount` method in the inheritance hierarchy
    to the subclasses where it is relevant. This is shown in the diagram that follows.
    The `unmount` method is moved to the subclasses `Knight` and `OrcRider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing down](img/B05034_05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While pulling up (see the next heading) or pushing down type of refactoring
    simplifies things, it may not always serve its purpose. The `unmount` method was
    intended just as an illustration. The horse is associated with movement. One option
    is to define a move behavior here. For example, move using a horse, move using
    a wild boar, and so on. Another alternative is to define the unit types as mounted
    or unmounted. Refer to [Chapter 6](ch06.html "Chapter 6. Design Patterns"), *Design
    Patterns* on design patterns, which shows an elegant way to handle a similar situation.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the opposite of pushing down, where we use the inheritance principle.
    A subclass defines some functionality. The exact same method is defined in other
    subclasses. This method can be pulled up and defined in the superclass to make
    it available to all the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tools for Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are tools that automate certain types of refactoring. For example, if
    you want to rename a method, the tool will rename it, and automatically update
    all the references to the method in the code. Here is a partial list of such tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a Python IDE**: Assuming you are using an IDE for Python application
    development, the most convenient option is to use the built-in features of the
    IDE to refactor the code. IDEs such as PyCharm provide a menu item for refactoring,
    and support the most frequently performed refactoring operations, like the ones
    discussed in previous sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rope**: Rope is an open source library for refactoring Python code. If you
    are a fan of editors such as vim or emacs, plugins are available to integrate
    the refactoring feature in the editor. The library can be installed using pip.
    For more information, see the GitHub page [https://github.com/python-rope](https://github.com/python-rope).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bicycle repair man**: This is another refactoring tool available for Python.
    The library can be installed using pip. Visit [https://pypi.python.org/pypi/bicyclerepair](https://pypi.python.org/pypi/bicyclerepair)
    for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a quick recap of where we left the discussion on unit testing. The intention
    was to write a unit test for the functionality found in the non-public method,
    `AttackOfTheOrcs._occupy_huts`. One straightforward option was to call this method
    directly from the unit test. However, calling a non-public method is not considered
    best practice, so we started looking for alternatives. Another option was to refactor
    `AttackOfTheOrcs.play`, and use an extracted `public` method in the unit test.
    At this point, we took a detour from unit testing and learned the basics of refactoring.
    Now it is time to refactor `AttackOfTheOrcs.play` using the techniques we have
    just learned.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for the game *Attack of the Orcs* gives enough opportunity
    for refactoring. The `play` method is shown next. The code comments are omitted
    for the sake of illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring for testability](img/B05034_05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first part of the preceding code does some preparatory work to create the
    objects needed. It creates the `Knight` and the `Hut` instances, along with the
    objects that represent the hut occupants. Additionally, it prints some information
    on the game. As an initial refactoring, we will extract a new `public` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring for testability](img/B05034_05_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The new method primarily improves code readability, and also makes it simpler
    to write a test.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in the *Refactoring preamble* section, this is a toy problem. The refactoring
    strategy used here is to extract a new method for improved readability and testability.
    You could refactor this by some other means as well. For example, the setup code
    creates things such as the player and huts. May be you should also rename `_occupy_huts`
    to `create_huts`? Choices may vary, and so do the refactoring strategies. More
    than answering the question what is the best strategy to refactor here, this section
    mainly serves as an example of how refactoring could help simplify the task of
    writing a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: This basic refactoring of the `play` method will enable writing a unit test
    for the `setup_game_scenario` method, which in turn, will help test the functionality
    in `_occupy_huts`.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth unit test – setup_game_scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed in the *Refactoring preamble* section, this test will verify the
    following things: (a) there are exactly five huts, and (b) the hut occupant is
    an instance of `AbstractGameUnit`, or of the type `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This test is shown next. You can also find this test in the supporting code
    along with the other tests. See the `wargame/test/test_wargame.py` file. The code
    comments should make it self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fourth unit test – setup_game_scenario](img/B05034_05_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the preceding unit test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some exercises have already been suggested in various sections of this chapter.
    Try those exercises. For example, split the unit tests so that you have separate
    modules for testing functionality from different classes. Add more unit tests
    to improve the code coverage. Also, try running `nosetests` on the tests that
    we have already written.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and redesign exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several low-hanging fruits for refactoring! Review the `AttackOfTheOrcs._occupy_huts`
    method. It creates hut objects, and puts an occupant in each of them. As the first
    step, you can rename it `create_huts`. The code in this method could be better
    written. It uses `if...else` conditions to decide which occupant to create. Although
    it works in this simple application, if you add other types of occupant (elves,
    dwarfs, wizards, and so on) it will become a maintenance headache.
  prefs: []
  type: TYPE_NORMAL
- en: 'What could we do here? One strategy is to let the `Hut` class manage the creation
    of the `occupant` object. The hut could ask a factory to randomly create an occupant.
    You will learn about the factory pattern in [Chapter 6](ch06.html "Chapter 6. Design
    Patterns"), *Design Patterns*. Since we are looking at this as a refactoring problem,
    you could try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the signature of `Hut.__init__` so that you can optionally specify the
    `occupant`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `Hut` class, create an `occupant` (if not already available) by calling
    a new utility function, `create_unit`. You will need to write this new utility
    function (the solution is not provided). The function should not be a method of
    the class `Hut`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter started by emphasizing the need for testing. It introduced you to
    the unit testing framework in Python. You learned how to write and execute unit
    tests. The next topic served as an introduction to Python mock library. The chapter
    demonstrated the use of `Mock` objects in unit tests. Next, it showed an example
    where it was difficult to write a unit test without refactoring the code first.
    At this point, you learned the basics of refactoring, refactored the code, and
    then developed a unit test for this example.
  prefs: []
  type: TYPE_NORMAL
- en: During development, you often encounter a recurring problem. Often, a general
    solution (or a recipe) exists that works for this problem. This is often referred
    to as a design pattern. In the next chapter, we will review a few commonly used
    design patterns in Python.
  prefs: []
  type: TYPE_NORMAL
