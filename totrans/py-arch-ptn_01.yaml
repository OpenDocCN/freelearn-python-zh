- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Software Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构简介
- en: The objective of this chapter is to present an introduction to what software
    architecture is and where it's useful. We will look at some of the basic techniques
    used when defining the architecture of a system and a baseline example of the
    web services architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是介绍什么是软件架构以及它在哪些方面有用。我们将探讨在定义系统架构时使用的一些基本技术，以及网络服务架构的基线示例。
- en: This chapter includes a discussion of the implications that software structure
    has for team structure and communication. As the successful building of any non-tiny
    piece of software depends heavily on successful communication and collaboration
    between one or more teams of multiple developers, this factor should be taken
    into consideration. Also, the structure of the software can have a profound effect
    on how different elements are accessed, so how software is structured has ramifications
    for security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了软件结构对团队结构和沟通的影响。由于任何非微小的软件的成功构建都严重依赖于一个或多个开发团队之间的成功沟通和协作，因此应考虑这一因素。此外，软件的结构可能对如何访问不同元素有深远的影响，因此软件的结构对安全性有影响。
- en: Also, in this chapter, there will be a brief introduction to the architecture
    of an example system that we will be using to present the different patterns and
    discussions throughout the rest of the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将简要介绍我们将使用来展示本书其余部分不同模式和讨论的示例系统的架构。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining the structure of a system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义系统的结构
- en: Dividing into smaller units
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其划分为更小的单元
- en: Conway's Law in software architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构中的康威定律
- en: General overview of the example
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例的一般概述
- en: Security aspects of software architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构的安全性方面
- en: Let's dive in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨。
- en: Defining the structure of a system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义系统的结构
- en: At its core, software development is about creating and managing complex systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的本质是创建和管理复杂系统。
- en: In the early days of computing, programs were relatively simple. At most, they
    perhaps could calculate a parabolic trajectory or factorize numbers. The very
    first computer program, designed in 1843 by Ada Lovelace, calculated a sequence
    of Bernoulli numbers. A hundred years after that, during the Second World War,
    electronic computers were invented to break encryption codes. As the possibilities
    of the new invention started to be explored, more and more complex operations
    and systems were designed. Tools like compilers and high-level languages multiplied
    the number of possibilities and the rapid advancement of hardware allowed more
    and more operations to be performed. This quickly created a need to manage the
    growing complexity and apply consistent engineering principles to the creation
    of software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，程序相对简单。最多，它们可能能够计算抛物线轨迹或分解数字。最早的计算机程序是由阿达·洛芙莱斯在1843年设计的，计算了伯努利数列。在那之后的一百年，在第二次世界大战期间，电子计算机被发明出来以破解加密代码。随着这一新发明可能性的探索，越来越多的复杂操作和系统被设计出来。编译器和高级语言等工具增加了可能性的数量，硬件的快速进步使得更多的操作得以执行。这迅速产生了管理不断增长的复杂性和将一致性的工程原则应用于软件创建的需求。
- en: More than 50 years after the birth of the computing industry, the software tools
    at our disposal are incredibly varied and powerful. We stand on the shoulders
    of giants to build our own software. We can quickly add a lot of functionalities
    with relatively little effort, either leveraging high-level languages and APIs
    or using out-of-the-box modules and packages. With this great power comes the
    great responsibility of managing the explosion of complexity that it produces.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机产业诞生50多年后，我们可用的软件工具种类繁多且功能强大。我们站在巨人的肩膀上构建自己的软件。我们可以以相对较小的努力快速添加许多功能，无论是利用高级语言和API，还是使用现成的模块和包。随着这种巨大的力量而来的是管理由此产生的复杂性爆炸的巨大责任。
- en: In the most simple terms, software architecture defines the structure of a software
    system. This architecture can develop organically, usually in the early stages
    of a project, but after system growth and a few change requests, the need to think
    carefully about the architecture becomes more and more important. As the system
    becomes bigger, the structure becomes more difficult to change, which affects
    future efforts. It's easier to make changes following the structure rather than
    against the structure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，软件架构定义了软件系统的结构。这种架构可以有机地发展，通常在项目的早期阶段，但在系统增长和几个变更请求之后，仔细思考架构的需求变得越来越重要。随着系统变得更大，结构变得更难以更改，这会影响未来的努力。遵循结构进行更改比违反结构进行更改更容易。
- en: Making it so that certain changes are difficult to do is not necessarily always
    a bad thing. Changes that *should* be made difficult could involve elements that
    need to be overseen by different teams or perhaps elements that can affect external
    customers. While the main focus is to create a system that's easy and efficient
    to change in the future, a smart architectural design will have a proper balance
    of ease and difficulty based on the requirements. Later in the chapter, we will
    study security as a clear example of when to keep certain operations difficult
    to implement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使某些更改变得困难并不一定是坏事。应该变得困难的更改可能涉及需要由不同团队监督的元素，或者可能影响外部客户的元素。虽然主要重点是创建一个未来易于且高效更改的系统，但一个明智的架构设计将根据需求在易用性和难度之间取得适当的平衡。在本章的后面部分，我们将研究安全作为一个明确的例子，说明何时保持某些操作难以实施。
- en: 'At the core of software architecture, then, is taking a look at the big picture:
    to focus on where the system is going to be in the future, to be able to materialize
    this view, but also to help the present situation. The usual choice between short-term
    wins and long-term operation is very important in development, and its most common
    outcome is the creation of technical debt. Software architecture deals mostly
    with long-term implications.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，软件架构的核心是审视全局：关注系统未来将处于何种状态，能够将这种观点具体化，同时也帮助当前情况。在短期收益和长期运营之间的选择在开发中非常重要，其最常见的后果是技术债务的产生。软件架构主要处理长期影响。
- en: 'The considerations for software architecture can be quite numerous and there
    needs to be a balance between them. Some examples may include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构的考虑因素可能相当多，需要在它们之间取得平衡。一些例子可能包括：
- en: '**Business vision**, if the system is going to be commercially exploited. This
    may include requirements coming from stakeholders like marketing, sales, or management.
    Business vision is typically driven by customers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务愿景**，如果系统将要进行商业利用。这可能包括来自营销、销售或管理的利益相关者的需求。业务愿景通常由客户驱动。'
- en: '**Technical requirements**, like being sure that the system is scalable and
    can handle a certain number of users, or that the system is fast enough for its
    use case. A news website requires different update times than a real-time trading
    system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术要求**，例如确保系统可扩展并能处理一定数量的用户，或者系统足够快以适应其用例。新闻网站需要与实时交易系统不同的更新时间。'
- en: '**Security and reliability concerns**, the seriousness of which depends on
    how risky or critical the application and the data stored are.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和可靠性问题**，其严重性取决于应用程序和数据存储的风险或关键程度。'
- en: '**Division of tasks**, to allow multiple teams, perhaps specialized in different
    areas, to work in a flexible way at the same time on the same system. As systems
    grow, the need to divide them into semi-autonomous, smaller components becomes
    more pressing. Small projects may live longer with a "single-block" or monolithic
    approach.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务划分**，允许多个团队，可能在不同领域专业化，同时以灵活的方式在同一系统上工作。随着系统的发展，将它们划分为半自主的、更小的组件的需求变得更加迫切。小型项目可能通过“单一块”或单体方法存在得更久。'
- en: '**Use specific technologies**, for example, to allow integration with other
    systems or leverage the existing knowledge in the team.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用特定技术**，例如，允许与其他系统集成或利用团队中现有的知识。'
- en: These considerations will influence the structure and design of a system. In
    a sense, the software architect is responsible for implementing the application
    vision and matching it with the specific technologies and teams that will develop
    it. That makes the software architect an important intermediary between the business
    teams and the technology teams, as well as between the different technology teams.
    Communication is a critical aspect of the job.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑将影响系统的结构和设计。在某种程度上，软件架构师负责实现应用程序的愿景，并将其与将开发它的特定技术和团队相匹配。这使得软件架构师成为业务团队和技术团队之间，以及不同技术团队之间的重要中间人。沟通是这个职位的一个关键方面。
- en: To enable successful communication, a good architecture should define boundaries
    between the different aspects and assign clear responsibilities. The software
    architect should, in addition to defining clear boundaries, facilitate the creation
    of interface channels between the system components and follow up on the implementation
    details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现成功的沟通，一个好的架构应该定义不同方面之间的边界，并分配明确的职责。除了定义清晰的边界之外，软件架构师还应促进系统组件之间的接口通道的创建，并跟进实施细节。
- en: Ideally, the architectural design should happen at the beginning of system design,
    with a well thought-out design based on the requirements for the project. This
    is the general approach in this book because it's the best way to explain the
    different options and techniques. But it's not the most common use case in real
    life.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，架构设计应该在系统设计之初进行，基于项目需求进行深思熟虑的设计。这是本书中的一般方法，因为这是解释不同选项和技术最佳的方式。但在现实生活中，这并不是最常见的用例。
- en: One of the main challenges for a software architect is working with existing
    systems that need to be adapted, making incremental approaches toward a better
    system, all while not interrupting the normal daily operation that keeps the business
    running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师面临的主要挑战之一是处理需要适应的现有系统，朝着更好的系统逐步改进，同时不中断保持业务运行的正常日常运营。
- en: Division into smaller units
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将系统划分为更小的单元
- en: The main technique for software architecture is to divide the whole system into
    smaller elements and describe how they interact with each other. Each smaller
    element, or unit, should have a clear function and interface.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构的主要技术是将整个系统划分为更小的元素，并描述它们如何相互交互。每个较小的元素或单元应该有一个明确的职能和接口。
- en: 'For example, a common architecture for a typical system could be a web service
    architecture composed of:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个典型系统的常见架构可能是一个由以下部分组成的网络服务架构：
- en: A database that stores all the data in MySQL
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个存储所有数据的MySQL数据库
- en: A web worker that serves dynamic HTML content written in PHP
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供用PHP编写的动态HTML内容的网络工作者
- en: An Apache web server that handles all the web requests, returns any static files,
    like CSS and images, and forwards the dynamic requests to the web worker
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Apache网络服务器处理所有网络请求，返回任何静态文件，如CSS和图像，并将动态请求转发给网络工作者
- en: '![Diagram'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图解'
- en: Description automatically generated](img/B17580_01_01.png)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_01_01.png)
- en: 'Figure 1.1: Typical web architecture'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：典型的网络架构
- en: 'This architecture and tech stack has been extremely popular since the early
    2000s and was called LAMP, an acronym made from the different open source projects
    involved: (L)inux as an operating system, (A)pache, (M)ySQL, and (P)HP. Nowadays,
    the technologies can be swapped for equivalent ones, like using PostgreSQL instead
    of MySQL or Nginx instead of Apache, but still using the LAMP name. The LAMP architecture
    can be considered the default starting point when designing web-based client/server
    systems using HTTP, creating a solid and proven foundation to start building a
    more complex system.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构和技术堆栈自2000年代初以来一直非常流行，被称为LAMP，这是一个由涉及的不同开源项目组成的缩写：(L)inux作为操作系统，(A)pache，(M)ySQL，和(P)HP。如今，这些技术可以被替换为等效的技术，例如使用PostgreSQL代替MySQL或Nginx代替Apache，但仍然使用LAMP这个名字。LAMP架构可以被认为是使用HTTP设计基于网络的客户端/服务器系统的默认起点，为构建更复杂的系统提供了一个坚实和经过验证的基础。
- en: As you can see, every different element has a distinct function in the system.
    They interact with each other in clearly defined ways. This is known as the **Single-Responsibility
    principle**. When presented with new features, most use cases will fall clearly
    within one of the elements of the system. Any style changes will be handled by
    the web server and dynamic changes by the web worker. There are dependencies between
    the elements, as the data stored in the database may need to be changed to support
    dynamic requests, but they can be detected early in the process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个不同的元素在系统中都有独特的功能。它们以明确定义的方式相互交互。这被称为**单一职责原则**。当面对新功能时，大多数用例将明确属于系统的一个元素。任何样式更改将由Web服务器处理，动态更改由Web工作器处理。元素之间存在依赖关系，因为数据库中存储的数据可能需要更改以支持动态请求，但这些依赖关系可以在处理过程中早期检测到。
- en: We will describe this architecture in greater detail in *Chapter 9*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第9章*中更详细地描述这种架构。
- en: 'Each element has different requirements and characteristics:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都有不同的需求和特性：
- en: The database needs to be reliable, as it stores all the data. Maintenance work
    like backup- and recovery-related work will be important. The database won't be
    updated very frequently, as databases are very stable. Changes to the table schemas
    will be made through restarts in the web worker.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库需要可靠，因为它存储了所有数据。维护工作，如备份和恢复相关的工作，将非常重要。数据库不会频繁更新，因为数据库非常稳定。对表架构的更改将通过Web工作器中的重启进行。
- en: The web worker needs to be scalable and not store any state. Instead, any data
    will be sent and received from the database. This element will be updated often.
    Multiple copies can be run, either in the same machine or in multiple ones to
    allow horizontal scalability.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web工作器需要可扩展且不存储任何状态。相反，所有数据都将从数据库发送和接收。这个元素将经常更新。可以在同一台机器或多台机器上运行多个副本，以实现水平扩展。
- en: The web server will require some changes for new styling, but that won't happen
    very often. Once the configuration is properly set up, this element will remain
    quite stable. Only one web server per machine is required, as it's capable of
    load-balancing between multiple web workers.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器可能需要一些新的样式更改，但这不会经常发生。一旦配置设置正确，这个元素将保持相当稳定。每台机器只需要一个Web服务器，因为它能够平衡多个Web工作器的负载。
- en: As we can see, the work balance between elements is very different, as the web
    worker will be the focus for most new work, while the other two elements will
    be much more stable. The database will require specific work for us to be sure
    that it's in good shape, as it's arguably the most critical element of the three.
    The other two can recover quickly if there's a problem, but any corruption in
    the database will generate a lot of problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，元素之间的工作平衡非常不同，因为Web工作器将是大多数新工作的焦点，而其他两个元素将更加稳定。数据库需要特定的工作以确保其处于良好状态，因为它可以说是三个元素中最关键的一个。其他两个元素在出现问题时可以快速恢复，但数据库中的任何损坏都会引发大量问题。
- en: The most critical and valuable element of a system is almost always the stored
    data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中最关键和最有价值的元素几乎总是存储的数据。
- en: The communication protocols are also unique. The web worker talks to the database
    using SQL statements. The web server talks to the web worker using a dedicated
    interface, normally FastCGI or a similar protocol. The web server communicates
    with the external clients via HTTP requests. The web server and the database don't
    talk to each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议也是独特的。Web工作器使用SQL语句与数据库进行通信。Web服务器通过专用接口与Web工作器通信，通常是FastCGI或类似的协议。Web服务器通过HTTP请求与外部客户端通信。Web服务器和数据库之间不直接通信。
- en: These three protocols are different. This doesn't have to be the case for all
    systems; different components can share the same protocol. For example, there
    can be multiple RESTful interfaces, which is common in microservices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个协议是不同的。对于所有系统来说，情况不一定如此；不同的组件可以共享相同的协议。例如，可以有多个RESTful接口，这在微服务中很常见。
- en: In-process communication
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程内通信
- en: The typical way of looking at different units is as different processes running
    independently, but that's not the only option. Two different modules inside the
    same process can still follow the Single-Responsibility principle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 观察不同单元的典型方式是它们作为独立运行的不同进程，但这不是唯一的选择。同一个进程内的两个不同模块仍然可以遵循单一职责原则。
- en: The Single-Responsibility principle can be applied at different levels and is
    used to define the divisions between functions or other blocks. So, it can be
    applied in smaller and smaller scopes. It's turtles all the way down! But, from
    the point of view of architecture, the higher-level elements are the most important,
    as it's the higher level that defines the structure. Knowing how far to go in
    terms of detail is clearly important, but when taking an architectural approach,
    it is better to err on the "big picture" side rather than the "too much detail"
    one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则可以在不同的层面上应用，并用于定义功能或其他块之间的划分。因此，它可以在越来越小的范围内应用。这是“乌龟一直到底”！但是，从架构的角度来看，高级元素是最重要的，因为它是定义结构的高层。清楚地知道在细节上走多远显然很重要，但在采用架构方法时，最好是偏向“大局”而不是“过多细节”。
- en: A clear example of this would be a library that's maintained independently,
    but it could also be certain modules within a code base. For example, you could
    create a module that performs all the external HTTP calls and handles all the
    complexity of keeping connections, retries, handling errors, and so on, or you
    could create a module to produce reports in multiple formats, based on some parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个清晰的例子是一个独立维护的库，但也可能是代码库中的某些模块。例如，你可以创建一个模块来执行所有的外部HTTP调用，并处理保持连接、重试、错误处理等所有复杂性，或者你可以创建一个模块来根据某些参数生成多种格式的报告。
- en: The important characteristic is that in order to create an independent element,
    the API needs to be clearly defined and the responsibility needs to be well defined.
    It should be possible for the module to be extracted into a different repo and
    installed as a third-party element for it to be considered truly independent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的特性是，为了创建一个独立的元素，API需要被明确定义，责任也需要被明确界定。模块应该能够被提取到不同的仓库中，并作为第三方元素安装，这样才被认为是真正独立的。
- en: Creating a big component with internal divisions only is a well-known pattern
    called a monolithic architecture. The LAMP architecture described above is an
    example of that, as most of the code is defined inside the web worker. Monoliths
    are the usual de facto starts of projects, as normally at the start there's no
    big plan and dividing things strictly into multiple components doesn't have a
    big advantage when the code base is small. As the code base and system grow more
    and more complex, the division of elements inside the monolith starts to make
    sense, and later it may start to make sense to split it into several components.
    We will discuss monoliths further in *Chapter 9*, *Microservices vs Monolith*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建具有内部划分的大组件是一种众所周知的模式，称为单体架构。上面描述的LAMP架构就是这样一个例子，因为大部分代码都是在web worker内部定义的。单体通常是项目的实际默认起点，因为通常在开始时没有大的计划，当代码库较小时，将事物严格划分为多个组件并没有很大的优势。随着代码库和系统的日益复杂，单体内部的元素划分开始变得有意义，后来可能开始有意义地将其拆分为几个组件。我们将在*第9章*，*微服务与单体*中进一步讨论单体。
- en: Inside the same component, communication is typically straightforward, as internal
    APIs will be used. In the vast majority of cases, the same programming language
    will be used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一组件内部，通信通常是直接的，因为会使用内部API。在绝大多数情况下，会使用相同的编程语言。
- en: Conway's Law – Effects on software architecture
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威定律——对软件架构的影响
- en: 'A critical concept to always keep in mind while dealing with architectural
    designs is Conway''s Law. Conway''s Law is a well-known adage that postulates
    that the systems introduced in organizations mirror the communication pattern
    of the organization structure ([https://www.thoughtworks.com/insights/articles/demystifying-conways-law](https://www.thoughtworks.com/insights/articles/demystifying-conways-law)):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理架构设计时始终需要牢记的一个关键概念是康威定律。康威定律是一个广为人知的格言，它假设组织引入的系统反映了组织结构的通信模式([https://www.thoughtworks.com/insights/articles/demystifying-conways-law](https://www.thoughtworks.com/insights/articles/demystifying-conways-law))：
- en: Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization's communication structure.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何设计系统（广义上）的组织都会产生一个结构，其结构与组织的通信结构相匹配。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Melvin E. Conway
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —— 梅尔文·E·康威
- en: This means that the structure of the organization's people is replicated, either
    explicitly or otherwise, to form the software structure created by an organization.
    In a very simple example, a company that has two big departments – say, purchases
    and sales – will tend to create two big systems, one focused on buying and another
    on selling, that talk to each other, instead of other possible structures, like
    a system with divisions by product.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着组织的员工结构，无论是明确还是隐含地，都会被复制，以形成组织创建的软件结构。在一个非常简单的例子中，一个有两个大型部门的公司——比如说采购和销售——可能会倾向于创建两个大型系统，一个专注于采购，另一个专注于销售，它们之间相互通信，而不是其他可能的架构，比如按产品划分的体系。
- en: This can feel natural; after all, communication between teams is more difficult
    than communication within teams. Communication between teams would need to be
    more structured and require more active work. Communication inside a single group
    would be more fluid and less rigid. These elements are key for the design of a
    good software architecture.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉是自然的；毕竟，团队间的沟通比团队内的沟通更困难。团队间的沟通需要更加结构化，并需要更多的主动工作。单个团队内部的沟通会更加流畅，不那么僵化。这些元素对于良好软件架构的设计至关重要。
- en: The main thing for the successful application of any software architecture is
    that the team structure needs to follow the designed architecture quite closely.
    Trying to deviate too much will result in difficulties, as the tendency will be
    to structure, de facto, everything following group divisions. In the same way,
    changing the architecture of a system would likely necessitate restructuring the
    organization. This is a difficult and painful process, as anyone who has experienced
    a company reorganization will attest.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件架构成功应用的主要因素是团队结构需要非常紧密地遵循设计的架构。试图偏离太多会导致困难，因为趋势将是根据群体划分来结构化一切。同样，改变系统的架构可能需要重组组织。这是一个困难和痛苦的过程，任何经历过公司重组的人都会证实这一点。
- en: Division of responsibilities is also a key aspect. A single software element
    should have a clear owner, and this shouldn't be distributed across multiple teams.
    Different teams have different goals and focuses, which will complicate the long-term
    vision and create tensions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 职责划分也是一个关键方面。单个软件元素应该有一个明确的负责人，而且这个负责人不应该分散到多个团队中。不同的团队有不同的目标和重点，这会复杂化长期愿景并产生紧张关系。
- en: The reverse, a single team taking ownership of multiple elements, is definitely
    possible but also requires careful consideration to ensure that this doesn't overstress
    the team.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个团队负责多个元素也是可能的，但这也需要仔细考虑，以确保不会过度压垮团队。
- en: If there's a big imbalance in the mapping of work units to teams (for example,
    too many work units for one team and too few for another team), it is likely that
    there's a problem with the architecture of the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工作单元分配到团队之间的不平衡很大（例如，一个团队的工作单元太多，而另一个团队的工作单元太少），那么很可能是系统的架构存在问题。
- en: As remote work becomes more common and teams increasingly become located in
    different parts of the world, communication is also impacted. That's why it has
    become very common to set up different branches to take care of different elements
    of the system and to use detailed APIs to overcome the physical barriers of geographical
    distance. Communication improvements also have an effect on the capacity for collaboration,
    making remote work more effective and allowing fully remote teams to work closely
    together on the same code base.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着远程工作的日益普遍，团队越来越多地分布在世界的不同地区，沟通也受到了影响。这就是为什么建立不同的分支机构来处理系统的不同元素，并使用详细的API来克服地理距离的物理障碍变得非常普遍。沟通的改善也对协作能力产生了影响，使远程工作更加高效，并允许完全远程的团队能够紧密地共同工作在同一代码库上。
- en: The recent COVID-19 crisis has greatly increased the trend of remote working,
    especially in software. This is resulting in more people working remotely and
    in better tools that are adapted to work in this way. While time zone differences
    are still a big barrier to communication, more and more companies and teams are
    learning to work effectively in full-remote mode. Remember that Conway's Law is
    very much dependent on the communication dependencies of organizations, but communication
    itself can change and improve.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 近期的COVID-19危机极大地增加了远程工作的趋势，尤其是在软件行业。这导致越来越多的人远程工作，并使用适应这种工作方式的更好工具。尽管时区差异仍然是沟通的一个大障碍，但越来越多的公司和团队正在学习以全远程模式有效地工作。记住，康威定律在很大程度上取决于组织的沟通依赖性，但沟通本身可以改变和改进。
- en: Conway's Law should not be considered an impediment to overcome but a reflection
    of the fact that organizational structure has an impact on the structure of the
    software. Software architecture is tightly related to how different teams are
    coordinated and responsibilities are divided. It has an important human communication
    component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律不应被视为需要克服的障碍，而应视为组织结构对软件结构有影响的反映。软件架构与不同团队如何协调以及责任如何划分紧密相关。它包含一个重要的人际沟通成分。
- en: Keeping this in mind will help you design a successful software architecture
    so that the communication flow is fluid at all times and you can identify problems
    in advance. Software architecture is, of course, closely tied to the human factor,
    as the architecture will ultimately be implemented and maintained by engineers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点将有助于您设计一个成功的软件架构，以便在任何时候沟通流程都是流畅的，并且您可以提前识别问题。当然，软件架构与人为因素紧密相关，因为架构最终将由工程师实施和维护。
- en: Application example – Overview
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序示例 – 概述
- en: In this book, we will be using an application as an example to demonstrate the
    different elements and patterns presented. This application will be simple but
    divided into different elements for demonstration purposes. The full code for
    the example is available on GitHub, and different parts of it will be presented
    in the different chapters. The example is written in Python, using well-known
    frameworks and modules.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用一个应用程序作为示例来展示所呈现的不同元素和模式。这个应用程序将简单，但为了演示目的，将分为不同的元素。示例的完整代码可在GitHub上找到，不同章节将展示其不同部分。示例是用Python编写的，使用了知名的框架和模块。
- en: The example application is a web application for microblogging, very similar
    to Twitter. In essence, users will write short text messages that will be available
    for other users to read.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序是一个微博客网络应用程序，非常类似于Twitter。本质上，用户将撰写简短的文本消息，可供其他用户阅读。
- en: 'The architecture of the example system is described in this diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例系统的架构在本图中描述：
- en: '![Diagram'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图](img/Diagram.png)'
- en: Description automatically generated](img/B17580_01_02.png)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_01_02.png)
- en: 'Figure 1.2: Example architecture'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：示例架构
- en: 'It has the following high-level functional elements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下高级功能元素：
- en: A public website in HTML that can be accessed. This includes functionality for
    login, logout, writing new micro-posts, and reading other users' micro-posts (no
    need to be logged in for this).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可访问的公共网站，使用HTML编写。这包括登录、登出、撰写新微帖子以及阅读其他用户的微帖子（阅读不需要登录）的功能。
- en: A public RESTful API, to allow the usage of other clients (mobile, JavaScript,
    and so on) instead of the HTML site. This will authenticate the users using OAuth
    and perform actions similar to the website.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共RESTful API，允许使用其他客户端（移动、JavaScript等）而不是HTML网站。这将使用OAuth对用户进行身份验证并执行类似于网站的操作。
- en: These two elements, while distinct, will be made into a single application,
    as shown in the diagram. The front-facing part of the application will include
    a web server, as we saw in the LAMP architecture description, which has not been
    displayed here for simplicity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素虽然不同，但将被合并成一个单一的应用程序，如图所示。应用程序的前端部分将包括一个Web服务器，正如我们在LAMP架构描述中看到的，这里为了简单起见没有展示。
- en: A task manager that will execute event-driven tasks. We will add periodic tasks
    that will calculate daily statistics and send email notifications to users when
    they are named in a micro-post.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将执行事件驱动任务的任务管理器。我们将添加周期性任务，计算每日统计数据，并在用户被提及在微帖子中时向用户发送电子邮件通知。
- en: A database that stores all the information. Note that access to it is shared
    between the different elements.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库，存储所有信息。请注意，不同元素之间可以共享对它的访问。
- en: Internally, a common package to ensure that the database is accessed correctly
    for all the services. This package works as a different element.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，有一个常见的包来确保所有服务正确访问数据库。这个包作为一个不同的元素工作。
- en: Security aspects of software architecture
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的安全方面
- en: An important element to take into consideration when creating an architecture
    is the security requirements. Not every application is the same, so some can be
    more relaxed in this aspect than others. For example, a banking application needs
    to be 100 times more secure than, say, an internet forum for discussing cats.
    The most common example of this is the storage of passwords. The most naive approach
    to passwords is to store them, in plain text, associated with a username or email
    address – say, in a file or a database table. When the user tries to log in, we
    receive the input password, compare it with the one stored previously, and, if
    they are the same, we allow the user to log in. Right?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建架构时需要考虑的一个重要元素是安全要求。并非每个应用程序都是相同的，因此有些可能在这一点上比其他更宽松。例如，银行应用程序需要比讨论猫的互联网论坛安全100倍。最常见的例子是密码的存储。对密码最天真方法是存储它们，以纯文本形式与用户名或电子邮件地址关联——比如在一个文件或数据库表中。当用户尝试登录时，我们接收输入的密码，将其与之前存储的密码进行比较，如果它们相同，我们允许用户登录。对吧？
- en: 'Well, this is a very bad idea, because it can produce serious problems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是一个非常糟糕的想法，因为它可能会产生严重的问题：
- en: If an attacker has access to the storage for the application, they'll be able
    to read the passwords of all the users. Users tend to reuse passwords (even if
    it's a bad idea), so, paired with their emails, they'll be exposed to attacks
    on multiple applications, not only the breached one.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果攻击者可以访问应用程序的存储，他们将能够读取所有用户的密码。用户倾向于重复使用密码（即使这是一个坏主意），因此，与他们的电子邮件配对，他们将在多个应用程序上暴露于攻击，而不仅仅是被破坏的那个。
- en: This may seem unlikely, but keep in mind that any copy of the data stored is
    susceptible to attack, including backups.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不太可能，但请记住，存储的任何数据副本都容易受到攻击，包括备份。
- en: Another real issue is insider threats, workers who may have legitimate access
    to the system but copy data for nefarious purposes or by mistake. For very sensitive
    data, this can be a very important consideration.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个真实的问题是内部威胁，可能合法访问系统但出于恶意目的或错误地复制数据的员工。对于非常敏感的数据，这可能是一个非常重要的考虑因素。
- en: Mistakes like displaying the password of a user in status logs.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，在状态日志中显示用户密码的错误。
- en: 'To make things secure, data needs to be structured in a way that''s as protected
    as possible from access or even copying, without exposing the real passwords of
    users. The usual solution to this is to have the following schema:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全，数据需要以尽可能保护的方式结构化，防止访问或甚至复制，同时不暴露用户的真实密码。通常的解决方案是采用以下架构：
- en: The password itself is not stored. Instead, a *cryptographical hash* of the
    password is stored. This applies a mathematical function to the password and generates
    a replicable sequence of bits, but the reverse operation is computationally very
    difficult.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码本身并不存储。相反，存储的是密码的加密哈希值。这将对密码应用一个数学函数并生成一个可复制的位序列，但反向操作在计算上非常困难。
- en: As the hash is deterministic based on the input, a malicious actor could detect
    duplicated passwords, as their hashes are the same. To avoid this problem, a random
    sequence of characters, called a *salt*, is added for each account. This will
    be added to each password before hashing, meaning two users with the same password
    but different salts will have different hashes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于哈希值是基于输入的确定性，恶意行为者可以检测到重复的密码，因为它们的哈希值相同。为了避免这个问题，为每个账户添加一个随机字符序列，称为“盐”。这意味着具有相同密码但不同盐的两个用户将具有不同的哈希值。
- en: Both the resulting hash and the salt are stored.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果的哈希值和盐都会被存储。
- en: When a user tries to log in, their input password is added to the salt, and
    the result is compared with the stored hash. If it's correct, the user is logged
    in.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户尝试登录时，他们的输入密码会添加到盐中，然后将结果与存储的哈希值进行比较。如果正确，用户将被登录。
- en: Note that in this design, the actual password is unknown to the system. It's
    not stored anywhere and is only accepted temporarily to compare it with the expected
    hash, after being processed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个设计中，实际密码对系统来说是未知的。它不会被存储在任何地方，只是在临时接受并与预期的哈希值进行比较后进行处理。
- en: This example is presented in a simplified way. There are multiple ways of using
    this schema and different ways of comparing a hash. For example, the `bcrypt`
    function can be applied multiple times, increasing encryption each time, which
    can increase the time required to produce a valid hash, making it more resistant
    to brute-force attacks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是以简化的方式呈现的。有多种使用此模式的方法和比较哈希的不同方式。例如，`bcrypt`函数可以被多次应用，每次加密都会增加，这会增加生成有效哈希所需的时间，使其对暴力攻击更具抵抗力。
- en: This kind of system is more secure than one that stores the password directly,
    as the password is not known by the people operating the system, nor is it stored
    anywhere.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接存储密码的系统相比，这种系统更安全，因为操作系统的人不知道密码，也没有任何地方存储密码。
- en: The problem of mistakenly displaying the password of a user in status logs may
    still happen! Extra care should be taken to make sure that sensitive information
    is not being logged by mistake.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态日志中错误地显示用户密码的问题仍然可能发生！应该格外小心，以确保敏感信息没有被错误地记录。
- en: In certain cases, the same approach as for passwords can be taken to encrypt
    other stored data, so that only customers can access their own data. For example,
    you can enable end-to-end encryption for a communication channel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可以采取与密码相同的方法来加密其他存储数据，以便只有客户可以访问他们自己的数据。例如，可以为通信通道启用端到端加密。
- en: Security has a very close relationship with the architecture of a system. As
    we saw before, the architecture defines which aspects are easy and difficult to
    change and can make some unsafe things impossible to do, like knowing the password
    of a user, as we described in the previous example. Other options include not
    storing data from the user to keep privacy or reducing the data exposed in internal
    APIs, for example. Software security is a very difficult problem and is often
    a double-edged sword, and trying to make a system more secure can have the side
    effect of making operations long-winded and inconvenient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性与系统的架构有着非常紧密的联系。正如我们之前所看到的，架构定义了哪些方面容易改变，哪些方面难以改变，并且可以使某些不安全的行为变得不可能，例如，像我们在上一个例子中所描述的那样，知道用户的密码。其他选项包括不存储用户数据以保持隐私或减少内部API中暴露的数据，例如。软件安全是一个非常困难的问题，通常是一把双刃剑，试图使系统更加安全可能会产生使操作变得冗长和不方便的副作用。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at what software architecture is and when it is required,
    as well as its focus on the long-term approach, which is characteristic of the
    discipline. We learned that the underlying structure of software is difficult
    to change and that that aspect should be taken into consideration when designing
    and changing a software system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了软件架构是什么以及何时需要它，以及它对长期方法的关注，这是该学科的特点。我们了解到软件的底层结构很难改变，因此在设计和更改软件系统时应该考虑这一方面。
- en: We described how the most important thing is to divide a complex system into
    smaller parts and assign clear goals and objectives to each of them, keeping in
    mind that these smaller parts can use multiple programming languages and refer
    to different scopes. We also described the LAMP architecture and how it's a widely
    successful starting point when creating simple web service systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了如何将复杂系统分解成更小的部分，并为每个部分分配清晰的目标和目标，同时考虑到这些较小的部分可以使用多种编程语言并引用不同的范围。我们还描述了LAMP架构以及它如何是创建简单Web服务系统的广泛成功的起点。
- en: We talked about how Conway's Law affects the architecture of a system, as underlying
    team structures have a direct impact on the implementation and structure of software.
    After all, software is operated and developed by humans, and human communication
    needs to be accounted for to implement it successfully.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了康威定律如何影响系统的架构，因为底层团队结构对软件的实现和结构有直接影响。毕竟，软件是由人类操作和开发的，人类沟通需要被考虑到才能成功实施。
- en: We described the example that we will use throughout the book to describe the
    different elements and patterns we will present. Finally, we commented on the
    security aspects of software architecture and how creating barriers to accessing
    data as part of the structural design of a system can mitigate security issues.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了本书中将使用的例子，以描述我们将要展示的不同元素和模式。最后，我们评论了软件架构的安全方面以及如何通过作为系统结构设计一部分的数据访问障碍来缓解安全问题。
- en: In the next section of the book, we will talk about the different aspects of
    designing a system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一节中，我们将讨论设计一个系统的不同方面。
