- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Software Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this chapter is to present an introduction to what software
    architecture is and where it's useful. We will look at some of the basic techniques
    used when defining the architecture of a system and a baseline example of the
    web services architecture.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes a discussion of the implications that software structure
    has for team structure and communication. As the successful building of any non-tiny
    piece of software depends heavily on successful communication and collaboration
    between one or more teams of multiple developers, this factor should be taken
    into consideration. Also, the structure of the software can have a profound effect
    on how different elements are accessed, so how software is structured has ramifications
    for security.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in this chapter, there will be a brief introduction to the architecture
    of an example system that we will be using to present the different patterns and
    discussions throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the structure of a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing into smaller units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conway's Law in software architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General overview of the example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security aspects of software architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the structure of a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, software development is about creating and managing complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of computing, programs were relatively simple. At most, they
    perhaps could calculate a parabolic trajectory or factorize numbers. The very
    first computer program, designed in 1843 by Ada Lovelace, calculated a sequence
    of Bernoulli numbers. A hundred years after that, during the Second World War,
    electronic computers were invented to break encryption codes. As the possibilities
    of the new invention started to be explored, more and more complex operations
    and systems were designed. Tools like compilers and high-level languages multiplied
    the number of possibilities and the rapid advancement of hardware allowed more
    and more operations to be performed. This quickly created a need to manage the
    growing complexity and apply consistent engineering principles to the creation
    of software.
  prefs: []
  type: TYPE_NORMAL
- en: More than 50 years after the birth of the computing industry, the software tools
    at our disposal are incredibly varied and powerful. We stand on the shoulders
    of giants to build our own software. We can quickly add a lot of functionalities
    with relatively little effort, either leveraging high-level languages and APIs
    or using out-of-the-box modules and packages. With this great power comes the
    great responsibility of managing the explosion of complexity that it produces.
  prefs: []
  type: TYPE_NORMAL
- en: In the most simple terms, software architecture defines the structure of a software
    system. This architecture can develop organically, usually in the early stages
    of a project, but after system growth and a few change requests, the need to think
    carefully about the architecture becomes more and more important. As the system
    becomes bigger, the structure becomes more difficult to change, which affects
    future efforts. It's easier to make changes following the structure rather than
    against the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Making it so that certain changes are difficult to do is not necessarily always
    a bad thing. Changes that *should* be made difficult could involve elements that
    need to be overseen by different teams or perhaps elements that can affect external
    customers. While the main focus is to create a system that's easy and efficient
    to change in the future, a smart architectural design will have a proper balance
    of ease and difficulty based on the requirements. Later in the chapter, we will
    study security as a clear example of when to keep certain operations difficult
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of software architecture, then, is taking a look at the big picture:
    to focus on where the system is going to be in the future, to be able to materialize
    this view, but also to help the present situation. The usual choice between short-term
    wins and long-term operation is very important in development, and its most common
    outcome is the creation of technical debt. Software architecture deals mostly
    with long-term implications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The considerations for software architecture can be quite numerous and there
    needs to be a balance between them. Some examples may include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business vision**, if the system is going to be commercially exploited. This
    may include requirements coming from stakeholders like marketing, sales, orÂ management.
    Business vision is typically driven by customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical requirements**, like being sure that the system is scalable and
    can handle a certain number of users, or that the system is fast enough for its
    use case. A news website requires different update times than a real-time trading
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and reliability concerns**, the seriousness of which depends on
    how risky or critical the application and the data stored are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division of tasks**, to allow multiple teams, perhaps specialized in different
    areas, to work in a flexible way at the same time on the same system. As systems
    grow, the need to divide them into semi-autonomous, smaller components becomes
    more pressing. Small projects may live longer with a "single-block" or monolithic
    approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use specific technologies**, for example, to allow integration with other
    systems or leverage the existing knowledge in the team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These considerations will influence the structure and design of a system. In
    a sense, the software architect is responsible for implementing the application
    vision and matching it with the specific technologies and teams that will develop
    it. That makes the software architect an important intermediary between the business
    teams and the technology teams, as well as between the different technology teams.
    Communication is a critical aspect of the job.
  prefs: []
  type: TYPE_NORMAL
- en: To enable successful communication, a good architecture should define boundaries
    between the different aspects and assign clear responsibilities. The software
    architect should, in addition to defining clear boundaries, facilitate the creation
    of interface channels between the system components and follow up on the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the architectural design should happen at the beginning of system design,
    with a well thought-out design based on the requirements for the project. This
    is the general approach in this book because it's the best way to explain the
    different options and techniques. But it's not the most common use case in real
    life.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main challenges for a software architect is working with existing
    systems that need to be adapted, making incremental approaches toward a better
    system, all while not interrupting the normal daily operation that keeps the business
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Division into smaller units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main technique for software architecture is to divide the whole system into
    smaller elements and describe how they interact with each other. Each smaller
    element, or unit, should have a clear function and interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a common architecture for a typical system could be a web service
    architecture composed of:'
  prefs: []
  type: TYPE_NORMAL
- en: A database that stores all the data in MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web worker that serves dynamic HTML content written in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Apache web server that handles all the web requests, returns any static files,
    like CSS and images, and forwards the dynamic requests to the web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_01_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Typical web architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture and tech stack has been extremely popular since the early
    2000s and was called LAMP, an acronym made from the different open source projects
    involved: (L)inux as an operating system, (A)pache, (M)ySQL, and (P)HP. Nowadays,
    the technologies can be swapped for equivalent ones, like using PostgreSQL instead
    of MySQL or Nginx instead of Apache, but still using the LAMP name. The LAMP architecture
    can be considered the default starting point when designing web-based client/server
    systems using HTTP, creating a solid and proven foundation to start building a
    more complex system.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, every different element has a distinct function in the system.
    They interact with each other in clearly defined ways. This is known as the **Single-Responsibility
    principle**. When presented with new features, most use cases will fall clearly
    within one of the elements of the system. Any style changes will be handled by
    the web server and dynamic changes by the web worker. There are dependencies between
    the elements, as the data stored in the database may need to be changed to support
    dynamic requests, but they can be detected early in the process.
  prefs: []
  type: TYPE_NORMAL
- en: We will describe this architecture in greater detail in *Chapter 9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element has different requirements and characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The database needs to be reliable, as it stores all the data. Maintenance work
    like backup- and recovery-related work will be important. The database won't be
    updated very frequently, as databases are very stable. Changes to the table schemas
    will be made through restarts in the web worker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web worker needs to be scalable and not store any state. Instead, any data
    will be sent and received from the database. This element will be updated often.
    Multiple copies can be run, either in the same machine or in multiple ones to
    allow horizontal scalability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server will require some changes for new styling, but that won't happen
    very often. Once the configuration is properly set up, this element will remain
    quite stable. Only one web server per machine is required, as it's capable of
    load-balancing between multiple web workers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the work balance between elements is very different, as the web
    worker will be the focus for most new work, while the other two elements will
    be much more stable. The database will require specific work for us to be sure
    that it's in good shape, as it's arguably the most critical element of the three.
    The other two can recover quickly if there's a problem, but any corruption in
    the database will generate a lot of problems.
  prefs: []
  type: TYPE_NORMAL
- en: The most critical and valuable element of a system is almost always the stored
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The communication protocols are also unique. The web worker talks to the database
    using SQL statements. The web server talks to the web worker using a dedicated
    interface, normally FastCGI or a similar protocol. The web server communicates
    with the external clients via HTTP requests. The web server and the database don't
    talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: These three protocols are different. This doesn't have to be the case for all
    systems; different components can share the same protocol. For example, there
    can be multiple RESTful interfaces, which is common in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In-process communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The typical way of looking at different units is as different processes running
    independently, but that's not the only option. Two different modules inside the
    sameÂ process can still follow the Single-Responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: The Single-Responsibility principle can be applied at different levels and is
    used to define the divisions between functions or other blocks. So, it can be
    applied in smaller and smaller scopes. It's turtles all the way down! But, from
    the point of view of architecture, the higher-level elements are the most important,
    as it's the higher level that defines the structure. Knowing how far to go in
    terms of detail is clearly important, but when taking an architectural approach,
    it is better to err on the "big picture" side rather than the "too much detail"
    one.
  prefs: []
  type: TYPE_NORMAL
- en: A clear example of this would be a library that's maintained independently,
    but it could also be certain modules within a code base. For example, you could
    create a module that performs all the external HTTP calls and handles all the
    complexity of keeping connections, retries, handling errors, and so on, or you
    could create a module to produce reports in multiple formats, based on some parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The important characteristic is that in order to create an independent element,
    the API needs to be clearly defined and the responsibility needs to be well defined.
    It should be possible for the module to be extracted into a different repo and
    installed as a third-party element for it to be considered truly independent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a big component with internal divisions only is a well-known pattern
    called a monolithic architecture. The LAMP architecture described above is an
    example of that, as most of the code is defined inside the web worker. Monoliths
    are the usual de facto starts of projects, as normally at the start there's no
    big plan and dividing things strictly into multiple components doesn't have a
    big advantage when the code base is small. As the code base and system grow more
    and more complex, the division of elements inside the monolith starts to make
    sense, and later it may start to make sense to split it into several components.
    We will discuss monoliths further in *Chapter 9*, *Microservices vs Monolith*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the same component, communication is typically straightforward, as internal
    APIs will be used. In the vast majority of cases, the same programming language
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Conway's Law â Effects on software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A critical concept to always keep in mind while dealing with architectural
    designs is Conway''s Law. Conway''s Law is a well-known adage that postulates
    that the systems introduced in organizations mirror the communication pattern
    of the organization structure ([https://www.thoughtworks.com/insights/articles/demystifying-conways-law](https://www.thoughtworks.com/insights/articles/demystifying-conways-law)):'
  prefs: []
  type: TYPE_NORMAL
- en: Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization's communication structure.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â Melvin E. Conway
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that the structure of the organization's people is replicated, either
    explicitly or otherwise, to form the software structure created by an organization.
    In a very simple example, a company that has two big departments â say, purchases
    and sales â will tend to create two big systems, one focused on buying and another
    on selling, that talk to each other, instead of other possible structures, like
    a system with divisions by product.
  prefs: []
  type: TYPE_NORMAL
- en: This can feel natural; after all, communication between teams is more difficult
    than communication within teams. Communication between teams would need to be
    more structured and require more active work. Communication inside a single group
    would be more fluid and less rigid. These elements are key for the design of a
    good software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The main thing for the successful application of any software architecture is
    that the team structure needs to follow the designed architecture quite closely.
    Trying to deviate too much will result in difficulties, as the tendency will be
    to structure, de facto, everything following group divisions. In the same way,
    changing the architecture of a system would likely necessitate restructuring the
    organization. This is a difficult and painful process, as anyone who has experienced
    a company reorganization will attest.
  prefs: []
  type: TYPE_NORMAL
- en: Division of responsibilities is also a key aspect. A single software element
    should have a clear owner, and this shouldn't be distributed across multiple teams.
    Different teams have different goals and focuses, which will complicate the long-term
    vision and create tensions.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse, a single team taking ownership of multiple elements, is definitely
    possible but also requires careful consideration to ensure that this doesn't overstress
    the team.
  prefs: []
  type: TYPE_NORMAL
- en: If there's a big imbalance in the mapping of work units to teams (for example,
    too many work units for one team and too few for another team), it is likely that
    there's aÂ problem with the architecture of the system.
  prefs: []
  type: TYPE_NORMAL
- en: As remote work becomes more common and teams increasingly become located in
    different parts of the world, communication is also impacted. That's why it has
    become very common to set up different branches to take care of different elements
    of the system and to use detailed APIs to overcome the physical barriers of geographical
    distance. Communication improvements also have an effect on the capacity for collaboration,
    making remote work more effective and allowing fully remote teams to work closely
    together on the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: The recent COVID-19 crisis has greatly increased the trend of remote working,
    especially in software. This is resulting in more people working remotely and
    in better tools that are adapted to work in this way. While time zone differences
    are still a big barrier to communication, more and more companies and teams are
    learning to work effectively in full-remote mode. Remember that Conway's Law is
    very much dependent on the communication dependencies of organizations, but communication
    itself can change and improve.
  prefs: []
  type: TYPE_NORMAL
- en: Conway's Law should not be considered an impediment to overcome but a reflection
    of the fact that organizational structure has an impact on the structure of the
    software. Software architecture is tightly related to how different teams are
    coordinated and responsibilities are divided. It has an important human communication
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind will help you design a successful software architecture
    so that the communication flow is fluid at all times and you can identify problems
    in advance. Software architecture is, of course, closely tied to the human factor,
    as the architecture will ultimately be implemented and maintained by engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Application example â Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will be using an application as an example to demonstrate the
    different elements and patterns presented. This application will be simple but
    divided into different elements for demonstration purposes. The full code for
    the example is available on GitHub, and different parts of it will be presented
    in the different chapters. The example is written in Python, using well-known
    frameworks and modules.
  prefs: []
  type: TYPE_NORMAL
- en: The example application is a web application for microblogging, very similar
    to Twitter. In essence, users will write short text messages that will be available
    for other users to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the example system is described in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_01_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Example architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following high-level functional elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A public website in HTML that can be accessed. This includes functionality for
    login, logout, writing new micro-posts, and reading other users' micro-posts (no
    need to be logged in for this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public RESTful API, to allow the usage of other clients (mobile, JavaScript,
    and so on) instead of the HTML site. This will authenticate the users using OAuth
    and perform actions similar to the website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two elements, while distinct, will be made into a single application,
    as shown in the diagram. The front-facing part of the application will include
    a web server, as we saw in the LAMP architecture description, which has not been
    displayed here for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: A task manager that will execute event-driven tasks. We will add periodic tasks
    that will calculate daily statistics and send email notifications to users when
    they are named in a micro-post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database that stores all the information. Note that access to it is shared
    between the different elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, a common package to ensure that the database is accessed correctly
    for all the services. This package works as a different element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security aspects of software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important element to take into consideration when creating an architecture
    is the security requirements. Not every application is the same, so some can be
    more relaxed in this aspect than others. For example, a banking application needs
    to be 100 times more secure than, say, an internet forum for discussing cats.
    The most common example of this is the storage of passwords. The most naive approach
    to passwords is to store them, in plain text, associated with a username or email
    address â say, in a file or a database table. When the user tries to log in, we
    receive the input password, compare it with the one stored previously, and, if
    they are the same, we allow the user to log in. Right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is a very bad idea, because it can produce serious problems:'
  prefs: []
  type: TYPE_NORMAL
- en: If an attacker has access to the storage for the application, they'll be able
    to read the passwords of all the users. Users tend to reuse passwords (even if
    it's a bad idea), so, paired with their emails, they'll be exposed to attacks
    on multiple applications, not only the breached one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may seem unlikely, but keep in mind that any copy of the data stored is
    susceptible to attack, including backups.
  prefs: []
  type: TYPE_NORMAL
- en: Another real issue is insider threats, workers who may have legitimate access
    to the system but copy data for nefarious purposes or by mistake. For very sensitive
    data, this can be a very important consideration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mistakes like displaying the password of a user in status logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make things secure, data needs to be structured in a way that''s as protected
    as possible from access or even copying, without exposing the real passwords of
    users. The usual solution to this is to have the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: The password itself is not stored. Instead, a *cryptographical hash* of the
    password is stored. This applies a mathematical function to the password and generates
    a replicable sequence of bits, but the reverse operation is computationally very
    difficult.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the hash is deterministic based on the input, a malicious actor could detect
    duplicated passwords, as their hashes are the same. To avoid this problem, a random
    sequence of characters, called a *salt*, is added for each account. This will
    be added to each password before hashing, meaning two users with the same password
    but different salts will have different hashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the resulting hash and the salt are stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a user tries to log in, their input password is added to the salt, and
    the result is compared with the stored hash. If it's correct, the user is logged
    in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that in this design, the actual password is unknown to the system. It's
    not stored anywhere and is only accepted temporarily to compare it with the expected
    hash, after being processed.
  prefs: []
  type: TYPE_NORMAL
- en: This example is presented in a simplified way. There are multiple ways of using
    this schema and different ways of comparing a hash. For example, the `bcrypt`
    function can be applied multiple times, increasing encryption each time, which
    can increase the time required to produce a valid hash, making it more resistant
    to brute-force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of system is more secure than one that stores the password directly,
    as the password is not known by the people operating the system, nor is it stored
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of mistakenly displaying the password of a user in status logs may
    still happen! Extra care should be taken to make sure that sensitive information
    is not being logged by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: In certain cases, the same approach as for passwords can be taken to encrypt
    other stored data, so that only customers can access their own data. For example,
    you can enable end-to-end encryption for a communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: Security has a very close relationship with the architecture of a system. As
    we saw before, the architecture defines which aspects are easy and difficult to
    change and can make some unsafe things impossible to do, like knowing the password
    of a user, as we described in the previous example. Other options include not
    storing data from the user to keep privacy or reducing the data exposed in internal
    APIs, for example. Software security is a very difficult problem and is often
    a double-edged sword, and trying to make a system more secure can have the side
    effect of making operations long-winded and inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what software architecture is and when it is required,
    as well as its focus on the long-term approach, which is characteristic of the
    discipline. We learned that the underlying structure of software is difficult
    to change and that that aspect should be taken into consideration when designing
    and changing a software system.
  prefs: []
  type: TYPE_NORMAL
- en: We described how the most important thing is to divide a complex system into
    smaller parts and assign clear goals and objectives to each of them, keeping in
    mind that these smaller parts can use multiple programming languages and refer
    to different scopes. We also described the LAMP architecture and how it's a widely
    successful starting point when creating simple web service systems.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about how Conway's Law affects the architecture of a system, as underlying
    team structures have a direct impact on the implementation and structure of software.
    After all, software is operated and developed by humans, and human communication
    needs to be accounted for to implement it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: We described the example that we will use throughout the book to describe the
    different elements and patterns we will present. Finally, we commented on the
    security aspects of software architecture and how creating barriers to accessing
    data as part of the structural design of a system can mitigate security issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we will talk about the different aspects of
    designing a system.
  prefs: []
  type: TYPE_NORMAL
