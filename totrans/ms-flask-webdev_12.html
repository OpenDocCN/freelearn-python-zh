<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing Flask Apps</h1>
                </header>
            
            <article>
                
<p>Throughout the book, every time that we've made a modification to our application's code, we've had to manually load the affected web pages into our browser to test if the code was working correctly. As the application grows, this process becomes more and more tedious, especially if you change something that is low-level and used everywhere, such as SQLAlchemy model code.</p>
<p>In order to automate the process of verifying that our code works the way we want it to, we will use a built-in feature of Python that allows us to write tests, normally named unit tests or integration tests, which are checked against our application's code.</p>
<p>In this chapter, you will learn how to do the following:</p>
<ul>
<li>Writing simple tests with Python's unitest library</li>
<li>Testing security, and validating logins and role based access</li>
<li>Writing a test for a REST API</li>
<li>Testing your user interface</li>
<li>Measuring test coverage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are unit tests?</h1>
                </header>
            
            <article>
                
<p>Testing a program is very simple. All it involves is developing code that will run particular pieces of your program and specifying what you expect the results to be, and then comparing it to what the results from the piece of the program actually are. If the results are the same, the test passes. If the results are different, the test fails. Typically, these tests are run upon Pull Request creation on your CI server, so all the reviewers of the PR can immediately check if the requested change breaks something or not. </p>
<p class="mce-root"/>
<p>In program testing, there are three main types of tests. <strong>Unit tests</strong> are tests that verify the correctness of individual pieces of code, such as functions. Second is <strong>integration testing</strong>, which tests the correctness of various units of programs working in tandem. The last type of testing is <strong>end-to-end testing</strong>, which tests the correctness of the whole system at once, rather than individual pieces. Many other types of testing exist, some of which include load tests, security tests, and recovery tests.</p>
<p>In this chapter, we will be using unit testing and end-to-end testing in order to verify that our code is working as planned. </p>
<p>This brings us to some of the first rules of code testing: make sure your tests can actually fail, write simple test functions that test only one thing, and make your test code easy to read and write. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How does testing work?</h1>
                </header>
            
            <article>
                
<p>Let's start with a very simple Python function for us to test:</p>
<pre>def square(x): 
    return x * x </pre>
<p>In order to verify the correctness of this code, we pass a value, and will test if the result of the function is what we expect. For example, we could give it an input of 5, and would expect the result to be 25.</p>
<p>To illustrate the concept, we can manually test this function in the command line using the <kbd>assert</kbd> statement. The <kbd>assert</kbd> statement in Python simply says that if the conditional statement after the <kbd>assert</kbd> keyword returns <kbd>False</kbd>, then it will throw an exception as follows:</p>
<pre>    <strong>$ python</strong>
    <strong>&gt;&gt;&gt; def square(x): </strong>
    <strong>...     return x * x</strong>
    <strong>&gt;&gt;&gt; assert square(5) == 25</strong>
    <strong>&gt;&gt;&gt; assert square(7) == 49</strong>
    <strong>&gt;&gt;&gt; assert square(10) == 100</strong>
    <strong>&gt;&gt;&gt; assert square(10) == 0</strong>
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    AssertionError
  </pre>
<p>Using these <kbd>assert</kbd> statements, we verified that the square function was working as intended.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing the application</h1>
                </header>
            
            <article>
                
<p><strong>Unit testing</strong> in Python works by combining <kbd>assert</kbd> statements into their own functions inside a class. This <em>collection of testing functions</em> inside the class is called a <strong>test case</strong>. Each function inside the test case should test only one thing, which is the main idea behind unit testing. Testing only one thing in your unit tests forces you to verify each piece of code individually, and not gloss over any of the functionality of your code. If you write your unit tests correctly, you will end up with lots and lots of them. While this may seem overly verbose, it will save you from headaches further down the road.</p>
<p>In this configuration, we will use SQLLite in the memory engine database, which allows us to guarantee that the tests will not interfere with our actual database. Also, the configuration disables WTForms' CSRF checks, to allow us to submit forms from the tests without the CSRF token:</p>
<pre><span>class </span><span>TestConfig</span>(Config):<br/><br/>    DEBUG = <span>True<br/></span><span>    </span>DEBUG_TB_ENABLED = <span>False<br/></span><span>    </span>SQLALCHEMY_DATABASE_URI = <span>'sqlite:///:memory:'<br/></span><span>    </span>SQLALCHEMY_TRACK_MODIFICATIONS = <span>False<br/></span><span>    </span>CACHE_TYPE = <span>'null'<br/></span><span>    </span>WTF_CSRF_ENABLED = <span>False<br/></span><span><br/></span><span>    </span>CELERY_BROKER_URL = <span>"amqp://guest:guest@localhost:5672//"<br/></span><span>    </span>CELERY_BACKEND_URL = <span>"amqp://guest:guest@localhost:5672//"<br/></span><span><br/></span><span>    </span>MAIL_SERVER = <span>'localhost'<br/></span><span>    </span>MAIL_PORT = <span>25<br/></span><span>    </span>MAIL_USERNAME = <span>'username'<br/></span><span>    </span>MAIL_PASSWORD = <span>'password'<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the route functions</h1>
                </header>
            
            <article>
                
<p>Let's build our first test case. In this test case, we will be testing if the route functions successfully return a response when we access its URL. In a new directory <span>named </span><kbd>tests</kbd>, at the root of the project directory, create a new file named <kbd>test_urls.py</kbd>, which will hold all of the unit tests for the routes. Each test case should have its own file, and each test case should focus on one area of the code that you are testing.</p>
<p class="mce-root"/>
<p>In <kbd>test_urls.py</kbd>, let's start creating what the built-in Python <kbd>unittest</kbd> library needs. The code will use the <kbd>unittest</kbd> library from Python in order to run all the tests that we create in the test case:</p>
<pre>import unittest 
 
class TestURLs(unittest.TestCase): 
    pass 
 
if __name__ == '__main__': 
    unittest.main() </pre>
<p>Let's see what happens when this code is run. We will use the <kbd>unittest</kbd> library's ability to automatically find our test cases to run the tests. The pattern that the <kbd>unittest</kbd> library looks for is <kbd>test*.py</kbd>:</p>
<pre><strong>$ python -m unittest discover</strong>
    
---------------------------------------------------------------------
Ran 0 tests in 0.000s
    
OK</pre>
<p>Because there are no tests in the test case, the test case passed successfully.</p>
<div class="packt_infobox">The test script was run from the parent directory of the script, and not in the test folder itself. This is to allow imports of the application code inside the test scripts.</div>
<p>In order to test the URLs, we need to have a way to query the application's routes without actually running a server, so our requests are returned. Flask provides a way of accessing routes in tests, called the <em>test client</em>. The test client gives methods to create HTTP requests on our routes, without having to actually run the application with <kbd>app.run()</kbd>.</p>
<p>We will need the test client object for each of the tests in this test case, but adding in code to each <kbd>unittest</kbd> to create the test client doesn't make much sense when we have the <kbd>setUp</kbd> method. The <kbd>setUp</kbd> method is run before each unit test, and can attach variables to itself in order for the test method to access them. In our <kbd>setUp</kbd> method, we need to create the application object with our <kbd>TestConfig</kbd> object and create the test client.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Also, there are three bugs that we need to work around. The first two are in the Flask Admin and Flask Restful extensions, which do not remove the Blueprint objects stored internally when the application object they are applied to is destroyed. Third, Flask SQLAlchemy's initializer doesn't correctly add the application object while outside the <kbd>webapp</kbd> directory:</p>
<pre><span>class </span><span>TestURLs</span>(unittest.TestCase):<br/><br/>    <span>def </span><span>setUp</span>(<span>self</span>):<br/>        admin._views = []<br/>        rest_api.resources = []<br/><br/>        app = create_app(<span>'config.TestConfig'</span>)<br/>        <span>self</span>.client = app.test_client()<br/>        db.app = app<br/>        db.create_all()</pre>
<div class="packt_infobox">All of the bugs listed here existed at the time of writing, but may no longer exist when you read this chapter.</div>
<p>Along with the <kbd>setUp</kbd> method, there is also the <kbd>tearDown</kbd> method, which is run every time a unit test ends. The <kbd>tearDown</kbd> method's goal is to destroy any objects, created in the <kbd>setUp</kbd> method, that cannot <span>automatically</span><span> </span><span>be deleted or closed. In our case, we will use the</span> <kbd>tearDown</kbd> <span>method to close and remove our database sessions, as follows:</span></p>
<pre>class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        db.session.remove()</pre>
<p>Now we can create our first unit test. The first test will test whether accessing the root of our application returns a <kbd>302 redirect</kbd> code to the blog home page, as follows:</p>
<pre>class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        ... 
 
    def test_root_redirect(self): 
        """ Tests if the root URL gives a 302 """ 
 
        result = self.client.get('/') 
        assert result.status_code == 302 
        assert "/blog/" in result.headers['Location'] </pre>
<p>Each unit test must start with the word <kbd>test</kbd> to tell the <kbd>unittest</kbd> library that the function is a unit test, and not just some utility function inside the test case class.</p>
<p>Now, if we run the tests again, we can see its progress and how it passes the checks:</p>
<pre>    <strong>$ python -m unittest discover</strong>
    <strong>.</strong>
    ---------------------------------------------------------------------
    Ran 1 tests in 0.128s
    
    OK
  </pre>
<p>The best way to write tests is to ask yourself what you are looking for ahead of time, write the <kbd>assert</kbd> statements, and write the code needed to execute those asserts. This forces you to ask what you are really testing, before you actually start writing the test. It's also the practice to write a Python doc string for each unit test, as it will be printed with the name of the test whenever the test fails. After you write 50 or more tests, this can be very helpful to know exactly what the test is for.</p>
<p>Rather than using the built-in <kbd>assert</kbd> keyword from Python, we can use some of the methods provided by the <kbd>unittest</kbd> library. These methods provide specialized error messages and debug information when the <kbd>assert</kbd> statements inside these functions fail.</p>
<p>The following is a list of all of the special <kbd>assert</kbd> statements given by the <kbd>unittest</kbd> library and what they do:</p>
<ul>
<li><kbd>assertEqual(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>x == y</kbd></li>
<li><kbd>assertNotEqual(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>x != y</kbd></li>
<li><kbd>assertTrue(x)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is <kbd>True</kbd></li>
<li><kbd>assertFalse(x)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is <kbd>False</kbd></li>
<li><kbd>assertIs(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is <kbd>y</kbd></li>
<li><kbd>assertIsNot(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is not <kbd>y</kbd></li>
<li><kbd>assertIsNone(x)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is <kbd>None</kbd></li>
<li><kbd>assertIsNotNone(x)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is not <kbd>None</kbd></li>
<li><kbd>assertIn(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>y</kbd> contains <kbd>x</kbd></li>
<li><kbd>assertNotIn(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>x</kbd> is not in <kbd>y</kbd></li>
<li><kbd>assertIsInstance(x, y)</kbd>: Asserts<span> </span><span>that</span> <kbd>isinstance(x, y)</kbd></li>
<li><kbd>assertNotIsInstance(x, y)</kbd>: Asserts<span> </span>not <kbd>isinstance(x, y)</kbd></li>
</ul>
<p class="mce-root"/>
<p>If we wanted to test the return value of a normal page, the unit test would look like this:</p>
<pre>class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        ... 
 
    def test_root_redirect(self): 
        ... 
 
    def test_blog_home(self): 
        """ Tests if the blog home page returns successfully """ 
        result = self.client.get('/blog/')
        self.assertEqual(result.status_code, 200)</pre>
<p>Remember that the preceding code only tests if the URLs give returns successfully. The content of the return data is not a part of these tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing security</h1>
                </header>
            
            <article>
                
<p>Testing security is obviously very important—if you expose your application to the web, you can be sure that your security will be heavily tested, and not for the right reasons. All of your secured endpoints will be tested and exploited if not correctly secured. First of all, we should test our login and logout processes.</p>
<p>If we wanted to test submitting a form, such as the login form, we can use the post method of the test client. Let's create a <kbd>test_login</kbd> method to see if the login form works correctly:</p>
<pre><span>class </span><span>TestURLs</span>(unittest.TestCase):<br/>....<br/><br/>    <span>def </span><span>_insert_user</span>(<span>self</span><span>, </span>username<span>, </span>password<span>, </span>role_name):<br/>        test_role = Role(role_name)<br/>        db.session.add(test_role)<br/>        db.session.commit()<br/><br/>        test_user = User(username)<br/>        test_user.set_password(password)<br/>        db.session.add(test_user)<br/>        db.session.commit()<br/><br/>    <span>def </span><span>test_login</span>(<span>self</span>):<br/>        <span>""" Tests if the login form works correctly """<br/></span><span><br/></span><span>        </span>result = <span>self</span>.client.post(<span>'/auth/login'</span><span>, </span><span>data</span>=<span>dict</span>(<br/>            <span>username</span>=<span>'test'</span><span>,<br/></span><span>            </span><span>password</span>=<span>"test"<br/></span><span>        </span>)<span>, </span><span>follow_redirects</span>=<span>True</span>)<br/><br/>        <span>self</span>.assertEqual(result.status_code<span>, </span><span>200</span>)<br/>        <span>self</span>.assertIn(<span>'You have been logged in'</span><span>, </span>result.data)<br/>...</pre>
<p>The additional check for the string in the return data exists because the return code is not affected by the validity of the entered data. The <kbd>post</kbd> method will work for testing any of the form objects we have created throughout the book.</p>
<p>Now, let's create a failed login attempt:</p>
<pre><span>def </span><span>test_failed_login</span>(<span>self</span>):<br/>    <span>self</span>._insert_user(<span>'test'</span><span>, </span><span>'test'</span><span>, </span><span>'default'</span>)<br/>    result = <span>self</span>.client.post(<span>'/auth/login'</span><span>, </span><span>data</span>=<span>dict</span>(<br/>        <span>username</span>=<span>'test'</span><span>,<br/></span><span>        </span><span>password</span>=<span>"badpassword"<br/></span><span>    </span>)<span>, </span><span>follow_redirects</span>=<span>True</span>)<br/><br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>200</span>)<br/>    <span>self</span>.assertIn(<span>'Invalid username or password'</span><span>, </span>result.data)<br/>    result = <span>self</span>.client.get(<span>'/blog/new'</span>)<br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>302</span>)</pre>
<p>In the preceding snippet, we make sure that a login attempt with failed credentials does not give the user a successful login, and in the same test, we also make sure that a failed login will not give the user sufficient access to add a new blog post. This may seem trivial, and it is easy to implement, but as previously stated, you should make each test simple, and only test one thing with each test, but aim to cover all your features and possibilities.</p>
<p>Another example of an important test covers unauthorized access from a logged-in user:</p>
<pre><span>def </span><span>test_unauthorized_access_to_admin</span>(<span>self</span>):<br/>    <span>self</span>._insert_user(<span>'test'</span><span>, </span><span>'test'</span><span>, </span><span>'default'</span>)<br/>    <span>result </span>= <span>self</span>.client.post(<span>'/auth/login'</span><span>, </span><span>data</span>=<span>dict</span>(<br/>        <span>username</span>=<span>'test'</span><span>,<br/></span><span>        </span><span>password</span>=<span>"test"<br/></span><span>    </span>)<span>, </span><span>follow_redirects</span>=<span>True</span>)<br/>    result = <span>self</span>.client.get(<span>'/admin/customview/'</span>)<br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>403</span>)</pre>
<p>Here, we make sure that a low-privileged user does not have access to an high privilege area of our application: the admin interface.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the REST API </h1>
                </header>
            
            <article>
                
<p>Still in the context of security, we will now learn how to test our REST API. Remember that we have implemented JWT security, so for each request, we need to use a previously acquired access token.</p>
<p>JWT authentication tests should look like this:</p>
<pre><span>def </span><span>test_api_jwt_login</span>(<span>self</span>):<br/>    <span>self</span>._insert_user(<span>'test'</span><span>, </span><span>'test'</span><span>, </span><span>'default'</span>)<br/>    headers = {<span>'content-type'</span>: <span>'application/json'</span>}<br/>    result = <span>self</span>.client.post(<span>'/auth/api'</span><span>, </span><span>headers</span>=headers<span>, </span><span>data</span>=<span>'{"username":"test","password":"test"}'</span>)<br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>200</span>)<br/><br/><span>def </span><span>test_api_jwt_failed_login</span>(<span>self</span>):<br/>    <span>self</span>._insert_user(<span>'test'</span><span>, </span><span>'test'</span><span>, </span><span>'default'</span>)<br/>    headers = {<span>'content-type'</span>: <span>'application/json'</span>}<br/>    result = <span>self</span>.client.post(<span>'/auth/api'</span><span>, </span><span>headers</span>=headers<span>, </span><span>data</span>=<span>'{"username":"test","password":"test123"}'</span>)<br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>401</span>)</pre>
<p>Some important details to note here include the way we set our HTTP header to JSON, and how we pass the JSON payload on the HTTP POST method—this will happen on all our REST API tests.</p>
<p>Next, let's see how to develop a test for the new post REST API. <kbd>/api/post</kbd><span> is the endpoint for blog posts, and the POST HTTP method is the method for adding a new post to the Blog application. Revisit <a href="e6143102-d0e2-4134-a6db-28fb38643ea7.xhtml" target="_blank">Chapter 8</a>, <em>Building RESTful APIs</em> if this is not clear.</span></p>
<pre><span>def </span><span>test_api_new_post</span>(<span>self</span>):<br/>    <span>self</span>._insert_user(<span>'test'</span><span>, </span><span>'test'</span><span>, </span><span>'default'</span>)<br/>    headers = {<span>'content-type'</span>: <span>'application/json'</span>}<br/>    result = <span>self</span>.client.post(<span>'/auth/api'</span><span>, </span><span>headers</span>=headers<span>, </span><span>data</span>=<span>'{"username":"test","password":"test"}'</span>)<br/>    <strong>access_token = json.loads(result.data)[<span>'access_token'</span>]</strong><br/><strong>    headers[<span>'Authorization'</span>] = <span>"Bearer %s" </span>% access_token</strong><br/>    result = <span>self</span>.client.post(<span>'api/post'</span><span>, </span><span>headers</span>=headers<span>, </span><span>data</span>=<span>'{"title":"Text Title","text":"Changed"}'</span>)<br/>    <span>self</span>.assertEqual(result.status_code<span>, </span><span>201</span>)</pre>
<p class="mce-root"/>
<p>Once again, this is a simple test to develop—notice the way that we request an access token from our authentication JWT API using the <kbd>/auth/api</kbd><span> endpoint, and how we use it to make the call to <kbd>/api/post</kbd>. has expected the access token is used to construct the HTTP authorization header using the form <kbd>Authorization: Bearer &lt;ACCESS_TOKEN&gt;</kbd>. This can be a bit cumbersome to repeat on each API test, so make sure to write a helper function to keep your code "DRY"—that is, "Don't Repeat Yourself".</span></p>
<p>Now that you understand the mechanics of unit testing, you can use unit testing in order to test all the parts of your application. This can include testing all the routes in the application; testing any utility function that we have made, such as <kbd>sidebar_data</kbd>; and testing all possible combinations of roles and access protected pages.</p>
<p>If your application's code has a feature, no matter how small, you should have a test for it. Why? Because whatever can go wrong, will go wrong. If the validity of your application's code relies entirely on manual testing, then something is going to get overlooked as your app grows. When something gets overlooked, then broken code is deployed to live servers, which annoys your users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User interface testing</h1>
                </header>
            
            <article>
                
<p>In order to test the high level of our application's code and to create system tests, we will write tests that work with browsers, and verify that the UI code is functioning properly. Using a tool called Selenium, we will create Python code that hooks into a browser and controls it purely from code. This works by finding elements on the screen, and then performing actions on those elements through Selenium. Click on it or input keystrokes. Also, Selenium allows you to perform checks on the page content by giving you access to the elements' content, such as their attributes and inner text. For more advanced checks, Selenium even has an interface which can run arbitrary JavaScript on the page. If the JavaScript returns a value, it is automatically converted into a Python type.</p>
<p>Before we touch the code, Selenium needs to be installed. Make sure you have your virtualenv activated, and that Selenium is included in the <kbd>requirements.txt</kbd> file:</p>
<pre>...    <br/>selenium<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To begin with the code, our UI tests need a file of their own in the <kbd>tests</kbd> directory, named <kbd>test_ui.py</kbd>. Because system tests do not test one specific thing, the best way to write user interface tests is to think of the test as going through a typical user's flow. Before you write the test itself, write down the specific steps that our fake user is going to simulate:</p>
<pre>import unittest 
 
 
class TestURLs(unittest.TestCase): 
    def setUp(self): 
        pass 
 
    def tearDown(self): 
        pass 
 
    def test_add_new_post(self): 
        """ Tests if the new post page saves a Post object to the 
            database 
 
            1. Log the user in 
            2. Go to the new_post page 
            3. Fill out the fields and submit the form 
            4. Go to the blog home page and verify that the post  
               is on the page 
        """ 
        pass </pre>
<p>Now that we know exactly what our test is going to do, let's start adding in the Selenium code. In the <kbd>setUp</kbd> and <kbd>tearDown</kbd> methods, we need code to start up a web browser that will Selenium control, and then close it when the test is over:</p>
<pre>import unittest 
from selenium import webdriver
 
class TestURLs(unittest.TestCase): 
    def setUp(self): 
        self.driver = webdriver.Chrome() 
 
    def tearDown(self): 
        self.driver.close()</pre>
<p class="mce-root"/>
<p>This code spawns a new Firefox window with Selenium controlling it. For this to work, of course, you need Firefox installed on your computer. Selenium does have support for other browsers, but using others requires an extra program in order for it to work correctly. Firefox thus has the best support out of all the browsers.</p>
<p>Before we write the code for the test, let's explore the Selenium API as follows:</p>
<pre>    <strong>$ python</strong>
    <strong>&gt;&gt;&gt; from selenium import webdriver</strong>
    <strong>&gt;&gt;&gt; driver = webdriver.Chrome()</strong>
    <strong># load the Google homepage</strong>
    <strong>&gt;&gt;&gt; driver.get("http://www.google.com")</strong>
    <strong># find a element by its class</strong>
    <strong>&gt;&gt;&gt; search_field = driver.find_element_by_class_name("gsfi")</strong>
    <strong># find a element by its name</strong>
    <strong>&gt;&gt;&gt; search_field = driver.find_element_by_name("q")</strong>
    <strong># find an element by its id</strong>
    <strong>&gt;&gt;&gt; search_field = driver.find_element_by_id("lst-ib")</strong>
    <strong># find an element with JavaScript</strong>
    <strong>&gt;&gt;&gt; search_field = driver.execute_script(</strong>
    <strong>    "return document.querySelector('#lst-ib')"</strong>
    <strong>)</strong>
    <strong># search for flask</strong>
    <strong>&gt;&gt;&gt; search_field.send_keys("flask")</strong>
    <strong>&gt;&gt;&gt; search_button = driver.find_element_by_name("btnK")</strong>
    <strong>&gt;&gt;&gt; search_button.click()</strong>
  </pre>
<p>These are the main functions from Selenium that we will be using, but there are many other ways to find and interact with elements on the web page.</p>
<div class="packt_tip">For the full list of available features, refer to the Selenium-Python documentation at <a href="http://selenium-python.readthedocs.org"><span class="URLPACKT">http://selenium-python.readthedocs.org</span></a>.</div>
<p>There are two gotchas in Selenium that need to be kept in mind while writing your tests, or you will run into very odd bugs that are almost impossible to debug from their error messages:</p>
<ul>
<li>Selenium is designed to work as if there is an actual person controlling the browser. This means that, if an element cannot be seen on the page, Selenium cannot interact with it. For example, if an element covers another element that you wish to click on—say, a modal window is in front of a button—then the button cannot be pushed. If the element's CSS has its display set to <kbd>none</kbd>, or its visibility set to <kbd>hidden</kbd>, the results will be the same.</li>
<li>All of the variables that point toward elements on the screen are stored as pointers to those elements in the browser, meaning they are not stored in Python's memory. If the page changes without using the <kbd>get</kbd> method, such as when a link is clicked and a new element pointer is created, then the test will crash. This happens because the driver will continuously be looking for the elements on the previous page, and not finding them on the new one. The <kbd>get</kbd> method of the driver clears out all those references.</li>
</ul>
<p>In the preceding tests, we used the test client in order to simulate a request to the application object. However, because we are now using something that needs to directly interface with the application through a web browser, we need an actual server to be running. This server needs to be run in a separate Terminal window before the user interface tests are run, so that the latter have something to request. To do this, we need a separate Python file in order to run the server with our test configuration, as well as needing to set up some models for our UI tests to use. At the root of the project directory, in a new file named <span><kbd>run_test_server.py</kbd>,</span> add the following:</p>
<pre>from webapp import create_app 
from webapp.models import db, User, Role 
 
app = create_app('config.TestConfig') 
 
db.app = app 
db.create_all() 
 
default = Role("default") 
poster = Role("poster") 
db.session.add(default) 
db.session.add(poster) 
db.session.commit() 
 
test_user = User("test") 
test_user.set_password("test") 
test_user.roles.append(poster) 
db.session.add(test_user) 
db.session.commit() 
 
app.run() </pre>
<p>Now that we have both the test server script and some knowledge of Selenium's API, we can finally write the code for our test:</p>
<pre><span>import </span>time<br/><span>import </span>unittest<br/><span>from </span>selenium <span>import </span>webdriver<br/><br/><br/><span>class </span><span>TestURLs</span>(unittest.TestCase):<br/>    <span>def </span><span>setUp</span>(<span>self</span>):<br/>        <span>self</span>.driver = webdriver.Chrome()<br/><br/>    <span>def </span><span>tearDown</span>(<span>self</span>):<br/>        <span>self</span>.driver.close()<br/><br/>    <span>def </span><span>test_add_new_post</span>(<span>self</span>):<br/>        <span>""" Tests if the new post page saves a Post object to the<br/></span><span>            database<br/></span><span><br/></span><span>            1. Log the user in<br/></span><span>            2. Go to the new_post page<br/></span><span>            3. Fill out the fields and submit the form<br/></span><span>            4. Go to the blog home page and verify that the post is<br/></span><span>               on the page<br/></span><span>        """<br/></span><span>        </span><span># login<br/></span><span>        </span><span>self</span>.driver.get(<span>"http://localhost:5000/auth/login"</span>)<br/><br/>        username_field = <span>self</span>.driver.find_element_by_name(<span>"username"</span>)<br/>        username_field.send_keys(<span>"test"</span>)<br/><br/>        password_field = <span>self</span>.driver.find_element_by_name(<span>"password"</span>)<br/>        password_field.send_keys(<span>"test"</span>)<br/><br/>        login_button = <span>self</span>.driver.find_element_by_id(<span>"login_button"</span>)<br/>        login_button.click()<br/><br/>        <span># fill out the form<br/></span><span>        </span><span>self</span>.driver.get(<span>"http://localhost:5000/blog/new"</span>)<br/><br/>        title_field = <span>self</span>.driver.find_element_by_name(<span>"title"</span>)<br/>        title_field.send_keys(<span>"Test Title"</span>)<br/><br/>        <span>#Locate the CKEditor iframe<br/></span><span>        </span>time.sleep(<span>3</span>)<br/>        basic_page_body_xpath = <span>"//div[contains(@id, 'cke_1_contents')]/iframe"<br/></span><span>        </span>ckeditor_frame = <span>self</span>.driver.find_element_by_xpath(basic_page_body_xpath)<br/><br/>        <span>#Switch to iframe<br/></span><span>        </span><span>self</span>.driver.switch_to.frame(ckeditor_frame)<br/>        editor_body = <span>self</span>.driver.find_element_by_xpath(<span>"//body"</span>)<br/>        editor_body.send_keys(<span>"Test content"</span>)<br/>        <span>self</span>.driver.switch_to.default_content()<br/><br/>        post_button = <span>self</span>.driver.find_element_by_class_name(<span>"btn-primary"</span>)<br/>        post_button.click()<br/><br/>        <span># verify the post was created<br/></span><span>        </span><span>self</span>.driver.get(<span>"http://localhost:5000/blog"</span>)<br/>        <span>self</span>.assertIn(<span>"Test Title"</span><span>, </span><span>self</span>.driver.page_source)<br/>        <span>self</span>.assertIn(<span>"Test content"</span><span>, </span><span>self</span>.driver.page_source)<br/><br/><br/><span>if </span>__name__ == <span>"__main__"</span>:<br/>    unittest.main()</pre>
<p>Most of this test uses the methods that we introduced earlier. However, there is a new method in this test, named <kbd>switch_to</kbd>. The <kbd>switch_to</kbd> method is the context of the driver that allows the selection of elements inside an <kbd>iframe</kbd> element. Normally, it's impossible for the parent window to select any elements inside an <kbd>iframe</kbd> <span>element </span>using JavaScript, but because we are directly interfacing with the browser itself, we can access an <kbd>iframe</kbd> element's contents. We need to switch contacts like these, because the WYSIWYG editor inside the post creation page uses <kbd>iframe</kbd> in order to create itself. After we are done with selecting elements within the <kbd>iframe</kbd>, we need to switch back to the parent context using the <kbd>parent_frame</kbd> method.</p>
<p>You now have the tools that you need to <span>completely </span>test both your server code and your user interface code. For the rest of the chapter, we will focus on tools and methodologies, in order to make your testing even more effective in ensuring your application's correctness.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test coverage</h1>
                </header>
            
            <article>
                
<p>Now that our tests have been written, we have to know whether our code is sufficiently tested. The concept of <strong>test coverage</strong>, also known as <strong>code coverage</strong>, was invented to solve this issue. In any project, the test coverage represents what percentage of the code in the project was executed when the tests were run, and which lines were never run. This gives an idea of what parts of the project aren't being tested by our unit tests. To add coverage reports to our project, install the coverage library with <kbd>pip</kbd>, and make sure it's included in the <kbd>requirements.txt</kbd>:</p>
<pre><strong>    (venv)$ pip install coverage</strong></pre>
<p>The coverage library can be run as a command-line program that will run your test suite, and take its measurements while the tests are running:</p>
<pre>    <strong>$ coverage run --source webapp --branch -m unittest discover</strong></pre>
<p>The <kbd>--source</kbd> flag tells <kbd>coverage</kbd> to only report on the test coverage for the files in the <kbd>webapp</kbd> directory. If that weren't included, the percentages for all the libraries used in the app would be included as well. By default, if any code in an <kbd>if</kbd> statement is executed, the entire <kbd>if</kbd> statement is said to have executed. The <kbd>--branch</kbd> flag tells <kbd>coverage</kbd> to disable this, and measure everything.</p>
<p>After <kbd>coverage</kbd> runs our tests and takes its measurements, we can see a report of its findings in two ways. The first is to see a printout of each file's coverage percentage on the command line:</p>
<pre><strong>$ coverage report</strong>
...<br/># You will get a full detailed report of your test coverage, breakdown by python file name coverage, and with the line numbers missed by your test<br/>...<br/><br/>TOTAL 729 312 118 10 56%</pre>
<p>The second way to see the report is to use the HTML generating ability of <kbd>coverage</kbd> to see a detailed breakdown of each file in the browser, using the following command:</p>
<pre>    <strong>$ coverage html</strong></pre>
<p>The preceding command creates a directory named <kbd>htmlcov</kbd>. When the <kbd>index.html</kbd> file is opened in the browser, each file name can be clicked on to reveal the breakdown of which lines were run, and which were not, during the tests:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-641 image-border" src="assets/6e4f6711-c002-4e0a-a7b0-5fbff0adb5a4.png" style="width:113.83em;height:109.58em;"/></div>
<p>In the preceding screenshot, the <kbd>blog/controllers.py</kbd> file was opened, and the coverage report clearly shows that the post route was never executed. However, this also gives some false negatives. As the user interface tests are not testing code that is being run by the coverage program, it doesn't count toward our coverage report. In order to fix this, just to make sure that you have tests in your test cases for each individual function that would have been tested in the user interface tests.</p>
<p class="mce-root"/>
<p>In most projects, the percentage to aim for is around 90% code coverage. It's very rare that a project will have 100% of its code testable, and this possibility decreases as the size of the project increases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test-driven development</h1>
                </header>
            
            <article>
                
<p>Now that we have our tests written, how can they be integrated into the development process? Currently, we are using our tests in order to ensure code correctness after we create a feature. But, what if we flipped the order and used tests in order to create correct code from the beginning? This is what <strong>test-driven development</strong> (<strong>TDD</strong>) advocates.</p>
<p>TDD follows a simple loop to write the code of a new feature in your application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-650 image-border" src="assets/55a76ee5-c1da-4c76-adc3-4a1af6308ab1.png" style="width:160.33em;height:112.00em;"/></div>
<p>In a project that uses TDD, the first thing that you write, before any of the code that controls what you are actually building, is the tests. What this forces the programmers on the project to do is to plan out the project's scope, design, and requirements before writing any code. While designing APIs, it also forces the programmer to design the interface (or contract) of the API from a consumer's perspective, rather than design the interface after all the backend code has been written.</p>
<p>In TDD, tests are designed to fail the first time that you run them. There is a saying in TDD, that if your tests don't fail the first time that you run them, you're not really testing anything. What this means is that you are most likely testing to the tested unit's function, rather than how it should function while writing tests after the fact.</p>
<p>After your tests fail the first time, you then continuously write code until all the tests pass. This process is repeated for each new feature.</p>
<p>Once all of the original tests pass and the code is refactored, TDD tells you to stop writing code. By only writing code until the tests pass, TDD also enforces the <strong>You Aren't Going To Need It</strong> (<strong>YAGNI</strong>) philosophy, which states that programmers should only implement what they actually need, rather than what they perceive they will need. A huge amount of wasted effort is made during development when programmers try to preemptively add functionality when no-one needed it.</p>
<p>TDD also promotes the idea of <strong>Keep It Simple, Stupid</strong> (<strong>KISS</strong>), which dictates that simplicity should be a design goal from the beginning. TDD promotes KISS because it requires small, testable units of code that can be separated from each other and don't rely on a shared global state.</p>
<p>Also, in projects that follow TDD, there is an always-current documentation throughout the tests. One of the axioms of programming is that with any sufficiently large program, the documentation will always be out of date. This is because the documentation is one of the last things on the mind of the programmer when they are changing the code. However, with tests, there are clear examples of each piece of functionality in the project (if the project has a large code coverage percentage). The tests are updated all the time, and therefore, show good examples of how the functions and API of the program should work.</p>
<p>Now that you understand Flask's functionality and how to write tests for Flask, the next project that you create in Flask can be made <span>entirely </span>with TDD.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Now that you understand testing and what it can do for your application, you can create applications that are guaranteed to be less bug-ridden. You will spend less time fixing bugs, and more time adding features that are requested by your users.</p>
<p>As a final challenge to the reader, before moving onto the next chapter, try to get your code coverage over 95%.</p>
<p>In the next chapter, we will finish the book by going over the ways by which you can deploy your application into a production environment on a server.</p>


            </article>

            
        </section>
    </body></html>