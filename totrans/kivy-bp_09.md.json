["```py\npython –m kivy.atlas <atlas_name> <texture_size> <images…>\n```", "```py\n{\n    \"game-0.png\": {\n        \"player\": [2, 170, 78, 84],\n        \"bullet\": [82, 184, 24, 16]\n    }\n}\n```", "```py\nImage:\n    source: 'flags/Israel.png'\n```", "```py\nImage:\n    source: 'atlas://flags/Israel'\n```", "```py\nkivy -m kivy.atlas icons 512 icon_clock.png icon_paint.png\n```", "```py\n[INFO] Kivy v1.8.0\n[INFO] [Atlas] create an 512x512 rgba image\n('Atlas created at', 'icons.atlas')\n1 image have been created\n```", "```py\nfrom kivy.app import App\n\nclass BasicApp(App):\n    pass\n\nif __name__ == '__main__':\n    BasicApp().run()\n```", "```py\nBoxLayout:\n    orientation: 'horizontal'\n\n    Image:\n        source: 'atlas://icons/icon_clock'\n\n    Image:\n        source: 'atlas://icons/icon_paint'\n```", "```py\nfrom collections import namedtuple\n\nUVMapping = namedtuple('UVMapping', 'u0 v0 u1 v1 su sv')\n```", "```py\nclass UVMapping:\n    def __init__(self, u0, v0, u1, v1, su, sv):\n        self.u0 = u0  # top left corner\n        self.v0 = v0  # ---\n        self.u1 = u1  # bottom right corner\n        self.v1 = v1  # ---\n        self.su = su  # equals to 0.5 * width\n        self.sv = sv  # equals to 0.5 * height\n```", "```py\nimport json\nfrom kivy.core.image import Image\n\ndef load_atlas(atlas_name):\n    with open(atlas_name, 'rb') as f:\n        atlas = json.loads(f.read().decode('utf-8'))\n\n    tex_name, mapping = atlas.popitem()\n    tex = Image(tex_name).texture\n    tex_width, tex_height = tex.size\n\n    uvmap = {}\n    for name, val in mapping.items():\n        x0, y0, w, h = val\n        x1, y1 = x0 + w, y0 + h\n        uvmap[name] = UVMapping(\n            x0 / tex_width, 1 - y1 / tex_height,\n            x1 / tex_width, 1 - y0 / tex_height,\n            0.5 * w, 0.5 * h)\n\n    return tex, uvmap\n```", "```py\n>>> load_atlas('icons.atlas')\n\n(<Texture size=(512, 512)...>,\n {'icon_paint': UVMapping(u0=0.2578125, v0=0.00390625,\n                          u1=0.5078125, v1=0.25390625,\n                          su=64.0, sv=64.0),\n  'icon_clock': UVMapping(...)})\n```", "```py\nfrom kivy.graphics import Mesh\nfrom kivy.graphics.instructions import RenderContext\nfrom kivy.uix.widget import Widget\n\nclass GlslDemo(Widget):\n    def __init__(self, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.canvas = RenderContext(use_parent_projection=True)\n        self.canvas.shader.source = 'tex_atlas.glsl'\n\n        fmt = (\n            (b'vCenter',     2, 'float'),\n            (b'vPosition',   2, 'float'),\n            (b'vTexCoords0', 2, 'float'),\n        )\n\n        texture, uvmap = load_atlas('icons.atlas')\n\n        a = uvmap['icon_clock']\n        vertices = (\n            128, 128, -a.su, -a.sv, a.u0, a.v1,\n            128, 128,  a.su, -a.sv, a.u1, a.v1,\n            128, 128,  a.su,  a.sv, a.u1, a.v0,\n            128, 128, -a.su,  a.sv, a.u0, a.v0,\n        )\n        indices = (0, 1, 2, 2, 3, 0)\n\n        b = uvmap['icon_paint']\n        vertices += (\n            256, 256, -b.su, -b.sv, b.u0, b.v1,\n            256, 256,  b.su, -b.sv, b.u1, b.v1,\n            256, 256,  b.su,  b.sv, b.u1, b.v0,\n            256, 256, -b.su,  b.sv, b.u0, b.v0,\n        )\n        indices += (4, 5, 6, 6, 7, 4)\n\n        with self.canvas:\n            Mesh(fmt=fmt, mode='triangles',\n                 vertices=vertices, indices=indices,\n                 texture=texture)\n```", "```py\n---vertex\n$HEADER$\n\nattribute vec2 vCenter;\n\nvoid main(void)\n{\n    tex_coord0 = vTexCoords0;\n    mat4 move_mat = mat4\n        (1.0, 0.0, 0.0, vCenter.x,\n         0.0, 1.0, 0.0, vCenter.y,\n         0.0, 0.0, 1.0, 0.0,\n         0.0, 0.0, 0.0, 1.0);\n    vec4 pos = vec4(vPosition.xy, 0.0, 1.0) * move_mat;\n    gl_Position = projection_mat * modelview_mat * pos;\n}\n\n---fragment\n$HEADER$\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(texture0, tex_coord0);\n}\n```", "```py\nclass PSWidget(Widget):\n    indices = []\n    vertices = []\n    particles = []\n\n    def __init__(self, **kwargs):\n        Widget.__init__(self, **kwargs)\n        self.canvas = RenderContext(use_parent_projection=True)\n        self.canvas.shader.source = self.glsl\n\n        self.vfmt = (\n            (b'vCenter', 2, 'float'),\n            (b'vScale', 1, 'float'),\n            (b'vPosition', 2, 'float'),\n            (b'vTexCoords0', 2, 'float'),\n        )\n\n        self.vsize = sum(attr[1] for attr in self.vfmt)\n\n        self.texture, self.uvmap = load_atlas(self.atlas)\n```", "```py\ndef make_particles(self, Cls, num):\n    count = len(self.particles)\n    uv = self.uvmap[Cls.tex_name]\n\n    for i in range(count, count + num):\n        j = 4 * i\n        self.indices.extend((\n            j, j + 1, j + 2, j + 2, j + 3, j))\n\n        self.vertices.extend((\n            0, 0, 1, -uv.su, -uv.sv, uv.u0, uv.v1,\n            0, 0, 1,  uv.su, -uv.sv, uv.u1, uv.v1,\n            0, 0, 1,  uv.su,  uv.sv, uv.u1, uv.v0,\n            0, 0, 1, -uv.su,  uv.sv, uv.u0, uv.v0,\n        ))\n\n        p = Cls(self, i)\n        self.particles.append(p)\n```", "```py\ndef update_glsl(self, nap):\n    for p in self.particles:\n        p.advance(nap)\n        p.update()\n\n    self.canvas.clear()\n\n    with self.canvas:\n        Mesh(fmt=self.vfmt, mode='triangles',\n             indices=self.indices, vertices=self.vertices,\n             texture=self.texture)\n```", "```py\nclass Particle:\n    x = 0\n    y = 0\n    size = 1\n\n    def __init__(self, parent, i):\n        self.parent = parent\n        self.vsize = parent.vsize\n        self.base_i = 4 * i * self.vsize\n        self.reset(created=True)\n\n    def update(self):\n        for i in range(self.base_i,\n                       self.base_i + 4 * self.vsize,\n                       self.vsize):\n            self.parent.vertices[i:i + 3] = (\n                self.x, self.y, self.size)\n\n    def reset(self, created=False):\n        raise NotImplementedError()\n\n    def advance(self, nap):\n        raise NotImplementedError()\n```", "```py\nfrom kivy.base import EventLoop\nfrom kivy.clock import Clock\n\nclass Game(PSWidget):\n    glsl = 'game.glsl'\n    atlas = 'game.atlas'\n\n    def initialize(self):\n        pass\n\nclass GameApp(App):\n    def build(self):\n        EventLoop.ensure_window()\n        return Game()\n\n    def on_start(self):\n        self.root.initialize()\n        Clock.schedule_interval(\n            self.root.update_glsl, 60 ** -1)\n```", "```py\nfrom random import randint, random\n\nclass Star(Particle):\n    plane = 1\n    tex_name = 'star'\n\n    def reset(self, created=False):\n        self.plane = randint(1, 3)\n\n        if created:\n            self.x = random() * self.parent.width\n        else:\n            self.x = self.parent.width\n\n        self.y = random() * self.parent.height\n        self.size = 0.1 * self.plane\n\n    def advance(self, nap):\n        self.x -= 20 * self.plane * nap\n        if self.x < 0:\n            self.reset()\n```", "```py\ndef initialize(self):\n    self.make_particles(Star, 200)\n```", "```py\nfrom kivy.core.window import Window\n\nclass Game(PSWidget):\n    def update_glsl(self, nap):\n        self.player_x, self.player_y = Window.mouse_pos\n\n        PSWidget.update_glsl(self, nap)\n```", "```py\nclass Player(Particle):\n    tex_name = 'player'\n\n    def reset(self, created=False):\n        self.x = self.parent.player_x\n        self.y = self.parent.player_y\n\n    advance = reset\n```", "```py\ndef initialize(self):\n    self.make_particles(Star, 200)\n    self.make_particles(Player, 1)\n```", "```py\nclass Trail(Particle):\n    tex_name = 'trail'\n\n    def reset(self, created=False):\n        self.x = self.parent.player_x + randint(-30, -20)\n        self.y = self.parent.player_y + randint(-10, 10)\n\n        if created:\n            self.size = 0\n        else:\n            self.size = random() + 0.6\n\n    def advance(self, nap):\n        self.size -= nap\n        if self.size <= 0.1:\n            self.reset()\n        else:\n            self.x -= 120 * nap\n```", "```py\ndef initialize(self):\n    self.make_particles(Star, 200)\n    self.make_particles(Trail, 200)\n    self.make_particles(Player, 1)\n```", "```py\nclass Game(PSWidget):\n    firing = False\n    fire_delay = 0\n\n    def on_touch_down(self, touch):\n        self.firing = True\n        self.fire_delay = 0\n\n    def on_touch_up(self, touch):\n        self.firing = False\n```", "```py\ndef update_glsl(self, nap):\n    self.player_x, self.player_y = Window.mouse_pos\n\n    if self.firing:\n self.fire_delay -= nap\n\n    PSWidget.update_glsl(self, nap)\n```", "```py\nclass Bullet(Particle):\n    active = False\n    tex_name = 'bullet'\n\n    def reset(self, created=False):\n        self.active = False\n        self.x = -100\n        self.y = -100\n```", "```py\ndef advance(self, nap):\n    if self.active:\n        self.x += 250 * nap\n        if self.x > self.parent.width:\n            self.reset()\n\n    elif (self.parent.firing and\n          self.parent.fire_delay <= 0):\n        self.active = True\n        self.x = self.parent.player_x + 40\n        self.y = self.parent.player_y\n        self.parent.fire_delay += 0.3333\n```", "```py\nclass Game(PSWidget):\n    spawn_delay = 1\n\n    def update_glsl(self, nap):\n        self.player_x, self.player_y = Window.mouse_pos\n\n        if self.firing:\n            self.fire_delay -= nap\n\n        self.spawn_delay -= nap\n\n        PSWidget.update_glsl(self, nap)\n```", "```py\ndef initialize(self):\n    self.make_particles(Star, 200)\n    self.make_particles(Trail, 200)\n    self.make_particles(Player, 1)\n    self.make_particles(Enemy, 25)\n    self.make_particles(Bullet, 25)\n\n    self.bullets = self.particles[-25:]\n```", "```py\nclass Enemy(Particle):\n    active = False\n    tex_name = 'ufo'\n    v = 0\n\n    def reset(self, created=False):\n        self.active = False\n        self.x = -100\n        self.y = -100\n        self.v = 0\n\n    def advance(self, nap):\n        if self.active:\n            if self.check_hit():  # Step 1\n                self.reset()\n                return\n\n            self.x -= 200 * nap  # Step 2\n            if self.x < -50:\n                self.reset()\n                return\n\n            self.y += self.v * nap  # Step 3\n            if self.y <= 0:\n                self.v = abs(self.v)\n            elif self.y >= self.parent.height:\n                self.v = -abs(self.v)\n\n        elif self.parent.spawn_delay <= 0:  # Step 4\n            self.active = True\n            self.x = self.parent.width + 50\n            self.y = self.parent.height * random()\n            self.v = randint(-100, 100)\n            self.parent.spawn_delay += 1\n```", "```py\ndef check_hit(self):\n    if math.hypot(self.parent.player_x - self.x,\n                  self.parent.player_y - self.y) < 60:\n        return True\n\n    for b in self.parent.bullets:\n        if not b.active:\n            continue\n\n        if math.hypot(b.x - self.x, b.y - self.y) < 30:\n            b.reset()\n            return True\n```"]