["```py\n#:set padding 20\n\nFloatLayout:\n    Board:\n        id: board\n        pos_hint: {'center_x': 0.5, 'center_y': 0.5}\n        size_hint: (None, None)\n        center: root.center\n        size: [min(root.width, root.height) - 2 * padding] * 2\n```", "```py\nfrom kivy.graphics import BorderImage\nfrom kivy.uix.widget import Widget\n\nspacing = 15\n\nclass Board(Widget):\n    def __init__(self, **kwargs):\n        super(Board, self).__init__(**kwargs)\n        self.resize()\n\n    def resize(self, *args):\n        self.cell_size = (0.25 * (self.width - 5 * spacing), ) * 2\n        self.canvas.before.clear()\n        with self.canvas.before:\n            BorderImage(pos=self.pos, size=self.size,\n                        source='board.png')\n\n    on_pos = resize\n    on_size = resize\n```", "```py\nfor x in range(4):\n    for y in range(4):\n        # code that uses cell at (x, y)\n```", "```py\n# In main.py\ndef all_cells():\n    for x in range(4):\n        for y in range(4):\n            yield (x, y)\n```", "```py\nfor x, y in all_cells():\n    # code that uses cell at (x, y)\n```", "```py\n# In main.py\nclass Board(Widget):\n    def cell_pos(self, board_x, board_y):\n        return (self.x + board_x *\n                (self.cell_size[0] + spacing) + spacing,\n                self.y + board_y *\n                (self.cell_size[1] + spacing) + spacing)\n```", "```py\nfrom kivy.graphics import Color, BorderImage\nfrom kivy.utils import get_color_from_hex\n\nwith self.canvas.before:\n    BorderImage(pos=self.pos, size=self.size,\n                source='board.png')\n    Color(*get_color_from_hex('CCC0B4'))\n    for board_x, board_y in all_cells():\n        BorderImage(pos=self.cell_pos(board_x, board_y),\n                    size=self.cell_size,\n                    source='cell.png')\n```", "```py\n[[None, None, None, None],\n [None, None, None, None],\n [None, None, None, None],\n [None, None, None, None]]\n```", "```py\nclass Board(Widget):\n    b = None\n\n    def reset(self):\n        self.b = [[None for i in range(4)]\n                  for j in range(4)]\n```", "```py\n# In main.py\nfrom kivy.app import App\n\nclass GameApp(App):\n    def on_start(self):\n        board = self.root.ids.board\n        board.reset()\n```", "```py\n# In main.py, under class Board:\ndef valid_cell(self, board_x, board_y):\n    return (board_x >= 0 and board_y >= 0 and\n            board_x <= 3 and board_y <= 3)\n\ndef can_move(self, board_x, board_y):\n    return (self.valid_cell(board_x, board_y) and\n            self.b[board_x][board_y] is None)\n```", "```py\nLabel:\n    pos: root.pos\n```", "```py\n# In main.py\nfrom kivy.properties import ListProperty, NumericProperty\n\nclass Tile(Widget):\n    font_size = NumericProperty(24)\n    number = NumericProperty(2)  # Text shown on the tile\n    color = ListProperty(get_color_from_hex(tile_colors[2]))\n    number_color = ListProperty(get_color_from_hex('776E65'))\n```", "```py\n<Tile>:\n    canvas:\n        Color:\n            rgb: self.color\n\n        BorderImage:\n            pos: self.pos\n            size: self.size\n            source: 'cell.png'\n\n    Label:\n        pos: root.pos\n        size: root.size\n        bold: True\n        color: root.number_color\n        font_size: root.font_size\n        text: str(root.number)\n```", "```py\n# In main.py\ncolors = (\n    'EEE4DA', 'EDE0C8', 'F2B179', 'F59563',\n    'F67C5F', 'F65E3B', 'EDCF72', 'EDCC61',\n    'EDC850', 'EDC53F', 'EDC22E')\n```", "```py\ntile_colors = {2 ** i: color for i, color in\n               enumerate(colors, start=1)}\n```", "```py\n{2: 'EEE4DA',\n 4: 'EDE0C8',\n # ...\n 1024: 'EDC53F',\n 2048: 'EDC22E'}\n```", "```py\nclass Tile(Widget):\n    font_size = NumericProperty(24)\n    number = NumericProperty(2)\n    color = ListProperty(get_color_from_hex(tile_colors[2]))\n    number_color = ListProperty(get_color_from_hex('776E65'))\n\n    def __init__(self, number=2, **kwargs):\n        super(Tile, self).__init__(**kwargs)\n        self.font_size = 0.5 * self.width\n        self.number = number\n        self.update_colors()\n\n    def update_colors(self):\n        self.color = get_color_from_hex(\n            tile_colors[self.number])\n        if self.number > 4:\n            self.number_color = \\\n                get_color_from_hex('F9F6F2')\n```", "```py\ntile = Tile(pos=self.cell_pos(x, y), size=self.cell_size)\nself.add_widget(tile)\n```", "```py\nclass Tile(Widget):\n    # Other methods skipped to save space\n\n    def resize(self, pos, size):\n        self.pos = pos\n        self.size = size\n        self.font_size = 0.5 * self.width\n```", "```py\ndef resize(self, *args):\n    # Previously-seen code omitted\n\n    for board_x, board_y in all_cells():\n        tile = self.b[board_x][board_y]\n        if tile:\n            tile.resize(pos=self.cell_pos(board_x, board_y),\n                        size=self.cell_size)\n```", "```py\n# In main.py, a method of class Board:\ndef new_tile(self, *args):\n    empty_cells = [(x, y) for x, y in all_cells()  # Step 1\n                   if self.b[x][y] is None]\n\n    x, y = random.choice(empty_cells)  # Step 2\n    tile = Tile(pos=self.cell_pos(x, y),  # Step 3\n                size=self.cell_size)\n    self.b[x][y] = tile  # Step 4\n    self.add_widget(tile)\n```", "```py\ndef reset(self):\n    self.b = [[None for i in range(4)]\n              for j in range(4)]  # same as before\n    self.new_tile()\n    self.new_tile()  # put down 2 tiles\n```", "```py\nfrom kivy.core.window import Keyboard\n\nkey_vectors = {\n    Keyboard.keycodes['up']: (0, 1),\n    Keyboard.keycodes['right']: (1, 0),\n    Keyboard.keycodes['down']: (0, -1),\n    Keyboard.keycodes['left']: (-1, 0),\n}\n```", "```py\n# In main.py, under class Board:\ndef on_key_down(self, window, key, *args):\n    if key in key_vectors:\n        self.move(*key_vectors[key])\n\n# Then, during the initialization (in GameApp.on_start())\nWindow.bind(on_key_down=board.on_key_down)\n```", "```py\ndef all_cells(flip_x=False, flip_y=False):\n    for x in (reversed(range(4)) if flip_x else range(4)):\n        for y in (reversed(range(4)) if flip_y else range(4)):\n            yield (x, y)\n```", "```py\ndef move(self, dir_x, dir_y):\n    for board_x, board_y in all_cells(dir_x > 0, dir_y > 0):\n        tile = self.b[board_x][board_y]\n        if not tile:\n            continue\n\n        x, y = board_x, board_y\n        while self.can_move(x + dir_x, y + dir_y):\n            self.b[x][y] = None\n            x += dir_x\n            y += dir_y\n            self.b[x][y] = tile\n\n        if x == board_x and y == board_y:\n            continue  # nothing has happened\n\n        anim = Animation(pos=self.cell_pos(x, y),\n                         duration=0.25, transition='linear')\n        anim.start(tile)\n```", "```py\nfrom kivy.vector import Vector\n\n# A method of class Board:\ndef on_touch_up(self, touch):\n    v = Vector(touch.pos) - Vector(touch.opos)\n    if v.length() < 20:\n        return\n\n    if abs(v.x) > abs(v.y):\n        v.y = 0\n    else:\n        v.x = 0\n\n    self.move(*v.normalize())\n```", "```py\ndef can_combine(self, board_x, board_y, number):\n    return (self.valid_cell(board_x, board_y) and\n            self.b[board_x][board_y] is not None and\n            self.b[board_x][board_y].number == number)\n```", "```py\nif self.can_combine(x + dir_x, y + dir_y,\n                    tile.number):\n    self.b[x][y] = None\n    x += dir_x\n    y += dir_y\n    self.remove_widget(self.b[x][y])\n    self.b[x][y] = tile\n    tile.number *= 2\n    tile.update_colors()\n```", "```py\ndef move(self, dir_x, dir_y):\n    moving = False\n\n    # Large portion of the code is omitted to save trees\n\n        if x == board_x and y == board_y:\n            continue  # nothing has happened\n\n        anim = Animation(pos=self.cell_pos(x, y),\n                         duration=0.25, transition='linear')\n        if not moving:\n            anim.on_complete = self.new_tile\n            moving = True\n\n        anim.start(tile)\n```", "```py\n# This is for demonstration only\nanim = Animation(pos=self.cell_pos(x, y),\n                 duration=10, transition='linear')\n```", "```py\nclass Board(Widget):\n moving = False\n\n    def move(self, dir_x, dir_y):\n if self.moving:\n return\n\n        # Again, large portion of the code is omitted\n\n            anim = Animation(pos=self.cell_pos(x, y),\n                             duration=0.25,\n                             transition='linear')\n if not self.moving:\n                anim.on_complete = self.new_tile\n self.moving = True\n\n            anim.start(tile)\n```", "```py\ntile.number *= 2\nif (tile.number == 2048):\n    print('You win the game')\n```", "```py\ndef is_deadlocked(self):\n    for x, y in all_cells():\n        if self.b[x][y] is None:\n            return False  # Step 1\n\n        number = self.b[x][y].number\n        if self.can_combine(x + 1, y, number) or \\\n                self.can_combine(x, y + 1, number):\n            return False  # Step 2\n    return True  # Step 3\n```", "```py\ndef new_tile(self, *args):\n    empty_cells = [(x, y) for x, y in all_cells()\n                   if self.b[x][y] is None]\n\n    # Spawning a new tile (omitted)\n\n    if len(empty_cells) == 1 and self.is_deadlocked():\n        print('Game over (board is deadlocked)')\n\n    self.moving = False  # See above, \"Synchronizing turns\"\n```"]