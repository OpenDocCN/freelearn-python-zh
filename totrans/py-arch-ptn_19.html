<html><head></head><body><div><p>&#13;&#13;
    <h1 class="chapterNumber">15</h1>&#13;&#13;
    <h1 id="_idParaDest-273" class="chapterTitle">Debugging</h1>&#13;&#13;
    <p class="normal">Generally speaking, the cycle for debugging problems has the following steps:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered">Detecting the problem. A new problem or defect is discovered</li>&#13;&#13;
      <li class="numbered">Analyzing and assigning priority to this problem, to be sure that we spend time on meaningful problems and focus on the most important ones</li>&#13;&#13;
      <li class="numbered">Investigating what exactly causes the problem. Ideally, this should end with a way of replicating the problem in a local environment</li>&#13;&#13;
      <li class="numbered">Replicating the problem locally, and getting into the specific details on why it happens</li>&#13;&#13;
      <li class="numbered">Fixing the problem</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">As you can see, the general strategy is to first locate and understand the problem, so we can then properly debug and fix it.</p>&#13;&#13;
    <p class="normal">In this chapter, we'll cover the following topics to see effective techniques on how to work through all those phases:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Detecting and processing defects</li>&#13;&#13;
      <li class="bullet">Investigation in production</li>&#13;&#13;
      <li class="bullet">Understanding the problem in production</li>&#13;&#13;
      <li class="bullet">Local debugging</li>&#13;&#13;
      <li class="bullet">Python introspection tools</li>&#13;&#13;
      <li class="bullet">Debugging with logs</li>&#13;&#13;
      <li class="bullet">Debugging with breakpoints</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Let's take a look at the very first step when dealing with defects.</p>&#13;&#13;
    <h1 id="_idParaDest-274" class="title">Detecting and processing defects</h1>&#13;&#13;
    <p class="normal">The first step is actually detecting the problem. This can sound a bit silly, but it's a quite crucial stage.</p>&#13;&#13;
    <div>&#13;&#13;
      <p class="Tip--PACKT-">While we will mainly use the term "bug" to describe any defect, remember that it may include details like bad performance or unexpected behavior that may not be properly categorized as a "bug." The proper tool to fix the problem could be different, but the detection is normally done in a similar way.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Detecting problems can be<a id="_idIndexMarker986"/> done in different ways, and some may be more evident than others. Normally, once the code is in production, defects will be detected by a user, either internally (best case) or externally (worst case), or through monitoring.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Keep in mind that monitoring will only be able to capture obvious, and typically serious, errors.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Based on how problems are detected, we can categorize them into different severities, for example:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Catastrophic problems</strong> that are<a id="_idIndexMarker987"/> completely stopping the operation. These bugs mean that nothing, not even non-related tasks in the same system, works</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Critical problems</strong> that<a id="_idIndexMarker988"/> stop the execution of some tasks, but not others</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Serious problems</strong> that <a id="_idIndexMarker989"/>will stop or cause problems with certain tasks, but only in some circumstances. For example, a parameter is not checked and produces an exception, or some combination produces a task so slow that it produces a timeout</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Mild problems</strong>, which include<a id="_idIndexMarker990"/> tasks containing errors or inaccuracies. For example, a task produces an empty result in certain circumstances, or a problem in the UI that doesn't allow calling a functionality</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Cosmetic or minor problems</strong> like <a id="_idIndexMarker991"/>typos and similar</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Because every development team is limited, there will always be too many bugs and having the proper approach on what to pay attention to and what to fix first is critical. Normally bugs in the first group will obviously be quite pressing to fix and will require an immediate all-hands reaction. But categorization and prioritization are important. </p>&#13;&#13;
    <p class="normal">Having a clear signal on what things to look for next will help developers have a clear view and be efficient by spending time on important problems and not whatever is the latest. Teams themselves can perform some triage of problems, but it's good to add some context.</p>&#13;&#13;
    <p class="normal">Keep in mind that usually, you<a id="_idIndexMarker992"/> need to both correct bugs and implement new features, and each of these tasks can distract from the other. </p>&#13;&#13;
    <p class="normal">Fixing bugs is important, not only for the resulting quality of the service, as any user will find working with a buggy service very frustrating. But it's also important for the development team, as working with a low-quality service is also frustrating for developers. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">A proper balance needs to be struck between bug fixing and introducing new features. Also remember to allocate time for the corresponding new bugs introduced for new features. A feature is not ready when released, it's ready when its bugs are fixed.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Any detected problem, except the catastrophic ones, where context is irrelevant, should capture the context surrounding the steps that were required to produce the error. The objective of this is to be able to <em class="italic">reproduce</em> the error.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Reproducing the error is a critical element of fixing it. The worst-case scenario is that a bug is intermittent or appears to happen at random times. More digging will be required in order to understand why it is happening when it's happening.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">When a problem can <a id="_idIndexMarker993"/>be replicated, you're halfway to the solution. The problem can be ideally replicated into a test, so it can be tested over and over until the problem is understood and fixed. In the best situations, this test can be a unit test, if the problem affects a single system and all the conditions are understood and can be replicated. If the problem affects more than one system, it may be necessary to create integration tests.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">A common problem during an investigation is to find out what the specific circumstances are that are provoking the problem, for example, data that's set up in a particular way in production and that triggers some issue. Finding exactly what is causing the problem can be complicated in this environment. We will talk later in the chapter about finding a problem in production.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Once a problem is categorized and replicable, the investigation can proceed to understand <em class="italic">why</em>.</p>&#13;&#13;
    <p class="normal">Visually inspecting the code and trying to reason where problems and bugs are is normally not good enough. Even very simple code will surprise you in terms of how it's executed. Being able to analyze how, in a particular case, the code is executing with precision is critical for analyzing and fixing problems that are found.</p>&#13;&#13;
    <h1 id="_idParaDest-275" class="title">Investigation in production</h1>&#13;&#13;
    <p class="normal">Once we are aware that <a id="_idIndexMarker994"/>we have a problem in production, we need to understand what is happening and what the key elements that produce it are.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">It's very important to remark on the importance of being able to replicate a problem. If that's the case, tests can be done to produce the error and follow the consequences.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The most important tools when analyzing why a particular problem is produced are the observability tools. That's why it is important to do preparation work in advance to be sure to be able to find problems when required.</p>&#13;&#13;
    <p class="normal">We talked in previous chapters about logs and metrics. When debugging, metrics are normally not relevant, except to show the relative importance of a bug. Checking an increase in returned errors can be important to detect that there's an error, but detecting what error will require more precise information.</p>&#13;&#13;
    <p class="normal">Do not underestimate metrics, though. They can help quickly determine what specific component is failing or if there's any relationship with other elements, for example, if there's a single server that's producing errors, or if it has run out of memory or hard drive space. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">For example, a problematic server can produce apparently random errors, if the external requests are directed to different servers, and the failure is related to a combination of a specific request addressed to a specific server.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">But in any case, logs will generally be more useful in determining which part of the code is behaving badly. As we saw in <em class="chapterRef">Chapter 12</em>,<em class="italic"> Logging</em>, we can describe error logs as detecting two kinds of problems:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Expected errors</strong>. In this case, we<a id="_idIndexMarker995"/> did the work of debugging the error beforehand and knowing what happened should be easy. Examples of this can be an external request that returns an error, a database that cannot be connected to, etc.<p class="bullet-para">Most of these errors will be related to external services (from the point of view of the one raising the error) that are misbehaving. This could indicate a network problem, misconfiguration, or problems in other services. It is not rare that errors propagate through the system as an error may provoke a cascading failure. Typically, though, the<a id="_idIndexMarker996"/> origin will be an unexpected error and the rest will be expected ones, as they'll receive the error from an external source.</p>&#13;&#13;
      </li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Unexpected errors</strong>. The sign <a id="_idIndexMarker997"/>of these errors are logs indicating that something has gone wrong, and in most modern programming languages, a stack trace of some sort in the logs detailing the line of code when the error was produced.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">By default, any kind of framework that executes tasks, like a web framework or task management system, will produce an error, but keep the system stable. This means that only the task producing the error will be interrupted and any new task will be handled from scratch.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="bullet-para">The system should provide the proper handling for the task. For example, a web server will return a 500 error, and a task management system may retry the task after some delay. This may lead to the error being propagated, as we saw before.</p>&#13;&#13;
    <p class="normal">In any of the two <a id="_idIndexMarker998"/>cases, the main tool to detect what the problem was will be logs. Either the logs show a known problem that is captured and properly labeled, or the logs show a stack trace that should indicate what specific part of the code is showing the error.</p>&#13;&#13;
    <p class="normal">Finding the element and part of the code that is the source of the error is important for understanding the problem and for debugging the specific problem. This is particularly important in microservices architectures, as they'll have multiple independent elements.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">We talked about microservices and monolithic architectures in <em class="chapterRef">Chapter 9</em>,<em class="chapterRef"> </em><em class="italic">Microservices vs Monolith</em>. Monoliths are easier to deal with in terms of bugs, as all the code is handled on the same site, but anyway they'll become more and more complex as they grow.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Keep in mind that sometimes it is not possible to totally avoid errors. For example, if there's an external dependency calling an external API and it has a problem, this may trigger internal errors. These can be mitigated, failing gracefully, or generating a state of "service not available." But the root of the error may not be possible to fixÂ totally. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Mitigating external dependencies may require creating redundancy, even using different suppliers so as not to be dependent on a single point of failure, though this may not be realistic, as it can be extremely costly.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">We can have these cases be notified to us, but they won't require further short-term action.</p>&#13;&#13;
    <p class="normal">In other cases, when the error is not immediately obvious and further investigation needs to be done, it will require some debugging.</p>&#13;&#13;
    <h1 id="_idParaDest-276" class="title">Understanding the problem in production</h1>&#13;&#13;
    <p class="normal">The challenge in complex systems is the fact that detecting problems becomes exponentially more complicated. As<a id="_idIndexMarker999"/> multiple layers and modules are added and interact with each other, bugs become potentially more subtle and more complex.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">As we saw before, microservice architectures can be especially difficult to debug. The interaction between different microservices can produce complex interactions that can produce subtle problems in the integration of its different parts. This integration can be difficult to test in integration tests, or perhaps the source of the problem is in a blind spot of the integration tests.</p>&#13;&#13;
      <p class="Tip--PACKT-">But monoliths can also have problems as their parts grow more complex. Difficult bugs may be produced due to the interaction of specific production data that interacts in an unexpected way. A big advantage of monolithic systems is that the tests will cover the whole system, making it easier to replicate with unit or integration tests.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The objective in this step, though, should be to analyze enough of the problem in production to be able to replicate it in a local environment, where the smaller scale of the environment will make it easier and less invasive to probe and make changes. Once enough information has been collected, it's better to leave any production environment alone and focus on the specifics of the problem. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Remember that having a replicable bug is more than half the battle! Once the problem can be categorized as a replicable set of steps locally, a test can be created to produce it over and over and debug in a controlled environment.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Sometimes, general logging enabled is enough to determine exactly what the bug is or how to replicate it locally. In those cases, it may be necessary to research the circumstances that trigger the problem.</p>&#13;&#13;
    <h2 id="_idParaDest-277" class="title">Logging a request ID</h2>&#13;&#13;
    <p class="normal">One of the problems <a id="_idIndexMarker1000"/>when analyzing a large number of logs is correlating them. To properly group logs that are related to each other, we could filter by the host that generates them and select a short window of time, but even that may not be good enough as two or more different tasks can be running at the same time. We need a unique identifier per task or request that can trace all logs coming from the same source. We will call this<a id="_idIndexMarker1001"/> identifier a request ID, as they are added automatically in many frameworks. This sometimes is called a task ID in task managers.</p>&#13;&#13;
    <p class="normal">In cases where multiple services are involved, like in microservice architectures, it is very important to keep a common request ID that can work to trace the different requests between different services. That allows you to follow and correlate different logs in the system from different services that have the same origin. </p>&#13;&#13;
    <p class="normal">The following diagram shows the flow between a frontend and two backend services that are called internally. Note that the <code class="Code-In-Text--PACKT-">X-Request-ID</code> header is set by the frontend and it's forwarded to service A, which then forwards it toward service B.</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_15_01.png" alt="A picture containing diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="319"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 15.1: Request ID across multiple services</p>&#13;&#13;
    <p class="normal">Because all of them share the same request ID, logs can be filtered by that information to obtain all the information about a single task.</p>&#13;&#13;
    <p class="normal">To achieve this, we can use the module <code class="Code-In-Text--PACKT-">django_log_request_id</code> to create a request ID in Django applications.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">You can see the whole documentation here: <a href="https://github.com/dabapps/django-log-request-id/">https://github.com/dabapps/django-log-request-id/</a>.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">We show some code<a id="_idIndexMarker1002"/> in GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug">https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug</a> following the example across the book. This requires creating a virtual environment and installing the package, alongside the rest of the requirements.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m venv ./venv&#13;&#13;
$ source ./venv/bin/activate&#13;&#13;
(venv) $ pip install -r requirements.txt&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The code has been<a id="_idIndexMarker1003"/> changed to include some extra logs in the <code class="Code-In-Text--PACKT-">microposts/api/views.py</code> file (as seen at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py</a>):</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">from rest_framework.generics import ListCreateAPIView&#13;&#13;
from rest_framework.generics import RetrieveUpdateDestroyAPIView&#13;&#13;
from .models import Micropost, Usr&#13;&#13;
from .serializers import MicropostSerializer&#13;&#13;
import logging&#13;&#13;
logger = logging.getLogger(__name__)&#13;&#13;
class MicropostsListView(ListCreateAPIView):&#13;&#13;
    serializer_class = MicropostSerializer&#13;&#13;
    def get_queryset(self):&#13;&#13;
        logger.info('Getting queryset')&#13;&#13;
        result = Micropost.objects.filter(user__username=self.kwargs['username'])&#13;&#13;
        logger.info(f'Querysert ready {result}')&#13;&#13;
        return result&#13;&#13;
    def perform_create(self, serializer):&#13;&#13;
        user = Usr.objects.get(username=self.kwargs['username'])&#13;&#13;
        serializer.save(user=user)&#13;&#13;
class MicropostView(RetrieveUpdateDestroyAPIView):&#13;&#13;
    serializer_class = MicropostSerializer&#13;&#13;
    def get_queryset(self):&#13;&#13;
        logger.info('Getting queryset for single element')&#13;&#13;
        result = Micropost.objects.filter(user__username=self.kwargs['username'])&#13;&#13;
        logger.info(f'Queryset ready {result}')&#13;&#13;
        return result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note how this is now adding some logs when accessing the list collections page and the individual micropost page. We will use the example URL <code class="Code-In-Text--PACKT-">/api/users/jaime/collection/5</code>.</p>&#13;&#13;
    <p class="normal">To enable the <a id="_idIndexMarker1004"/>usage of the request ID, we need to properly set up the <a id="_idIndexMarker1005"/>configuration in <code class="Code-In-Text--PACKT-">microposts/settings.py</code> (<a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py</a>):</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">LOG_REQUEST_ID_HEADER = "HTTP_X_REQUEST_ID"&#13;&#13;
GENERATE_REQUEST_ID_IF_NOT_IN_HEADER = True&#13;&#13;
LOGGING = {&#13;&#13;
    'version': 1,&#13;&#13;
    'disable_existing_loggers': False,&#13;&#13;
    'filters': {&#13;&#13;
        'request_id': {&#13;&#13;
            '()': 'log_request_id.filters.RequestIDFilter'&#13;&#13;
        }&#13;&#13;
    },&#13;&#13;
    'formatters': {&#13;&#13;
        'standard': {&#13;&#13;
            'format': '%(levelname)-8s [%(asctime)s] [%(request_id)s] %(name)s: %(message)s'&#13;&#13;
        },&#13;&#13;
    },&#13;&#13;
    'handlers': {&#13;&#13;
        'console': {&#13;&#13;
            'level': 'INFO',&#13;&#13;
            'class': 'logging.StreamHandler',&#13;&#13;
            'filters': ['request_id'],&#13;&#13;
            'formatter': 'standard',&#13;&#13;
        },&#13;&#13;
    },&#13;&#13;
    'root': {&#13;&#13;
        'handlers': ['console'],&#13;&#13;
        'level': 'INFO',&#13;&#13;
    },&#13;&#13;
}&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">LOGGING</code> dictionary is a characteristic in Django that describes how to log. <code class="Code-In-Text--PACKT-">filters</code> adds extra information, in this case, our <code class="Code-In-Text--PACKT-">request_id</code>, <code class="Code-In-Text--PACKT-">formatter</code> describes the specific format to use (note that we add <code class="Code-In-Text--PACKT-">request_id</code> as a parameter, which will be presented in brackets). </p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">handlers</code> describes what happens to each message, joining <code class="Code-In-Text--PACKT-">filters</code> and <code class="Code-In-Text--PACKT-">formatter</code> with information about levels to display and where to send the info. In this case, <code class="Code-In-Text--PACKT-">StreamHandler</code> will <a id="_idIndexMarker1006"/>send the log to <code class="Code-In-Text--PACKT-">stdout</code>. We set all the logs on the <code class="Code-In-Text--PACKT-">root</code> level to<a id="_idIndexMarker1007"/> use this <code class="Code-In-Text--PACKT-">handler</code>.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Check the Django documentation for more information: <a href="https://docs.djangoproject.com/en/3.2/topics/logging/">https://docs.djangoproject.com/en/3.2/topics/logging/</a>. Logging in Django may take a bit of experience in setting all the parameters correctly. Take your time when configuring it.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The lines,</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">LOG_REQUEST_ID_HEADER = "HTTP_X_REQUEST_ID"&#13;&#13;
GENERATE_REQUEST_ID_IF_NOT_IN_HEADER = True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">state that a new <code class="Code-In-Text--PACKT-">Request ID</code> parameter should be created if not found as a header in the input and that the name of the header will be <code class="Code-In-Text--PACKT-">X-Request-ID</code>.</p>&#13;&#13;
    <p class="normal">Once all of this is configured, we can run a test starting the server with: </p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(venv) $ python3 manage.py runserver&#13;&#13;
Watching for file changes with StatReloader&#13;&#13;
2021-10-23 16:11:16,694 INFO     [none] django.utils.autoreload: Watching for file changes with StatReloader&#13;&#13;
Performing system checks...&#13;&#13;
System check identified no issues (0 silenced).&#13;&#13;
October 23, 2021 - 16:11:16&#13;&#13;
Django version 3.2.8, using settings 'microposts.settings'&#13;&#13;
Starting development server at http://127.0.0.1:8000/&#13;&#13;
Quit the server with CONTROL-C&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">On another screen, make a call to the test URL with <code class="Code-In-Text--PACKT-">curl</code>:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(venv) $ curl http://localhost:8000/api/users/jaime/collection/5&#13;&#13;
{"href":"http://localhost:8000/api/users/jaime/collection/5","id":5,"text":"A referenced micropost","referenced":"dana","timestamp":"2021-06-10T21:15:27.511837Z","user":"jaime"}&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">At the same time, you'll see the logs on the server screen:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">2021-10-23 16:12:47,969 INFO     [66e9f8f1b43140338ddc3ef569b8e845] api.views: Getting queryset for single element&#13;&#13;
2021-10-23 16:12:47,971 INFO     [66e9f8f1b43140338ddc3ef569b8e845] api.views: Queryset ready &lt;QuerySet [&lt;Micropost: Micropost object (1)&gt;, &lt;Micropost: Micropost object (2)&gt;, &lt;Micropost: Micropost object (5)&gt;]&gt;&#13;&#13;
[23/Oct/2021 16:12:47] "GET /api/users/jaime/collection/5 HTTP/1.1" 200 177&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Which, as you can <a id="_idIndexMarker1008"/>see, added<a id="_idIndexMarker1009"/> a new request ID element, <code class="Code-In-Text--PACKT-">66e9f8f1b43140338ddc3ef569b8e845</code> in this case.</p>&#13;&#13;
    <p class="normal">But the request ID can also be created by calling with the proper header. Let's try again, making another <code class="Code-In-Text--PACKT-">curl</code> request and the <code class="Code-In-Text--PACKT-">-H</code> parameter to add a header.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ curl -H "X-Request-ID:1A2B3C" http://localhost:8000/api/users/jaime/collection/5&#13;&#13;
{"href":"http://localhost:8000/api/users/jaime/collection/5","id":5,"text":"A referenced micropost","referenced":"dana","timestamp":"2021-06-10T21:15:27.511837Z","user":"jaime"}&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">You can check the logs in the server again:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">2021-10-23 16:14:41,122 INFO     [1A2B3C] api.views: Getting queryset for single element&#13;&#13;
2021-10-23 16:14:41,124 INFO     [1A2B3C] api.views: Queryset ready &lt;QuerySet [&lt;Micropost: Micropost object (1)&gt;, &lt;Micropost: Micropost object (2)&gt;, &lt;Micropost: Micropost object (5)&gt;]&gt;&#13;&#13;
[23/Oct/2021 16:14:41] "GET /api/users/jaime/collection/5 HTTP/1.1" 200 177&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This shows that the request ID has been set by the value in the header.</p>&#13;&#13;
    <p class="normal">The request ID can be passed over other services by using the <code class="Code-In-Text--PACKT-">Session</code> included in the same module, which acts as a <code class="Code-In-Text--PACKT-">Session</code> in the <code class="Code-In-Text--PACKT-">requests</code> module.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">from log_request_id.session import Session&#13;&#13;
session = Session()&#13;&#13;
session.get('http://nextservice/url')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This will set the<a id="_idIndexMarker1010"/> proper header in the request, passing through it to the next<a id="_idIndexMarker1011"/> step of the chain, like service A or service B.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Be sure to check the <code class="Code-In-Text--PACKT-">django-log-request-id</code> documentation.</p>&#13;&#13;
    </p>&#13;&#13;
    <h2 id="_idParaDest-278" class="title">Analyzing data</h2>&#13;&#13;
    <p class="normal">If the default logs are not <a id="_idIndexMarker1012"/>enough to understand the problem, the next stage in those cases is understanding the data related to the problem. Typically, the data storage may be inspected to follow up on the related data for the task, to see if there's any indication about that.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">This step may be complicated by either missing data or data restrictions that make it difficult or impossible to obtain the data. Sometimes only a few people in the organization can access the required data, which may delay the investigation. Another possibility is that the data is impossible to retrieve. For example, data policies <a id="_idIndexMarker1013"/>may not store the data, or the data may be encrypted. This is a regular occurrence in cases involving <strong class="keyword">Personally Identifiable Information</strong> (<strong class="keyword">PII</strong>), passwords, or similar data.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Analyzing the stored data may require performing ad hoc manual queries to databases or other kinds of data storage to find out if the related data is consistent or if there is any combination of parameters that's not expected.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Remember that the objective is to capture information from production to be able to understand and replicate the problem independently.In some cases, when investigating a problem in production, it is possible that changing the data manually will fix the issue. This could be necessary in some emergency situations, but the objective still needs to be to understand why this inconsistent situation of the data has been possible or how the service should be changed to allow you to deal with this data situation. Then the code can be changed accordingly to ensure that the problem doesn't happen in the future.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">If investigating the <a id="_idIndexMarker1014"/>data is not enough to be able to understand the problem, it may be necessary to increase the information on the logs.</p>&#13;&#13;
    <h2 id="_idParaDest-279" class="title">Increasing logging</h2>&#13;&#13;
    <p class="normal">If the regular logs and <a id="_idIndexMarker1015"/>an investigation of the data don't bear fruit, it may be necessary to increase the level of logging with special logs, following the problem.</p>&#13;&#13;
    <p class="normal">This is a last-resort method, because it has two main problems:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Any change in the logs needs to be deployed, which makes it costly and expensive to run. </li>&#13;&#13;
      <li class="bullet">The number of logs in the system will be incremented, which will require more space to store them. Depending on the number of requests in the system, this can create pressure on the logging system.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">These extra logs should always be short term, and should be reverted as soon as possible.</p>&#13;&#13;
    <p class="normal">While enabling an extra level of logging, like setting logs to <code class="Code-In-Text--PACKT-">DEBUG</code> level, is technically possible, this will probably increase the logs too much, and will make it difficult to know what the key ones are in the massive amount of logs. With some <code class="Code-In-Text--PACKT-">DEBUG</code> logs, specifics of the area under investigation can be temporally promoted to <code class="Code-In-Text--PACKT-">INFO</code> or higher to make sure that they are properly logged.</p>&#13;&#13;
    <p class="normal">Be extra careful with information that's logged temporally. Confidential information like PII should not be logged. Instead, try to log surrounding information that can help find out the problem.</p>&#13;&#13;
    <p class="normal">For example, if there's a suspicion that some unexpected character may be producing a problem with the algorithm to check the password, instead of logging the password, some code can be added to detect whether there's an invalid character.</p>&#13;&#13;
    <p class="normal">For example, assuming there's a problem with a password or secret that has an emoji, we could extract only non-ASCII characters to find out if this is the problem, like this:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; password = 'secret password <img src="img/Emoji.png" alt="" width="21" height="20"/>'&#13;&#13;
&gt;&gt;&gt; bad_characters = [c for c in password if not c.isascii()]&#13;&#13;
&gt;&gt;&gt; bad_characters&#13;&#13;
['<img src="img/Emoji.png" alt="" width="21" height="20"/>']&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The value in <code class="Code-In-Text--PACKT-">bad_characters</code> can be then logged, as it won't contain the full password. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Note that this assumption is probably easier to test quickly and without any secret data with a unit test. This is just an example.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Adding temporal <a id="_idIndexMarker1016"/>logs is cumbersome, as it typically will involve several deployments until finding out the problem. It's always important to keep the number of logs to a minimum, cleaning up the useless ones as quickly as possible, and remember to remove them completely after the work is done.</p>&#13;&#13;
    <p class="normal">Remember that the work is just to be able to reproduce the problem locally, so you can more efficiently investigate and fix the problem locally. Sometimes the problem may be deemed obvious after some temporal log, but, good TDD practice, as we saw in <em class="chapterRef">Chapter 10</em>,<em class="italic"> Testing and TDD</em>, tests displaying and then fixing the bug.</p>&#13;&#13;
    <p class="normal">Once we can detect the problem locally, it is time to go to the next step.</p>&#13;&#13;
    <h1 id="_idParaDest-280" class="title">Local debugging</h1>&#13;&#13;
    <p class="normal">Debugging locally means exposing and<a id="_idIndexMarker1017"/> fixing a problem once we have a local reproduction.</p>&#13;&#13;
    <p class="normal">The basic steps of debugging are reproducing the problem, knowing what the current, incorrect result is, and knowing what the correct result should be. With that information, we can start debugging.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">A great way of creating the reproduction of the problem is with a test, if that's possible. As we saw in <em class="chapterRef">Chapter 10</em>,<em class="italic"> Testing and TDD</em>, this is the basis of TDD. Create a test that fails and then change the code to make it pass. This approach is very usable when fixing bugs.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Taking a step back, any debugging process follows the following process:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">You realize there's a problem</li>&#13;&#13;
      <li class="numbered">You understand what the correct behavior should be</li>&#13;&#13;
      <li class="numbered">You investigate and discover why the current system behaves incorrectly</li>&#13;&#13;
      <li class="numbered">You fix the problem</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">Keeping this process in mind is also useful from a local debugging perspective, though at this point, it is likely that <em class="italic">steps 1</em> and <em class="italic">2</em> are already sorted out. In the vast majority of cases, the difficult step is <em class="italic">3</em>, as we've been seeing throughout the chapter.</p>&#13;&#13;
    <p class="normal">To understand, once<a id="_idIndexMarker1018"/> presented with the code, <em class="italic">why</em> the code is behaving as it is, a method similar to the scientific method can be used to systematize the approach:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">Measure and observe the code</li>&#13;&#13;
      <li class="numbered">Produce a hypothesis on why a certain result is being produced</li>&#13;&#13;
      <li class="numbered">Validate or disprove the hypothesis by either analyzing the produced state, if possible, or creating a specific "experiment" (some specific code, like a test) to force it to be produced</li>&#13;&#13;
      <li class="numbered">Use the resulting information to iterate the process until the source of the problem is totally understood</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">Note that this process doesn't necessarily need to be applied to the whole problem. It can be focused on the specific parts of the code that can influence the problem. For example, is this setting activated in this case? Is this loop in the code being accessed? Is the value calculated lower than a threshold, which will later send us down a different code path? </p>&#13;&#13;
    <p class="normal">All those answers will increase the knowledge of why the code is behaving in the way that it's behaving.</p>&#13;&#13;
    <p class="normal">Debugging is a skill. Some people may say it's an art. In any case, it can be improved over time, as more time gets invested in it. Practice plays an important role in developing the kind of intuition that involves knowing when to take a deeper look into some areas over others to identify the promising areas where the code may be failing. </p>&#13;&#13;
    <p class="normal">There are some general ideas that can be very helpful when approaching debugging:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Divide and conquer</strong>. Take small steps and isolate areas of the code so it's possible to simplify the code and make it digestible. As important as understanding when there's a problem in the code is detecting when there isn't so we can set our focus on the relevant bits. </li>&#13;&#13;
    </ul>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Edward J. Gauss<a id="_idIndexMarker1019"/> described this method in what he called the "<strong class="keyword">wolf fence algorithm</strong>" in a 1982 article:</p>&#13;&#13;
      <p class="Tip-Within-Bullet--PACKT-"><em class="italic">There's one wolf in Alaska; how do you find it? First build a fence down the middle of the state, wait for the wolf to howl, determine which side of the fence it is on. Repeat process on that side only, until you get to the point where you can see the wolf</em>.</p>&#13;&#13;
    </p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Move backward from the visible error</strong>. It's quite common that the source of a problem is not where an error is raised or obvious, but instead the error was produced earlier. A good approach is to move backward from the position where the problem is obvious and then validate the flow. This allows you to ignore all code that comes <em class="italic">after</em> the problem, and have a clear path of analysis.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">You can make an assumption, as long as you can then prove that this assumption is correct.</strong> Code is complex, and you won't be able to keep the whole codebase in your head. Instead, focus needs to be carefully moved across different parts, making assumptions about what the rest is returning.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">As Sherlock Holmes once said:</p>&#13;&#13;
      <p class="Tip-Within-Bullet--PACKT-"><em class="italic">When you have eliminated the impossible, whatever remains, however improbable, must be the truth</em>.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="bullet-para">Properly eliminating <a id="_idIndexMarker1020"/>everything can be arduous, but removing proven assumptions from the mind will reduce the amount of code to analyze and verify. </p>&#13;&#13;
    <p class="bullet-para">But those assumptions need to be validated to really prove that they are correct, or we risk the chance of making a wrong assumption. It's very easy to fall into bad assumptions and think that the problem is in a particular part of the code when it really is in another.</p>&#13;&#13;
    <p class="normal">Though the whole range of techniques and possibilities of debugging is there, and certainly sometimes bugs can be convoluted and difficult to detect and fix, most bugs are typically easy to understand and fix. Perhaps they are a typo, an off-by-one error, or a type error that needs to be checked. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Keeping the code simple helps a lot in later debugging problems. Simple code is easy to understand and debug.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Before we move on to specific techniques, we need to understand the tools in Python help in our investigation.</p>&#13;&#13;
    <h1 id="_idParaDest-281" class="title">Python introspection tools </h1>&#13;&#13;
    <p class="normal">As Python is a<a id="_idIndexMarker1021"/> dynamic language, it's very flexible and allows you to perform <a id="_idIndexMarker1022"/>actions on its objects to discover their properties or types.</p>&#13;&#13;
    <p class="normal">This is called <em class="italic">introspection</em>, and allows you to inspect elements without having too much context about the objects to be inspected. This can be performed at runtime, so it can be used while debugging to discover the attributes and methods of any object.</p>&#13;&#13;
    <p class="normal">The main starting point is the <code class="Code-In-Text--PACKT-">type</code> function. The <code class="Code-In-Text--PACKT-">type</code> function simply returns the class of an object. For example:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; my_object = {'example': True}&#13;&#13;
&gt;&gt;&gt; type(my_object)&#13;&#13;
&lt;class 'dict'&gt;&#13;&#13;
&gt;&gt;&gt; another_object = {'example'}&#13;&#13;
&gt;&gt;&gt; type(another_object)&#13;&#13;
&lt;class 'set'&gt;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This can be used to double-check that an object is of the expected <code class="Code-In-Text--PACKT-">type</code>. </p>&#13;&#13;
    <p class="normal">A typical example error is to have a problem because a variable can be either an object or <code class="Code-In-Text--PACKT-">None</code>. In that case, it's possible that a mistake handling the variable makes it necessary to double-check that the type is the expected one.</p>&#13;&#13;
    <p class="normal">While <code class="Code-In-Text--PACKT-">type</code> is useful in debugging environments, avoid using it directly in your code. </p>&#13;&#13;
    <p class="normal">For example, avoid comparing defaults of <code class="Code-In-Text--PACKT-">None</code>, <code class="Code-In-Text--PACKT-">True</code>, and <code class="Code-In-Text--PACKT-">False</code> with their types, as they are created as singletons. That means there's a single instance of each of these objects, so every time that we need to verify if an object is <code class="Code-In-Text--PACKT-">None</code>, it's better to make an identity comparison, like this:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; object = None&#13;&#13;
&gt;&gt;&gt; object is None&#13;&#13;
True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Identity comparisons can prevent the kind of problem where the usage of <code class="Code-In-Text--PACKT-">None</code> or <code class="Code-In-Text--PACKT-">False</code> can't be distinguished in an <code class="Code-In-Text--PACKT-">if</code> block.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; object = False&#13;&#13;
&gt;&gt;&gt; if not object:&#13;&#13;
...     print('Check valid')&#13;&#13;
...&#13;&#13;
Check valid&#13;&#13;
&gt;&gt;&gt; object = None&#13;&#13;
&gt;&gt;&gt; if not object:&#13;&#13;
...     print('Check valid')&#13;&#13;
...&#13;&#13;
Check valid&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Instead, only <a id="_idIndexMarker1023"/>checking against the identity comparison will allow<a id="_idIndexMarker1024"/> you to detect only the value of <code class="Code-In-Text--PACKT-">None</code> properly.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; object = False&#13;&#13;
&gt;&gt;&gt; if object is None:&#13;&#13;
...     print('object is None')&#13;&#13;
...&#13;&#13;
&gt;&gt;&gt; object = None&#13;&#13;
&gt;&gt;&gt; if object is None:&#13;&#13;
...     print('object is None')&#13;&#13;
...&#13;&#13;
object is None&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The same can be used for Boolean values.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; bool('Testing') is True&#13;&#13;
True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">For other cases, there's the <code class="Code-In-Text--PACKT-">isinstance</code> function, which can be used to find if a particular object is an instance of a particular class:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class A:&#13;&#13;
...     pass&#13;&#13;
...&#13;&#13;
&gt;&gt;&gt; a = A()&#13;&#13;
&gt;&gt;&gt; isinstance(a, A)&#13;&#13;
True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This is better than making comparisons with <code class="Code-In-Text--PACKT-">type</code>, because it is aware of any inheritance that may have been produced. For example, in the following code we see how an object from a class that inherits from another will return that it's an instance of either, while the <code class="Code-In-Text--PACKT-">type</code> function will only return one.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class A:&#13;&#13;
...     pass&#13;&#13;
...&#13;&#13;
&gt;&gt;&gt; class B(A):&#13;&#13;
...     pass&#13;&#13;
...&#13;&#13;
&gt;&gt;&gt; b = B()&#13;&#13;
&gt;&gt;&gt; isinstance(b, B)&#13;&#13;
True&#13;&#13;
&gt;&gt;&gt; isinstance(b, A)&#13;&#13;
True&#13;&#13;
&gt;&gt;&gt; type(b)&#13;&#13;
&lt;class '__main__.B'&gt;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The most <a id="_idIndexMarker1025"/>useful function for introspection, though, is <code class="Code-In-Text--PACKT-">dir</code>. <code class="Code-In-Text--PACKT-">dir</code> allows <a id="_idIndexMarker1026"/>you to see all the methods and attributes in an object, and it's particularly useful when analyzing objects from a not-clear origin, or where the interface is not clear.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; d = {}&#13;&#13;
&gt;&gt;&gt; dir(d)&#13;&#13;
['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Obtaining the whole attributes can be a bit too much in certain situations, so the returned values can filter out the double-underscore ones to reduce the amount of noise and be able to detect attributes that can give some clue about the object usage more easily.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; [attr for attr in dir(d) if not attr.startswith('__')]&#13;&#13;
['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Another interesting function is <code class="Code-In-Text--PACKT-">help</code>, which displays the help from objects. This is particularly helpful for methods:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; help(d.pop)&#13;&#13;
Help on built-in function pop:&#13;&#13;
pop(...) method of builtins.dict instance&#13;&#13;
    D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#13;&#13;
    If key is not found, default is returned if given, otherwise KeyError is raised&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This function <a id="_idIndexMarker1027"/>displays the <a id="_idIndexMarker1028"/>defined <code class="Code-In-Text--PACKT-">docstring</code> from the object.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class C:&#13;&#13;
...     '''&#13;&#13;
...     This is an example docstring&#13;&#13;
...     '''&#13;&#13;
...     pass&#13;&#13;
...&#13;&#13;
&gt;&gt;&gt; c = C()&#13;&#13;
&gt;&gt;&gt; help(c)&#13;&#13;
Help on C in module __main__ object:&#13;&#13;
class C(builtins.object)&#13;&#13;
 |  This is an example docstring&#13;&#13;
 |&#13;&#13;
 |  Data descriptors defined here:&#13;&#13;
 |&#13;&#13;
 |  __dict__&#13;&#13;
 |      dictionary for instance variables (if defined)&#13;&#13;
 |&#13;&#13;
 |  __weakref__&#13;&#13;
 |      list of weak references to the object (if defined)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">All these methods can help you navigate code that's new or under analysis without being an expert, and avoid many checks with code that can be hard to search through.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Adding sensible <code class="Code-In-Text--PACKT-">docstrings</code> is a great help not only for keeping the code well commented and adding context for developers working in the code, but also in case of debugging in <a id="_idIndexMarker1029"/>parts where the function or object is used. You can learn more about <code class="Code-In-Text--PACKT-">docstrings</code> in the PEP 257 document: <a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a>.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Using these tools is good, but let's see how we can understand the behavior of the code.</p>&#13;&#13;
    <h1 id="_idParaDest-282" class="title">Debugging with logs</h1>&#13;&#13;
    <p class="normal">A simple yet effective <a id="_idIndexMarker1030"/>way of detecting what's going on and how the code is being executed is adding comments that are displayed either containing statements like <code class="Code-In-Text--PACKT-">starting the loop here</code> or including values of variables like <code class="Code-In-Text--PACKT-">Value of A = X</code>. By strategically locating these kinds of outputs, the developer can understand the flow of the program.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">We touched on this earlier in this chapter as well as in <em class="chapterRef">Chapter 10</em>,<em class="italic"> Testing and TDD</em>. </p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The simplest form of this approach is <strong class="keyword">print debugging</strong>. It consists of adding <code class="Code-In-Text--PACKT-">print</code> statements to be able to watch the <a id="_idIndexMarker1031"/>output from them, normally while executing the code locally in a test or similar.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Print debugging can be considered a bit controversial to some people. It has been around for a long time, and it's considered a crude way of debugging. In any case, it can be very quick and flexible and can fit some debug cases very well, as we will see.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Obviously, these <code class="Code-In-Text--PACKT-">print</code> statements need to be removed after the process has been finished. One of the main <a id="_idIndexMarker1032"/>complaints about this technique is precisely this, that there's a chance that some <code class="Code-In-Text--PACKT-">print</code> statements intended for debugging are not removed, and it's a common mistake.</p>&#13;&#13;
    <p class="normal">This can be refined, though, by instead of directly using <code class="Code-In-Text--PACKT-">print</code> statements, using logs instead, as we introduced in <em class="chapterRef">Chapter 12</em>,<em class="italic"> Logging</em>.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Ideally, these logs will be <code class="Code-In-Text--PACKT-">DEBUG</code> logs, which will only be displayed when running tests, but won't be produced in a production environment. </p>&#13;&#13;
      <p class="Tip--PACKT-">While logs can be added and not produced later, it's good practice anyway to remove any spurious logs after fixing the bug. Logs can accumulate and there will be an excessive amount of them unless they are periodically taken care of. It can be difficult to find information in a big wall of text.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The advantage of this method is that it can be done quickly and it can also be used to explore logs that can then be promoted to permanent ones, once adapted.</p>&#13;&#13;
    <p class="normal">Another important advantage is that tests can be run very quickly, as adding more logs is a simple operation, and logs won't interfere with the execution of code. This makes it a good combination to use with TDD practices.</p>&#13;&#13;
    <p class="normal">The fact that the logs won't interfere with the code and code can be running unaffected can make some difficult bugs based on concurrency easier to debug, asÂ interrupting the flow of the operation in those cases will affect the behavior of theÂ bug.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Concurrent bugs can be quite complicated. They are produced when two independent threads interact in an unexpected way. Because of the uncertain nature of what one thread will start and stop or when an action from one thread will affect the other, they normally require extensive logs to try to capture the specifics of that problem.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">While debugging through logs can be quite convenient, it requires certain knowledge of where and what logs to set to obtain the relevant information. Anything not logged won't be visible in the next run. This knowledge can come through a discovery process and take time to pinpoint the relevant information that will lead to fixing the bug.</p>&#13;&#13;
    <p class="normal">Another problem is that<a id="_idIndexMarker1033"/> new logs are new code, and they can create problems if there are errors introduced like bad assumptions or typos. This will normally be easy to fix, but can be an annoyance and require a new run.</p>&#13;&#13;
    <p class="normal">Remember that all introspection tools that we talked about before in the chapter are available.</p>&#13;&#13;
    <h1 id="_idParaDest-283" class="title">Debugging with breakpoints</h1>&#13;&#13;
    <p class="normal">In other situations, it's <a id="_idIndexMarker1034"/>better to stop the execution of the code and take a look at the current status. Given that Python is a dynamic language, it means that, if we stop the execution of the script and enter the interpreter, we can run any kind of code and see its results.</p>&#13;&#13;
    <p class="normal">This is exactly what is done through the usage of the <code class="Code-In-Text--PACKT-">breakpoint</code> function.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">breakpoint</code> is a relatively new addition to Python, available since Python 3.7. Previously, it was necessary to import the module <code class="Code-In-Text--PACKT-">pdb</code>, typically in this way in a single line:</p>&#13;&#13;
      <p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">import pdb; pdb.set_trace()</code></p>&#13;&#13;
      <p class="Information-Box--PACKT-">Other than the ease of usage, <code class="Code-In-Text--PACKT-">breakpoint</code> has some other advantages that we will see.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">When the interpreter<a id="_idIndexMarker1035"/> finds a <code class="Code-In-Text--PACKT-">breakpoint</code> call, it stops and opens an interactive interpreter. From this interactive interpreter, the current status of the code can be examined and any investigation can take place, simply executing the code. This makes it possible to understand interactively what the code is doing.</p>&#13;&#13;
    <p class="normal">Let's take a look at some code and analyze how it runs. The code can be found on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py</a> and it's the following:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def valid(candidate):&#13;&#13;
    if candidate &lt;= 1:&#13;&#13;
        return False&#13;&#13;
    lower = candidate - 1&#13;&#13;
    while lower &gt; 1:&#13;&#13;
        if candidate / lower == candidate // lower:&#13;&#13;
            return False&#13;&#13;
    return True&#13;&#13;
assert not valid(1)&#13;&#13;
assert valid(3)&#13;&#13;
assert not valid(15)&#13;&#13;
assert not valid(18)&#13;&#13;
assert not valid(50)&#13;&#13;
assert valid(53)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Perhaps you are able to <a id="_idIndexMarker1036"/>understand what the code does, but let's take a look at it interactively. You can check first that all the <code class="Code-In-Text--PACKT-">assert</code> statements at the end are correct.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 debug.py&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">But we now introduce a <code class="Code-In-Text--PACKT-">breakpoint</code> call before line 9, right at the start of the <code class="Code-In-Text--PACKT-">while</code> loop.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    while lower &gt; 1:&#13;&#13;
        breakpoint()&#13;&#13;
        if candidate / lower == candidate // lower:&#13;&#13;
            return False&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Execute the program again and it now stops at that line and presents an interactive prompt:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 debug.py&#13;&#13;
&gt; ./debug.py(10)valid()&#13;&#13;
-&gt; if candidate / lower == candidate // lower:&#13;&#13;
(Pdb)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Check the value of <code class="Code-In-Text--PACKT-">candidate</code> and both operations.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(Pdb) candidate&#13;&#13;
3&#13;&#13;
(Pdb) candidate / lower&#13;&#13;
1.5&#13;&#13;
(Pdb) candidate // lower&#13;&#13;
1&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This line is checking whether <a id="_idIndexMarker1037"/>dividing <code class="Code-In-Text--PACKT-">candidate</code> by <code class="Code-In-Text--PACKT-">lower</code> produces an exact integer, as in that case both operations will return the same. Execute the next line by hitting <code class="Code-In-Text--PACKT-">n</code>, from the command <code class="Code-In-Text--PACKT-">n(ext)</code>, and check that the loop ends and it returns <code class="Code-In-Text--PACKT-">True</code>:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(Pdb) n&#13;&#13;
&gt; ./debug.py(13)valid()&#13;&#13;
-&gt; lower -= 1&#13;&#13;
(Pdb) n&#13;&#13;
&gt; ./debug.py(8)valid()&#13;&#13;
-&gt; while lower &gt; 1:&#13;&#13;
(Pdb) n&#13;&#13;
&gt; ./debug.py(15)valid()&#13;&#13;
-&gt; return True&#13;&#13;
(Pdb) n&#13;&#13;
--Return--&#13;&#13;
&gt; ./debug.py(15)valid()-&gt;True&#13;&#13;
-&gt; return True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Continue the execution until a new <code class="Code-In-Text--PACKT-">breakpoint</code> is found using the command <code class="Code-In-Text--PACKT-">c</code>, from <code class="Code-In-Text--PACKT-">c(ontinue)</code>. Note this happens on the next call to <code class="Code-In-Text--PACKT-">valid</code>, which has an input of 15.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(Pdb) c&#13;&#13;
&gt; ./debug.py(10)valid()&#13;&#13;
-&gt; if candidate / lower == candidate // lower:&#13;&#13;
(Pdb) candidate&#13;&#13;
15&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">You can also use the command <code class="Code-In-Text--PACKT-">l(ist)</code> to display the surrounding code.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(Pdb) l&#13;&#13;
  5&#13;&#13;
  6  	    lower = candidate - 1&#13;&#13;
  7&#13;&#13;
  8  	    while lower &gt; 1:&#13;&#13;
  9  	        breakpoint()&#13;&#13;
 10  -&gt;	        if candidate / lower == candidate // lower:&#13;&#13;
 11  	            return False&#13;&#13;
 12&#13;&#13;
 13  	        lower -= 1&#13;&#13;
 14&#13;&#13;
 15  	    return True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Continue freely <a id="_idIndexMarker1038"/>investigating the code. When you are finished, run <code class="Code-In-Text--PACKT-">q(uit)</code> to exit.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">(Pdb) q&#13;&#13;
bdb.BdbQuit&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">After analyzing the code carefully, you probably know what it does. It checks whether a number is prime or not by checking if it's divisible by any number lower than the number itself.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">We investigated similar code and improvements in <em class="chapterRef">Chapter 14</em>,<em class="italic"> Profiling</em>. This is, needless to say, not the most efficient way of setting code to check this, but it has been added as an example and for teaching purposes.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Another two <a id="_idIndexMarker1039"/>useful debug commands are <code class="Code-In-Text--PACKT-">s(tep)</code>, to get into a function call, and <code class="Code-In-Text--PACKT-">r(eturn)</code>, to execute the code until the current function returns its execution.</p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">breakpoint</code> can also be customized to call other debuggers, not only <code class="Code-In-Text--PACKT-">pdb</code>. There are other debuggers for Python<a id="_idIndexMarker1040"/> that include more contextual information or with more advanced usages, like <code class="Code-In-Text--PACKT-">ipdb</code> (<a href="https://pypi.org/project/ipdb/">https://pypi.org/project/ipdb/</a>). To use them, you need to set the <code class="Code-In-Text--PACKT-">PYTHONBREAKPOINT</code> environment variable with the endpoint for the debugger, after installing the debugger.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ pip3 install ipdb&#13;&#13;
â¦&#13;&#13;
$ PYTHONBREAKPOINT=IPython.core.debugger.set_trace python3 debug.py&#13;&#13;
&gt; ./debug.py(10)valid()&#13;&#13;
      8     while lower &gt; 1:&#13;&#13;
      9         breakpoint()&#13;&#13;
---&gt; 10         if candidate / lower == candidate // lower:&#13;&#13;
     11             return False&#13;&#13;
     12&#13;&#13;
ipdb&gt;&#13;&#13;
</code></pre>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">This environment variable can be set to 0 to skip any breakpoint, effectively deactivating the debug process: <code class="Code-In-Text--PACKT-">PYTHONBREAKPOINT=0</code>. This can be used as a failsafe to avoid being interrupted by breakpoint statements that haven't been properly removed, or to quickly run the code without interruptions.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">There are multiple <a id="_idIndexMarker1041"/>debuggers that can be used, including support from IDEs like Visual Studio or PyCharm. Here are examples of two other debuggers:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">pudb</code> (<a href="https://github.com/inducer/pudb">https://github.com/inducer/pudb</a>): Has a console-based graphical interface and more <a id="_idIndexMarker1042"/>context around the code and variables</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">remote-pdb</code> (<a href="https://github.com/ionelmc/python-remote-pdb">https://github.com/ionelmc/python-remote-pdb</a>): Allows you to debug remotely, connecting to a TCP socket. This allows you to debug a program running in a <a id="_idIndexMarker1043"/>different machine or trigger the debugger in a situation where there's no good access to the <code class="Code-In-Text--PACKT-">stdout</code> of the process, for example, because it's running in the background</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Using a debugger properly is a skill that requires time to learn. Be sure to try different options and get comfortable with them. Debugging will also be used while running tests, as we described in <em class="chapterRef">Chapter 10</em>,<em class="italic"> Testing and TDD</em>.</p>&#13;&#13;
    <h1 id="_idParaDest-284" class="title">Summary</h1>&#13;&#13;
    <p class="normal">In this chapter, we described the general process of detecting and fixing problems. When working in complex systems, there's the challenge of properly detecting and categorizing the different reports to be sure that they are prioritized. It's very important to be able to reliably reproduce the problem in order to show all the conditions and context that are producing the issue.</p>&#13;&#13;
    <p class="normal">Once a problem is deemed important, there needs to be an investigation into why this problem is happening. This can be on the running code, and use the available tools in production to see if it can be understood why the problem occurs. The objective of this investigation is to be able to replicate the problem locally. </p>&#13;&#13;
    <p class="normal">Most issues will be easy to reproduce locally and move forward, but we also described some tools in case it remains a mystery why the issue is being produced. As the main tool to understand the behavior of the code in production is logs, we talked about creating a request ID that can help us to trace the different calls and relate logs from different systems. We also described how the data in the environment may have the key to why the problem is occurring there. If it is necessary, the number of logs may need to be increased to extract information from production, though this should be reserved for very elusive bugs.</p>&#13;&#13;
    <p class="normal">We then moved on to how to debug locally, after replicating the problem, ideally, as we saw in <em class="chapterRef">Chapter 10</em>,<em class="italic"> Testing and TDD</em>, in the form of a unit test. We gave some general ideas to help with debugging, though it must be said that debugging is a skill that needs to be practiced.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Debugging can be learned and improved, so it's an area where more experienced developers can help their junior counterparts. Be sure to create a team where it is encouraged to help with debugging when required in difficult cases. Two pairs of eyes see more than one!</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">We introduced some of the tools that help with debugging in Python, which make use of the possibilities that Python presents for introspection. As Python is a dynamic language, there are a lot of possibilities, as it's able to execute any code, including all the introspection capabilities.</p>&#13;&#13;
    <p class="normal">We then talked about how to create logs to debug, which is an improved version of using <code class="Code-In-Text--PACKT-">print</code> statements, and, when done in a systematic way, can help to create better logs in the long run. Finally, we moved on to debugging using the <code class="Code-In-Text--PACKT-">breakpoint</code> function call, which stops the execution of the program and allows you to inspect and understand the status at that point, as well as continuing with the flow.</p>&#13;&#13;
    <p class="normal">In the next chapter, we will talk about the challenges of working in the architecture of a system when it's running and needs to be evolved.</p>&#13;&#13;
  </div>&#13;&#13;
</div></body></html>