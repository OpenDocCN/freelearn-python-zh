["```py\n@asyncio.coroutine\ndef build_user_list(query_list):\n    user_list = []\n    for record in query_list:\n        yield from asyncio.sleep(2)\n        user_list.append(\" \".join([str(record.id), \n            record.username, record.password]))\n    return user_list\n```", "```py\n@router.get(\"/login/list/all\")\n@asyncio.coroutine\ndef list_login():\n    repo = LoginRepository()\n    result = yield from repo.get_all_login()\n    data = jsonable_encoder(result)\n    return data\n```", "```py\n@router.get(\"/login/list/records\")\n@asyncio.coroutine\ndef list_login_records():\n    repo = LoginRepository()\n    login_data = yield from repo.get_all_login()\n    result = yield from \n       asyncio.gather(count_login(login_data), \n            build_user_list(login_data))\n    data = jsonable_encoder(result[1])\n    return {'num_rec': result[0], 'user_list': data}\n```", "```py\nasync def count_login(query_list):\n    await asyncio.sleep(2)\n    return len(query_list)\n```", "```py\n@router.post(\"/admin/add\")\nasync def add_admin(req: AdminReq):\n    admin_dict = req.dict(exclude_unset=True)\n    repo = AdminRepository()\n    result = await repo.insert_admin(admin_dict)\n    if result == True: \n        return req \n    else: \n        return JSONResponse(content={'message':'update \n            trainer profile problem encountered'}, \n              status_code=500)\n```", "```py\n@router.get(\"/admin/login/list/enc\")\nasync def generate_encypted_profile():\n    repo = AdminLoginRepository()\n    result = await repo.join_login_admin()\n    encoded_data = await asyncio.gather(\n       *(extract_enc_admin_profile(rec) for rec in result))\n    return encoded_data\n```", "```py\nasync def extract_enc_admin_profile(admin_rec):\n    p = await extract_profile(admin_rec)\n    pinfo = await extract_condensed(p)\n    encp = await decrypt_profile(pinfo)\n    return encp\n```", "```py\nasync def extract_profile(admin_details):\n    profile = {}\n    login = admin_details.parent\n    profile['firstname'] = admin_details.firstname\n    … … … … … …\n    profile['password'] = login.password \n    await asyncio.sleep(1)\n    return profile\nasync def extract_condensed(profiles):\n    profile_info = \" \".join([profiles['firstname'], \n       profiles['lastname'], profiles['username'], \n       profiles['password']])\n    await asyncio.sleep(1)\n    return profile_info \nasync def decrypt_profile(profile_info):\n    key = Fernet.generate_key()\n    fernet = Fernet(key)\n    encoded_profile = fernet.encrypt(profile_info.encode())\n    return encoded_profile\n```", "```py\nasync def process_billing(query_list):\n    billing_list = []\n\n    async def extract_billing(qlist, q: Queue):\n        assigned_billing = {}\n        for record in qlist:\n            await asyncio.sleep(2)\n            assigned_billing['admin_name'] = \"{} {}\"\n              .format(record.firstname, record.lastname)\n            if not len(record.children) == 0:\n                assigned_billing['billing_items'] = \n                      record.children\n            else:\n                assigned_billing['billing_items'] = None\n\n            await q.put(assigned_billing)\n    async def build_billing_sheet(q: Queue):\n        while True: \n            await asyncio.sleep(2)\n            assigned_billing = await q.get()\n            name = assigned_billing['admin_name']\n            billing_items = \n                assigned_billing['billing_items']\n            if not billing_items == None:\n                for item in billing_items:\n                    billing_list.append(\n                    {'admin_name': name, 'billing': item})\n            else: \n                billing_list.append(\n                    {'admin_name': name, 'billing': None})\n            q.task_done()\n```", "```py\n    q = asyncio.Queue()\n    build_sheet = asyncio.create_task(\n               build_billing_sheet(q))\n    await asyncio.gather(asyncio.create_task(\n             extract_billing(query_list, q)))\n\n    await q.join()\n    build_sheet.cancel()\n    return billing_list\n```", "```py\npip install hypercorn\n```", "```py\nhypercorn --keyfile key.pem --certfile cert.pem main:app       --bind 'localhost:8000' --reload\n```", "```py\nasync def generate_billing_sheet(billing_date, query_list):\n    filepath = os.getcwd() + '/data/billing-' + \n                  str(billing_date) +'.csv'\n    with open(filepath, mode=\"a\") as sheet:\n        for vendor in query_list:\n            billing = vendor.children\n            for record in billing:\n                if billing_date == record.date_billed:\n                    entry = \";\".join(\n             [str(record.date_billed), vendor.account_name, \n              vendor.account_number, str(record.payable),\n              str(record.total_issues) ])\n                    sheet.write(entry)\n                await asyncio.sleep(1) \n```", "```py\n@router.post(\"/billing/save/csv\")\nasync def save_vendor_billing(billing_date:date, \n              tasks: BackgroundTasks):\n    repo = BillingVendorRepository()\n    result = await repo.join_vendor_billing()\n    tasks.add_task(generate_billing_sheet, \n            billing_date, result)\n    tasks.add_task(create_total_payables_year, \n            billing_date, result)\n    return {\"message\" : \"done\"}\n```", "```py\npip install celery\n```", "```py\nfrom celery import Celery\nfrom celery.utils.log import get_task_logger \ncelery = Celery(\"services.billing\",   \n   broker='redis://localhost:6379/0', \n   backend='redis://localhost', \n   include=[\"services.billing\", \"models\", \"config\"])\nclass CeleryConfig:\n    task_create_missing_queues = True\n    celery_store_errors_even_if_ignored = True\n    task_store_errors_even_if_ignored = True \n    task_ignore_result = False\n    task_serializer = \"pickle\"\n    result_serializer = \"pickle\"\n    event_serializer = \"json\"\n    accept_content = [\"pickle\", \"application/json\", \n          \"application/x-python-serialize\"]\n    result_accept_content = [\"pickle\", \"application/json\",\n          \"application/x-python-serialize\"]\ncelery.config_from_object(CeleryConfig)\ncelery_log = get_task_logger(__name__)\n```", "```py\n@celery.task(\n    name=\"services.billing.tasks\n            .create_total_payables_year_celery\", \n                auto_retry=[ValueError, TypeError], \n                  max_tries=5)\ndef create_total_payables_year_celery(billing_date,\n              query_list):\n        total = 0.0\n        for vendor in query_list:\n            billing = vendor.children\n            for record in billing:\n                if billing_date == record.date_billed:\n                    total += record.payable      \n        celery_log.info('computed result: ' + str(total))\n        return total   \n```", "```py\n@router.post(\"/billing/total/payable\")\nasync def compute_payables_yearly(billing_date:date):\n    repo = BillingVendorRepository()\n    result = await repo.join_vendor_billing()\n    total_result = create_total_payables_year_celery\n       .apply_async(queue='default', \n            args=(billing_date, result))\n    total_payable = total_result.get(timeout=1)\n    return {\"total_payable\": total_payable }\n```", "```py\ncelery  -A services.billing worker -Q default -P solo -c 2 -l info\n```", "```py\npip install flower\n```", "```py\ncelery -A services.billing flower\n```", "```py\ncelery = Celery(\"services.billing\",   \n    broker='amqp://guest:guest@127.0.0.1:5672', \n    result_backend='redis://localhost:6379/0', \n    include=[\"services.billing\", \"models\", \"config\"])\n```", "```py\npip install kafka-python\n```", "```py\nC:\\..\\kafka\\bin\\windows\\zookeeper-server-start.bat            C:\\..\\kafka\\config\\zookeeper.properties\n```", "```py\nC:\\..\\kafka\\bin\\windows\\kafka-server-start.bat                C:\\..\\kafka\\config\\server.properties\n```", "```py\nC:\\..\\kafka-topics.bat --create --bootstrap-server             localhost:9092 --replication-factor 1 --partitions 3         --topic newstopic\n```", "```py\nfrom kafka import KafkaProducer\nproducer = KafkaProducer(\n     bootstrap_servers='localhost:9092')\ndef json_date_serializer(obj):\n    if isinstance(obj, (datetime, date)):\n        return obj.isoformat()\n    raise TypeError (\"Data %s not serializable\" % \n             type(obj))\n@router.post(\"/messenger/kafka/send\")\nasync def send_messnger_details(req: MessengerReq): \n    messenger_dict = req.dict(exclude_unset=True)\n    producer.send(\"newstopic\", \n       bytes(str(json.dumps(messenger_dict, \n          default=json_date_serializer)), 'utf-8')) \n    return {\"content\": \"messenger details sent\"}\n```", "```py\nkafka-console-consumer.bat --bootstrap-server                                                                                                                                                                                                                 127.0.0.1:9092 --topic newstopic\n```", "```py\nkafka-console-consumer.bat --bootstrap-server 127.0.0.1:9092 --topic newstopic --from-beginning\n```", "```py\nfrom sse_starlette.sse import EventSourceResponse\n@router.get('/messenger/sse/add')\nasync def send_message_stream(request: Request):\n\n    async def event_provider():\n        while True:\n            if await request.is_disconnected():\n                break\n            message = consumer.poll()\n            if not len(message.items()) == 0:\n                for tp, records in message.items():\n                   for rec in records:\n                     messenger_dict = \n                      json.loads(rec.value.decode('utf-8'),\n                       object_hook=date_hook_deserializer )\n\n                     repo = MessengerRepository()\n                     result = await \n                      repo.insert_messenger(messenger_dict)\n                     id = uuid4()\n                     yield {\n                       \"event\": \"Added … status: {},  \n                           Received: {}\". format(result, \n                            datetime.utcfromtimestamp(\n                               rec.timestamp // 1000)\n                               .strftime(\"%B %d, %Y \n                                      [%I:%M:%S %p]\")),\n                       \"id\": str(id),\n                       \"retry\": SSE_RETRY_TIMEOUT,\n                       \"data\": rec.value.decode('utf-8')\n                      }\n\n            await asyncio.sleep(SSE_STREAM_DELAY)\n    return EventSourceResponse(event_provider())\n```", "```py\nimport asyncio\nfrom fastapi import WebSocket\n@router.websocket(\"/customer/list/ws\")\nasync def customer_list_ws(websocket: WebSocket):\n    await websocket.accept()\n    repo = CustomerRepository()\n    result = await repo.get_all_customer()\n\n    for rec in result:\n        data = rec.to_dict()\n        await websocket.send_json(json.dumps(data, \n           default=json_date_serializer))\n        await asyncio.sleep(0.01)\n        client_resp = await websocket.receive_json()\n        print(\"Acknowledging receipt of record id \n           {}.\".format(client_resp['rec_id']))\n    await websocket.close()    \n```", "```py\nimport websockets\n@router.get(\"/customer/wsclient/list/\")  \nasync def customer_list_ws_client():\n    uri = \"ws://localhost:8000/ch08/customer/list/ws\"\n    async with websockets.connect(uri) as websocket:\n        while True:\n           try:\n             res = await websocket.recv()\n             data_json = json.loads(res, \n                object_hook=date_hook_deserializer)\n\n             print(\"Received record: \n                       {}.\".format(data_json))\n\n             data_dict = json.loads(data_json)\n             client_resp = {\"rec_id\": data_dict['id'] }\n             await websocket.send(json.dumps(client_resp))\n\n           except websockets.ConnectionClosed:\n                 break\n        return {\"message\": \"done\"}\n```", "```py\nimport asyncio\nfrom rx.disposable import Disposable\nasync def process_list(observer):\n      repo = SalesRepository()\n      result = await repo.get_all_sales()\n\n      for item in result:\n        record = \" \".join([str(item.publication_id),  \n          str(item.copies_issued), str(item.date_issued), \n          str(item.revenue), str(item.profit), \n          str(item.copies_sold)])\n        cost = item.copies_issued * 5.0\n        projected_profit = cost - item.revenue\n        diff_err = projected_profit - item.profit\n        if (diff_err <= 0):\n            observer.on_next(record)\n        else:\n            observer.on_error(record)\n      observer.on_completed()\n```", "```py\ndef create_observable(loop):\n    def evaluate_profit(observer, scheduler):\n        task = asyncio.ensure_future(\n            process_list(observer), loop=loop)\n        return Disposable(lambda: task.cancel())\n    return rx.create(evaluate_profit)\n```", "```py\n@router.get(\"/sales/list/quota\")\nasync def list_sales_by_quota():\n    loop = asyncio.get_event_loop()\n    observer = create_observable(loop)\n\n    observer.subscribe(\n        on_next=lambda value: print(\"Received Instruction \n              to buy {0}\".format(value)),\n        on_completed=lambda: print(\"Completed trades\"),\n        on_error=lambda e: print(e),\n        scheduler = AsyncIOScheduler(loop) \n    )\n    return {\"message\": \"Notification \n           sent to the background\"}\n```", "```py\nimport asyncio\nimport rx\nimport rx.operators as ops\nasync def compute_subscriptions():\n    total = 0.0\n    repo = SubscriptionCustomerRepository()\n    result = await repo.join_customer_subscription_total()\n\n    for customer in result:\n        subscription = customer.children\n        for item in subscription:\n            total = total + (item.price * item.qty)\n    await asyncio.sleep(1)\n    return total\ndef fetch_records(rate, loop) -> rx.Observable:\n    return rx.interval(rate).pipe(\n        ops.map(lambda i: rx.from_future(\n          loop.create_task(compute_subscriptions()))),\n        ops.merge_all()\n    )\n```", "```py\nasync def fetch_subscription(min_date:date, \n         max_date:date, loop) -> rx.Observable:\n    headers = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\"\n        }\n    async with httpx.AsyncClient(http2=True, \n             verify=False) as client:\n        content = await \n          client.get('https://localhost:8000/ch08/\n            subscription/list/all', headers=headers)\n    y = json.loads(content.text)\n    source = rx.from_(y)\n    observable = source.pipe(\n      ops.filter(lambda c: filter_within_dates(\n               c, min_date, max_date)),\n      ops.map(lambda a: rx.from_future(loop.create_task(\n            convert_str(a)))),\n      ops.merge_all(),\n    )\n    return observable\n```", "```py\ndef filter_within_dates(rec, min_date:date, max_date:date):\n    date_pur = datetime.strptime(\n             rec['date_purchased'], '%Y-%m-%d')\n    if date_pur.date() >= min_date and \n             date_pur.date() <= max_date:\n        return True\n    else:\n        return False\n```", "```py\nasync def convert_str(rec):\n    if not rec == None:\n        total = rec['qty'] * rec['price']\n        record = \" \".join([rec['branch'], \n            str(total), rec['date_purchased']])\n        await asyncio.sleep(1)\n        return record\n```", "```py\n@router.post(\"/subscription/dated\")\nasync def list_dated_subscription(min_date:date, \n            max_date:date):\n\n    loop = asyncio.get_event_loop()\n    observable = await fetch_subscription(min_date, \n             max_date, loop)\n\n    observable.subscribe(\n       on_next=lambda item: \n         print(\"Subscription details: {}.\".format(item)),\n       scheduler=AsyncIOScheduler(loop)\n    )\n```", "```py\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def initialize():\n    engine = await db.set_bind(\"postgresql+asyncpg://\n          postgres:admin2255@localhost:5433/nsms\")\n```", "```py\n@app.on_event(\"shutdown\")\nasync def destroy():\n    engine, db.bind = db.bind, None\n    await engine.close()\n```"]