- en: Chapter 2. Database Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using model mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin with URL-related methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle creation and modification dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to take care of meta tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle generic relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multilingual fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching from South migrations to Django migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a foreign key to the many-to-many field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start a new app, the first thing to do is create the models that represent
    your database structure. We are assuming that you have previously created Django
    apps or at least, you have read and understood the official Django tutorial. In
    this chapter, we will see a few interesting techniques that make your database
    structure consistent throughout different apps in your project. Then, we will
    see how to create custom model fields in order to handle internationalization
    of your data in the database. At the end of the chapter, we will see how to use
    migrations to change your database structure in the process of development.
  prefs: []
  type: TYPE_NORMAL
- en: Using model mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented languages, such as Python, a mixin class can be viewed as
    an interface with implemented features. When a model extends a mixin, it implements
    the interface and includes all its fields, properties, and methods. Mixins in
    Django models can be used when you want to reuse the generic functionalities in
    different models multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you will need to create reusable mixins. Some typical examples of mixins
    are given later in this chapter. A good place to keep your model mixins is in
    the `utils` module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you create a reusable app that you will share with others, keep the model
    mixins in the reusable app, for example, in the `base.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of any Django app, where you want to use the mixins
    and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django model inheritance supports three types of inheritance: abstract base
    classes, multi-table inheritance, and proxy models. Model mixins are abstract
    model classes with specified fields, properties, and methods. When you create
    a model such as `Idea`, as shown in the preceding example, it inherits all the
    features from `UrlMixin`, `CreationModificationMixin`, and `MetaTagsMixin`. All
    the fields of the abstract classes are saved in the same database table as the
    fields of the extending model. In the following recipes, you will learn how to
    define your model mixins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using the `@python_2_unicode_compatible` decorator for our
    `Idea` model. As you might remember from the *Making your code compatible with
    both Python 2.7 and Python 3* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Django 1.8"), *Getting Started with Django 1.8*, it''s purpose is
    to make the `__str__()` method compatible with Unicode for both the following
    Python versions: 2.7 and 3.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about the different types of model inheritance, refer to the official
    Django documentation available at [https://docs.djangoproject.com/en/1.8/topics/db/models/#model-inheritance](https://docs.djangoproject.com/en/1.8/topics/db/models/#model-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making your code compatible with both Python 2.7 and Python 3* recipe in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with Django 1.8"), *Getting
    Started with Django 1.8*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods recipe*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin with URL-related methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For every model that has its own page, it is good practice to define the `get_absolute_url()`
    method. This method can be used in templates and also in the Django admin site
    to preview the saved object. However, `get_absolute_url()` is ambiguous as it
    returns the URL path instead of the full URL. In this recipe, we will see how
    to create a model mixin that allows you to define either the URL path or the full
    URL by default, generate the other out of the box, and take care of the `get_absolute_url()`
    method that is being set.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't done it yet, create the `utils` package to save your mixins.
    Then, create the `models.py` file in the `utils` package (alternatively, if you
    create a reusable app, put the mixins in the `base.py` file in your app).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `models.py` file of your `utils` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the mixin in your app, import it from the `utils` package, inherit the
    mixin in your model class, and define the `get_url_path()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you check this code in the staging or production environment or run a local
    server with a different IP or port than the defaults, set `DEFAULT_WEBSITE_URL`
    in your local settings (without the trailing slash), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UrlMixin` class is an abstract model that has three methods: `get_url()`,
    `get_url_path()`, and `get_absolute_url()`. The `get_url()` or `get_url_path()`
    methods are expected to be overwritten in the extended model class, for example,
    `Idea`. You can define `get_url()`, which is the full URL of the object, and then
    `get_url_path()` will strip it to the path. You can also define `get_url_path()`,
    which is the absolute path of the object, and then `get_url()` will prepend the
    website URL to the beginning of the path. The `get_absolute_url()` method will
    mimic the `get_url_path()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rule of thumb is to always overwrite the `get_url_path()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the templates, use `<a href="{{ idea.get_url_path }}">{{ idea.title }}</a>`
    when you need a link of an object in the same website. Use `<a href="{{ idea.get_url
    }}">{{ idea.title }}</a>` for the links in e-mails, RSS feeds, or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The default `get_absolute_url()` method will be used in the Django model administration
    for the *View on site* functionality and might also be used by some third-party
    Django apps.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle creation and modification dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common behavior to have timestamps in your models for the creation and
    modification of your model instances. In this recipe, we will see how to create
    a simple model mixin that saves the creation and modification dates and times
    for your model. Using such a mixin will ensure that all the models use the same
    field names for the timestamps and have the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't done this yet, create the `utils` package to save your mixins.
    Then, create the `models.py` file in the `utils` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of your `utils` package and insert the following
    content there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CreationModificationDateMixin` class is an abstract model, which means
    that extending model classes will create all the fields in the same database table,
    that is, there will be no one-to-one relationships that make the table difficult
    to handle. This mixin has two date-time fields and the `save()` method that will
    be called when saving the extended model. The `save()` method checks whether the
    model has no primary key, which is the case of a new not-yet-saved instance. In
    this case, it sets the creation date to the current date and time. If the primary
    key exists, the modification date is set to the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, instead of the `save()` method, you can use the `auto_now_add`
    and `auto_now` attributes for the created and modified fields, which will add
    creation and modification timestamps automatically.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to take care of meta tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to optimize your site for search engines, you need to not only set
    the semantic markup for each page but also the appropriate meta tags. For maximum
    flexibility, you need to have a way to define specific meta tags for each object,
    which has its own page on your website. In this recipe, we will see how to create
    a model mixin for the fields and methods related to the meta tags.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous recipes, make sure that you have the `utils` package
    for your mixins. Open the `models.py` file from this package in your favorite
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Put the following content in the `models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This mixin adds four fields to the model that extends from it: `meta_keywords`,
    `meta_description`, `meta_author`, and `meta_copyright`. The methods to render
    the meta tags in HTML are also added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use this mixin in a model such as `Idea`, which is shown in the first
    recipe of this chapter, then you can put the following in the `HEAD` section of
    your detail page template to render all the meta tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also render a specific meta tag using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed from the code snippet, the rendered meta tags are marked
    as safe, that is, they are not escaped and we don't need to use the safe template
    filter. Only the values that come from the database are escaped in order to guarantee
    that the final HTML is well-formed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using model mixins* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model mixin to handle generic relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides normal database relationships such as a foreign-key relationship or
    many-to-many relationship, Django has a mechanism to relate a model to an instance
    of any other model. This concept is called generic relations. For each generic
    relation, there is a content type of the related model that is saved as well as
    the ID of the instance of this model.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to generalize the creation of generic relations
    in the model mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe to work, you need to have the `contenttypes` app installed.
    It should be in the `INSTALLED_APPS` directory by default, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, make sure that you have the `utils` package for your model mixins already
    created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `models.py` file in the `utils` package in a text editor and insert
    the following content there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is an example of how to use two generic relationships in your
    app (put this code in `demo_app/models.py`), as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, this snippet is more complex than the previous ones. The `object_relation_mixin_factory`
    object is not a mixin itself; it is a function that generates a model mixin, that
    is, an abstract model class to extend from. The dynamically created mixin adds
    the `content_type` and `object_id` fields and the `content_object` generic foreign
    key that points to the related instance.
  prefs: []
  type: TYPE_NORMAL
- en: Why couldn't we just define a simple model mixin with these three attributes?
    A dynamically generated abstract class allows us to have prefixes for each field
    name; therefore, we can have more than one generic relation in the same model.
    For example, the `Like` model, which was shown previously, will have the `content_type`,
    `object_id`, and `content_object` fields for the favorite object and `owner_content_type`,
    `owner_object_id`, and `owner_content_object` for the one (user or institution)
    who liked the object.
  prefs: []
  type: TYPE_NORMAL
- en: The `object_relation_mixin_factory()` function adds a possibility to limit the
    content type choices by the `limit_content_type_choices_to` parameter. The preceding
    example limits the choices for `owner_content_type` only to the content types
    of the `User` and `Institution` models. Also, there is the `limit_object_choices_to`
    parameter that can be used by custom form validation to limit the generic relations
    only to specific objects, for example, the objects with published status.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to take care of meta tags* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multilingual fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses the internationalization mechanism to translate verbose strings
    in the code and templates. However, it's up to the developer to decide how to
    implement the multilingual content in the models. There are several third-party
    modules that handle translatable model fields; however, I prefer the simple solution
    that will be introduced to you in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of the approach that you will learn about are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is straightforward to define multilingual fields in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simple to use the multilingual fields in database queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use contributed administration to edit models with the multilingual
    fields without additional modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need it, you can easily show all the translations of an object in the
    same template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use database migrations to add or remove languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you have the `utils` package created? You will now need a new `fields.py`
    file for the custom model fields there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to define the multilingual character field and
    multilingual text field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `fields.py` file and create the multilingual character field as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add an analogous multilingual text field. The differing parts
    are highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll consider an example of how to use the multilingual fields in your
    app, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set multiple languages in your settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the multilingual fields for your model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example of `Idea` will create a model that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, there will be two properties: `title` and `description`
    that will return the title and description in the currently active language.'
  prefs: []
  type: TYPE_NORMAL
- en: The `MultilingualCharField` and `MultilingualTextField` fields will juggle the
    model fields dynamically, depending on your `LANGUAGES` setting. They will overwrite
    the `contribute_to_class()` method that is used when the Django framework creates
    the model classes. The multilingual fields dynamically add character or text fields
    for each language of the project. Also, the properties are created in order to
    return the translated value of the currently active language or the main language
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can have the following in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will show the text in English, German, French, or Lithuanian, depending
    on the currently selected language. However, it will fall back to English if the
    translation doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. If you want to have your `QuerySet` ordered by the
    translated titles in the view, you can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not true that once you have created your database structure, it won't
    change in the future. As development happens iteratively, you can get updates
    on the business requirements in the development process and you will need to perform
    database schema changes along the way. With the Django migrations, you don't need
    to change the database tables and fields manually, as most of it is done automatically
    using the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activate your virtual environment in the command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the database migrations, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create models in your new `demo_app` app, you need to create an initial
    migration that will create the database tables for your app. This can be done
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first time that you want to create all the tables for your project, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It executes the usual database synchronization for all apps that have no database
    migrations, and in addition to this, it migrates all apps that have the migrations
    set. Also, run this command when you want to execute the new migrations for all
    your apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you want to execute the migrations for a specific app, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you make some changes in the database schema, you have to create a migration
    for that schema. For example, if we add a new subtitle field to the `Idea` model,
    we can create the migration using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a data migration that modifies the data in the database table, we
    can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a skeleton data migration, which you need to modify and add data
    manipulation to it before applying.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To list all the available applied and unapplied migrations, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The applied migrations will be listed with a `[X]` prefix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To list all the available migrations for a specific app, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django migrations are instruction files for the database migration mechanism.
    The instruction files inform us which database tables to create or remove; which
    fields to add or remove; and which data to insert, update, or delete.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of migrations in Django. One is schema migration and the
    other is data migration. Schema migration should be created when you add new models,
    or add or remove fields. Data migration should be used when you want to fill the
    database with some values or massively delete values from the database. Data migrations
    should be created using a command in the command-line tool and then programmed
    in the migration file. Migrations for each app are saved in their `migrations`
    directories. The first migration will be usually called `0001_initial.py`, and
    the other migrations in our example app will be called `0002_subtitle_added.py`
    and `0003_populate_subtitle.py`. Each migration gets a number prefix that is automatically
    incremented. For each migration that is executed, there is an entry that is saved
    in the `django_migrations` database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to migrate back and forth by specifying the number of the migration
    to which we want to migrate to, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to undo all the migrations for a specific app, you can do so using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not commit your migrations to version control until you have tested the forward
    and backward migration process and you are sure that they will work well in other
    development and public website environments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling project dependencies with pip and Including external dependencies
    in your project* recipes in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Django 1.8"), *Getting Started with Django 1.8*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Changing a foreign key to the many-to-many field* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching from South migrations to Django migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you, like me, have been using Django since before database migrations existed
    in the core functionality, that is, before Django 1.7; you have, more than likely,
    used third-party South migrations before. In this recipe, you will learn how to
    switch your project from South migrations to Django migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that all apps and their South migrations are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrate all your apps to the latest South migrations, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove `south` from `INSTALLED_APPS` in the settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each app with South migrations, delete the migration files and only leave
    the `migrations` directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create new migration files with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fake the initial Django migrations as the database schema has already been
    set correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have any circular foreign keys in the apps (that is, two models in different
    apps pointing to each other with a foreign key or many-to-many relation), separately
    apply the fake initial migrations to these apps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no conflict in the database when switching to the new way of dealing
    with the database schema changes as the South migration history is saved in the
    `south_migrationhistory` database table; whereas, the Django migration history
    is saved in the `django_migrations` database table. The only problem are the migration
    files that have different syntax and, therefore, the South migrations need to
    be completely replaced with the Django migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, at first, we delete the South migration files. Then, the `makemigrations`
    command recognizes the empty `migrations` directories and creates new initial
    Django migrations for each app. Once these migrations are faked, the further Django
    migrations can be created and applied.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using migrations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Changing a foreign key to the many-to-many field* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a foreign key to the many-to-many field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a practical example of how to change a many-to-one relation to
    many-to-many relation, while preserving the already existing data. We will use
    both schema and data migrations for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider that you have the `Idea` model with a foreign key pointing
    to the `Category` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial migration should be created and executed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will teach you how to switch from a foreign key relation
    to many-to-many relation, while preserving the already existing data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new many-to-many field called `categories`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and run a schema migration in order to add the new field to the database,
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a data migration to copy categories from the foreign key to the many-to-many
    field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the newly created migration file (`demo_app/migrations/0003_copy_categories.py`)
    and define the forward migration instructions, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following data migration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the foreign key field `category` in the `models.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and run a schema migration in order to delete the categories field from
    the database table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first, we add a new many-to-many field to the `Idea` model. Then, we copy
    the existing relations from a foreign key relation to the many-to-many relation.
    Lastly, we remove the foreign key relation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using migrations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Switching from South migrations to Django migrations* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
