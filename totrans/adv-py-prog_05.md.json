["```py\n$pip install cython\n```", "```py\n        def hello(): \n          print('Hello, World!') \n    ```", "```py\n    $ cython hello.pyx\n    ```", "```py\n    $ gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-\n    strict-aliasing -lm -I/usr/include/python3.5/ -o \n    hello.so hello.c\n    ```", "```py\n        >>> import hello \n        >>> hello.hello() \n        Hello, World!\n    ```", "```py\n    $ cython -3 hello.pyx\n    ```", "```py\n    $ gcc -I/usr/include/python3.5 # ... other options\n    $ gcc -I/usr/include/python2.7 # ... other options\n    ```", "```py\n        from distutils.core import setup \n        from Cython.Build import cythonize \n        setup( \n          name='Hello',\n          ext_modules = cythonize('hello.pyx')\n        ) \n    ```", "```py\n        cythonize(['hello.pyx', 'world.pyx', '*.pyx']) \n    ```", "```py\n    $ python setup.py build_ext --inplace\n    ```", "```py\n        >>> import pyximport \n        >>> pyximport.install() \n        >>> import hello # This will compile hello.pyx \n    ```", "```py\n        %load_ext Cython\n    ```", "```py\n    %%cython \n    def hello_snippet(): \n        print(\"Hello, Cython!\") \n    hello_snippet()\n    Hello,  Cython! \n```", "```py\n    cdef int i \n```", "```py\n    cdef double a, b = 2.0, c = 3.0 \n```", "```py\n    a = 'hello' \n```", "```py\n    a = 1 \n```", "```py\n    %%cython \n    cdef int i \n    i = 3.0 \n    # Output has been cut \n    ...cf4b.pyx:2:4 Cannot assign type 'double' to 'int' \n```", "```py\n    %%cython \n    def example(): \n       cdef int i, j=0 \n       for i in range(100):\n           j += 1 \n       return j \n    example() \n    # Result:\n    # 100 \n```", "```py\n    def example_python(): \n        j=0 \n        for i in range(100):\n            j += 1 \n        return j \n    %timeit example() \n    10000000 loops, best of 3: 25 ns per loop \n    %timeit example_python() \n    100000 loops, best of 3: 2.74 us per loop \n```", "```py\n    cdef object a_py \n    # both 'hello' and 1 are Python objects \n    a_py = 'hello' \n    a_py = 1 \n```", "```py\n    cdef int a = 0 \n    cdef double b \n    b = <double> a \n```", "```py\n    def max_python(int a, int b):\n        return a if a > b else b \n```", "```py\n    cdef int max_cython(int a, int b): \n        return a if a > b else b \n```", "```py\n    cpdef int max_hybrid(int a, int b): \n        return a if a > b else b \n```", "```py\n    cdef inline int max_inline(int a, int b): \n        return a if a > b else b \n```", "```py\n    cdef class Point:\n        cdef double x \n        cdef double y\n        def __init__(self, double x, double y): \n            self.x = x \n            self.y = y \n```", "```py\n    cdef double norm(Point p): \n        return (p.x**2 + p.y**2)**0.5 \n```", "```py\n    >>> a = Point(0.0, 0.0) \n    >>> a.x \n    AttributeError: 'Point' object has no attribute 'x' \n```", "```py\n    cdef class Point: \n        cdef public double x \n```", "```py\n    cdef int max(int a, int b) \n    cdef int min(int a, int b) \n```", "```py\n    cdef int max(int a, int b): \n      return a if a > b else b \n    cdef int min(int a, int b): \n      return a if a < b else b \n```", "```py\n    max(abs(x1 - x2), abs(y1 - y2)) \n```", "```py\n    from mathlib cimport max \n    def chebyshev(int x1, int y1, int x2, int y2): \n        return max(abs(x1 - x2), abs(y1 - y2)) \n```", "```py\n    %%cython \n    cdef double a \n    from libc.stdio cimport printf \n    printf(\"%p\", &a)\n    # Output:\n    # 0x7fc8bb611210 \n```", "```py\n    from libc.stdio cimport printf \n    cdef double a \n    cdef double *a_pointer \n    a_pointer = &a # a_pointer and &a are of the same type \n```", "```py\n    cdef double a \n    cdef double *a_pointer \n    a_pointer = &a \n    a = 3.0 \n    print(a_pointer[0]) # prints 3.0 \n```", "```py\n    cdef double arr[10]\n```", "```py\n    cdef double arr[5][2] \n```", "```py\n    arr[0] = 1.0 \n```", "```py\n%%cython \nfrom libc.stdio cimport printf \ncdef double arr[10] \nprintf(\"%p\\n\", arr) \nprintf(\"%p\\n\", &arr[0])\n# Output\n# 0x7ff6de204220 \n# 0x7ff6de204220\n```", "```py\n    cimport numpy as c_np\n    import numpy as np\n```", "```py\n    cdef c_np.ndarray[double, ndim=2] arr \n```", "```py\n    %%cython \n    import numpy as np \n    def numpy_bench_py(): \n        py_arr = np.random.rand(1000) \n        cdef int i \n        for i in range(1000): \n            py_arr[i] += 1 \n```", "```py\n    %%cython \n    import numpy as np \n    cimport numpy as c_np \n    def numpy_bench_c(): \n        cdef c_np.ndarray[double, ndim=1] c_arr \n        c_arr = np.random.rand(1000) \n        cdef int i\n        for i in range(1000): \n           c_arr[i] += 1 \n```", "```py\n    %timeit numpy_bench_c() \n    100000 loops, best of 3: 11.5 us per loop \n    %timeit numpy_bench_py() \n    1000 loops, best of 3: 603 us per loop \n```", "```py\n    cdef int[:] a \n    cdef double[:, :] b \n```", "```py\n    import numpy as np \n    cdef int[:] arr \n    arr_np = np.zeros(10, dtype='int32') \n    arr = arr_np # We bind the array to the memoryview \n```", "```py\n    arr[2] = 1 # Changing memoryview \n    print(arr_np) \n    # [0 0 1 0 0 0 0 0 0 0] \n```", "```py\n    cdef int[:, :, :] a \n    arr[0, :, :] # Is a 2-dimensional memoryview \n    arr[0, 0, :] # Is a 1-dimensional memoryview \n    arr[0, 0, 0] # Is an int \n```", "```py\n    import numpy as np \n    cdef double[:, :] b \n    cdef double[:] r \n    b = np.random.rand(10, 3) \n    r = np.zeros(3, dtype='float64') \n    b[0, :] = r # Copy the value of r in the first row of b \n```", "```py\n    def evolve_numpy(self, dt): \n        timestep = 0.00001 \n        nsteps = int(dt/timestep) \n        r_i = np.array([[p.x, p.y] for p in \\\n            self.particles])     \n        ang_speed_i = np.array([p.ang_speed for p in \\\n          self.particles]) \n        v_i = np.empty_like(r_i) \n        for i in range(nsteps): \n            norm_i = np.sqrt((r_i ** 2).sum(axis=1)) \n            v_i = r_i[:, [1, 0]] \n            v_i[:, 0] *= -1 \n            v_i /= norm_i[:, np.newaxis]         \n            d_i = timestep * ang_speed_i[:, np.newaxis] * \\\n                v_i \n            r_i += d_i \n        for i, p in enumerate(self.particles): \n            p.x, p.y = r_i[i] \n```", "```py\n    # file: simul.py \n    def evolve_cython(self, dt): \n        timestep = 0.00001 \n        nsteps = int(dt/timestep) \n\n        r_i = np.array([[p.x, p.y] for p in \\\n            self.particles])     \n        ang_speed_i = np.array([p.ang_speed for p in \\\n            self.particles]) \n\n        c_evolve(r_i, ang_speed_i, timestep, nsteps) \n\n        for i, p in enumerate(self.particles): \n            p.x, p.y = r_i[i] \n\n    # file: cevolve.pyx \n    import numpy as np \n\n    def c_evolve(r_i, ang_speed_i, timestep, nsteps): \n        v_i = np.empty_like(r_i) \n\n        for i in range(nsteps): \n            norm_i = np.sqrt((r_i ** 2).sum(axis=1)) \n\n            v_i = r_i[:, [1, 0]] \n            v_i[:, 0] *= -1 \n            v_i /= norm_i[:, np.newaxis]         \n\n            d_i = timestep * ang_speed_i[:, np.newaxis] * \n                v_i \n\n            r_i += d_i \n```", "```py\n    def benchmark(npart=100, method='python'): \n        particles = [\n                     Particle(uniform(-1.0, 1.0),\n                              uniform(-1.0, 1.0),\n                              uniform(-1.0, 1.0)) \n                              for i in range(npart)\n            ] \n        simulator = ParticleSimulator(particles) \n        if method=='python': \n            simulator.evolve_python(0.1)\n        elif method == 'cython': \n            simulator.evolve_cython(0.1) \n        elif method == 'numpy': \n            simulator.evolve_numpy(0.1) \n```", "```py\n    %timeit benchmark(100, 'cython') \n    1 loops, best of 3: 401 ms per loop \n    %timeit benchmark(100, 'numpy') \n    1 loops, best of 3: 413 ms per loop \n```", "```py\n    def c_evolve(double[:, :] r_i,\n                 double[:] ang_speed_i,\n                 double timestep,\n                 int nsteps): \n```", "```py\n    cdef int i, j \n    cdef int nparticles = r_i.shape[0] \n```", "```py\n      for i in range(nsteps): \n          for j in range(nparticles): \n              x = r_i[j, 0] \n              y = r_i[j, 1] \n              ang_speed = ang_speed_i[j] \n\n              norm = sqrt(x ** 2 + y ** 2) \n\n              vx = (-y)/norm \n              vy = x/norm \n\n              dx = timestep * ang_speed * vx \n              dy = timestep * ang_speed * vy \n\n              r_i[j, 0] += dx \n              r_i[j, 1] += dy \n```", "```py\n    cdef double norm, x, y, vx, vy, dx, dy, ang_speed \n```", "```py\n    from libc.math cimport sqrt \n```", "```py\n    In [4]: %timeit benchmark(100, 'cython') \n    100 loops, best of 3: 13.4 ms per loop \n    In [5]: %timeit benchmark(100, 'numpy') \n    1 loops, best of 3: 429 ms per loop \n```", "```py\n    In [2]: %timeit benchmark(1000, 'cython') \n    10 loops, best of 3: 134 ms per loop \n    In [3]: %timeit benchmark(1000, 'numpy') \n    1 loops, best of 3: 877 ms per loop\n```", "```py\n$ cython -a cevolve.pyx\n$ firefox cevolve.html\n```", "```py\n    cimport cython \n    @cython.boundscheck(False) \n    def myfunction(): \n        # Code here \n```", "```py\n    with cython.boundscheck(False): \n        # Code here \n```", "```py\n    # cython: boundscheck=False \n```", "```py\n$ cython -X boundscheck=True\n```", "```py\n    cimport cython \n    @cython.boundscheck(False) \n    @cython.cdivision(True) \n    def c_evolve(double[:, :] r_i,double[:] ang_speed_i, \\\n                 double timestep,int nsteps): \n```", "```py\n    In [3]: %timeit benchmark(100, 'cython') \n    100 loops, best of 3: 13.4 ms per loop \n```", "```py\n    import numpy as np \n    from distance import chebyshev \n    def benchmark(): \n        a = np.random.rand(100, 2) \n        b = np.random.rand(100, 2) \n        for x1, y1 in a: \n            for x2, y2 in b: \n                chebyshev(x1, x2, y1, y2) \n```", "```py\n    # cython: profile=True \n    cdef int max(int a, int b): \n        # Code here \n```", "```py\n    import cheb \n    %prun cheb.benchmark() \n# Output:\n2000005 function calls in 2.066 seconds \n  Ordered by: internal time \n  ncalls tottime percall cumtime percall \n  filename:lineno(function) \n       1   1.664   1.664   2.066   2.066 \n cheb.py:4(benchmark) \n 1000000   0.351   0.000   0.401   0.000\n {distance.chebyshev} \n 1000000   0.050   0.000   0.050   0.000 mathlib.pyx:2(max) \n       2   0.000   0.000   0.000   0.000 {method 'rand' of \n'mtrand.RandomState' objects} \n       1   0.000   0.000   2.066   2.066 \n <string>:1(<module>) \n       1   0.000   0.000   0.000   0.000 {method 'disable' \n of        '_lsprof.Profiler' objects} \n```", "```py\n    %%cython\n    import numpy as np\n    cdef int max(int a, int b):\n        return a if a > b else b\n    cdef int chebyshev(int x1, int y1, int x2, int y2):\n        return max(abs(x1 - x2), abs(y1 - y2))\n    def c_benchmark():\n        a = np.random.rand(1000, 2)\n        b = np.random.rand(1000, 2)\n        for x1, y1 in a:\n           for x2, y2 in b:\n               chebyshev(x1, x2, y1, y2)\n```", "```py\n    %%cython -a -f -c=-DCYTHON_TRACE=1\n    # cython: linetrace=True\n    # cython: binding=True\n    import numpy as np\n    cdef int max(int a, int b):\n        return a if a > b else b\n    def chebyshev(int x1, int y1, int x2, int y2):\n        return max(abs(x1 - x2), abs(y1 - y2))\n    def c_benchmark():\n        a = np.random.rand(1000, 2)\n        b = np.random.rand(1000, 2)\n\n        for x1, y1 in a:\n            for x2, y2 in b:\n                chebyshev(x1, x2, y1, y2)\n```", "```py\n%load_ext line_profiler\n%lprun -f c_benchmark c_benchmark()\n# Output:\nTimer unit: 1e-06 s\nTotal time: 2.322 s\nFile: /home/gabriele/.cache/ipython/cython/_cython_\nmagic_18ad8204e9d29650f3b09feb48ab0f44.pyx\nFunction: c_benchmark at line 11\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    11                                           def \nc_benchmark():\n    12         1          226    226.0      0.0      a = \nnp.random.rand...\n    13         1           67     67.0      0.0      b = \nnp.random.rand...    \n    14                                               \n    15      1001         1715      1.7      0.1      for \nx1, y1 in a:\n    16   1001000      1299792      1.3     56.0          \nfor x2, y2 in b:\n    17   1000000      1020203      1.0     43.9              \nchebyshev...\n```"]