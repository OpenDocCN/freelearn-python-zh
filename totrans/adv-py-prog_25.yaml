- en: '*Chapter 22*: The Façade Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第22章*：外观模式'
- en: 'In the previous chapter, we covered a third structural pattern, the bridge
    pattern, which helps to define an abstraction and its implementation in a decoupled
    way, so that both can vary independently. Now, we will learn about another structural
    pattern, the **façade** pattern, which achieves an important goal in many software
    use cases: hiding the inner workings of an application and only giving access
    to what is necessary.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一个第三种结构模式，即桥接模式，它有助于以解耦的方式定义抽象及其实现，以便两者可以独立变化。现在，我们将学习另一种结构模式，即**外观**模式，它在许多软件用例中实现了一个重要的目标：隐藏应用程序的内部工作原理，并且只提供必要的访问权限。
- en: 'In the chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the façade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解外观模式
- en: Real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实案例
- en: Use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: Throughout this chapter, we will see why façade is a good pattern to employ
    and what its benefits are, and as always, implement a hands-on example in Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到为什么外观是一个好的模式来使用，以及它的好处是什么，并且像往常一样，我们将通过Python的实际示例来实现。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过此链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22)。
- en: Understanding the façade pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解外观模式
- en: As systems evolve, they can get very complex. It is not unusual to end up with
    a very large (and sometimes confusing) collection of classes and interactions.
    In many cases, we don't want to expose this complexity to the client. This is
    where façade comes to our rescue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的演变，它们可以变得非常复杂。最终得到一个非常大的（有时是令人困惑的）类和交互集合并不罕见。在许多情况下，我们不想将这种复杂性暴露给客户端。这就是外观模式拯救我们的地方。
- en: The façade design pattern helps us to hide the internal complexity of our systems
    and expose only what is necessary to the client through a simplified interface.
    In essence, a façade is an abstraction layer implemented over an existing complex
    system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式帮助我们隐藏系统的内部复杂性，并通过简化的接口仅向客户端暴露必要的内容。本质上，外观是一个在现有复杂系统上实现的抽象层。
- en: Let's take the example of a computer to illustrate things. A computer is a complex
    machine that depends on several parts to be fully functional. To keep things simple,
    the word *computer*, in this case, refers to an IBM derivative that uses a von
    Neumann architecture. Booting a computer is a particularly complex procedure.
    The CPU, main memory, and hard disk need to be up and running, the boot loader
    must be loaded from the hard disk to the main memory, the CPU must boot the **operating
    system** (**OS**) kernel, and so forth. Instead of exposing all this complexity
    to the client, we create a façade that encapsulates the whole procedure, making
    sure that all steps are executed in the right order.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以计算机为例来阐述这一点。计算机是一个复杂的机器，它依赖于几个部分才能完全运行。为了简化问题，这里的“计算机”一词指的是使用冯·诺伊曼架构的IBM衍生产品。启动计算机是一个特别复杂的程序。CPU、主内存和硬盘需要运行，引导加载程序必须从硬盘加载到主内存，CPU必须引导**操作系统**（**OS**）内核，等等。我们不需要将所有这些复杂性暴露给客户端，因此我们创建了一个外观，它封装了整个程序，确保所有步骤都按正确的顺序执行。
- en: In terms of object design and programming, we should have several classes, but
    only the `Computer` class needs to be exposed to the client code. The client will
    only have to execute the `start()` method of the `Computer` class, for example,
    and all the other complex parts are taken care of by the façade `Computer` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象设计和编程方面，我们应该有几个类，但只有`Computer`类需要暴露给客户端代码。客户端只需执行`Computer`类的`start()`方法，例如，其他所有复杂的部分都由外观`Computer`类处理。
- en: Let's discuss more real-life examples of the façade pattern in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论更多外观模式的真实案例。
- en: Real-world examples
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实案例
- en: The façade pattern is quite common in life. When you call a bank or a company,
    you are usually first connected to the customer service department. The customer
    service employee acts as a façade between you and the actual department (billing,
    technical support, general assistance, and so on), and the employee that will
    help you with your specific problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式在现实生活中非常常见。当你拨打银行或公司的电话时，你通常首先会被连接到客户服务部门。客户服务员工充当你与实际部门（账单、技术支持、一般协助等）之间的外观，以及将帮助你解决具体问题的员工。
- en: Another example is the key used to turn on a car or motorcycle, which can also
    be considered a façade. It is a simple way of activating a system that is very
    complex internally. And, of course, the same is true for other complex electronic
    devices that we can activate with a single button, such as computers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是用于打开汽车或摩托车的钥匙，这也可以被视为外观。这是一种简单的方法来激活内部非常复杂的系统。当然，对于我们可以用单个按钮激活的其他复杂电子设备，也是如此，例如计算机。
- en: In software, the `django-oscar-datacash` module is a Django third-party module
    that integrates with the **DataCash** payment gateway. The module has a gateway
    class that provides fine-grained access to the various DataCash APIs. On top of
    that, it also offers a façade class that provides a less granular API (for those
    who don't want to mess with the details), and the ability to save transactions
    for auditing purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，`django-oscar-datacash`模块是一个与**DataCash**支付网关集成的Django第三方模块。该模块有一个网关类，它提供了对各种DataCash
    API的细粒度访问。在此基础上，它还提供了一个外观类，提供了一个不那么细粒度的API（对于那些不想处理细节的人来说），以及保存交易以供审计的能力。
- en: In the next section, we will see why the façade pattern is important in software.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到外观模式在软件中的重要性。
- en: Use cases
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: The most common reason to use the façade pattern is to provide a single, simple
    entry point to a complex system. By introducing a façade, the client code can
    use a system by simply calling a single method/function. At the same time, the
    internal system does not lose any functionality; it just encapsulates it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观模式最常见的原因是提供一个单一、简单的入口点来访问复杂的系统。通过引入外观，客户端代码可以通过调用单个方法/函数来使用系统。同时，内部系统不会失去任何功能；它只是封装了它。
- en: 'Not exposing the internal functionality of a system to the client code gives
    us an extra benefit: we can introduce changes to the system, but the client code
    remains unaware of and unaffected by the changes. No modifications are required
    to the client code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不向客户端代码暴露系统的内部功能给我们带来了额外的优势：我们可以对系统进行更改，但客户端代码对此一无所知，也不会受到影响。无需对客户端代码进行任何修改。
- en: The façade is also useful if you have more than one layer in your system. You
    can introduce one façade entry point per layer, and let all layers communicate
    with each other through their façades. This, in turn, promotes **loose coupling**
    and keeps the layers as independent as possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统中有多层，外观也非常有用。你可以为每一层引入一个外观入口点，并让所有层通过它们的外观相互通信。这反过来又促进了**松耦合**，并尽可能保持层之间的独立性。
- en: With that, we are now ready to try our hand at an actual implementation example
    in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经准备好在下一节尝试一个实际的实现示例。
- en: Implementation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Assume that we want to create an OS using a multiserver approach, similar to
    how it is done in **MINIX 3** ([j.mp/minix3](http://j.mp/minix3)) or **GNU Hurd**
    ([j.mp/gnuhurd](http://j.mp/gnuhurd)). A multiserver OS has a minimal kernel,
    called the **microkernel**, which runs in privileged mode. All the other services
    of the system are following a server architecture (driver server, process server,
    file server, and so forth). Each server belongs to a different memory address
    space and runs on top of the microkernel in user mode. The pros of this approach
    are that the OS can become more fault-tolerant, reliable, and secure. For example,
    since all drivers are running in user mode on a driver server, a bug in a driver
    cannot crash the whole system, nor can it affect the other servers. The cons of
    this approach are the performance overhead and the complexity of system programming.
    These are a result of the communication happening between a server and the microkernel,
    as well as between the independent servers, using message passing. Message passing
    is more complex than the shared memory model used in monolithic kernels, such
    as Linux ([j.mp/helenosm](http://j.mp/helenosm)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用多服务器方法创建一个操作系统，类似于在**MINIX 3**（[j.mp/minix3](http://j.mp/minix3)）或**GNU
    Hurd**（[j.mp/gnuhurd](http://j.mp/gnuhurd)）中实现的方式。多服务器操作系统有一个最小的内核，称为**微内核**，它在特权模式下运行。系统中的所有其他服务都遵循服务器架构（驱动服务器、进程服务器、文件服务器等等）。每个服务器属于不同的内存地址空间，并在用户模式下运行在微内核之上。这种方法的优点是操作系统可以变得更加容错、可靠和安全的。例如，由于所有驱动都在驱动服务器上以用户模式运行，一个驱动程序中的错误不能使整个系统崩溃，也不能影响其他服务器。这种方法的缺点是性能开销和系统编程的复杂性。这些都是由于服务器和微内核之间，以及独立服务器之间通过消息传递进行通信的结果。消息传递比在如Linux（[j.mp/helenosm](http://j.mp/helenosm)）这样的单一内核中使用的共享内存模型更复杂。
- en: 'We begin with a `Server` interface. An `Enum` parameter describes the different
    possible states of a server. We use the `Server` interface and make the fundamental
    `boot()` and `kill()` methods mandatory, assuming that different actions are needed
    to be taken for booting, killing, and restarting each server. If you have not
    used the ABC module before, note the following important things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Server`接口开始。一个`Enum`参数描述了服务器可能的不同状态。我们使用`Server`接口并使基本的`boot()`和`kill()`方法成为强制性的，假设对于启动、终止和重启每个服务器都需要采取不同的操作。如果你之前没有使用ABC模块，请注意以下重要事项：
- en: We need to subclass `ABCMeta` using the `metaclass` keyword.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用`metaclass`关键字来子类化`ABCMeta`。
- en: We use the `@abstractmethod` decorator for stating which methods should be implemented
    (mandatory) by all subclasses of the server.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`@abstractmethod`装饰器来声明服务器所有子类应该实现（强制）的方法。
- en: Try removing the `boot()` or `kill()` method of a subclass and see what happens.
    Do the same after removing the `@abstractmethod` decorator as well. Do things
    work as you expected?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试移除子类的`boot()`或`kill()`方法，看看会发生什么。同样，在移除`@abstractmethod`装饰器之后也做同样的事情。事情是否如你所预期的那样进行？
- en: 'Let''s consider the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A modular OS can have a great number of interesting servers: a file server,
    a process server, an authentication server, a network server, a graphical/window
    server, and so forth. The following example includes two stub servers: `FileServer`
    and `ProcessServer`. Apart from the methods required to be implemented by the
    `Server` interface, each server can have its own specific methods. For instance,
    `FileServer` has a `create_file()` method for creating files, and `ProcessServer`
    has a `create_process()` method for creating processes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化操作系统可以拥有大量有趣的服务器：文件服务器、进程服务器、认证服务器、网络服务器、图形/窗口服务器等等。以下示例包括两个存根服务器：`FileServer`和`ProcessServer`。除了`Server`接口要求实现的方法外，每个服务器还可以有自己的特定方法。例如，`FileServer`有一个`create_file()`方法用于创建文件，而`ProcessServer`有一个`create_process()`方法用于创建进程。
- en: 'The `FileServer` class is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileServer`类如下：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ProcessServer` class is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessServer`类如下：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `OperatingSystem` class is a façade. In its `__init__()` method, all the
    necessary server instances are created. The `start()` method, used by the client
    code, is the entry point to the system. More wrapper methods can be added, if
    necessary, as access points to the services of the servers, such as the `create_file()`,
    and `create_process()` wrappers. From the client's point of view, all those services
    are provided by the `OperatingSystem` class. The client should not be confused
    by unnecessary details such as the existence of servers and the responsibility
    of each server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperatingSystem` 类是一个门面。在其 `__init__()` 方法中，创建了所有必要的服务器实例。客户端代码使用的 `start()`
    方法是进入系统的入口点。如果需要，可以添加更多包装方法，作为访问服务器服务（如 `create_file()` 和 `create_process()` 包装器）的入口点。从客户端的角度来看，所有这些服务都是由
    `OperatingSystem` 类提供的。客户端不应该被服务器存在和每个服务器的责任等不必要的细节所困惑。'
- en: 'The code for the `OperatingSystem` class is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperatingSystem` 类的代码如下：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you are going to see in a minute, when we present a summary of the example,
    there are many dummy classes and servers. They are there to give you an idea about
    the required abstractions (`User`, `Process`, `File`, and so forth) and servers
    (`WindowServer`, `NetworkServer`, and so forth) for making the system functional.
    A recommended exercise is to implement at least one service of the system (for
    example, file creation). Feel free to change the interface and the signature of
    the methods to fit your needs. Make sure that after your changes, the client code
    does not need to know anything other than the façade `OperatingSystem` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在下一分钟看到的那样，当我们展示示例的摘要时，有许多虚拟类和服务器。它们的存在是为了让您了解所需的抽象（如 `User`、`Process`、`File`
    等）和服务器（如 `WindowServer`、`NetworkServer` 等），以便使系统功能化。一个推荐的练习是实现系统至少一个服务（例如，文件创建）。请随意更改接口和方法签名以适应您的需求。确保在您的更改之后，客户端代码除了门面
    `OperatingSystem` 类之外不需要了解任何其他内容。
- en: 'This application could be summarized in the following UML diagram, where `OperatingSystem`
    interacts with both `FileServer` and `ProcessServer`, hiding their methods away
    from the client code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序可以用以下 UML 图来总结，其中 `OperatingSystem` 与 `FileServer` 和 `ProcessServer` 交互，将它们的方法隐藏在客户端代码之外：
- en: '![Figure 22.1 — UML diagram for the OS example ](img/Figure_22.1_B17499.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 22.1 — OS 示例的 UML 图](img/Figure_22.1_B17499.jpg)'
- en: Figure 22.1 — UML diagram for the OS example
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.1 — OS 示例的 UML 图
- en: 'We are going to recapitulate the details of our implementation example; the
    full code is in the `facade.py` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾实现示例的细节；完整的代码在 `facade.py` 文件中：
- en: 'We start with the imports we need:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义所需的导入：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We define the `State` constant using `Enum`, as shown earlier.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `Enum` 定义了 `State` 常量，如之前所示。
- en: 'We then add the `User`, `Process`, and `File` classes, which do nothing in
    this minimal but functional example:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加了 `User`、`Process` 和 `File` 类，在这个最小但功能性的示例中，它们什么都不做：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We define the base `Server` class, as shown earlier.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了之前展示的基类 `Server`。
- en: We then define the `FileServer` class and the `ProcessServer` class, which are
    both subclasses of `Server`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了 `FileServer` 类和 `ProcessServer` 类，它们都是 `Server` 的子类。
- en: 'We add two other dummy classes, `WindowServer` and `NetworkServer`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了两个其他虚拟类，`WindowServer` 和 `NetworkServer`：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we define our façade class, `OperatingSystem`, as shown earlier.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了我们之前展示的 `OperatingSystem` 门面类。
- en: 'Finally, here is the main part of the code, where we use the façade we have
    defined:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这里是代码的主要部分，我们使用了我们定义的门面：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, executing the `python facade.py` command shows the starting
    message of our two stub servers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，执行 `python facade.py` 命令会显示我们两个虚拟服务器的起始消息：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The façade `OperatingSystem` class does a good job. The client code can create
    files and processes without needing to know internal details about the OS, such
    as the existence of multiple servers. To be precise, the client code can call
    the methods for creating files and processes, but they are currently dummies.
    As an interesting exercise, you can implement one of the two methods, or even
    both.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 门面 `OperatingSystem` 类做得很好。客户端代码可以创建文件和进程，而无需了解操作系统内部细节，例如多个服务器的存在。更准确地说，客户端代码可以调用创建文件和进程的方法，但它们目前是虚拟的。作为一个有趣的练习，你可以实现这两个方法中的任何一个，甚至两个都实现。
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned how to use the façade pattern. This pattern
    is ideal for providing a simple interface to client code that wants to use a complex
    system but does not need to be aware of the system''s complexity. We discussed
    a Django third-party module that uses façade: `django-oscar-datacash`. It uses
    the façade pattern to provide a simple DataCash API and the ability to save transactions.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用门面模式。这个模式非常适合为想要使用复杂系统但不需要了解系统复杂性的客户端代码提供一个简单的接口。我们讨论了一个使用门面的Django第三方模块：`django-oscar-datacash`。它使用门面模式提供了一个简单的DataCash
    API以及保存交易的能力。
- en: We also learned how to implement the interface used by a multiserver OS. Overall,
    we learned that a façade is an elegant way of hiding the complexity of a system
    because, in most cases, the client code should not be aware of such details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何实现多服务器操作系统所使用的接口。总的来说，我们了解到门面模式是一种优雅地隐藏系统复杂性的方法，因为在大多数情况下，客户端代码不应该意识到这些细节。
- en: In the next chapter, we will cover other structural design patterns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍其他结构化设计模式。
- en: Questions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the high-level benefits of using the façade pattern?
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用门面模式有哪些高级好处？
- en: How does using the façade pattern help when it comes to making changes to an
    application?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用门面模式在修改应用程序时有什么帮助？
- en: How is the façade pattern implemented in the Python example of the OS we considered?
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们考虑的操作系统Python示例中，门面模式是如何实现的？
- en: Further reading
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns* by Gamma Enrich, Helm Richard, Johnson Ralph, and Vlissides
    John available at [https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 《*设计模式*》由Gamma Enrich，Helm Richard，Johnson Ralph和Vlissides John著，可在[https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)找到
