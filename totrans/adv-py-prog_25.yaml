- en: '*Chapter 22*: The Façade Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered a third structural pattern, the bridge
    pattern, which helps to define an abstraction and its implementation in a decoupled
    way, so that both can vary independently. Now, we will learn about another structural
    pattern, the **façade** pattern, which achieves an important goal in many software
    use cases: hiding the inner workings of an application and only giving access
    to what is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the façade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will see why façade is a good pattern to employ
    and what its benefits are, and as always, implement a hands-on example in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter22).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the façade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As systems evolve, they can get very complex. It is not unusual to end up with
    a very large (and sometimes confusing) collection of classes and interactions.
    In many cases, we don't want to expose this complexity to the client. This is
    where façade comes to our rescue.
  prefs: []
  type: TYPE_NORMAL
- en: The façade design pattern helps us to hide the internal complexity of our systems
    and expose only what is necessary to the client through a simplified interface.
    In essence, a façade is an abstraction layer implemented over an existing complex
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the example of a computer to illustrate things. A computer is a complex
    machine that depends on several parts to be fully functional. To keep things simple,
    the word *computer*, in this case, refers to an IBM derivative that uses a von
    Neumann architecture. Booting a computer is a particularly complex procedure.
    The CPU, main memory, and hard disk need to be up and running, the boot loader
    must be loaded from the hard disk to the main memory, the CPU must boot the **operating
    system** (**OS**) kernel, and so forth. Instead of exposing all this complexity
    to the client, we create a façade that encapsulates the whole procedure, making
    sure that all steps are executed in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of object design and programming, we should have several classes, but
    only the `Computer` class needs to be exposed to the client code. The client will
    only have to execute the `start()` method of the `Computer` class, for example,
    and all the other complex parts are taken care of by the façade `Computer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss more real-life examples of the façade pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The façade pattern is quite common in life. When you call a bank or a company,
    you are usually first connected to the customer service department. The customer
    service employee acts as a façade between you and the actual department (billing,
    technical support, general assistance, and so on), and the employee that will
    help you with your specific problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the key used to turn on a car or motorcycle, which can also
    be considered a façade. It is a simple way of activating a system that is very
    complex internally. And, of course, the same is true for other complex electronic
    devices that we can activate with a single button, such as computers.
  prefs: []
  type: TYPE_NORMAL
- en: In software, the `django-oscar-datacash` module is a Django third-party module
    that integrates with the **DataCash** payment gateway. The module has a gateway
    class that provides fine-grained access to the various DataCash APIs. On top of
    that, it also offers a façade class that provides a less granular API (for those
    who don't want to mess with the details), and the ability to save transactions
    for auditing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see why the façade pattern is important in software.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common reason to use the façade pattern is to provide a single, simple
    entry point to a complex system. By introducing a façade, the client code can
    use a system by simply calling a single method/function. At the same time, the
    internal system does not lose any functionality; it just encapsulates it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not exposing the internal functionality of a system to the client code gives
    us an extra benefit: we can introduce changes to the system, but the client code
    remains unaware of and unaffected by the changes. No modifications are required
    to the client code.'
  prefs: []
  type: TYPE_NORMAL
- en: The façade is also useful if you have more than one layer in your system. You
    can introduce one façade entry point per layer, and let all layers communicate
    with each other through their façades. This, in turn, promotes **loose coupling**
    and keeps the layers as independent as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are now ready to try our hand at an actual implementation example
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume that we want to create an OS using a multiserver approach, similar to
    how it is done in **MINIX 3** ([j.mp/minix3](http://j.mp/minix3)) or **GNU Hurd**
    ([j.mp/gnuhurd](http://j.mp/gnuhurd)). A multiserver OS has a minimal kernel,
    called the **microkernel**, which runs in privileged mode. All the other services
    of the system are following a server architecture (driver server, process server,
    file server, and so forth). Each server belongs to a different memory address
    space and runs on top of the microkernel in user mode. The pros of this approach
    are that the OS can become more fault-tolerant, reliable, and secure. For example,
    since all drivers are running in user mode on a driver server, a bug in a driver
    cannot crash the whole system, nor can it affect the other servers. The cons of
    this approach are the performance overhead and the complexity of system programming.
    These are a result of the communication happening between a server and the microkernel,
    as well as between the independent servers, using message passing. Message passing
    is more complex than the shared memory model used in monolithic kernels, such
    as Linux ([j.mp/helenosm](http://j.mp/helenosm)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a `Server` interface. An `Enum` parameter describes the different
    possible states of a server. We use the `Server` interface and make the fundamental
    `boot()` and `kill()` methods mandatory, assuming that different actions are needed
    to be taken for booting, killing, and restarting each server. If you have not
    used the ABC module before, note the following important things:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to subclass `ABCMeta` using the `metaclass` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `@abstractmethod` decorator for stating which methods should be implemented
    (mandatory) by all subclasses of the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try removing the `boot()` or `kill()` method of a subclass and see what happens.
    Do the same after removing the `@abstractmethod` decorator as well. Do things
    work as you expected?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A modular OS can have a great number of interesting servers: a file server,
    a process server, an authentication server, a network server, a graphical/window
    server, and so forth. The following example includes two stub servers: `FileServer`
    and `ProcessServer`. Apart from the methods required to be implemented by the
    `Server` interface, each server can have its own specific methods. For instance,
    `FileServer` has a `create_file()` method for creating files, and `ProcessServer`
    has a `create_process()` method for creating processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileServer` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProcessServer` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `OperatingSystem` class is a façade. In its `__init__()` method, all the
    necessary server instances are created. The `start()` method, used by the client
    code, is the entry point to the system. More wrapper methods can be added, if
    necessary, as access points to the services of the servers, such as the `create_file()`,
    and `create_process()` wrappers. From the client's point of view, all those services
    are provided by the `OperatingSystem` class. The client should not be confused
    by unnecessary details such as the existence of servers and the responsibility
    of each server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `OperatingSystem` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you are going to see in a minute, when we present a summary of the example,
    there are many dummy classes and servers. They are there to give you an idea about
    the required abstractions (`User`, `Process`, `File`, and so forth) and servers
    (`WindowServer`, `NetworkServer`, and so forth) for making the system functional.
    A recommended exercise is to implement at least one service of the system (for
    example, file creation). Feel free to change the interface and the signature of
    the methods to fit your needs. Make sure that after your changes, the client code
    does not need to know anything other than the façade `OperatingSystem` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This application could be summarized in the following UML diagram, where `OperatingSystem`
    interacts with both `FileServer` and `ProcessServer`, hiding their methods away
    from the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 22.1 — UML diagram for the OS example ](img/Figure_22.1_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22.1 — UML diagram for the OS example
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to recapitulate the details of our implementation example; the
    full code is in the `facade.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the imports we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the `State` constant using `Enum`, as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then add the `User`, `Process`, and `File` classes, which do nothing in
    this minimal but functional example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the base `Server` class, as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define the `FileServer` class and the `ProcessServer` class, which are
    both subclasses of `Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add two other dummy classes, `WindowServer` and `NetworkServer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we define our façade class, `OperatingSystem`, as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, here is the main part of the code, where we use the façade we have
    defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, executing the `python facade.py` command shows the starting
    message of our two stub servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The façade `OperatingSystem` class does a good job. The client code can create
    files and processes without needing to know internal details about the OS, such
    as the existence of multiple servers. To be precise, the client code can call
    the methods for creating files and processes, but they are currently dummies.
    As an interesting exercise, you can implement one of the two methods, or even
    both.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned how to use the façade pattern. This pattern
    is ideal for providing a simple interface to client code that wants to use a complex
    system but does not need to be aware of the system''s complexity. We discussed
    a Django third-party module that uses façade: `django-oscar-datacash`. It uses
    the façade pattern to provide a simple DataCash API and the ability to save transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to implement the interface used by a multiserver OS. Overall,
    we learned that a façade is an elegant way of hiding the complexity of a system
    because, in most cases, the client code should not be aware of such details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover other structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the high-level benefits of using the façade pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does using the façade pattern help when it comes to making changes to an
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the façade pattern implemented in the Python example of the OS we considered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns* by Gamma Enrich, Helm Richard, Johnson Ralph, and Vlissides
    John available at [https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)'
  prefs: []
  type: TYPE_NORMAL
