["```py\nclass ConfigHelper(object):\n    def __init__(self, userdirs=None):\n        \"\"\"@keyword userdirs: list of user config\n                              subdirectories names\n        \"\"\"\n        super(ConfigHelper, self).__init__()\n\n        # Attributes\n        self.userdirs = userdirs\n\n        # Setup\n        self.InitializeConfig()\n\n    def InitializeConfig(self):\n        \"\"\"Setup config directories\"\"\"\n        # Create main user config directory if it does\n        # not exist.\n        datap = wx.StandardPaths_Get().GetUserDataDir()\n        if not os.path.exists(datap):\n            os.mkdir(datap)\n        # Make sure that any other application specific\n        # config subdirectories have been created.\n        if self.userdirs:\n            for dname in userdirs:\n                self.CreateUserCfgDir(dname)\n\n```", "```py\n    def CreateUserCfgDir(self, dirname):\n        \"\"\"Create a user config subdirectory\"\"\"\n        path = wx.StandardPaths_Get().GetUserDataDir()\n        path = os.path.join(path, dirname)\n        if not os.path.exists(path):\n            os.mkdir(path)\n\n```", "```py\n    def GetUserConfigPath(self, relpath):\n        \"\"\"Get the path to a resource file\n        in the users configuration directory.\n        @param relpath: relative path (i.e config.cfg)\n        @return: string\n        \"\"\"\n        path = wx.StandardPaths_Get().GetUserDataDir()\n        path = os.path.join(path, relpath)\n        return path\n\n```", "```py\n    def HasConfigFile(self, relpath):\n        \"\"\"Does a given config file exist\"\"\"\n        path = self.GetUserConfigPath(relpath)\n        return os.path.exists(path)\n\n```", "```py\nclass SuperFoo(wx.App):\n    def OnInit(self):\n        self.SetAppName(\"SuperFoo\")\n        self.config = ConfigHelper()\n        self.frame = SuperFooFrame(None, title=\"SuperFoo\")\n        self.frame.Show()\n        return True\n\n    def GetConfig(self):\n        return self.config\n\n```", "```py\nclass PersistentFrame(wx.Frame):\n    def __init__(self, *args, **kwargs):\n        super(PersistentFrame, self).__init__(*args, **kwargs)\n\n        # Setup\n        wx.CallAfter(self.RestoreState)\n\n        # Event Handlers\n        self.Bind(wx.EVT_CLOSE, self._OnClose)\n\n```", "```py\n    def _OnClose(self, event):\n        position = self.GetPosition()\n        size = self.GetSize()\n        cfg = wx.Config()\n        cfg.Write('pos', repr(position.Get()))\n        cfg.Write('size', repr(size.Get()))\n        event.Skip()\n\n```", "```py\n    def RestoreState(self):\n        \"\"\"Restore the saved position and size\"\"\"\n        cfg = wx.Config()\n        name = self.GetName()\n        position = cfg.Read(name + '.pos',\n                            repr(wx.DefaultPosition))\n        size = cfg.Read(name + '.size',\n                        repr(wx.DefaultSize))\n        # Turn strings back into tuples\n        position = eval(position)\n        size = eval(size)\n        # Restore settings to Frame\n        self.SetPosition(position)\n        self.SetSize(size)\n\n```", "```py\nimport wx\nimport threading\nimport socket\nimport select\n\nclass SingleInstApp(wx.App):\n    \"\"\"App baseclass that only allows a single instance to\n    exist at a time.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super(SingleInstApp, self).__init__(*args, **kwargs)\n\n        # Setup (note this will happen after subclass OnInit)\n        instid = \"%s-%s\" % (self.GetAppName(), wx.GetUserId())\n        self._checker = wx.SingleInstanceChecker(instid)\n        if self.IsOnlyInstance():\n           # First instance so start IPC server\n           self._ipc = IpcServer(self, instid, 27115)\n           self._ipc.start()\n           # Open a window\n           self.DoOpenNewWindow()\n        else:\n            # Another instance so just send a message to\n            # the instance that is already running.\n            cmd = \"OpenWindow.%s\" % instid\n            if not SendMessage(cmd, port=27115):\n                print \"Failed to send message!\"\n\n    def __del__(self):\n        self.Cleanup()\n\n```", "```py\n    def Cleanup(self):\n        # Need to cleanup instance checker on exit\n        if hasattr(self, '_checker'):\n            del self._checker\n        if hasattr(self, '_ipc'):\n            self._ipc.Exit()\n\n    def Destroy(self):\n        self.Cleanup()\n        super(SingleInstApp, self).Destroy()\n\n    def IsOnlyInstance(self):\n        return not self._checker.IsAnotherRunning()\n\n    def DoOpenNewWindow(self):\n        \"\"\"Interface for subclass to open new window\n        on ipc notification.\n        \"\"\"\n        pass\n\n```", "```py\nclass IpcServer(threading.Thread):\n    \"\"\"Simple IPC Server\"\"\"\n    def __init__(self, app, session, port):\n        super(IpcServer, self).__init__()\n\n        # Attributes\n        self.keeprunning = True\n        self.app = app\n        self.session = session\n        self.socket = socket.socket(socket.AF_INET,\n                                    socket.SOCK_STREAM)\n\n        # Setup TCP socket\n        self.socket.bind(('127.0.0.1', port))\n        self.socket.listen(5)\n        self.setDaemon(True)\n\n```", "```py\n    def run(self):\n        \"\"\"Run the server loop\"\"\"\n        while self.keeprunning:\n            try:\n                client, addr = self.socket.accept()\n\n                # Read from the socket\n                # blocking up to 2 seconds at a time\n                ready = select.select([client,],[], [],2)\n                if ready[0]:\n                    recieved = client.recv(4096)\n\n                if not self.keeprunning:\n                    break\n\n                # If message ends with correct session\n                # ID then process it.\n                if recieved.endswith(self.session):\n                    if recieved.startswith('OpenWindow'):\n                        wx.CallAfter(self.app.DoOpenNewWindow)\n                    else:\n                        # unknown command message\n                        pass\n                recieved = ''\n            except socket.error, msg:\n                print \"TCP error! %s\" % msg\n                break\n\n        # Shutdown the socket\n        try:\n            self.socket.shutdown(socket.SHUT_RDWR)\n        except:\n            pass\n\n        self.socket.close()\n\n    def Exit(self):\n        self.keeprunning = False\n\n```", "```py\ndef SendMessage(message, port):\n    \"\"\"Send a message to another instance of the app\"\"\"\n    try:\n        # Setup the client socket\n        client = socket.socket(socket.AF_INET,\n                               socket.SOCK_STREAM)\n        client.connect(('127.0.0.1', port))\n        client.send(message)\n        client.shutdown(socket.SHUT_RDWR)\n        client.close()\n    except Exception, msg:\n        return False\n    else:\n        return True\n\n```", "```py\nimport wx\nimport sys\nimport traceback\n\ndef ExceptionHook(exctype, value, trace):\n    \"\"\"Handler for all unhandled exceptions\n    @param exctype: Exception Type\n    @param value: Error Value\n    @param trace: Trace back info\n    \"\"\"\n    # Format the traceback\n    exc = traceback.format_exception(exctype, value, trace)\n    ftrace = \"\".join(exc)\n    app = wx.GetApp()\n    if app:\n        msg = \"An unexpected error has occurred: %s\" % ftrace\n        wx.MessageBox(msg, app.GetAppName(),\n                      style=wx.ICON_ERROR|wx.OK)\n        app.Exit()\n    else:\n        sys.stderr.write(ftrace)\n\nclass ExceptionHandlerApp(wx.App):\n    def OnInit(self):\n        sys.excepthook = ExceptionHook\n        return True\n\n```", "```py\nimport wx\nimport sys\n\nclass OSXApp(wx.App):\n    def OnInit(self):\n        # Enable native spell checking and right\n        # click menu for Mac TextCtrl's\n        if wx.Platform == '__WXMAC__':\n            spellcheck = \"mac.textcontrol-use-spell-checker\"\n            wx.SystemOptions.SetOptionInt(spellcheck, 1)\n        self.frame = OSXFrame(None,\n                              title=\"Optimize for OSX\")\n        self.frame.Show()\n        return True\n\n    def MacReopenApp(self):\n        self.GetTopWindow().Raise()\n\nclass OSXFrame(wx.Frame):\n    \"\"\"Main application window\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(OSXFrame, self).__init__(*args, **kwargs)\n\n        # Attributes\n        self.textctrl = wx.TextCtrl(self,\n                                    style=wx.TE_MULTILINE)\n\n        # Setup Menus\n        mb = wx.MenuBar()\n        fmenu = wx.Menu()\n        fmenu.Append(wx.ID_OPEN)\n        fmenu.Append(wx.ID_EXIT)\n        mb.Append(fmenu, \"&File\")\n        emenu = wx.Menu()\n        emenu.Append(wx.ID_COPY)\n        emenu.Append(wx.ID_PREFERENCES)\n        mb.Append(emenu, \"&Edit\")\n        hmenu = wx.Menu()\n        hmenu.Append(wx.NewId(), \"&Online Help...\")\n        hmenu.Append(wx.ID_ABOUT, \"&About...\")\n        mb.Append(hmenu, \"&Help\")\n\n        if wx.Platform == '__WXMAC__':\n            # Make sure we don't get duplicate\n            # Help menu since we used non standard name\n            app = wx.GetApp()\n            app.SetMacHelpMenuTitleName(\"&Help\")\n\n        self.SetMenuBar(mb)\n        self.SetInitialSize()\n\nif __name__ == '__main__':\n    app = OSXApp(False)\n    app.MainLoop()\n\n```", "```py\nimport wx\nimport os\n\n# Make a shorter alias\n_ = wx.GetTranslation\n\n```", "```py\nclass I18NApp(wx.App):\n    def OnInit(self):\n        self.SetAppName(\"I18NTestApp\")\n        # Get Language from last run if set\n        config = wx.Config()\n        language = config.Read('lang', 'LANGUAGE_DEFAULT')\n\n        # Setup the Locale\n        self.locale = wx.Locale(getattr(wx, language))\n        path = os.path.abspath(\"./locale\") + os.path.sep\n        self.locale.AddCatalogLookupPathPrefix(path)\n        self.locale.AddCatalog(self.GetAppName())\n\n        # Local is not setup so we can create things that\n        # may need it to retrieve translations.\n        self.frame = TestFrame(None,\n                               title=_(\"Sample App\"))\n        self.frame.Show()\n        return True\n\n```", "```py\nclass TestFrame(wx.Frame):\n    \"\"\"Main application window\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(TestFrame, self).__init__(*args, **kwargs)\n\n        # Attributes\n        self.panel = TestPanel(self)\n\n        # Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.panel, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n        self.SetInitialSize((300, 300))\n\nclass TestPanel(wx.Panel):\n    def __init__(self, parent):\n        super(TestPanel, self).__init__(parent)\n\n        # Attributes\n        self.closebtn = wx.Button(self, wx.ID_CLOSE)\n        self.langch = wx.Choice(self,\n                                choices=[_(\"English\"),\n                                         _(\"Japanese\")])\n\n        # Layout\n        self.__DoLayout()\n\n        # Event Handler\n        self.Bind(wx.EVT_CHOICE, self.OnChoice)\n        self.Bind(wx.EVT_BUTTON,\n                  lambda event: self.GetParent().Close())\n\n    def __DoLayout(self):\n        vsizer = wx.BoxSizer(wx.VERTICAL)\n        hsizer = wx.BoxSizer(wx.HORIZONTAL)\n\n        label = wx.StaticText(self, label=_(\"Hello\"))\n        hsizer.AddStretchSpacer()\n        hsizer.Add(label, 0, wx.ALIGN_CENTER)\n        hsizer.AddStretchSpacer()\n\n        langsz = wx.BoxSizer(wx.HORIZONTAL)\n        langlbl = wx.StaticText(self, label=_(\"Language\"))\n        langsz.AddStretchSpacer()\n        langsz.Add(langlbl, 0, wx.ALIGN_CENTER_VERTICAL)\n        langsz.Add(self.langch, 0, wx.ALL, 5)\n        langsz.AddStretchSpacer()\n\n        vsizer.AddStretchSpacer()\n        vsizer.Add(hsizer, 0, wx.EXPAND)\n        vsizer.Add(langsz, 0, wx.EXPAND|wx.ALL, 5)\n        vsizer.Add(self.closebtn, 0, wx.ALIGN_CENTER)\n        vsizer.AddStretchSpacer()\n\n        self.SetSizer(vsizer)\n\n    def OnChoice(self, event):\n        sel = self.langch.GetSelection()\n        config = wx.Config()\n        if sel == 0:\n            val = 'LANGUAGE_ENGLISH'\n        else:\n            val = 'LANGUAGE_JAPANESE'\n        config.Write('lang', val)\n\nif __name__ == '__main__':\n    app = I18NApp(False)\n    app.MainLoop()\n\n```", "```py\nLang_Canonical_Name/LC_MESSAGES/CatalogName.mo\n\n```", "```py\nja_JP/LC_MESSAGES/I18NTestApp.mo\n\n```", "```py\nmsgfmt ja_JP.po\n\n```", "```py\nimport wx\nimport sys\n\n#---- Application Information ----#\nAPP = \"FileEditor.py\"\nNAME = \"File Editor\"\nVERSION = \"1.0\"\nAUTHOR = \"Author Name\"\nAUTHOR_EMAIL = \"authorname@someplace.com\"\nURL = \"http://fileeditor_webpage.foo\"\nLICENSE = \"wxWidgets\"\nYEAR = \"2010\"\n\n#---- End Application Information ----#\n\n```", "```py\nRT_MANIFEST = 24\n\ndef BuildPy2Exe():\n    \"\"\"Generate the Py2exe files\"\"\"\n    from distutils.core import setup\n    try:\n        import py2exe\n    except ImportError:\n        print \"\\n!! You dont have py2exe installed. !!\\n\"\n        exit()\n\n```", "```py\n    pyver = sys.version_info[:2]\n    if pyver == (2, 6):\n        fname = \"py26manifest.xml\"\n    elif pyver == (2, 5):\n        fname = \"py25manifest.xml\"\n    else:\n        vstr = \".\".join(pyver)\n        assert False, \"Unsupported Python Version %s\" % vstr\n    with open(fname, 'rb') as handle:\n        manifest = handle.read()\n        manifest = manifest % dict(prog=NAME)\n\n```", "```py\n    OPTS = {\"py2exe\" : {\"compressed\" : 1,\n                        \"optimize\" : 1,\n                        \"bundle_files\" : 2,\n                        \"excludes\" : [\"Tkinter\",],\n                        \"dll_excludes\": [\"MSVCP90.dll\"]}}\n\n```", "```py\n    setup(\n        name = NAME,\n        version = VERSION,\n        options = OPTS,\n        windows = [{\"script\": APP,\n                    \"icon_resources\": [(1, \"Icon.ico\")],\n                    \"other_resources\" : [(RT_MANIFEST, 1,\n                                          manifest)],\n                  }],\n        description = NAME,\n        author = AUTHOR,\n        author_email = AUTHOR_EMAIL,\n        license = LICENSE,\n        url = URL,\n        )\n\n```", "```py\ndef BuildOSXApp():\n    \"\"\"Build the OSX Applet\"\"\"\n    from setuptools import setup\n\n```", "```py\n    # py2app uses this to generate the plist xml for\n    # the applet.\n    copyright = \"Copyright %s %s\" % (AUTHOR, YEAR)\n    appid = \"com.%s.%s\" % (NAME, NAME)\n    PLIST = dict(CFBundleName = NAME,\n             CFBundleIconFile = 'Icon.icns',\n             CFBundleShortVersionString = VERSION,\n             CFBundleGetInfoString = NAME + \" \" + VERSION,\n             CFBundleExecutable = NAME,\n             CFBundleIdentifier = appid,\n             CFBundleTypeMIMETypes = ['text/plain',],\n             CFBundleDevelopmentRegion = 'English',\n             NSHumanReadableCopyright = copyright\n             )\n\n```", "```py\n    PY2APP_OPTS = dict(iconfile = \"Icon.icns\",\n                       argv_emulation = True,\n                       optimize = True,\n                       plist = PLIST)\n\n    setup(\n        app = [APP,],\n        version = VERSION,\n        options = dict( py2app = PY2APP_OPTS),\n        description = NAME,\n        author = AUTHOR,\n        author_email = AUTHOR_EMAIL,\n        license = LICENSE,\n        url = URL,\n        setup_requires = ['py2app'],\n        )\n\nif __name__ == '__main__':\n    if wx.Platform == '__WXMSW__':\n        # Windows\n        BuildPy2Exe()\n    elif wx.Platform == '__WXMAC__':\n        # OSX\n        BuildOSXApp()\n    else:\n        print \"Unsupported platform: %s\" % wx.Platform\n\n```", "```py\npython setup.py py2exe\n\n```", "```py\npython setup.py py2app\n\n```"]