<html><head></head><body>
  <div><h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-159" class="chapterTitle">Creating Menus with Menu and Tkinter Dialogs</h1>
    <p class="normal">As an application grows in functionality, it becomes increasingly counterproductive to cram all its functions and inputs into a single form. Instead, we will need to organize access to features, information, and controls in a way that keeps them available without cluttering up the visual presentation. GUI toolkits like Tkinter offer us a couple of tools to help deal with this. First, the <strong class="keyword">menu system</strong>, typically located at the top of the application window (or, on some platforms, in a global desktop menu), can be used to organize application functions in a condensed hierarchy. Second, <strong class="keyword">dialog windows</strong>, often referred to as <strong class="keyword">dialog boxes</strong>, provide a quick means of displaying temporary windows containing information, errors, or basic forms.</p>
    <p class="normal">In this chapter, we're going to explore the use and best practices of menus and dialog boxes in Tkinter through the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Solving problems in our application</em>, we'll analyze some reported problems with our application and design a solution involving menus and dialog boxes.</li>
      <li class="bullet">In <em class="italic">Implementing Tkinter dialogs</em>, we'll explore Tkinter's dialog classes and how to use them to implement common application functionality.</li>
      <li class="bullet">In <em class="italic">Designing the application menu</em>, we'll organize our application's features into a main menu system using Tkinter's <code class="Code-In-Text--PACKT-">Menu</code> widget.</li>
    </ul>
    <p class="normal">Let's begin by seeing what improvements our application needs.</p>
    <h1 id="_idParaDest-160" class="title">Solving problems in our application</h1>
    <p class="normal">Although everyone is happy<a id="_idIndexMarker506"/> with your application so far, your boss, after discussion with the staff, has brought you this set of problems that need to be addressed:</p>
    <ul>
      <li class="bullet">The hard-coded filename is a problem. Occasionally the data entry staff aren't able to get to a form until the following day; in this situation, they need to be able to manually enter the filename that they'd like to append the data to.</li>
      <li class="bullet">Also, the data entry<a id="_idIndexMarker507"/> staff have mixed feelings about the auto-filling features in the form. Some find it very helpful, but others would like auto-fill to be partially or completely disabled.</li>
      <li class="bullet">Some users have a hard time noticing the status bar text at the bottom, and would like the application to be more assertive when it fails to save a data record due to field errors.</li>
      <li class="bullet">Finally, the lab is bringing in some interns to work in the labs, and the issue of data security has been raised. IT has suggested a simple login requirement would be advisable. It doesn't have to have high security, just enough to "keep the honest person honest."</li>
    </ul>
    <h2 id="_idParaDest-161" class="title">Planning solutions to the issues</h2>
    <p class="normal">It's clear you need to implement<a id="_idIndexMarker508"/> a way to enter login credentials, select a save file name, and toggle the auto-populate features of the form. You also need to make the status text more noticeable. First, you consider just adding controls to the main application for these features and increasing the size of the status text. You make a quick mock-up that looks like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.1: Our first attempt at adding the new features: three Entry widgets for login data and filename, and two Checkbutton widgets for the settings</p>
    <p class="normal">It's immediately evident<a id="_idIndexMarker509"/> that this is not a great design, and certainly not one that will accommodate growth. Your users don't want to have to type a file path and filename blindly into the box, nor do they need the extra login fields and check boxes cluttering up the user interface. Making the status font larger seems like a good idea, until you realize that the form is now so long it will likely just get pushed off the bottom of the screen.</p>
    <p class="normal">Thinking through other GUI applications, you realize that these features are typically handled by dialog<a id="_idIndexMarker510"/> windows, usually activated from menu options. Taking menus and dialogs into consideration, you plan the following solutions to the problems:</p>
    <ul>
      <li class="bullet">A <strong class="keyword">file dialog</strong>, activated from a menu system, can be used to select the file that the data will be saved to.</li>
      <li class="bullet">A <strong class="keyword">settings menu</strong> in our menu system will handle activating or disabling auto-fill.</li>
      <li class="bullet">An <strong class="keyword">error dialog</strong> will be used to display problematic status messages more assertively.</li>
      <li class="bullet">A <strong class="keyword">login dialog</strong> can be used to enter login information.</li>
    </ul>
    <p class="normal">Before we can code this solution, we'll need to learn more about dialogs in Tkinter.</p>
    <h1 id="_idParaDest-162" class="title">Implementing Tkinter dialogs</h1>
    <p class="normal">Tkinter contains a number of submodules<a id="_idIndexMarker511"/> that provide ready-made dialog windows for different situations. These include:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">messagebox</code>, for displaying simple messages and warnings</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">filedialog</code>, for prompting the user for a file or folder path</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">simpledialog</code>, for requesting string, integer, or float values from a user</li>
    </ul>
    <p class="normal">In this section, we're going to explore these dialogs and use them to solve some of the problems with our application.</p>
    <h2 id="_idParaDest-163" class="title">Error dialogs with the Tkinter messagebox</h2>
    <p class="normal">The best way to display simple<a id="_idIndexMarker512"/> dialog boxes in Tkinter is by using the <code class="Code-In-Text--PACKT-">tkinter.messagebox</code> module, which provides a variety<a id="_idIndexMarker513"/> of information-display dialog types.</p>
    <p class="normal">Since it is a submodule, we<a id="_idIndexMarker514"/> need to explicitly import it before we can use it, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">from tkinter import messagebox
</code></pre>
    <p class="normal">Rather than having a lot of widget classes<a id="_idIndexMarker515"/> that we create instances of, the <code class="Code-In-Text--PACKT-">messagebox</code> module provides a selection of <strong class="keyword">convenience functions</strong> for making use of its various dialog types. When executed, each function displays a different combination of buttons and a preset icon, along with a message and detail text that you specify. When the user clicks a button in the dialog or closes it, the function will return a Boolean or string value depending on which button was clicked.</p>
    <p class="normal">The following table shows some of the <code class="Code-In-Text--PACKT-">messagebox</code> module's functions with their icons and return values:</p>
    <table id="table001-3" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Function</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Icon</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Button text/Return value</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askokcancel()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Question</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">OK (<code class="Code-In-Text--PACKT-">True</code>), Cancel (<code class="Code-In-Text--PACKT-">False</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askretrycancel()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Warning</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Retry (<code class="Code-In-Text--PACKT-">True</code>), Cancel (<code class="Code-In-Text--PACKT-">False</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askyesno()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Question</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Yes (<code class="Code-In-Text--PACKT-">True</code>), No (<code class="Code-In-Text--PACKT-">False</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askyesnocancel()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Question</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Yes (<code class="Code-In-Text--PACKT-">True</code>), No (<code class="Code-In-Text--PACKT-">False</code>), Cancel (<code class="Code-In-Text--PACKT-">None</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">showerror()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Error</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">OK (<code class="Code-In-Text--PACKT-">ok</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">showinfo()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Information</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">OK (<code class="Code-In-Text--PACKT-">ok</code>)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">showwarning()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Warning</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">OK (<code class="Code-In-Text--PACKT-">ok</code>)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Each <code class="Code-In-Text--PACKT-">message</code><code class="Code-In-Text--PACKT-"><a id="_idIndexMarker516"/></code><code class="Code-In-Text--PACKT-">box</code> function accepts this same<a id="_idIndexMarker517"/> set of arguments:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">title</code> sets the title<a id="_idIndexMarker518"/> of the window, which is displayed in the title bar and/or task bar in your desktop environment.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">message</code> sets the main message of the dialog. It's usually in a heading font and should be kept fairly short.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">detail</code> sets the body text of the dialog, which is usually displayed in the standard window font.</li>
    </ul>
    <p class="normal">A basic call to <code class="Code-In-Text--PACKT-">messagebox.showinfo()</code> would look something like this:</p>
    <pre class="programlisting code"><code class="hljs-code">messagebox.showinfo(
  title='This is the title',
  message='This is the message',
  detail='This is the detail'
)
</code></pre>
    <p class="normal">In Windows 10, it results in a dialog box that looks like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_02.png" alt="A showinfo() message box on Windows 10"/></figure>
    <p class="packt_figref">Figure 7.2: A showinfo() message box on Windows 10</p>
    <p class="normal">On<a id="_idIndexMarker519"/> macOS, you'd see<a id="_idIndexMarker520"/> something like<a id="_idIndexMarker521"/> this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.3: A showinfo() message box on macOS</p>
    <p class="normal">On Ubuntu Linux, the dialog looks like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.4: A showinfo() message box on Ubuntu Linux</p>
    <div><p class="Tip--PACKT-">Note that Tkinter <code class="Code-In-Text--PACKT-">messagebox</code> dialog boxes are <strong class="keyword">modal</strong>, which means that the program execution pauses<a id="_idIndexMarker522"/> and the rest of the UI is unresponsive while the dialog box is open. There is no way to change this, so only use them in situations where it's acceptable for the program to pause execution while the box is open.</p>
    </div>
    <p class="normal">Let's create<a id="_idIndexMarker523"/> a small example script to show<a id="_idIndexMarker524"/> the use of the<a id="_idIndexMarker525"/> <code class="Code-In-Text--PACKT-">messagebox</code> functions:</p>
    <pre class="programlisting code"><code class="hljs-code"># messagebox_demo.py
import tkinter as tk
from tkinter import messagebox
see_more = messagebox.askyesno(
  title='See more?',
  message='Would you like to see another box?',
  detail='Click NO to quit'
)
if not see_more:
  exit()
messagebox.showinfo(
  title='You got it',
  message="Ok, here's another dialog.",
  detail='Hope you like it!'
)
</code></pre>
    <p class="normal">This creates a dialog with <strong class="screenText">Yes</strong> and <strong class="screenText">No</strong> buttons. If the user clicks <strong class="screenText">No</strong>, the function returns <code class="Code-In-Text--PACKT-">False</code> and the application<a id="_idIndexMarker526"/> exits. In the case our user<a id="_idIndexMarker527"/> wants to see more boxes, the program continues<a id="_idIndexMarker528"/> and displays an information box.</p>
    <h2 id="_idParaDest-164" class="title">Showing error dialogs in ABQ Data Entry</h2>
    <p class="normal">Now that you understand how to use <code class="Code-In-Text--PACKT-">messagebox</code>, error dialogs should be easy to implement in our application. The <code class="Code-In-Text--PACKT-">Application._on_save()</code> method already displays errors in the status bar; we just<a id="_idIndexMarker529"/> need to make the same text display<a id="_idIndexMarker530"/> in an error dialog as well.</p>
    <p class="normal">First, open <code class="Code-In-Text--PACKT-">application.py</code>, and let's import <code class="Code-In-Text--PACKT-">messagebox</code> like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py at the top of the file
from tkinter import messagebox
</code></pre>
    <p class="normal">Now, locate the line in the <code class="Code-In-Text--PACKT-">Application._on_save()</code> method that updates the application status with any errors (inside the <code class="Code-In-Text--PACKT-">if errors:</code> block). Just after that line, let's add some code to display the error dialog, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application._on_save()
    if errors:
      # ... after setting the status:
      message = "Cannot save record"
      detail = (
        "The following fields have errors: "
        "\n  * {}".format(
          '\n  * '.join(errors.keys())
      ))
      messagebox.showerror(
        title='Error',
        message=message,
        detail=detail
      )
      return False
</code></pre>
    <p class="normal">The first thing we've done is build the message and detail strings for the dialog, making a bullet list of the fields that have errors by joining them with <code class="Code-In-Text--PACKT-">\n *</code> (that is, a newline, space, and asterisk). Unfortunately, <code class="Code-In-Text--PACKT-">messagebox</code> dialogs don't support any sort of markup or rich text, so constructs like bullet lists need to be built manually using regular characters.</p>
    <p class="normal">After building<a id="_idIndexMarker531"/> the messages, we call <code class="Code-In-Text--PACKT-">messagebox.showerror()</code> to display them. Remember<a id="_idIndexMarker532"/> that the application will freeze at this point until the user clicks <strong class="screenText">OK</strong> and the <code class="Code-In-Text--PACKT-">showerror()</code> function returns.</p>
    <p class="normal">Open the program and hit <strong class="screenText">Save</strong>; you'll see a dialog box alerting you to the errors in the application, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B17578_07_05.png" alt="The error message when we try to save with no data"/></figure>
    <p class="packt_figref">Figure 7.5: The error message on Windows 10 when we try to save with no data</p>
    <p class="normal">This error should be hard for anyone to miss!</p>
    <div><p class="Tip--PACKT-">One shortcoming of the <code class="Code-In-Text--PACKT-">messagebox</code> module's dialogs is that they don't scroll; a long error message will create a dialog that may fill (or extend beyond) the screen. If this is a potential problem, you'll want to create a custom dialog containing a scrollable widget. We'll make a custom dialog later in this section.</p>
    </div>
    <h2 id="_idParaDest-165" class="title">Using filedialog</h2>
    <p class="normal">When a user needs<a id="_idIndexMarker533"/> to enter a file or directory path, the preferred<a id="_idIndexMarker534"/> way to do this is to display a dialog containing a miniature file browser, commonly called a <strong class="keyword">file dialog</strong>. Like most toolkits, Tkinter provides us with dialogs<a id="_idIndexMarker535"/> for opening files, saving files, and selecting a directory. These are all part of the <code class="Code-In-Text--PACKT-">filedialog</code> module.</p>
    <p class="normal">Just like <code class="Code-In-Text--PACKT-">messagebox</code>, <code class="Code-In-Text--PACKT-">filedialog</code> is a Tkinter submodule that needs to be explicitly imported to be used. Also like <code class="Code-In-Text--PACKT-">messagebox</code>, it contains a set of convenience functions that create file dialogs appropriate to different scenarios.</p>
    <p class="normal">The following table lists the functions, what they return, and what can be selected in the dialog shown:</p>
    <table id="table002-3" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Function</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Return value</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Allows selection of</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askdirectory()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Directory path as string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Directories only</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askopenfile()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">File handle object</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Existing file only</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askopenfilename()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">File path as string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Existing file only</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">askopenfilenames()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Multiple file paths as a list of strings</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Multiple existing files</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">asksaveasfile()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">File handle object</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">New or existing file</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">asksaveasfilename()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">File path as string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">New or existing file</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">As you can see, each file selection dialog comes in two versions: one that returns a path as a string, and one that returns an open file object.</p>
    <p class="normal">Each function can take the following arguments:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">title</code> specifies the dialog window title.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">parent</code> specifies the (optional) parent widget. The file dialog will appear over this widget.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">initialdir</code> sets the directory in which the file browser should start.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">filetypes</code> is a list of tuples, each with a label and matching pattern, which will be used to build the "Format" or "files of type" drop-down typically seen under the filename entry. This is used to filter the visible files to only those supported by the application. For example, a value of <code class="Code-In-Text--PACKT-">[('Text', '*.txt'), ('Python', '*.py')]</code> would provide the ability to see only <code class="Code-In-Text--PACKT-">.txt</code> or <code class="Code-In-Text--PACKT-">.py</code> files.</li>
    </ul>
    <p class="normal">The <code class="Code-In-Text--PACKT-">asksaveasfile()</code> and <code class="Code-In-Text--PACKT-">asksaveasfilename()</code> functions take the following two additional arguments:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">initialfile</code>: This argument is a default file path to select</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">defaultextension</code>: This argument is a file extension string that will be automatically appended to the filename if the user doesn't include one</li>
    </ul>
    <p class="normal">Finally, the methods that return a file object take a <code class="Code-In-Text--PACKT-">mode</code> argument that specifies the mode to use when opening the file; these are the same one- or two-character strings used by Python's built-in <code class="Code-In-Text--PACKT-">open()</code> function (for example, <code class="Code-In-Text--PACKT-">r</code> for read-only, <code class="Code-In-Text--PACKT-">w</code> for write, and so on).</p>
    <div><p class="Information-Box--PACKT-">Be aware that <code class="Code-In-Text--PACKT-">asksaveasfile()</code> automatically opens the selected file in write mode by default. This immediately empties the contents of the selected file, <em class="italic">even if you do not subsequently write anything to the file or close the file handle! </em>For that reason, this function should be avoided unless you're absolutely certain the selected file should be overwritten.</p>
    </div>
    <p class="normal">On macOS and Windows, <code class="Code-In-Text--PACKT-">filedialog</code> uses the operating system's built-in file dialogs, which you are<a id="_idIndexMarker536"/> likely familiar with. On Linux, it will use its own dialog, which looks<a id="_idIndexMarker537"/> something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.6: File dialog on Ubuntu Linux</p>
    <p class="normal">Which dialog do we need to use in our application? Let's consider our needs:</p>
    <ul>
      <li class="bullet">We need a dialog that allows us to select an existing file.</li>
      <li class="bullet">We also need to be able to create a new file.</li>
      <li class="bullet">Since opening the file is the responsibility of the model, we don't want Tkinter to open it for us, so we'll just want to get a filename to pass to the model.</li>
    </ul>
    <p class="normal">These requirements clearly point to the <code class="Code-In-Text--PACKT-">asksaveasfilename()</code> function. Let's create a method on our <code class="Code-In-Text--PACKT-">Application</code> object that will use this dialog to get a filename and build a new model.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">abq_data_entry/application.py</code> and start a new method on the <code class="Code-In-Text--PACKT-">Application</code> class called <code class="Code-In-Text--PACKT-">_on_file_select()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/application.py, in the Application class
  def _on_file_select(self, *_):
    """Handle the file-&gt;select action"""
    filename = filedialog.asksaveasfilename(
      title='Select the target file for saving records',
      defaultextension='.csv',
      filetypes=[('CSV', '*.csv *.CSV')]
    )
</code></pre>
    <p class="normal">The method first<a id="_idIndexMarker538"/> launches an <code class="Code-In-Text--PACKT-">asksaveasfilename</code> file dialog; using the <code class="Code-In-Text--PACKT-">filetypes</code> argument, the<a id="_idIndexMarker539"/> selection of existing files will be limited to those ending in <code class="Code-In-Text--PACKT-">.csv</code> or <code class="Code-In-Text--PACKT-">.CSV</code>. When the dialog exits, the function will return the path to the selected file as a string to <code class="Code-In-Text--PACKT-">filename</code>. Somehow, we have to get this path to our model.</p>
    <p class="normal">Currently, the filename used by the model is generated in the model's initializer method. To create a new model with a user-provided filename, we'll need to update the initializer so that it can accept a filename as an argument instead.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">abq_data_entry/model.py</code> and let's edit the <code class="Code-In-Text--PACKT-">CSVModel.__init__()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/models.py, in CSVModel
  def __init__(self, <strong class="hljs-slc">filename=None</strong>):
    <strong class="hljs-keyword-slc">if not</strong><strong class="hljs-slc"> filename</strong>:
      datestring = datetime.today().strftime("%Y-%m-%d")
      filename = "abq_data_record_{}.csv".format(datestring)
    self.file = Path(filename)
</code></pre>
    <p class="normal">As you can see, we've added <code class="Code-In-Text--PACKT-">filename</code> as a keyword argument with a default value of <code class="Code-In-Text--PACKT-">None</code>. If <code class="Code-In-Text--PACKT-">filename</code> does happen to be empty, we'll use our generated filename as before. This way, we don't have to alter any existing code using <code class="Code-In-Text--PACKT-">CSVModel</code>, but we have the option to pass in a filename.</p>
    <p class="normal">Now, go back to the <code class="Code-In-Text--PACKT-">Application</code> class and let's finish out the <code class="Code-In-Text--PACKT-">_on_file_select()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/application.py, in CSVModel._on_file_select()
    if filename:
      self.model = m.CSVModel(filename=filename)
</code></pre>
    <p class="normal">This is all that<a id="_idIndexMarker540"/> we need to change to use a different file. Currently there's no way<a id="_idIndexMarker541"/> for us to run this callback; we'll address that in the next section, <em class="italic">Designing the application menu</em>. First, though, let's talk about the last dialog module, <code class="Code-In-Text--PACKT-">simpledialog</code>.</p>
    <h2 id="_idParaDest-166" class="title">Using simpledialog and creating a custom dialog</h2>
    <p class="normal">Quite often in a GUI application, you will need to stop everything and ask the user for a value before the program<a id="_idIndexMarker542"/> can continue with an operation. For this purpose, Tkinter<a id="_idIndexMarker543"/> provides the <code class="Code-In-Text--PACKT-">simpledialog</code> module. Like <code class="Code-In-Text--PACKT-">messagebox</code>, it provides us with some convenience functions<a id="_idIndexMarker544"/> that display a modal dialog and return a value based<a id="_idIndexMarker545"/> on the user's interaction. However, with <code class="Code-In-Text--PACKT-">simpledialog</code>, the dialog box contains an <code class="Code-In-Text--PACKT-">Entry</code> widget that allows the user to provide a value.</p>
    <p class="normal">As with the other dialog libraries, we have to import <code class="Code-In-Text--PACKT-">simpledialog</code> to use it, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">from tkinter import simpledialog as sd
</code></pre>
    <p class="normal">There are three convenience functions available: <code class="Code-In-Text--PACKT-">askstring()</code>, <code class="Code-In-Text--PACKT-">askinteger()</code>, and <code class="Code-In-Text--PACKT-">askfloat()</code>. Each one takes a <code class="Code-In-Text--PACKT-">title</code> and <code class="Code-In-Text--PACKT-">prompt</code> argument, for providing the window title and the text prompt for the entry, respectively.</p>
    <p class="normal">For example, let's ask the user for a word:</p>
    <pre class="programlisting code"><code class="hljs-code">word = sd.askstring('Word', 'What is the word?')
</code></pre>
    <p class="normal">This will display a box like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_07.png" alt="The askstring dialog box on macOS"/></figure>
    <p class="packt_figref">Figure 7.7: The askstring dialog box on macOS</p>
    <p class="normal">When the user clicks <strong class="screenText">OK</strong>, the function will return whatever was typed into the <code class="Code-In-Text--PACKT-">Entry</code> widget as a string. <code class="Code-In-Text--PACKT-">askinteger()</code> and <code class="Code-In-Text--PACKT-">askfloat()</code> work exactly the same, except that they will try to convert the entered value into an integer or float before returning it. The <code class="Code-In-Text--PACKT-">Entry</code> widget itself<a id="_idIndexMarker546"/> is not validated using validation callbacks, but Tkinter will display<a id="_idIndexMarker547"/> an error box when the dialog is submitted if there is a problem converting the entered value, as shown here:</p>
    <figure class="mediaobject"><img src="img/B17578_07_08.png" alt="Error generated from askinteger() when a non-integer value is submitted."/></figure>
    <p class="packt_figref">Figure 7.8: Error generated from askinteger() when a non-integer value is submitted</p>
    <h3 id="_idParaDest-167" class="title">Creating a Login dialog using simpledialog</h3>
    <p class="normal">One of the tasks we've been given for this chapter is adding a <code class="Code-In-Text--PACKT-">Login</code> dialog to our application. It seems like something <code class="Code-In-Text--PACKT-">simpledialog</code> can help us with, but none of the built-in convenience functions<a id="_idIndexMarker548"/> really work well for this purpose: <code class="Code-In-Text--PACKT-">askstring()</code> could<a id="_idIndexMarker549"/> be used, but it only asks for one string at a time, and it would be nice if we could mask the password entry for user security.</p>
    <p class="normal">Fortunately we can create our own custom <code class="Code-In-Text--PACKT-">simpledialog</code> class with any set of fields we wish. To do that, we'll subclass the <code class="Code-In-Text--PACKT-">simpledialog.Dialog</code> class.</p>
    <p class="normal">Since this is a GUI form, let's add it to our <code class="Code-In-Text--PACKT-">abq_data_entry/views.py</code> file. Open that file and start with importing <code class="Code-In-Text--PACKT-">Dialog</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/views.py at the top
from tkinter.simpledialog import Dialog
</code></pre>
    <p class="normal">Now, at the end of the file, let's start a new class called <code class="Code-In-Text--PACKT-">LoginDialog</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/views.py at the bottom
class LoginDialog(Dialog):
  """A dialog that asks for username and password"""
  def __init__(self, parent, title, error=''):
    self._pw = tk.StringVar()
    self._user = tk.StringVar()
    self._error = tk.StringVar(value=error)
    super().__init__(parent, title=title)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Dialog</code> initializer expects a <code class="Code-In-Text--PACKT-">parent</code> argument specifying the widget over which it will appear, as well as a <code class="Code-In-Text--PACKT-">title</code> argument for the window title of the box. We've also added a keyword argument, <code class="Code-In-Text--PACKT-">error</code>, that will allow us to pass an error message to the dialog box when we display it.</p>
    <p class="normal">Inside the initializer, we're setting up private control variables for the user, password, and error strings, then calling the superclass initializer. To actually build the GUI for the <code class="Code-In-Text--PACKT-">Dialog</code> class, we need to override a method called <code class="Code-In-Text--PACKT-">body()</code>. This method is expected to build the main body<a id="_idIndexMarker550"/> of the GUI and return an instance<a id="_idIndexMarker551"/> of an input widget, which should receive focus when the dialog is displayed.</p>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">body()</code> method will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def body(self, frame):
    ttk.Label(frame, text='Login to ABQ').grid(row=0)
    if self._error.get():
      ttk.Label(frame, textvariable=self._error).grid(row=1)
    user_inp = w.LabelInput(
      frame, 'User name:', input_class=w.RequiredEntry,
      var=self._user
    )
    user_inp.grid()
    w.LabelInput(
      frame, 'Password:', input_class=w.RequiredEntry,
      input_args={'show': '*'}, var=self._pw
    ).grid()
    return user_inp.input
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">frame</code> argument to this method is a <code class="Code-In-Text--PACKT-">tkinter.Frame</code> object created by the super-class initializer on which the body of the dialog can be built. Our method needs to build the form on this frame. Here, we've added a <code class="Code-In-Text--PACKT-">Label</code> widget for the top of the form, then made use of our <code class="Code-In-Text--PACKT-">LabelInput</code> class to add User name and Password fields. For our password input, we're using the <code class="Code-In-Text--PACKT-">show</code> argument to mask password entry with asterisks. Also note that we've saved a local reference to the user input class; remember that <code class="Code-In-Text--PACKT-">body()</code> needs to return a reference to a widget that will have focus when the dialog is shown.</p>
    <p class="normal">Notice there are no buttons defined by our <code class="Code-In-Text--PACKT-">body()</code> method. By default, <code class="Code-In-Text--PACKT-">Dialog</code> creates an <strong class="screenText">OK</strong> button and <strong class="screenText">Cancel</strong> button, which are connected to the <code class="Code-In-Text--PACKT-">Dialog.ok()</code> and <code class="Code-In-Text--PACKT-">Dialog.cancel()</code> callbacks, respectively. This is fine for many situations, but we might prefer for our dialog to show <strong class="screenText">Login</strong> and <strong class="screenText">Cancel</strong> instead. To do that, we need to override the <code class="Code-In-Text--PACKT-">buttonbox()</code> method. This method is responsible for putting the buttons on the form and connecting them to their callbacks.</p>
    <p class="normal">Let's override that method like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  def buttonbox(self):
    box = ttk.Frame(self)
    ttk.Button(
      box, text="Login", command=self.ok, default=tk.ACTIVE
    ).grid(padx=5, pady=5)
    ttk.Button(
      box, text="Cancel", command=self.cancel
    ).grid(row=0, column=1, padx=5, pady=5)
    self.bind("&lt;Return&gt;", self.ok)
    self.bind("&lt;Escape&gt;", self.cancel)
    box.pack()
</code></pre>
    <p class="normal">In this method, we've created a <code class="Code-In-Text--PACKT-">Frame</code> widget, then added Login and Cancel buttons. Each button<a id="_idIndexMarker552"/> is connected to the appropriate callback<a id="_idIndexMarker553"/> and added to the frame. Next, we've bound the same callbacks to the <code class="Code-In-Text--PACKT-">Return</code> and <code class="Code-In-Text--PACKT-">Escape</code> keys, respectively. This isn't strictly necessary, but it's a nice touch for keyboard-only users, and it's what the superclass version of the method does.</p>
    <p class="normal">To make the entered data easily available to the code calling the dialog, we'll create a tuple with the entered username and password and make it available as a class member when the user clicks <strong class="screenText">Login</strong>. </p>
    <p class="normal">We could override the <code class="Code-In-Text--PACKT-">ok()</code> method to do this, but that method takes care of some other logic (like closing the dialog) that we don't want to have to re-implement. Instead, <code class="Code-In-Text--PACKT-">Dialog</code> features an <code class="Code-In-Text--PACKT-">apply()</code> method that we are meant to override with our custom logic.</p>
    <p class="normal">Ours will simply look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def apply(self):
    self.result = (self._user.get(), self._pw.get())
</code></pre>
    <p class="normal">This function builds a tuple containing the entered data and stores it as a public member, <code class="Code-In-Text--PACKT-">result</code>. Code using our <code class="Code-In-Text--PACKT-">LoginDialog</code> class can access this attribute to retrieve the <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code>.</p>
    <h3 id="_idParaDest-168" class="title">Incorporating the LoginDialog in our class</h3>
    <p class="normal">The convenience functions, <code class="Code-In-Text--PACKT-">askstring()</code>, <code class="Code-In-Text--PACKT-">askfloat()</code>, and <code class="Code-In-Text--PACKT-">askinteger()</code>, essentially create an instance of their associated<a id="_idIndexMarker554"/> dialog class and return its <code class="Code-In-Text--PACKT-">result</code> attribute. To use our custom dialog class, we'll essentially do the same thing. When we get the result, however, we'll pass it to an authentication method that will decide if the credentials are valid or not. If they're not, we'll re-display the dialog with an error until either the credentials are correct, or the user cancels the dialog.</p>
    <p class="normal">To begin, let's write an authentication method. We'll be adding this to the <code class="Code-In-Text--PACKT-">Application</code> class, so open <code class="Code-In-Text--PACKT-">application.py</code> and add this <code class="Code-In-Text--PACKT-">_simple_login()</code> method to the end of the class:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, at the end of the Application class
  @staticmethod
  def _simple_login(username, password):
    return username == 'abq' and password == 'Flowers'
</code></pre>
    <p class="normal">Notice we've implemented this as a static method, since it does not need access to the instance or class. It will simply<a id="_idIndexMarker555"/> take the <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> given and see if they match hard-coded values. It returns <code class="Code-In-Text--PACKT-">True</code> or <code class="Code-In-Text--PACKT-">False</code> accordingly.</p>
    <div><p class="Information-Box--PACKT-">This is quite possibly the worst way you can do password security in an application; <em class="italic">do not</em> ever use this approach in a real application. We are using it here for the sake of illustration, since the point is to understand dialogs. In <em class="chapterRef">Chapter 12</em>, <em class="italic">Improving Data Storage with SQL</em>, we'll implement an authentication backend that's actually production-worthy. </p>
    </div>
    <p class="normal">Now, let's create a second method that will display the login dialog and test the entered credentials for validity, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, at the end of the Application class
  def _show_login(self):
    error = ''
    title = "Login to ABQ Data Entry"
    while True:
      login = v.LoginDialog(self, title, error)
      if not login.result:  # User canceled
        return False
      username, password = login.result
      if self._simple_login(username, password):
        return True
      error = 'Login Failed' # loop and redisplay
</code></pre>
    <p class="normal">In this method, we begin by creating <code class="Code-In-Text--PACKT-">error</code> and <code class="Code-In-Text--PACKT-">title</code> variables, then entering an infinite loop. Inside the loop, we create our <code class="Code-In-Text--PACKT-">LoginDialog</code> instance using the <code class="Code-In-Text--PACKT-">title</code> and <code class="Code-In-Text--PACKT-">error</code> strings. This will display the dialog, and execution will halt here until the user either cancels or submits the dialog. When that happens, <code class="Code-In-Text--PACKT-">login</code> is assigned to the instance of the dialog (<em class="italic">not</em> to the results!). Now we can check <code class="Code-In-Text--PACKT-">login.result</code> to see what the user entered.</p>
    <p class="normal">If <code class="Code-In-Text--PACKT-">result</code> is empty, the user canceled, so we can return <code class="Code-In-Text--PACKT-">False</code> from the method. If the user entered something, we'll extract <code class="Code-In-Text--PACKT-">result</code> into its <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> values, then pass those to our <code class="Code-In-Text--PACKT-">_simple_login()</code> method. If the credentials check out, we will return <code class="Code-In-Text--PACKT-">True</code>; if not, we'll update the error string and let the loop iterate again, re-displaying the dialog. The net result is that this method will return either <code class="Code-In-Text--PACKT-">False</code> if the dialog was canceled, or <code class="Code-In-Text--PACKT-">True</code> if the authentication succeeded.</p>
    <p class="normal">Now, we need to call this method<a id="_idIndexMarker556"/> during the startup of our application. We'll do this in the application's initializer. Since dialogs cannot be created until a root window has been created, we'll have to do this just after the call to <code class="Code-In-Text--PACKT-">super().__init__()</code> (remember that <code class="Code-In-Text--PACKT-">Application</code> is a subclass of <code class="Code-In-Text--PACKT-">Tk</code>, so calling <code class="Code-In-Text--PACKT-">super().__init__()</code> is what creates our <code class="Code-In-Text--PACKT-">Tk</code> instance).</p>
    <p class="normal">Add the following code to <code class="Code-In-Text--PACKT-">Application.__init__()</code>, just under the call to <code class="Code-In-Text--PACKT-">super().__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.withdraw()
    if not self._show_login():
      self.destroy()
      return
    self.deiconify()
</code></pre>
    <p class="normal">The first line calls the <code class="Code-In-Text--PACKT-">withdraw()</code> method, which hides our main window. We don't strictly have to do this, but without it we'll have a blank <code class="Code-In-Text--PACKT-">Application</code> window hanging around while the login dialog is being presented.</p>
    <p class="normal">After hiding the blank window, we'll call <code class="Code-In-Text--PACKT-">_show_login()</code> and test its <code class="Code-In-Text--PACKT-">return</code> value. Remember it will return <code class="Code-In-Text--PACKT-">True</code> if the user successfully authenticates, or <code class="Code-In-Text--PACKT-">False</code> if the user cancels the dialog. In the latter case, we'll call <code class="Code-In-Text--PACKT-">self.destroy()</code>, which deletes our <code class="Code-In-Text--PACKT-">Tk</code> instance, and return from the method. Effectively, this quits the application.</p>
    <div><p class="Tip--PACKT-">Normally you would call <code class="Code-In-Text--PACKT-">Application.quit()</code> to exit a Tkinter program; this method of the <code class="Code-In-Text--PACKT-">Tk</code> object causes the main loop to exit and thus the program ends. However, at this point in the program, we haven't started the main loop yet, so <code class="Code-In-Text--PACKT-">quit()</code> won't do anything. If we destroy the window and return without adding anything else, the main loop will see that the root window is destroyed and exit after its first iteration.</p>
    </div>
    <p class="normal">If the user is successful in authenticating, we'll call the application's <code class="Code-In-Text--PACKT-">deiconify()</code> method, which restores its visibility. Then we continue with the remainder of the initializer.</p>
    <p class="normal">Go ahead and launch<a id="_idIndexMarker557"/> the application to give your <code class="Code-In-Text--PACKT-">LoginDialog</code> class a test run. It should look something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_09.png" alt="The login dialog"/></figure>
    <p class="packt_figref">Figure 7.9: The login dialog</p>
    <p class="normal">Great job!</p>
    <h1 id="_idParaDest-169" class="title">Designing the application menu</h1>
    <p class="normal">Most applications organize functionality into a hierarchical menu system, typically displayed at the top<a id="_idIndexMarker558"/> of the application or screen (depending on the operating system). While the organization of this menu varies between operating systems, certain items are fairly common across platforms.</p>
    <p class="normal">Of these common items, our application<a id="_idIndexMarker559"/> will need the following:</p>
    <ul>
      <li class="bullet">A <strong class="keyword">File menu</strong> containing file operations such as <strong class="screenText">Open</strong>/<strong class="screenText">Save</strong>/<strong class="screenText">Export</strong>, and often an option to quit<a id="_idIndexMarker560"/> the application. Our users will need this menu to select a file to save to, and to quit the program.</li>
      <li class="bullet">An <strong class="keyword">Options menu</strong> where users can configure the application. We'll need this menu for our<a id="_idIndexMarker561"/> toggle settings; sometimes a menu like this is called Preferences or Settings, but we'll go with Options for now.</li>
      <li class="bullet">A <strong class="keyword">Help menu</strong>, which contains links to help documentation, or, at the very least, an About message<a id="_idIndexMarker562"/> giving the basic information about the<a id="_idIndexMarker563"/> application. We'll implement this menu for the About dialog.</li>
    </ul>
    <div><p class="Information-Box--PACKT-">Apple, Microsoft, and the GNOME Project publish guidelines for macOS, Windows, and the GNOME desktop environment (used on Linux and BSD), respectively; each set of guidelines addresses the layout of menu items specific to that platform. We'll explore this in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>.</p>
    </div>
    <p class="normal">Before we can implement our menu, we'll need to understand how menus work in Tkinter.</p>
    <h2 id="_idParaDest-170" class="title">The Tkinter Menu widget</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">tkinter.Menu</code> widget is the building block used to implement menus in Tkinter applications; it's a fairly<a id="_idIndexMarker564"/> simple widget that acts as a container for any number of menu items.</p>
    <p class="normal">The menu items can be one of the following five types:</p>
    <table id="table003-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Item type</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">command</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A labeled item that executes a command when clicked</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">checkbutton</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A labeled checkbutton that can be tied to a Boolean control variable</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">radiobutton</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A labeled radio button that can be tied to a control variable</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">separator</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A system-appropriate visual separator, usually a black line</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">cascade</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A submenu, implemented as a second <code class="Code-In-Text--PACKT-">Menu</code> instance</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">To explore how the <code class="Code-In-Text--PACKT-">Menu</code> class works, let's start a simple example script, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># menu_demo.py
import tkinter as tk
root = tk.Tk()
root.geometry('200x150')
main_text = tk.StringVar(value='Hi')
label = tk.Label(root, textvariable=main_text)
label.pack(side='bottom')
</code></pre>
    <p class="normal">This application sets up a 200-by-150-pixel main window with a <code class="Code-In-Text--PACKT-">Label</code> widget, whose text is controlled by a string variable, <code class="Code-In-Text--PACKT-">main_text</code>. Now, let's start adding the menu components, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">main_menu = tk.Menu(root)
root.config(menu=main_menu)
</code></pre>
    <p class="normal">This creates a <code class="Code-In-Text--PACKT-">Menu</code> instance and then sets it as the main menu of our application by assigning it to the <code class="Code-In-Text--PACKT-">root</code> window's <code class="Code-In-Text--PACKT-">menu</code> argument.</p>
    <p class="normal">Currently, the menu is empty, so let's add an item; add this code to the script:</p>
    <pre class="programlisting code"><code class="hljs-code">main_menu.add('command', label='Quit', command=root.quit)
</code></pre>
    <p class="normal">Here, we've added a <code class="Code-In-Text--PACKT-">command</code> item to quit the application. The <code class="Code-In-Text--PACKT-">Menu.add()</code> method allows us<a id="_idIndexMarker565"/> to specify an item type and any number of keyword arguments to create a new menu item. In the case of a <code class="Code-In-Text--PACKT-">command</code> item, we need to at least have a <code class="Code-In-Text--PACKT-">label</code> argument specifying the text that will show in the menu and a <code class="Code-In-Text--PACKT-">command</code> argument pointing to a Python callback.</p>
    <div><p class="Information-Box--PACKT-">Some platforms, such as macOS, don't allow a command in the top-level menu. We'll cover the differences between menus on different platforms in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>. </p>
    </div>
    <p class="normal">Next, let's try creating a submenu, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">text_menu = tk.Menu(main_menu, tearoff=False)
</code></pre>
    <p class="normal">Creating a submenu is just like creating a menu, except that we specify the parent menu as the widget's parent. Notice the <code class="Code-In-Text--PACKT-">tearoff</code> argument; by default, submenus in Tkinter are <strong class="keyword">tearable</strong>, which means they<a id="_idIndexMarker566"/> can be pulled off and moved around as independent windows.</p>
    <p class="normal">You don't have to disable this option, but it is a rather archaic UI feature that is rarely used on modern platforms. Our users will likely just find it confusing, so we're going to disable it whenever we create submenus.</p>
    <p class="normal">Now that we have a submenu object, let's add some commands, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">text_menu.add_command(
  label='Set to "Hi"',
  command=lambda: main_text.set('Hi')
)
text_menu.add_command(
  label='Set to "There"',
  command=lambda: main_text.set('There')
)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">add_command()</code> method used here is simply a shortcut for <code class="Code-In-Text--PACKT-">add('command')</code>, and it can be used on any <code class="Code-In-Text--PACKT-">Menu</code> object. There are analogous methods for adding other items as well (<code class="Code-In-Text--PACKT-">add_cascade()</code>, <code class="Code-In-Text--PACKT-">add_separator()</code>, and so on).</p>
    <p class="normal">Now that we've populated the <code class="Code-In-Text--PACKT-">text_menu</code>, let's use the <code class="Code-In-Text--PACKT-">add_cascade()</code> method to add our menu back to its parent widget as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">main_menu.add_cascade(label="Text", menu=text_menu)
</code></pre>
    <p class="normal">When adding a submenu<a id="_idIndexMarker567"/> to its parent menu, we simply have to provide the label for the menu and the menu object itself.</p>
    <h3 id="_idParaDest-171" class="title">Using Checkbutton and Radiobutton items</h3>
    <p class="normal">In addition to commands and submenus, we can also add <code class="Code-In-Text--PACKT-">Checkbutton</code> and <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets<a id="_idIndexMarker568"/> to the menu. To demonstrate this, let's create another submenu<a id="_idIndexMarker569"/> with options to alter the label's appearance.</p>
    <p class="normal">First, we'll need to add the following setup code:</p>
    <pre class="programlisting code"><code class="hljs-code">font_bold = tk.BooleanVar(value=False)
font_size = tk.IntVar(value=10)
def set_font(*args):
  size = font_size.get()
  bold = 'bold' if font_bold.get() else ''
  font_spec = f'TkDefaultFont {size} {bold}'
  label.config(font=font_spec)
font_bold.trace_add('write', set_font)
font_size.trace_add('write', set_font)
set_font()
</code></pre>
    <p class="normal">To use <code class="Code-In-Text--PACKT-">checkbutton</code> and <code class="Code-In-Text--PACKT-">radiobutton</code> items in a menu, we need to first create control variables to bind to them. Here, we're just creating a Boolean variable for the bold font toggle, and an integer variable for the font size. Next, we've created a callback function that reads the variables<a id="_idIndexMarker570"/> and sets the <code class="Code-In-Text--PACKT-">Label</code> widget's <code class="Code-In-Text--PACKT-">font</code> property from them<a id="_idIndexMarker571"/> when called. Finally, we've set up a trace on both variables to call the callback whenever the values are changed, and called the callback to initialize the font settings.</p>
    <p class="normal">Now, we just need to create the menu options to change the variables; add this code next:</p>
    <pre class="programlisting code"><code class="hljs-code">appearance_menu = tk.Menu(main_menu, tearoff=False)
main_menu.add_cascade(label="Appearance", menu=appearance_menu)
appearance_menu.add_checkbutton(label="Bold", variable=font_bold)
</code></pre>
    <p class="normal">Here we've created the submenu for the appearance options and added the checkbutton for bold text. Like a regular <code class="Code-In-Text--PACKT-">Checkbutton</code> widget, the <code class="Code-In-Text--PACKT-">add_checkbutton()</code> method uses a <code class="Code-In-Text--PACKT-">variable</code> argument to assign its control variable. Unlike a regular <code class="Code-In-Text--PACKT-">Checkbutton</code> widget, though, it uses the <code class="Code-In-Text--PACKT-">label</code> argument, rather than the <code class="Code-In-Text--PACKT-">text</code> argument, to assign the label text.</p>
    <div><p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">checkbutton</code> item works with a <code class="Code-In-Text--PACKT-">BooleanVar</code> by default; however, just like a <code class="Code-In-Text--PACKT-">Checkbutton</code> widget, you can use it with different control variable types by passing in <code class="Code-In-Text--PACKT-">onvalue</code> and <code class="Code-In-Text--PACKT-">offvalue</code> arguments. </p>
    </div>
    <p class="normal">To demonstrate <code class="Code-In-Text--PACKT-">radiobutton</code> items, let's add a submenu to our Appearance submenu, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">size_menu = tk.Menu(appearance_menu, tearoff=False)
appearance_menu.add_cascade(label='Font size', menu=size_menu)
for size in range(8, 24, 2):
  size_menu.add_radiobutton(
    label="{} px".format(size),
    value=size, variable=font_size
  )
</code></pre>
    <p class="normal">Just as we added a submenu to our main menu, we can add submenus to submenus. In theory, you could nest submenus indefinitely, but most UI guidelines discourage more than two levels. </p>
    <p class="normal">To create the items for our size menu, we're just iterating a generated list of even numbers between 8 and 24; for each one, we call <code class="Code-In-Text--PACKT-">add_radiobutton()</code>, adding an item with a value equal to that size. Just as with regular <code class="Code-In-Text--PACKT-">Radiobutton</code> widgets, the control variable<a id="_idIndexMarker572"/> passed to the <code class="Code-In-Text--PACKT-">variable</code> argument will be updated with the value<a id="_idIndexMarker573"/> stored in the <code class="Code-In-Text--PACKT-">value</code> argument when the button is selected.</p>
    <p class="normal">Finally, let's add a call to <code class="Code-In-Text--PACKT-">mainloop()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">root.mainloop()
</code></pre>
    <p class="normal">Launch the application and try it out. You should get something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_10.png" alt="The Menu demo application"/></figure>
    <p class="packt_figref">Figure 7.10: The Menu demo application</p>
    <p class="normal">Now that we understand how to work with the <code class="Code-In-Text--PACKT-">Menu</code> widget, let's design and implement a menu for our application.</p>
    <h2 id="_idParaDest-172" class="title">Implementing the ABQ application menu</h2>
    <p class="normal">As a major component of the GUI, our main menu code would be right at home in the <code class="Code-In-Text--PACKT-">views.py</code> file. However, because it's going<a id="_idIndexMarker574"/> to be expanded considerably as our application grows, we'll put it in its own module file. Create a new file the <code class="Code-In-Text--PACKT-">abq_data_entry</code> directory called <code class="Code-In-Text--PACKT-">mainmenu.py</code>. Then begin the file with a docstring and our imports:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py
"""The Main Menu class for ABQ Data Entry"""
import tkinter as tk
from tkinter import messagebox
</code></pre>
    <p class="normal">Next, let's subclass <code class="Code-In-Text--PACKT-">tkinter.Menu</code> to create our own main menu class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">class MainMenu(tk.Menu):
  """The Application's main menu"""
  def __init__(self, parent, **kwargs):
    super().__init__(parent, **kwargs)
</code></pre>
    <p class="normal">We will be building the rest of the menu inside the initializer, though for the moment this doesn't do anything<a id="_idIndexMarker575"/> extra. Before we start building the menu, let's drop back into our <code class="Code-In-Text--PACKT-">application.py</code> module and set up this class as the application's main menu.</p>
    <p class="normal">First, import the class at the top of the file, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, at the top after the import statements
from .mainmenu import MainMenu
</code></pre>
    <p class="normal">Next, inside <code class="Code-In-Text--PACKT-">Application.__init__()</code>, we need to create an instance of our <code class="Code-In-Text--PACKT-">MainMenu</code> class and make it the application's menu. Update the method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.title("ABQ Data Entry Application")
    self.columnconfigure(0, weight=1)
    <strong class="hljs-slc">menu = MainMenu(self)</strong>
    <strong class="hljs-slc">self.config(menu=menu)</strong>
</code></pre>
    <p class="normal">Now let's head back to <code class="Code-In-Text--PACKT-">mainmenu.py</code> and start building the components of our menu.</p>
    <h3 id="_idParaDest-173" class="title">Adding a Help menu</h3>
    <p class="normal">Let's begin with something<a id="_idIndexMarker576"/> simple. We'll just add an About dialog to display<a id="_idIndexMarker577"/> some information about our program. This is typically located in a Help menu.</p>
    <p class="normal">Add the following code to <code class="Code-In-Text--PACKT-">MainMenu.__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside MainMenu.__init__()
    help_menu = tk.Menu(self, tearoff=False)
    help_menu.add_command(label='About…', command=self.show_about)
</code></pre>
    <p class="normal">Here, we've added a Help menu<a id="_idIndexMarker578"/> and a command for About. </p>
    <p class="normal">The command specifies<a id="_idIndexMarker579"/> an instance method, <code class="Code-In-Text--PACKT-">show_about()</code>, as its callback; so, we'll need to add that method to the class, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside the MainMenu class
  def show_about(self):
    """Show the about dialog"""
    about_message = 'ABQ Data Entry'
    about_detail = (
      'by Alan D Moore\n'
      'For assistance please contact the author.'
    )
    messagebox.showinfo(
      title='About', message=about_message, detail=about_detail
    )
</code></pre>
    <p class="normal">This method just specifies some basic information about the application and displays it in a <code class="Code-In-Text--PACKT-">messagebox</code> dialog. You can, of course, update the <code class="Code-In-Text--PACKT-">about_detail</code> variable with your own information, or a much longer (and hopefully more helpful) message.</p>
    <h3 id="_idParaDest-174" class="title">Adding a File menu</h3>
    <p class="normal">The next menu we'll create is a File menu. This will have two commands, one for selecting a file and another<a id="_idIndexMarker580"/> for quitting the application. Unlike the About dialog, though, we<a id="_idIndexMarker581"/> can't really implement the callback logic for either command in the menu class itself. File selection will need to call the <code class="Code-In-Text--PACKT-">Application._on_file_select()</code> method we created earlier in the chapter, and the quit command will need to call <code class="Code-In-Text--PACKT-">Application.quit()</code>.</p>
    <p class="normal">Since the menu's parent widget will be the <code class="Code-In-Text--PACKT-">Application</code> object, we could just bind these commands to <code class="Code-In-Text--PACKT-">parent._on_file_select</code> and <code class="Code-In-Text--PACKT-">parent.quit</code>, but that would create a tight coupling situation as we discussed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Planning for the Expansion of Our Application</em>. As we did in that chapter, we'll instead use generated events to communicate back to the controller class.</p>
    <p class="normal">One possible way to implement our File menu commands is to use a <code class="Code-In-Text--PACKT-">lambda</code> function, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    file_menu.add_command(
      label="Select file…",
      command=lambda: self.event_generate('&lt;&lt;FileSelect&gt;&gt;')
    )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">lambda</code> keyword creates<a id="_idIndexMarker582"/> an anonymous inline function that contains<a id="_idIndexMarker583"/> a single expression. It is often used in situations where we need a reference to a function (such as a widget's <code class="Code-In-Text--PACKT-">command</code> argument) but don't need the overhead of defining a named function. In this case, we're creating an anonymous function that generates a custom <code class="Code-In-Text--PACKT-">&lt;&lt;FileSelect&gt;&gt;</code> event on the <code class="Code-In-Text--PACKT-">MainMenu</code> object using <code class="Code-In-Text--PACKT-">event_generate()</code>.</p>
    <div><p class="Information-Box--PACKT-">You can find out more about Lambda expressions in <em class="italic">Section 6.14</em> of the Python official<a id="_idIndexMarker584"/> documentation, available at <a href="https://docs.python.org/3/reference/expressions.html">https://docs.python.org/3/reference/expressions.html</a>.</p>
    </div>
    <p class="normal">However, there are two problems with this approach.</p>
    <p class="normal">First, using <code class="Code-In-Text--PACKT-">lambda</code> every time is rather verbose and ugly, and since our menu is going to be generating a lot of custom events as the application grows, we'd like to avoid a lot of repetitive boilerplate code.</p>
    <p class="normal">Second, binding events on a <code class="Code-In-Text--PACKT-">Menu</code> object doesn't work on all platforms (particularly, it doesn't work on Microsoft Windows). This has to do with the fact that the <code class="Code-In-Text--PACKT-">Menu</code> is built around the native menu system of each platform. To work around this, we'll need to get a reference to our <code class="Code-In-Text--PACKT-">root</code> window and bind our events to that.</p>
    <p class="normal">Since this makes our code even uglier, it makes sense to create a simple wrapper function that will keep our menu definitions nice and clean.</p>
    <p class="normal">Add the following <code class="Code-In-Text--PACKT-">_event()</code> method to the <code class="Code-In-Text--PACKT-">MainMenu</code> class above the initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside MainMenu
  def _event(self, sequence):
    def callback(*_):
      root = self.master.winfo_toplevel()
      root.event_generate(sequence)
    return callback
</code></pre>
    <p class="normal">This simple method creates a function that causes the <code class="Code-In-Text--PACKT-">root</code> window instance to generate the provided <code class="Code-In-Text--PACKT-">sequence</code> string, then returns a reference to the newly defined function. To get a reference to the <code class="Code-In-Text--PACKT-">root</code> window, we call <code class="Code-In-Text--PACKT-">winfo_toplevel()</code> on the menu's parent widget (<code class="Code-In-Text--PACKT-">self.master</code>), which returns the top-level window of the menu's parent widget. You might wonder why we don't just use <code class="Code-In-Text--PACKT-">self.master</code>, or just call <code class="Code-In-Text--PACKT-">winfo_toplevel()</code> on the <code class="Code-In-Text--PACKT-">Menu</code> object itself. In the first case, we can't be sure what the menu's parent widget will be until we create an instance of it, especially as our program evolves in the future. While we can't be sure exactly what the parent widget will be, we can be sure it will be a widget<a id="_idIndexMarker585"/> on a window; by calling <code class="Code-In-Text--PACKT-">winfo_toplevel()</code> we should get the <code class="Code-In-Text--PACKT-">root</code> window.</p>
    <p class="normal">In the second case, the <code class="Code-In-Text--PACKT-">winfo_toplevel()</code> method, when called on a <code class="Code-In-Text--PACKT-">Menu</code> object, actually returns the top level of the <em class="italic">menu</em>. In other words, <code class="Code-In-Text--PACKT-">self.winfo_toplevel()</code> in this context would just return our <code class="Code-In-Text--PACKT-">MainMenu</code> object.</p>
    <p class="normal">Now we can update our menu items to use this wrapper method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside MainMenu.__init__()
    file_menu = tk.Menu(self, tearoff=False)
    file_menu.add_command(
      label="Select file…",
      command=self._event('&lt;&lt;FileSelect&gt;&gt;')
    )
    file_menu.add_separator()
    file_menu.add_command(
      label="Quit",
      command=self._event('&lt;&lt;FileQuit&gt;&gt;')
    )
</code></pre>
    <div><p class="Tip--PACKT-">Note the use of the ellipsis character (<code class="Code-In-Text--PACKT-">…</code>) after <code class="Code-In-Text--PACKT-">"Select file"</code>. This is a convention in menus to indicate when a command will open another window or dialog to get information from the user rather than just running a command directly.</p>
    </div>
    <p class="normal">Now our code looks much cleaner. To make these commands work, we'll need to tell our <code class="Code-In-Text--PACKT-">Application</code> class to listen for these events and take appropriate action when they're generated.</p>
    <p class="normal">Back in the <code class="Code-In-Text--PACKT-">application.py</code> file, let's add the following lines to <code class="Code-In-Text--PACKT-">Application.__init__()</code>, just after the menu object setup:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    event_callbacks = {
      '&lt;&lt;FileSelect&gt;&gt;': self._on_file_select,
      '&lt;&lt;FileQuit&gt;&gt;': lambda _: self.quit(),
    }
    for sequence, callback in event_callbacks.items():
      self.bind(sequence, callback)
</code></pre>
    <p class="normal">Here, we've created an <code class="Code-In-Text--PACKT-">event_callbacks</code> dictionary, matching event sequences to callback methods. Then, we're iterating through the dictionary, binding each sequence to its event. </p>
    <p class="normal">As we add more<a id="_idIndexMarker586"/> items to our menu, we'll just need to update the dictionary with the additional bindings. Note that we cannot bind the <code class="Code-In-Text--PACKT-">&lt;&lt;FileQuit&gt;&gt;</code> action directly to <code class="Code-In-Text--PACKT-">self.quit()</code>. That's because callbacks bound using the <code class="Code-In-Text--PACKT-">bind()</code> method pass arguments when the callback is called, and <code class="Code-In-Text--PACKT-">self.quit()</code> takes no arguments. We're using a <code class="Code-In-Text--PACKT-">lambda</code> call here just to filter out the added argument from the callback.</p>
    <h3 id="_idParaDest-175" class="title">Adding a settings menu</h3>
    <p class="normal">The next thing we need to add is our Options menu, which will allow the user to specify whether they want the Date and Sheet data auto-filled in the form or not. We've already seen that adding<a id="_idIndexMarker587"/> checkbutton options to a menu<a id="_idIndexMarker588"/> is fairly easy, but actually making these options work is going to take some additional plumbing work. Somehow, we need to connect these menu options to the <code class="Code-In-Text--PACKT-">DataRecordForm</code> instance so that it can disable the automation appropriately.</p>
    <p class="normal">To do this, let's begin by creating a dictionary in the <code class="Code-In-Text--PACKT-">Application</code> class that will store some control variables:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
# before the menu setup
  self.settings = {
    'autofill date': tk.BooleanVar(),
    'autofill sheet data': tk.BooleanVar()
  }
</code></pre>
    <p class="normal">Next, we will need to make sure both our <code class="Code-In-Text--PACKT-">DataRecordForm</code> and <code class="Code-In-Text--PACKT-">MainMenu</code> objects have access to these settings; we will do this by passing the <code class="Code-In-Text--PACKT-">settings</code> dictionary to their initializer methods and storing it as an instance variable on each class.</p>
    <p class="normal">First, in <code class="Code-In-Text--PACKT-">views.py</code>, let's update the <code class="Code-In-Text--PACKT-">DataRecordForm.__init__()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside DataRecordForm class
  def __init__(self, parent, model, <strong class="hljs-slc">settings</strong>, *args, **kwargs):
    super().__init__(parent, *args, **kwargs)
    self.model = model
    <strong class="hljs-slc">self.settings = settings</strong>
</code></pre>
    <p class="normal">Next, in <code class="Code-In-Text--PACKT-">mainmenu.py</code>, let's update the <code class="Code-In-Text--PACKT-">MainMenu.__init__()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside MainMenu class
  def __init__(self, parent, <strong class="hljs-slc">settings</strong>, **kwargs):
    super().__init__(parent, **kwargs)
    <strong class="hljs-slc">self.settings = settings</strong>
</code></pre>
    <p class="normal">Now, back in the <code class="Code-In-Text--PACKT-">Application</code> class, we have to update the code that creates instances of these classes to pass<a id="_idIndexMarker589"/> in the <code class="Code-In-Text--PACKT-">settings</code> dictionary to each one. Update<a id="_idIndexMarker590"/> the code in <code class="Code-In-Text--PACKT-">Application.__init__()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application.__init__()
  # update the menu creation line:
  menu = MainMenu(self, <strong class="hljs-slc">self.settings</strong>)
  #...
  # update the data record form creation line:
  self.recordform = v.DataRecordForm(
    self,
    self.model,
    <strong class="hljs-slc">self.settings</strong>
  )
</code></pre>
    <p class="normal">Each class now has access to the <code class="Code-In-Text--PACKT-">settings</code> dictionary, so let's put it to use. To begin with, let's add our Options menu to the main menu.</p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">MainMenu</code> file, add this code to the initializer method to build the menu:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, in MainMenu.__init__()
    options_menu = tk.Menu(self, tearoff=False)
    options_menu.add_checkbutton(
      label='Autofill Date',
      variable=self.settings['autofill date']
    )
    options_menu.add_checkbutton(
      label='Autofill Sheet data',
      variable=self.settings['autofill sheet data']
    )
</code></pre>
    <p class="normal">Very simply, we've created a <code class="Code-In-Text--PACKT-">Menu</code> widget called <code class="Code-In-Text--PACKT-">options_menu</code> with two <code class="Code-In-Text--PACKT-">checkbutton</code> items that are bound to our settings variable. That's all the configuration our <code class="Code-In-Text--PACKT-">MainMenu</code> needs for the settings.</p>
    <p class="normal">The last thing we need<a id="_idIndexMarker591"/> to do is make these settings work<a id="_idIndexMarker592"/> with the <code class="Code-In-Text--PACKT-">DataRecordForm</code> class's <code class="Code-In-Text--PACKT-">reset()</code> method, which handles the auto-filling of these fields.</p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">views.py</code> file, locate the <code class="Code-In-Text--PACKT-">DataRecordForm.reset()</code> method, and find the code that sets the date variable. Update it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.reset()
    <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> self.settings[</strong><strong class="hljs-string-slc">'autofill date'</strong><strong class="hljs-slc">].get():</strong>
      current_date = datetime.today().strftime('%Y-%m-%d')
      self._vars['Date'].set(current_date)
      self._vars['Time'].label_widget.input.focus()
</code></pre>
    <p class="normal">All we've done here is put this date-setting logic below an <code class="Code-In-Text--PACKT-">if</code> statement that checks the <code class="Code-In-Text--PACKT-">settings</code> value. We need to do the same for our sheet data section, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (
      <strong class="hljs-slc">self.settings[</strong><strong class="hljs-string-slc">'autofill sheet data'</strong><strong class="hljs-slc">].get() </strong><strong class="hljs-keyword-slc">and</strong>
      plot not in ('', 0, plot_values[-1])
    ):
      self._vars['Lab'].set(lab)
      self._vars['Time'].set(time)
      # etc...
</code></pre>
    <p class="normal">Since this logic was already<a id="_idIndexMarker593"/> under an <code class="Code-In-Text--PACKT-">if</code> statement, we've just added another condition to the check. This<a id="_idIndexMarker594"/> should now give us functioning options.</p>
    <h3 id="_idParaDest-176" class="title">Finishing the menu</h3>
    <p class="normal">The last thing we need to do in our main menu is add the submenus we've created to the main menu. At the end of <code class="Code-In-Text--PACKT-">MainMenu.__init__()</code>, add the following lines:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, at the end of MainMenu.__init__()
    self.add_cascade(label='File', menu=file_menu)
    self.add_cascade(label='Options', menu=options_menu)
    self.add_cascade(label='Help', menu=help_menu)
</code></pre>
    <p class="normal">The submenus will be arranged from left to right in the order we add them. Typically the File menu is first and the Help menu is last, with the other menus arranged in between. We'll learn more about how to arrange menus with respect to platform in <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>.</p>
    <p class="normal">Run the application, and you should<a id="_idIndexMarker595"/> see a nice main menu like this:</p>
    <figure class="mediaobject"><img src="img/B17578_07_11.png" alt="The ABQ application sporting a fancy main menu"/></figure>
    <p class="packt_figref">Figure 7.11: The ABQ application sporting a fancy main menu</p>
    <p class="normal">Give the settings a try by un-checking them and entering some records. They should disable the auto-fill functionality when disabled.</p>
    <h2 id="_idParaDest-177" class="title">Persisting settings</h2>
    <p class="normal">Our settings work, but there's a major annoyance: they don't persist between sessions. Shut down the application<a id="_idIndexMarker596"/> and start it up again, and you'll see that the settings are back to their defaults. It's not a major problem, but it's a rough edge we shouldn't leave for our users. Ideally, their personal settings should load up each time they launch the application.</p>
    <p class="normal">Python gives us a variety of ways to persist data in files. We've already experienced CSV, which is designed for tabular<a id="_idIndexMarker597"/> data; there are other formats designed with different capabilities in mind. The following table shows just<a id="_idIndexMarker598"/> a few of the options for storing data available in the Python standard library:</p>
    <table id="table004-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Module</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">File type</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Suitable for</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Benefits</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Drawbacks</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">pickle</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Binary</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Any Python object</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Fast, easy, small files</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Not safe, files not human-readable, whole file must be read</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">configparser</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Text</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Key -&gt; value pairs</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Human-readable files</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Can't handle sequences or complex objects, limited hierarchy</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">json</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Text</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Simple values and sequences</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Widely used, easy, human-readable</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Can't handle dates, complex objects without modification</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">xml</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Text</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Any kind of Python object</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Powerful, flexible, human-readable files</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Not safe, complex to use, verbose syntax</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">sqlite</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Binary</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Relational data</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Fast, powerful, can represent complex relationships</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Requires SQL knowledge, objects must be translated to tables</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 7.3:</p>
    <p class="normal">If this weren't enough, there are even more options available in the third-party libraries. Almost any of them would be suitable for storing a couple of Boolean values, so how do we choose? Let's consider the options:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">SQL</code> and <code class="Code-In-Text--PACKT-">XML</code> are powerful, but far too complex for our simple needs here.</li>
      <li class="bullet">We'd like to stick to a text format in case we need to debug a corrupt settings file, so <code class="Code-In-Text--PACKT-">pickle</code> is out.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">configparser</code> would work for now, but its inability to handle lists, tuples, and dictionaries may be limiting in the future.</li>
    </ul>
    <p class="normal">That leaves <code class="Code-In-Text--PACKT-">json</code>, which is a good option. While it can't handle every kind of Python object, it can handle strings, numbers, and Boolean values, as well as lists and dictionaries. It can even be extended to handle other kinds of data. It should cover our current configuration needs<a id="_idIndexMarker599"/> just fine, and most likely our future needs as well.</p>
    <div><p class="Information-Box--PACKT-">What does it mean when we say that a library is "not safe"? Some data formats are designed with powerful capabilities, such as extensibility, linking, or aliasing, which parser libraries must implement. Unfortunately, those capabilities can be exploited for malicious purposes. For example, the "billion laughs" XML vulnerability combines three XML capabilities to craft a file that, when parsed, expands to a massive size (usually causing the program or, in some cases, the operating system, to crash).</p>
    </div>
    <h3 id="_idParaDest-178" class="title">Building a model for settings persistence</h3>
    <p class="normal">As with any kind of data persistence, we need to start by implementing a model. As with our <code class="Code-In-Text--PACKT-">CSVModel</code> class, the settings<a id="_idIndexMarker600"/> model needs to save and load the data, as well as authoritatively defining the layout of the settings data. Since we're using <code class="Code-In-Text--PACKT-">json</code>, we need to import it. Add this to the top of <code class="Code-In-Text--PACKT-">models.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import json
</code></pre>
    <p class="normal">Now, down at the end of <code class="Code-In-Text--PACKT-">models.py</code>, let's start a new <code class="Code-In-Text--PACKT-">SettingsModel</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, at the bottom
class SettingsModel:
  """A model for saving settings"""
  fields = {
    'autofill date': {'type': 'bool', 'value': True},
    'autofill sheet data': {'type': 'bool', 'value': True}
  }
</code></pre>
    <p class="normal">As we did with the <code class="Code-In-Text--PACKT-">CSVModel</code>, we've begun our class with a class variable that defines the <code class="Code-In-Text--PACKT-">fields</code> included in the settings file. Currently, it only contains our two Boolean values. Each field in the dictionary defines a data type and default value for the field. Note that we're using strings here rather than Python <code class="Code-In-Text--PACKT-">type</code> objects; doing this will allow us to persist both the type and the value to a text file.</p>
    <p class="normal">Next, let's create the initializer method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in SettingsModel
  def __init__(self):
    filename = 'abq_settings.json'
    self.filepath = Path.home() / filename
</code></pre>
    <p class="normal">The initializer will determine the file path to which our settings will be saved; for now, we've hard-coded the name <code class="Code-In-Text--PACKT-">abq_settings.json</code> and stored it in the user's home directory. <code class="Code-In-Text--PACKT-">Path.home()</code> is a class method of the <code class="Code-In-Text--PACKT-">Path</code> class that provides us with a <code class="Code-In-Text--PACKT-">Path</code> object pointed<a id="_idIndexMarker601"/> to the user's home directory. In this way, each user on the system can have their own settings file.</p>
    <p class="normal">As soon as the model is created, we'll want to load the user's saved options from disk, so let's add a call to an instance method we'll call <code class="Code-In-Text--PACKT-">load()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, at the end of SettingsModel.__init__()
    self.load()
</code></pre>
    <p class="normal">Now we need to implement the <code class="Code-In-Text--PACKT-">load()</code> method. A simplistic implementation may look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def load(self):
    with open(self.filepath, 'r') as fh:
      self.fields = json.load(fh)
</code></pre>
    <p class="normal">This simply opens the file stored in our <code class="Code-In-Text--PACKT-">self.filepath</code> location and overwrites the <code class="Code-In-Text--PACKT-">fields</code> variable with whatever contents are extracted by <code class="Code-In-Text--PACKT-">json.load()</code>. This is the gist of what we need to do, but there are two problems with this approach:</p>
    <ul>
      <li class="bullet">What happens if the file doesn't exist? (For example, if the user has never run the program before.)</li>
      <li class="bullet">What happens if the JSON data in the model doesn't match with the keys expected by our application? (For example, if it was tampered with, or created by an older version of the application.)</li>
    </ul>
    <p class="normal">Let's create a more robust callback that addresses these issues, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside the SettingsModel class
  def load(self):
    if not self.filepath.exists():
      return
    with open(self.filepath, 'r') as fh:
      raw_values = json.load(fh)
    for key in self.fields:
      if key in raw_values and 'value' in raw_values[key]:
        raw_value = raw_values[key]['value']
        self.fields[key]['value'] = raw_value
</code></pre>
    <p class="normal">In this version, we address the first issue by checking to see if the file exists. If the file doesn't exist, the method simply returns and does nothing. It's perfectly reasonable for the file not to exist, especially<a id="_idIndexMarker602"/> if the user has never run the program or edited any of the settings. In this case, the method would leave <code class="Code-In-Text--PACKT-">self.fields</code> alone and the user would end up with the defaults.</p>
    <p class="normal">To address the second problem, we've pulled the JSON data into a local variable called <code class="Code-In-Text--PACKT-">raw_values</code>; then, we update <code class="Code-In-Text--PACKT-">fields</code> by retrieving from <code class="Code-In-Text--PACKT-">raw_values</code> only those keys that are defined by our class. If the JSON data lacks a particular key, we skip it, leaving <code class="Code-In-Text--PACKT-">fields</code> with its default value.</p>
    <p class="normal">In addition to loading settings, our model will of course need to save its data. Let's write a <code class="Code-In-Text--PACKT-">save()</code> method to write our values to the file:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside the SettingsModel class
  def save(self):
    with open(self.filepath, 'w') as fh:
      json.dump(self.fields, fh)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">json.dump()</code> function is the inverse of <code class="Code-In-Text--PACKT-">json.load()</code>: it takes a Python object and a file handle, converts the object to a JSON string, and writes it to the file. Saving our settings data is as simple as converting the <code class="Code-In-Text--PACKT-">fields</code> dictionary to a JSON string and writing it to the specified text file.</p>
    <p class="normal">The final method our model needs is a way for external code to set values; we could just allow external code to manipulate the <code class="Code-In-Text--PACKT-">fields</code> dictionary directly, but in the interest of protecting our data integrity, we'll do it through a method call. </p>
    <p class="normal">Keeping with Tkinter convention, we'll call this method <code class="Code-In-Text--PACKT-">set()</code>.</p>
    <p class="normal">A basic implementation of the <code class="Code-In-Text--PACKT-">set()</code> method is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def set(self, key, value):
  self.fields[key]['value'] = value
</code></pre>
    <p class="normal">This simple method just takes <code class="Code-In-Text--PACKT-">key</code> and <code class="Code-In-Text--PACKT-">value</code> arguments and writes them to the <code class="Code-In-Text--PACKT-">fields</code> dictionary. This opens up some potential problems, though:</p>
    <ul>
      <li class="bullet">What if the value provided isn't valid for the data type?</li>
      <li class="bullet">What if the key isn't in our <code class="Code-In-Text--PACKT-">fields</code> dictionary? Should we allow outside code to just add new keys?</li>
    </ul>
    <p class="normal">These situations could<a id="_idIndexMarker603"/> create problems in the application that would be hard to debug, so our <code class="Code-In-Text--PACKT-">set()</code> method should safeguard against these scenarios.</p>
    <p class="normal">Let's create a more robust version, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside the SettingsModel class
  def set(self, key, value):
    if (
      key in self.fields and
      type(value).__name__ == self.fields[key]['type']
    ):
      self.fields[key]['value'] = value
    else:
      raise ValueError("Bad key or wrong variable type")
</code></pre>
    <p class="normal">In this version, we check if the given <code class="Code-In-Text--PACKT-">key</code> argument exists in <code class="Code-In-Text--PACKT-">fields</code>, and if the <code class="Code-In-Text--PACKT-">type</code> of the data matches the type defined for that field. To match the <code class="Code-In-Text--PACKT-">value</code> variable's object type to the <code class="Code-In-Text--PACKT-">field</code> dictionary's <code class="Code-In-Text--PACKT-">type</code> strings, we have extracted the variable's data type as a string using <code class="Code-In-Text--PACKT-">type(value).__name__</code>. This returns a string like <code class="Code-In-Text--PACKT-">bool</code> for Boolean variables, or <code class="Code-In-Text--PACKT-">str</code> for strings. With these checks protecting our value assignment, an attempt to write an unknown key or incorrect variable type will fail.</p>
    <p class="normal">However, we don't let it fail silently; if there is bad data, we immediately raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception. Why raise an exception? If the test fails, it can only mean a bug in the calling code. With an exception, we'll know immediately if the calling code is sending bad requests to our model. Without it, requests would fail silently, leaving a hard-to-find bug.</p>
    <h3 id="_idParaDest-179" class="title">Using the settings model in our application</h3>
    <p class="normal">Our application needs to load in the settings when it starts, then save them automatically whenever<a id="_idIndexMarker604"/> they are changed. Currently, the application's <code class="Code-In-Text--PACKT-">settings</code> dictionary is created manually, but our model, as the authority on the settings data structure, should really be telling it what kind of variables to create.</p>
    <p class="normal">Back in the <code class="Code-In-Text--PACKT-">Application.__init__()</code> method, locate the line that creates our <code class="Code-In-Text--PACKT-">settings</code> dictionary, and replace it with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.settings_model = m.SettingsModel()
    self._load_settings()
</code></pre>
    <p class="normal">First, we've created a <code class="Code-In-Text--PACKT-">SettingsModel</code> instance, storing it as an instance variable. Then, we're running an<a id="_idIndexMarker605"/> instance method called <code class="Code-In-Text--PACKT-">_load_settings()</code>. This method will be responsible for querying the <code class="Code-In-Text--PACKT-">settings_model</code> to create the <code class="Code-In-Text--PACKT-">Application.settings</code> dictionary.</p>
    <p class="normal">At the end of the class definition, let's create the <code class="Code-In-Text--PACKT-">_load_settings()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside the Application class
  def _load_settings(self):
    """Load settings into our self.settings dict."""
    vartypes = {
      'bool': tk.BooleanVar,
      'str': tk.StringVar,
      'int': tk.IntVar,
      'float': tk.DoubleVar
    }
    self.settings = dict()
    for key, data in self.settings_model.fields.items():
      vartype = vartypes.get(data['type'], tk.StringVar)
      self.settings[key] = vartype(value=data['value'])
</code></pre>
    <p class="normal">Our model stores the type and value for each variable, but our application needs Tkinter control variables. We need to translate the model's representation of the data into a structure that <code class="Code-In-Text--PACKT-">Application</code> can use. So the first thing this function does is create a <code class="Code-In-Text--PACKT-">vartypes</code> dictionary to translate our <code class="Code-In-Text--PACKT-">type</code> strings to control variable types. </p>
    <p class="normal">Although we currently only have Boolean variables in our settings, we're going to anticipate more settings in the future and create a function capable of handling strings, floats, and integers as well.</p>
    <p class="normal">After defining the <code class="Code-In-Text--PACKT-">vartypes</code> dictionary and creating an empty dictionary for <code class="Code-In-Text--PACKT-">settings</code>, we just need to iterate through <code class="Code-In-Text--PACKT-">self.settings_model.fields</code>, creating a matching control variable for each field. Note that <code class="Code-In-Text--PACKT-">vartypes.get(data['type'], tk.StringVar)</code> ensures that, if we get a variable type not listed in <code class="Code-In-Text--PACKT-">vartypes</code>, we'll just create a <code class="Code-In-Text--PACKT-">StringVar</code> for it.</p>
    <p class="normal">The main reason for using Tkinter variables here is so that we can trace any changes the user makes to the values<a id="_idIndexMarker606"/> via the UI and respond immediately. Specifically, we want to save our settings whenever the user makes a change. To implement this, add the last two lines to the method:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application._load_settings()
    for var in self.settings.values():
      var.trace_add('write', self._save_settings)
</code></pre>
    <p class="normal">This adds a trace that calls <code class="Code-In-Text--PACKT-">_save_settings</code> whenever a settings variable is changed. Of course, this means we need to write a method called <code class="Code-In-Text--PACKT-">Application._save_settings()</code>, which will save the settings to disk.</p>
    <p class="normal">Add this code to the end of <code class="Code-In-Text--PACKT-">Application</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _save_settings(self, *_):
    for key, variable in self.settings.items():
      self.settings_model.set(key, variable.get())
    self.settings_model.save()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">save_settings()</code> method just needs to get the data back from <code class="Code-In-Text--PACKT-">Application.settings</code> to the model and then save it. It's as simple as iterating through <code class="Code-In-Text--PACKT-">self.settings</code> and calling our model's <code class="Code-In-Text--PACKT-">set()</code> method to pull in the values one at a time. Once we've updated the values, we call the model's <code class="Code-In-Text--PACKT-">save()</code> method.</p>
    <p class="normal">This completes our settings persistence; you should be able to run the program and observe that the settings are saved, even when you close and re-open the application. You'll also find a file in your home directory called <code class="Code-In-Text--PACKT-">abq_settings.json</code> (this isn't the ideal place to keep a settings file, but we'll address that in <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>).</p>
    <h1 id="_idParaDest-180" class="title">Summary</h1>
    <p class="normal">In this chapter, our simple form has taken a big step forward toward being a full-blown application. We've implemented a main menu, option settings that are persisted between executions, and an About dialog. We've added the ability to select a file where records are saved, and improved the visibility of form errors with an error dialog. Along the way, you learned about Tkinter menus, file dialogs, message boxes, and custom dialogs, as well as the various options for persisting data in the standard library.</p>
    <p class="normal">In the next chapter, we're going to be asked to make the program read data as well as write it. We'll learn about Ttk's <code class="Code-In-Text--PACKT-">Treeview</code> and <code class="Code-In-Text--PACKT-">Notebook</code> widgets, and how to make our <code class="Code-In-Text--PACKT-">CSVModel</code> and <code class="Code-In-Text--PACKT-">DataRecordForm</code> classes capable of reading and updating existing data.</p>
  </div>
</body></html>