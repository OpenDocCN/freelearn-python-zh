<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-67"><a id="_idTextAnchor067"/>3</h1>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Accessing the Network</h1>
<p>In the previous chapter, we looked into programmable networks and their history. One of the ideas we explored <a id="_idIndexMarker331"/>was <strong class="bold">Software-Defined Networking</strong> (<strong class="bold">SDN</strong>), where we saw why the separation between the data plane and the control plane was important. One important point of SDN was its architecture and how it separates<a id="_idIndexMarker332"/> the <strong class="bold">North Bound Interface</strong> (<strong class="bold">NBI</strong>) and <strong class="bold">South Bound Interface</strong> (<strong class="bold">SBI</strong>). In this chapter, we are going to explore how to access the <a id="_idIndexMarker333"/>network devices that can be interpreted as the SBI for SDN when OpenFlow is not available on the device.</p>
<p>As we have seen before, OpenFlow is not a widely adopted protocol, and its availability is limited to a few manufacturers and devices. Therefore, if you are planning to use SDN, you may need to use the available native methods to configure the devices.</p>
<p>Network access is not only used for SDN but also for a variety of software, such as network configuration, configuration audit, upgrade tools, and automation, among others. Additionally, devices usually have multiple methods or protocols, some of which may be better than others.</p>
<p>In this chapter, we will explore the most common methods and protocols for accessing network devices for our network automation. Since devices have multiple methods, we will aim to give you enough information so that you can choose the one that is most appropriate for your network automation code.</p>
<p>We are going to explore the following topics:</p>
<ul>
<li>Working with the CLI</li>
<li>Using SNMP</li>
<li>Employing NETCONF</li>
<li>Adopting gRPC</li>
<li>Operating with gNMI</li>
</ul>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Working with the CLI</h1>
<p>The<strong class="bold"> Command-Line Interface</strong> (<strong class="bold">CLI</strong>) is <a id="_idIndexMarker334"/>perhaps the most widely available method for accessing a network device. It is a term imported from computers, which was a<a id="_idIndexMarker335"/> replacement for <strong class="bold">teletypewriter</strong> (<strong class="bold">TTY</strong>) machines. A CLI is normally implemented by using a program that runs inside the device to interpret the keys being typed. Early implementations of the CLI program monitored the device’s serial port, where a terminal with a keyboard was connected to communicate.</p>
<p>In UNIX, the CLI program was called a shell, and the<a id="_idIndexMarker336"/> first shell, called the <strong class="bold">V6 shell</strong>, was created in 1971 by Ken Thompson<a id="_idIndexMarker337"/> at Bell Labs. The <strong class="bold">Bourne shell</strong> was introduced in 1977 as a replacement for the V6 shell. Although the UNIX shell is used as an interactive command interpreter, it was also intended to be a scripting language and contains most of the features that are commonly considered to produce structured programs.</p>
<p>Network devices use a simplified version of a shell for their CLIs. Let’s explore a bit more what CLI access can offer.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>The command prompt</h2>
<p>When using the CLI in our network automation work, the command prompt is the most important piece in our code to be interpreted. We will see that the device uses the command prompt to indicate when it is ready to receive a new command.</p>
<p>A <code>$</code>, <code>%</code>, <code>#</code>, <code>:</code>, <code>&gt;</code>, or <code>-</code>. It also can include additional information, such as the current time, working directory, username, or hostname. On many network devices, the prompt normally ends with <code>$</code> or <code>%</code>, and for the privileged CLI access mode, it normally ends with <code>#</code>, which is similar to the UNIX superuser, <code>root</code>.</p>
<p>Most of the <a id="_idIndexMarker339"/>prompts can be modified by the user – however, the most common information presented in the prompts of network devices is the hostname and sometimes, the username used for login.</p>
<p>The example in <em class="italic">Figure 3.1</em> shows an <code>core-router</code> and the <code>&gt;</code> character at the end, meaning it is waiting for the commands to be placed where the cursor is:</p>
<div><div><img alt="Figure 3.1 – A FRR router command prompt example" src="img/B18165_03_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – A FRR router command prompt example</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Serial access</h2>
<p>A network device normally <a id="_idIndexMarker341"/>has a special port <a id="_idIndexMarker342"/>called a <em class="italic">console</em> or <em class="italic">serial console</em>. This <a id="_idIndexMarker343"/>port is normally configured to operate at a slow speed, and the common configuration sets the baud rate to 9,600, with some devices able to accept up to 115,200 bits per second. The serial port<a id="_idIndexMarker344"/> is normally<a id="_idIndexMarker345"/> a <strong class="bold">DB9</strong> connector or an <strong class="bold">RJ45</strong>, with <strong class="bold">RS232</strong> technical specifications. <em class="italic">Figure 3.2</em> shows an example of the pins used for DB9 and RJ45 serial console connectors. </p>
<p>The program that handles the serial port is normally independent of the device’s operating system, allowing this type of port to be used in catastrophic scenarios:</p>
<div><div><img alt="Figure 3.2 – An example of a device’s serial port pin configuration " src="img/B18165_03_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – An example of a device’s serial port pin configuration </p>
<p>It’s important to note that the serial port<a id="_idIndexMarker346"/> is used in the following cases:</p>
<ul>
<li>Extreme cases when the network device is unresponsible</li>
<li>For local maintenance in the presence of a technician</li>
<li>Critical upgrades with the risk of crashes or operation system deletion</li>
<li>Operation system<a id="_idIndexMarker347"/> or hardware failure</li>
</ul>
<p>The network automation should avoid using the serial port to configure the device because no parallelism exists (only one port) and its speed is limited.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Remote insecure access</h2>
<p>For the reasons explained<a id="_idIndexMarker348"/> previously, the serial port is slow and can’t be used in parallel. Therefore, the best way to access the network device is via remote access, which can be done via <strong class="bold">Out-Of-Band</strong> (<strong class="bold">OOB</strong>) or <a id="_idIndexMarker349"/>in-band management (described in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">.</em></p>
<p>How to determine whether the access is secure or not will depend on the protocol used and what kind of network is used to transport this remote access. If access is via an OOB network, it is normally secured and has separated and isolated infrastructure, but if it is in-band, some extra care needs to be taken to avoid some common security breaches.</p>
<h3>Insecure applications and protocols</h3>
<p>The following applications are normally not encrypted and are easy to eavesdrop on, proxy, or hijack.</p>
<h4>Telnet</h4>
<p>Telnet<a id="_idIndexMarker350"/> is an application that uses TCP port <code>23</code> to access a remote device. The data is not encrypted and there is no authentication on the connection. TCP hijacking and eavesdropping are the most common security problems when using Telnet. To make sure these threats are not present, the network path carrying the access must be secured or isolated.</p>
<p>Telnet normally requires a password and sometimes a username as well.</p>
<h4>RSH</h4>
<p><code>514</code> and does not provide encryption or a password. As IP addresses are used to authenticate access, this protocol is extremely insecure and susceptible to IP spoofing attacks. </p>
<p>If it were not for its lack of security, RSH would be a fast and easy option for running commands and creating network automation.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Remote secure access</h2>
<p>To make sure <a id="_idIndexMarker352"/>remote access is secure, the data has to be encrypted and the hosts need to have some sort of identity-based authentication to make sure whoever is connecting is allowed to connect.</p>
<p>The most used application for remote<a id="_idIndexMarker353"/> CLI access is <code>22</code> as the default.</p>
<h3>Identity-based authentication</h3>
<p>The identity-based authentication <a id="_idIndexMarker354"/>on SSH is based on a key fingerprint using SHA-256 (an encryption algorithm). When SSH is used for the first time, SSH asks you to confirm the fingerprint key to make sure the host you are connecting to is the correct one. An example of this fingerprint is shown in <em class="italic">Figure 3.3</em>:</p>
<div><div><img alt="Figure 3.3 – An example of an SSH fingerprint acceptance request " src="img/B18165_03_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – An example of an SSH fingerprint acceptance request </p>
<p>Although<a id="_idIndexMarker355"/> SSH is considered a secure application protocol for accessing devices, the identity-based key fingerprint needs to be managed properly to avoid the most common attack, called <em class="italic">man-in-the-middle</em>. This<a id="_idIndexMarker356"/> attack redirects the traffic to another device, pretends it is the end device, and uses this procedure to capture the password of the final target network device, as shown in <em class="italic">Figure 3.4</em>:</p>
<div><div><img alt="Figure 3.4 – An example of a man-in-the-middle attack on a network device" src="img/B18165_03_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – An example of a man-in-the-middle attack on a network device</p>
<p>There are several ways to avoid a man-in-the-middle attack: one is to make sure the network device has an ACL (discussed in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>) that filters incoming IPs that are not part of the management. Another is to make sure identity key management is shared with the agent who is requesting remote access.</p>
<p>Why is this important? Because network automation needs to make sure it uses a secure channel to modify the network and the key management is a shared responsibility between the network operators and the network automation teams.</p>
<p>Here are some<a id="_idIndexMarker357"/> pros and cons of using a CLI for network automation:</p>
<p><strong class="bold">Pros</strong>:</p>
<ul>
<li>Available on almost all network devices</li>
<li>Able to access the whole network device’s operating system</li>
<li>Critical and privileged access</li>
<li>Remote or local access via serial access without a network</li>
</ul>
<p><strong class="bold">Cons</strong>:</p>
<ul>
<li>Slow</li>
<li>Limited <a id="_idIndexMarker358"/>parallel access</li>
<li>When not correctly used, may allow hackers to interfere</li>
<li>Interactive, requiring prompt</li>
<li>Data information is not structured (such as JSON or XML), which makes it prone to interpretation errors</li>
</ul>
<p>To wrap up this section, we’ve covered the usage of the CLI, which is the oldest interface known for gathering information from network devices. We also learned that a CLI is the only way to collect or configure the device for some network devices. One of the important points is that CLI is always present on the network device. In the next section, we will see how we can improve the interface of the network device for gathering network information, called SNMP. </p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Using SNMP</h1>
<p><strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>) is perhaps the oldest and most used protocol to gather <a id="_idIndexMarker359"/>management information from devices. The SNMP specification was first published in 1998 in RFC 2261 and was designed to be simple and fast.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>SNMP agents and managers</h2>
<p>SNMP defines two identities:</p>
<ul>
<li>The manager (or server)</li>
<li>The agent</li>
</ul>
<p>The <a id="_idIndexMarker360"/>agent is normally a network device and the<a id="_idIndexMarker361"/> manager is a network management system.</p>
<p>SNMP uses UDP and TCP<a id="_idIndexMarker362"/> as transport protocols with ports <code>161</code> and <code>162</code>. The UDP port <code>161</code> is used to gather or set information in an on-demand manner, where the manager sends the request to the agent. The UDP port <code>162</code> is used asynchronously without a request from the manager. The agent sends UDP packets to the server whenever necessary. This method is called an SNMP trap and is used to send unsolicited messages, such as alarms or threshold-level breaches.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>An SNMP MIB</h2>
<p>As <a id="_idIndexMarker363"/>described in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, a <strong class="bold">Management Information Base</strong> (<strong class="bold">MIB</strong>) is <a id="_idIndexMarker364"/>used as an identifier to access the network information variable. The identifier is known as<a id="_idIndexMarker365"/> an <strong class="bold">Object Identifier</strong> (<strong class="bold">OID</strong>), as seen in <em class="italic">Figure 1.8</em>.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>SNMP versions</h2>
<p>SNMP comes with <a id="_idIndexMarker366"/>version 1, version 2c, and version 3. They were published at different times, and the differences are the available methods, transport protocol, MIB variables, and cryptography. SNMP agents are compatible backward – therefore, an agent that supports version 3 can work with all versions. The following sections present a summary of each version.</p>
<h3>SNMPv1</h3>
<p>This is <a id="_idIndexMarker367"/>the first version and contains most of the MIB variables and methods. It is based on UDP, using a community string as authentication. It only supported 32-bit MIB counters, which is a problem with fast interfaces, as the counter expires quickly.</p>
<h3>SNMPv2c</h3>
<p>Introduced<a id="_idIndexMarker368"/> 64-bit MIB variable counters and the <code>InformRequest</code> and <code>GetBulkRequest</code> methods. Version 2 was not adopted because of security complexity. Version 2c was then published with simplifications and was widely accepted.</p>
<h3>SNMPv3</h3>
<p>Introduced cryptography<a id="_idIndexMarker369"/> for authentication and privacy. The <code>Report</code> method was added.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>SNMP primitive methods</h2>
<p>SNMP essentially uses the<a id="_idIndexMarker370"/> following primitive methods.</p>
<ul>
<li><code>GET</code>: Methods to gather information from the agent:<ul><li><code>GetRequest</code>: Given an OID, returns the variable associated with it</li><li><code>GetNextRequest</code>: Given an OID, returns the next OID with the variable associated with it (used on an SNMP MIB walk function)</li><li><code>GetBulkRequest</code>: Given an OID base, returns all OIDs and variables under this OID branch (sometimes causes long responses that can’t be interrupted)</li></ul></li>
<li><code>SET</code>: Methods to set a value on the agent:<ul><li><code>SetRequest</code>: Given an OID and a value, sets it on the MIB</li></ul></li>
<li><code>Response</code>: All responses for <code>SET</code> and <code>GET</code></li>
<li><code>TRAP</code>: Asynchronous information sent from the agent to the manager with an OID and a variable</li>
<li><code>InformRequest</code>: Used to <a id="_idIndexMarker371"/>send asynchronous information with acknowledgment</li>
</ul>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>SNMP security issues</h2>
<p>Because of a lack <a id="_idIndexMarker372"/>of cryptography and authentication, SNMPv1 and v2 are vulnerable to IP spoofing attacks, which allow hackers to potentially send <code>SET</code> requests to agents compromising the network. Historically, because of this security issue, SNMP is not used to write configuration and only gathers configuration using the <code>GET</code> method or <code>TRAP</code>.</p>
<p>Here are some pros and cons of<a id="_idIndexMarker373"/> using SNMP for network automation:</p>
<p><strong class="bold">Pros</strong>:</p>
<ul>
<li>Easy to implement</li>
<li>Fast</li>
<li>Parallelism is easy</li>
<li>No privileged<a id="_idIndexMarker374"/> access</li>
</ul>
<p><strong class="bold">Cons</strong>:</p>
<ul>
<li>Requires <a id="_idIndexMarker375"/>pooling to gather information frequently</li>
<li>Not normally used for writing information</li>
<li>Very limited scope of data coverage compared to a CLI</li>
<li>Security<a id="_idIndexMarker376"/> issues when writing</li>
</ul>
<p>As we saw in this section, SNMP is the oldest and most robust protocol for network management. Although it has security and scope problems for writing configurations, its protocol is light, fast, and easy to read. The following section will cover the protocol developed by the IETF working group to fill the gap in network management concerning configuration. It is called NETCONF.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Employing NETCONF</h1>
<p>The <strong class="bold">Network Configuration Protocol</strong> (<strong class="bold">NETCONF</strong>) is a network management protocol developed and <a id="_idIndexMarker377"/>standardized by the IETF in 2006. It provides mechanisms to install, manipulate, and delete the configuration of network devices.</p>
<p>NETCONF operations <a id="_idIndexMarker378"/>are implemented on top of a <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) layer. The NETCONF protocol uses <strong class="bold">Extensible Markup Language </strong>(<strong class="bold">XML</strong>)-based data<a id="_idIndexMarker379"/> encoding for the configuration data as well as the protocol messages. The protocol messages can also be exchanged on top of a secure transport protocol such as SSH (RFC 6242) or using TLS (RFC 7589).</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Motivation</h2>
<p>Up until the<a id="_idIndexMarker380"/> early part of the 21st century, the only management protocol available from IETF was SNMP, which was developed in the late 1980s. It became clear that despite what was originally intended, SNMP was not being used to configure network equipment and was mainly being used for gathering network device information (as we have seen previously). The reasons are various, but mainly because SNMP was insecure and had a limited scope compared to a CLI for instance.</p>
<p>In June 2002, the network management community and the Internet Architecture Board got together with network key operators to discuss the real situation on network management protocols and usage. The results of this meeting are documented in RFC 3535 (<a href="https://datatracker.ietf.org/doc/html/rfc3535">https://datatracker.ietf.org/doc/html/rfc3535</a>).</p>
<p>It turned out that network operators, instead of using SNMP, were primarily using different proprietary CLIs to configure their network devices. The reasons were various, including security issues and the lack of scope to configure or write configs because SNMP was too rigid to do so. </p>
<p>On the other hand, around this time, Juniper Networks had started to use an XML-based network management approach, which was seen by IETF and the network operator community as an opportunity to combine efforts. This led to the creation of the NETCONF working group in May 2003.</p>
<p>In <a id="_idIndexMarker381"/>December 2006, with a lot of help from Juniper Networks, the first version of the base NETCONF protocol was published, RFC 4741 (<a href="https://datatracker.ietf.org/doc/html/rfc4741">https://datatracker.ietf.org/doc/html/rfc4741</a>). After that, several extensions were published in subsequent years (RFC 5277, RFC 5717, RFC 6243, RFC 6470, and RFC 6536, among others). The last revised version of NETCONF is documented in RFC 6241, published in June 2011 (updated by RFC 7803 and RFC 8526).</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>OpenConfig</h2>
<p><strong class="bold">OpenConfig</strong> is<a id="_idIndexMarker382"/> an informal working group of network operators sharing the goal of moving our networks toward a more dynamic, programmable infrastructure by adopting SDN principles such as declarative configuration and model-driven management and operations.</p>
<p>Our initial focus in OpenConfig is on compiling a consistent set of vendor-neutral data models – written<a id="_idIndexMarker383"/> in <strong class="bold">Yet Another Next Generation</strong> (<strong class="bold">YANG</strong>) – based on the actual operational needs from use cases and requirements from multiple network operators.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>YANG</h2>
<p>YANG is a <a id="_idIndexMarker384"/>data modeling language that is used by the NETCONF protocol. YANG can be used to model both configuration data and state data from network devices. It is a modular language representing data structures in the XML format but can also be represented by other formats.</p>
<p>For each network device feature, at least one RFC describes the data model with YANG – for instance, VRRP (in <a href="B18165_02.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>) describes the YANG data model in RFC 8347 (<a href="https://datatracker.ietf.org/doc/html/rfc8347">https://datatracker.ietf.org/doc/html/rfc8347</a>). Another effort to cover network ACLs (see <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>) describes the YANG models in RFC 8519 (<a href="https://datatracker.ietf.org/doc/html/rfc8519">https://datatracker.ietf.org/doc/html/rfc8519</a>).</p>
<p>Let’s examine the characteristics of YANG and the details of the model a bit more closely.</p>
<h3>The data modeling process is hard</h3>
<p>It is important to understand that creating a YANG data model for a router function is not an easy task because it has to accommodate possible scenarios from the existing methods of all possible devices. So, it is not a fresh start from scratch, but the task of modeling functions that are already in use in several vendors and devices. Let’s take one example – the YANG data model<a id="_idIndexMarker385"/> for <strong class="bold">Routing Policy</strong>. As you can see on the timeline shown in <em class="italic">Figure 3.5</em>, the work started in 2015, and after more than 30 drafts, the standard<a id="_idIndexMarker386"/> was finally published in October 2021, which meant it took almost 7 years:</p>
<div><div><img alt="Figure 3.5 – Timeline for creating a YANG data model for Routing Policy" src="img/B18165_03_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Timeline for creating a YANG data model for Routing Policy</p>
<p>It would be easier if each vendor had its own YANG data model, but then that would remove the general dependency.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>NETCONF</h2>
<p>NETCONF<a id="_idIndexMarker387"/> uses client-server communication based on RPCs. With NETCONF, server configurations are stored in a NETCONF configuration datastore that follows a YANG data format specification. To change or update data, a client sends an XML-based remote procedure call over one of the secure transfer methods, and the server replies with XML-encoded data.</p>
<p>NETCONF has four layers, as shown in <em class="italic">Figure 3.6</em>, extracted from the original RFC 6241:</p>
<div><div><img alt="Figure 3.6 – The four layers described in the RFC 6241" src="img/B18165_03_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – The four layers described in the RFC 6241</p>
<p>Let’s summarize each of the layers:</p>
<ul>
<li><strong class="bold">Content</strong> layer: Consists <a id="_idIndexMarker388"/>of configuration data and notification data. Valid content is defined in the YANG specification.</li>
<li><code>get</code>, <code>get-config</code>, <code>edit-config</code>, <code>copy-config</code>, <code>delete-config</code>, <code>lock</code>, <code>unlock</code>, <code>close-session</code>, and <code>kill-session</code>.</li>
<li><code>&lt;rpc&gt;</code> request from a client or a <code>&lt;rpc-reply&gt;</code> from a server. RFC6241 also added notifications to this layer.</li>
<li><strong class="bold">Secure Transport</strong> layer: This <a id="_idIndexMarker391"/>layer deals with the protocols used to transmit NETCONF messages. SSH, TLS, and HTTP are a few of the protocols associated with this layer.</li>
</ul>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>RESTCONF</h2>
<p>The RESTCONF protocol<a id="_idIndexMarker392"/> is a proposed standard defined in RFC 8040 (<a href="https://www.rfc-editor.org/rfc/rfc8040.html">https://www.rfc-editor.org/rfc/rfc8040.html</a>). NETCONF and RESTCONF are similar in terms of their capabilities, but RESTCONF came later in 2017 with a <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>)<strong class="bold">ful API</strong> model<a id="_idIndexMarker393"/> using HTTP. They both allow administrators to query information or modify settings using a client-server model. RESTCONF is different in a few key ways:</p>
<ul>
<li>RESTCONF uses HTTP</li>
<li>RESTCONF supports both JSON and XML</li>
<li>RESTCONF does not have the concept of transaction and therefore does not have the <code>lock</code> concept as NETCONF does</li>
</ul>
<p>RESTCONF is not intended to replace NETCONF. Rather, it was created to allow the use of a RESTful API that can be used to query and configure devices with NETCONF or YANG configuration datastores.</p>
<p><em class="italic">Figure 3.7</em> shows a table extracted from RFC 8040 that demonstrates the overlap between RESTCONF and NETCONF calls:</p>
<div><div><img alt="Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from RFC 8040" src="img/B18165_03_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from RFC 8040</p>
<p>Here <a id="_idIndexMarker394"/>are some <a id="_idIndexMarker395"/>pros and cons of using NETCONF or RESTCONF:</p>
<p><strong class="bold">Pros</strong>:</p>
<ul>
<li>Incorporate network specification</li>
<li>IETF standards</li>
<li>No privileged access</li>
<li>Allow stream event notifications</li>
<li>Programmatic device configuration</li>
</ul>
<p><strong class="bold">Cons</strong>:</p>
<ul>
<li>Not all <a id="_idIndexMarker396"/>device <a id="_idIndexMarker397"/>capabilities are covered in YANG</li>
<li>Adoption of NETCONF has been really slow</li>
<li>NETCONF transport is limited and implementation is old</li>
<li>Not <a id="_idIndexMarker398"/>that<a id="_idIndexMarker399"/> efficient</li>
</ul>
<p>This section summarizes how NETCONF, RESTCONF, and YANG are used to interact with network devices. The transaction states of NETCONF make it a powerful tool for network configuration. Despite its good base of IETF standards, NETCONF is not efficient enough to handle some of the network automation we want, such as collecting data at a high-frequency rate. In the following section, we are going to explore a newer protocol called gRPC.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Adopting gRPC</h1>
<p><strong class="bold">gRPC</strong> was <a id="_idIndexMarker400"/>published in 2015 as an open source RPC framework. It is one of the most promising protocols to be used in automation because it is easy to create a program and add methods to obtain or set configuration on the network device.</p>
<p>gRPC does not directly use TCP for transport, but  HTTP/2 instead, which was published in 2015 to overcome the limitations of HTTP/1.1. While it is backward compatible with HTTP/1.1, HTTP/2 brings many added advanced capabilities, such as the following:</p>
<ul>
<li><strong class="bold">Binary framing layer</strong>: Request <a id="_idIndexMarker401"/>and response is divided into small messages and framed in binary format, making message transmission efficient</li>
<li><strong class="bold">Bidirectional full-duplex streaming</strong>: Here, the client can request and the server can respond simultaneously</li>
<li><strong class="bold">Flow control (used in HTTP/2)</strong>: Enables the detailed control of memory used for the network buffers</li>
<li><strong class="bold">Header compression</strong>: Everything in HTTP/2, including headers, is encoded before it is sent, significantly improving performance</li>
<li><strong class="bold">Asynchronous and synchronous processing</strong>: Can be used to perform different types of interaction and<a id="_idIndexMarker402"/> streaming RPCs</li>
</ul>
<p>All these features of HTTP/2 enable gRPC to use fewer resources, resulting in reduced response times between clients and servers.</p>
<p>To ensure the security of gRPC, TLS end-to-end encryption can be used, and authentication can use SSL or TLS with or without token-based authentication or the need to define your own authentication system by extending the provided code (more on authentication can be<a id="_idIndexMarker403"/> found at <a href="https://grpc.io/docs/guides/auth/">https://grpc.io/docs/guides/auth/</a>).</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>The letter g</h2>
<p>Initially, in<a id="_idIndexMarker404"/> version 1.0 of the protocol, the letter <em class="italic">g</em> was a recursive reference to the name gRPC, but as later versions were published, another word was added, making the name a bit of code entertainment. For instance, in version 1.1, the word was <em class="italic">good</em>, in version 1.2, it was <em class="italic">green</em>, and for version 1.42, it was <em class="italic">granola</em>. A complete list of names used for the letter <em class="italic">g</em> can be found in the gRPC source code here: <a href="https://grpc.github.io/grpc/core/md_doc_g_stands_for.html">https://grpc.github.io/grpc/core/md_doc_g_stands_for.html</a>.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Motivation</h2>
<p>Google has used <a id="_idIndexMarker405"/>a single general-purpose RPC <a id="_idIndexMarker406"/>infrastructure called <strong class="bold">Stubby</strong> to connect the large number of microservices running within and across Google data centers for more than a decade. That motivated Google to publish and sponsor the creation of gRPC.</p>
<p class="callout-heading">Letter from the gRPC team on Monday, October 26, 2015</p>
<p class="callout"><em class="italic">The gRPC team is excited to announce the immediate availability of gRPC Beta. This release represents a major step forward in API stability, with most API changes in the future being additive in nature. It opens the door for gRPC use in production environments.</em></p>
<p class="callout"><em class="italic">We updated grpc.io documentation to reflect the latest changes and released language-specific reference documentation. In the release notes on GitHub for Java, Go, and all other languages, you will find information on what has changed.</em></p>
<p class="callout"><em class="italic">We would like to thank everyone who contributed code, gave presentations, adopted the technology, and participated in the community. We look forward to 1.0 with your support!</em></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>Overview</h2>
<p>gRPC <a id="_idIndexMarker407"/>uses the concept of a client and server application. Client applications can directly invoke server applications on remote machines just as if they were local objects. gRPC is based on the idea of defining a service and specifying methods that can be called remotely using their parameters and return types. The server implements this interface and runs a gRPC server to handle client calls. The client has a stub (just referred to as a client in some languages) that provides the same methods as the server.</p>
<p>In the world of network automation, the gRCP client is actually our automation software and the gRPC server is the network device, as illustrated in <em class="italic">Figure 3.8</em>:</p>
<div><div><img alt="Figure 3.8 – Basic request and response for gRPC" src="img/B18165_03_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Basic request and response for gRPC</p>
<p>The gRPC <a id="_idIndexMarker408"/>server and client are not required to use the same programming language. Today, there are several implementations of different languages, whether Go, Python, Java, or Ruby. A complete list of the languages supported <a id="_idIndexMarker409"/>can be found here: <a href="https://grpc.io/docs/languages/">https://grpc.io/docs/languages/</a>.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>Protobuf</h2>
<p>By<a id="_idIndexMarker410"/> default, gRPC uses <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>), which is <a id="_idIndexMarker411"/>another open source mechanism for serializing data created by Google. Although Protobuf is the default, gRPC can also use JSON instead, but that is less efficient, as we are going to see.</p>
<p>Protobuf is a<a id="_idIndexMarker412"/> language- and platform-neutral mechanism for<a id="_idIndexMarker413"/> serializing data, like JSON or XML but much smaller, faster, and simpler. The structure of the data is defined once and then a specially generated source code is used to easily write and read this structured data from a variety of data streams with any programming language.</p>
<p>More about<a id="_idIndexMarker414"/> Protobuf can be found here: <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a>.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>gRPC and network telemetry</h2>
<p>During our network <a id="_idIndexMarker415"/>automation work, we are going to experience a series of limitations, especially in gathering network information in an effective way. So, let’s explore the following example.</p>
<p>Imagine a network with 500 devices, with 50 interfaces on each device on average. Each interface needs to gather multiple variables, such as the current state, the error rate, drop counts, packet-in counts, or packet-out counts. If we consider a conservative approach, such as only collecting 10 variables per interface, for this network example, we are going to gather information from 10 variables x 50 interfaces x 500 devices, which adds up to 250,000 variables.</p>
<p>The other point to consider is the frequency of the data. In the 90s, network management required information from the network every 5 minutes and that was sufficient for handling failures and troubleshooting, but nowadays, the interval is much smaller. We are looking to gather information at intervals of less than 1 minute, ideally every 30 or 10 seconds. The reason is that troubleshooting and failure resolution can occur faster when detecting failures quickly.</p>
<p>So, in our example, 250,000 variables every 10 seconds give us an enormous amount of data using traditional polling mechanisms such as SNMP. However, one important point to note here is most of the content of the variables might not change at all, such as the counters for interfaces when there is no traffic, the state of the interface when nothing has changed, the interface discard counter when there aren’t any, or the error rate when the interface is perfectly fine. Therefore, several or even the majority of the contents of the network variables are not going to change that often, meaning that pooling mechanisms are inefficient and accumulate redundant information over time. What would be better than polling? Streaming telemetry. Streaming telemetry allows devices to send incremental updates continuously as soon as changes occur. In this way, the collection of network information can be done more effectively than with pooling.</p>
<p>gRPC supports<a id="_idIndexMarker416"/> bidirectional streaming, which gives this protocol a huge advantage compared to the others we saw so far for data collection.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Code examples using gRPC</h2>
<p>To make the example <a id="_idIndexMarker417"/>more realistic for network automation, let’s have a service on the routers that can return the following information:</p>
<ul>
<li>Return the memory utilization in percent</li>
<li>Return the CPU utilization in percent</li>
<li>Return the router uptime in seconds</li>
</ul>
<p>Our examples will create a client gRPC stub to communicate to the router, which will be the gRPC server, as depicted in <em class="italic">Figure 3.8</em>. We are only going to demonstrate the client side and we are going to assume the gRPC server on the router has already been implemented.</p>
<h3>The Protobuf file</h3>
<p>The Protobuf file<a id="_idIndexMarker418"/> definition is a single part of the code that is not tied to any language. The<a id="_idIndexMarker419"/> same file definition is used on the client and the server. It is compiled once and feeds the client and server programs to interpret the data used to generate the RPCs. For our example, the Protobuf file would look as follows:</p>
<pre class="source-code">
service RouterStatus {
  rpc GetStatus (StatusRequest) returns (StatusReply);
}
message StatusRequest {}
message StatusReply {
  double memory = 1;
  double cpu = 2;
  int32 uptime = 3;
} </pre>
<h3>An example using Python</h3>
<p>Here is an example <a id="_idIndexMarker420"/>using Python. The import name, <code>r_grpc</code>, compiles the code for Python from the Protobuf file:</p>
<pre class="source-code">
import grpc
import routerstatus_pb2
import routerstatus_pb2_grpc as r_grpc
def run():
    address = "router:50051"
    with grpc.insecure_channel(address) as channel:
        stub = r_grpc.StatusStub(channel)
        r = stub.GetStatus(r_grpc.StatusRequest())
        print("Memory:{.2f}% CPU:{.2f}%, Uptime:{d}s\n".format(r.memory, r.cpu, r.uptime))
if __name__ == '__main__':
    run()</pre>
<h3>An example using Go</h3>
<p>Here is an <a id="_idIndexMarker421"/>example using a Go program client. Note that <code>pb</code> (used on the import) is the code compiled for the Protobuf:</p>
<pre class="source-code">
import (
    "context"
    "log"
    "time"
    "fmt"
    "google.golang.org/grpc"
    pb "example/routerstatus"
)
func main() {
    address = "router:50051"
    // Set up a connection to the server.
    conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())
    if err != nil {
        log.Fatalf("did not connect: %v", err)
    }
    c := pb.NewStatusClient(conn)
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()
    r, err := c.GetStatus(ctx, &amp;pb.StatusRequest{})
    if err != nil {
        log.Fatalf("could not get router status: %v", err)
    }
    fmt.Printf("CPU:%.2f%%, Memory:%.2f%%, Uptime:%ds", r.GetCpu(), r.GetMemory(), r.GetUptime())
}</pre>
<p>Here are some <a id="_idIndexMarker422"/>pros and cons of using gRPC for network automation:</p>
<p><strong class="bold">Pros</strong>:</p>
<ul>
<li>Secure</li>
<li>Fast</li>
<li>Parallelism is easy</li>
<li>No privileged access is possible</li>
<li>Flexible and can expose any local device command using the gRPC server</li>
</ul>
<p><strong class="bold">Cons</strong>:</p>
<ul>
<li>Not many<a id="_idIndexMarker423"/> network devices have gRPC capability</li>
</ul>
<p>In this section, we saw that gRPC is a powerful protocol to use for network automation. However, it is not well integrated into network devices yet. The majority of the new operating systems on network devices come with this capability. In the next section, a higher-level protocol called gNMI will be used to make better use of the gRPC protocol for network automation.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Operating with gNMI</h1>
<p>As we saw before, gRPC is probably the most appropriate protocol for working with devices in terms of performance. However, it is actually a generic protocol to be used in any client and server interaction – not only network devices but also computer servers. For this reason, <strong class="bold">gRPC Network Management Interface</strong> (<strong class="bold">gNMI</strong>) was created.</p>
<p>gNMI is an<a id="_idIndexMarker424"/> open source protocol specification created by the OpenConfig working group that is used to communicate to and from network devices using YANG (discussed in the <em class="italic">NETCONF</em> section). In other words, gNMI was created to utilize the good work done by people defining the network specification data using YANG but with a more modern protocol such as gRPC instead of NETCONF.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Protocol layers</h2>
<p>gNMI uses gRPC. For that, it <a id="_idIndexMarker425"/>has to translate the YANG data description into Protobuf to serialize the communication, as illustrated in <em class="italic">Figure 3.9</em>. At the bottom of the diagram is a normal gRPC connection over HTTP/2 and TLS. The gRPC code is auto-generated from the gNMI Protobuf model and gNMI carries the data modeled in YANG, which can support encoding in JSON, like the example below.</p>
<div><div><img alt="Figure 3.9 – gNMI protocol layers" src="img/B18165_03_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – gNMI protocol layers</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>The data model</h2>
<p>gNMI uses a data model called <code>PathElem</code> messages. Each <code>PathElem</code> consists of a name encoded as a string. An element’s name must be encoded as a <code>PathElem</code> may optionally specify a set of keys, specified as a <code>map&lt;string,string&gt;</code> (dictionary or map).   </p>
<p>The root path, <code>/</code>, is encoded as a zero-length array (slice) of <code>PathElem</code> messages. Here are some example declarations in Go and Python:</p>
<ul>
<li><code>path := []*PathElem{}</code></li>
<li><code>path = []</code></li>
</ul>
<p>A human-readable path can be formed by concatenating elements of the prefix and path using the <code>/</code> separator. </p>
<p>So, let’s see the following representation: <code>/interfaces/interface[name=Ethernet1/2/3]/state.</code></p>
<p>This is specified as follows:</p>
<pre class="source-code">
&lt;elem: &lt;name: "interfaces”&gt;elem: &lt;name: "interface"key: &lt;key: "name”value: "Ethernet1/2/3"&gt;&gt;elem: &lt;name: "state"&gt;&gt;</pre>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>The communication model</h2>
<p>The <a id="_idIndexMarker428"/>communication model uses a target and client as follows:</p>
<ul>
<li><strong class="bold">Target</strong>: The<a id="_idIndexMarker429"/> device within the gNMI that acts as the owner of the data that is being manipulated or collected. Typically, this is our network device.</li>
<li><strong class="bold">Client or collector:</strong> The <a id="_idIndexMarker430"/>system using the gNMI to query or modify data on the target or act as a collector for streamed data. Typically, this is the network management system or our automation code.</li>
</ul>
<p>Similar to gRPC, the<a id="_idIndexMarker431"/> server actually is on the network device, as depicted in <em class="italic">Figure 3.10</em>:</p>
<div><div><img alt="Figure 3.10 – gNMI ﻿target and ﻿client communication" src="img/B18165_03_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – gNMI target and client communication</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Service definition</h2>
<p>The gNMI <a id="_idIndexMarker432"/>service is based on RPC calls called <code>Capabilities</code>, <code>Get</code>, <code>Set</code>, and <code>Subscribe</code>, which will be detailed in the following sections.</p>
<h3>Capabilities RPC</h3>
<p>A client can discover the capabilities of the <a id="_idIndexMarker433"/>target using the <code>CapabilityRequest</code> message is sent by the client to interrogate the target. The target must then reply with a <code>CapabilityResponse</code> message that includes its gNMI service version, the versioned data models it supports, and the supported data encodings. This information is used in subsequent RPC messages from the client to indicate the set of models that the client will use for the <code>Get</code> and <code>Subscribe</code> RPC calls and the encoding to be used for the data.</p>
<h3>Get RPC</h3>
<p>The <code>GetRequest</code> message to the target, specifying the path that is to be retrieved. Upon reception of the <code>GetRequest</code> message, the target serializes the requested path and returns a <code>GetResponse</code> message. This connection is short-lived and the target closes the <code>Get</code> RPC following the transmission of the <code>GetResponse</code> message.</p>
<h3>Set RPC</h3>
<p>Modifications to the state<a id="_idIndexMarker435"/> of the target are made through the <code>SetRequest</code> message to the target indicating the modifications it desires.</p>
<p>A target receiving a <code>SetRequest</code> message processes the operations specified within it, which are treated as a transaction. In response to a <code>SetRequest</code> message, the target must respond with a <code>SetResponse</code> message. For each operation specified in the <code>SetReques</code>t message, an <code>UpdateResult</code> message must be included in the response field of <code>SetResponse</code>.</p>
<h3>Subscribe RPC</h3>
<p>This <a id="_idIndexMarker436"/>perhaps is the most important call on the gNMI because it is the one that allows Streaming Telemetry, as discussed before.  </p>
<p>When a client wishes to receive updates relating to the state of data instances on a target, it creates a subscription via the <strong class="bold">Subscribe RPC</strong>. A subscription consists of one or more paths, with a specified subscription mode. The mode of each subscription determines the triggers for updates to the data sent from the target to the client.</p>
<p>All requests for new subscriptions are encapsulated within a <code>SubscribeRequest</code> message, which itself has a mode describing the longevity of the subscription. A client may create a subscription that has a dedicated stream to return one-off data (<code>ONCE</code>); a subscription that utilizes a stream to periodically request a set of data (<code>POLL</code>); or a long-lived subscription that streams data according to the triggers specified within the individual subscription’s mode (<code>STREAM</code>). For Streaming Telemetry, the mode is set to <code>STREAM</code>.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>gNMI-gateway</h2>
<p><strong class="bold">gNMI-gateway</strong> is <a id="_idIndexMarker437"/>open source software that was initially developed by Netflix and then released as part of the OpenConfig working group to collect and distribute OpenConfig-modeled gNMI data from network devices. </p>
<p>The motivations to create gNMI-gateway were various, as follows:</p>
<ul>
<li>First, there were not many open source services available to consume and distribute OpenConfig-modeled gNMI Streaming Telemetry data.</li>
<li>Second, there was a lack of failure tolerance for the client and target connection using gNMI data streaming, making Streaming Telemetry vulnerable. As the client dies, the streamed data is lost until another subscription takes place.</li>
<li>The third was the lack of supporting multiple consumers. If multiple departments in a company want data from a network device or a group of network devices, it would be necessary for all of them to send subscriptions to the targets. With clustering functionality and replication in gNMI-gateway, it is possible to avoid unnecessarily duplicating gNMI connections to targets and offer the same data to multiple customers.</li>
<li>Fourth, there was a lack of unifying gNMI clients with non-gNMI clients. gNMI-gateway allows either <a id="_idIndexMarker438"/>gNMI clients or non-gNMI clients to gather information.</li>
</ul>
<p><em class="italic">Figure 3.11</em> shows<a id="_idIndexMarker439"/> a single instance of gNMI-gateway with gNMI clients and non-gNMI clients, also known as exporters. <strong class="bold">Apache Kafta</strong> (<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>) is one <a id="_idIndexMarker440"/>piece of software that can be used as an exporter; another one already<a id="_idIndexMarker441"/> implemented is <strong class="bold">Prometheus</strong> (<a href="https://prometheus.io/">https://prometheus.io/</a>):</p>
<div><div><img alt="Figure 3.11 – A single instance of gNMI-gateway" src="img/B18165_03_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – A single instance of gNMI-gateway</p>
<p>The redundancy can be obtained by using multiple instances of gNMI-gateway which is implemented<a id="_idIndexMarker442"/> by using <strong class="bold">Apache Zookeeper</strong> (<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a>), as illustrated in <em class="italic">Figure 3.12</em>. If only one instance is running, there is no need to use Apache Zookeeper:</p>
<div><div><img alt="Figure 3.12 – Multiple instances of gNMI-gateway" src="img/B18165_03_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Multiple instances of gNMI-gateway</p>
<p>More on gNMI-gateway<a id="_idIndexMarker443"/> can be found here: <a href="https://github.com/openconfig/gnmi">https://github.com/openconfig/gnmi</a>.</p>
<p>For reference, here is a full presentation on gNMI-gateway presented at 2020’s NANOG Webcast: <a href="https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/">https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/</a>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Full specification on<a id="_idIndexMarker444"/> gNMI can be found here: <a href="https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md">https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md</a>.</p>
<p>Here are some pros and cons of using<a id="_idIndexMarker445"/> gNMI for network automation:</p>
<p><strong class="bold">Pros</strong>:</p>
<ul>
<li>Secure</li>
<li>Fast</li>
<li>Parallelism is easy</li>
<li>No privileged access is possible</li>
<li>Incorporates YANG specification for networking</li>
<li>Allows easy Streaming Telemetry</li>
<li>Capable of <a id="_idIndexMarker446"/>adding gNMI-gateway with full redundancy</li>
</ul>
<p><strong class="bold">Cons</strong>:</p>
<ul>
<li>Not<a id="_idIndexMarker447"/> many network devices have gNMI capability</li>
</ul>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Summary</h1>
<p>In this chapter, we covered the major methods used by software engineers to interact with network devices. Not many more methods are available, so I would assume we have covered perhaps 99.9% of all existing methods at the time of writing. </p>
<p>Using the information provided in this chapter, you can choose which method or methods to incorporate into your network automation code. In most cases, you won’t be able to cover all scenarios using just one method; you will probably have to combine two or more methods.</p>
<p>The next chapter will explore how files can be used to define a network. We will discuss the pros and cons of each type of file that’s available.</p>
</div>
</body></html>