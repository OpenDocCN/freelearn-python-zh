<html><head></head><body>
<div id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.2.1">Accessing the Network</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we looked into programmable networks and their history. </span><span class="koboSpan" id="kobo.3.2">One of the ideas we explored </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.4.1">was </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Software-Defined Networking</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">SDN</span></strong><span class="koboSpan" id="kobo.8.1">), where we saw why the separation between the data plane and the control plane was important. </span><span class="koboSpan" id="kobo.8.2">One important point of SDN was its architecture and how it separates</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.9.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">North Bound Interface</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">NBI</span></strong><span class="koboSpan" id="kobo.13.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">South Bound Interface</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">SBI</span></strong><span class="koboSpan" id="kobo.17.1">). </span><span class="koboSpan" id="kobo.17.2">In this chapter, we are going to explore how to access the </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.18.1">network devices that can be interpreted as the SBI for SDN when OpenFlow is not available on the device.</span></p>
<p><span class="koboSpan" id="kobo.19.1">As we have seen before, OpenFlow is not a widely adopted protocol, and its availability is limited to a few manufacturers and devices. </span><span class="koboSpan" id="kobo.19.2">Therefore, if you are planning to use SDN, you may need to use the available native methods to configure the devices.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Network access is not only used for SDN but also for a variety of software, such as network configuration, configuration audit, upgrade tools, and automation, among others. </span><span class="koboSpan" id="kobo.20.2">Additionally, devices usually have multiple methods or protocols, some of which may be better than others.</span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will explore the most common methods and protocols for accessing network devices for our network automation. </span><span class="koboSpan" id="kobo.21.2">Since devices have multiple methods, we will aim to give you enough information so that you can choose the one that is most appropriate for your network automation code.</span></p>
<p><span class="koboSpan" id="kobo.22.1">We are going to explore the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Working with the CLI</span></li>
<li><span class="koboSpan" id="kobo.24.1">Using SNMP</span></li>
<li><span class="koboSpan" id="kobo.25.1">Employing NETCONF</span></li>
<li><span class="koboSpan" id="kobo.26.1">Adopting gRPC</span></li>
<li><span class="koboSpan" id="kobo.27.1">Operating with gNMI</span></li>
</ul>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.28.1">Working with the CLI</span></h1>
<p><span class="koboSpan" id="kobo.29.1">The</span><strong class="bold"><span class="koboSpan" id="kobo.30.1"> Command-Line Interface</span></strong><span class="koboSpan" id="kobo.31.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.32.1">CLI</span></strong><span class="koboSpan" id="kobo.33.1">) is </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.34.1">perhaps the most widely available method for accessing a network device. </span><span class="koboSpan" id="kobo.34.2">It is a term imported from computers, which was a</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.35.1"> replacement for </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">teletypewriter</span></strong><span class="koboSpan" id="kobo.37.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.38.1">TTY</span></strong><span class="koboSpan" id="kobo.39.1">) machines. </span><span class="koboSpan" id="kobo.39.2">A CLI is normally implemented by using a program that runs inside the device to interpret the keys being typed. </span><span class="koboSpan" id="kobo.39.3">Early implementations of the CLI program monitored the device’s serial port, where a terminal with a keyboard was connected to communicate.</span></p>
<p><span class="koboSpan" id="kobo.40.1">In UNIX, the CLI program was called a shell, and the</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.41.1"> first shell, called the </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">V6 shell</span></strong><span class="koboSpan" id="kobo.43.1">, was created in 1971 by Ken Thompson</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.44.1"> at Bell Labs. </span><span class="koboSpan" id="kobo.44.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">Bourne shell</span></strong><span class="koboSpan" id="kobo.46.1"> was introduced in 1977 as a replacement for the V6 shell. </span><span class="koboSpan" id="kobo.46.2">Although the UNIX shell is used as an interactive command interpreter, it was also intended to be a scripting language and contains most of the features that are commonly considered to produce structured programs.</span></p>
<p><span class="koboSpan" id="kobo.47.1">Network devices use a simplified version of a shell for their CLIs. </span><span class="koboSpan" id="kobo.47.2">Let’s explore a bit more what CLI access can offer.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.48.1">The command prompt</span></h2>
<p><span class="koboSpan" id="kobo.49.1">When using the CLI in our network automation work, the command prompt is the most important piece in our code to be interpreted. </span><span class="koboSpan" id="kobo.49.2">We will see that the device uses the command prompt to indicate when it is ready to receive a new command.</span></p>
<p><span class="koboSpan" id="kobo.50.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">command prompt</span></strong><span class="koboSpan" id="kobo.52.1"> (or prompt) is </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.53.1">a sequence of characters used in the CLI to indicate readiness to accept a new command, which means it </span><em class="italic"><span class="koboSpan" id="kobo.54.1">prompts</span></em><span class="koboSpan" id="kobo.55.1"> the user to take action. </span><span class="koboSpan" id="kobo.55.2">A prompt usually ends with one of the following characters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">$</span></strong><span class="koboSpan" id="kobo.57.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">%</span></strong><span class="koboSpan" id="kobo.59.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">#</span></strong><span class="koboSpan" id="kobo.61.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">:</span></strong><span class="koboSpan" id="kobo.63.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">&gt;</span></strong><span class="koboSpan" id="kobo.65.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">-</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">It also can include additional information, such as the current time, working directory, username, or hostname. </span><span class="koboSpan" id="kobo.67.3">On many network devices, the prompt normally ends with </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">$</span></strong><span class="koboSpan" id="kobo.69.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">%</span></strong><span class="koboSpan" id="kobo.71.1">, and for the privileged CLI access mode, it normally ends with </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">#</span></strong><span class="koboSpan" id="kobo.73.1">, which is similar to the UNIX superuser, </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">root</span></strong><span class="koboSpan" id="kobo.75.1">.</span></p>
<p><span class="koboSpan" id="kobo.76.1">Most of the </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.77.1">prompts can be modified by the user – however, the most common information presented in the prompts of network devices is the hostname and sometimes, the username used for login.</span></p>
<p><span class="koboSpan" id="kobo.78.1">The example in </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Figure 3.1</span></em><span class="koboSpan" id="kobo.80.1"> shows an </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">FRRouting</span></strong><span class="koboSpan" id="kobo.82.1"> command prompt</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.83.1"> with the hostname as </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">core-router</span></strong><span class="koboSpan" id="kobo.85.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">&gt;</span></strong><span class="koboSpan" id="kobo.87.1"> character at the end, meaning it is waiting for the commands to be placed where the cursor is:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.88.1"><img alt="Figure 3.1 – A FRR router command prompt example" src="image/B18165_03_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.89.1">Figure 3.1 – A FRR router command prompt example</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.90.1">Serial access</span></h2>
<p><span class="koboSpan" id="kobo.91.1">A network device normally </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.92.1">has a special port </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.93.1">called a </span><em class="italic"><span class="koboSpan" id="kobo.94.1">console</span></em><span class="koboSpan" id="kobo.95.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.96.1">serial console</span></em><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">This </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.98.1">port is normally configured to operate at a slow speed, and the common configuration sets the baud rate to 9,600, with some devices able to accept up to 115,200 bits per second. </span><span class="koboSpan" id="kobo.98.2">The serial port</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.99.1"> is normally</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.100.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">DB9</span></strong><span class="koboSpan" id="kobo.102.1"> connector or an </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">RJ45</span></strong><span class="koboSpan" id="kobo.104.1">, with </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">RS232</span></strong><span class="koboSpan" id="kobo.106.1"> technical specifications. </span><em class="italic"><span class="koboSpan" id="kobo.107.1">Figure 3.2</span></em><span class="koboSpan" id="kobo.108.1"> shows an example of the pins used for DB9 and RJ45 serial console connectors. </span></p>
<p><span class="koboSpan" id="kobo.109.1">The program that handles the serial port is normally independent of the device’s operating system, allowing this type of port to be used in catastrophic scenarios:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.110.1"><img alt="Figure 3.2 – An example of a device’s serial port pin configuration " src="image/B18165_03_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.111.1">Figure 3.2 – An example of a device’s serial port pin configuration </span></p>
<p><span class="koboSpan" id="kobo.112.1">It’s important to note that the serial port</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.113.1"> is used in the following cases:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.114.1">Extreme cases when the network device is unresponsible</span></li>
<li><span class="koboSpan" id="kobo.115.1">For local maintenance in the presence of a technician</span></li>
<li><span class="koboSpan" id="kobo.116.1">Critical upgrades with the risk of crashes or operation system deletion</span></li>
<li><span class="koboSpan" id="kobo.117.1">Operation system</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.118.1"> or hardware failure</span></li>
</ul>
<p><span class="koboSpan" id="kobo.119.1">The network automation should avoid using the serial port to configure the device because no parallelism exists (only one port) and its speed is limited.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.120.1">Remote insecure access</span></h2>
<p><span class="koboSpan" id="kobo.121.1">For the reasons explained</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.122.1"> previously, the serial port is slow and can’t be used in parallel. </span><span class="koboSpan" id="kobo.122.2">Therefore, the best way to access the network device is via remote access, which can be done via </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Out-Of-Band</span></strong><span class="koboSpan" id="kobo.124.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">OOB</span></strong><span class="koboSpan" id="kobo.126.1">) or </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.127.1">in-band management (described in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.128.1">Chapter 1</span></em></a><em class="italic"><span class="koboSpan" id="kobo.129.1">.</span></em></p>
<p><span class="koboSpan" id="kobo.130.1">How to determine whether the access is secure or not will depend on the protocol used and what kind of network is used to transport this remote access. </span><span class="koboSpan" id="kobo.130.2">If access is via an OOB network, it is normally secured and has separated and isolated infrastructure, but if it is in-band, some extra care needs to be taken to avoid some common security breaches.</span></p>
<h3><span class="koboSpan" id="kobo.131.1">Insecure applications and protocols</span></h3>
<p><span class="koboSpan" id="kobo.132.1">The following applications are normally not encrypted and are easy to eavesdrop on, proxy, or hijack.</span></p>
<h4><span class="koboSpan" id="kobo.133.1">Telnet</span></h4>
<p><span class="koboSpan" id="kobo.134.1">Telnet</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.135.1"> is an application that uses TCP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">23</span></strong><span class="koboSpan" id="kobo.137.1"> to access a remote device. </span><span class="koboSpan" id="kobo.137.2">The data is not encrypted and there is no authentication on the connection. </span><span class="koboSpan" id="kobo.137.3">TCP hijacking and eavesdropping are the most common security problems when using Telnet. </span><span class="koboSpan" id="kobo.137.4">To make sure these threats are not present, the network path carrying the access must be secured or isolated.</span></p>
<p><span class="koboSpan" id="kobo.138.1">Telnet normally requires a password and sometimes a username as well.</span></p>
<h4><span class="koboSpan" id="kobo.139.1">RSH</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.140.1">Remote Shell</span></strong><span class="koboSpan" id="kobo.141.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.142.1">RSH</span></strong><span class="koboSpan" id="kobo.143.1">) is rarely </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.144.1">used. </span><span class="koboSpan" id="kobo.144.2">In 1980, it was developed as an alternative to Telnet to provide non-interactive and fast remote command execution. </span><span class="koboSpan" id="kobo.144.3">RSH uses TCP on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">514</span></strong><span class="koboSpan" id="kobo.146.1"> and does not provide encryption or a password. </span><span class="koboSpan" id="kobo.146.2">As IP addresses are used to authenticate access, this protocol is extremely insecure and susceptible to IP spoofing attacks. </span></p>
<p><span class="koboSpan" id="kobo.147.1">If it were not for its lack of security, RSH would be a fast and easy option for running commands and creating network automation.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.148.1">Remote secure access</span></h2>
<p><span class="koboSpan" id="kobo.149.1">To make sure </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.150.1">remote access is secure, the data has to be encrypted and the hosts need to have some sort of identity-based authentication to make sure whoever is connecting is allowed to connect.</span></p>
<p><span class="koboSpan" id="kobo.151.1">The most used application for remote</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.152.1"> CLI access is </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Secure Shell</span></strong><span class="koboSpan" id="kobo.154.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.155.1">SSH</span></strong><span class="koboSpan" id="kobo.156.1">). </span><span class="koboSpan" id="kobo.156.2">SSH is implemented using the transport protocol TCP with port </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">22</span></strong><span class="koboSpan" id="kobo.158.1"> as the default.</span></p>
<h3><span class="koboSpan" id="kobo.159.1">Identity-based authentication</span></h3>
<p><span class="koboSpan" id="kobo.160.1">The identity-based authentication </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.161.1">on SSH is based on a key fingerprint using SHA-256 (an encryption algorithm). </span><span class="koboSpan" id="kobo.161.2">When SSH is used for the first time, SSH asks you to confirm the fingerprint key to make sure the host you are connecting to is the correct one. </span><span class="koboSpan" id="kobo.161.3">An example of this fingerprint is shown in </span><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 3.3</span></em><span class="koboSpan" id="kobo.163.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.164.1"><img alt="Figure 3.3 – An example of an SSH fingerprint acceptance request " src="image/B18165_03_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.165.1">Figure 3.3 – An example of an SSH fingerprint acceptance request </span></p>
<p><span class="koboSpan" id="kobo.166.1">Although</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.167.1"> SSH is considered a secure application protocol for accessing devices, the identity-based key fingerprint needs to be managed properly to avoid the most common attack, called </span><em class="italic"><span class="koboSpan" id="kobo.168.1">man-in-the-middle</span></em><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">This</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.170.1"> attack redirects the traffic to another device, pretends it is the end device, and uses this procedure to capture the password of the final target network device, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.171.1">Figure 3.4</span></em><span class="koboSpan" id="kobo.172.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.173.1"><img alt="Figure 3.4 – An example of a man-in-the-middle attack on a network device" src="image/B18165_03_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">Figure 3.4 – An example of a man-in-the-middle attack on a network device</span></p>
<p><span class="koboSpan" id="kobo.175.1">There are several ways to avoid a man-in-the-middle attack: one is to make sure the network device has an ACL (discussed in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.176.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.177.1">) that filters incoming IPs that are not part of the management. </span><span class="koboSpan" id="kobo.177.2">Another is to make sure identity key management is shared with the agent who is requesting remote access.</span></p>
<p><span class="koboSpan" id="kobo.178.1">Why is this important? </span><span class="koboSpan" id="kobo.178.2">Because network automation needs to make sure it uses a secure channel to modify the network and the key management is a shared responsibility between the network operators and the network automation teams.</span></p>
<p><span class="koboSpan" id="kobo.179.1">Here are some</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.180.1"> pros and cons of using a CLI for network automation:</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.181.1">Pros</span></strong><span class="koboSpan" id="kobo.182.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.183.1">Available on almost all network devices</span></li>
<li><span class="koboSpan" id="kobo.184.1">Able to access the whole network device’s operating system</span></li>
<li><span class="koboSpan" id="kobo.185.1">Critical and privileged access</span></li>
<li><span class="koboSpan" id="kobo.186.1">Remote or local access via serial access without a network</span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.187.1">Cons</span></strong><span class="koboSpan" id="kobo.188.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.189.1">Slow</span></li>
<li><span class="koboSpan" id="kobo.190.1">Limited </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.191.1">parallel access</span></li>
<li><span class="koboSpan" id="kobo.192.1">When not correctly used, may allow hackers to interfere</span></li>
<li><span class="koboSpan" id="kobo.193.1">Interactive, requiring prompt</span></li>
<li><span class="koboSpan" id="kobo.194.1">Data information is not structured (such as JSON or XML), which makes it prone to interpretation errors</span></li>
</ul>
<p><span class="koboSpan" id="kobo.195.1">To wrap up this section, we’ve covered the usage of the CLI, which is the oldest interface known for gathering information from network devices. </span><span class="koboSpan" id="kobo.195.2">We also learned that a CLI is the only way to collect or configure the device for some network devices. </span><span class="koboSpan" id="kobo.195.3">One of the important points is that CLI is always present on the network device. </span><span class="koboSpan" id="kobo.195.4">In the next section, we will see how we can improve the interface of the network device for gathering network information, called SNMP. </span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.196.1">Using SNMP</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.197.1">Simple Network Management Protocol</span></strong><span class="koboSpan" id="kobo.198.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.199.1">SNMP</span></strong><span class="koboSpan" id="kobo.200.1">) is perhaps the oldest and most used protocol to gather </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.201.1">management information from devices. </span><span class="koboSpan" id="kobo.201.2">The SNMP specification was first published in 1998 in RFC 2261 and was designed to be simple and fast.</span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.202.1">SNMP agents and managers</span></h2>
<p><span class="koboSpan" id="kobo.203.1">SNMP defines two identities:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.204.1">The manager (or server)</span></li>
<li><span class="koboSpan" id="kobo.205.1">The agent</span></li>
</ul>
<p><span class="koboSpan" id="kobo.206.1">The </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.207.1">agent is normally a network device and the</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.208.1"> manager is a network management system.</span></p>
<p><span class="koboSpan" id="kobo.209.1">SNMP uses UDP and TCP</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.210.1"> as transport protocols with ports </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">161</span></strong><span class="koboSpan" id="kobo.212.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">162</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">The UDP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">161</span></strong><span class="koboSpan" id="kobo.216.1"> is used to gather or set information in an on-demand manner, where the manager sends the request to the agent. </span><span class="koboSpan" id="kobo.216.2">The UDP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">162</span></strong><span class="koboSpan" id="kobo.218.1"> is used asynchronously without a request from the manager. </span><span class="koboSpan" id="kobo.218.2">The agent sends UDP packets to the server whenever necessary. </span><span class="koboSpan" id="kobo.218.3">This method is called an SNMP trap and is used to send unsolicited messages, such as alarms or threshold-level breaches.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.219.1">An SNMP MIB</span></h2>
<p><span class="koboSpan" id="kobo.220.1">As </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.221.1">described in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.222.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.223.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Management Information Base</span></strong><span class="koboSpan" id="kobo.225.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.226.1">MIB</span></strong><span class="koboSpan" id="kobo.227.1">) is </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.228.1">used as an identifier to access the network information variable. </span><span class="koboSpan" id="kobo.228.2">The identifier is known as</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.229.1"> an </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Object Identifier</span></strong><span class="koboSpan" id="kobo.231.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.232.1">OID</span></strong><span class="koboSpan" id="kobo.233.1">), as seen in </span><em class="italic"><span class="koboSpan" id="kobo.234.1">Figure 1.8</span></em><span class="koboSpan" id="kobo.235.1">.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.236.1">SNMP versions</span></h2>
<p><span class="koboSpan" id="kobo.237.1">SNMP comes with </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.238.1">version 1, version 2c, and version 3. </span><span class="koboSpan" id="kobo.238.2">They were published at different times, and the differences are the available methods, transport protocol, MIB variables, and cryptography. </span><span class="koboSpan" id="kobo.238.3">SNMP agents are compatible backward – therefore, an agent that supports version 3 can work with all versions. </span><span class="koboSpan" id="kobo.238.4">The following sections present a summary of each version.</span></p>
<h3><span class="koboSpan" id="kobo.239.1">SNMPv1</span></h3>
<p><span class="koboSpan" id="kobo.240.1">This is </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.241.1">the first version and contains most of the MIB variables and methods. </span><span class="koboSpan" id="kobo.241.2">It is based on UDP, using a community string as authentication. </span><span class="koboSpan" id="kobo.241.3">It only supported 32-bit MIB counters, which is a problem with fast interfaces, as the counter expires quickly.</span></p>
<h3><span class="koboSpan" id="kobo.242.1">SNMPv2c</span></h3>
<p><span class="koboSpan" id="kobo.243.1">Introduced</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.244.1"> 64-bit MIB variable counters and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">InformRequest</span></strong><span class="koboSpan" id="kobo.246.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">GetBulkRequest</span></strong><span class="koboSpan" id="kobo.248.1"> methods. </span><span class="koboSpan" id="kobo.248.2">Version 2 was not adopted because of security complexity. </span><span class="koboSpan" id="kobo.248.3">Version 2c was then published with simplifications and was widely accepted.</span></p>
<h3><span class="koboSpan" id="kobo.249.1">SNMPv3</span></h3>
<p><span class="koboSpan" id="kobo.250.1">Introduced cryptography</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.251.1"> for authentication and privacy. </span><span class="koboSpan" id="kobo.251.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Report</span></strong><span class="koboSpan" id="kobo.253.1"> method was added.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.254.1">SNMP primitive methods</span></h2>
<p><span class="koboSpan" id="kobo.255.1">SNMP essentially uses the</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.256.1"> following primitive methods.</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">GET</span></strong><span class="koboSpan" id="kobo.258.1">: Methods to gather information from the agent:</span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">GetRequest</span></strong><span class="koboSpan" id="kobo.260.1">: Given an OID, returns the variable associated with it</span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">GetNextRequest</span></strong><span class="koboSpan" id="kobo.262.1">: Given an OID, returns the next OID with the variable associated with it (used on an SNMP MIB walk function)</span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">GetBulkRequest</span></strong><span class="koboSpan" id="kobo.264.1">: Given an OID base, returns all OIDs and variables under this OID branch (sometimes causes long responses that can’t be interrupted)</span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">SET</span></strong><span class="koboSpan" id="kobo.266.1">: Methods to set a value on the agent:</span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">SetRequest</span></strong><span class="koboSpan" id="kobo.268.1">: Given an OID and a value, sets it on the MIB</span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Response</span></strong><span class="koboSpan" id="kobo.270.1">: All responses for </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">SET</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">GET</span></strong></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">TRAP</span></strong><span class="koboSpan" id="kobo.275.1">: Asynchronous information sent from the agent to the manager with an OID and a variable</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">InformRequest</span></strong><span class="koboSpan" id="kobo.277.1">: Used to </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.278.1">send asynchronous information with acknowledgment</span></li>
</ul>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.279.1">SNMP security issues</span></h2>
<p><span class="koboSpan" id="kobo.280.1">Because of a lack </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.281.1">of cryptography and authentication, SNMPv1 and v2 are vulnerable to IP spoofing attacks, which allow hackers to potentially send </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">SET</span></strong><span class="koboSpan" id="kobo.283.1"> requests to agents compromising the network. </span><span class="koboSpan" id="kobo.283.2">Historically, because of this security issue, SNMP is not used to write configuration and only gathers configuration using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">GET</span></strong><span class="koboSpan" id="kobo.285.1"> method or </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">TRAP</span></strong><span class="koboSpan" id="kobo.287.1">.</span></p>
<p><span class="koboSpan" id="kobo.288.1">Here are some pros and cons of</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.289.1"> using SNMP for network automation:</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.290.1">Pros</span></strong><span class="koboSpan" id="kobo.291.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.292.1">Easy to implement</span></li>
<li><span class="koboSpan" id="kobo.293.1">Fast</span></li>
<li><span class="koboSpan" id="kobo.294.1">Parallelism is easy</span></li>
<li><span class="koboSpan" id="kobo.295.1">No privileged</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.296.1"> access</span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.297.1">Cons</span></strong><span class="koboSpan" id="kobo.298.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.299.1">Requires </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.300.1">pooling to gather information frequently</span></li>
<li><span class="koboSpan" id="kobo.301.1">Not normally used for writing information</span></li>
<li><span class="koboSpan" id="kobo.302.1">Very limited scope of data coverage compared to a CLI</span></li>
<li><span class="koboSpan" id="kobo.303.1">Security</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.304.1"> issues when writing</span></li>
</ul>
<p><span class="koboSpan" id="kobo.305.1">As we saw in this section, SNMP is the oldest and most robust protocol for network management. </span><span class="koboSpan" id="kobo.305.2">Although it has security and scope problems for writing configurations, its protocol is light, fast, and easy to read. The following section will cover the protocol developed by the IETF working group to fill the gap in network management concerning configuration. </span><span class="koboSpan" id="kobo.305.3">It is called NETCONF.</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.306.1">Employing NETCONF</span></h1>
<p><span class="koboSpan" id="kobo.307.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">Network Configuration Protocol</span></strong><span class="koboSpan" id="kobo.309.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.310.1">NETCONF</span></strong><span class="koboSpan" id="kobo.311.1">) is a network management protocol developed and </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.312.1">standardized by the IETF in 2006. </span><span class="koboSpan" id="kobo.312.2">It provides mechanisms to install, manipulate, and delete the configuration of network devices.</span></p>
<p><span class="koboSpan" id="kobo.313.1">NETCONF operations </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.314.1">are implemented on top of a </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Remote Procedure Call</span></strong><span class="koboSpan" id="kobo.316.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.317.1">RPC</span></strong><span class="koboSpan" id="kobo.318.1">) layer. </span><span class="koboSpan" id="kobo.318.2">The NETCONF protocol uses </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">Extensible Markup Language </span></strong><span class="koboSpan" id="kobo.320.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">XML</span></strong><span class="koboSpan" id="kobo.322.1">)-based data</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.323.1"> encoding for the configuration data as well as the protocol messages. </span><span class="koboSpan" id="kobo.323.2">The protocol messages can also be exchanged on top of a secure transport protocol such as SSH (RFC 6242) or using TLS (RFC 7589).</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.324.1">Motivation</span></h2>
<p><span class="koboSpan" id="kobo.325.1">Up until the</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.326.1"> early part of the 21</span><span class="superscript"><span class="koboSpan" id="kobo.327.1">st</span></span><span class="koboSpan" id="kobo.328.1"> century, the only management protocol available from IETF was SNMP, which was developed in the late 1980s. </span><span class="koboSpan" id="kobo.328.2">It became clear that despite what was originally intended, SNMP was not being used to configure network equipment and was mainly being used for gathering network device information (as we have seen previously). </span><span class="koboSpan" id="kobo.328.3">The reasons are various, but mainly because SNMP was insecure and had a limited scope compared to a CLI for instance.</span></p>
<p><span class="koboSpan" id="kobo.329.1">In June 2002, the network management community and the Internet Architecture Board got together with network key operators to discuss the real situation on network management protocols and usage. </span><span class="koboSpan" id="kobo.329.2">The results of this meeting are documented in RFC 3535 (</span><a href="https://datatracker.ietf.org/doc/html/rfc3535"><span class="koboSpan" id="kobo.330.1">https://datatracker.ietf.org/doc/html/rfc3535</span></a><span class="koboSpan" id="kobo.331.1">).</span></p>
<p><span class="koboSpan" id="kobo.332.1">It turned out that network operators, instead of using SNMP, were primarily using different proprietary CLIs to configure their network devices. </span><span class="koboSpan" id="kobo.332.2">The reasons were various, including security issues and the lack of scope to configure or write configs because SNMP was too rigid to do so. </span></p>
<p><span class="koboSpan" id="kobo.333.1">On the other hand, around this time, Juniper Networks had started to use an XML-based network management approach, which was seen by IETF and the network operator community as an opportunity to combine efforts. </span><span class="koboSpan" id="kobo.333.2">This led to the creation of the NETCONF working group in May 2003.</span></p>
<p><span class="koboSpan" id="kobo.334.1">In </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.335.1">December 2006, with a lot of help from Juniper Networks, the first version of the base NETCONF protocol was published, RFC 4741 (</span><a href="https://datatracker.ietf.org/doc/html/rfc4741"><span class="koboSpan" id="kobo.336.1">https://datatracker.ietf.org/doc/html/rfc4741</span></a><span class="koboSpan" id="kobo.337.1">). </span><span class="koboSpan" id="kobo.337.2">After that, several extensions were published in subsequent years (RFC 5277, RFC 5717, RFC 6243, RFC 6470, and RFC 6536, among others). </span><span class="koboSpan" id="kobo.337.3">The last revised version of NETCONF is documented in RFC 6241, published in June 2011 (updated by RFC 7803 and RFC 8526).</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.338.1">OpenConfig</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.339.1">OpenConfig</span></strong><span class="koboSpan" id="kobo.340.1"> is</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.341.1"> an informal working group of network operators sharing the goal of moving our networks toward a more dynamic, programmable infrastructure by adopting SDN principles such as declarative configuration and model-driven management and operations.</span></p>
<p><span class="koboSpan" id="kobo.342.1">Our initial focus in OpenConfig is on compiling a consistent set of vendor-neutral data models – written</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.343.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">Yet Another Next Generation</span></strong><span class="koboSpan" id="kobo.345.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.346.1">YANG</span></strong><span class="koboSpan" id="kobo.347.1">) – based on the actual operational needs from use cases and requirements from multiple network operators.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.348.1">YANG</span></h2>
<p><span class="koboSpan" id="kobo.349.1">YANG is a </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.350.1">data modeling language that is used by the NETCONF protocol. </span><span class="koboSpan" id="kobo.350.2">YANG can be used to model both configuration data and state data from network devices. </span><span class="koboSpan" id="kobo.350.3">It is a modular language representing data structures in the XML format but can also be represented by other formats.</span></p>
<p><span class="koboSpan" id="kobo.351.1">For each network device feature, at least one RFC describes the data model with YANG – for instance, VRRP (in </span><a href="B18165_02.xhtml#_idTextAnchor041"><em class="italic"><span class="koboSpan" id="kobo.352.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.353.1">) describes the YANG data model in RFC 8347 (</span><a href="https://datatracker.ietf.org/doc/html/rfc8347"><span class="koboSpan" id="kobo.354.1">https://datatracker.ietf.org/doc/html/rfc8347</span></a><span class="koboSpan" id="kobo.355.1">). </span><span class="koboSpan" id="kobo.355.2">Another effort to cover network ACLs (see </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.356.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.357.1">) describes the YANG models in RFC 8519 (</span><a href="https://datatracker.ietf.org/doc/html/rfc8519"><span class="koboSpan" id="kobo.358.1">https://datatracker.ietf.org/doc/html/rfc8519</span></a><span class="koboSpan" id="kobo.359.1">).</span></p>
<p><span class="koboSpan" id="kobo.360.1">Let’s examine the characteristics of YANG and the details of the model a bit more closely.</span></p>
<h3><span class="koboSpan" id="kobo.361.1">The data modeling process is hard</span></h3>
<p><span class="koboSpan" id="kobo.362.1">It is important to understand that creating a YANG data model for a router function is not an easy task because it has to accommodate possible scenarios from the existing methods of all possible devices. </span><span class="koboSpan" id="kobo.362.2">So, it is not a fresh start from scratch, but the task of modeling functions that are already in use in several vendors and devices. </span><span class="koboSpan" id="kobo.362.3">Let’s take one example – the YANG data model</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.363.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Routing Policy</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">As you can see on the timeline shown in </span><em class="italic"><span class="koboSpan" id="kobo.366.1">Figure 3.5</span></em><span class="koboSpan" id="kobo.367.1">, the work started in 2015, and after more than 30 drafts, the standard</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.368.1"> was finally published in October 2021, which meant it took almost 7 years:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.369.1"><img alt="Figure 3.5 – Timeline for creating a YANG data model for Routing Policy" src="image/B18165_03_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.370.1">Figure 3.5 – Timeline for creating a YANG data model for Routing Policy</span></p>
<p><span class="koboSpan" id="kobo.371.1">It would be easier if each vendor had its own YANG data model, but then that would remove the general dependency.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.372.1">NETCONF</span></h2>
<p><span class="koboSpan" id="kobo.373.1">NETCONF</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.374.1"> uses client-server communication based on RPCs. </span><span class="koboSpan" id="kobo.374.2">With NETCONF, server configurations are stored in a NETCONF configuration datastore that follows a YANG data format specification. </span><span class="koboSpan" id="kobo.374.3">To change or update data, a client sends an XML-based remote procedure call over one of the secure transfer methods, and the server replies with XML-encoded data.</span></p>
<p><span class="koboSpan" id="kobo.375.1">NETCONF has four layers, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.376.1">Figure 3.6</span></em><span class="koboSpan" id="kobo.377.1">, extracted from the original RFC 6241:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.378.1"><img alt="Figure 3.6 – The four layers described in the RFC 6241" src="image/B18165_03_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.379.1">Figure 3.6 – The four layers described in the RFC 6241</span></p>
<p><span class="koboSpan" id="kobo.380.1">Let’s summarize each of the layers:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.381.1">Content</span></strong><span class="koboSpan" id="kobo.382.1"> layer: Consists </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.383.1">of configuration data and notification data. </span><span class="koboSpan" id="kobo.383.2">Valid content is defined in the YANG specification.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.384.1">Operations</span></strong><span class="koboSpan" id="kobo.385.1"> layer: This </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.386.1">layer is also defined by YANG. </span><span class="koboSpan" id="kobo.386.2">It details the type of action or query for a given NETCONF transaction. </span><span class="koboSpan" id="kobo.386.3">For example, you can use NETCONF to edit, delete, or copy configuration data. </span><span class="koboSpan" id="kobo.386.4">Valid operations are </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">get</span></strong><span class="koboSpan" id="kobo.388.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">get-config</span></strong><span class="koboSpan" id="kobo.390.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">edit-config</span></strong><span class="koboSpan" id="kobo.392.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">copy-config</span></strong><span class="koboSpan" id="kobo.394.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">delete-config</span></strong><span class="koboSpan" id="kobo.396.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">lock</span></strong><span class="koboSpan" id="kobo.398.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">unlock</span></strong><span class="koboSpan" id="kobo.400.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">close-session</span></strong><span class="koboSpan" id="kobo.402.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">kill-session</span></strong><span class="koboSpan" id="kobo.404.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.405.1">Messages</span></strong><span class="koboSpan" id="kobo.406.1"> layer: Provides </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.407.1">a mechanism for encoding </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">remote procedure calls</span></strong><span class="koboSpan" id="kobo.409.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.410.1">RPCs</span></strong><span class="koboSpan" id="kobo.411.1">). </span><span class="koboSpan" id="kobo.411.2">A message may be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">&lt;rpc&gt;</span></strong><span class="koboSpan" id="kobo.413.1"> request from a client or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">&lt;rpc-reply&gt;</span></strong><span class="koboSpan" id="kobo.415.1"> from a server. </span><span class="koboSpan" id="kobo.415.2">RFC6241 also added notifications to this layer.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.416.1">Secure Transport</span></strong><span class="koboSpan" id="kobo.417.1"> layer: This </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.418.1">layer deals with the protocols used to transmit NETCONF messages. </span><span class="koboSpan" id="kobo.418.2">SSH, TLS, and HTTP are a few of the protocols associated with this layer.</span></li>
</ul>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.419.1">RESTCONF</span></h2>
<p><span class="koboSpan" id="kobo.420.1">The RESTCONF protocol</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.421.1"> is a proposed standard defined in RFC 8040 (</span><a href="https://www.rfc-editor.org/rfc/rfc8040.html"><span class="koboSpan" id="kobo.422.1">https://www.rfc-editor.org/rfc/rfc8040.html</span></a><span class="koboSpan" id="kobo.423.1">). </span><span class="koboSpan" id="kobo.423.2">NETCONF and RESTCONF are similar in terms of their capabilities, but RESTCONF came later in 2017 with a </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.425.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.426.1">REST</span></strong><span class="koboSpan" id="kobo.427.1">)</span><strong class="bold"><span class="koboSpan" id="kobo.428.1">ful API</span></strong><span class="koboSpan" id="kobo.429.1"> model</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.430.1"> using HTTP. </span><span class="koboSpan" id="kobo.430.2">They both allow administrators to query information or modify settings using a client-server model. </span><span class="koboSpan" id="kobo.430.3">RESTCONF is different in a few key ways:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.431.1">RESTCONF uses HTTP</span></li>
<li><span class="koboSpan" id="kobo.432.1">RESTCONF supports both JSON and XML</span></li>
<li><span class="koboSpan" id="kobo.433.1">RESTCONF does not have the concept of transaction and therefore does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">lock</span></strong><span class="koboSpan" id="kobo.435.1"> concept as NETCONF does</span></li>
</ul>
<p><span class="koboSpan" id="kobo.436.1">RESTCONF is not intended to replace NETCONF. </span><span class="koboSpan" id="kobo.436.2">Rather, it was created to allow the use of a RESTful API that can be used to query and configure devices with NETCONF or YANG configuration datastores.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.437.1">Figure 3.7</span></em><span class="koboSpan" id="kobo.438.1"> shows a table extracted from RFC 8040 that demonstrates the overlap between RESTCONF and NETCONF calls:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.439.1"><img alt="Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from RFC 8040" src="image/B18165_03_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from RFC 8040</span></p>
<p><span class="koboSpan" id="kobo.441.1">Here </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.442.1">are some </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.443.1">pros and cons of using NETCONF or RESTCONF:</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.444.1">Pros</span></strong><span class="koboSpan" id="kobo.445.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.446.1">Incorporate network specification</span></li>
<li><span class="koboSpan" id="kobo.447.1">IETF standards</span></li>
<li><span class="koboSpan" id="kobo.448.1">No privileged access</span></li>
<li><span class="koboSpan" id="kobo.449.1">Allow stream event notifications</span></li>
<li><span class="koboSpan" id="kobo.450.1">Programmatic device configuration</span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.451.1">Cons</span></strong><span class="koboSpan" id="kobo.452.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.453.1">Not all </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.454.1">device </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.455.1">capabilities are covered in YANG</span></li>
<li><span class="koboSpan" id="kobo.456.1">Adoption of NETCONF has been really slow</span></li>
<li><span class="koboSpan" id="kobo.457.1">NETCONF transport is limited and implementation is old</span></li>
<li><span class="koboSpan" id="kobo.458.1">Not </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.459.1">that</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.460.1"> efficient</span></li>
</ul>
<p><span class="koboSpan" id="kobo.461.1">This section summarizes how NETCONF, RESTCONF, and YANG are used to interact with network devices. </span><span class="koboSpan" id="kobo.461.2">The transaction states of NETCONF make it a powerful tool for network configuration. </span><span class="koboSpan" id="kobo.461.3">Despite its good base of IETF standards, NETCONF is not efficient enough to handle some of the network automation we want, such as collecting data at a high-frequency rate. In the following section, we are going to explore a newer protocol called gRPC.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.462.1">Adopting gRPC</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.463.1">gRPC</span></strong><span class="koboSpan" id="kobo.464.1"> was </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.465.1">published in 2015 as an open source RPC framework. </span><span class="koboSpan" id="kobo.465.2">It is one of the most promising protocols to be used in automation because it is easy to create a program and add methods to obtain or set configuration on the network device.</span></p>
<p><span class="koboSpan" id="kobo.466.1">gRPC does not directly use TCP for transport, but  HTTP/2 instead, which was published in 2015 to overcome the limitations of HTTP/1.1. </span><span class="koboSpan" id="kobo.466.2">While it is backward compatible with HTTP/1.1, HTTP/2 brings many added advanced capabilities, such as the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.467.1">Binary framing layer</span></strong><span class="koboSpan" id="kobo.468.1">: Request </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.469.1">and response is divided into small messages and framed in binary format, making message transmission efficient</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.470.1">Bidirectional full-duplex streaming</span></strong><span class="koboSpan" id="kobo.471.1">: Here, the client can request and the server can respond simultaneously</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.472.1">Flow control (used in HTTP/2)</span></strong><span class="koboSpan" id="kobo.473.1">: Enables the detailed control of memory used for the network buffers</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.474.1">Header compression</span></strong><span class="koboSpan" id="kobo.475.1">: Everything in HTTP/2, including headers, is encoded before it is sent, significantly improving performance</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.476.1">Asynchronous and synchronous processing</span></strong><span class="koboSpan" id="kobo.477.1">: Can be used to perform different types of interaction and</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.478.1"> streaming RPCs</span></li>
</ul>
<p><span class="koboSpan" id="kobo.479.1">All these features of HTTP/2 enable gRPC to use fewer resources, resulting in reduced response times between clients and servers.</span></p>
<p><span class="koboSpan" id="kobo.480.1">To ensure the security of gRPC, TLS end-to-end encryption can be used, and authentication can use SSL or TLS with or without token-based authentication or the need to define your own authentication system by extending the provided code (more on authentication can be</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.481.1"> found at </span><a href="https://grpc.io/docs/guides/auth/"><span class="koboSpan" id="kobo.482.1">https://grpc.io/docs/guides/auth/</span></a><span class="koboSpan" id="kobo.483.1">).</span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.484.1">The letter g</span></h2>
<p><span class="koboSpan" id="kobo.485.1">Initially, in</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.486.1"> version 1.0 of the protocol, the letter </span><em class="italic"><span class="koboSpan" id="kobo.487.1">g</span></em><span class="koboSpan" id="kobo.488.1"> was a recursive reference to the name gRPC, but as later versions were published, another word was added, making the name a bit of code entertainment. </span><span class="koboSpan" id="kobo.488.2">For instance, in version 1.1, the word was </span><em class="italic"><span class="koboSpan" id="kobo.489.1">good</span></em><span class="koboSpan" id="kobo.490.1">, in version 1.2, it was </span><em class="italic"><span class="koboSpan" id="kobo.491.1">green</span></em><span class="koboSpan" id="kobo.492.1">, and for version 1.42, it was </span><em class="italic"><span class="koboSpan" id="kobo.493.1">granola</span></em><span class="koboSpan" id="kobo.494.1">. </span><span class="koboSpan" id="kobo.494.2">A complete list of names used for the letter </span><em class="italic"><span class="koboSpan" id="kobo.495.1">g</span></em><span class="koboSpan" id="kobo.496.1"> can be found in the gRPC source code here: </span><a href="https://grpc.github.io/grpc/core/md_doc_g_stands_for.html"><span class="koboSpan" id="kobo.497.1">https://grpc.github.io/grpc/core/md_doc_g_stands_for.html</span></a><span class="koboSpan" id="kobo.498.1">.</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.499.1">Motivation</span></h2>
<p><span class="koboSpan" id="kobo.500.1">Google has used </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.501.1">a single general-purpose RPC </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.502.1">infrastructure called </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Stubby</span></strong><span class="koboSpan" id="kobo.504.1"> to connect the large number of microservices running within and across Google data centers for more than a decade. </span><span class="koboSpan" id="kobo.504.2">That motivated Google to publish and sponsor the creation of gRPC.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.505.1">Letter from the gRPC team on Monday, October 26, 2015</span></p>
<p class="callout"><em class="italic"><span class="koboSpan" id="kobo.506.1">The gRPC team is excited to announce the immediate availability of gRPC Beta. </span><span class="koboSpan" id="kobo.506.2">This release represents a major step forward in API stability, with most API changes in the future being additive in nature. It opens the door for gRPC use in production environments.</span></em></p>
<p class="callout"><em class="italic"><span class="koboSpan" id="kobo.507.1">We updated grpc.io documentation to reflect the latest changes and released language-specific reference documentation. </span><span class="koboSpan" id="kobo.507.2">In the release notes on GitHub for Java, Go, and all other languages, you will find information on what has changed.</span></em></p>
<p class="callout"><em class="italic"><span class="koboSpan" id="kobo.508.1">We would like to thank everyone who contributed code, gave presentations, adopted the technology, and participated in the community. </span><span class="koboSpan" id="kobo.508.2">We look forward to 1.0 with your support!</span></em></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.509.1">Overview</span></h2>
<p><span class="koboSpan" id="kobo.510.1">gRPC </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.511.1">uses the concept of a client and server application. </span><span class="koboSpan" id="kobo.511.2">Client applications can directly invoke server applications on remote machines just as if they were local objects. </span><span class="koboSpan" id="kobo.511.3">gRPC is based on the idea of defining a service and specifying methods that can be called remotely using their parameters and return types. </span><span class="koboSpan" id="kobo.511.4">The server implements this interface and runs a gRPC server to handle client calls. </span><span class="koboSpan" id="kobo.511.5">The client has a stub (just referred to as a client in some languages) that provides the same methods as the server.</span></p>
<p><span class="koboSpan" id="kobo.512.1">In the world of network automation, the gRCP client is actually our automation software and the gRPC server is the network device, as illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.513.1">Figure 3.8</span></em><span class="koboSpan" id="kobo.514.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.515.1"><img alt="Figure 3.8 – Basic request and response for gRPC" src="image/B18165_03_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.516.1">Figure 3.8 – Basic request and response for gRPC</span></p>
<p><span class="koboSpan" id="kobo.517.1">The gRPC </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.518.1">server and client are not required to use the same programming language. </span><span class="koboSpan" id="kobo.518.2">Today, there are several implementations of different languages, whether Go, Python, Java, or Ruby. </span><span class="koboSpan" id="kobo.518.3">A complete list of the languages supported </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.519.1">can be found here: </span><a href="https://grpc.io/docs/languages/"><span class="koboSpan" id="kobo.520.1">https://grpc.io/docs/languages/</span></a><span class="koboSpan" id="kobo.521.1">.</span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.522.1">Protobuf</span></h2>
<p><span class="koboSpan" id="kobo.523.1">By</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.524.1"> default, gRPC uses </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">Protocol Buffers</span></strong><span class="koboSpan" id="kobo.526.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Protobuf</span></strong><span class="koboSpan" id="kobo.528.1">), which is </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.529.1">another open source mechanism for serializing data created by Google. </span><span class="koboSpan" id="kobo.529.2">Although Protobuf is the default, gRPC can also use JSON instead, but that is less efficient, as we are going to see.</span></p>
<p><span class="koboSpan" id="kobo.530.1">Protobuf is a</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.531.1"> language- and platform-neutral mechanism for</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.532.1"> serializing data, like JSON or XML but much smaller, faster, and simpler. </span><span class="koboSpan" id="kobo.532.2">The structure of the data is defined once and then a specially generated source code is used to easily write and read this structured data from a variety of data streams with any programming language.</span></p>
<p><span class="koboSpan" id="kobo.533.1">More about</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.534.1"> Protobuf can be found here: </span><a href="https://developers.google.com/protocol-buffers"><span class="koboSpan" id="kobo.535.1">https://developers.google.com/protocol-buffers</span></a><span class="koboSpan" id="kobo.536.1">.</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.537.1">gRPC and network telemetry</span></h2>
<p><span class="koboSpan" id="kobo.538.1">During our network </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.539.1">automation work, we are going to experience a series of limitations, especially in gathering network information in an effective way. </span><span class="koboSpan" id="kobo.539.2">So, let’s explore the following example.</span></p>
<p><span class="koboSpan" id="kobo.540.1">Imagine a network with 500 devices, with 50 interfaces on each device on average. </span><span class="koboSpan" id="kobo.540.2">Each interface needs to gather multiple variables, such as the current state, the error rate, drop counts, packet-in counts, or packet-out counts. </span><span class="koboSpan" id="kobo.540.3">If we consider a conservative approach, such as only collecting 10 variables per interface, for this network example, we are going to gather information from 10 variables x 50 interfaces x 500 devices, which adds up to 250,000 variables.</span></p>
<p><span class="koboSpan" id="kobo.541.1">The other point to consider is the frequency of the data. </span><span class="koboSpan" id="kobo.541.2">In the 90s, network management required information from the network every 5 minutes and that was sufficient for handling failures and troubleshooting, but nowadays, the interval is much smaller. </span><span class="koboSpan" id="kobo.541.3">We are looking to gather information at intervals of less than 1 minute, ideally every 30 or 10 seconds. </span><span class="koboSpan" id="kobo.541.4">The reason is that troubleshooting and failure resolution can occur faster when detecting failures quickly.</span></p>
<p><span class="koboSpan" id="kobo.542.1">So, in our example, 250,000 variables every 10 seconds give us an enormous amount of data using traditional polling mechanisms such as SNMP. </span><span class="koboSpan" id="kobo.542.2">However, one important point to note here is most of the content of the variables might not change at all, such as the counters for interfaces when there is no traffic, the state of the interface when nothing has changed, the interface discard counter when there aren’t any, or the error rate when the interface is perfectly fine. </span><span class="koboSpan" id="kobo.542.3">Therefore, several or even the majority of the contents of the network variables are not going to change that often, meaning that pooling mechanisms are inefficient and accumulate redundant information over time. </span><span class="koboSpan" id="kobo.542.4">What would be better than polling? </span><span class="koboSpan" id="kobo.542.5">Streaming telemetry. </span><span class="koboSpan" id="kobo.542.6">Streaming telemetry allows devices to send incremental updates continuously as soon as changes occur. In this way, the collection of network information can be done more effectively than with pooling.</span></p>
<p><span class="koboSpan" id="kobo.543.1">gRPC supports</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.544.1"> bidirectional streaming, which gives this protocol a huge advantage compared to the others we saw so far for data collection.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.545.1">Code examples using gRPC</span></h2>
<p><span class="koboSpan" id="kobo.546.1">To make the example </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.547.1">more realistic for network automation, let’s have a service on the routers that can return the following information:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.548.1">Return the memory utilization in percent</span></li>
<li><span class="koboSpan" id="kobo.549.1">Return the CPU utilization in percent</span></li>
<li><span class="koboSpan" id="kobo.550.1">Return the router uptime in seconds</span></li>
</ul>
<p><span class="koboSpan" id="kobo.551.1">Our examples will create a client gRPC stub to communicate to the router, which will be the gRPC server, as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.552.1">Figure 3.8</span></em><span class="koboSpan" id="kobo.553.1">. </span><span class="koboSpan" id="kobo.553.2">We are only going to demonstrate the client side and we are going to assume the gRPC server on the router has already been implemented.</span></p>
<h3><span class="koboSpan" id="kobo.554.1">The Protobuf file</span></h3>
<p><span class="koboSpan" id="kobo.555.1">The Protobuf file</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.556.1"> definition is a single part of the code that is not tied to any language. </span><span class="koboSpan" id="kobo.556.2">The</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.557.1"> same file definition is used on the client and the server. </span><span class="koboSpan" id="kobo.557.2">It is compiled once and feeds the client and server programs to interpret the data used to generate the RPCs. </span><span class="koboSpan" id="kobo.557.3">For our example, the Protobuf file would look as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
service RouterStatus {
  rpc GetStatus (StatusRequest) returns (StatusReply);
}
message StatusRequest {}
message StatusReply {
  double memory = 1;
  double cpu = 2;
  int32 uptime = 3;
} </span></pre>
<h3><span class="koboSpan" id="kobo.559.1">An example using Python</span></h3>
<p><span class="koboSpan" id="kobo.560.1">Here is an example </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.561.1">using Python. </span><span class="koboSpan" id="kobo.561.2">The import name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">r_grpc</span></strong><span class="koboSpan" id="kobo.563.1">, compiles the code for Python from the Protobuf file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
import grpc
import routerstatus_pb2
import routerstatus_pb2_grpc as r_grpc
def run():
    address = "router:50051"
    with grpc.insecure_channel(address) as channel:
        stub = r_grpc.StatusStub(channel)
        r = stub.GetStatus(r_grpc.StatusRequest())
        print("Memory:{.2f}% CPU:{.2f}%, Uptime:{d}s\n".format(r.memory, r.cpu, r.uptime))
if __name__ == '__main__':
    run()</span></pre>
<h3><span class="koboSpan" id="kobo.565.1">An example using Go</span></h3>
<p><span class="koboSpan" id="kobo.566.1">Here is an </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.567.1">example using a Go program client. </span><span class="koboSpan" id="kobo.567.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">pb</span></strong><span class="koboSpan" id="kobo.569.1"> (used on the import) is the code compiled for the Protobuf:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
import (
    "context"
    "log"
    "time"
    "fmt"
    "google.golang.org/grpc"
    pb "example/routerstatus"
)
func main() {
    address = "router:50051"
    // Set up a connection to the server.
</span><span class="koboSpan" id="kobo.570.2">    conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())
    if err != nil {
        log.Fatalf("did not connect: %v", err)
    }
    c := pb.NewStatusClient(conn)
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()
    r, err := c.GetStatus(ctx, &amp;pb.StatusRequest{})
    if err != nil {
        log.Fatalf("could not get router status: %v", err)
    }
    fmt.Printf("CPU:%.2f%%, Memory:%.2f%%, Uptime:%ds", r.GetCpu(), r.GetMemory(), r.GetUptime())
}</span></pre>
<p><span class="koboSpan" id="kobo.571.1">Here are some </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.572.1">pros and cons of using gRPC for network automation:</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.573.1">Pros</span></strong><span class="koboSpan" id="kobo.574.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.575.1">Secure</span></li>
<li><span class="koboSpan" id="kobo.576.1">Fast</span></li>
<li><span class="koboSpan" id="kobo.577.1">Parallelism is easy</span></li>
<li><span class="koboSpan" id="kobo.578.1">No privileged access is possible</span></li>
<li><span class="koboSpan" id="kobo.579.1">Flexible and can expose any local device command using the gRPC server</span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.580.1">Cons</span></strong><span class="koboSpan" id="kobo.581.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.582.1">Not many</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.583.1"> network devices have gRPC capability</span></li>
</ul>
<p><span class="koboSpan" id="kobo.584.1">In this section, we saw that gRPC is a powerful protocol to use for network automation. </span><span class="koboSpan" id="kobo.584.2">However, it is not well integrated into network devices yet. </span><span class="koboSpan" id="kobo.584.3">The majority of the new operating systems on network devices come with this capability. In the next section, a higher-level protocol called gNMI will be used to make better use of the gRPC protocol for network automation.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.585.1">Operating with gNMI</span></h1>
<p><span class="koboSpan" id="kobo.586.1">As we saw before, gRPC is probably the most appropriate protocol for working with devices in terms of performance. </span><span class="koboSpan" id="kobo.586.2">However, it is actually a generic protocol to be used in any client and server interaction – not only network devices but also computer servers. </span><span class="koboSpan" id="kobo.586.3">For this reason, </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">gRPC Network Management Interface</span></strong><span class="koboSpan" id="kobo.588.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.589.1">gNMI</span></strong><span class="koboSpan" id="kobo.590.1">) was created.</span></p>
<p><span class="koboSpan" id="kobo.591.1">gNMI is an</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.592.1"> open source protocol specification created by the OpenConfig working group that is used to communicate to and from network devices using YANG (discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.593.1">NETCONF</span></em><span class="koboSpan" id="kobo.594.1"> section). </span><span class="koboSpan" id="kobo.594.2">In other words, gNMI was created to utilize the good work done by people defining the network specification data using YANG but with a more modern protocol such as gRPC instead of NETCONF.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.595.1">Protocol layers</span></h2>
<p><span class="koboSpan" id="kobo.596.1">gNMI uses gRPC. </span><span class="koboSpan" id="kobo.596.2">For that, it </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.597.1">has to translate the YANG data description into Protobuf to serialize the communication, as illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.598.1">Figure 3.9</span></em><span class="koboSpan" id="kobo.599.1">. </span><span class="koboSpan" id="kobo.599.2">At the bottom of the diagram is a normal gRPC connection over HTTP/2 and TLS. </span><span class="koboSpan" id="kobo.599.3">The gRPC code is auto-generated from the gNMI Protobuf model and gNMI carries the data modeled in YANG, which can support encoding in JSON, like the example below.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.600.1"><img alt="Figure 3.9 – gNMI protocol layers" src="image/B18165_03_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.601.1">Figure 3.9 – gNMI protocol layers</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.602.1">The data model</span></h2>
<p><span class="koboSpan" id="kobo.603.1">gNMI uses a data model called </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">path</span></strong><span class="koboSpan" id="kobo.605.1"> for </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.606.1">encoding and decoding. </span><span class="koboSpan" id="kobo.606.2">Path encoding in gNMI uses a</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.607.1"> structured format and is encoded as an ordered list (such as a slice or array) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">PathElem</span></strong><span class="koboSpan" id="kobo.609.1"> messages. </span><span class="koboSpan" id="kobo.609.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">PathElem</span></strong><span class="koboSpan" id="kobo.611.1"> consists of a name encoded as a string. </span><span class="koboSpan" id="kobo.611.2">An element’s name must be encoded as a </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">UTF-8</span></strong><span class="koboSpan" id="kobo.613.1"> string. </span><span class="koboSpan" id="kobo.613.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">PathElem</span></strong><span class="koboSpan" id="kobo.615.1"> may optionally specify a set of keys, specified as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">map&lt;string,string&gt;</span></strong><span class="koboSpan" id="kobo.617.1"> (dictionary or map).   </span></p>
<p><span class="koboSpan" id="kobo.618.1">The root path, </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">/</span></strong><span class="koboSpan" id="kobo.620.1">, is encoded as a zero-length array (slice) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">PathElem</span></strong><span class="koboSpan" id="kobo.622.1"> messages. </span><span class="koboSpan" id="kobo.622.2">Here are some example declarations in Go and Python:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.623.1">Go</span></strong><span class="koboSpan" id="kobo.624.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">path := []*PathElem{}</span></strong></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.626.1">Python</span></strong><span class="koboSpan" id="kobo.627.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">path = []</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.629.1">A human-readable path can be formed by concatenating elements of the prefix and path using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">/</span></strong><span class="koboSpan" id="kobo.631.1"> separator. </span></p>
<p><span class="koboSpan" id="kobo.632.1">So, let’s see the following representation: </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">/interfaces/interface[name=Ethernet1/2/3]/state.</span></strong></p>
<p><span class="koboSpan" id="kobo.634.1">This is specified as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
&lt;elem: &lt;name: "interfaces”&gt;elem: &lt;name: "interface"key: &lt;key: "name”value: "Ethernet1/2/3"&gt;&gt;elem: &lt;name: "state"&gt;&gt;</span></pre>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.636.1">The communication model</span></h2>
<p><span class="koboSpan" id="kobo.637.1">The </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.638.1">communication model uses a target and client as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.639.1">Target</span></strong><span class="koboSpan" id="kobo.640.1">: The</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.641.1"> device within the gNMI that acts as the owner of the data that is being manipulated or collected. </span><span class="koboSpan" id="kobo.641.2">Typically, this is our network device.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">Client or collector:</span></strong><span class="koboSpan" id="kobo.643.1"> The </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.644.1">system using the gNMI to query or modify data on the target or act as a collector for streamed data. </span><span class="koboSpan" id="kobo.644.2">Typically, this is the network management system or our automation code.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.645.1">Similar to gRPC, the</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.646.1"> server actually is on the network device, as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.647.1">Figure 3.10</span></em><span class="koboSpan" id="kobo.648.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.649.1"><img alt="Figure 3.10 – gNMI ﻿target and ﻿client communication" src="image/B18165_03_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.650.1">Figure 3.10 – gNMI target and client communication</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.651.1">Service definition</span></h2>
<p><span class="koboSpan" id="kobo.652.1">The gNMI </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.653.1">service is based on RPC calls called </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Capabilities</span></strong><span class="koboSpan" id="kobo.655.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">Get</span></strong><span class="koboSpan" id="kobo.657.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Set</span></strong><span class="koboSpan" id="kobo.659.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Subscribe</span></strong><span class="koboSpan" id="kobo.661.1">, which will be detailed in the following sections.</span></p>
<h3><span class="koboSpan" id="kobo.662.1">Capabilities RPC</span></h3>
<p><span class="koboSpan" id="kobo.663.1">A client can discover the capabilities of the </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.664.1">target using the </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">Capabilities RPC</span></strong><span class="koboSpan" id="kobo.666.1">. </span><span class="koboSpan" id="kobo.666.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">CapabilityRequest</span></strong><span class="koboSpan" id="kobo.668.1"> message is sent by the client to interrogate the target. </span><span class="koboSpan" id="kobo.668.2">The target must then reply with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">CapabilityResponse</span></strong><span class="koboSpan" id="kobo.670.1"> message that includes its gNMI service version, the versioned data models it supports, and the supported data encodings. </span><span class="koboSpan" id="kobo.670.2">This information is used in subsequent RPC messages from the client to indicate the set of models that the client will use for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Get</span></strong><span class="koboSpan" id="kobo.672.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Subscribe</span></strong><span class="koboSpan" id="kobo.674.1"> RPC calls and the encoding to be used for the data.</span></p>
<h3><span class="koboSpan" id="kobo.675.1">Get RPC</span></h3>
<p><span class="koboSpan" id="kobo.676.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">Get RPC</span></strong><span class="koboSpan" id="kobo.678.1"> provides</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.679.1"> an interface where a client can request a set of paths to be serialized and transmitted to it by the target. </span><span class="koboSpan" id="kobo.679.2">The client sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">GetRequest</span></strong><span class="koboSpan" id="kobo.681.1"> message to the target, specifying the path that is to be retrieved. </span><span class="koboSpan" id="kobo.681.2">Upon reception of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">GetRequest</span></strong><span class="koboSpan" id="kobo.683.1"> message, the target serializes the requested path and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">GetResponse</span></strong><span class="koboSpan" id="kobo.685.1"> message. </span><span class="koboSpan" id="kobo.685.2">This connection is short-lived and the target closes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Get</span></strong><span class="koboSpan" id="kobo.687.1"> RPC following the transmission of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">GetResponse</span></strong><span class="koboSpan" id="kobo.689.1"> message.</span></p>
<h3><span class="koboSpan" id="kobo.690.1">Set RPC</span></h3>
<p><span class="koboSpan" id="kobo.691.1">Modifications to the state</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.692.1"> of the target are made through the </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">Set RPC</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="koboSpan" id="kobo.694.2">A client sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">SetRequest</span></strong><span class="koboSpan" id="kobo.696.1"> message to the target indicating the modifications it desires.</span></p>
<p><span class="koboSpan" id="kobo.697.1">A target receiving a </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">SetRequest</span></strong><span class="koboSpan" id="kobo.699.1"> message processes the operations specified within it, which are treated as a transaction. </span><span class="koboSpan" id="kobo.699.2">In response to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">SetRequest</span></strong><span class="koboSpan" id="kobo.701.1"> message, the target must respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">SetResponse</span></strong><span class="koboSpan" id="kobo.703.1"> message. </span><span class="koboSpan" id="kobo.703.2">For each operation specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">SetReques</span></strong><span class="koboSpan" id="kobo.705.1">t message, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">UpdateResult</span></strong><span class="koboSpan" id="kobo.707.1"> message must be included in the response field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">SetResponse</span></strong><span class="koboSpan" id="kobo.709.1">.</span></p>
<h3><span class="koboSpan" id="kobo.710.1">Subscribe RPC</span></h3>
<p><span class="koboSpan" id="kobo.711.1">This </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.712.1">perhaps is the most important call on the gNMI because it is the one that allows Streaming Telemetry, as discussed before.  </span></p>
<p><span class="koboSpan" id="kobo.713.1">When a client wishes to receive updates relating to the state of data instances on a target, it creates a subscription via the </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">Subscribe RPC</span></strong><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">A subscription consists of one or more paths, with a specified subscription mode. </span><span class="koboSpan" id="kobo.715.3">The mode of each subscription determines the triggers for updates to the data sent from the target to the client.</span></p>
<p><span class="koboSpan" id="kobo.716.1">All requests for new subscriptions are encapsulated within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">SubscribeRequest</span></strong><span class="koboSpan" id="kobo.718.1"> message, which itself has a mode describing the longevity of the subscription. </span><span class="koboSpan" id="kobo.718.2">A client may create a subscription that has a dedicated stream to return one-off data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">ONCE</span></strong><span class="koboSpan" id="kobo.720.1">); a subscription that utilizes a stream to periodically request a set of data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">POLL</span></strong><span class="koboSpan" id="kobo.722.1">); or a long-lived subscription that streams data according to the triggers specified within the individual subscription’s mode (</span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">STREAM</span></strong><span class="koboSpan" id="kobo.724.1">). </span><span class="koboSpan" id="kobo.724.2">For Streaming Telemetry, the mode is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">STREAM</span></strong><span class="koboSpan" id="kobo.726.1">.</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.727.1">gNMI-gateway</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.728.1">gNMI-gateway</span></strong><span class="koboSpan" id="kobo.729.1"> is </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.730.1">open source software that was initially developed by Netflix and then released as part of the OpenConfig working group to collect and distribute OpenConfig-modeled gNMI data from network devices. </span></p>
<p><span class="koboSpan" id="kobo.731.1">The motivations to create gNMI-gateway were various, as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.732.1">First, there were not many open source services available to consume and distribute OpenConfig-modeled gNMI Streaming Telemetry data.</span></li>
<li><span class="koboSpan" id="kobo.733.1">Second, there was a lack of failure tolerance for the client and target connection using gNMI data streaming, making Streaming Telemetry vulnerable. </span><span class="koboSpan" id="kobo.733.2">As the client dies, the streamed data is lost until another subscription takes place.</span></li>
<li><span class="koboSpan" id="kobo.734.1">The third was the lack of supporting multiple consumers. </span><span class="koboSpan" id="kobo.734.2">If multiple departments in a company want data from a network device or a group of network devices, it would be necessary for all of them to send subscriptions to the targets. </span><span class="koboSpan" id="kobo.734.3">With clustering functionality and replication in gNMI-gateway, it is possible to avoid unnecessarily duplicating gNMI connections to targets and offer the same data to multiple customers.</span></li>
<li><span class="koboSpan" id="kobo.735.1">Fourth, there was a lack of unifying gNMI clients with non-gNMI clients. </span><span class="koboSpan" id="kobo.735.2">gNMI-gateway allows either </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.736.1">gNMI clients or non-gNMI clients to gather information.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.737.1">Figure 3.11</span></em><span class="koboSpan" id="kobo.738.1"> shows</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.739.1"> a single instance of gNMI-gateway with gNMI clients and non-gNMI clients, also known as exporters. </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">Apache Kafta</span></strong><span class="koboSpan" id="kobo.741.1"> (</span><a href="https://kafka.apache.org/"><span class="koboSpan" id="kobo.742.1">https://kafka.apache.org/</span></a><span class="koboSpan" id="kobo.743.1">) is one </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.744.1">piece of software that can be used as an exporter; another one already</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.745.1"> implemented is </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">Prometheus</span></strong><span class="koboSpan" id="kobo.747.1"> (</span><a href="https://prometheus.io/"><span class="koboSpan" id="kobo.748.1">https://prometheus.io/</span></a><span class="koboSpan" id="kobo.749.1">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.750.1"><img alt="Figure 3.11 – A single instance of gNMI-gateway" src="image/B18165_03_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.751.1">Figure 3.11 – A single instance of gNMI-gateway</span></p>
<p><span class="koboSpan" id="kobo.752.1">The redundancy can be obtained by using multiple instances of gNMI-gateway which is implemented</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.753.1"> by using </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">Apache Zookeeper</span></strong><span class="koboSpan" id="kobo.755.1"> (</span><a href="https://zookeeper.apache.org/"><span class="koboSpan" id="kobo.756.1">https://zookeeper.apache.org/</span></a><span class="koboSpan" id="kobo.757.1">), as illustrated in </span><em class="italic"><span class="koboSpan" id="kobo.758.1">Figure 3.12</span></em><span class="koboSpan" id="kobo.759.1">. </span><span class="koboSpan" id="kobo.759.2">If only one instance is running, there is no need to use Apache Zookeeper:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.760.1"><img alt="Figure 3.12 – Multiple instances of gNMI-gateway" src="image/B18165_03_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.761.1">Figure 3.12 – Multiple instances of gNMI-gateway</span></p>
<p><span class="koboSpan" id="kobo.762.1">More on gNMI-gateway</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.763.1"> can be found here: </span><a href="https://github.com/openconfig/gnmi"><span class="koboSpan" id="kobo.764.1">https://github.com/openconfig/gnmi</span></a><span class="koboSpan" id="kobo.765.1">.</span></p>
<p><span class="koboSpan" id="kobo.766.1">For reference, here is a full presentation on gNMI-gateway presented at 2020’s NANOG Webcast: </span><a href="https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/"><span class="koboSpan" id="kobo.767.1">https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/</span></a><span class="koboSpan" id="kobo.768.1">.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.769.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.770.1">Full specification on</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.771.1"> gNMI can be found here: </span><a href="https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md"><span class="koboSpan" id="kobo.772.1">https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md</span></a><span class="koboSpan" id="kobo.773.1">.</span></p>
<p><span class="koboSpan" id="kobo.774.1">Here are some pros and cons of using</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.775.1"> gNMI for network automation:</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.776.1">Pros</span></strong><span class="koboSpan" id="kobo.777.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.778.1">Secure</span></li>
<li><span class="koboSpan" id="kobo.779.1">Fast</span></li>
<li><span class="koboSpan" id="kobo.780.1">Parallelism is easy</span></li>
<li><span class="koboSpan" id="kobo.781.1">No privileged access is possible</span></li>
<li><span class="koboSpan" id="kobo.782.1">Incorporates YANG specification for networking</span></li>
<li><span class="koboSpan" id="kobo.783.1">Allows easy Streaming Telemetry</span></li>
<li><span class="koboSpan" id="kobo.784.1">Capable of </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.785.1">adding gNMI-gateway with full redundancy</span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.786.1">Cons</span></strong><span class="koboSpan" id="kobo.787.1">:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.788.1">Not</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.789.1"> many network devices have gNMI capability</span></li>
</ul>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.790.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.791.1">In this chapter, we covered the major methods used by software engineers to interact with network devices. </span><span class="koboSpan" id="kobo.791.2">Not many more methods are available, so I would assume we have covered perhaps 99.9% of all existing methods at the time of writing. </span></p>
<p><span class="koboSpan" id="kobo.792.1">Using the information provided in this chapter, you can choose which method or methods to incorporate into your network automation code. </span><span class="koboSpan" id="kobo.792.2">In most cases, you won’t be able to cover all scenarios using just one method; you will probably have to combine two or more methods.</span></p>
<p><span class="koboSpan" id="kobo.793.1">The next chapter will explore how files can be used to define a network. </span><span class="koboSpan" id="kobo.793.2">We will discuss the pros and cons of each type of file that’s available.</span></p>
</div>
</body></html>