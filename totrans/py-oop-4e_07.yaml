- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our examples so far, we''ve already seen many of the built-in Python data
    structures in action. You''ve probably also covered many of them in introductory
    books or tutorials. In this chapter, we''ll discuss the object-oriented features
    of these data structures, when they should be used instead of a regular class,
    and when they should not be used. In particular, we''ll be covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and named tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists and sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three types of queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's case study will revisit the data model for the *k*-nearest neighbors
    classifier. After looking at Python's sophisticated built-in data structure and
    class definitions, we can simplify some of the application class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by looking at some of the foundational constructs. The `object`
    class, specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Empty objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the most basic Python built-in, one that we''ve used implicitly
    many times already, the one (it turns out) we''ve extended in every class we have
    created: the `object`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, we can instantiate an `object` without writing a subclass, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as you can see, it's not possible to set any attributes on an `object` that
    was instantiated directly. This isn't because the Python developers wanted to
    force us to write our own classes, or anything so sinister. They did this to save
    memory – a lot of memory. When Python allows an object to have arbitrary attributes,
    it takes a certain amount of system memory to keep track of what attributes each
    object has, for storing both the attribute name and its value. Even if no attributes
    are stored, memory is allocated to make it possible to add attributes. Given the
    dozens, hundreds, or thousands of objects (*every* class extends the `object`
    class) in a typical Python program, this small amount of memory would quickly
    become a large amount of memory. So, Python disables arbitrary properties on `object`,
    and several other built-ins, by default.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to restrict arbitrary properties on our own classes using `__slots__`.
    Slots are part of *Chapter 12*, *Advanced Design Patterns*. We'll look at them
    as a way to save memory for objects that occur many, many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, however, trivial to create an empty object class of our own; we saw
    it in our earliest example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In effect, `class MyObject` is equivalent to `class MyObject(object)`. As we''ve
    already seen, it''s possible to set attributes on such classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to group an unknown number of attribute values together, we could
    store them in an empty object like this. The problem with this approach is the
    lack of an obvious schema that we can use to understand what attributes should
    be present and what types of values they'll have.
  prefs: []
  type: TYPE_NORMAL
- en: A focus of this book is the way classes and objects should only be used when
    you want to specify *both* data and behaviors. Therefore, it is important to decide
    from the outset whether the data is purely data, or whether it is an object in
    disguise. Once that design decision is made, the rest of the design can grow from
    the seed concept.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are objects that can store a specific number of other objects in sequence.
    They are *immutable*, meaning we can't add, remove, or replace objects on the
    fly. This may seem like a massive restriction, but the truth is, if you need to
    modify a tuple, you're using the wrong data type (usually, a `list` would be more
    suitable). The primary benefit of tuples' immutability is a tuple of immutable
    objects (like strings and numbers and other tuples) has a hash value, allowing
    us to use them as keys in dictionaries, and members of a set. (A tuple that contains
    a mutable structure, like a list, set, or dict, isn't composed of immutable items,
    and doesn't have a hash value. We'll look closely at this distinction in the next
    section.)
  prefs: []
  type: TYPE_NORMAL
- en: Instances of Python's built-in generic `tuple` class are used to store data;
    behavior cannot be associated with a built-in tuple. If we require behavior to
    manipulate a tuple, we have to pass the tuple into a function (or method on another
    object) that performs the action. This is the subject of *Chapter 8*, *The Intersection
    of Object-Oriented and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples overlap with the idea of coordinates or dimensions. A mathematical (x,
    y) pair or (r, g, b) color are examples of tuples; the order matters, a lot: the
    color (255, 0, 0) looks nothing like (0, 255, 0). The primary purpose of a tuple
    is to aggregate different pieces of data together into one container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a tuple by separating values with a comma. Usually, tuples are wrapped
    in parentheses to make them easy to read and to separate them from other parts
    of an expression, but this is not always mandatory. The following two assignments
    are identical (they record a stock, the current price, the 52-week high, and the
    52-week low, for a rather profitable company):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (When the first edition of this book was printed, this stock was trading around
    US$ 8 per share; the stock value has almost doubled with each edition of this
    book!)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re grouping a tuple inside of some other object, such as a function
    call, list comprehension, or generator, the parentheses are required. Otherwise,
    it would be impossible for the interpreter to know whether it is a tuple or the
    next function parameter. For example, the following function accepts a tuple and
    a date, and returns a tuple of the date and the middle value between the stock''s
    high and low value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a new four-tuple is created directly inside the function call.
    The items are separated by commas and the entire tuple is cuddled up inside parentheses.
    This tuple is then followed by a comma to separate it from the second argument,
    a `datetime.date` object. When Python displays a tuple, it uses what's called
    the **canonical** representation; this will always include `()`'s, making the
    `()`'s a common practice even when they're not – strictly – required. The `return`
    statement, specifically, has redundant `()`'s around the tuple it creates.
  prefs: []
  type: TYPE_NORMAL
- en: The degenerate cases include a tuple with only one item, written like this `(2.718,)`.
    The extra comma is required here. An empty tuple is `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can sometimes wind up with a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s sometimes surprising that the variable `a` will be a one-tuple. The trailing
    comma is what creates an expression list with a single item; this is the value
    of the tuple. The `()`''s are required for two things: (1) to create an empty
    tuple or (2) to separate a tuple from other expressions. For example, the following
    creates nested tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The trailing commas in Python are politely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `middle()` function also illustrates **tuple unpacking**. The first line
    inside the function unpacks the `stock` parameter into four different variables.
    The tuple has to be exactly the same length as the number of variables, or it
    will raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unpacking is a very useful feature in Python. A tuple groups related values
    together to make storing and passing them around simpler; the moment we need to
    access the pieces, we can unpack them into separate variables. Of course, sometimes
    we only need access to one of the variables in the tuple. We can use the same
    syntax that we use for other sequence types (lists and strings, for example) to
    access an individual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use slice notation to extract larger pieces of tuples, as demonstrated
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples, while illustrating how flexible tuples can be, also demonstrate
    one of their major disadvantages: readability. How does someone reading this code
    know what is in position 2 of a specific tuple? They can guess, using the name
    of the variable we assigned it to, that it is `high` of some sort, but if we had
    just accessed the tuple value in a calculation without assigning it, there would
    be no such indication. They would have to paw through the code to find where the
    tuple was packed or unpacked before they could discover what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing tuple members directly is fine in some circumstances, but don''t
    make a habit of it. The index values become what we might call *magic numbers*:
    numbers that seem to come out of thin air with no apparent meaning within the
    code. This opacity is the source of many coding errors and leads to hours of frustrated
    debugging. Try to use tuples only when you know that all the values are going
    to be useful at once and it''s normally going to be unpacked when it is accessed.
    Think of (x, y) coordinate pairs and (r, g, b) colors, where the number of items
    is fixed, the order matters, and the meaning is clear.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to provide some useful documentation is to define numerous little helper
    functions. This can help to clarify the way a tuple is used. Here's an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We need to keep these helper functions collected together into a single namespace.
    Doing this causes us to suspect that a class is better than a tuple with a lot
    of helper functions. There are other alternatives to clarifying the contents of
    tuples, the most important of which is the `typing.NamedTuple` class.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples via typing.NamedTuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what do we do when we want to group values together but know we''re frequently
    going to need to access them individually? There are actually several options,
    including these:'
  prefs: []
  type: TYPE_NORMAL
- en: We could use an empty `object` instance, as discussed previously. We can assign
    arbitrary attributes to this object. But without a good definition of what's allowed
    and what types are expected, we'll have trouble understanding this. And we'll
    get a lot of **mypy** errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use a dictionary. This can work out nicely, and we can formalize the
    acceptable list of keys for the dictionary with the `typing.TypedDict` hint. We'll
    touch on these in the case study for *Chapter 9*, *Strings, Serialization, and
    File Paths*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a `@dataclass`, the subject of the next section in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also provide names to the positions of a tuple. While we're at it, we
    can also define methods for these named tuples, making them super helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named tuples are tuples with attitude. They are a great way to create an immutable
    grouping of data values. When we define a **named tuple** we're creating a subclass
    of `typing.NamedTuple`, based on a list of names and data types. We don't need
    to write an `__init__()` method; it's created for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This new class will have a number of methods, including `__init__()`, `__repr__()`,
    `__hash__()`, and `__eq__()`. These will be based on the generic `tuple` processing
    with the added benefit of names for the various items. There are more methods,
    including comparison operations. Here''s how we can create a tuple of this class.
    It looks almost like creating a generic tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use keyword parameters to make things more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The constructor must have exactly the correct number of arguments to create
    the tuple. Values can be passed in as positional or keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to recognize that the names are provided at the class level,
    but we are **not** actually creating class-level attributes. The class-level names
    are used to build the `__init__()` method; each instance will have the expected
    names for the positions within the tuple. There's a clever metaclass-level transformation
    from what we wrote into the somewhat more complex definition of the resulting
    class with named, positional items. For more information on metaclasses, refer
    back to *Chapter 6*, *Abstract Base Classes and Operator Overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting instance of our `NamedTuple` subclass, `Stock`, can then be packed,
    unpacked, indexed, sliced, and otherwise treated like a normal tuple, but we can
    also access individual attributes by name as if it were an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Named tuples are perfect for many use cases. Like strings, tuples and named
    tuples are immutable, so we cannot modify an attribute once it has been set. For
    example, the current value of this company''s stock has gone down since we started
    this discussion, but we can''t set the new value, as can be seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The immutability refers only to the attributes of the tuple itself. This can
    seem odd, but it's a consequence of the definitions of an immutable tuple. The
    tuple can contain mutable elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The object, `t`, is a tuple, which means it's immutable. The tuple object contains
    two items. The value of `t[0]` is a string, which is also immutable. The value
    of `t[1]`, however, is a mutable list. The mutability of the list is not altered
    by the immutability of the object, `t`, with which it's associated. A list is
    mutable, irrespective of context. The tuple, `t`, is immutable, even if items
    within it are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Because the example tuple, `t`, contains a mutable list, it doesn't have a hash
    value. This shouldn't be surprising, either. The `hash()` computation requires
    the hash from each item within the collection. Since the list value of `t[1]`
    can't produce a hash, the tuple `t` – as a whole – can't produce a hash, either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what happens when we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the unhashable list object means the tuple – as a whole – is
    also unhashable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create methods to compute derived values of the attributes of a named
    tuple. We can, for example, redefine our `Stock` tuple to include the middle computation
    as a method (or a `@property`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t change the state, but we can compute values derived from the current
    state. This lets us couple computations directly to the tuple holding the source
    data. Here''s an object created with this definition of the `Stock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `middle()` method is now part of the class definition. The best part? The
    **mypy** tool can look over our shoulder to be sure the type hints all match up
    properly throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: The state of a named tuple is fixed when the tuple is created. If we need to
    be able to change stored data, a `dataclass` may be what we need instead. We'll
    look at those next.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Python 3.7, dataclasses let us define ordinary objects with a clean syntax
    for specifying attributes. They look – superficially – very similar to named tuples.
    This is a pleasant approach that makes it easy to understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `dataclass` version of our `Stock` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For this case, the definition is nearly identical to the `NamedTuple` definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `dataclass` function is applied as a class decorator, using the `@` operator.
    We encountered decorators in *Chapter 6*, *Abstract Base Classes and Operator
    Overloading*. We'll dig into them deeply in *Chapter 11*, *Common Design Patterns*.
    This class definition syntax isn't much less verbose than an ordinary class with `__init__()`,
    but it gives us access to several additional `dataclass` features.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to recognize that the names are provided at the class level,
    but are **not** actually creating class-level attributes. The class level names
    are used to build several methods, including the `__init__()` method; each instance
    will have the expected attributes. The decorator transforms what we wrote into
    the more complex definition of a class with the expected attributes and parameters
    to `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because dataclass objects can be stateful, mutable objects, there are a number
    of extra features available. We'll start with some basics. Here's an example of
    creating an instance of the `Stock` dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once instantiated, the `Stock` object can be used like any ordinary class.
    You can access and update attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other objects, we can add attributes beyond those formally declared
    as part of the dataclass. This isn''t always the best idea, but it''s supported
    because this is an ordinary mutable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding attributes isn''t available for frozen dataclasses, which we''ll talk
    about later in this section. At first glance, it seems like dataclasses don''t
    give many benefits over an ordinary class definition with an appropriate constructor.
    Here''s an ordinary class that''s similar to the dataclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'One obvious benefit to a dataclass is we only need to state the attribute names
    once, saving the repetition in the `__init__()` parameters and body. But wait,
    that''s not all! The dataclass also provides a much more useful string representation
    than we get from the implicit superclass, `object`. By default, dataclasses include
    an equality comparison, also. This can be turned off in the cases where it doesn''t
    make sense. The following example compares the manually built class to these dataclass
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The class built manually has an awful default representation, and the lack of
    an equality test can make life difficult. We'd prefer the behavior of the `Stock`
    class defined as a dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Class definitions decorated with `@dataclass` also have many other useful features.
    For example, you can specify a default value for the attributes of a dataclass.
    Perhaps the market is currently closed and you don''t know what the values for
    the day are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can construct this class with just the stock name; the rest of the values
    will take on the defaults. But you can still specify values if you prefer, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw earlier that dataclasses support equality comparison by default. If
    all the attributes compare as equal, then the dataclass objects as a whole also
    compare as equal. By default, dataclasses do not support other comparisons, such
    as less than or greater than, and they can''t be sorted. However, you can easily
    add comparisons if you wish, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s okay to ask "Is that all that''s needed?" The answer is yes. The `order=True`
    parameter to the decorator leads to the creation of all of the comparison special
    methods. This change gives us the opportunity to sort and compare the instances
    of this class. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the dataclass decorator receives the `order=True` argument, it will, by
    default, compare the values based on each of the attributes in the order they
    were defined. So, in this case, it first compares the `name` attribute values
    of the two objects. If those are the same, it compares the `current` attribute
    values. If those are also the same, it will move on to `high` and will even include
    `low` if all the other attributes are equal. The rules follow the definition of
    a tuple: the order of definition is the order of comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature of dataclasses is `frozen=True`. This creates a
    class that's similar to a `typing.NamedTuple`. There are some differences in what
    we get as features. We'd need to use `@dataclass(frozen=True, ordered=True)` to
    create structures. This leads to a question of "Which is better?", which – of
    course – depends on the details of a given use case. We haven't explored all of
    the optional features of dataclasses, like initialization-only fields and the
    `__post_init__()` method. Some applications don't need all of these features,
    and a simple `NamedTuple` may be adequate.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other approaches. Outside the standard library, packages like
    `attrs`, `pydantic`, and `marshmallow` provide attribute definition capabilities
    that are – in some ways – similar to dataclasses. Other packages outside the standard
    library offer additional features. See [https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html](https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html)
    for a comparison.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at two ways to create unique classes with specific attribute values,
    named tuples and dataclasses. It's often easier to start with dataclasses and
    add specialized methods. This can save us a bit of programming because some of
    the basics, like initialization, comparison, and string representations, are handled
    elegantly for us.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to look at Python's built-in generic collections, `dict`, `list`,
    and `set`. We'll start by exploring dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dictionaries are incredibly useful containers that allow us to map objects directly
    to other objects. Dictionaries are extremely efficient at looking up a **value**,
    given a specific **key** object that maps to that value. The secret of the speed
    is using a **hash** of the key to locate the value. Every immutable Python object
    has a numeric hash code; a relatively simple table is used to map the numeric
    hashes directly to values. This trick means a dictionary never searches the entire
    collection for a key; the key is transformed to a hash, which locates the associated
    value (almost) immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries can be created either using the `dict()` constructor or the `{}` syntax
    shortcut. In practice, the latter format is almost always used. We can prepopulate
    a dictionary by separating the keys from the values using a colon and separating
    the key-value pairs using a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create dictionaries using keyword parameters. We can use `dict(current=1235.20,
    high=1242.54, low=1231.06)` to create the value `{''current'': 1235.2, ''high'':
    1242.54, ''low'': 1231.06}`. This `dict()` syntax overlaps with other constructors
    like dataclasses and named tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our stock application, we would most often want to look up
    prices by the stock symbol. We can create a dictionary that uses stock symbols
    as keys, and tuples (you could also use named tuples or dataclasses as values,
    of course) of current, high, and low as values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen in previous examples, we can then look up values in the dictionary
    by requesting a key inside square brackets. If the key is not in the dictionary,
    it will raise a `KeyError` exception, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, of course, catch the `KeyError` and handle it. But we have other options.
    Remember, dictionaries are objects, even if their primary purpose is to hold other
    objects. As such, they have several behaviors associated with them. One of the
    most useful of these methods is the `get` method; it accepts a key as the first
    parameter and an optional default value if the key doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For even more control, we can use the `setdefault()` method. If the key is
    in the dictionary, this method behaves just like the `get()` method; it returns
    the value for that key. Otherwise, if the key is not in the dictionary, it will
    not only return the default value we supply in the method call (just like the
    `get()` method does); it will also set the key to that same value. Another way
    to think of it is that `setdefault()` sets a value in the dictionary only if that
    value has not previously been set. Then, it returns the value in the dictionary;
    either the one that was already there or the newly provided default value, as
    can be seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `"GOOG"` stock was already in the dictionary, so when we tried to use `setdefault()`
    to change it to an invalid value, it just returned the value already in the dictionary.
    The key `"BB"` was not in the dictionary, so the `setdefault()` method returned
    the default value and set the new value in the dictionary for us. We then check
    that the new stock is, indeed, in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints for dictionaries must include the type for the keys and the type
    for the values. Starting with Python 3.9, and **mypy** release 0.812, we describe
    this structure with a type hint of `dict[str, tuple[float, float, float]]`; we
    can avoid importing the `typing` module. Depending on your version of Python,
    you'll often need to use `from __future__ import annotations` as the first line
    of code in your module; this includes the necessary language support to treat
    built-in classes as properly generic type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three other useful dictionary methods are `keys()`, `values()`, and `items()`.
    The first two return iterators over all the keys and all the values in the dictionary.
    We can use these in `for` loops if we want to process all the keys or values.
    We''ll return to the universality of iterators in *Chapter 10*, *The Iterator
    Pattern*. The `items()` method is probably the most useful; it returns an iterator
    over tuples of `(key, value)` pairs for every item in the dictionary. This works
    great with tuple unpacking in a `for` loop to loop over associated keys and values.
    The following example does just that to print each stock in the dictionary with
    its current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Each key/value tuple is unpacked into two variables named `stock` and `values` (we
    could use any variable names we wanted, but these both seem appropriate) and then
    printed in a formatted string.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the stocks show up in the same order in which they were inserted.
    This was not true until Python 3.6, and was not a formal part of the language
    definition until Python 3.7\. Before that, the `dict` implementation used a different
    underlying data structure with a difficult-to-predict ordering. According to PEP
    478, Python 3.5's final release was in September 2020, making this older, difficult-to-predict
    ordering fully obsolete. To preserve the ordering of keys, we used to be forced
    to use the `OrderedDict` class in the `collections` module, but that's no longer
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous ways to retrieve data from a dictionary once it has been
    instantiated: we can use square brackets as index syntax, the `get()` method,
    the `setdefault()` method, or iterate over the `items()` method, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as you likely already know, we can set a value in a dictionary using
    the same indexing syntax we use to retrieve a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To reflect a change in the GOOG stock, we can update the tuple value in the
    dictionary. We can use this index syntax to set a value for any key, regardless
    of whether the key is in the dictionary. If it is in the dictionary, the old value
    will be replaced with the new one; otherwise, a new key-value pair will be created.
  prefs: []
  type: TYPE_NORMAL
- en: We've been using strings as dictionary keys, so far, but we aren't limited to
    string keys. It is common to use strings as keys, especially when we're storing
    data in a dictionary to gather it together (instead of using an object or dataclass
    with named properties). But we can also use tuples, numbers, or even objects we've
    defined ourselves as dictionary keys. The essential ingredient is a `__hash__()`
    method, which immutable types offer. While we can even use different types of
    objects as keys in a single dictionary, this is difficult to describe to **mypy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a dictionary with a variety of keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code shows several different types of keys we can supply to a dictionary.
    The data structure has a type hint of `dict[Union[str, int, float, Tuple[str,
    int], AnObject], str]`. This is clearly terribly complex. Writing type hints for
    this can be bewildering, suggesting it's not the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: This example also shows one type of object that cannot be used as a key. We've
    already used lists extensively, and we'll be seeing many more details of them
    in the next section. Because lists are mutable – they can change at any time (by
    adding or removing items, for example) – they cannot hash to a single value.
  prefs: []
  type: TYPE_NORMAL
- en: We can use code like the following to examine values in the dictionary. This
    works because the default behavior of a mapping is to iterate over the keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To be usable as a dictionary key, an object must be **hashable**, that is, have
    a `__hash__()` method to convert the object''s state into a unique integer value
    for rapid lookup in a dictionary or set. The built-in `hash()` function uses the
    `__hash__()` method of the object''s class. This hash is used to find values in
    a dictionary. For example, strings map to integers based on numeric codes for
    the characters in the string, while tuples combine hashes of the items inside
    the tuple. Any two objects that are considered equal (such as strings with the
    same characters or tuples with the same values) **must** also have the same hash
    value. Note that there is an asymmetry between equality and matching hash values.
    If two strings have the same hash value, they could still be unequal. Think of
    hash equality as an approximation for an equality test: if the hashes aren''t
    equal, don''t bother looking at the details. If the hashes are equal, invest the
    time in checking each attribute value or each item of the tuple, or each individual
    character of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of two integers with the same hash value that are not actually
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use these values as keys in a dictionary, a hash collision algorithm
    will keep them separated. The situation leads to a microscopic slowdown in these
    rare cases of hash collisions. This is why dictionary lookup isn''t **always**
    immediate: a hash collision might slow down access.'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in mutable objects – including lists, dictionaries, and sets – cannot
    be used as dictionary keys. These mutable collections don't provide hash values.
    We can, however, create our own class of objects that are both mutable and provide
    a hash value; this is unsafe because a change to the object's state can make it
    difficult to find the key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We can go too far, of course. It is certainly possible to create a class with
    a mixture of mutable and immutable attributes and confine a customized hash computation
    to the mutable attributes. Because of the differences in behavior between the
    mutable and immutable features, this seems like it's really two objects that collaborate,
    not a single object with mutable and immutable features. We can use the immutable
    part for dictionary keys and keep the mutable part in the dictionary value.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, there are no limits on the types of objects that can be used as
    dictionary values. We can use a string key that maps to a list value, for example,
    or we can have a nested dictionary as a value in another dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionaries are extremely versatile and have numerous uses. Here are two major
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: We can have dictionaries where all the values are different instances of objects
    with the same type. For example, our stock dictionary would have a type hint of
    `dict[str, tuple[float, float, float]]`. The string key maps to a three-tuple
    of values. We use the stock symbol as an index to price details. If we had a more
    complex `Stock` class, we might have a dictionary with `dict[str, Stock]` as the
    type hint for an index into these objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second design is to have each key represent some aspect or attribute of
    a single object; the values often have distinct types. We may, for example, represent
    a stock with `{''name'': ''GOOG'', ''current'': 1245.21, ''range'': (1252.64,
    1245.18)}`. This case clearly overlaps with named tuples, dataclasses, and objects
    in general. Indeed, there''s a special type hint for this kind of dictionary,
    called a `TypedDict`, that looks like a `NamedTuple` type hint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This second example can be confusing; how do we decide how to represent attribute
    values of an object? We can rank the techniques like this.
  prefs: []
  type: TYPE_NORMAL
- en: For a lot of cases, dataclasses offer a number of helpful features with less
    code writing. They can be immutable, or mutable, giving us a wide range of options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For cases where the data is immutable, a `NamedTuple` can be slightly more efficient
    than a frozen dataclass by about 5% – not much. What tips the balance here is
    an expensive attribute computation. While a `NamedTuple` can have properties,
    if the computation is very costly and the results are used frequently, it can
    help to compute it in advance, something a `NamedTuple` isn't good at. Check out
    the documentation for dataclasses and their `__post_init__()` method as a better
    choice in the rare case where it's helpful to compute an attribute value in advance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dictionaries are ideal when the complete set of keys isn't known in advance.
    When we're starting a design, we may have throwaway prototypes or proofs of concept
    using dictionaries. When we try to write unit tests and type hints, we may need
    to ramp up the formality. In some cases, the domain of possible keys is known,
    and a `TypedDict` type hint makes sense as a way to characterize the valid keys
    and value types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the similar syntax, it's relatively easy to try different designs
    to see which works better for the problem, which is faster, which is easier to
    test, and which uses less memory. Sometimes, all three converge and there's one
    best choice. More often, it's a trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, most classes are implemented using dictionaries under the hood.
    You can see this by loading an object into the interactive interpreter and looking
    at the `__dict__` special attribute, if it's present. When you access an attribute
    on an object using syntax like `obj.attr_name`, this is effectively `obj.__dict__['attr_name']`
    under the hood. It's actually a bit more complicated, involving `__getattr__()`
    and `__getattribute__()`, but you get the gist. Even dataclasses have a `__dict__`
    attribute, which just goes to show how widely used dictionaries really are. They
    aren't universal, but they are common.
  prefs: []
  type: TYPE_NORMAL
- en: Using defaultdict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen how to use the `setdefault` method to set a default value if a
    key doesn''t exist, but this can get a bit monotonous if we need to set a default
    value every time we look up a value. For example, if we''re writing code that
    counts the number of times a letter occurs in a given sentence, we could do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we access the dictionary, we need to check that it has a value already,
    and if not, set it to zero. When something like this needs to be done every time
    an empty key is requested, we can create a different version of a dictionary.
    The `defaultdict`, defined in the `collections` module, handles missing keys elegantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks odd: the `defaultdict()` evaluation accepts a function, `int`,
    in its constructor. We''re not evaluating the `int()` function; we''re providing
    a reference to this function to `defaultdict()`. Whenever a key is accessed that
    is not already in the dictionary, it calls that function, with no parameters,
    to create a default value.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `defaultdict[str, int]` type hint is slightly wordier than the
    `defaultdict()` evaluation itself. The `defaultdict()` class only needs a function
    that will create default values. The type of the keys doesn't actually matter
    at runtime; any object with a `__hash__()` method will work. When using `defaultdict`
    as a type hint, though, it needs some additional details before we can be **sure**
    this will work. We need to provide both the type of the key – `str`, in this example
    – and the type of object that will be associated with the key – `int`, in this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `frequencies` object uses the function `int()` to create
    default values. This is the constructor for an integer object. Normally, integers
    are created as a literal, by typing an integer number into our code. If we do
    create an integer using the `int()` constructor, it's often part of a conversion;
    for example, to convert a string of digits into an integer, like `int("42")`.
    But if we call `int()` without any arguments, it returns, conveniently, the number
    zero. In this code, if a letter doesn't exist in the `defaultdict`, the number
    zero is created by the factory function and returned when we access it. Then,
    we add one to this number to indicate that we've found an instance of that letter
    and save the updated value back into the dictionary. The next time we find the
    same character, the new number will be returned and we can increment the value
    and save it back into the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defaultdict()` is useful for creating dictionaries of containers. If we
    want to create a dictionary of closing stock prices for the past 30 days, we could
    use a stock symbol as the key and store the prices in a `list`; the first time
    we access the stock price, we would want to create an empty list. Simply pass
    the `list` function into the `defaultdict`, like this: `defaultdict(list)`. The
    `list()` function will be called every time a previously unknown key is accessed.
    We can do similar things with sets or even empty dictionaries if we want to use
    a subsidiary dictionary as the value for a key.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can also write our own functions and pass them into the `defaultdict`.
    Suppose we want to create a `defaultdict` where each key maps to a dataclass with
    information about that key. If we define our dataclass with default values, then
    our class name will work as a function without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this dataclass, `Prices`, with all default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the class has default values for all attributes, we can use the class
    name without argument values and get a useful object. This means our class name
    will work as the argument to the `defaultdict()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print `portfolio`, we see how the default objects were saved in the
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This `portfolio` dictionary creates a default `Prices` object for unknown keys.
    This works because the `Prices` class had default values for all of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this even further. What if we want prices for stocks grouped
    by month? We want a dictionary with a key of the stock name. Within that we want
    dictionaries keyed by month. And within that inner dictionary, we want prices.
    This can be tricky because we want a default function that takes zero arguments
    and creates a `defaultdict(Prices)` for us. We can define a one-line function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can also use a Python lambda form – a no-name, one expression function for
    this. A lambda can have parameters, but we don't need any. The single expression
    is the object we'd like created as a default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we can have nested `defaultdict` dictionaries. When a key is missing, a
    proper default is built.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `by_month` collection's top-level key points to an internal dictionary.
    The internal dictionary has prices for each month.
  prefs: []
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''d think that algorithms could not get much simpler than using `defaultdict(int)`.
    The *I want to count specific instances in an iterable* use case is common enough
    that the Python developers created a specific class for this exact purpose, simplifying
    things even further. The previous code that counts characters in a string can
    easily be calculated in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Counter` object behaves like a beefed-up dictionary where the keys are
    the items being counted and the values are the quantities of such items. One of
    the most useful functions is the `most_common()` method. It returns a list of
    `(key,count)` tuples in descending order by the count. You can optionally pass
    an integer argument into `most_common()` to request a list of only the most common
    elements. For example, you could write a simple polling application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Presumably, you'd get the responses from a database or by using a computer vision
    algorithm to count the kids who raised their hands. Here, we hardcoded the `responses`
    object with literal values so that we can test the `most_common()` method. This
    method always returns a list, even when we only asked for one element. The hint
    is effectively `list[tuple[T, int]]` where `T` is the type we're counting. In
    our example, where we're counting strings, the hint for the `most_common()` method
    is `list[tuple[str, int]]`. We only want the first item from a one-item list,
    so `[0]` is required. We can then decompose the two-tuple into the value that
    was counted and the integer count.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of lists, it's time to dig a little more deeply into Python's list
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's generic list structure is integrated into a number of language features.
    We don't need to import them and rarely need to use method syntax to access their
    features. We can visit all the items in a list without explicitly requesting an
    iterator object, and we can construct a list (as with a dictionary) with very
    simple-looking syntax. Further, list comprehensions and generator expressions
    turn them into a veritable Swiss Army knife of computing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know how to create or append to a list, how to retrieve items from
    a list, or what *slice notation* is, we direct you to the official Python tutorial,
    posthaste. It can be found online at [http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/).
    In this section, we'll move beyond the basics to cover when lists should be used,
    and their nature as objects.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, lists should normally be used when we want to store several instances
    of the *same* type of object; lists of strings or lists of numbers. We'll often
    use a type hint `list[T]` to specify the type, `T`, of object kept in the list,
    for example, `list[int]` or `list[str]`.
  prefs: []
  type: TYPE_NORMAL
- en: (Remember that `from __future__ import annotations` is required for this to
    work.) Lists must be used when we want to store items in some kind of order. Often,
    this is the order in which they were inserted, but they can also be sorted by
    other criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are mutable, so items can be added, replaced, and removed from the list.
    This can be handy for reflecting the state of some more complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: Like dictionaries, Python lists use an extremely efficient and well-tuned internal
    data structure so we can worry about what we're storing, rather than how we're
    storing it. Python expands on lists to provide some specialized data structures
    for queues and stacks. Python doesn't make a distinction between lists based on
    arrays or lists that use links. Generally, the built-in list data structure can
    serve a wide variety of purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use lists for collecting different attributes of individual items. Tuples,
    named tuples, dictionaries, and objects would all be more suitable for collecting
    different kinds of attribute values. Our first `Stock` data examples at the beginning
    of the chapter stored current price, minimum price, and maximum price, each a
    different attribute with a distinct meaning in a single sequence. This isn't really
    ideal, and named tuples or dataclasses were clearly superior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rather convoluted counterexample that demonstrates how we could perform
    the frequency example using a list. It is much more complicated than the dictionary
    examples and illustrates the effect that choosing the right (or wrong) data structure
    can have on the readability (and performance) of our code. This is demonstrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This code starts with a list of possible characters. The `string.ascii_letters` attribute
    provides a string of all the letters, lowercase and uppercase, in order. We convert
    this to a list and then use list concatenation (the `+` operator causes two lists
    to be concatenated into one) to add one more character, a space. These are the
    available characters in our frequency list (the code would break if we tried to
    add a letter that wasn't in the list).
  prefs: []
  type: TYPE_NORMAL
- en: The first line inside the function uses a list comprehension to turn the `CHARACTERS` list
    into a list of tuples. Then, we loop over each of the characters in the sentence.
    We first look up the index of the character in the `CHARACTERS` list, which we
    know has the same index in our frequencies list, since we created the second list
    from the first. We then update that index in the frequencies list by creating
    a new tuple, discarding the original one. Aside from garbage collection and memory
    waste concerns, this is rather difficult to read!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we filter the list by examining each tuple and keeping only pairs where
    the count is greater than zero. This removes the letters we allocated space for
    but never saw.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being longer, the `CHARACTERS.index(letter)` operation can be very slow.
    The worst case is to examine each of the characters in the list for a match. On
    average, it will search half the list. Compare this with a dictionary that does
    a hash computation and examines one item for a match. (Except in the case of a
    hash collision where there's a tiny probability of examining more than one and
    it has to handle hash collision with a second lookup.)
  prefs: []
  type: TYPE_NORMAL
- en: The type hint describes the type of the objects in the list. We summarized it
    as `list[tuple[str, int]]`. Each of the items in the resulting list will be a
    two-tuple. This lets **mypy** confirm that the operations respect the structure
    of the list overall and each tuple within the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like dictionaries, lists are objects, too. They have several methods that can
    be invoked upon them. Here are some common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The `append(element)` method adds an element to the end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `insert(index, element)` method inserts an item at a specific position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `count(element)` method tells us how many times an element appears in the
    list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index()` method tells us the index of an item in the list, raising an exception
    if it can't find it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find()` method does the same thing but returns `-1` instead of raising
    an exception for missing items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reverse()` method does exactly what it says – turns the list around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sort()` method has some rather intricate object-oriented behaviors, which
    we'll cover now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few more that are less commonly used. The complete list of methods
    is in the *Sequence Types* section of the Python Standard Library documentation:
    [https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range](https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range).'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without any parameters, the `sort()` method of a `list` object will generally
    do as expected. If we have a `list[str]` object, the `sort()` method will place
    the items in alphabetical order. This operation is case sensitive, so all capital
    letters will be sorted before lowercase letters; that is, `Z` comes before `a`.
    If it's a list of numbers, they will be sorted in numerical order. If a list of
    tuples is provided, the list is sorted by considering the elements in the tuple
    in order. If a mixture containing unsortable items is supplied, the sort will
    raise a `TypeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to place objects of classes we've defined ourselves into a list and
    make those objects sortable, we have to do a bit more work. The special `__lt__()`
    method, which stands for *less than*, must be defined on the class to make instances
    of that class comparable. The `sort` method on the list will access this method
    on each object to determine where it goes in the list. This method should return
    `True` if our class is somehow less than the passed parameter, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Often, when we need comparisons like this, we'll use a dataclass. As discussed
    in the *Dataclasses* section, the `@dataclass(order=True)` decorator will assure
    that all of the comparison methods are built for us. A named tuple also has the
    ordering operations defined by default.
  prefs: []
  type: TYPE_NORMAL
- en: One tricky situation that arises with sorting is handling a data structure sometimes
    called a **tagged union**. A union is a description of an object where attributes
    are not **always** relevant. If an attribute's relevance depends on another attribute's
    value, this can be seen as a union of distinct subtypes with a tag to distinguish
    between the two types.
  prefs: []
  type: TYPE_NORMAL
- en: Here's some example data, where a tag value, the **Data Source** column, is
    required to decide how best to deal with the remaining columns. Some values of
    **Data Source** tell us to use the timestamp, where as other values tell us to
    use the creation date.
  prefs: []
  type: TYPE_NORMAL
- en: '| Data Source | Timestamp | Creation Date | Name, Owner, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Local | 1607280522.68012 |  | "Some File", etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Remote |  | "2020-12-06T13:47:52.849153" | "Another File", etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Local | 1579373292.452993 |  | "This File", etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Remote |  | "2020-01-18T13:48:12.452993" | "That File", etc. |'
  prefs: []
  type: TYPE_TB
- en: How can we sort these into a single, coherent order? We'd like to have a single,
    consistent data type in our list, but the source data has two subtypes with a
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: A simple-seeming `if row.data_source == "Local":` can work to distinguish values,
    but it can be confusing logic for **mypy** to work with. One or two *ad hoc* `if`
    statements aren't too bad, but the design principle of throwing `if` statements
    at the problem isn't very scalable.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can consider **Timestamp** as the preferred representation.
    This means we only need to compute timestamps from the creation date string for
    the items where the data source is "Remote." In this example, either the float
    value or the string would sort into order properly. This happens to work out well
    because the string is in the carefully designed ISO format. If it was in American
    month-day-year format, it would require conversion to a timestamp to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Converting all of the various input formats to Python's native `datetime.datetime`
    objects is another choice. This has the advantage of being distinct from any of
    the input formats. While this is a little more work, it gives us more flexibility
    because we're not tied to a source data format that may change in the future.
    The concept is to make every variant input format convert to a single, common
    `datetime.datetime` instance.
  prefs: []
  type: TYPE_NORMAL
- en: What's central is treating the two subtypes as if they're a single class of
    objects. This doesn't always work out well. Often this is a design constraint
    that sneaks up on us when we have additional customers or additional sources of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start an implementation with a single type that supports both subtypes
    of data. This is not ideal, but it matches the source data and is often how we
    start tackling this kind of data. Here''s the essential class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `__lt__()` method compares an object of the `MultiItem` class to another
    instance of the same class. Because there are two implicit subclasses, we have
    to check the tag attributes, `self.data_source` and `other.data_source`, to see
    which of the various combinations of fields we're dealing with. We'll do a conversion
    from a timestamp or a string into a common representation. Then we can compare
    the two common representations.
  prefs: []
  type: TYPE_NORMAL
- en: The conversion processing is nearly duplicate code. Later in this section, we
    will look at refactoring this to remove the redundancy. The `cast()` operations
    are required to make it clear to **mypy** that the item will not be `None`. While
    we know the rules that match the tag (the **Data Source** column) and the two
    kinds of values, those rules need to be stated in a way **mypy** can exploit them.
    The `cast()` is how we tell **mypy** what the data will be at runtime; there's
    no processing that actually happens.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our application could have incomplete type hints and we could run
    with a bug and an object that's not an instance of `MultiItem` could be compared
    with an instance of `MultiItem`. This will likely result in a runtime error. The
    `cast()` is a claim about the intent and the design, with no runtime impact. Because
    of Python's duck typing, some unexpected type that has the right attributes can
    be used and will work. Unit testing is essential even with careful type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output illustrates this class in action when it comes to sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The comparison rules were applied among the various subtypes that were conflated
    into a single class definition. If the rules are more complex, however, this can
    become unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the `__lt__()` method is required to implement to enable sorting. To be
    complete, the class may also implement the similar `__gt__()`, `__eq__()`, `__ne__()`,
    `__ge__()`, and `__le__()` methods. This ensures all of the `<`, `>`, `==`, `!=`,
    `>=`, and `<=` operators also work properly. You can get this for free by implementing
    `__lt__()` and `__eq__()`, and then applying the `@total_ordering` class decorator
    to supply the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We didn't repeat the `__lt__()` method body; we encourage the reader to rewrite
    it to look more like the `__eq__()` method. When we provide some combination of
    `<` (or `>`) and `=`, the `@total_order` decorator can deduce the remaining logic
    operator implementations. For example, ![](img/B17070_07_001.png). The implementation
    of `__ge__(self, other)` is `not self < other`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that our class method definitions are (very) narrowly focused on comparing
    `timestamp` and `creation_date` attributes among these objects. The definitions
    of these methods are – perhaps – less than ideal because they reflect exactly
    one use case of comparison. We often have two possible designs:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the comparison operations narrowly, focused on a specific use case. In
    this example, we compare only the timestamps and ignore all other attributes.
    This is inflexible but can be made very efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the comparison operations broadly, often only supporting `__eq__()` and
    `__ne__()` because there are too many alternative ordering comparisons that could
    be used. We extract individual attribute comparison rules outside the class and
    make them part of the sorting operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second design strategy requires us to localize the comparison as part of
    evaluating the `sort()` method, instead of making the comparison a general part
    of the class. The `sort()` method can take an optional `key` argument. We use
    this to provide a "key extraction" function to the `sort()` method. This argument
    to `sort()` is a function that translates each object in a list into an object
    that can somehow be compared. In our case, we''d like a function to extract either
    the `timestamp` or the `creation_date` for comparison. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we use this `by_timestamp()` function to compare objects using
    `datetime` objects from each `SimpleMultiItem` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve divorced the sorting rules from the class, leading to a pleasant simplification.
    We can leverage this kind of design to provide other kinds of sorts. We might,
    for example, sort by name only. This is slightly simpler because no conversion
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We've created a lambda object, a tiny no-name function that takes an item as
    an argument and returns the value of `item.name`. A lambda is a function, but
    it doesn't have a name, and it can't have any statements. It only has a single
    expression. If you need statements (for example a try/except clause) you need
    a conventional function definition outside the `sort()` method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few sort key operations that are so common that the Python team
    has supplied them so you don''t have to write them yourself. For example, it is
    common to sort a list of tuples by something other than the first item in the
    list. The `operator.attrgetter` method can be used as a key to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `attrgetter()` function fetches a specific attribute from an object. When
    working with tuples or dictionaries, `itemgetter()` can be used to extract a specific
    item by name or position. There's even a `methodcaller()`, which returns the result
    of a method call on the object being sorted. Refer to the `operator` module documentation
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There's rarely one single sort order for data objects. Providing the key function
    as part of the `sort()` method lets us define a wide variety of sorting rules
    without creating complex class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: After looking at dictionaries and now lists, we can turn our attention to sets.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are extremely versatile tools that suit many container object applications.
    But they are not useful when we want to ensure that objects in a list are unique.
    For example, a song library may contain many songs by the same artist. If we want
    to sort through the library and create a list of all the artists, we would have
    to check the list to see whether we've added the artist already, before we add
    them again.
  prefs: []
  type: TYPE_NORMAL
- en: This is where sets come in. Sets come from mathematics, where they represent
    an unordered group of unique items. We can try to add an item to a set five times,
    but the "is a member of a set" doesn't change after the first time we add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, sets can hold any hashable object, not just strings or numbers.
    Hashable objects implement the `__hash__()` method; these are the same objects
    that can be used as keys in dictionaries; so again, mutable lists, sets, and dictionaries
    are out. Like mathematical sets, they can store only one copy of each object.
    If we''re trying to create a list of song artists, we can create a set of string
    names and simply add them to the set. This example starts with a list of `(song,
    artist)` tuples and creates a set of the artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no built-in syntax for an empty set as there is for lists and dictionaries;
    we create a set using the `set()` constructor. However, we can use the curly braces
    (borrowed from dictionary syntax) to create a set, so long as the set contains
    values. If we use colons to separate pairs of values, it''s a dictionary, as in
    `{''key'': ''value'', ''key2'': ''value2''}`. If we just separate values with
    commas, it''s a set, as in `{''value'', ''value2''}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Items can be added individually to the set using the `add()` method, and updated
    in bulk using the `update()` method. If we run the script shown above, we see
    that the set works as advertised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you're paying attention to the output, you'll notice that the items are not
    printed in the order they were added to the sets. Indeed each time you run this,
    you may see the items in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are inherently unordered due to a hash-based data structure used for efficient
    access to the members. Because of this lack of ordering, sets cannot have items
    looked up by index. The primary purpose of a set is to divide the world into two
    groups: *things that are in the set*, and *things that are not in the set*. It
    is easy to check whether an item is in a set or to loop over the items in a set,
    but if we want to sort or order them, we have to convert the set to a list. This
    output shows all three of these activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This output is highly variable; any one of the possible orderings could be used,
    depending on the hash randomization in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The primary *feature* of a set is uniqueness. Sets are often used to deduplicate
    data. Sets are also used to create combinations, including unions and differences
    between collections. Most of the methods on the set type operate on other sets,
    allowing us to efficiently combine or compare the items in two or more sets.
  prefs: []
  type: TYPE_NORMAL
- en: The `union` method is the most common and easiest to understand. It takes a
    second set as a parameter and returns a new set that contains all elements that
    are in *either* of the two sets; if an element is in both original sets, it will
    only show up once in the new set. Union is like a logical `or` operation. Indeed,
    the `|` operator can be used on two sets to perform the union operation, if you
    don't like calling methods.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the `intersection` method accepts a second set and returns a new
    set that contains only those elements that are in *both* sets. It is like a logical `and` operation,
    and can also be referenced using the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `symmetric_difference` method tells us what''s left; it is the
    set of objects that are in one set or the other, but not in both. It uses the
    `^` operator. The following example illustrates these methods by comparing some
    artists preferred by two different people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are three examples of union, intersection, and symmetric difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The union, intersection, and symmetric difference methods are commutative. We
    can say `dusty_artists.union(steve_artists)` or `steve_artists.union(dusty_artists)`
    and get the same general result. The order of values will vary because of hash
    randomization, but the same items will be present in both sets.
  prefs: []
  type: TYPE_NORMAL
- en: There are also methods that return different results depending on who is the
    caller and who is the argument. These methods include `issubset` and `issuperset`,
    which are the inverse of each other. Both return a `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: The `issubset` method returns `True` if all of the items in the calling set
    are also in the set passed as an argument. We can use the `<=` operator for this,
    also.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `issuperset` method returns `True` if all of the items in the argument are
    also in the calling set. Thus, `s.issubset(t)`, `s <= t`, `t.issuperset(s)`, and
    `t >= s` are all identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will both return `True` if `t` contains all the elements in `s`. (The `<`
    and `>` operators are for proper subsets and proper supersets; there are no named
    methods for these operations.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `difference` method returns all the elements that are in the calling
    set, but not in the set passed as an argument. The `difference` method can also
    be represented by the `-` operator. The following code illustrates these methods
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `difference` method, in the final expression, returns an empty set, since
    there are no items in `bands` that are not in `artists`. Looked at another way,
    we start with the value in `bands` and then remove all the items from `artists`.
    It may be helpful to think of as the expression `bands - artists`.
  prefs: []
  type: TYPE_NORMAL
- en: The `union`, `intersection`, and `difference` methods can all take multiple
    sets as arguments; they will return, as we might expect, the set that is created
    when the operation is called on all the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: So, the methods on sets clearly suggest that sets are meant to operate on other
    sets, and that they are not just containers. If we have data coming in from two
    different sources and need to quickly combine them in some way, so as to determine
    where the data overlaps or is different, we can use set operations to efficiently
    compare them. Or, if we have data incoming that may contain duplicates of data
    that has already been processed, we can use sets to compare the two and process
    only the new data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is valuable to know that sets are much more efficient than lists
    when checking for membership using the `in` keyword. If you use the `value in
    container` syntax on a set or a list, it will return `True` if one of the elements
    in `container` is equal to `value`, and `False` otherwise. However, in a list,
    it will look at every object in the container until it finds the value, whereas
    in a set, it simply hashes the value and checks for membership. This means that
    a set will find the value in the same amount of time no matter how big the container
    is, but a list will take longer and longer to search for a value as the list contains
    more and more values.
  prefs: []
  type: TYPE_NORMAL
- en: Three types of queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll look at an application of the list structure to create a queue. A queue
    is a special kind of buffer, summarized as **First In First Out** (**FIFO**).
    The idea is to act as a temporary stash so one part of an application can write
    to the queue while another part consumes items from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: A database might have a queue of data to be written to disk. When our application
    performs an update, the local cache version of the data is updated so all other
    applications can see the change. The write to the disk, however, may be placed
    in a queue for a writer to deal with a few milliseconds later.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re looking at files and directories, a queue can be a handy place
    to stash details of the directories so they can be processed later. We''ll often
    represent a directory as the path from the root of the filesystem to the file
    of interest. We''ll look at `Path` objects in detail in *Chapter 9*, *Strings,
    Serialization, and File Paths*. The algorithm works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize this list-like structure as growing via an `append()` and
    shrinking via `pop(0)`. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Queue concept'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is for the queue to grow and shrink: each directory grows the queue
    and each file shrinks the queue. Eventually, all the files and directories have
    been processed and the queue is empty. The original order is preserved by the
    FIFO rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several ways to implement a queue in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: List using the `pop()` and `append()` methods of a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `collections.deque` structure, which supports `popleft()` and `append()`
    methods. A "deque" is a Double-Ended Queue. This is an elegant queue implementation
    that's faster than a simple list for the specific operations of appending and
    popping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `queue` module provides a queue often used for multithreading, but it can
    also be used for our single thread to examine a directory tree. This uses `get()`
    and `put()` methods. Since this structure is designed for concurrency, it locks
    the data structure to assure that each change is atomic and can't be interrupted
    by other threads. For a non-concurrent application, the locking overhead is a
    performance penalty we can avoid. This is the subject of *Chapter 14*, *Concurrency*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `heapq` module also provides a queue, but it does some extra processing
    that's irrelevant to this specific example. It keeps items in priority order,
    not the order they were put into the queue, breaking the FIFO expectation. We'll
    use this in *Chapter 8*, in the *Functions are objects, too* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these implementations is slightly different. This suggests we want
    to create handy wrapper classes around them to provide a uniform interface. We
    can create class definitions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the three essential operations for a queue. We can put something
    into the queue, appending it to the end. We can get something from the queue,
    removing the item at the head of the queue. Finally, we can ask if the queue is
    empty. We''ve layered this on a list class by extending it to add three new methods:
    `put()`, `get()`, and `empty()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next is a slightly different implementation. The `typing.Deque` type hint is
    the wrapper around the `collections.deque` class. A recent change to Python changed
    the underlying `collections.deque` class, removing the need for a special hint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It's hard to see the distinction between this implementation and the generic
    list implementation. It turns out the `popleft()` method is a higher-speed version
    of `pop(0)` in a conventional list. Otherwise, this looks very similar to the
    list-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a final version that uses the `queue` module. This `queue` module's implementation
    uses locks to prevent the data structure from being damaged by concurrent access
    across multiple threads. It's generally opaque to us, except as a tiny performance
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This implementation works because we decided to use the `Queue` class interface
    as the template for the other two classes. This meant we didn't have to do any
    real work to implement this class; this design was the overall target for the
    other class designs.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints, however, are rather complex-looking. The `queue.Queue` class
    definition is also a generic type hint. When the code is being examined by **mypy**,
    the `TYPE_CHECKING` variable is `True`, and we need to provide a parameter to
    the generic type. When the `TYPE_CHECKING` variable is `False`, we're not using
    **mypy**, and the class name (without any additional parameters) is all that's
    needed to define a queue at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three classes are similar with respect to the three defined methods.
    We could define an abstract base class for them. Or we could provide the following
    type hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This `PathQueue` type hint summarizes all three types, allowing us to define
    an object of any of these three classes to use for the final implementation choice.
  prefs: []
  type: TYPE_NORMAL
- en: The question of "which is better" is answered by the standard response of "it
    depends on what you need to do."
  prefs: []
  type: TYPE_NORMAL
- en: For single-threaded applications, the `collections.deque` is ideal; it's designed
    for this purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For multi-threaded applications, the `queue.Queue` is required to provide a
    data structure that can be read and written by multiple concurrent threads. We'll
    return to this in *Chapter 14*, *Concurrency*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we can often leverage a built-in structure, like the generic `list` class,
    for a wide variety of purposes, it may not be ideal. The other two implementations
    offer advantages over the built-in list. Python's standard library, and the broader
    ecosystem of external packages available through the Python Package Index (PYPI),
    can provide improvements over generic structures. What's important is having a
    specific improvement before searching high and low for a "perfect" package. In
    our example, the performance difference between the `deque` and the `list` is
    small. The time is dominated by the OS work required to gather the raw data. For
    a large file system, perhaps spanning multiple hosts, the difference will add
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Python's object-orientation gives us the latitude to explore design alternatives.
    We should feel free to try more than one solution to a problem as a way to better
    understand the problem, and arrive at an acceptable solution.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter's case study, we'll revisit our design, leveraging Python's
    `@dataclass` definitions. This holds some potential for streamlining our design.
    We'll be looking at some choices and limitations; this will lead us to explore
    some difficult engineering trade-offs, where there isn't one obvious best approach.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at immutable `NamedTuple` class definitions. These objects have
    no internal state changes, leading to the possibility of some design simplifications.
    This will also change our design to make less use of inheritance and more use
    of composition.
  prefs: []
  type: TYPE_NORMAL
- en: Logical model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the design we have so far for our `model.py` module. This shows
    the hierarchy of `Sample` class definitions, used to reflect the various ways
    samples are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Class diagram so far'
  prefs: []
  type: TYPE_NORMAL
- en: 'The various `Sample` classes are a very good fit with the dataclass definition.
    These objects have a number of attributes, and the methods built automatically
    seem to fit the behaviors we want. Here''s the revised `Sample` class, implemented
    as a `@dataclass` instead of being built entirely by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `@dataclass` decorator to create a class from the supplied
    attribute type hints. We can use the resulting `Sample` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how we create instances of a class defined with the `@dataclass`
    decorator. Note that a representation function, `__repr__()`, was automatically
    created for us; it displays a useful level of detail, as shown in the example
    above. This is very pleasant. It almost feels like cheating!
  prefs: []
  type: TYPE_NORMAL
- en: Here are the definitions for some more of the `Sample` class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This seems to cover the user stories described in *Chapter 1*, *Object-Oriented
    Design*, and expanded in *Chapter 4*, *Expecting the Unexpected*. We can provide
    training data, test the classifier, and handle the classification of unknown samples.
    We didn't have to write very much code and we get a lot of useful features.
  prefs: []
  type: TYPE_NORMAL
- en: We do have a potential problem, however. While we are permitted to set a classification
    attribute on a `TrainingKnownSample` instance, this doesn't seem to be a great
    idea. Here's an example, where we create a sample to be used for training, and
    then also set a classification attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Generally, Python doesn't stop us from creating a new attribute, like `classification`,
    in an object. This behavior could be the source of hidden bugs. (A good unit test
    will often expose these bugs.) Note the additional attribute is not reflected
    in the `__repr__()` method processing or `__eq__()` method comparisons for this
    class. It's not a serious problem. In later sections, we'll address it using frozen
    dataclasses as well as the `typing.NamedTuple` class.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining classes in our model don't enjoy the same huge benefit from being
    implemented as dataclasses as the `Sample` classes did. When a class has a lot
    of attributes, and few methods, then the `@dataclass` definition is a big help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another class to benefit the most from the `@dataclass` treatment is the `Hyperparameter` class.
    Here''s the first part of the definition, with the method body omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This reveals an interesting feature that is made available when we use `from
    __future__ import annotations`. Specifically, the value of `weakref.ReferenceType["TrainingData"]`has
    two distinct goals:'
  prefs: []
  type: TYPE_NORMAL
- en: The **mypy** tool uses this to check type references. We must provide a qualifier, `weakref.ReferenceType["TrainingData"]`.
    This uses a string as a forward reference to the yet-undefined `TrainingData` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When evaluated at runtime by the `@dataclass` decorator to build a class definition,
    the additional type qualifier isn't used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've omitted the details of the `classify()` method. We'll examine some alternative
    implementations in *Chapter 10*, *The Iterator Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't seen all the features of dataclasses. In the next section, we'll
    freeze them to help spot the kind of bug where a piece of training data is used
    for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Frozen dataclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The general case for dataclasses is to create mutable objects. The state of
    an object can be changed by assigning new values to the attributes. This isn't
    always a desirable feature, and we can make a dataclass immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe the UML diagram of the design by adding a stereotype of `«Frozen»`.
    This notation can help to remind us of the implementation choice of making the
    object immutable. We must also respect an important rule of frozen dataclasses:
    an extension via inheritance must also be frozen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the frozen `Sample` objects must be kept separate from the
    mutable objects that are part of processing an unknown or testing sample. This
    splits our design into two families of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: A small hierarchy of immutable classes, specifically `Sample` and `KnownSample`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some associated classes that leverage these frozen classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The related classes for testing samples, training samples, and unknown samples
    form a loose collection of classes with nearly identical methods and attributes.
    We can call this a "paddling" of related classes. This comes from the duck typing
    rule: "When I see a bird that walks like a duck and quacks like a duck, I call
    that bird a duck." Objects created from classes with the same attributes and methods
    are interchangeable, even though they lack a common abstract superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe this revised design with a diagram like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Revised class diagram with frozen classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the change to the `Sample` class hierarchy. It''s relatively minor
    and easy to overlook the `frozen=True` in a few places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create an instance of a `TrainingKnownSample` or `TestingKnownSample`,
    we have to respect the composition of these objects: there''s a frozen `KnownSample` object
    inside each of these classes. The following example shows one way to create a
    composite object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This nested construction of a `TrainingKnownSample` instance containing a `KnownSample` object
    is explicit. It exposes the immutable `KnownSample` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frozen design has a very pleasant consequence for detecting subtle bugs.
    The following example shows the exception raised by improper use of a `TrainingKnownSample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can't accidentally introduce a bug that changes a training instance.
  prefs: []
  type: TYPE_NORMAL
- en: We get one more bonus feature that makes it easier to spot duplicates when allocating
    instances to the training set. The frozen versions of the `Sample` (and `KnownSample`)
    classes produce a consistent `hash()` value. This makes it easier to locate duplicate
    values by examining the subset of items with a common hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate use of `@dataclass` and `@dataclass(frozen=True)` can be a big help
    in implementing object-oriented Python. These definitions provide a rich set of
    features with minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: One other technique available to us is similar to the frozen dataclass, the
    `typing.NamedTuple`. We'll look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: NamedTuple classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `typing.NamedTuple` is somewhat similar to using `@dataclass(frozen=True)`.
    There are some significant differences in the implementation details, however.
    In particular, the `typing.NamedTuple` class does not support inheritance in the
    most obvious way. This leads us to a design based around composition of objects
    in the `Sample` class hierarchy. With inheritance, we're often extending a base
    class to add features. With composition, we're often building multi-part objects
    of several different classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of `Sample` as `NamedTuple`. It looks similar to the
    `@dataclass` definition. The definition of `KnownSample`, however, must change
    dramatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `KnownSample` class is a composite, built from a `Sample` instance, plus
    the species assigned when the data was loaded initially. Since these are both
    subclasses of `typing.NamedTuple`, the values are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shifted from inheritance to composition in our design. Here are the
    two concepts, side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Inheritance-based versus composition-based class designs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences can be easy to overlook in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an **inheritance-focused** design, a `KnownSample` instance is a `Sample`
    instance. It has five attributes: all four attributes inherited from the `Sample`
    class plus one attribute unique to the `KnownSample` subclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a **composition-focused** design, a `KnownSample_C` instance is composed
    of a `Sample` instance and a species classification. It has two attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've seen, both designs will work. The choice is difficult and often revolves
    around the number and the complexity of the methods that are inherited from the
    superclass. In this example, there are no methods of importance to the application
    defined in the `Sample` class.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance versus composition design decision represents a difficult choice
    with no single, right answer. The decision is often helped by a nuanced understanding
    of whether a subclass truly is a member of the superclass or not. Metaphorically,
    we often ask if an Apple is a Fruit to help understand narrower subclasses and
    generic superclasses. The problem we have is that an Apple can also be a Dessert,
    confounding what seemed to be a simple decision with additional details.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget, an Apple (as applesauce) may be part of the Main Course, also.
    This kind of complication can make an "is-a" question harder to answer. In our
    case, the "is-a" relationship between samples, known samples, unknown samples,
    testing, and training samples may not be the best path forward. We seem to have
    multiple roles (i.e., testing, training, to-be-classified) that are associated
    with each sample, and there may only be two subclasses of `Sample`, known and
    unknown.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestingKnownSample` and `TrainingKnownSample` class definitions follow
    the duck typing rule. They have similar attributes and can be used interchangeably
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In this case, both `TestingKnownSample` and `TrainingKnownSample` are composite
    objects that contain a `KnownSample` object. The primary difference is the presence
    (or absence) of an additional attribute, the `classification` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of creating a `TrainingKnownSample` and trying (erroneously)
    to set the classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The code reflects the composite-of-composite design. A `TrainingKnownSample`
    instance contains a `KnownSample` object, which contains a `Sample` object. The
    example shows that we cannot add a new attribute to a `TrainingKnownSample` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we've seen a total of four ways to address object-oriented design
    and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we've looked at creating objects "from scratch," writing
    all the method definitions ourselves. We've emphasized inheritance among the classes
    in the `Sample` class hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we've seen a stateful class definition using `@dataclass`.
    This supports inheritance among the classes in the `Sample` class hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've also seen a stateless (or immutable) definition using `@dataclass(frozen=True)`.
    This tends to discourage some aspects of inheritance and favor composition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we've looked at stateless (or immutable) definitions using `NamedTuple`.
    This must be designed using composition. This preliminary overview of these classes
    makes the design seem quite simple. We'll return to this in *Chapter 8*, *The
    Intersection of Object-Oriented and Functional Programming*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot of flexibility in Python. It's important to look at the choices
    from the viewpoint of our future self trying to add or alter features. It helps
    to follow the SOLID design principles and focus on Single Responsibility and Interface
    Segregation to isolate and encapsulate our class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've explored a variety of built-in Python data structures in this chapter.
    Python lets us do a great deal of object-oriented programming without the overheads
    of numerous, potentially confusing, class definitions. We can rely on a number
    of built-in classes where they fit our problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and named tuples let us leverage a simple collection of attributes. We
    can extend the `NamedTuple` definition to add methods when those are necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataclasses provide sophisticated collections of attributes. A variety of methods
    can be provided for us, simplifying the code we need to write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries are an essential feature, used widely in Python. There are many
    places where keys are associated with values. The syntax for using the built-in
    dictionary class makes it easy to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists and sets are also first-class parts of Python; our applications can make
    use of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also looked at three types of queues. These are more specialized structures
    with more focused patterns of access than a generic list object. The idea of specialization
    and narrowing the domain of features can lead to performance improvements, also,
    making the concept widely applicable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, in the case study, we looked at ways to use these built-in classes
    to define our data samples used for testing and training.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to learn how to choose the correct data structure is to do it wrong
    a few times (intentionally or accidentally!). Take some code you've recently written,
    or write some new code that uses a list. Try rewriting it using some different
    data structures. Which ones make more sense? Which ones don't? Which have the
    most elegant code?
  prefs: []
  type: TYPE_NORMAL
- en: Try this with a few different pairs of data structures. You can look at examples
    you've done for previous chapter exercises. Are there objects with methods where
    you could have used dataclasses, `namedtuple`, or `dict` instead? Attempt both
    and see. Are there dictionaries that could have been sets because you don't really
    access the values? Do you have lists that check for duplicates? Would a set suffice?
    Or maybe several sets? Would one of the queue implementations be more efficient?
    Is it useful to restrict the API to the top of a stack rather than allowing random
    access to the list?
  prefs: []
  type: TYPE_NORMAL
- en: Have you written any container objects recently that you could improve by inheriting
    a built-in and overriding some of the *special* double-underscore methods? You
    may have to do some research (using `dir` and `help`, or the Python library reference)
    to find out which methods need overriding.
  prefs: []
  type: TYPE_NORMAL
- en: Are you sure inheritance is the correct tool to apply; could a composition-based
    solution be more effective? Try both (if it's possible) before you decide. Try
    to find different situations where each method is better than the other.
  prefs: []
  type: TYPE_NORMAL
- en: If you were familiar with the various Python data structures and their uses
    before you started this chapter, you may have been bored. But if that is the case,
    there's a good chance you use data structures too much! Look at some of your old
    code and rewrite it to use more self-made classes. Carefully consider the alternatives
    and try them all out; which one makes for the most readable and maintainable system?
  prefs: []
  type: TYPE_NORMAL
- en: The `MultiItem` example in this section started with a clunky-looking `__lt__()`
    method. The second version had a slightly nicer `__eq__()` method. Rewrite `__lt__()`
    to follow the design pattern of `__eq__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bigger problem with the original class design was trying to handle the
    variety of subtypes and their optional fields. The presence of an optional attribute
    is a suggestion that – perhaps – there are distinct classes struggling to separate
    from each other. What happens if we distinguish between two closely related but
    distinct classes: `LocalItem` (which uses `timestamp`) and `RemoteItem` (which
    uses `created_date`). We can define a common type hint as a `Union[LocalItem,
    RemoteItem]`. If each class has a property like `creation_datetime` that computes
    a `datetime.datetime` object, would processing be simpler? Build the two classes;
    create some test data. How does it look to separate the two subtypes?'
  prefs: []
  type: TYPE_NORMAL
- en: Always critically evaluate your code and design decisions. Make a habit of reviewing
    old code and take note of whether your understanding of *good design* has changed
    since you wrote it. Software design has a large aesthetic component, and like
    artists with oil on canvas, we all have to find the style that suits us best.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered several built-in data structures and attempted to understand how
    to choose one for specific applications. Sometimes, the best thing we can do is
    create a new class of objects, but often, one of the built-ins provides exactly
    what we need. When it doesn't, we can always use inheritance or composition to
    adapt them to our use cases. We can even override special methods to completely
    change the behavior of built-in syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss how to integrate the object-oriented and
    not-so-object-oriented aspects of Python. Along the way, we'll discover that it's
    more object-oriented than it looks at first sight!
  prefs: []
  type: TYPE_NORMAL
