<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor121"/>5</h1>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor122"/>Behavioral Design Patterns</h1>
			<p>In the previous chapter, we covered structural patterns and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) patterns that help us create clean, maintainable, and scalable code. The next category of design patterns is <strong class="bold">behavioral design patterns</strong>. Behavioral patterns deal with <a id="_idIndexMarker408"/>object interconnection <span class="No-Break">and algorithms.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The Chain of <span class="No-Break">Responsibility pattern</span></li>
				<li>The <span class="No-Break">Command pattern</span></li>
				<li>The <span class="No-Break">Observer pattern</span></li>
				<li>The <span class="No-Break">State pattern</span></li>
				<li>The <span class="No-Break">Interpreter pattern</span></li>
				<li>The <span class="No-Break">Strategy pattern</span></li>
				<li>The <span class="No-Break">Memento pattern</span></li>
				<li>The <span class="No-Break">Iterator pattern</span></li>
				<li>The <span class="No-Break">Template pattern</span></li>
				<li>Other behavioral <span class="No-Break">design patterns</span></li>
			</ul>
			<p>At the end of this chapter, you will know how to improve your software project designs using <span class="No-Break">behavioral patterns.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor123"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. The additional technical requirements for the code discussed in this chapter are <span class="No-Break">the following:</span></p>
			<ul>
				<li>For the State pattern section, install the <strong class="source-inline">state_machine</strong> module, using the command: <strong class="source-inline">python -m pip </strong><span class="No-Break"><strong class="source-inline">install</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">state_machine</strong></span><span class="No-Break">.</span></li>
				<li>For the Interpreter pattern section, install the <strong class="source-inline">pyparsing</strong> module, using the command: <strong class="source-inline">python –m pip </strong><span class="No-Break"><strong class="source-inline">install pyparsing</strong></span><span class="No-Break">.</span></li>
				<li>For the Template pattern section, install the <strong class="source-inline">cowpy</strong> module, using the command: <strong class="source-inline">python -m pip </strong><span class="No-Break"><strong class="source-inline">install cowpy</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor124"/>The Chain of Responsibility pattern</h1>
			<p>The<a id="_idIndexMarker409"/> Chain of Responsibility pattern offers an<a id="_idIndexMarker410"/> elegant way to handle requests by passing them through a chain of handlers. Each handler in the chain has the autonomy to decide whether it can process the request or if it should delegate it further along the chain. This pattern shines when dealing with operations that involve multiple handlers but don’t necessarily require all of them to <span class="No-Break">be involved.</span></p>
			<p>In practice, this pattern encourages us to focus on objects and the flow of a request within an application. Notably, the client code remains blissfully unaware of the entire chain of handlers. Instead, it only interacts with the first processing element in the chain. Similarly, each processing element knows only about its immediate successor, forming a one-way relationship similar to a singly linked list. This structure is purposefully designed to achieve decoupling between the sender (client) and the receivers (<span class="No-Break">processing elements).</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor125"/>Real-world examples</h2>
			<p>ATMs and, in general, any kind of<a id="_idIndexMarker411"/> machine that accepts/returns banknotes or coins (for example, a snack-vending machine) use the Chain of Responsibility pattern. There is always a single slot for all banknotes, as shown in the following diagram, courtesy <span class="No-Break">of </span><a href="http://www.sourcemaking.com"><span class="No-Break">www.sourcemaking.com</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B21896_05_01.jpg" alt="Figure 5.1 – Chain of Responsibility example: the ATM"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Chain of Responsibility example: the ATM</p>
			<p>When a <a id="_idIndexMarker412"/>banknote is dropped, it is <a id="_idIndexMarker413"/>routed to the appropriate receptacle. When it is returned, it is taken from the appropriate receptacle. We can think of the single slot as the shared communication medium and the different receptacles as the processing elements. The result contains cash from one or more receptacles. For example, in the preceding diagram, we see what happens when we request $175 from <span class="No-Break">the ATM.</span></p>
			<p>In some web frameworks, filters or middleware are pieces of code that are executed before an HTTP request arrives at a target. There is a chain of filters. Each filter performs a different action (user authentication, logging, data compression, and so forth), and either forwards the request to the next filter until the chain is exhausted, or it breaks the flow if there is an error—for example, the authentication failed three <span class="No-Break">consecutive times.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor126"/>Use cases for the Chain of Responsibility pattern</h2>
			<p>By using<a id="_idIndexMarker414"/> the Chain of Responsibility pattern, we <a id="_idIndexMarker415"/>provide a chance for a number of different objects to satisfy a specific request. This is useful when we don’t know in advance which object should satisfy a given request. An example of this is a <strong class="bold">purchase system</strong>. In<a id="_idIndexMarker416"/> purchase systems, there are many approval authorities. One approval authority might be able to approve orders up to a certain value, let’s say $100. If the order is for more than $100, the order is sent to the next approval authority in the chain, which can approve orders up to $200, and <span class="No-Break">so forth.</span></p>
			<p>Another case where the Chain of Responsibility is useful is when we know that more than one object might need to process a single request. This is what happens in event-based programming. A single event, such as a left-mouse click, can be caught by more than <span class="No-Break">one listener.</span></p>
			<p>It is important to note that the Chain of Responsibility pattern is not very useful if all the requests can be taken care of by a single processing element unless we really don’t know which element that is. The value of this pattern is the decoupling that it offers, as we have seen in the <em class="italic">Loose coupling</em> section of <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational Design Principles</em>. Instead of having a many-to-many relationship between a client and all processing elements (and the same is true regarding the relationship between a processing element and all other processing elements), a client only needs to know how to communicate with the start (head) of <span class="No-Break">the chain.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor127"/>Implementing the Chain of Responsibility pattern</h2>
			<p>There are many ways to implement<a id="_idIndexMarker417"/> a Chain of Responsibility in Python, but my favorite implementation is the one by Vespe Savikko (<a href="https://legacy.python.org/workshops/1997-10/proceedings/savikko.html">https://legacy.python.org/workshops/1997-10/proceedings/savikko.html</a>). Vespe’s implementation uses dynamic dispatching in a Pythonic style to <span class="No-Break">handle requests.</span></p>
			<p>Let’s implement a simple, event-based system using Vespe’s implementation as a guide. The following is the UML class diagram of <span class="No-Break">the system:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B21896_05_02.jpg" alt="Figure 5.2 – UML class diagram of an event-based window system"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – UML class diagram of an event-based window system</p>
			<p>The <strong class="source-inline">Event</strong> class <a id="_idIndexMarker418"/>describes an event. We’ll<a id="_idIndexMarker419"/> keep it simple, so, in our case, an event has <span class="No-Break">only </span><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
class Event:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name</pre>			<p>The <strong class="source-inline">Widget</strong> class is the core class of the application. The <strong class="bold">parent</strong> aggregation shown in the UML diagram indicates that each widget can have a reference to a <strong class="source-inline">parent</strong> object, which, by convention, we assume is a <strong class="source-inline">Widget</strong> instance. Note, however, that according to the rules of inheritance, an instance of any of the subclasses of <strong class="source-inline">Widget</strong> (for example, an instance of <strong class="source-inline">MsgText</strong>) is also an instance of <strong class="source-inline">Widget</strong>. The class has a <strong class="source-inline">handle()</strong> method, which uses dynamic dispatching through <strong class="source-inline">hasattr()</strong> and <strong class="source-inline">getattr()</strong> to decide who the handler of a specific request (event) is. If the widget that is asked to handle an event does not support it, there are two fallback mechanisms. If the widget has a parent, then the <strong class="source-inline">handle()</strong> method of the parent is executed. If the widget has no parent but a <strong class="source-inline">handle_default()</strong> method, <strong class="source-inline">handle_default()</strong> is executed. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Widget:
    def __init__(self, parent=None):
        self.parent = parent
    def handle(self, event):
        handler = f"handle_{event}"
        if hasattr(self, handler):
            method = getattr(self, handler)
            method(event)
        elif self.parent is not None:
            self.parent.handle(event)
        elif hasattr(self, "handle_default"):
            self.handle_default(event)</pre>			<p>At this point, you <a id="_idIndexMarker420"/>might have realized<a id="_idIndexMarker421"/> why the <strong class="source-inline">Widget</strong> and <strong class="source-inline">Event</strong> classes are only associated (no aggregation or composition relationships) in the UML class diagram. The association is used to show that the <strong class="source-inline">Widget</strong> class knows about the <strong class="source-inline">Event</strong> class but does not have any strict reference to it, since an event needs to be passed only as a parameter <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">handle()</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">MainWIndow</strong>, <strong class="source-inline">MsgText</strong>, and <strong class="source-inline">SendDialog</strong> are all widgets with different behaviors. Not all these three widgets are expected to be able to handle the same events, and even if they can handle the same event, they might behave differently. <strong class="source-inline">MainWindow</strong> can handle only the close and <span class="No-Break">default events:</span></p>
			<pre class="source-code">
class MainWindow(Widget):
    def handle_close(self, event):
        print(f"MainWindow: {event}")
    def handle_default(self, event):
        print(f"MainWindow Default: {event}")</pre>			<p><strong class="source-inline">SendDialog</strong> can handle only the <span class="No-Break"><strong class="source-inline">paint</strong></span><span class="No-Break"> event:</span></p>
			<pre class="source-code">
class SendDialog(Widget):
    def handle_paint(self, event):
        print(f"SendDialog: {event}")</pre>			<p>Finally, <strong class="source-inline">MsgText</strong> can handle only the <span class="No-Break"><strong class="source-inline">down</strong></span><span class="No-Break"> event:</span></p>
			<pre class="source-code">
class MsgText(Widget):
    def handle_down(self, event):
        print(f"MsgText: {event}")</pre>			<p>The <strong class="source-inline">main()</strong> function<a id="_idIndexMarker422"/> shows how we can create <a id="_idIndexMarker423"/>a few widgets and events, and how the widgets react to those events. All events are sent to all the widgets. Note the parent relationship of each widget—the <strong class="source-inline">sd</strong> object (an instance of <strong class="source-inline">SendDialog</strong>) has as its parent the <strong class="source-inline">mw</strong> object (an instance of <strong class="source-inline">MainWindow</strong>). However, not all objects need to have a parent that is an instance of <strong class="source-inline">MainWindow</strong>. For example, the <strong class="source-inline">msg</strong> object (an instance of <strong class="source-inline">MsgText</strong>) has the <strong class="source-inline">sd</strong> object as <span class="No-Break">a parent:</span></p>
			<pre class="source-code">
def main():
    mw = MainWindow()
    sd = SendDialog(mw)
    msg = MsgText(sd)
    for e in ("down", "paint", "unhandled", "close"):
        evt = Event(e)
        print(f"Sending event -{evt}- to MainWindow")
        mw.handle(evt)
        print(f"Sending event -{evt}- to SendDialog")
        sd.handle(evt)
        print(f"Sending event -{evt}- to MsgText")
        msg.handle(evt)</pre>			<p>Let’s recapitulate the complete code (see file <strong class="source-inline">ch05/chain.py</strong>) of <span class="No-Break">the implementation:</span></p>
			<ol>
				<li>We define the <strong class="source-inline">Event</strong> class, followed by the <span class="No-Break"><strong class="source-inline">Widget</strong></span><span class="No-Break"> class.</span></li>
				<li>We define the specialized widget classes, <strong class="source-inline">MainWindow</strong>, <strong class="source-inline">SendDialog</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">MsgText</strong></span><span class="No-Break">.</span></li>
				<li>Finally, we add the code for the <strong class="source-inline">main()</strong> function; we make sure it can be called thanks to the usual trick at <span class="No-Break">the end.</span></li>
			</ol>
			<p>Executing<a id="_idIndexMarker424"/> the <strong class="source-inline">python ch05/chain.py</strong> command <a id="_idIndexMarker425"/>gives us the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Sending event -down- to MainWindow</strong>
<strong class="bold">MainWindow Default: down</strong>
<strong class="bold">Sending event -down- to SendDialog</strong>
<strong class="bold">MainWindow Default: down</strong>
<strong class="bold">Sending event -down- to MsgText</strong>
<strong class="bold">MsgText: down</strong>
<strong class="bold">Sending event -paint- to MainWindow</strong>
<strong class="bold">MainWindow Default: paint</strong>
<strong class="bold">Sending event -paint- to SendDialog</strong>
<strong class="bold">SendDialog: paint</strong>
<strong class="bold">Sending event -paint- to MsgText</strong>
<strong class="bold">SendDialog: paint</strong>
<strong class="bold">Sending event -unhandled- to MainWindow</strong>
<strong class="bold">MainWindow Default: unhandled</strong>
<strong class="bold">Sending event -unhandled- to SendDialog</strong>
<strong class="bold">MainWindow Default: unhandled</strong>
<strong class="bold">Sending event -unhandled- to MsgText</strong>
<strong class="bold">MainWindow Default: unhandled</strong>
<strong class="bold">Sending event -close- to MainWindow</strong>
<strong class="bold">MainWindow: close</strong>
<strong class="bold">Sending event -close- to SendDialog</strong>
<strong class="bold">MainWindow: close</strong>
<strong class="bold">Sending event -close- to MsgText</strong>
<strong class="bold">MainWindow: close</strong></pre>			<h1 id="_idParaDest-123"><a id="_idTextAnchor128"/>The Command pattern</h1>
			<p>Most <a id="_idIndexMarker426"/>applications nowadays have an undo operation. It is hard to<a id="_idIndexMarker427"/> imagine, but undo did not exist in any software for many years. Undo was introduced in 1974, but Fortran and Lisp, two programming languages that are still widely used, were created in 1957 and 1958, respectively! I wouldn’t like to have been an application user during those years. Making a mistake meant that the user had no easy way to <span class="No-Break">fix it.</span></p>
			<p>Enough with the history. We want to know how we can implement the undo functionality in our applications. Since you have read the title of this chapter, you already know which design pattern is recommended to implement undo: the <span class="No-Break">Command pattern.</span></p>
			<p>The Command design pattern helps us encapsulate an operation (undo, redo, copy, paste, and so forth) as an object. What this simply means is that we create a class that contains all the logic and the methods required to implement the operation. The advantages of doing this are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We don’t have to execute a command directly. It can be executed <span class="No-Break">at will.</span></li>
				<li>The object that invokes the command is decoupled from the object that knows how to perform it. The invoker does not need to know any implementation details about <span class="No-Break">the command.</span></li>
				<li>If it makes sense, multiple commands can be grouped to allow the invoker to execute them in order. This is useful, for instance, when implementing a multilevel <span class="No-Break">undo command.</span></li>
			</ul>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor129"/>Real-world examples</h2>
			<p>When we go to<a id="_idIndexMarker428"/> a restaurant for dinner, we give the <a id="_idIndexMarker429"/>order to the waiter. The check (usually paper) that they use to write the order is an example of a command. After writing the order, the waiter places it in the check queue that is executed by the cook. Each check is independent and can be used to execute many different commands, for example, one command for each item that will <span class="No-Break">be cooked.</span></p>
			<p>As you would expect, we also have several examples in the software. Here are two I can <span class="No-Break">think of:</span></p>
			<ul>
				<li>PyQt is the Python binding of the QT toolkit. PyQt contains a <strong class="source-inline">QAction</strong> class that models an action as a command. Extra optional information is supported for every action, such as description, tooltip, <span class="No-Break">and shortcut.</span></li>
				<li>Git Cola, a Git GUI written in Python, uses the command pattern to modify the model, amend a commit, apply a different election, check out, and <span class="No-Break">so forth.</span></li>
			</ul>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor130"/>Use cases for the Command pattern</h2>
			<p>Many developers use the undo<a id="_idIndexMarker430"/> example as the only use case of the Command pattern. The truth is that undo is the killer feature of the Command pattern. However, the Command pattern can actually do <span class="No-Break">much more:</span></p>
			<ul>
				<li><strong class="bold">GUI buttons and menu items</strong>: The PyQt example that was already mentioned uses the Command pattern to implement actions on buttons and <span class="No-Break">menu items.</span></li>
				<li><strong class="bold">Other operations</strong>: Apart from undo, commands can be used to implement any operation. A few examples are <em class="italic">cut</em>, <em class="italic">copy</em>, <em class="italic">paste</em>, <em class="italic">redo</em>, and <span class="No-Break"><em class="italic">capitalize text</em></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Transactional behavior and logging</strong>: Transactional behavior and logging are important to keep a persistent log of changes. They are used by operating systems to recover from system crashes, relational databases to implement transactions, filesystems to implement snapshots, and installers (wizards) to revert <span class="No-Break">canceled installations.</span></li>
				<li><strong class="bold">Macros</strong>: By macros, in this case, we mean a sequence of actions that can be recorded and<a id="_idIndexMarker431"/> executed on demand at any point in time. Popular editors such as Emacs and<a id="_idIndexMarker432"/> Vim <span class="No-Break">support macros.</span></li>
			</ul>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor131"/>Implementing the Command pattern</h2>
			<p>Let’s use the Command pattern to implement<a id="_idIndexMarker433"/> the following basic <span class="No-Break">file utilities:</span></p>
			<ul>
				<li>Creating a file and, optionally, adding text <span class="No-Break">to it</span></li>
				<li>Reading the contents of <span class="No-Break">a file</span></li>
				<li>Renaming <span class="No-Break">a file</span></li>
			</ul>
			<p>We are not going to implement these utilities from scratch since Python already offers good implementations for them in the <strong class="source-inline">os</strong> module. What we want to do is to add an extra abstraction level on top of them so that they can be treated as commands. By doing this, we get all the advantages offered <span class="No-Break">by commands.</span></p>
			<p>Each command has <span class="No-Break">two parts:</span></p>
			<ul>
				<li><strong class="bold">The initialization part</strong>: It is taken care of by the <strong class="source-inline">__init__()</strong> method and contains all the information required by the command to be able to do something useful (the path of a file, the contents that will be written to the file, and <span class="No-Break">so forth).</span></li>
				<li><strong class="bold">The execution part</strong>: It is taken care of by the <strong class="source-inline">execute()</strong> method. We call that method when we want to run a command. This is not necessarily right after <span class="No-Break">initializing it.</span></li>
			</ul>
			<p>Let’s start <a id="_idIndexMarker434"/>with the rename utility, which we implement<a id="_idIndexMarker435"/> using the <strong class="source-inline">RenameFile</strong> class. The class is initialized using the source and destination file paths. We add the <strong class="source-inline">execute()</strong> method, which does the actual renaming using <strong class="source-inline">os.rename()</strong>. To provide support for the undo operation, we add the <strong class="source-inline">undo()</strong> method, where we use <strong class="source-inline">os.rename()</strong> again to revert the name of the file to its original value. Note that we also use logging to improve <span class="No-Break">the output.</span></p>
			<p>The beginning of the code, the imports we need, and the <strong class="source-inline">RenameFile</strong> class, are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import logging
import os
logging.basicConfig(level=logging.DEBUG)
class RenameFile:
    def __init__(self, src, dest):
        self.src = src
        self.dest = dest
    def execute(self):
        logging.info(
            f"[renaming '{self.src}' to '{self.dest}']"
        )
        os.rename(self.src, self.dest)
    def undo(self):
        logging.info(
            f"[renaming '{self.dest}' back to '{self.src}']"
        )
        os.rename(self.dest, self.src)</pre>			<p>Next, we <a id="_idIndexMarker436"/>add a <strong class="source-inline">CreateFile</strong> class for the command used <a id="_idIndexMarker437"/>to create a file. The initialization method for that class accepts the familiar <strong class="source-inline">path</strong> parameter and a <strong class="source-inline">txt</strong> parameter for the content that will be written to the file. If nothing is passed as content, the default “hello world” text is written to the file. Normally, the sane default behavior is to create an empty file, but for the needs of this example, I decided to write a default string in it. Then, we add an <strong class="source-inline">execute()</strong> method, in which we use Python’s <strong class="source-inline">open()</strong> function to open the file in <strong class="bold">write mode</strong>, and the <strong class="source-inline">write()</strong> function to write the <strong class="source-inline">txt</strong> string <span class="No-Break">to it.</span></p>
			<p>The undo for the operation of creating a file is to delete that file. Thus, the <strong class="source-inline">undo()</strong> method is added to the class, where we use the <strong class="source-inline">os.remove()</strong> function to do <span class="No-Break">the job.</span></p>
			<p>The definition for the <strong class="source-inline">CreateFile</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class CreateFile:
    def __init__(self, path, txt="hello world\n"):
        self.path = path
        self.txt = txt
    def execute(self):
        logging.info(f"[creating file '{self.path}']")
        with open(
            self.path, "w", encoding="utf-8"
        ) as out_file:
            out_file.write(self.txt)
    def undo(self):
        logging.info(f"deleting file {self.path}")
        os.remove(self.path)</pre>			<p>The last<a id="_idIndexMarker438"/> utility gives us the ability to read the contents of<a id="_idIndexMarker439"/> a file. The <strong class="source-inline">execute()</strong> method of the <strong class="source-inline">ReadFile</strong> class uses <strong class="source-inline">open()</strong> again, this time in read mode, and just prints the content of <span class="No-Break">the file.</span></p>
			<p>The <strong class="source-inline">ReadFile</strong> class is defined <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class ReadFile:
    def __init__(self, path):
        self.path = path
    def execute(self):
        logging.info(f"[reading file '{self.path}']")
        with open(
            self.path, "r", encoding="utf-8"
        ) as in_file:
            print(in_file.read(), end="")</pre>			<p>The <strong class="source-inline">main()</strong> function makes use of the utilities we have defined. The <strong class="source-inline">orig_name</strong> and <strong class="source-inline">new_name</strong> parameters are the original and new name of the file that is created and renamed. A commands list is used to add (and configure) all the commands that we want to execute at a later point. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    orig_name, new_name = "file1", "file2"
    commands = (
        CreateFile(orig_name),
        ReadFile(orig_name),
        RenameFile(orig_name, new_name),
    )
for c in commands:
    c.execute()</pre>			<p>Then, we ask<a id="_idIndexMarker440"/> the users whether they want to undo the <a id="_idIndexMarker441"/>executed commands or not. The user selects whether the commands will be undone or not. If they choose to undo them, <strong class="source-inline">undo()</strong> is executed for all commands in the commands list. However, since not all commands support undo, exception handling is used to catch (and log) the <strong class="source-inline">AttributeError</strong> exception generated when the <strong class="source-inline">undo()</strong> method is missing. That part of the code would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
    answer = input("reverse the executed commands? [y/n] ")
    if answer not in "yY":
        print(f"the result is {new_name}")
        exit()
    for c in reversed(commands):
        try:
            c.undo()
        except AttributeError as e:
            logging.error(str(e))</pre>			<p>Let’s recapitulate the complete code (in the <strong class="source-inline">ch05/command.py</strong> file) of <span class="No-Break">the implementation:</span></p>
			<ol>
				<li>We import <strong class="source-inline">logging</strong> and <span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break"> modules.</span></li>
				<li>We do the usual <span class="No-Break">logging configuration.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">RenameFile</strong></span><span class="No-Break"> class.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">CreateFile</strong></span><span class="No-Break"> class.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">ReadFile</strong></span><span class="No-Break"> class.</span></li>
				<li>We add a <strong class="source-inline">main()</strong> function, and call it as usual, to test <span class="No-Break">our design.</span></li>
			</ol>
			<p>Executing the <strong class="source-inline">python ch05/command.py</strong> command gives us the following output, if we accept to reverse <span class="No-Break">the commands:</span></p>
			<pre class="source-code">
<strong class="bold">INFO:root:[creating file 'file1']</strong>
<strong class="bold">INFO:root:[reading file 'file1']</strong>
<strong class="bold">hello world</strong>
<strong class="bold">INFO:root:[renaming 'file1' to 'file2']</strong>
<strong class="bold">reverse the executed commands? [y/n] y</strong>
<strong class="bold">INFO:root:[renaming 'file2' back to 'file1']</strong>
<strong class="bold">ERROR:root:'ReadFile' object has no attribute 'undo'</strong>
<strong class="bold">INFO:root:deleting file file1</strong></pre>			<p>However, if we <a id="_idIndexMarker442"/>do not accept to reverse the commands, the<a id="_idIndexMarker443"/> output is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">INFO:root:[creating file 'file1']</strong>
<strong class="bold">INFO:root:[reading file 'file1']</strong>
<strong class="bold">hello world</strong>
<strong class="bold">INFO:root:[renaming 'file1' to 'file2']</strong>
<strong class="bold">reverse the executed commands? [y/n] n</strong>
<strong class="bold">the result is file2</strong></pre>			<p>These <a id="_idIndexMarker444"/>outputs are as<a id="_idIndexMarker445"/> expected. However, note that <strong class="source-inline">ERROR</strong>, in the first case, is normal for <span class="No-Break">this context.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor132"/>The Observer pattern</h1>
			<p>The <a id="_idIndexMarker446"/>Observer pattern describes a publish-subscribe relationship between a <a id="_idIndexMarker447"/>single object, the publisher, which is also known as the subject <a id="_idIndexMarker448"/>or <strong class="bold">observable</strong>, and one or more objects, the subscribers, also known<a id="_idIndexMarker449"/> as <strong class="bold">observers</strong>. So, the subject notifies the subscribers of any state changes, typically by calling one of <span class="No-Break">their methods.</span></p>
			<p>The ideas behind the Observer pattern are the same as those behind the separation of concerns principle, that is, to increase decoupling between the publisher and subscribers, and to make it easy to add/remove subscribers <span class="No-Break">at runtime.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor133"/>Real-world examples</h2>
			<p>Dynamics in an auction are similar to the<a id="_idIndexMarker450"/> behavior of the Observer pattern. Every auction bidder has a number paddle that is raised whenever they want to place a bid. Whenever the paddle is raised by a bidder, the auctioneer acts as the subject by updating the price of the bid and broadcasting the new price to all <span class="No-Break">bidders (subscribers).</span></p>
			<p>In software, we can cite at least <span class="No-Break">two examples:</span></p>
			<ul>
				<li><strong class="bold">Kivy</strong>, the <a id="_idIndexMarker451"/>Python framework for developing <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), has a module called <strong class="bold">Properties</strong>, which implements the Observer pattern. Using this technique, you can specify what should happen when a property’s <span class="No-Break">value changes.</span></li>
				<li>The <strong class="bold">RabbitMQ library</strong> provides an<a id="_idIndexMarker452"/> implementation of an <strong class="bold">Advanced Message Queuing Protocol </strong>(<strong class="bold">AMQP</strong>) messaging broker. It is possible to construct a Python application that interacts with RabbitMQ in such a way that it subscribes to messages and publishes them to queues, which is essentially the Observer <span class="No-Break">design pattern.</span></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor134"/>Use cases for the Observer pattern</h2>
			<p>We generally use the Observer<a id="_idIndexMarker453"/> pattern when we want to inform/update one or more objects (observers/subscribers) about a change that happened on a given object (subject/publisher/observable). The number of observers, as well as who those observers are, may vary and can be <span class="No-Break">changed dynamically.</span></p>
			<p>We can think of many cases where Observer can be useful. One such use case is news feeds. With RSS, Atom, or other related formats, you follow a feed, and every time it is updated, you receive a notification about <span class="No-Break">the update.</span></p>
			<p>The same concept exists in social networking applications. If you are connected to another person using a social networking service, and your connection updates something, you are notified <span class="No-Break">about it.</span></p>
			<p>Event-driven <a id="_idIndexMarker454"/>systems are another example where Observer is<a id="_idIndexMarker455"/> usually used. In such systems, you have listeners that listen for specific events. The listeners are triggered when an event they are listening to is created. This can be typing a specific key (on the keyboard), moving the mouse, and more. The event plays the role of the <em class="italic">publisher</em>, and the listeners play the role of the <em class="italic">observers</em>. The key point in this case is that multiple listeners (observers) can be attached to a single <span class="No-Break">event (publisher).</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor135"/>Implementing the Observer pattern</h2>
			<p>As an example, let’s implement<a id="_idIndexMarker456"/> a weather monitoring system. In such a system, you have a weather station that collects weather-related data (temperature, humidity, and atmospheric pressure). Our system needs to allow different devices and applications to receive real-time updates whenever there is a change in the <span class="No-Break">weather data.</span></p>
			<p>We can apply the Observer pattern using the <span class="No-Break">following elements:</span></p>
			<ul>
				<li><strong class="bold">Subject (weather station)</strong>: Create a <strong class="source-inline">WeatherStation</strong> class that acts as the subject. This class will maintain a list of observers (devices or applications) interested in receiving <span class="No-Break">weather updates.</span></li>
				<li><strong class="bold">Observers (devices and applications)</strong>: Implement various observer classes, representing devices such as smartphones, tablets, weather apps, and even a display screen in a local store. Each observer will subscribe to receive updates from the <span class="No-Break">weather station.</span></li>
				<li><strong class="bold">Registration and notification</strong>: The weather station provides methods for observers to register (<strong class="source-inline">subscribe</strong>) and unregister (<strong class="source-inline">unsubscribe</strong>) themselves. When there is a change in weather data (e.g., a new temperature reading), the weather station notifies all <span class="No-Break">registered observers.</span></li>
				<li><strong class="bold">Update mechanism</strong>: Each observer defines an <strong class="source-inline">update()</strong> method that the weather station calls when notifying about changes. For instance, a smartphone observer may update its weather app with the latest data, while a local store display may update its <span class="No-Break">digital sign.</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started.</span></p>
			<p>First, we define the <strong class="source-inline">Observer</strong> interface, which holds an <strong class="source-inline">update</strong> method that observers must implement. Observers are expected to update themselves when the subject’s <span class="No-Break">state changes:</span></p>
			<pre class="source-code">
class Observer:
    def update(self, temperature, humidity, pressure):
        pass</pre>			<p>Next, we<a id="_idIndexMarker457"/> define the <strong class="source-inline">WeatherStation</strong> subject class. It <a id="_idIndexMarker458"/>maintains a list of observers and provides methods to add and remove observers. The <strong class="source-inline">set_weather_data</strong> method is used to simulate changes in weather data. When the weather data changes, it notifies all registered observers by calling their <strong class="source-inline">update</strong> methods. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class WeatherStation:
    def __init__(self):
        self.observers = []
    def add_observer(self, observer):
        self.observers.append(observer)
    def remove_observer(self, observer):
        self.observers.remove(observer)
    def set_weather_data(self, temperature, humidity, pressure):
        for observer in self.observers:
            observer.update(temperature, humidity, pressure)</pre>			<p>Let’s now<a id="_idIndexMarker459"/> define the <strong class="source-inline">DisplayDevice</strong> observer class. Its <strong class="source-inline">update</strong> method <a id="_idIndexMarker460"/>prints weather information <span class="No-Break">when called:</span></p>
			<pre class="source-code">
class DisplayDevice(Observer):
    def __init__(self, name):
        self.name = name
    def update(self, temperature, humidity, pressure):
        print(f"{self.name} Display")
        print(
            f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"
        )</pre>			<p>Similarly, we define another observer class, <strong class="source-inline">WeatherApp</strong>, which prints weather information in a different format when its <strong class="source-inline">update</strong> method <span class="No-Break">is called:</span></p>
			<pre class="source-code">
class WeatherApp(Observer):
    def __init__(self, name):
        self.name = name
    def update(self, temperature, humidity, pressure):
        print(f"{self.name} App - Weather Update")
        print(
            f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"
        )</pre>			<p>Now, in<a id="_idIndexMarker461"/> the <strong class="source-inline">main()</strong> function, we do <span class="No-Break">several</span><span class="No-Break"><a id="_idIndexMarker462"/></span><span class="No-Break"> things:</span></p>
			<ul>
				<li>We create an instance of the <strong class="source-inline">WeatherStation</strong> class, which acts as <span class="No-Break">the subject.</span></li>
				<li>We create instances of <strong class="source-inline">DisplayDevice</strong> and <strong class="source-inline">WeatherApp</strong>, representing different types <span class="No-Break">of observers.</span></li>
				<li>We register these observers with <strong class="source-inline">weather_station</strong> using the <span class="No-Break"><strong class="source-inline">add_observer</strong></span><span class="No-Break"> method.</span></li>
				<li>We simulate changes in weather data by calling the <strong class="source-inline">set_weather_data</strong> method of <strong class="source-inline">weather_station</strong>. This triggers updates to all <span class="No-Break">registered observers.</span></li>
			</ul>
			<p>The code of the <strong class="source-inline">main()</strong> function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    # Create the WeatherStation
    weather_station = WeatherStation()
    # Create and register observers
    display1 = DisplayDevice("Living Room")
    display2 = DisplayDevice("Bedroom")
    app1 = WeatherApp("Mobile App")
    weather_station.add_observer(display1)
    weather_station.add_observer(display2)
    weather_station.add_observer(app1)
    # Simulate weather data changes
    weather_station.set_weather_data(25.5, 60, 1013.2)
    weather_station.set_weather_data(26.0, 58, 1012.8)</pre>			<p>Let’s<a id="_idIndexMarker463"/> recapitulate the complete code (in the <strong class="source-inline">ch05/observer.py</strong> file) of <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker464"/></span><span class="No-Break">implementation:</span></p>
			<ol>
				<li>We define the <span class="No-Break">Observer interface.</span></li>
				<li>We define the <strong class="source-inline">WeatherStation</strong> <span class="No-Break">subject class.</span></li>
				<li>We define two observer classes, <strong class="source-inline">DisplayDevice</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">WeatherApp</strong></span><span class="No-Break">.</span></li>
				<li>We add a <strong class="source-inline">main()</strong> function where we test <span class="No-Break">our design.</span></li>
			</ol>
			<p>Executing the <strong class="source-inline">python ch05/observer.py</strong> command gives us the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Living Room Display</strong>
<strong class="bold">- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa</strong>
<strong class="bold">Bedroom Display</strong>
<strong class="bold">- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa</strong>
<strong class="bold">Mobile App App - Weather Update</strong>
<strong class="bold">- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa</strong>
<strong class="bold">Living Room Display</strong>
<strong class="bold">- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa</strong>
<strong class="bold">Bedroom Display</strong>
<strong class="bold">- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa</strong>
<strong class="bold">Mobile App App - Weather Update</strong>
<strong class="bold">- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa</strong></pre>			<p>As you can see, this example demonstrates the Observer pattern, where the subject notifies its observers about changes in its state. Observers are loosely coupled with the subject and can be added or removed dynamically, providing flexibility and decoupling in <span class="No-Break">the system.</span></p>
			<p>As an exercise, you can see that when unregistering an observer, using the <strong class="source-inline">remove_observer()</strong> method, and then simulating additional weather data changes, only the remaining registered observers receive updates. As a<a id="_idIndexMarker465"/> helper, to test this, here are 2 lines of<a id="_idIndexMarker466"/> code to add at the end of the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
    weather_station.remove_observer(display2)
    weather_station.set_weather_data(27.2, 55, 1012.5)</pre>			<p>Next, we will discuss the <span class="No-Break">State pattern.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor136"/>The State pattern</h1>
			<p>In the <a id="_idIndexMarker467"/>previous chapter, we covered the Observer pattern, which is<a id="_idIndexMarker468"/> useful in a program to notify other objects when the state of a given object changes. Let’s continue discovering those patterns proposed by the Gang <span class="No-Break">of Four.</span></p>
			<p>OOP focuses on maintaining the states of objects that interact with each other. A very handy tool to model state<a id="_idIndexMarker469"/> transitions when solving many problems is known as a <strong class="bold">finite-state machine</strong> (commonly called<a id="_idIndexMarker470"/> a <span class="No-Break"><strong class="bold">state machine</strong></span><span class="No-Break">).</span></p>
			<p>What’s a state machine? A state machine is an <a id="_idIndexMarker471"/>abstract machine that has two key components, that is, states and transitions. A state<a id="_idIndexMarker472"/> is the current (active) status of a system. For example, if we have a radio receiver, two possible states for it are to be tuned to FM or AM. Another possible state is for it to be switching from one FM/AM radio station to another. A transition<a id="_idIndexMarker473"/> is a switch from one state to another. A transition is initiated by a triggering event or condition. Usually, an action or set of actions is executed before or after a transition occurs. Assuming that our radio receiver is tuned to the 107 FM station, an example of a transition is for the button to be pressed by the listener to switch it to <span class="No-Break">107.5 FM.</span></p>
			<p>A nice feature of state machines is that<a id="_idIndexMarker474"/> they can be represented as graphs (called <strong class="bold">state diagrams</strong>), where each state is a node, and each transition is an edge between <span class="No-Break">two nodes.</span></p>
			<p>State machines can <a id="_idIndexMarker475"/>be used to solve many kinds of problems, both non-computational and computational. Non-computational examples include vending machines, elevators, traffic lights, combination locks, parking meters, and automated gas pumps. Computational examples include game programming and other categories of computer programming, hardware design, protocol design, and programming <span class="No-Break">language parsing.</span></p>
			<p>Now, we <a id="_idIndexMarker476"/>have an idea of what state machines are! But how are state machines related to the State design pattern? It turns out that the State pattern<a id="_idIndexMarker477"/> is nothing more than a state machine applied to a particular software engineering problem (<em class="italic">Gang of Four-95</em>, page 342), (<em class="italic">Python 3 Patterns, Recipes and Idioms by Bruce Eckel &amp; Friends</em>, <span class="No-Break">page 151).</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor137"/>Real-world examples</h2>
			<p>A snack vending machine is an <a id="_idIndexMarker478"/>example of the State pattern in everyday life. Vending machines have different states and react differently depending on the amount of money that we insert. Depending on our selection and the money we insert, the machine can do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Reject our selection because the product we requested is out <span class="No-Break">of stock.</span></li>
				<li>Reject our selection because the amount of money we inserted was <span class="No-Break">not sufficient.</span></li>
				<li>Deliver the product and give no change because we inserted the <span class="No-Break">exact amount.</span></li>
				<li>Deliver the product and return <span class="No-Break">the change.</span></li>
			</ul>
			<p>There are, for sure, more possible states, but you get <span class="No-Break">the point.</span></p>
			<p>Other examples of the state pattern in real life are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Traffic lights</span></li>
				<li>Game states in a <span class="No-Break">video game</span></li>
			</ul>
			<p>In software, the state pattern is commonly used. Python and its ecosystem offer several packages/modules one can use to implement state machines. We will see how to use one of them in the <span class="No-Break">implementation section.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor138"/>Use cases for the State pattern</h2>
			<p>The State pattern is applicable to <a id="_idIndexMarker479"/>many problems. All the problems that can be solved using state machines are good use cases for using the State pattern. An example we have already seen is the process model for an <span class="No-Break">operating/embedded system.</span></p>
			<p>Programming language compiler implementation is another good example. Lexical and syntactic analysis can use states to build abstract <span class="No-Break">syntax trees.</span></p>
			<p>Event-driven systems are yet another example. In an event-driven system, the transition from one state to another triggers an event/message. Many computer games use this technique. For example, a monster might move from the guard state to the attack state when the main hero <span class="No-Break">approaches it.</span></p>
			<p>To quote Thomas Jaeger, in his article, <em class="italic">The State Design Pattern vs. State </em><span class="No-Break"><em class="italic">Machine</em></span><span class="No-Break"> (</span><a href="https://thomasjaeger.wordpress.com/2012/12/13/the-state-design-pattern-vs-state-machine-2/"><span class="No-Break">https://thomasjaeger.wordpress.com/2012/12/13/the-state-design-pattern-vs-state-machine-2/</span></a><span class="No-Break">):</span></p>
			<p><em class="italic">The state design pattern allows for full encapsulation of an unlimited number of states on a context for easy maintenance </em><span class="No-Break"><em class="italic">and flexibility.</em></span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/>Implementing the State pattern</h2>
			<p>Let’s write<a id="_idIndexMarker480"/> code that demonstrates how to create a state <a id="_idIndexMarker481"/>machine based on the state diagram shown earlier in this chapter. Our state machine should cover the different states of a process and the transitions <span class="No-Break">between them.</span></p>
			<p>The State design pattern is usually implemented using a parent <strong class="source-inline">State</strong> class that contains the common functionality of all the states, and several concrete classes derived from <strong class="source-inline">State</strong>, where each derived class contains only the state-specific required functionality. The State pattern focuses on implementing a state machine. The core parts of a state machine are the states and transitions between the states. It doesn’t matter how those parts <span class="No-Break">are implemented.</span></p>
			<p>To avoid reinventing the wheel, we can make use of existing Python modules that not only help us create state machines but also do it in a Pythonic way. A module that I find very useful <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">state_machine</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">state_machine</strong> module is simple enough that no special introduction is required. We will cover most aspects of it while going through the code of <span class="No-Break">the example.</span></p>
			<p>Let’s start with the <strong class="source-inline">Process</strong> class. Each created process has its own state machine. The first step to creating a state machine using the <strong class="source-inline">state_machine</strong> module is to use the <strong class="source-inline">@acts_as_state_machine</strong> decorator. Then, we define the states of our state machine. This is a one-to-one mapping of what we see in the state diagram. The only difference is that we should give a hint about the initial state of the state machine. We do that by setting the initial attribute value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@acts_as_state_machine
class Process:
    created = State(initial=True)
    waiting = State()
    running = State()
    terminated = State()
    blocked = State()
    swapped_out_waiting = State()
    swapped_out_blocked = State()</pre>			<p>Next, we<a id="_idIndexMarker482"/> are going to define the transitions. In the <strong class="source-inline">state_machine</strong> module, a<a id="_idIndexMarker483"/> transition is an instance of the <strong class="source-inline">Event</strong> class. We define the possible transitions using the <strong class="source-inline">from_states</strong> and <span class="No-Break"><strong class="source-inline">to_state</strong></span><span class="No-Break"> arguments:</span></p>
			<pre class="source-code">
wait = Event(
    from_states=(
        created,
        running,
        blocked,
        swapped_out_waiting,
    ),
    to_state=waiting,
)
run = Event(
    from_states=waiting, to_state=running
)
terminate = Event(
    from_states=running, to_state=terminated
)
block = Event(
    from_states=(
        running,
        swapped_out_blocked,
    ),
    to_state=blocked,
)
swap_wait = Event(
    from_states=waiting,
    to_state=swapped_out_waiting,
)
swap_block = Event(
    from_states=blocked,
    to_state=swapped_out_blocked,
)</pre>			<p>Also, as you<a id="_idIndexMarker484"/> may have noticed that <strong class="source-inline">from_states</strong> can be either a single<a id="_idIndexMarker485"/> state or a group of <span class="No-Break">states (tuple).</span></p>
			<p>Each process has a name. Officially, a process needs to have much more information to be useful (for example, ID, priority, status, and so forth) but let’s keep it simple to focus on <span class="No-Break">the pattern:</span></p>
			<pre class="source-code">
def __init__(self, name):
    self.name = name</pre>			<p>Transitions are not very useful if nothing happens when they occur. The <strong class="source-inline">state_machine</strong> module provides us with the <strong class="source-inline">@before</strong> and <strong class="source-inline">@after</strong> decorators that can be used to execute actions before or after a transition occurs, respectively. You can imagine updating some objects within the system or sending an email or a notification to someone. For this example, the actions are limited to printing information about the state change of the<a id="_idIndexMarker486"/> process, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@after("wait")
def wait_info(self):
    print(f"{self.name} entered waiting mode")
@after("run")
def run_info(self):
    print(f"{self.name} is running")
@before("terminate")
def terminate_info(self):
    print(f"{self.name} terminated")
@after("block")
def block_info(self):
    print(f"{self.name} is blocked")
@after("swap_wait")
def swap_wait_info(self):
    print(
        f"{self.name} is swapped out and waiting"
    )
@after("swap_block")
def swap_block_info(self):
    print(
        f"{self.name} is swapped out and blocked"
    )</pre>			<p>Next, we need <a id="_idIndexMarker487"/>the <strong class="source-inline">transition()</strong> function, which accepts<a id="_idIndexMarker488"/> <span class="No-Break">three arguments:</span></p>
			<ul>
				<li><strong class="source-inline">process</strong>, which is an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Process</strong></span></li>
				<li><strong class="source-inline">event</strong>, which is an instance of <strong class="source-inline">Event</strong> (wait, run, terminate, and <span class="No-Break">so forth)</span></li>
				<li><strong class="source-inline">event_name</strong>, which is the name of <span class="No-Break">the event</span></li>
			</ul>
			<p>The name of the event is printed if something goes wrong when trying to execute <strong class="source-inline">event</strong>. Here is the code for <span class="No-Break">the function:</span></p>
			<pre class="source-code">
def transition(proc, event, event_name):
    try:
        event()
    except InvalidStateTransition:
        msg = (
            f"Transition of {proc.name} from {proc.current_state} "
            f"to {event_name} failed"
        )
        print(msg)</pre>			<p>The <strong class="source-inline">state_info()</strong> function shows some basic information about the current (active) state of <span class="No-Break">the process:</span></p>
			<pre class="source-code">
def state_info(proc):
    print(
        f"state of {proc.name}: {proc.current_state}"
    )</pre>			<p>At the <a id="_idIndexMarker489"/>beginning of the <strong class="source-inline">main()</strong> function, we define some <a id="_idIndexMarker490"/>string constants, which are passed <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">event_name</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
def main():
    RUNNING = "running"
    WAITING = "waiting"
    BLOCKED = "blocked"
    TERMINATED = "terminated"</pre>			<p>Next, we create two <strong class="source-inline">Process</strong> instances and display information about their <span class="No-Break">initial state:</span></p>
			<pre class="source-code">
p1, p2 = Process("process1"), Process(
    "process2"
)
[state_info(p) for p in (p1, p2)]</pre>			<p>The rest of the function<a id="_idIndexMarker491"/> experiments with different transitions. Recall the state diagram we covered in this chapter. The allowed transitions should be with respect to the state diagram. For example, it should be possible to switch from a running state to a blocked state, but it shouldn’t<a id="_idIndexMarker492"/> be possible to switch from a blocked state to a <span class="No-Break">running state:</span></p>
			<pre class="source-code">
print()
transition(p1, p1.wait, WAITING)
transition(p2, p2.terminate, TERMINATED)
[state_info(p) for p in (p1, p2)]
print()
transition(p1, p1.run, RUNNING)
transition(p2, p2.wait, WAITING)
[state_info(p) for p in (p1, p2)]
print()
transition(p2, p2.run, RUNNING)
[state_info(p) for p in (p1, p2)]
print()
[
    transition(p, p.block, BLOCKED)
    for p in (p1, p2)
]
[state_info(p) for p in (p1, p2)]
print()
[
    transition(p, p.terminate, TERMINATED)
    for p in (p1, p2)
]
[state_info(p) for p in (p1, p2)]</pre>			<p>Here is the<a id="_idIndexMarker493"/> recapitulation of the full implementation <a id="_idIndexMarker494"/>example (the <span class="No-Break"><strong class="source-inline">ch05/state.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We begin by importing what we need <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">state_machine</strong></span><span class="No-Break">.</span></li>
				<li>We define the <strong class="source-inline">Process</strong> class with its <span class="No-Break">simple attributes.</span></li>
				<li>We add the <strong class="source-inline">Process</strong> class’s <span class="No-Break">initialization method.</span></li>
				<li>We also need to define, in the <strong class="source-inline">Process</strong> class, the methods to provide <span class="No-Break">its states.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">transition()</strong></span><span class="No-Break"> function.</span></li>
				<li>Next, we define the <span class="No-Break"><strong class="source-inline">state_info()</strong></span><span class="No-Break"> function.</span></li>
				<li>Finally, we add the main function of <span class="No-Break">the program.</span></li>
			</ol>
			<p>Here’s what<a id="_idIndexMarker495"/> we get when executing the Python <span class="No-Break"><strong class="source-inline">ch05/state.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">state of process1: created</strong>
<strong class="bold">state of process2: created</strong>
<strong class="bold">process1 entered waiting mode</strong>
<strong class="bold">Transition of process2 from created to terminated failed</strong>
<strong class="bold">state of process1: waiting</strong>
<strong class="bold">state of process2: created</strong>
<strong class="bold">process1 is running</strong>
<strong class="bold">process2 entered waiting mode</strong>
<strong class="bold">state of process1: running</strong>
<strong class="bold">state of process2: waiting</strong>
<strong class="bold">process2 is running</strong>
<strong class="bold">state of process1: running</strong>
<strong class="bold">state of process2: running</strong>
<strong class="bold">process1 is blocked</strong>
<strong class="bold">process2 is blocked</strong>
<strong class="bold">state of process1: blocked</strong>
<strong class="bold">state of process2: blocked</strong>
<strong class="bold">Transition of process1 from blocked to terminated failed</strong>
<strong class="bold">Transition of process2 from blocked to terminated failed</strong>
<strong class="bold">state of process1: blocked</strong>
<strong class="bold">state of process2: blocked</strong></pre>			<p>Indeed, the <a id="_idIndexMarker496"/>output shows that illegal transitions such as created → terminated and blocked → terminated fail gracefully. We don’t want the application to <a id="_idIndexMarker497"/>crash when an illegal transition is requested, and this is handled properly by the <span class="No-Break">except block.</span></p>
			<p>Notice how using a good module such as <strong class="source-inline">state_machine</strong> eliminates conditional logic. There’s no need to use long and error-prone <strong class="source-inline">if…else</strong> statements that check for each and <a id="_idIndexMarker498"/>every state <a id="_idIndexMarker499"/>transition and react <span class="No-Break">to them.</span></p>
			<p>To get a better feeling for the state pattern and state machines, I strongly recommend you implement your own example. This can be anything: a simple video game (you can use state machines to handle the states of the main hero and the enemies), an elevator, a parser, or any other system that can be modeled using <span class="No-Break">state machines.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor140"/>The Interpreter pattern</h1>
			<p>Often, we <a id="_idIndexMarker500"/>need to create a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). A <a id="_idIndexMarker501"/>DSL is<a id="_idIndexMarker502"/> a computer language of limited expressiveness targeting a particular domain. DSLs are used for different things, such as combat simulation, billing, visualization, configuration, and communication protocols. DSLs are divided into internal DSLs and <span class="No-Break">external DSLs.</span></p>
			<p>Internal DSLs<a id="_idIndexMarker503"/> are built on top of a host programming language. An example of an internal DSL is a language that solves linear equations using Python. The advantages of using an internal DSL are that we don’t have to worry about creating, compiling, and parsing grammar because these are already taken care of by the host language. The disadvantage is that we are constrained by the features of the host language. It is very challenging to create an expressive, concise, and fluent internal DSL if the host language does not have <span class="No-Break">these features.</span></p>
			<p>External DSLs<a id="_idIndexMarker504"/> do not depend on host languages. The creator of the DSL can decide all aspects of the language (grammar, syntax, and so forth). They are also responsible for creating a parser and compiler <span class="No-Break">for it.</span></p>
			<p>The Interpreter pattern<a id="_idIndexMarker505"/> is related only to internal DSLs. Therefore, the goal is to create a simple but useful language using the features provided by the host programming language, which in this case is Python. Note that Interpreter does not address parsing at all. It assumes that we already have the parsed data in some convenient form. This can be an <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) or any <a id="_idIndexMarker506"/>other handy data structure [<em class="italic">Gang of Four-95</em>, <span class="No-Break">page 276].</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor141"/>Real-world examples</h2>
			<p>A <a id="_idIndexMarker507"/>musician is an example of the Interpreter pattern. Musical notation represents the pitch and duration of a sound graphically. The musician <a id="_idIndexMarker508"/>can reproduce a sound precisely based on its notation. In a sense, musical notation is the language of music, and the musician is the interpreter of <span class="No-Break">that language.</span></p>
			<p>We can also cite <span class="No-Break">software examples:</span></p>
			<ul>
				<li>In the C++ world, <strong class="source-inline">boost::spirit</strong> is considered an internal DSL for <span class="No-Break">implementing parsers.</span></li>
				<li>An example in Python is PyT, an<a id="_idIndexMarker509"/> internal DSL used to generate XHTML/HTML. PyT focuses on performance and claims to have comparable speed with Jinja2. Of course, we should not assume that the Interpreter pattern is necessarily used in PyT. However, since it is an internal DSL, the Interpreter is a very good candidate <span class="No-Break">for it.</span></li>
			</ul>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor142"/>Use cases for the Interpreter pattern</h2>
			<p>The Interpreter pattern is<a id="_idIndexMarker510"/> used when we want to offer a simple language to domain experts and advanced users to solve their problems. The first thing we should stress is that the Interpreter pattern should only be used to implement simple languages. If the language has the requirements of an external DSL, there are better tools to create languages from scratch (Yacc and Lex, Bison, ANTLR, and <span class="No-Break">so on).</span></p>
			<p>Our goal is to offer the right programming abstractions to the specialist, who is often not a programmer, to make them productive. Ideally, they shouldn’t know advanced Python to use our DSL, but knowing even a little bit of Python is a plus since that’s what we eventually get at the end. Advanced Python concepts should not be a requirement. Moreover, the performance of the DSL is usually not an important concern. The focus is on offering a language that hides the peculiarities of the host language and offers a more human-readable syntax. Admittedly, Python is already a very readable language with far less peculiar <a id="_idIndexMarker511"/>syntax than many other <span class="No-Break">programming languages.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor143"/>Implementing the Interpreter pattern</h2>
			<p>Let’s create an<a id="_idIndexMarker512"/> internal DSL to control a smart house. This <a id="_idIndexMarker513"/>example fits well into<a id="_idIndexMarker514"/> the <strong class="bold">internet of things</strong> (<strong class="bold">IoT</strong>) era, which is getting more and more attention nowadays. The user can control their home using a very simple event notation. An event has the form of command -&gt; receiver -&gt; arguments. The arguments part <span class="No-Break">is optional.</span></p>
			<p>Not all events require arguments. An example of an event that does not require any arguments is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
open -&gt; gate</pre>			<p>An example of an event that requires arguments is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
increase -&gt; boiler temperature -&gt; 3 degrees</pre>			<p>The <strong class="source-inline">-&gt;</strong> symbol is used to mark the end of one part of an event and state the beginning of the next one. There are many ways to implement an internal DSL. We can use plain old regular expressions, string processing, a combination of operator overloading, and metaprogramming, or a library/tool that can do the hard work for us. Although, officially, the Interpreter pattern does not address parsing, I feel that a practical example needs to cover parsing as well. For this reason, I decided to use a tool to take care of the parsing part. The tool is called pyparsing and, to find out more about it, check out the mini-book <em class="italic">Getting Started with Pyparsing</em> by Paul <span class="No-Break">McGuir</span><span class="No-Break">e (</span><a href="https://www.oreilly.com/library/view/getting-started-with/9780596514235/"><span class="No-Break">https://</span><span class="No-Break">www.oreilly.com/library/view/getting-started-with/9780596514235/</span></a><span class="No-Break">).</span></p>
			<p>Before getting into coding, it is a good practice to define a simple grammar for our language. We can define the grammar using <a id="_idIndexMarker515"/>the <strong class="bold">Backus-Naur Form</strong> (<span class="No-Break"><strong class="bold">BNF</strong></span><span class="No-Break">) notation:</span></p>
			<pre class="source-code">
event ::= command token receiver token arguments
 command ::= word+
 word ::= a collection of one or more alphanumeric characters
 token ::= -&gt;
 receiver ::= word+
 arguments ::= word+</pre>			<p>What the grammar basically tells us is that an event has the form of command -&gt; receiver -&gt; arguments, and that commands, receivers, and arguments have the same form: a group of one or more alphanumeric characters. If you are wondering about the necessity of the numeric part, it is included to allow us to pass arguments, such as three degrees at the increase -&gt; boiler temperature -&gt; 3 <span class="No-Break">degrees command.</span></p>
			<p>Now that we <a id="_idIndexMarker516"/>have defined the grammar, we can move on<a id="_idIndexMarker517"/> to converting it to actual code. Here’s what the code <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
word = Word(alphanums)
command = Group(OneOrMore(word))
token = Suppre"s("-&gt;")
device = Group(OneOrMore(word))
argument = Group(OneOrMore(word))
event = command + token + device + Optional(token + argument)</pre>			<p>The basic difference between the code and grammar definition is that the code needs to be written in the bottom-up approach. For instance, we cannot use a word without first assigning it a value. <strong class="source-inline">Suppress</strong> is used to state that we want the <strong class="source-inline">-&gt;</strong> symbol to be skipped from the <span class="No-Break">parsed results.</span></p>
			<p>The full code of the final implementation example (see the <strong class="source-inline">ch05/interpreter/interpreter.py</strong> file) uses many placeholder classes, but to keep you focused, I will first show a minimal version featuring only one class. Let’s look at the <strong class="source-inline">Boiler</strong> class. A boiler has a default temperature of 83° Celsius. There are also two methods to increase and decrease the <span class="No-Break">current temperature:</span></p>
			<pre class="source-code">
class Boiler:
    def __init__(self):
        self.temperature = 83  # in celsius
    def __str__(self):
        return f"boiler temperature: {self.temperature}"
    def increase_temperature(self, amount):
        print(f"increasing the boiler's temperature by {amount} degrees")
        self.temperature += amount
    def decrease_temperature(self, amount):
        print(f"decreasing the boiler's temperature by {amount} degrees")
        self.temperature -= amount</pre>			<p>The next step is to<a id="_idIndexMarker518"/> add the grammar, which we already covered. We<a id="_idIndexMarker519"/> will also create a <strong class="source-inline">boiler</strong> instance and print its <span class="No-Break">default state:</span></p>
			<pre class="source-code">
word = Word(alphanums)
command = Group(OneOrMore(word))
token = Suppress("-&gt;")
device = Group(OneOrMore(word))
argument = Group(OneOrMore(word))
event = command + token + device + Optional(token + argument)
boiler = Boiler()</pre>			<p>The simplest way to retrieve the parsed output of pyparsing is by using the <strong class="source-inline">parseString()</strong> method. The result is a <strong class="source-inline">ParseResults</strong> instance, which is a parse tree that can be treated as a nested list. For example, executing <strong class="source-inline">print(event.parseStri'g('increase -&gt; boiler temperature -&gt; 3 degr'es'))</strong> would give‘<strong class="source-inline">[['incre'se']' ['boi'er', 'temperat're']' ''3', 'degr'es']]</strong> as <span class="No-Break">a result.</span></p>
			<p>So, in this case, we <a id="_idIndexMarker520"/>know that the first sublist is the <em class="italic">command</em> (increase), the second sublist is the <em class="italic">receiver</em> (boiler temperature), and the third sublist is the <em class="italic">argument</em> (3°). We can unpack the <strong class="source-inline">ParseResults</strong> instance, which <a id="_idIndexMarker521"/>gives us direct access to these three parts of the event. Having direct access means that we can match patterns to find out which method should <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
test = "increase -&gt; boiler temperature -&gt; 3 degrees"
cmd, dev, arg = event.parseString(test)
cmd_str = " ".join(cmd)
dev_str = " ".join(dev)
if "increase" in cmd_str and "boiler" in dev_str:
    boiler.increase_temperature(int(arg[0]))
print(boiler)</pre>			<p>Executing the preceding code snippet (using <strong class="source-inline">python ch05/interpreter/boiler.py</strong>) gives the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">increasing the boiler's temperature by 3 degrees</strong>
<strong class="bold">boiler temperature: 86</strong></pre>			<p>The full code for our implementation (in the <strong class="source-inline">ch05/interpreter/interpreter.py</strong> file) is not very different from what I just described. It is just extended to support more events and devices. Let’s summarize the <span class="No-Break">steps here:</span></p>
			<ol>
				<li>First, we import all we need <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">pyparsing</strong></span><span class="No-Break">.</span></li>
				<li>We define the following classes: <strong class="source-inline">Gate</strong>, <strong class="source-inline">Aircondition</strong>, <strong class="source-inline">Heating</strong>, <strong class="source-inline">Boiler</strong> (already presented), <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Fridge</strong></span><span class="No-Break">.</span></li>
				<li>Next, we have our <span class="No-Break">main function:</span><ol><li class="Alphabets">We prepare the parameters for the tests we will be performing, using the following variables: <strong class="source-inline">tests</strong>, <strong class="source-inline">open_actions</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">close_actions</strong></span><span class="No-Break">.</span></li><li class="Alphabets">We execute the <span class="No-Break">test actions.</span></li></ol></li>
			</ol>
			<p>Executing the <strong class="source-inline">python ch05/interpreter/interpreter.py</strong> command gives the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">opening the gate</strong>
<strong class="bold">closing the garage</strong>
<strong class="bold">turning on the air condition</strong>
<strong class="bold">turning off the heating</strong>
<strong class="bold">increasing the boiler's temperature by 5 degrees</strong>
<strong class="bold">decreasing the fridge's temperature by 2 degrees</strong></pre>			<p>If you want to<a id="_idIndexMarker522"/> experiment more with this example, I have <a id="_idIndexMarker523"/>a few suggestions for you. The first change that will make it much more interesting is to make it interactive. Currently, all the events are hardcoded in the <strong class="source-inline">tests</strong> tuple. However, the user wants to be able to activate events using an interactive prompt. Do not forget to check how sensitive <strong class="source-inline">pyparsing</strong> is regarding spaces, tabs, or unexpected input. For example, what happens if the user types <strong class="source-inline">turn off -&gt; </strong><span class="No-Break"><strong class="source-inline">heating 37</strong></span><span class="No-Break">?</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>The Strategy pattern</h1>
			<p>Several<a id="_idIndexMarker524"/> solutions often exist for the same problem. Consider the <a id="_idIndexMarker525"/>task of sorting, which involves arranging the elements of a list in a particular sequence. For example, a variety of sorting algorithms are available for the task of sorting. Generally, no single algorithm outperforms all others in <span class="No-Break">every situation.</span></p>
			<p>Selecting a sorting algorithm depends on various factors, tailored to the specifics of each case. Some key considerations include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">The number of elements to be sorted, known as the input size</strong>: While most sorting<a id="_idIndexMarker526"/> algorithms perform adequately with a small input size, only a select few maintain efficiency with <span class="No-Break">larger datasets.</span></li>
				<li><strong class="bold">The best/average/worst time complexity of the algorithm</strong>: Time complexity is (roughly) the amount of time the algorithm takes to complete, excluding coefficients and lower-order terms. This is often the most usual criterion to pick an algorithm, although it is not <span class="No-Break">always sufficient.</span></li>
				<li><strong class="bold">The space complexity of the algorithm</strong>: Space complexity is (again roughly) the amount of physical memory needed to fully execute an algorithm. This is very important when we are working with big data or embedded systems, which usually have <span class="No-Break">limited memory.</span></li>
				<li><strong class="bold">Stability of the algorithm</strong>: An algorithm is considered stable when it maintains the relative order of elements with equal values after it <span class="No-Break">is executed.</span></li>
				<li><strong class="bold">Code complexity of the algorithm</strong>: If two algorithms have the same time/space complexity <a id="_idIndexMarker527"/>and are both stable, it is important to know which algorithm is easier to code <span class="No-Break">and maintain.</span></li>
			</ul>
			<p>Other factors <a id="_idIndexMarker528"/>might also influence the choice of a sorting algorithm. The key consideration is whether a single algorithm must be applied universally. The answer is, unsurprisingly, no. It is more practical to have access to various sorting algorithms and choose the most suitable one for a given situation, based on the criteria. That’s what the Strategy pattern <span class="No-Break">is about.</span></p>
			<p>The Strategy pattern <a id="_idIndexMarker529"/>promotes using multiple algorithms to solve a problem. Its killer feature is that it makes it possible to switch algorithms at runtime transparently (the client code is unaware of the change). So, if you have two algorithms and you know that one works better with small input sizes, while the other works better with large input sizes, you can use Strategy to decide which algorithm to use based on the input data <span class="No-Break">at runtime.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Real-world examples</h2>
			<p>Reaching an<a id="_idIndexMarker530"/> airport to catch a flight is a good <a id="_idIndexMarker531"/>real-life <span class="No-Break">Strategy example:</span></p>
			<ul>
				<li>If we want to save money and we leave early, we can go <span class="No-Break">by bus/train</span></li>
				<li>If we don’t mind paying for a parking place and have our own car, we can go <span class="No-Break">by car</span></li>
				<li>If we don’t have a car but we are in a hurry, we can take <span class="No-Break">a taxi</span></li>
			</ul>
			<p>There are trade-offs between cost, time, convenience, and <span class="No-Break">so forth.</span></p>
			<p>In software, Python’s <strong class="source-inline">sorted()</strong> and <strong class="source-inline">list.sort()</strong> functions are examples of the Strategy pattern. Both functions accept a named parameter key, which is basically the name of the <a id="_idIndexMarker532"/>function that implements a sorting strategy (<em class="italic">Python 3 Patterns, Recipes, and Idioms, by Bruce Eckel &amp; Friends</em>, <span class="No-Break">page 202).</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Use cases for the Strategy pattern</h2>
			<p>Strategy is a very generic <a id="_idIndexMarker533"/>design pattern with many use cases. In general, whenever we want to be able to apply different algorithms dynamically and transparently, Strategy is the way to go. By different algorithms, I mean different implementations of the same algorithm. This means that the result should be the same, but each implementation has a different performance and code complexity (as an example, think of sequential search versus <span class="No-Break">binary search).</span></p>
			<p>Apart from its usage for sorting algorithms as we mentioned, the Strategy pattern is used to create different formatting representations, either to achieve portability (for example, line-breaking differences between platforms) or dynamically change the representation <span class="No-Break">of data.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Implementing the Strategy pattern</h2>
			<p>There is not much to be said about implementing<a id="_idIndexMarker534"/> the Strategy pattern. In languages where functions are not first-class citizens, each Strategy should be implemented in a different class. In Python, functions are objects (we can use variables to reference and manipulate them) and this simplifies the implementation <span class="No-Break">of Strategy.</span></p>
			<p>Assume<a id="_idIndexMarker535"/> that we are asked to implement an algorithm to check whether all characters in a string are unique. For example, the algorithm should return true if we enter the dream string because none of the characters are repeated. If we enter the pizza string, it should return false because the letter “z” exists two times. Note that the repeated characters do not need to be consecutive, and the string does not need to be a valid word. The algorithm should also return false for the 1r2a3ae string because the letter “a” <span class="No-Break">appear<a id="_idTextAnchor148"/>s twice.</span></p>
			<p>After thinking about the problem carefully, we come up with an implementation that sorts the string and compares all characters pair by pair. First, we implement the <strong class="source-inline">pairs()</strong> function, which returns all neighbors pairs of a <span class="No-Break">sequence, </span><span class="No-Break"><strong class="source-inline">seq</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
def pairs(seq):
    n = len(seq)
    for i in range(n):
        yield seq[i], seq[(i + 1) % n]</pre>			<p>Next, we implement the <strong class="source-inline">allUniqueSort()</strong> function, which accepts a string, <strong class="source-inline">s</strong>, and returns <strong class="source-inline">True</strong> if all characters in the string are unique; otherwise, it returns <strong class="source-inline">False</strong>. To demonstrate the Strategy pattern, we will simplify by assuming that this algorithm fails to scale. We assume<a id="_idIndexMarker536"/> that it works fine for strings that are up to five<a id="_idIndexMarker537"/> characters. For longer strings, we simulate a slowdown by inserting a <span class="No-Break">sleep statement:</span></p>
			<pre class="source-code">
SLOW = 3  # in seconds
LIMIT = 5  # in characters
WARNING"= "too bad, you picked the slow algorithm":("
def allUniqueSort(s):
    if len(s) &gt; LIMIT:
        print(WARNING)
        time.sleep(SLOW)
    srtStr = sorted(s)
    for c1, c2 in pairs(srtStr):
        if c1 == c2:
            return False
    return True</pre>			<p>We are not <a id="_idIndexMarker538"/>happy with the performance of <strong class="source-inline">allUniqueSort()</strong>, and we are trying to think of ways to improve it. After some time, we come up with a new algorithm, <strong class="source-inline">allUniqueSet()</strong>, that eliminates the need to sort. In this case, we use a set. If the character in check has already been inserted in the set, it <a id="_idIndexMarker539"/>means that not all characters in the string <span class="No-Break">are unique:</span></p>
			<pre class="source-code">
def allUniqueSet(s):
    if len(s) &lt; LIMIT:
        print(WARNING)
        time.sleep(SLOW)
    return True if len(set(s)) == len(s) else False</pre>			<p>Unfortunately, while <strong class="source-inline">allUniqueSet()</strong> has no scaling problems, for some strange reason, it performs worse than <strong class="source-inline">allUniqueSort()</strong> when checking short strings. What can we do in this case? Well, we can keep both algorithms and use the one that fits best, depending on the length of the string that we want <span class="No-Break">to check.</span></p>
			<p>The <strong class="source-inline">allUnique()</strong> function accepts an input string, <strong class="source-inline">s</strong>, and a strategy function, <strong class="source-inline">strategy</strong>, which, in this case, is one of <strong class="source-inline">allUniqueSort()</strong> and <strong class="source-inline">allUniqueSet()</strong>. The <strong class="source-inline">allUnique()</strong> function executes the input strategy and returns its result to <span class="No-Break">the caller.</span></p>
			<p>Then, the <strong class="source-inline">main()</strong> function lets the user perform the <span class="No-Break">following actions:</span></p>
			<ul>
				<li>Enter the word to be checked for <span class="No-Break">character uniqueness</span></li>
				<li>Choose the pattern that will <span class="No-Break">be used</span></li>
			</ul>
			<p>It also does some basic error handling and gives the ability to the user to <span class="No-Break">quit gracefully:</span></p>
			<pre class="source-code">
def main():
    WORD_IN_DESC = "Insert word (type quit to exit)&gt; "
    STRAT_IN_DESC = "Choose strategy: [1] Use a set, [2] Sort and pair&gt; "
    while True:
        word = None
        while not word:
            word = input(WORD_IN_DESC)
            if word == "quit":
                print("bye")
                return
            strategy_picked = None
            strategies = {"1": allUniqueSet, "2": allUniqueSort}
            while strategy_picked not in strategies.keys():
                strategy_picked = input(STRAT_IN_DESC)
                try:
                    strategy = strategies[strategy_picked]
                    result = allUnique(word, strategy)
                    print(f"allUnique({word}): {result}")
                except KeyError:
                    print(f"Incorrect option: {strategy_picked}")</pre>			<p>Here’s a <a id="_idIndexMarker540"/>summary of the complete code for our <a id="_idIndexMarker541"/>implementation example (the <span class="No-Break"><strong class="source-inline">ch05/strategy.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We import the <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> module.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">pairs()</strong></span><span class="No-Break"> function.</span></li>
				<li>We define the values for the <strong class="source-inline">SLOW</strong>, <strong class="source-inline">LIMIT</strong>, and <span class="No-Break"><strong class="source-inline">WARNING</strong></span><span class="No-Break"> constants.</span></li>
				<li>We define the function for the first <span class="No-Break">algorithm, </span><span class="No-Break"><strong class="source-inline">allUniqueSort()</strong></span><span class="No-Break">.</span></li>
				<li>We define the function for the second <span class="No-Break">algorithm, </span><span class="No-Break"><strong class="source-inline">allUniqueSet()</strong></span><span class="No-Break">.</span></li>
				<li>Next, we define the <strong class="source-inline">allUnique()</strong> function that helps call a chosen algorithm by passing the corresponding <span class="No-Break">strategy function.</span></li>
				<li>Finally, we add the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></li>
			</ol>
			<p>Let’s see the <a id="_idIndexMarker542"/>output of <a id="_idIndexMarker543"/>a sample execution using the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch05/strategy.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">Insert word (type quit to exit)&gt; balloon</strong>
<strong class="bold">Choose strategy: [1] Use a set, [2] Sort and pair&gt; 1</strong>
<strong class="bold">allUnique(balloon): False</strong>
<strong class="bold">Insert word (type quit to exit)&gt; balloon</strong>
<strong class="bold">Choose strategy: [1] Use a set, [2] Sort and pair&gt; 2</strong>
<strong class="bold">too bad, you picked the slow algorithm :(</strong>
<strong class="bold">allUnique(balloon): False</strong>
<strong class="bold">Insert word (type quit to exit)&gt; bye</strong>
<strong class="bold">Choose strategy: [1] Use a set, [2] Sort and pair&gt; 1</strong>
<strong class="bold">too bad, you picked the slow algorithm :(</strong>
<strong class="bold">allUnique(bye): True</strong>
<strong class="bold">Insert word (type quit to exit)&gt; bye</strong>
<strong class="bold">Choose strategy: [1] Use a set, [2] Sort and pair&gt; 2</strong>
<strong class="bold">allUnique(bye): True</strong>
<strong class="bold">Insert word (type quit to exit)&gt;</strong></pre>			<p>The first word, <strong class="source-inline">balloon</strong>, has more than five characters and not all of them are unique. In this case, both algorithms return the correct result, <strong class="source-inline">False</strong>, but <strong class="source-inline">allUniqueSort()</strong> is slower and the user <span class="No-Break">is warned.</span></p>
			<p>The second word, <strong class="source-inline">bye</strong>, has less than five characters and all characters are unique. Again, both algorithms return the expected result, <strong class="source-inline">True</strong>, but this time, <strong class="source-inline">allUniqueSet()</strong> is slower and the user is warned <span class="No-Break">once more.</span></p>
			<p>Normally, the strategy that we want to use should not be picked by the user. The point of the strategy pattern is that it makes it possible to use different algorithms transparently. Change the code so that the faster algorithm is <span class="No-Break">always picked.</span></p>
			<p>There are two<a id="_idIndexMarker544"/> usual users of our code. One is the end user, who<a id="_idIndexMarker545"/> should be unaware of what’s happening in the code, and to achieve that we can follow the tips given in the previous paragraph. Another possible category of users is the other developers. Assume that we want to create an API that will be used by the other developers. How can we keep them unaware of the Strategy pattern? A tip is to think of encapsulating the two functions in a common class, for example, <strong class="source-inline">AllUnique</strong>. In this case, the other developers will just need to create an instance of that class and execute a single method, for instance, <strong class="source-inline">test()</strong>. What needs to be done in <span class="No-Break">this method?</span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/>The Memento pattern</h1>
			<p>In many situations, we<a id="_idIndexMarker546"/> need a way to easily take a snapshot of the<a id="_idIndexMarker547"/> internal state of an object, so that we can restore the object with it when needed. Memento is a design pattern that can help us implement a solution for <span class="No-Break">such situations.</span></p>
			<p>The Memento design pattern has three <span class="No-Break">key components:</span></p>
			<ul>
				<li><strong class="bold">Memento</strong>: A<a id="_idIndexMarker548"/> simple object that contains basic state storage and <span class="No-Break">retrieval capabilities</span></li>
				<li><strong class="bold">Originator</strong>: An object<a id="_idIndexMarker549"/> that gets and sets values of <span class="No-Break">Memento instances</span></li>
				<li><strong class="bold">Caretaker</strong>: An object <a id="_idIndexMarker550"/>that can store and retrieve all previously created <span class="No-Break">Memento instances</span></li>
			</ul>
			<p>Memento shares many similarities with the <span class="No-Break">Command pattern.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor150"/>Real-world examples</h2>
			<p>The <a id="_idIndexMarker551"/>Memento pattern can be seen in many situations in<a id="_idIndexMarker552"/> <span class="No-Break">real life.</span></p>
			<p>An example could be found in the dictionary we use for a language, such as English or French. The dictionary is regularly updated through the work of academic experts, with new words being added and other words becoming obsolete. Spoken and written languages evolve, and the official dictionary has to reflect that. From time to time, we revisit a previous edition to get an understanding of how the language was used at some point in the past. This could also be needed simply because information can be lost after a long period of time, and to find it, you may need to look into old editions. This can be useful for understanding something in a particular field. Someone doing research could use an old dictionary or go to the archives to find information about some words <span class="No-Break">and expressions.</span></p>
			<p>This example can be extended to other written material, such as books <span class="No-Break">and newspapers.</span></p>
			<p><strong class="bold">Zope</strong> (<a href="http://www.zope.org">http://www.zope.org</a>), with its <a id="_idIndexMarker553"/>integrated object database called <strong class="bold">Zope Object Database</strong> (<strong class="bold">ZODB</strong>), offers<a id="_idIndexMarker554"/> a good software example of the Memento pattern. It is famous for its <strong class="bold">Through-The-Web</strong> object management interface, with<a id="_idIndexMarker555"/> undo support, for website administrators. ZODB is an object database for Python and is in heavy use in the Pyramid and Plone stacks <span class="No-Break">among others.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor151"/>Use cases for the Memento pattern</h2>
			<p>Memento is usually used<a id="_idIndexMarker556"/> when you need to provide some sort of undo and redo capability for <span class="No-Break">your users.</span></p>
			<p>Another usage is the implementation of a UI dialog with OK/Cancel buttons, where we would store the state of the object on load, and if the user chooses to cancel, we would restore the initial state of <span class="No-Break">the object.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor152"/>Implementing the Memento pattern</h2>
			<p>We will <a id="_idIndexMarker557"/>approach the implementation of Memento, in a<a id="_idIndexMarker558"/> simplified way, and by doing things in a natural way for the Python language. This means we do not necessarily need <span class="No-Break">several classes.</span></p>
			<p>One thing we will use is Python’s <strong class="source-inline">pickle</strong> module. What is <strong class="source-inline">pickle</strong> used for? According to the module’s<a id="_idIndexMarker559"/> documentation (<a href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a>), the <strong class="source-inline">pickle</strong> module can transform a complex object into a byte stream, and it can transform the byte stream into an object with the same <span class="No-Break">internal structure.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">The <strong class="source-inline">pickle</strong> module is used here for the sake of our demonstration, but you should know that it is not secure for <span class="No-Break">generic usage.</span></p>
			<p>Let’s take a <strong class="source-inline">Quote</strong> class, with the <strong class="source-inline">text</strong> and <strong class="source-inline">author</strong> attributes. To create memento, we will use a method on that class, <strong class="source-inline">save_state()</strong>, which as the name suggests will dump the state of the object, using the <strong class="source-inline">pickle.dumps()</strong> function. This <span class="No-Break">creates memento:</span></p>
			<pre class="source-code">
class Quote:
    def __init__(self, text, author):
        self.text = text
        self.author = author
    def save_state(self):
        current_state = pickle.dumps(self.__dict__)
        return current_state</pre>			<p>That state can be restored later. For that, we add the <strong class="source-inline">restore_state()</strong> method, making use of the <span class="No-Break"><strong class="source-inline">pickle.loads()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
    def restore_state(self, memento):
        previous_state = pickle.loads(memento)
        self.__dict__.clear()
        self.__dict__.update(previous_state)</pre>			<p>Let’s also add the <span class="No-Break"><strong class="source-inline">__str__</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    def __str__(self):
        return f"{self.text}\n- By {self.author}."</pre>			<p>Then, in the<a id="_idIndexMarker560"/> main function, we can take care of things <a id="_idIndexMarker561"/>and test our implementation, <span class="No-Break">as usual:</span></p>
			<pre class="source-code">
def main():
    print("** Quote 1 **")
    q1 = Quote(
        "A room without books is like a body without a soul.",
        "Unknown author",
    )
    print(f"\nOriginal version:\n{q1}")
    q1_mem = q1.save_state()
    # Now, we found the author's name
    q1.author = "Marcus Tullius Cicero"
    print(f"\nWe found the author, and did an updated:\n{q1}")
    # Restoring previous state (Undo)
    q1.restore_state(q1_mem)
    print(f"\nWe had to restore the previous version:\n{q1}")
    print()
    print("** Quote 2 **")
    text = (
        "To be you in a world that is constantly \n"
        "trying to make you be something else is \n"
        "the greatest accomplishment."
    )
    q2 = Quote(
        text,
        "Ralph Waldo Emerson",
    )
    print(f"\nOriginal version:\n{q2}")
    _ = q2.save_state()
    # changes to the text
    q2.text = (
        "To be yourself in a world that is constantly \n"
        "trying to make you something else is the greatest \n"
        "accomplishment."
    )
    print(f"\nWe fixed the text:\n{q2}")
    q2_mem2 = q2.save_state()
    q2.text = (
        "To be yourself when the world is constantly \n"
        "trying to make you something else is the greatest \n"
        "accomplishment."
    )
    print(f"\nWe fixed the text again:\n{q2}")
    # Restoring previous state (Undo)
    q2.restore_state(q2_mem2)
    print(f"\nWe restored the 2nd version, the correct one:\n{q2}")</pre>			<p>Here’s the <a id="_idIndexMarker562"/>recapitulation of the steps in the<a id="_idIndexMarker563"/> example (the <span class="No-Break"><strong class="source-inline">ch05/memento.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We import the <span class="No-Break"><strong class="source-inline">pickle</strong></span><span class="No-Break"> module.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">Quote</strong></span><span class="No-Break"> class.</span></li>
				<li>Finally, we add the main function where we test <span class="No-Break">the implementation.</span></li>
			</ol>
			<p>Let’s view a sample execution using the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch05/memento.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">** Quote 1 **</strong>
<strong class="bold">Original version:</strong>
<strong class="bold">A room without books is like a body without a soul.</strong>
<strong class="bold">- By Unknown author.</strong>
<strong class="bold">We found the author, and did an updated:</strong>
<strong class="bold">A room without books is like a body without a soul.</strong>
<strong class="bold">- By Marcus Tullius Cicero.</strong>
<strong class="bold">We had to restore the previous version:</strong>
<strong class="bold">A room without books is like a body without a soul.</strong>
<strong class="bold">- By Unknown author.</strong>
<strong class="bold">** Quote 2 **</strong>
<strong class="bold">Original version:</strong>
<strong class="bold">To be you in a world that is constantly</strong>
<strong class="bold">trying to make you be something else is</strong>
<strong class="bold">the greatest accomplishment.</strong>
<strong class="bold">- By Ralph Waldo Emerson.</strong>
<strong class="bold">We fixed the text:</strong>
<strong class="bold">To be yourself in a world that is constantly</strong>
<strong class="bold">trying to make you something else is the greatest</strong>
<strong class="bold">accomplishment.</strong>
<strong class="bold">- By Ralph Waldo Emerson.</strong>
<strong class="bold">We fixed the text again:</strong>
<strong class="bold">To be yourself when the world is constantly</strong>
<strong class="bold">trying to make you something else is the greatest</strong>
<strong class="bold">accomplishment.</strong>
<strong class="bold">- By Ralph Waldo Emerson.</strong>
<strong class="bold">We restored the 2nd version, the correct one:</strong>
<strong class="bold">To be yourself in a world that is constantly</strong>
<strong class="bold">trying to make you something else is the greatest</strong>
<strong class="bold">accomplishment.</strong>
<strong class="bold">- By Ralph Waldo Emerson.</strong>
<strong class="bold">The output shows the program does what we expected: we can restore a previous state for each of our Quote objects.</strong></pre>			<h1 id="_idParaDest-147"><a id="_idTextAnchor153"/>The Iterator pattern</h1>
			<p>In <a id="_idIndexMarker564"/>programming, we use sequences or collections of objects a lot, particularly<a id="_idIndexMarker565"/> in algorithms and when writing programs that manipulate data. One can think of automation scripts, APIs, data-driven apps, and other domains. In this chapter, we are going to see a pattern that is useful whenever we must handle collections of objects: the <span class="No-Break">Iterator pattern.</span></p>
			<p class="callout-heading">Note, according to the definition given by Wikipedia</p>
			<p class="callout"><em class="italic">Iterator is a design pattern in which an iterator is used to traverse a container and access the container’s elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot </em><span class="No-Break"><em class="italic">be decoupled.</em></span></p>
			<p>The <a id="_idIndexMarker566"/>Iterator pattern is extensively used in the Python context. As we will see, this translates into Iterator being a language feature. It is so useful that the language developers decided to make it <span class="No-Break">a feature.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor154"/>Use cases for the Iterator pattern</h2>
			<p>It is a good idea to use the <a id="_idIndexMarker567"/>Iterator pattern whenever you want one or several of the <span class="No-Break">following behaviors:</span></p>
			<ul>
				<li>Make it easy to navigate through <span class="No-Break">a collection</span></li>
				<li>Get the next object in the collection at <span class="No-Break">any point</span></li>
				<li>Stop when you are done traversing through <span class="No-Break">the collection</span></li>
			</ul>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor155"/>Implementing the Iterator pattern</h2>
			<p>Iterator is<a id="_idIndexMarker568"/> implemented in Python for us, within for loops, list <a id="_idIndexMarker569"/>comprehensions, and so on. Iterator in Python is simply an object that can be iterated upon; an object that will return data, one element at <span class="No-Break">a time.</span></p>
			<p>We can do our own implementation for special cases, using the Iterator protocol, meaning that our iterator object must implement two special methods: <strong class="source-inline">__iter__()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">__next__()</strong></span><span class="No-Break">.</span></p>
			<p>An object is called iterable if we can get an iterator from it. Most of the built-in containers in Python (list, tuple, set, string, and so on) are iterable. The <strong class="source-inline">iter()</strong> function (which in turn calls the <strong class="source-inline">__iter__()</strong> method) returns an iterator <span class="No-Break">from them.</span></p>
			<p>Let’s consider a football team we want to implement with the help of the <strong class="source-inline">FootballTeam</strong> class. If we want to make an iterator out of it, we have to implement the Iterator protocol, since it is not a built-in container type such as the list type. Basically, built-in <strong class="source-inline">iter()</strong> and <strong class="source-inline">next()</strong> functions would not work on it unless they are added to <span class="No-Break">the implementation.</span></p>
			<p>First, we define the class of the iterator, <strong class="source-inline">FootballTeamIterator</strong>, that will be used to iterate through the football team object. The <strong class="source-inline">members</strong> attribute allows us to initialize the iterator object with our container object (which will be a <strong class="source-inline">FootballTeam</strong> instance). We add a <strong class="source-inline">__iter__()</strong> method to it, which would return the object itself, and a <strong class="source-inline">__next__()</strong> method to return the next person from the team at each call until we reach the last person. These will allow looping over the members of the football team via the iterator. The whole code for the <strong class="source-inline">FootballTeamIterator</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class FootballTeamIterator:
    def __init__(self, members):
        self.members = members
        self.index = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index &lt; len(self.members):
            val = self.members[self.index]
            self.index += 1
            return val
        else:
            raise StopIteration()</pre>			<p>So, now for <a id="_idIndexMarker570"/>the <strong class="source-inline">FootballTeam</strong> class itself; the <a id="_idIndexMarker571"/>next thing  to do is add a <strong class="source-inline">__iter__()</strong> method to it, which will initialize the iterator object that it needs (thus using <strong class="source-inline">FootballTeamIterator(self.members)</strong>) and <span class="No-Break">return it:</span></p>
			<pre class="source-code">
class FootballTeam:
    def __init__(self, members):
        self.members = members
    def __iter__(self):
        return FootballTeamIterator(self.members)</pre>			<p>We add a small main function to test our implementation. Once we have a <strong class="source-inline">FootballTeam</strong> instance, we call the <strong class="source-inline">iter()</strong> function on it to create the iterator, and we loop through it using a <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span></p>
			<pre class="source-code">
def main():
    members = [f"player{str(x)}" for x in range(1, 23)]
    members = members + ["coach1", "coach2", "coach3"]
    team = FootballTeam(members)
    team_it = iter(team)
    try:
        while True:
            print(next(team_it))
    except StopIteration:
        print("(End)")</pre>			<p>Here is<a id="_idIndexMarker572"/> a recap<a id="_idIndexMarker573"/> of the steps in our example (the <span class="No-Break"><strong class="source-inline">ch05/iterator.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We define the class for <span class="No-Break">the iterator.</span></li>
				<li>We define the <span class="No-Break">container class.</span></li>
				<li>We define our main function followed by the snippet to <span class="No-Break">call it.</span></li>
			</ol>
			<p>Here is the output we get when executing the <strong class="source-inline">python </strong><span class="No-Break"><strong class="source-inline">ch05/iterator.py</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
<strong class="bold">player1</strong>
<strong class="bold">player2</strong>
<strong class="bold">player3</strong>
<strong class="bold">player4</strong>
<strong class="bold">player5</strong>
<strong class="bold">...</strong>
<strong class="bold">player22</strong>
<strong class="bold">coach1</strong>
<strong class="bold">coach2</strong>
<strong class="bold">coach3</strong>
<strong class="bold">(End)</strong></pre>			<p>We got the <a id="_idIndexMarker574"/>expected output. Also, we can see that <a id="_idIndexMarker575"/>an exception was raised when we reached the end of the iteration, but it was caught, printing the <strong class="source-inline">(End)</strong> <span class="No-Break">string instead.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor156"/>The Template pattern</h1>
			<p>A key<a id="_idIndexMarker576"/> ingredient in writing good code is avoiding redundancy. In<a id="_idIndexMarker577"/> OOP, methods and functions are important tools that we can use to avoid writing <span class="No-Break">redundant code.</span></p>
			<p>Remember the <strong class="source-inline">sorted()</strong> example we saw when discussing the Strategy pattern. That function is generic enough that it can be used to sort more than one data structure (lists, tuples, and named tuples) using arbitrary keys. That’s the definition of a <span class="No-Break">good function.</span></p>
			<p>Functions such as <strong class="source-inline">sorted()</strong> demonstrate the ideal case. However, we cannot always write 100% <span class="No-Break">generic code.</span></p>
			<p>In the process of writing code that handles algorithms in the real world, we often end up writing redundant code. That’s the problem solved by the Template design pattern. This pattern focuses on eliminating code redundancy. The idea is that we should be able to redefine certain parts of an algorithm without changing <span class="No-Break">its structure.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor157"/>Real-world examples</h2>
			<p>The daily routine of a<a id="_idIndexMarker578"/> worker, especially for workers of the same company, is very close to the Template design pattern. All workers follow the same routine, but specific parts of the routine are <span class="No-Break">very different.</span></p>
			<p>In software, Python uses the Template pattern in the <strong class="source-inline">cmd</strong> module, which is used to build line-oriented command interpreters. Specifically, <strong class="source-inline">cmd.Cmd.cmdloop()</strong> implements an algorithm that reads input commands continuously and dispatches them to action methods. What is done before the loop, after the loop, and at the command parsing part is always the same. This is also called the <strong class="bold">invariant</strong> part of an algorithm. The elements that <a id="_idIndexMarker579"/>change are the actual action methods (the <span class="No-Break">variant part).</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor158"/>Use cases for the Template pattern</h2>
			<p>The <a id="_idIndexMarker580"/>Template design pattern focuses on eliminating code repetition. If we notice that there is repeatable code in algorithms that have structural<a id="_idIndexMarker581"/> similarities, we can keep the invariant (common) parts of the algorithms in a Template method/function and move the variant (different) parts in <span class="No-Break">action/hook methods/functions.</span></p>
			<p>Pagination is a good use case to use Template. A pagination algorithm can be split into an abstract (invariant) part and a concrete (variant) part. The invariant part takes care of things such as the maximum number of lines/pages. The variant part contains functionality to show the header and footer of a specific page that <span class="No-Break">is paginated.</span></p>
			<p>All application frameworks make use of some form of the Template pattern. When we use a framework to create a graphical application, we usually inherit from a class and implement our custom behavior. However, before this, a Template method is usually called, which implements the part of the application that is always the same, which is drawing the screen, handling the event loop, resizing and centralizing the window, and so on (<em class="italic">Python 3 Patterns, Recipes and Idioms, by Bruce Eckel &amp; Friends</em>, <span class="No-Break">page 133).</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor159"/>Implementing the Template pattern</h2>
			<p>In this example, we will implement<a id="_idIndexMarker582"/> a banner generator. The idea is rather simple. We want to send some text to a function, and the function should generate a banner containing the text. Banners have some sort of style, for example, dots or dashes surrounding the text. The banner generator has a default style, but we should be able to provide our <span class="No-Break">own style.</span></p>
			<p>The <strong class="source-inline">generate_banner()</strong> function is our Template function. It accepts, as an input, the text (<strong class="source-inline">msg</strong>) that we want our banner to contain, and the style (<strong class="source-inline">style</strong>) that we want to use. The <strong class="source-inline">generate_banner()</strong> function wraps the styled text with a simple header and footer. The header and footer can be much more complex, but nothing forbids us from calling functions that can do the header and footer generations instead of just printing <span class="No-Break">simple strings:</span></p>
			<pre class="source-code">
def generate_banner(msg, style):
    print("-- start of banner --")
    print(style(msg))
    print("-- end of banner --nn")</pre>			<p>The <strong class="source-inline">dots_style()</strong> function<a id="_idIndexMarker583"/> simply capitalizes <strong class="source-inline">msg</strong> and prints 10 dots before and <span class="No-Break">after it:</span></p>
			<pre class="source-code">
def dots_style(msg):
    msg = msg.capitalize()
    ten_dots = "." * 10
    msg = f"{ten_dots}{msg}{ten_dots}"
    return msg</pre>			<p>Another style that is supported by the generator is <strong class="source-inline">admire_style()</strong>. This style shows the text in <a id="_idIndexMarker584"/>uppercase and puts an exclamation mark between each character of <span class="No-Break">the text:</span></p>
			<pre class="source-code">
def admire_style(msg):
    msg = msg.upper()
    return "!".join(msg)</pre>			<p>The next style is by far my favorite. The <strong class="source-inline">cow_style()</strong> style executes the <strong class="source-inline">milk_random_cow()</strong> method of <strong class="source-inline">cowpy</strong>, which is used to generate a random ASCII art character every time <strong class="source-inline">cow_style()</strong> is executed. Here is the <span class="No-Break"><strong class="source-inline">cow_style()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
def cow_style(msg):
    msg = cow.milk_random_cow(msg)
    return msg</pre>			<p>The <strong class="source-inline">main()</strong> function sends the <strong class="source-inline">"happy coding"</strong> text to the banner and prints it to the standard output using all the <span class="No-Break">available styles:</span></p>
			<pre class="source-code">
def main():
    styles = (dots_style, admire_style, cow_style)
    msg = "happy coding"
    [generate_banner(msg, style) for style in styles]</pre>			<p>Here is the recap of the full code of the example (the <span class="No-Break"><strong class="source-inline">ch05/template.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We import the <strong class="source-inline">cow</strong> function <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">cowpy</strong></span><span class="No-Break">.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">generate_banner()</strong></span><span class="No-Break"> function.</span></li>
				<li>We define the <span class="No-Break"><strong class="source-inline">dots_style()</strong></span><span class="No-Break"> function.</span></li>
				<li>Next, we define the <strong class="source-inline">admire_style()</strong> and <span class="No-Break"><strong class="source-inline">cow_style()</strong></span><span class="No-Break"> functions.</span></li>
				<li>We finish with the main function and the snippet to <span class="No-Break">call it.</span></li>
			</ol>
			<p>Let’s look at <a id="_idIndexMarker585"/>a sample output by executing <strong class="source-inline">python ch05/template.py</strong> (note that your <strong class="source-inline">cow_style()</strong> output might be different due to <a id="_idIndexMarker586"/>the randomness <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">cowpy</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B21896_05_03.jpg" alt="Figure 5.3 – Sample art output of the ﻿ch05/template.py program"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Sample art output of the ch05/template.py program</p>
			<p>Do you like the art generated by <strong class="source-inline">cowpy</strong>? I certainly do. As an exercise, you can create your own style and add it to the <span class="No-Break">banner generator.</span></p>
			<p>Another <a id="_idIndexMarker587"/>good exercise is to try implementing your<a id="_idIndexMarker588"/> own <em class="italic">Template</em> example. Find some existing redundant code that you wrote and see whether this pattern <span class="No-Break">is applicable.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor160"/>Other behavioral design patterns</h1>
			<p>What about the other behavioral design patterns from the Gang of Four’s catalog? We also have the <strong class="bold">Mediator pattern</strong> and the <span class="No-Break"><strong class="bold">Visitor pattern</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>The <a id="_idIndexMarker589"/>Mediator pattern promotes loose coupling <a id="_idIndexMarker590"/>between objects by encapsulating how they interact and communicate with each other. In this pattern, objects don’t communicate directly with each other; instead, they communicate through a mediator object. This mediator object acts as a central hub that coordinates communication between the objects. The Mediator pattern stands out as a solution for <a id="_idIndexMarker591"/>promoting loose coupling and <a id="_idIndexMarker592"/>managing complex interactions <span class="No-Break">between objects.</span></li>
				<li>For complex use cases, the <a id="_idIndexMarker593"/>Visitor pattern provides <a id="_idIndexMarker594"/>a solution for separating algorithms from the objects on which they operate. By allowing new operations to be defined without modifying the classes of the elements on which they operate, the Visitor pattern promotes flexibility and extensibility in <span class="No-Break">object-oriented systems.</span></li>
			</ul>
			<p>We are not going to discuss these two patterns, since they are not commonly used by Python developers. Python offers built-in features and libraries that can help achieve loose coupling and/or extensibility goals without the need to implement these patterns. For example, one can use event-driven programming with a library such as <strong class="source-inline">asyncio</strong> instead of communication between objects through a mediator object. Additionally, using functions as first-class citizens, decorators, or context managers can provide ways to encapsulate algorithms and operations without the need for explicit <span class="No-Break">visitor objects.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor161"/>Summary</h1>
			<p>In this chapter, we discussed the behavioral <span class="No-Break">design patterns.</span></p>
			<p>First, we covered the Chain of Responsibility pattern, which simplifies the management of complex processing flows, making it a valuable tool for enhancing flexibility and maintainability in <span class="No-Break">software design.</span></p>
			<p>Second, we went over the Command pattern, which encapsulates a request as an object, thereby allowing us to parameterize clients with queues, requests, and operations. It also allows us to support undoable operations. Although the most advertised feature of command by far is undo, it has more uses. In general, any operation that can be executed at the user’s will at runtime is a good candidate for using the <span class="No-Break">Command pattern.</span></p>
			<p>We looked at the Observer pattern, which helps with the separation of concerns, increasing decoupling between the publisher and subscribers. We have seen that observers are loosely coupled with the subject and can be added or <span class="No-Break">removed dynamically.</span></p>
			<p>Then, we went over the State pattern, which is an implementation of one or more state machines used to solve a particular software engineering problem. A state machine can have only one active state at any point in time. A transition is a switch from the current state to a new state. It is normal to execute one or more actions before or after a transition occurs. State machines can be represented visually using state diagrams. State machines are used to solve many computational and non-computational problems. We saw how to implement a state machine for a computer system process using the <strong class="source-inline">state_machine</strong> module. The <strong class="source-inline">state_machine</strong> module simplifies the creation of a state machine and the definition of actions <span class="No-Break">before/after transitions.</span></p>
			<p>Afterward, we looked at the Interpreter pattern, which is used to offer a programming-like framework to advanced users and domain experts, without exposing the complexities of a programming language. This is achieved by implementing a DSL, a computer language that has limited expressiveness and targets a specific domain. The interpreter is related to what are called internal DSLs. Although parsing is generally not addressed by the Interpreter pattern, as an implementation example, we used pyparsing to create a DSL that controls a smart house and saw that using a good parsing tool makes interpreting the results using pattern <span class="No-Break">matching simple.</span></p>
			<p>Then, we looked at the Strategy design pattern, which is generally used when we want to be able to use multiple solutions for the same problem, transparently. There is no perfect algorithm for all input data and all cases, and by using Strategy, we can dynamically decide which algorithm to use in each case. We saw how Python, with its first-class functions, simplifies the implementation of Strategy by implementing two different algorithms that check whether all of the characters in a word <span class="No-Break">are unique.</span></p>
			<p>Next, we looked at the Memento pattern, which is used to store the state of an object when needed. Memento provides an efficient solution when implementing some sort of undo capability for your users. Another usage is the implementation of a UI dialog with OK/Cancel buttons, where, if the user chooses to cancel, we will restore the initial state of the object. We used an example to get a feel for how Memento, in a simplified form and using the <strong class="source-inline">pickle</strong> module from the standard library, can be used in an implementation where we want to be able to restore previous states of <span class="No-Break">data objects.</span></p>
			<p>We then looked at the Iterator pattern, which gives a nice and efficient way to iterate through sequences and collections of objects. In real life, whenever you have a collection of things and you are getting to those things one by one, you are using a form of the Iterator pattern. In Python, Iterator is a language feature. We can use it immediately on built-in containers such as lists and dictionaries, and we can define new iterable and iterator classes, to solve our problem, by using the Python iterator protocol. We saw that with an example of implementing a <span class="No-Break">football team.</span></p>
			<p>Then, we saw how we can use the Template pattern to eliminate redundant code when implementing algorithms with structural similarities. We saw how the daily routine of a worker resembles the Template pattern. We also mentioned two examples of how Python uses Template in its libraries. General use cases of when to use Template were also mentioned. We concluded by implementing a banner generator, which uses a Template function to implement custom <span class="No-Break">text styles.</span></p>
			<p>There are other structural design patterns: Mediator and Visitor. They are not commonly used by Python developers; therefore, we have not <span class="No-Break">discussed them.</span></p>
			<p>In the next chapter, we will explore architectural design patterns, which are patterns that help in solving common <span class="No-Break">architectural problems.</span></p>
		</div>
	

		<div id="_idContainer017" class="Content">
			<h1 id="_idParaDest-156" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor162"/>Part 3: Beyond the Gang of Four</h1>
			<p>This part goes beyond the classic design patterns to help you address special software design needs such as microservices, cloud-based applications, and performance optimization. It also discusses patterns for testing and specific <span class="No-Break">Python anti-patterns</span></p>
			<ul>
				<li><a href="B21896_06.xhtml#_idTextAnchor163"><em class="italic">Chapter 6</em></a>, <em class="italic">Architectural Design Patterns</em></li>
				<li><a href="B21896_07.xhtml#_idTextAnchor191"><em class="italic">Chapter 7</em></a>, <em class="italic">Concurrency and Asynchronous Patterns</em></li>
				<li><a href="B21896_08.xhtml#_idTextAnchor216"><em class="italic">Chapter 8</em></a>, <em class="italic">Performance Patterns</em></li>
				<li><a href="B21896_09.xhtml#_idTextAnchor233"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Systems Patterns</em></li>
				<li><a href="B21896_10.xhtml#_idTextAnchor256"><em class="italic">Chapter 10</em></a>, <em class="italic">Patterns for Testing</em></li>
				<li><a href="B21896_11.xhtml#_idTextAnchor273"><em class="italic">Chapter 11</em></a>, <em class="italic">Python Anti-Patterns</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer018" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>