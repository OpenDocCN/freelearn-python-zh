- en: Chapter 3. Expressions and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions are central to Python programming. As noted in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*, Python has a rich collection
    of operators and built-in functions. In this chapter, we'll summarize the relationship
    between data types and the operators they support.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most fundamental program possible is one that performs a calculation
    and displays output. To demonstrate this, we'll look at the `print()` function
    in this chapter. We'll expand on the basics by looking at a number of ways to
    produce nicely-formatted text output.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to look in detail at the Python syntax rules. This will be essential
    for writing scripts with more complex sequences of statements. It will also set
    the stage for looking at compound statements in [Chapter 5](ch05.html "Chapter 5. Logic,
    Comparisons, and Conditions"), *Logic, Comparisons, and Conditions*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also demonstrate some additional string processing techniques.
    We'll summarize some of the standard library modules that are focused on string
    processing. We'll look closely at the `re` module; we use this to build regular
    expressions that help parse string input. Between the built-in methods of the
    `str` class, and the `re` module, we can handle a wide variety of text input conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions, operators, and data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python expressions are built from operators and operands. In [Chapter 2](ch02.html
    "Chapter 2. Simple Data Types"), *Simple Data Types*, we introduced some of the
    basics of number and string operands, and looked at the variety of operators.
    We'll summarize the details here so that we can address some additional operator
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our numeric operands form a "tower", with types including:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Cardinality | Number of operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `complex` | Ideally, the most distinct values built from a pair of irrational
    numbers, ∞×∞.Actually (`float` × `float`) or about ![Expressions, operators, and
    data types](img/B03671_03_01.jpg) values. | The fewest operators; only arithmetic,
    some built-in functions, and the `cmath` module. |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | Ideally this is a rational number union with irrational numbers
    (∞+∞).Actually closer to ![Expressions, operators, and data types](img/B03671_03_02.jpg)
    distinct values. | Arithmetic operators, comparisons. Many additional `math` modules
    and built-in functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `fractions.Fraction` | Ideally, these are rational numbers (∞×∞).Actually
    only limited by available memory to represent two integers. | Arithmetic operators,
    comparisons, built-in functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal.Decimal` | Ideally, rational numbers.Actually only limited by memory
    | Arithmetic operators, comparisons, built-in functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Ideally, natural numbers, ∞.Actually limited only by memory. | Arithmetic
    operators, comparisons, plus bit-handling operators, libraries and built-in functions.
    |'
  prefs: []
  type: TYPE_TB
- en: The `Fraction` and `Decimal` class definitions must be imported, the other three
    classes are built-in. We typically use a statement such as `from fractions import
    Fraction`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the tower is that many arithmetic operators coerce operands
    up the tower from integer to float to complex. Most of the time, this fits with
    our implicit mathematical expectations. We would be unhappy if we had to write
    explicit conversions to compute `2.333*3`. Python's arithmetic rules assure us
    that we'll get the expected floating-point result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Decimal` class doesn''t fit well with the implicit coercion rules: in
    the rare case of trying to do arithmetic between `float` and `Decimal`, it''s
    unclear how to go about it. An attempt to make a `Decimal` value from a `float`
    value will expose tiny errors because `float` values are an approximation. An
    attempt to make a `float` value from a `Decimal` value subverts the `Decimal`
    objective of yielding exact results. In the face of this ambiguity, an exception
    will be raised. This means that we''ll need to write explicit conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: String objects are not implicitly coerced into numeric values. We must explicitly
    convert a string to a number. The `int()`, `float()`, `complex()`, `Fraction()`,
    and `Decimal()` functions convert a string to a number object of the appropriate
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We can group operators into a number of categories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**: `+`, `-`, `*`, `**`, `/`, `//`, `%`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit-oriented**: `<<`, `>>`, `&`, `|`, `^`, `~`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparison**: `<`, `>`, `<=`, `>=`, `==`, `!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bit-oriented operators are supported by operands of the `int` class. The
    other number classes don't have useful implementations of these operators. The
    bit-oriented operators are also defined for sets, something we'll look at in [Chapter
    6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Using operators on non-numeric data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply some of the arithmetic operators to strings, bytes, and tuples.
    The results are focused on creating larger strings or larger tuples from smaller
    pieces. Here are some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we applied `+` to two strings. In the second example,
    we applied `*` between a `str` and an `int`. Interestingly, Python produces a
    string result by concatenating several copies of the original string object. Multiplying
    by any negative number creates a zero-length string.
  prefs: []
  type: TYPE_NORMAL
- en: The print() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Python's REPL, we can enter an expression and Python prints
    the result. In other contexts, we must use the `print()` function to see results.
    The `print()` function implicitly writes to `sys.stdout`, so the results will
    be visible on the console where we ran the Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide any number of expressions to the `print()` function. Each value
    is converted to a string using the `repr()` function. The strings are combined
    with a default separator of `'' ''` and printed with a default line ending of
    `''\n''`. We can change the separator and line ending characters. Here are some
    examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've printed a string and the floating-point result of an expression. In the
    second example, we changed the separator string from a space to `'='`. In the
    third example, we changed the separator string to `'='` and the end-of-line string
    to `'!\n'`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `sep` and `end` parameters must be provided by name; these are
    called **keyword arguments**. Python syntax rules require that keyword argument
    values are provided after all of the positional arguments. We'll examine the rules
    in detail in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic
    Function Definitions*.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `,` as a separator to create simple **comma-separated values** (**CSV**)
    files. We can also use `\t` to create a kind of CSV file with a tab character
    as the column separator. The `csv` library module does an even more complete job
    of CSV formatting, specifically including proper escapes or quoting for data items
    which contain the separator character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to the standard error file, we''ll need to import the `sys` module,
    where that object is defined. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `sys` module. This contains definitions of `sys.stderr` and
    `sys.stdout` for the standard output files. By using the `file=` keyword parameter,
    we can direct a specific line of output to the `stderr` file instead of the default
    of `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: This can work well in a script file. Using the standard error file doesn't look
    very interesting at the REPL prompt since, by default, both standard output and
    standard error go to the console. Some IDE's will color-code the standard error
    output. We'll look at many ways to open and write to other files in [Chapter 10](ch10.html
    "Chapter 10. Files, Databases, Networks, and Contexts"), *Files, Databases, Networks,
    and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: Examining syntax rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are nine fundamental syntax rules in section 2.1 of the *Python Language
    Reference*. We''ll summarize those rules here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two species of statements: simple and compound. Simple statements
    must be complete on a single logical line. A compound statement starts with a
    single logical line and must contain indented statements. The initial clause of
    a compound statement ends with a `:` character. It''s possible, using rules 5
    and 6, to join a number of physical lines together to create a single logical
    line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a typical simple statement, complete in a single logical line:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a typical compound statement with a nested simple statement, spread
    across two logical lines:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: A **physical line** ends with `\n`. In Windows, `\r\n` is also accepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **comment** starts with `#` and continues to the end of the physical line.
    It will end the logical line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example of a comment:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: A special comment can be used to annotate the file encoding. This is generally
    not needed, since most IDE's and text editors handle the file encoding politely.
    We should generally save Python files in UTF-8 encoding. Older files may be saved
    in ASCII.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Physical lines can be joined explicitly into a logical line using the `\` as
    an escape character in front of the physical end-of-line character. This is rarely
    used and generally discouraged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Physical lines can be joined implicitly into a logical line using `()`, `[]`,
    or `{}`; these must pair properly for the logical line to be complete. An expression
    beginning with `(` can span multiple physical lines until there is a matching
    `)`. This is used frequently and is strongly encouraged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example of a statement that relies on `()` to join four physical
    lines into one logical line:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Blank lines contain only spaces, tabs and newlines. The interactive REPL uses
    a blank line to end a compound statement; the REPL is the only context in which
    a blank line is meaningful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leading whitespace is **required** to properly group statements inside the clauses
    of compound statements. Either spaces or tabs can be used to indent. Consistency
    is essential. A four space indent is widely used and strongly encouraged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Except at the beginning of the line,—where it determines nesting of compound
    statements—whitespace can be used freely between tokens. Note that there are some
    preferences regarding precisely how spaces are used within a statement; the **Python
    Enhancement Proposal** (**PEP**) number 8 provides some advice. See [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
    for fodder for endless disputes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perhaps the most important two rules are rule 6 and rule 8\. Rule 6 means that
    it is very common to use `()`, `[]`, and `{}` to force multiple physical lines
    to be joined into a single logical line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 8 requires that our indentation is done consistently: indents and outdents
    must be matched. While it''s legal to use tabs, spaces, and any haphazard—but
    consistent—mix of tabs and spaces, four spaces is highly recommended. Tabs are
    discouraged because they''re hard to distinguish from spaces. Most editors can
    be set to replace the tab key with four spaces. A good text editor can recognize
    the basics of Python syntax and can handle indents and outdents gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `()` to allow a statement to span multiple physical lines; avoid `\` at
    end-of-line.
  prefs: []
  type: TYPE_NORMAL
- en: Use a four space indent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that Python will merge adjacent strings when parsing the source.
    We can have code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This assignment statement used a gratuitous `()` pair to allow the logical line
    to span multiple physical lines. The expression is simply two adjacent strings,
    `"Hello"` and `"world"`. When Python parses the source text, these two adjacent
    strings are merged; only a single string is used when evaluating the statement.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, note that the REPL prompt changed from `>>>` to … because the
    REPL recognized the first physical line as a partial statement. This is a handy
    reminder that our statement isn't complete. When the final `)` was parsed, the
    statement was complete and the prompt switched back to `>>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting, partitioning, and joining strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at different processing methods for a string object. We can transform
    a string into a new string, create strings from non-string data, access a string
    to determine properties or locations within the string, and parse a string to
    decompose it.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we need to extract elements of a string. The `split()` method
    is used to locate repeating list-like structures within a string. The `partition()`
    method is used to separate the head and tail of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given a string of the form `"numerator=355,denominator=115"` we
    can use these two methods to locate the various names and values. Here''s how
    we can decompose this complex string into pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `split(",")` method to break the longer string on each `,` character,
    creating a list object which has two substrings. The REPL automatically assigns
    all expression results to a variable named `_`. We assigned the object to the
    `items` variable because the value of `_` gets overwritten by each expression
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `partition("=")` method on each item in the `items` variable to
    break the assignment down into name, `=`, and value. A more complex application
    would probably perform more complex processing on the names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `join()` method is the inverse of the `split()` method. This works with
    a sequence of string objects to create a single long string from many smaller
    strings. Here''s an example of using a tuple of strings to create a longer string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've created a sequence of three strings and assigned it to a variable named
    `options`. We then used the string `"|"` to join the items in the `options` sequence.
    The result is a longer string with the items separated by the given string.
  prefs: []
  type: TYPE_NORMAL
- en: The `split()` and `join()` methods work well with singletons. If we try to split
    a single item with no punctuation, we get a sequence with a single item. If we
    join a singleton item, the separator will not be used.
  prefs: []
  type: TYPE_NORMAL
- en: Python's string methods give us the tools to handle a variety of string parsing
    and decomposition. For a more general solution, we'll have to resort to even more
    powerful tools. We'll look at the regular expression module, `re`, later.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to create complex strings, we use the `format()` method. We'll look
    at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the format() method to make more readable output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sophisticated string creation can be done with the `format()` method. We create
    a template string and values which can be plugged into the template. Here''s an
    example of how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've created a variable, `c`, with a value of 42\. We've used a template, `"{0:d}°C
    is {1:.1f}°F"`, to format two values. The argument value with an index of 0 is
    `c`, the argument value with an index of 1 is the value of the expression `32+9*c/5`.
  prefs: []
  type: TYPE_NORMAL
- en: The template string includes literal characters, plus replacement fields. Each
    replacement field is surrounded by `{}`. The replacement field has two components
    with a syntax of `{index:specification}`. The *index* component identifies which
    item is taken from the positional arguments to the `format()` method. The *specification*
    component shows us how to format the selected object.
  prefs: []
  type: TYPE_NORMAL
- en: The example gives two specifications. One specification is the character `d`,
    which is the decimal integer conversion. The other is the slightly more complex
    `.1f`, which is a floating-point conversion with one digit to the right of the
    decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is considerable sophistication available in the format specifications.
    There are eight fields to a format specification. The syntax gloss looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've surrounded each field with `[]` to group the names visually. Note that
    all the fields are actually optional and have default values.
  prefs: []
  type: TYPE_NORMAL
- en: We'll summarize the fields from right to left in order of importance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**: This specifies the overall type of conversion. Depending on the kind
    of Python object, there are a number of type codes available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For string values, the type code of `s` is used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For integer values, type codes of `d`, `n`, `b`, `o`, `x`, or `X` can be used.
    These provide decimal, locale-aware numbers, binary, octal, or hexadecimal output.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For float values, type codes are `e`, `E`, `f`, `F`, `g`, `G`, `n`, or `%`.
    The `e` formats provide explicit exponents. The `f` codes show `float` values
    with no exponent. The `g` values are called **general** and choose `e` or `f,`
    depending on the size of the number. The `n` code is locale-aware, using the locale
    settings for floating-point presentation. The `%` multiplies by 100 and includes
    the `%` symbol.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precision**: The `.precision` value is only used for floating-point formats.
    It''s the number of positions to the right of the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The , separator**: If a `,` character is used, then US-style `,` as 1,000''s
    separators are included. This isn''t locale-aware, so it can''t be overridden
    by the OS and the Python locale module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width**: If omitted, the number is formatted as wide as necessary. If provided,
    the number is filled out to this width. By default, the fill uses leading spaces,
    but this can be changed by providing values for the *fill* and *align* fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0**: This forces filling to the required width with leading zeroes. This
    is the same as a fill and align of `0=`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#**: This is used with `b`, `o`, and `x` formatting to include a prefix of
    `0b`, `0o`, or `0x` in front of the number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign**: By default, positive numbers have no sign and negative numbers have
    a leading `-`. Providing a *sign* field of `+` means that all signs are shown
    explicitly. Providing a *sign* field of `-` means that an extra space is included
    for positive numbers, assuring that positive and negative numbers will align in
    columns when printed using a fixed-width font.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fill and align**: This fills up the space to the value of the *width* field.
    If we provide *align* without a specific *fill* character, the default character
    is a space. We can''t provide a *fill* character on its own, though. There are
    four codes we can use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` or *fill*`<` will push the data to the left, and the filling will be on
    the right.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` or *fill*`>` will push the data to the right, the fill character will be
    used on the left.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` or *fill*`^` will center the data, filling both left and right.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=` or *fill*`=` will put the sign first, and the fill character will be used
    after the sign. This will make the signs more prominent in a column of numbers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example that uses a fairly complex format specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've created an object, `amount`, with a `Decimal` value. We then used a format
    specification of `*>10n` on this number. This used leading `*` characters to fill
    out the number to 10 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of the standard string libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's standard library offers a number of modules with additional string
    processing features.
  prefs: []
  type: TYPE_NORMAL
- en: '`string`: The string module contains constants that decompose the ASCII characters
    into letters, numbers, whitespace, and so on. It contains the full definition
    of the formatter that is used by the `str.format()` method. We''ll look at this
    in the next section. It also contains the `Template` class which defines a string
    template into which values can be interpolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`re`: The regular expression library allows us to define a pattern that can
    be used to parse input strings. We''ll look at this in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difflib`: The `difflib` module is used to compare sequences of strings, typically
    from text files. There are a number of comparison algorithms available in this
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textwrap`: We can use the `textwrap` module to format large blocks of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicodedata`: The `unicodedata` module provides functions for determining
    what kind of Unicode character is present. Unicode Standard Annex 44 defines a
    collection of properties that apply to the Unicode characters. One commonly-used
    function is the general category of a character; this includes simple Latin rules
    like "Lu" for uppercase letter or "Nd" for decimal number. The general category
    codes also include "Sk" which is for non-letter like modifier symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringprep`: This is an implementation of RFC 3454, which prepares Unicode
    text strings in order to support sensible string comparisons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the re module to parse strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions give us a simple way to specify a set of related strings
    by describing the pattern they have in common. A regular expression is an element
    of set theory that could (in theory) define the set of all possible related strings.
    The theoretical matching process would be a quick check to see if a given string
    in this set of all possible strings is generated by the expression. Since the
    set of all possible strings generated from a pattern could potentially be infinite,
    this isn't how things work in practice.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `re` module, we generally do three things. Firstly, we specify
    the pattern string. Secondly, we compile the pattern into an object that efficiently
    determines if and where a given string matches the pattern. Finally, we repeatedly
    use the `pattern` object to efficiently match, search, or parse the given input
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, we need to process input which contains lines like this:
    `Birth Date: 3/8/1987` or `Birth Date: 1/18/59`. Note that the number of digits
    in each date and the amount of whitespace is allowed to vary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may perform any of the following three common kinds of processing:'
  prefs: []
  type: TYPE_NORMAL
- en: A **matching** regular expression might be `Birth Date:\s+\d+/\d+/\d+`. The
    `\s+` subexpression means one or more spaces. The `\d+` subexpression of this
    means one or more digits. A match pattern is usually designed to match the whole
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **searching** regular expression might be `\d+/\d+/\d+`. This search pattern
    includes one or more digits, `\d+`, and literal punctuation, `/`. This expression
    describes a substring that can be found somewhere within the given string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **parsing** pattern separates the various digit groups from the surrounding
    context. This is a slight modification to one of the previous examples to include
    `()`, that specifies what to capture. We might use `(\d+)/(\d+)/(\d+)` to show
    that the digit groups should be extracted for further processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can accomplish these matching, searching, and parsing operations with the
    `re` module in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general recipe for using regular expressions in a Python program has three
    essential steps. Of course, we must use import re to include the required module.
    The three steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the pattern string. This will almost always be a raw string, starting
    with `r"`, because the regular expression string will be full of `\` characters
    that we don't want to be treated as escapes by Python. Because `\` begins a Python
    language escape, if we want to write a standalone `\` character, we have to double
    them up in a non-raw string. It is better to use a raw string to write `r"\d+/\d+/\d+"`
    than `\\d+/\\d+/\\d+`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the `re.compile()` function to create a `pattern` object. The resulting
    object will do the real work of matching a given target string against the regular
    expression `pattern` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can combine the pattern and the compile in one statement like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the compiled `pattern` object to match or search the candidate strings.
    The result of a successful match or search will be a `Match` object. We can then
    use the match object, where necessary, to extract fields. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first example, the `date_pattern.match()` expression returned `None`
    because the given string didn't match the regular expression. In the second example,
    the given string did match the regular expression pattern, and a `Match` object
    was created. If our regular expression is used for parsing, we'll interrogate
    the `Match` object to get the various substrings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we have a `Match` object, it can have captured substrings that match parts
    of the overall pattern. We''ll usually make use of the various `group()` methods
    to get substrings. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we saw all of the matching content. In the second example,
    we saw the value of group number one, the first portion of the regular expression
    wrapped in `()`. In the final example, we saw all `()`-wrapped groups in the regular
    expression. Since there was only one such group, the value of `groups()` is a
    single-item `tuple` with matching text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a regular expression string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are numerous rules for creating regular expression patterns, and we'll
    look at a few of them here. The definitive list is in the *Python Standard Library*
    documentation for the `re` module, in section 6.2.1\. For more information on
    this topic, see *Mastering Python Regular Expressions* from Packt Books. See [https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'First we''ll look at the "atomic" regular expressions. Then we''ll look at
    the rules for combining regular expressions into a larger regular expression.
    Here are some simple, atomic regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Any single character. With a few exceptions, this means just about any printable
    character. The exceptions are the characters which have special meaning in the
    regular expression language, including `.`, `*`, `?`, `(`, `)`, `[`, `]`, `|`
    among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `.` matches any character. To match a period, the `\` escape character is
    used: `\.` matches a period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some escape sequences match whole classes of characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` matches any digit. `\D` matches any non-digit character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches any whitespace character. `\S` matches any non-space character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w` matches any word character. `\W` matches any non-word character. By default,
    these follow the Unicode rules. We can override this to follow a considerably
    simpler set of ASCII-only rules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some suffixes that we can put after a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: A `*` suffix means the previous expression can be matched zero or more times.
    This has the effect of making the previous RE pattern optional as well as eligible
    for repetition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `+` suffix means the previous expression can be matched one or more times.
    This means that the previous pattern is mandatory and can also be repeated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `?` suffix means the previous expression is optional; it can be matched zero
    times or just one time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To actually match a suffix character, use the `\` escape. For example, `\*`
    matches an asterisk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can combine individual expressions into larger patterns. Here are some common
    techniques for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of regular expressions is a regular expression. We simply put the
    expressions one after another inside the pattern string. When we write an expression
    like `Birth` it's a sequence of five atomic expressions which match each individual
    character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of characters in `[]` matches any one of the given characters. This
    is generally used with single-character expressions; often we'll see constructs
    like `[a-zA-Z0-9_]` to match any letter or digit or `_`. To match multiple-character
    strings we use a suffix after the `[]`. We can use `r"[0-9a-fA-F]+"` to match
    one or more hexadecimal digits. To make `-` one of the alternative characters,
    it must be first or last within the list of characters inside the `[]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two regular expressions separated by `|` is a regular expression. Either one
    can match. We might be looking at a pattern like `true|false`. We must match one
    of the two regular expressions: either `true` or `false`. To match the pipe character,
    `|`, it must be escaped like this `\|`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular expression surrounded by `()`'s is a regular expression. It's also
    preserved as a group, so that we can use the matching characters while parsing.
    To match parentheses, they must be escaped, `\(` matches a `(`. Substrings captured
    via `()` are available via the `group()` method of the match object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These rules help us examine the details of a specific pattern. Here''s a pattern
    we might use to parse some input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a regular expression which is a sequence of 5 regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The characters `(\w+)` make a regular expression, `\w`, with a `+` suffix enclosed
    in `()`. This matches any sequence of one or more word characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s*` is a regular expression. It''s a simple expression `\s` with a suffix
    of `*`. It matches zero or more whitespace characters. This means that spaces
    are optional after the initial word. If spaces are present, any number may be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=:]` is a regular expression built from two single-character expressions,
    `=` and `:`. It matches either one of the two characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s*` is used a second time to permit any number of whitespace characters between
    the `=` or `:` and the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final regular expression is `(.*)` which matches any sequence of characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use this regular expression, if a `Match` object is created, it will
    have two groups. We can then extract the name and value matched by the patterns
    within this regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unicode, ASCII, and bytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `re` module works with bytes as well as Unicode strings. We must provide
    proper pattern literals depending on which kind of string we''re working with.
    With Unicode, we use pattern literals with the `r` prefix: `r"\w+"`. With bytes,
    we use the `rb` prefix, `rb"\w+"`; the `rb` means raw bytes instead of raw Unicode
    characters.'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for the character classes are, of course, different. A Unicode string
    that matches the `"\w+"` pattern can have any of a wide variety of Unicode "word"
    characters. A bytes object that uses the `"\w+"` pattern will match ASCII characters
    from the set `a-z`, `A-Z`, `0-9` and `_`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must explicitly use bytes for the pattern literals when parsing, searching,
    or matching with bytes.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an option in the `re.compile()` to force a Unicode pattern to follow
    the simplified ASCII rules. If we write `re.compile(r"\w+", re.ASCII)` we've replaced
    the default Unicode assumption for `\w` with the ASCII rule for `\w` even though
    we're doing Unicode string matching.
  prefs: []
  type: TYPE_NORMAL
- en: Using the locale module for personalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When looking at the `str.format()` method, we saw that the `n` format type produced
    a number with formatting based on the user's locale. This means that the formatting
    varies according to the OS locale settings. Users in different countries will
    see that their personal locale settings are used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `locale` module to get locale-specific formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This script used the `locale` module to set the Python locale to match the prevailing
    OS locale. The locale is reported to be English as used in the US (`en_US`) and
    the preferred Unicode encoding is shown as UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: The formatted value of `23.456` showed up with a US English decimal point. This
    fits the expectations of users in the US.
  prefs: []
  type: TYPE_NORMAL
- en: We then switched the locale to Sweden. The language was reported as `sv_SE`,
    which means the Swedish language, as used in Sweden. The formatted value switched
    to `23,456` with a decimal comma, which is appropriate for users in Sweden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue this example, and use the `locale.currency()` formatting function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The amount was formatted using `,` for the decimal separator and `kr` as the
    local currency in Sweden. The locale module includes the currency names.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we provided the numeric value, `23.54`, in Python syntax, which does
    not vary by locale. Python floating-point literals always use decimal points.
    Only the output string from the `currency()` function uses the `,` character as
    a decimal place separator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've reviewed the essential numeric types and the operators
    available on Python. We've looked at some expressions that involve a mixture of
    string and numeric data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to view the output from our scripts, we've looked at the `print()`
    function. This is used widely to produce output. The `print()` function is a very
    handy tool for debugging particularly complex functions or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we've looked at how we can use the `str.format()` method to produce
    elaborately formatted data. This gives us a wide variety of techniques for converting
    Python objects to strings that can be displayed. We've also looked at some ways
    that we can parse strings using string method functions such as `split()` and
    `partition()`.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basics of string processing, we've looked at how we can use the `re`
    module to match, search, and parse strings. This module is sophisticated and has
    a large number of features for extracting useful information from input strings.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Variables, Assignment and Scoping Rules"),
    *Variables, Assignment and Scoping Rules*, we'll expand on our script-writing
    by using variables to store intermediate results. We'll also look at how objects
    are created and removed. These rules will lead to an understanding of which variables
    are visible in which portions of a complex program.
  prefs: []
  type: TYPE_NORMAL
