["```py\nclass Event:\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return self.name\n```", "```py\nclass Widget:\n    def __init__(self, parent=None):\n        self.parent = parent\n    def handle(self, event):\n        handler = f\"handle_{event}\"\n        if hasattr(self, handler):\n            method = getattr(self, handler)\n            method(event)\n        elif self.parent is not None:\n            self.parent.handle(event)\n        elif hasattr(self, \"handle_default\"):\n            self.handle_default(event)\n```", "```py\nclass MainWindow(Widget):\n    def handle_close(self, event):\n        print(f\"MainWindow: {event}\")\n    def handle_default(self, event):\n        print(f\"MainWindow Default: {event}\")\n```", "```py\nclass SendDialog(Widget):\n    def handle_paint(self, event):\n        print(f\"SendDialog: {event}\")\n```", "```py\nclass MsgText(Widget):\n    def handle_down(self, event):\n        print(f\"MsgText: {event}\")\n```", "```py\ndef main():\n    mw = MainWindow()\n    sd = SendDialog(mw)\n    msg = MsgText(sd)\n    for e in (\"down\", \"paint\", \"unhandled\", \"close\"):\n        evt = Event(e)\n        print(f\"Sending event -{evt}- to MainWindow\")\n        mw.handle(evt)\n        print(f\"Sending event -{evt}- to SendDialog\")\n        sd.handle(evt)\n        print(f\"Sending event -{evt}- to MsgText\")\n        msg.handle(evt)\n```", "```py\nSending event -down- to MainWindow\nMainWindow Default: down\nSending event -down- to SendDialog\nMainWindow Default: down\nSending event -down- to MsgText\nMsgText: down\nSending event -paint- to MainWindow\nMainWindow Default: paint\nSending event -paint- to SendDialog\nSendDialog: paint\nSending event -paint- to MsgText\nSendDialog: paint\nSending event -unhandled- to MainWindow\nMainWindow Default: unhandled\nSending event -unhandled- to SendDialog\nMainWindow Default: unhandled\nSending event -unhandled- to MsgText\nMainWindow Default: unhandled\nSending event -close- to MainWindow\nMainWindow: close\nSending event -close- to SendDialog\nMainWindow: close\nSending event -close- to MsgText\nMainWindow: close\n```", "```py\nimport logging\nimport os\nlogging.basicConfig(level=logging.DEBUG)\nclass RenameFile:\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n    def execute(self):\n        logging.info(\n            f\"[renaming '{self.src}' to '{self.dest}']\"\n        )\n        os.rename(self.src, self.dest)\n    def undo(self):\n        logging.info(\n            f\"[renaming '{self.dest}' back to '{self.src}']\"\n        )\n        os.rename(self.dest, self.src)\n```", "```py\nclass CreateFile:\n    def __init__(self, path, txt=\"hello world\\n\"):\n        self.path = path\n        self.txt = txt\n    def execute(self):\n        logging.info(f\"[creating file '{self.path}']\")\n        with open(\n            self.path, \"w\", encoding=\"utf-8\"\n        ) as out_file:\n            out_file.write(self.txt)\n    def undo(self):\n        logging.info(f\"deleting file {self.path}\")\n        os.remove(self.path)\n```", "```py\nclass ReadFile:\n    def __init__(self, path):\n        self.path = path\n    def execute(self):\n        logging.info(f\"[reading file '{self.path}']\")\n        with open(\n            self.path, \"r\", encoding=\"utf-8\"\n        ) as in_file:\n            print(in_file.read(), end=\"\")\n```", "```py\ndef main():\n    orig_name, new_name = \"file1\", \"file2\"\n    commands = (\n        CreateFile(orig_name),\n        ReadFile(orig_name),\n        RenameFile(orig_name, new_name),\n    )\nfor c in commands:\n    c.execute()\n```", "```py\n    answer = input(\"reverse the executed commands? [y/n] \")\n    if answer not in \"yY\":\n        print(f\"the result is {new_name}\")\n        exit()\n    for c in reversed(commands):\n        try:\n            c.undo()\n        except AttributeError as e:\n            logging.error(str(e))\n```", "```py\nINFO:root:[creating file 'file1']\nINFO:root:[reading file 'file1']\nhello world\nINFO:root:[renaming 'file1' to 'file2']\nreverse the executed commands? [y/n] y\nINFO:root:[renaming 'file2' back to 'file1']\nERROR:root:'ReadFile' object has no attribute 'undo'\nINFO:root:deleting file file1\n```", "```py\nINFO:root:[creating file 'file1']\nINFO:root:[reading file 'file1']\nhello world\nINFO:root:[renaming 'file1' to 'file2']\nreverse the executed commands? [y/n] n\nERROR, in the first case, is normal for this context.\n\t\t\tThe Observer pattern\n\t\t\tThe Observer pattern describes a publish-subscribe relationship between a single object, the publisher, which is also known as the subject or **observable**, and one or more objects, the subscribers, also known as **observers**. So, the subject notifies the subscribers of any state changes, typically by calling one of their methods.\n\t\t\tThe ideas behind the Observer pattern are the same as those behind the separation of concerns principle, that is, to increase decoupling between the publisher and subscribers, and to make it easy to add/remove subscribers at runtime.\n\t\t\tReal-world examples\n\t\t\tDynamics in an auction are similar to the behavior of the Observer pattern. Every auction bidder has a number paddle that is raised whenever they want to place a bid. Whenever the paddle is raised by a bidder, the auctioneer acts as the subject by updating the price of the bid and broadcasting the new price to all bidders (subscribers).\n\t\t\tIn software, we can cite at least two examples:\n\n\t\t\t\t*   **Kivy**, the Python framework for developing **user interfaces** (**UIs**), has a module called **Properties**, which implements the Observer pattern. Using this technique, you can specify what should happen when a property’s value changes.\n\t\t\t\t*   The **RabbitMQ library** provides an implementation of an **Advanced Message Queuing Protocol** (**AMQP**) messaging broker. It is possible to construct a Python application that interacts with RabbitMQ in such a way that it subscribes to messages and publishes them to queues, which is essentially the Observer design pattern.\n\n\t\t\tUse cases for the Observer pattern\n\t\t\tWe generally use the Observer pattern when we want to inform/update one or more objects (observers/subscribers) about a change that happened on a given object (subject/publisher/observable). The number of observers, as well as who those observers are, may vary and can be changed dynamically.\n\t\t\tWe can think of many cases where Observer can be useful. One such use case is news feeds. With RSS, Atom, or other related formats, you follow a feed, and every time it is updated, you receive a notification about the update.\n\t\t\tThe same concept exists in social networking applications. If you are connected to another person using a social networking service, and your connection updates something, you are notified about it.\n\t\t\tEvent-driven systems are another example where Observer is usually used. In such systems, you have listeners that listen for specific events. The listeners are triggered when an event they are listening to is created. This can be typing a specific key (on the keyboard), moving the mouse, and more. The event plays the role of the *publisher*, and the listeners play the role of the *observers*. The key point in this case is that multiple listeners (observers) can be attached to a single event (publisher).\n\t\t\tImplementing the Observer pattern\n\t\t\tAs an example, let’s implement a weather monitoring system. In such a system, you have a weather station that collects weather-related data (temperature, humidity, and atmospheric pressure). Our system needs to allow different devices and applications to receive real-time updates whenever there is a change in the weather data.\n\t\t\tWe can apply the Observer pattern using the following elements:\n\n\t\t\t\t*   `WeatherStation` class that acts as the subject. This class will maintain a list of observers (devices or applications) interested in receiving weather updates.\n\t\t\t\t*   **Observers (devices and applications)**: Implement various observer classes, representing devices such as smartphones, tablets, weather apps, and even a display screen in a local store. Each observer will subscribe to receive updates from the weather station.\n\t\t\t\t*   `subscribe`) and unregister (`unsubscribe`) themselves. When there is a change in weather data (e.g., a new temperature reading), the weather station notifies all registered observers.\n\t\t\t\t*   `update()` method that the weather station calls when notifying about changes. For instance, a smartphone observer may update its weather app with the latest data, while a local store display may update its digital sign.\n\n\t\t\tLet’s get started.\n\t\t\tFirst, we define the `Observer` interface, which holds an `update` method that observers must implement. Observers are expected to update themselves when the subject’s state changes:\n\n```", "```py\n\n\t\t\tNext, we define the `WeatherStation` subject class. It maintains a list of observers and provides methods to add and remove observers. The `set_weather_data` method is used to simulate changes in weather data. When the weather data changes, it notifies all registered observers by calling their `update` methods. The code is as follows:\n\n```", "```py\n\n\t\t\tLet’s now define the `DisplayDevice` observer class. Its `update` method prints weather information when called:\n\n```", "```py\n\n\t\t\tSimilarly, we define another observer class, `WeatherApp`, which prints weather information in a different format when its `update` method is called:\n\n```", "```py\n\n\t\t\tNow, in the `main()` function, we do several things:\n\n\t\t\t\t*   We create an instance of the `WeatherStation` class, which acts as the subject.\n\t\t\t\t*   We create instances of `DisplayDevice` and `WeatherApp`, representing different types of observers.\n\t\t\t\t*   We register these observers with `weather_station` using the `add_observer` method.\n\t\t\t\t*   We simulate changes in weather data by calling the `set_weather_data` method of `weather_station`. This triggers updates to all registered observers.\n\n\t\t\tThe code of the `main()` function is as follows:\n\n```", "```py\n\n\t\t\tLet’s recapitulate the complete code (in the `ch05/observer.py` file) of the implementation:\n\n\t\t\t\t1.  We define the Observer interface.\n\t\t\t\t2.  We define the `WeatherStation` subject class.\n\t\t\t\t3.  We define two observer classes, `DisplayDevice` and `WeatherApp`.\n\t\t\t\t4.  We add a `main()` function where we test our design.\n\n\t\t\tExecuting the `python ch05/observer.py` command gives us the following output:\n\n```", "```py\n\n\t\t\tAs you can see, this example demonstrates the Observer pattern, where the subject notifies its observers about changes in its state. Observers are loosely coupled with the subject and can be added or removed dynamically, providing flexibility and decoupling in the system.\n\t\t\tAs an exercise, you can see that when unregistering an observer, using the `remove_observer()` method, and then simulating additional weather data changes, only the remaining registered observers receive updates. As a helper, to test this, here are 2 lines of code to add at the end of the `main()` function:\n\n```", "```py\n\n\t\t\tNext, we will discuss the State pattern.\n\t\t\tThe State pattern\n\t\t\tIn the previous chapter, we covered the Observer pattern, which is useful in a program to notify other objects when the state of a given object changes. Let’s continue discovering those patterns proposed by the Gang of Four.\n\t\t\tOOP focuses on maintaining the states of objects that interact with each other. A very handy tool to model state transitions when solving many problems is known as a **finite-state machine** (commonly called a **state machine**).\n\t\t\tWhat’s a state machine? A state machine is an abstract machine that has two key components, that is, states and transitions. A state is the current (active) status of a system. For example, if we have a radio receiver, two possible states for it are to be tuned to FM or AM. Another possible state is for it to be switching from one FM/AM radio station to another. A transition is a switch from one state to another. A transition is initiated by a triggering event or condition. Usually, an action or set of actions is executed before or after a transition occurs. Assuming that our radio receiver is tuned to the 107 FM station, an example of a transition is for the button to be pressed by the listener to switch it to 107.5 FM.\n\t\t\tA nice feature of state machines is that they can be represented as graphs (called **state diagrams**), where each state is a node, and each transition is an edge between two nodes.\n\t\t\tState machines can be used to solve many kinds of problems, both non-computational and computational. Non-computational examples include vending machines, elevators, traffic lights, combination locks, parking meters, and automated gas pumps. Computational examples include game programming and other categories of computer programming, hardware design, protocol design, and programming language parsing.\n\t\t\tNow, we have an idea of what state machines are! But how are state machines related to the State design pattern? It turns out that the State pattern is nothing more than a state machine applied to a particular software engineering problem (*Gang of Four-95*, page 342), (*Python 3 Patterns, Recipes and Idioms by Bruce Eckel & Friends*, page 151).\n\t\t\tReal-world examples\n\t\t\tA snack vending machine is an example of the State pattern in everyday life. Vending machines have different states and react differently depending on the amount of money that we insert. Depending on our selection and the money we insert, the machine can do the following:\n\n\t\t\t\t*   Reject our selection because the product we requested is out of stock.\n\t\t\t\t*   Reject our selection because the amount of money we inserted was not sufficient.\n\t\t\t\t*   Deliver the product and give no change because we inserted the exact amount.\n\t\t\t\t*   Deliver the product and return the change.\n\n\t\t\tThere are, for sure, more possible states, but you get the point.\n\t\t\tOther examples of the state pattern in real life are as follows:\n\n\t\t\t\t*   Traffic lights\n\t\t\t\t*   Game states in a video game\n\n\t\t\tIn software, the state pattern is commonly used. Python and its ecosystem offer several packages/modules one can use to implement state machines. We will see how to use one of them in the implementation section.\n\t\t\tUse cases for the State pattern\n\t\t\tThe State pattern is applicable to many problems. All the problems that can be solved using state machines are good use cases for using the State pattern. An example we have already seen is the process model for an operating/embedded system.\n\t\t\tProgramming language compiler implementation is another good example. Lexical and syntactic analysis can use states to build abstract syntax trees.\n\t\t\tEvent-driven systems are yet another example. In an event-driven system, the transition from one state to another triggers an event/message. Many computer games use this technique. For example, a monster might move from the guard state to the attack state when the main hero approaches it.\n\t\t\tTo quote Thomas Jaeger, in his article, *The State Design Pattern vs. State* *Machine* ([https://thomasjaeger.wordpress.com/2012/12/13/the-state-design-pattern-vs-state-machine-2/](https://thomasjaeger.wordpress.com/2012/12/13/the-state-design-pattern-vs-state-machine-2/)):\n\t\t\t*The state design pattern allows for full encapsulation of an unlimited number of states on a context for easy maintenance* *and flexibility.*\n\t\t\tImplementing the State pattern\n\t\t\tLet’s write code that demonstrates how to create a state machine based on the state diagram shown earlier in this chapter. Our state machine should cover the different states of a process and the transitions between them.\n\t\t\tThe State design pattern is usually implemented using a parent `State` class that contains the common functionality of all the states, and several concrete classes derived from `State`, where each derived class contains only the state-specific required functionality. The State pattern focuses on implementing a state machine. The core parts of a state machine are the states and transitions between the states. It doesn’t matter how those parts are implemented.\n\t\t\tTo avoid reinventing the wheel, we can make use of existing Python modules that not only help us create state machines but also do it in a Pythonic way. A module that I find very useful is `state_machine`.\n\t\t\tThe `state_machine` module is simple enough that no special introduction is required. We will cover most aspects of it while going through the code of the example.\n\t\t\tLet’s start with the `Process` class. Each created process has its own state machine. The first step to creating a state machine using the `state_machine` module is to use the `@acts_as_state_machine` decorator. Then, we define the states of our state machine. This is a one-to-one mapping of what we see in the state diagram. The only difference is that we should give a hint about the initial state of the state machine. We do that by setting the initial attribute value to `True`:\n\n```", "```py\n\n\t\t\tNext, we are going to define the transitions. In the `state_machine` module, a transition is an instance of the `Event` class. We define the possible transitions using the `from_states` and `to_state` arguments:\n\n```", "```py\n\n\t\t\tAlso, as you may have noticed that `from_states` can be either a single state or a group of states (tuple).\n\t\t\tEach process has a name. Officially, a process needs to have much more information to be useful (for example, ID, priority, status, and so forth) but let’s keep it simple to focus on the pattern:\n\n```", "```py\n\n\t\t\tTransitions are not very useful if nothing happens when they occur. The `state_machine` module provides us with the `@before` and `@after` decorators that can be used to execute actions before or after a transition occurs, respectively. You can imagine updating some objects within the system or sending an email or a notification to someone. For this example, the actions are limited to printing information about the state change of the process, as follows:\n\n```", "```py\n\n\t\t\tNext, we need the `transition()` function, which accepts three arguments:\n\n\t\t\t\t*   `process`, which is an instance of `Process`\n\t\t\t\t*   `event`, which is an instance of `Event` (wait, run, terminate, and so forth)\n\t\t\t\t*   `event_name`, which is the name of the event\n\n\t\t\tThe name of the event is printed if something goes wrong when trying to execute `event`. Here is the code for the function:\n\n```", "```py\n\n\t\t\tThe `state_info()` function shows some basic information about the current (active) state of the process:\n\n```", "```py\n\n\t\t\tAt the beginning of the `main()` function, we define some string constants, which are passed as `event_name`:\n\n```", "```py\n\n\t\t\tNext, we create two `Process` instances and display information about their initial state:\n\n```", "```py\n\n\t\t\tThe rest of the function experiments with different transitions. Recall the state diagram we covered in this chapter. The allowed transitions should be with respect to the state diagram. For example, it should be possible to switch from a running state to a blocked state, but it shouldn’t be possible to switch from a blocked state to a running state:\n\n```", "```py\n\n\t\t\tHere is the recapitulation of the full implementation example (the `ch05/state.py` file):\n\n\t\t\t\t1.  We begin by importing what we need from `state_machine`.\n\t\t\t\t2.  We define the `Process` class with its simple attributes.\n\t\t\t\t3.  We add the `Process` class’s initialization method.\n\t\t\t\t4.  We also need to define, in the `Process` class, the methods to provide its states.\n\t\t\t\t5.  We define the `transition()` function.\n\t\t\t\t6.  Next, we define the `state_info()` function.\n\t\t\t\t7.  Finally, we add the main function of the program.\n\n\t\t\tHere’s what we get when executing the Python `ch05/state.py` command:\n\n```", "```py\n\n\t\t\tIndeed, the output shows that illegal transitions such as created → terminated and blocked → terminated fail gracefully. We don’t want the application to crash when an illegal transition is requested, and this is handled properly by the except block.\n\t\t\tNotice how using a good module such as `state_machine` eliminates conditional logic. There’s no need to use long and error-prone `if…else` statements that check for each and every state transition and react to them.\n\t\t\tTo get a better feeling for the state pattern and state machines, I strongly recommend you implement your own example. This can be anything: a simple video game (you can use state machines to handle the states of the main hero and the enemies), an elevator, a parser, or any other system that can be modeled using state machines.\n\t\t\tThe Interpreter pattern\n\t\t\tOften, we need to create a **domain-specific language** (**DSL**). A DSL is a computer language of limited expressiveness targeting a particular domain. DSLs are used for different things, such as combat simulation, billing, visualization, configuration, and communication protocols. DSLs are divided into internal DSLs and external DSLs.\n\t\t\tInternal DSLs are built on top of a host programming language. An example of an internal DSL is a language that solves linear equations using Python. The advantages of using an internal DSL are that we don’t have to worry about creating, compiling, and parsing grammar because these are already taken care of by the host language. The disadvantage is that we are constrained by the features of the host language. It is very challenging to create an expressive, concise, and fluent internal DSL if the host language does not have these features.\n\t\t\tExternal DSLs do not depend on host languages. The creator of the DSL can decide all aspects of the language (grammar, syntax, and so forth). They are also responsible for creating a parser and compiler for it.\n\t\t\tThe Interpreter pattern is related only to internal DSLs. Therefore, the goal is to create a simple but useful language using the features provided by the host programming language, which in this case is Python. Note that Interpreter does not address parsing at all. It assumes that we already have the parsed data in some convenient form. This can be an **abstract syntax tree** (**AST**) or any other handy data structure [*Gang of Four-95*, page 276].\n\t\t\tReal-world examples\n\t\t\tA musician is an example of the Interpreter pattern. Musical notation represents the pitch and duration of a sound graphically. The musician can reproduce a sound precisely based on its notation. In a sense, musical notation is the language of music, and the musician is the interpreter of that language.\n\t\t\tWe can also cite software examples:\n\n\t\t\t\t*   In the C++ world, `boost::spirit` is considered an internal DSL for implementing parsers.\n\t\t\t\t*   An example in Python is PyT, an internal DSL used to generate XHTML/HTML. PyT focuses on performance and claims to have comparable speed with Jinja2\\. Of course, we should not assume that the Interpreter pattern is necessarily used in PyT. However, since it is an internal DSL, the Interpreter is a very good candidate for it.\n\n\t\t\tUse cases for the Interpreter pattern\n\t\t\tThe Interpreter pattern is used when we want to offer a simple language to domain experts and advanced users to solve their problems. The first thing we should stress is that the Interpreter pattern should only be used to implement simple languages. If the language has the requirements of an external DSL, there are better tools to create languages from scratch (Yacc and Lex, Bison, ANTLR, and so on).\n\t\t\tOur goal is to offer the right programming abstractions to the specialist, who is often not a programmer, to make them productive. Ideally, they shouldn’t know advanced Python to use our DSL, but knowing even a little bit of Python is a plus since that’s what we eventually get at the end. Advanced Python concepts should not be a requirement. Moreover, the performance of the DSL is usually not an important concern. The focus is on offering a language that hides the peculiarities of the host language and offers a more human-readable syntax. Admittedly, Python is already a very readable language with far less peculiar syntax than many other programming languages.\n\t\t\tImplementing the Interpreter pattern\n\t\t\tLet’s create an internal DSL to control a smart house. This example fits well into the **internet of things** (**IoT**) era, which is getting more and more attention nowadays. The user can control their home using a very simple event notation. An event has the form of command -> receiver -> arguments. The arguments part is optional.\n\t\t\tNot all events require arguments. An example of an event that does not require any arguments is shown here:\n\n```", "```py\n\n\t\t\tAn example of an event that requires arguments is shown here:\n\n```", "```py\n\n\t\t\tThe `->` symbol is used to mark the end of one part of an event and state the beginning of the next one. There are many ways to implement an internal DSL. We can use plain old regular expressions, string processing, a combination of operator overloading, and metaprogramming, or a library/tool that can do the hard work for us. Although, officially, the Interpreter pattern does not address parsing, I feel that a practical example needs to cover parsing as well. For this reason, I decided to use a tool to take care of the parsing part. The tool is called pyparsing and, to find out more about it, check out the mini-book *Getting Started with Pyparsing* by Paul McGuire ([https://www.oreilly.com/library/view/getting-started-with/9780596514235/](https://www.oreilly.com/library/view/getting-started-with/9780596514235/)).\n\t\t\tBefore getting into coding, it is a good practice to define a simple grammar for our language. We can define the grammar using the **Backus-Naur Form** (**BNF**) notation:\n\n```", "```py\n\n\t\t\tWhat the grammar basically tells us is that an event has the form of command -> receiver -> arguments, and that commands, receivers, and arguments have the same form: a group of one or more alphanumeric characters. If you are wondering about the necessity of the numeric part, it is included to allow us to pass arguments, such as three degrees at the increase -> boiler temperature -> 3 degrees command.\n\t\t\tNow that we have defined the grammar, we can move on to converting it to actual code. Here’s what the code looks like:\n\n```", "```py\n\n\t\t\tThe basic difference between the code and grammar definition is that the code needs to be written in the bottom-up approach. For instance, we cannot use a word without first assigning it a value. `Suppress` is used to state that we want the `->` symbol to be skipped from the parsed results.\n\t\t\tThe full code of the final implementation example (see the `ch05/interpreter/interpreter.py` file) uses many placeholder classes, but to keep you focused, I will first show a minimal version featuring only one class. Let’s look at the `Boiler` class. A boiler has a default temperature of 83° Celsius. There are also two methods to increase and decrease the current temperature:\n\n```", "```py\n\n\t\t\tThe next step is to add the grammar, which we already covered. We will also create a `boiler` instance and print its default state:\n\n```", "```py\n\n\t\t\tThe simplest way to retrieve the parsed output of pyparsing is by using the `parseString()` method. The result is a `ParseResults` instance, which is a parse tree that can be treated as a nested list. For example, executing `print(event.parseStri'g('increase -> boiler temperature -> 3 degr'es'))` would give‘`[['incre'se']' ['boi'er', 'temperat're']' ''3', 'degr'es']]` as a result.\n\t\t\tSo, in this case, we know that the first sublist is the *command* (increase), the second sublist is the *receiver* (boiler temperature), and the third sublist is the *argument* (3°). We can unpack the `ParseResults` instance, which gives us direct access to these three parts of the event. Having direct access means that we can match patterns to find out which method should be executed:\n\n```", "```py\n\n\t\t\tExecuting the preceding code snippet (using `python ch05/interpreter/boiler.py`) gives the following output:\n\n```", "```py\nopening the gate\nclosing the garage\nturning on the air condition\nturning off the heating\nincreasing the boiler's temperature by 5 degrees\ntests tuple. However, the user wants to be able to activate events using an interactive prompt. Do not forget to check how sensitive pyparsing is regarding spaces, tabs, or unexpected input. For example, what happens if the user types turn off -> heating 37?\n\t\t\tThe Strategy pattern\n\t\t\tSeveral solutions often exist for the same problem. Consider the task of sorting, which involves arranging the elements of a list in a particular sequence. For example, a variety of sorting algorithms are available for the task of sorting. Generally, no single algorithm outperforms all others in every situation.\n\t\t\tSelecting a sorting algorithm depends on various factors, tailored to the specifics of each case. Some key considerations include the following:\n\n\t\t\t\t*   **The number of elements to be sorted, known as the input size**: While most sorting algorithms perform adequately with a small input size, only a select few maintain efficiency with larger datasets.\n\t\t\t\t*   **The best/average/worst time complexity of the algorithm**: Time complexity is (roughly) the amount of time the algorithm takes to complete, excluding coefficients and lower-order terms. This is often the most usual criterion to pick an algorithm, although it is not always sufficient.\n\t\t\t\t*   **The space complexity of the algorithm**: Space complexity is (again roughly) the amount of physical memory needed to fully execute an algorithm. This is very important when we are working with big data or embedded systems, which usually have limited memory.\n\t\t\t\t*   **Stability of the algorithm**: An algorithm is considered stable when it maintains the relative order of elements with equal values after it is executed.\n\t\t\t\t*   **Code complexity of the algorithm**: If two algorithms have the same time/space complexity and are both stable, it is important to know which algorithm is easier to code and maintain.\n\n\t\t\tOther factors might also influence the choice of a sorting algorithm. The key consideration is whether a single algorithm must be applied universally. The answer is, unsurprisingly, no. It is more practical to have access to various sorting algorithms and choose the most suitable one for a given situation, based on the criteria. That’s what the Strategy pattern is about.\n\t\t\tThe Strategy pattern promotes using multiple algorithms to solve a problem. Its killer feature is that it makes it possible to switch algorithms at runtime transparently (the client code is unaware of the change). So, if you have two algorithms and you know that one works better with small input sizes, while the other works better with large input sizes, you can use Strategy to decide which algorithm to use based on the input data at runtime.\n\t\t\tReal-world examples\n\t\t\tReaching an airport to catch a flight is a good real-life Strategy example:\n\n\t\t\t\t*   If we want to save money and we leave early, we can go by bus/train\n\t\t\t\t*   If we don’t mind paying for a parking place and have our own car, we can go by car\n\t\t\t\t*   If we don’t have a car but we are in a hurry, we can take a taxi\n\n\t\t\tThere are trade-offs between cost, time, convenience, and so forth.\n\t\t\tIn software, Python’s `sorted()` and `list.sort()` functions are examples of the Strategy pattern. Both functions accept a named parameter key, which is basically the name of the function that implements a sorting strategy (*Python 3 Patterns, Recipes, and Idioms, by Bruce Eckel & Friends*, page 202).\n\t\t\tUse cases for the Strategy pattern\n\t\t\tStrategy is a very generic design pattern with many use cases. In general, whenever we want to be able to apply different algorithms dynamically and transparently, Strategy is the way to go. By different algorithms, I mean different implementations of the same algorithm. This means that the result should be the same, but each implementation has a different performance and code complexity (as an example, think of sequential search versus binary search).\n\t\t\tApart from its usage for sorting algorithms as we mentioned, the Strategy pattern is used to create different formatting representations, either to achieve portability (for example, line-breaking differences between platforms) or dynamically change the representation of data.\n\t\t\tImplementing the Strategy pattern\n\t\t\tThere is not much to be said about implementing the Strategy pattern. In languages where functions are not first-class citizens, each Strategy should be implemented in a different class. In Python, functions are objects (we can use variables to reference and manipulate them) and this simplifies the implementation of Strategy.\n\t\t\tAssume that we are asked to implement an algorithm to check whether all characters in a string are unique. For example, the algorithm should return true if we enter the dream string because none of the characters are repeated. If we enter the pizza string, it should return false because the letter “z” exists two times. Note that the repeated characters do not need to be consecutive, and the string does not need to be a valid word. The algorithm should also return false for the 1r2a3ae string because the letter “a” appears twice.\n\t\t\tAfter thinking about the problem carefully, we come up with an implementation that sorts the string and compares all characters pair by pair. First, we implement the `pairs()` function, which returns all neighbors pairs of a sequence, `seq`:\n\n```", "```py\n\n\t\t\tNext, we implement the `allUniqueSort()` function, which accepts a string, `s`, and returns `True` if all characters in the string are unique; otherwise, it returns `False`. To demonstrate the Strategy pattern, we will simplify by assuming that this algorithm fails to scale. We assume that it works fine for strings that are up to five characters. For longer strings, we simulate a slowdown by inserting a sleep statement:\n\n```", "```py\n\n\t\t\tWe are not happy with the performance of `allUniqueSort()`, and we are trying to think of ways to improve it. After some time, we come up with a new algorithm, `allUniqueSet()`, that eliminates the need to sort. In this case, we use a set. If the character in check has already been inserted in the set, it means that not all characters in the string are unique:\n\n```", "```py\n\n\t\t\tUnfortunately, while `allUniqueSet()` has no scaling problems, for some strange reason, it performs worse than `allUniqueSort()` when checking short strings. What can we do in this case? Well, we can keep both algorithms and use the one that fits best, depending on the length of the string that we want to check.\n\t\t\tThe `allUnique()` function accepts an input string, `s`, and a strategy function, `strategy`, which, in this case, is one of `allUniqueSort()` and `allUniqueSet()`. The `allUnique()` function executes the input strategy and returns its result to the caller.\n\t\t\tThen, the `main()` function lets the user perform the following actions:\n\n\t\t\t\t*   Enter the word to be checked for character uniqueness\n\t\t\t\t*   Choose the pattern that will be used\n\n\t\t\tIt also does some basic error handling and gives the ability to the user to quit gracefully:\n\n```", "```py\n\n\t\t\tHere’s a summary of the complete code for our implementation example (the `ch05/strategy.py` file):\n\n\t\t\t\t1.  We import the `time` module.\n\t\t\t\t2.  We define the `pairs()` function.\n\t\t\t\t3.  We define the values for the `SLOW`, `LIMIT`, and `WARNING` constants.\n\t\t\t\t4.  We define the function for the first algorithm, `allUniqueSort()`.\n\t\t\t\t5.  We define the function for the second algorithm, `allUniqueSet()`.\n\t\t\t\t6.  Next, we define the `allUnique()` function that helps call a chosen algorithm by passing the corresponding strategy function.\n\t\t\t\t7.  Finally, we add the `main()` function.\n\n\t\t\tLet’s see the output of a sample execution using the `python` `ch05/strategy.py` command:\n\n```", "```py\nclass Quote:\n    def __init__(self, text, author):\n        self.text = text\n        self.author = author\n    def save_state(self):\n        current_state = pickle.dumps(self.__dict__)\n        return current_state\n```", "```py\n    def restore_state(self, memento):\n        previous_state = pickle.loads(memento)\n        self.__dict__.clear()\n        self.__dict__.update(previous_state)\n```", "```py\n    def __str__(self):\n        return f\"{self.text}\\n- By {self.author}.\"\n```", "```py\ndef main():\n    print(\"** Quote 1 **\")\n    q1 = Quote(\n        \"A room without books is like a body without a soul.\",\n        \"Unknown author\",\n    )\n    print(f\"\\nOriginal version:\\n{q1}\")\n    q1_mem = q1.save_state()\n    # Now, we found the author's name\n    q1.author = \"Marcus Tullius Cicero\"\n    print(f\"\\nWe found the author, and did an updated:\\n{q1}\")\n    # Restoring previous state (Undo)\n    q1.restore_state(q1_mem)\n    print(f\"\\nWe had to restore the previous version:\\n{q1}\")\n    print()\n    print(\"** Quote 2 **\")\n    text = (\n        \"To be you in a world that is constantly \\n\"\n        \"trying to make you be something else is \\n\"\n        \"the greatest accomplishment.\"\n    )\n    q2 = Quote(\n        text,\n        \"Ralph Waldo Emerson\",\n    )\n    print(f\"\\nOriginal version:\\n{q2}\")\n    _ = q2.save_state()\n    # changes to the text\n    q2.text = (\n        \"To be yourself in a world that is constantly \\n\"\n        \"trying to make you something else is the greatest \\n\"\n        \"accomplishment.\"\n    )\n    print(f\"\\nWe fixed the text:\\n{q2}\")\n    q2_mem2 = q2.save_state()\n    q2.text = (\n        \"To be yourself when the world is constantly \\n\"\n        \"trying to make you something else is the greatest \\n\"\n        \"accomplishment.\"\n    )\n    print(f\"\\nWe fixed the text again:\\n{q2}\")\n    # Restoring previous state (Undo)\n    q2.restore_state(q2_mem2)\n    print(f\"\\nWe restored the 2nd version, the correct one:\\n{q2}\")\n```", "```py\n** Quote 1 **\nOriginal version:\nA room without books is like a body without a soul.\n- By Unknown author.\nWe found the author, and did an updated:\nA room without books is like a body without a soul.\n- By Marcus Tullius Cicero.\nWe had to restore the previous version:\nA room without books is like a body without a soul.\n- By Unknown author.\n** Quote 2 **\nOriginal version:\nTo be you in a world that is constantly\ntrying to make you be something else is\nthe greatest accomplishment.\n- By Ralph Waldo Emerson.\nWe fixed the text:\nTo be yourself in a world that is constantly\ntrying to make you something else is the greatest\naccomplishment.\n- By Ralph Waldo Emerson.\nWe fixed the text again:\nTo be yourself when the world is constantly\ntrying to make you something else is the greatest\naccomplishment.\n- By Ralph Waldo Emerson.\nWe restored the 2nd version, the correct one:\nTo be yourself in a world that is constantly\ntrying to make you something else is the greatest\naccomplishment.\n- By Ralph Waldo Emerson.\nThe output shows the program does what we expected: we can restore a previous state for each of our Quote objects.\n```", "```py\nclass FootballTeamIterator:\n    def __init__(self, members):\n        self.members = members\n        self.index = 0\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.index < len(self.members):\n            val = self.members[self.index]\n            self.index += 1\n            return val\n        else:\n            raise StopIteration()\n```", "```py\nclass FootballTeam:\n    def __init__(self, members):\n        self.members = members\n    def __iter__(self):\n        return FootballTeamIterator(self.members)\n```", "```py\ndef main():\n    members = [f\"player{str(x)}\" for x in range(1, 23)]\n    members = members + [\"coach1\", \"coach2\", \"coach3\"]\n    team = FootballTeam(members)\n    team_it = iter(team)\n    try:\n        while True:\n            print(next(team_it))\n    except StopIteration:\n        print(\"(End)\")\n```", "```py\nplayer1\nplayer2\nplayer3\nplayer4\nplayer5\n...\nplayer22\ncoach1\ncoach2\ncoach3\n(End) string instead.\n\t\t\tThe Template pattern\n\t\t\tA key ingredient in writing good code is avoiding redundancy. In OOP, methods and functions are important tools that we can use to avoid writing redundant code.\n\t\t\tRemember the `sorted()` example we saw when discussing the Strategy pattern. That function is generic enough that it can be used to sort more than one data structure (lists, tuples, and named tuples) using arbitrary keys. That’s the definition of a good function.\n\t\t\tFunctions such as `sorted()` demonstrate the ideal case. However, we cannot always write 100% generic code.\n\t\t\tIn the process of writing code that handles algorithms in the real world, we often end up writing redundant code. That’s the problem solved by the Template design pattern. This pattern focuses on eliminating code redundancy. The idea is that we should be able to redefine certain parts of an algorithm without changing its structure.\n\t\t\tReal-world examples\n\t\t\tThe daily routine of a worker, especially for workers of the same company, is very close to the Template design pattern. All workers follow the same routine, but specific parts of the routine are very different.\n\t\t\tIn software, Python uses the Template pattern in the `cmd` module, which is used to build line-oriented command interpreters. Specifically, `cmd.Cmd.cmdloop()` implements an algorithm that reads input commands continuously and dispatches them to action methods. What is done before the loop, after the loop, and at the command parsing part is always the same. This is also called the **invariant** part of an algorithm. The elements that change are the actual action methods (the variant part).\n\t\t\tUse cases for the Template pattern\n\t\t\tThe Template design pattern focuses on eliminating code repetition. If we notice that there is repeatable code in algorithms that have structural similarities, we can keep the invariant (common) parts of the algorithms in a Template method/function and move the variant (different) parts in action/hook methods/functions.\n\t\t\tPagination is a good use case to use Template. A pagination algorithm can be split into an abstract (invariant) part and a concrete (variant) part. The invariant part takes care of things such as the maximum number of lines/pages. The variant part contains functionality to show the header and footer of a specific page that is paginated.\n\t\t\tAll application frameworks make use of some form of the Template pattern. When we use a framework to create a graphical application, we usually inherit from a class and implement our custom behavior. However, before this, a Template method is usually called, which implements the part of the application that is always the same, which is drawing the screen, handling the event loop, resizing and centralizing the window, and so on (*Python 3 Patterns, Recipes and Idioms, by Bruce Eckel & Friends*, page 133).\n\t\t\tImplementing the Template pattern\n\t\t\tIn this example, we will implement a banner generator. The idea is rather simple. We want to send some text to a function, and the function should generate a banner containing the text. Banners have some sort of style, for example, dots or dashes surrounding the text. The banner generator has a default style, but we should be able to provide our own style.\n\t\t\tThe `generate_banner()` function is our Template function. It accepts, as an input, the text (`msg`) that we want our banner to contain, and the style (`style`) that we want to use. The `generate_banner()` function wraps the styled text with a simple header and footer. The header and footer can be much more complex, but nothing forbids us from calling functions that can do the header and footer generations instead of just printing simple strings:\n\n```", "```py\n\n\t\t\tThe `dots_style()` function simply capitalizes `msg` and prints 10 dots before and after it:\n\n```", "```py\n\n\t\t\tAnother style that is supported by the generator is `admire_style()`. This style shows the text in uppercase and puts an exclamation mark between each character of the text:\n\n```", "```py\n\n\t\t\tThe next style is by far my favorite. The `cow_style()` style executes the `milk_random_cow()` method of `cowpy`, which is used to generate a random ASCII art character every time `cow_style()` is executed. Here is the `cow_style()` function:\n\n```", "```py\n\n\t\t\tThe `main()` function sends the `\"happy coding\"` text to the banner and prints it to the standard output using all the available styles:\n\n```", "```py\n\n\t\t\tHere is the recap of the full code of the example (the `ch05/template.py` file):\n\n\t\t\t\t1.  We import the `cow` function from `cowpy`.\n\t\t\t\t2.  We define the `generate_banner()` function.\n\t\t\t\t3.  We define the `dots_style()` function.\n\t\t\t\t4.  Next, we define the `admire_style()` and `cow_style()` functions.\n\t\t\t\t5.  We finish with the main function and the snippet to call it.\n\n\t\t\tLet’s look at a sample output by executing `python ch05/template.py` (note that your `cow_style()` output might be different due to the randomness of `cowpy`):\n\t\t\t![Figure 5.3 – Sample art output of the ﻿ch05/template.py program](img/B21896_05_03.jpg)\n\n\t\t\tFigure 5.3 – Sample art output of the ch05/template.py program\n\t\t\tDo you like the art generated by `cowpy`? I certainly do. As an exercise, you can create your own style and add it to the banner generator.\n\t\t\tAnother good exercise is to try implementing your own *Template* example. Find some existing redundant code that you wrote and see whether this pattern is applicable.\n\t\t\tOther behavioral design patterns\n\t\t\tWhat about the other behavioral design patterns from the Gang of Four’s catalog? We also have the **Mediator pattern** and the **Visitor pattern**:\n\n\t\t\t\t*   The Mediator pattern promotes loose coupling between objects by encapsulating how they interact and communicate with each other. In this pattern, objects don’t communicate directly with each other; instead, they communicate through a mediator object. This mediator object acts as a central hub that coordinates communication between the objects. The Mediator pattern stands out as a solution for promoting loose coupling and managing complex interactions between objects.\n\t\t\t\t*   For complex use cases, the Visitor pattern provides a solution for separating algorithms from the objects on which they operate. By allowing new operations to be defined without modifying the classes of the elements on which they operate, the Visitor pattern promotes flexibility and extensibility in object-oriented systems.\n\n\t\t\tWe are not going to discuss these two patterns, since they are not commonly used by Python developers. Python offers built-in features and libraries that can help achieve loose coupling and/or extensibility goals without the need to implement these patterns. For example, one can use event-driven programming with a library such as `asyncio` instead of communication between objects through a mediator object. Additionally, using functions as first-class citizens, decorators, or context managers can provide ways to encapsulate algorithms and operations without the need for explicit visitor objects.\n\t\t\tSummary\n\t\t\tIn this chapter, we discussed the behavioral design patterns.\n\t\t\tFirst, we covered the Chain of Responsibility pattern, which simplifies the management of complex processing flows, making it a valuable tool for enhancing flexibility and maintainability in software design.\n\t\t\tSecond, we went over the Command pattern, which encapsulates a request as an object, thereby allowing us to parameterize clients with queues, requests, and operations. It also allows us to support undoable operations. Although the most advertised feature of command by far is undo, it has more uses. In general, any operation that can be executed at the user’s will at runtime is a good candidate for using the Command pattern.\n\t\t\tWe looked at the Observer pattern, which helps with the separation of concerns, increasing decoupling between the publisher and subscribers. We have seen that observers are loosely coupled with the subject and can be added or removed dynamically.\n\t\t\tThen, we went over the State pattern, which is an implementation of one or more state machines used to solve a particular software engineering problem. A state machine can have only one active state at any point in time. A transition is a switch from the current state to a new state. It is normal to execute one or more actions before or after a transition occurs. State machines can be represented visually using state diagrams. State machines are used to solve many computational and non-computational problems. We saw how to implement a state machine for a computer system process using the `state_machine` module. The `state_machine` module simplifies the creation of a state machine and the definition of actions before/after transitions.\n\t\t\tAfterward, we looked at the Interpreter pattern, which is used to offer a programming-like framework to advanced users and domain experts, without exposing the complexities of a programming language. This is achieved by implementing a DSL, a computer language that has limited expressiveness and targets a specific domain. The interpreter is related to what are called internal DSLs. Although parsing is generally not addressed by the Interpreter pattern, as an implementation example, we used pyparsing to create a DSL that controls a smart house and saw that using a good parsing tool makes interpreting the results using pattern matching simple.\n\t\t\tThen, we looked at the Strategy design pattern, which is generally used when we want to be able to use multiple solutions for the same problem, transparently. There is no perfect algorithm for all input data and all cases, and by using Strategy, we can dynamically decide which algorithm to use in each case. We saw how Python, with its first-class functions, simplifies the implementation of Strategy by implementing two different algorithms that check whether all of the characters in a word are unique.\n\t\t\tNext, we looked at the Memento pattern, which is used to store the state of an object when needed. Memento provides an efficient solution when implementing some sort of undo capability for your users. Another usage is the implementation of a UI dialog with OK/Cancel buttons, where, if the user chooses to cancel, we will restore the initial state of the object. We used an example to get a feel for how Memento, in a simplified form and using the `pickle` module from the standard library, can be used in an implementation where we want to be able to restore previous states of data objects.\n\t\t\tWe then looked at the Iterator pattern, which gives a nice and efficient way to iterate through sequences and collections of objects. In real life, whenever you have a collection of things and you are getting to those things one by one, you are using a form of the Iterator pattern. In Python, Iterator is a language feature. We can use it immediately on built-in containers such as lists and dictionaries, and we can define new iterable and iterator classes, to solve our problem, by using the Python iterator protocol. We saw that with an example of implementing a football team.\n\t\t\tThen, we saw how we can use the Template pattern to eliminate redundant code when implementing algorithms with structural similarities. We saw how the daily routine of a worker resembles the Template pattern. We also mentioned two examples of how Python uses Template in its libraries. General use cases of when to use Template were also mentioned. We concluded by implementing a banner generator, which uses a Template function to implement custom text styles.\n\t\t\tThere are other structural design patterns: Mediator and Visitor. They are not commonly used by Python developers; therefore, we have not discussed them.\n\t\t\tIn the next chapter, we will explore architectural design patterns, which are patterns that help in solving common architectural problems.\n\n```", "```py\n\n```", "```py\n\n```"]