<html><head></head><body><div><div><h1 id="_idParaDest-190"><a id="_idTextAnchor194"/><a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>: Recordsets – Working with Model Data</h1>
			<p>In the previous chapters, we gave an overview of model creation and loading data into models. Now that we have a data model and some data to work with, it's time to learn more about how to programmatically interact with it.</p>
			<p>A business application needs business logic to compute data, perform validations, or automate operations. The <strong class="bold">Odoo</strong> framework API provides the tools for a developer to implement this business logic. Most of the time, this means querying, transforming, and writing data.</p>
			<p>Odoo implements an<strong class="bold"> Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) layer on top of the lower level database. The ORM objects provide the<strong class="bold"> Application Programming Interface</strong> (<strong class="bold">API</strong>) to be used to interact with the data. This API provides an execution environment and the creation of <strong class="bold">recordsets</strong>, that are objects  used to work the data stored in the database.</p>
			<p>This chapter explains how to use the execution environment and recordsets so that you have all the tools needed to implement the business processes.</p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Using the shell command to interactively explore the ORM API</li>
				<li>Understanding the execution environment and context</li>
				<li>Querying data using recordsets and domains</li>
				<li>Accessing data in recordsets</li>
				<li>Writing to records</li>
				<li>Working with date and time</li>
				<li>Working with recordsets</li>
				<li>Transactions and low-level SQL</li>
			</ul>
			<p>By the end of this chapter, you should be able to use Odoo code to perform all of these actions, and you will also be ready to use these tools to implement your own business processes.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor195"/>Technical requirements</h1>
			<p>The code examples in this chapter will be executed in an interactive shell and do not require any code from the previous chapters. A copy of the code can be found in the <code>ch07/ch07_recorsets_code.py</code> file.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor196"/>Using the shell command</h1>
			<p><code>shell</code> command option. These commands can be executed interactively to better understand how they work.</p>
			<p>To use it, add the <code>shell</code> command when starting Odoo, plus any Odoo options that we would usually use when starting Odoo:</p>
			<pre>(env15) $ odoo shell -c library.conf</pre>
			<p>This will initiate the usual server startup sequence in the terminal, but instead of launching an HTTP server listening for requests, it will start a Python prompt waiting for input.</p>
			<p>This interactive command interface simulates the environment found inside a <code>class</code> method, running under the <code>OdooBot</code> superuser. The <code>self</code> variable is available and is set to the <code>OdooBot</code> superuser record object.</p>
			<p>For example, these commands inspect the <code>self</code> recordset:</p>
			<pre>&gt;&gt;&gt; self
res.users(1,)
&gt;&gt;&gt; self._name
'res.users'
&gt;&gt;&gt; self.name
'OdooBot'
&gt;&gt;&gt; self.login
'__system__'</pre>
			<p>The previous <a id="_idIndexMarker511"/>commands print out the following:</p>
			<ul>
				<li>The <code>self</code> variable contains a <code>res.users</code> recordset containing a record with <code>ID 1</code>.</li>
				<li>The recordset model name, inspecting <code>self._name</code>, is <code>res.users</code>, as expected.</li>
				<li>The value for the record <code>name</code> field is <code>OdooBot</code>.</li>
				<li>The value for the record <code>login</code> field is <code>__system__</code>.<p class="callout-heading">Changes in Odoo 12</p><p class="callout">The <code>ID 1</code> superuser changed from <code>admin</code> to the internal <code>__system__</code> user. The <code>admin</code> user is now the <code>ID 2</code> user, and not a superuser, although the Odoo standard apps are careful to automatically grant it full access to them. The main reason for this change was to avoid having users perform day-to-day activities with the superuser account. Doing so is dangerous because this change bypasses all access rules and may cause inconsistent data, such as cross-company relationships. It's now meant to be used only for troubleshooting or very specific cross-company operations.</p></li>
			</ul>
			<p>As with Python, to exit the prompt, press <em class="italic">Ctrl</em> + <em class="italic">D</em>. This will also close the server process and return to the system shell prompt.</p>
			<p>We now know how to start an Odoo shell session. This is important for us to discover the Odoo API features. So, let's use it to explore the execution environment.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>The execution environment</h1>
			<p>Odoo recordsets <a id="_idIndexMarker512"/>operate in an <strong class="bold">environment</strong> context, providing relevant information about the context where the operation was triggered. For example,  the database cursor being used, the current Odoo user, and more.</p>
			<p>Python code running inside a model method has access to the <code>self</code> recordset variable, and the local environment can be accessed with <code>self.env</code>. The server shell environment also provides a <code>self</code> reference in a similar way to what is found inside a method.</p>
			<p>In this section, we will learn about the attributes made available by the execution environment and how to use them.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Environment attributes</h2>
			<p>As we <a id="_idIndexMarker513"/>have seen, <code>self</code> is a recordset. Recordsets carry environment information with them such as the user browsing the data and additional context-related information (for example, the active language and time zone).</p>
			<p>The current environment can be accessed using the <code>env</code> attribute of a recordset, as shown in this example:</p>
			<pre>&gt;&gt;&gt; self.env
&lt;odoo.api.Environment object at 0x7f6882f7df40&gt;</pre>
			<p>The execution environment in <code>self.env</code> has the following attributes available:</p>
			<ul>
				<li>The <code>env.cr</code> attribute is the database cursor being used.</li>
				<li>The <code>env.user</code> attribute is the record for the current user.</li>
				<li>The <code>env.uid</code> attribute is the ID for the session user. It is the same as <code>env.user.id</code>.</li>
				<li>The <code>env.context</code> attribute is an immutable dictionary containing the session context data.</li>
				<li>The <code>env.company</code> attribute is the active company.</li>
				<li>The <code>env.companies</code> attributes are the user's allowed companies.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <code>env.company</code> and <code>env.companies</code> attributes were introduced in Odoo 13. In previous versions, this information was read from the user record by using <code>env.user.company_id</code> and <code>env.user.company_ids</code>.</p></li>
			</ul>
			<p>The <a id="_idIndexMarker514"/>environment also provides access to the registry where all installed models are available. For example, <code>self.env["res.partner"]</code> returns a reference to the <code>partner</code> model. We can then use <code>search()</code> or <code>browse()</code> on it to create recordsets:</p>
			<pre>&gt;&gt;&gt; self.env["res.partner"].search([("display_name", "like", "Azure")])
res.partner(14, 26, 33, 27)</pre>
			<p>In this example, the returned recordset for the <code>res.partner</code> model contains three records, with IDs <code>14</code>, <code>26</code>, <code>33</code>, and <code>27</code>. The recordset is not ordered by ID, as the default order for the corresponding model was used. In the case of the partner model, the default object <code>_order</code> is <code>display_name</code>.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>The environment context</h2>
			<p>The <code>context</code> object is<a id="_idIndexMarker515"/> a dictionary carrying session data that can be used on both the client-side user interface and the server-side ORM and business logic.</p>
			<p>From the client side, it can carry information from one view to the next—such as the ID of the record active on the previous view after following a link or a button—or it can provide default values to be used in the next view.</p>
			<p>On the server side, some recordset field values can depend on the locale settings provided by the context. In particular, the <code>lang</code> key affects the value of the translatable fields.</p>
			<p>Context can also provide signals for server-side code. For example, the <code>active_test</code> key, when set to <code>False</code>, changes the behavior of the ORM <code>search()</code> method so that it does not apply the automatic filter on inactive records, ignoring the <code>active</code> record field.</p>
			<p>An initial context from the web client looks like this:</p>
			<pre>&gt;&gt;&gt; self.env.context
{'lang': 'en_US', 'tz': 'Europe/Brussels'}</pre>
			<p>Here, you can see the <code>lang</code> key with the user language and <code>tz</code> with the time zone information. The content in records might be different depending on the current context:</p>
			<ul>
				<li>Translated fields can have different values depending on the active <code>lang</code> language.</li>
				<li>Datetime fields, when returned to clients, can show different times depending on the active <code>tz</code> timezone.</li>
			</ul>
			<p>When opening a <a id="_idIndexMarker516"/>view from a link or a button in a previous view, the web client will automatically add a few keys to the context, providing information on the record we are navigating from:</p>
			<ul>
				<li><code>active_model</code> is the previous model name.</li>
				<li><code>active_id</code> is the ID of the original record the user was positioned at.</li>
				<li><code>active_ids</code> is a list of the IDs selected in cases where the user is navigating from a list view.</li>
			</ul>
			<p>Wizard assistants frequently use these keys to find the records they are expected to act on.</p>
			<p>The context can be used to set default values and activate default filters on the target web client view by using keys with these specific prefixes:</p>
			<ul>
				<li>The <code>default_</code> prefix added to a field name sets a default value for that field. For example, <code>{'default_user_id': uid}</code> sets the current user as a default value.</li>
				<li>The <code>default_search_</code> prefix added to a filter name will automatically enable that filter. For example, <code>{'default_search_filter_my_tasks': 1}</code> activates the filter with name <code>filter_my_books</code>.</li>
			</ul>
			<p>These prefixes are frequently used in <code>&lt;field context="{...}"&gt;</code> elements.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor200"/>Modifying the recordset execution environment and context</h2>
			<p>The recordset execution context can be modified to take advantage of the behaviors described in the previous section or to add information to be used in methods called on that recordset.</p>
			<p>The environment <a id="_idIndexMarker517"/>and its context can be modified <a id="_idIndexMarker518"/>through the following methods. Each of these returns a new recordset, along with a copy of the original with a modified environment:</p>
			<ul>
				<li>The <code>&lt;recordset&gt;.with_context(&lt;dictionary&gt;)</code> method replaces the context with the one provided in the dictionary.</li>
				<li>The <code>&lt;recordset&gt;.with_context(key=value, ...)</code> method modifies the context by setting the provided attributes on it.</li>
				<li>The <code>&lt;recordset&gt;.sudo([flag=True])</code> method enables or disables the superuser mode, allowing it to bypass security rules. The context user is kept the same.</li>
				<li>The <code>&lt;recordset&gt;.with_user(&lt;user&gt;)</code> method modifies the user to the one provided, which is either a user record or an ID number.</li>
				<li>The <code>&lt;recordset&gt;.with_company(&lt;company&gt;)</code> method modifies the company to the one provided, which is either a company record or an ID number.</li>
				<li>The <code>&lt;recordset&gt;.with_env(&lt;env&gt;)</code> method modifies the full environment of the recordset to the one provided.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <code>with_user()</code> and <code>with_company()</code> methods were introduced in Odoo 13. To switch users, previous versions used the <code>sudo([&lt;user&gt;])</code> method, which could be provided to a specific user to switch to the superuser context. To switch companies, previous versions used <code>with_context(force=company=&lt;id&gt;)</code>, setting a <code>context</code> key that was checked in the relevant business logic.</p></li>
			</ul>
			<p>Additionally, the environment object provides the <code>env.ref()</code> function, taking a string with an external identifier and returning the corresponding record, as shown in the following example:</p>
			<pre>&gt;&gt;&gt; self.env.ref('base.user_root')
res.users(1,)</pre>
			<p>If the external identifier does not exist, a <code>ValueError</code> exception is raised.</p>
			<p>We learned more about the execution environments when running Python code in the Odoo server. The next step is to interact with data. In this case, the first thing to learn is how to query data and create recordsets, which is discussed in the next section.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor201"/>Querying data with recordsets and domains</h1>
			<p>Odoo business logic will need to read data from the database to perform actions based on it. This is done through <em class="italic">recordsets</em>, which query the raw data and expose it as Python objects we can manipulate.</p>
			<p>Odoo <a id="_idIndexMarker519"/>Python will usually be running in a class method, where <code>self</code> represents the recordset to work with. In some cases, we need to create recordsets for <a id="_idIndexMarker520"/>other models. For that, we should get a<a id="_idIndexMarker521"/> reference to the models and then query it to create the recordset.</p>
			<p>The environment object, usually accessible as <code>self.env</code>, holds references to all the models available, and these can be accessed using dictionary-like syntax. For example, to get a reference to the <code>partner</code> model, use <code>self.env['res.partner']</code> or <code>self.env.get('res.partner')</code>. This model reference can then be used to create recordsets, as we will see next.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor202"/>Creating recordsets</h2>
			<p>The <code>search()</code> method <a id="_idIndexMarker522"/>takes a domain expression and returns a recordset with the records matching those conditions. For example, <code>[('name', 'like', 'Azure')]</code> will return all records with a <code>name</code> field containing <code>Azure</code>.</p>
			<p>If the model has the <code>active</code> special field then by default, only the records with <code>active=True</code> will be considered.</p>
			<p>The following keyword arguments can also be used:</p>
			<ul>
				<li>The <code>order</code> keyword is a string to be used as the <code>ORDER BY</code> clause in the database query. This is usually a comma-separated list of field names. Each field name may be followed by the <code>DESC</code> keyword to indicate a descending order.</li>
				<li>The <code>limit</code> keyword sets a maximum number of records to retrieve.</li>
				<li>The <code>offset</code> keyword ignores the first <code>n</code> results; it can be used with <code>limit</code> to query blocks of records at a time.</li>
			</ul>
			<p>Sometimes, we just need to know the number of records meeting certain conditions. For that, we can use <code>search_count()</code>, which returns the record count instead of a recordset in a more efficient way.</p>
			<p>The <code>browse()</code> method takes a list of IDs or a single ID and returns a recordset with those records. This can be convenient in cases where we already know the IDs of the records we want.</p>
			<p>For example, to<a id="_idIndexMarker523"/> get all the partner records containing <code>Lumber</code> in the display name, use the following <code>search()</code> call:</p>
			<pre>&gt;&gt;&gt; self.env['res.partner'].search([('display_name', 'like', 'Lumber')])
res.partner(15, 34)</pre>
			<p>In the case the IDs to query are known, use a <code>browse()</code> call, as in the following example:</p>
			<pre>&gt;&gt;&gt; self.env['res.partner'].browse([15, 34]) 
res.partner(15, 34)</pre>
			<p>Most of the time the IDs are not known, so the <code>search()</code> method is used more often than <code>browse()</code>.</p>
			<p>To make good use of <code>search()</code>, a good understanding of the domain filter syntax is needed. So, we will focus on this in the next section.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Domain expressions</h2>
			<p>A <code>WHERE</code> expressions that are used to query the database. A <code>('&lt;field&gt;', '&lt;operator&gt;', &lt;value&gt;)</code> tuple. For example, the following is a valid domain expression, with a single condition: <code>[('is_done', '=', False)]</code>. A domain expression with no conditions is also allowed. This translates to an empty list (<code>[]</code>) and the result is a query returning all records.</p>
			<p>There are actually two possible evaluation contexts for domains: on the client side, such as in <em class="italic">window actions</em> and web client <em class="italic">views</em>, and on the server side, such as in security <em class="italic">record rules</em> and model method Python code. What can be used in the <code>&lt;field&gt;</code> and <code>&lt;value&gt;</code> elements may depend on the evaluation context.</p>
			<p>Next, we will look at a detailed explanation for each element of a domain condition: <strong class="bold">field</strong>, <strong class="bold">operator</strong>, and <strong class="bold">value</strong>.</p>
			<h3>The field element of a domain condition</h3>
			<p>The first condition element is a<a id="_idIndexMarker526"/> string with the name of the field being filtered. When the domain expression is used on the server side, the field element can use dot-notation to access the values of related models. For example, we could use something like <code>'publisher_id.name'</code>, or even <code>'publisher_id.country_id.name'</code>.</p>
			<p>On the client side, dot-notation is not allowed, and only simple field names can be used.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In cases where a related record value is needed for a client-side domain expression because dot-notation can't be used, the solution is to add to the model a related field by using a <code>related=</code> attribute. This way, the value is accessible as a directly accessible model field.</p>
			<h3>The operator element of a domain condition</h3>
			<p>The second <a id="_idIndexMarker527"/>condition element is the operator to apply on the field being filtered. What follows is a list of the allowed operators:</p>
			<div><div><img src="img/Table_7.1_B16119.jpg" alt="" width="1650" height="1883"/>
				</div>
			</div>
			<p>These operators <a id="_idIndexMarker528"/>are applied to the field provided in the first element, using the value provided in the third element. For example, <code>('shipping_address_id', 'child_of', partner_id)</code> checks the evaluation context for a <code>partner_id</code> variable and reads its value. The database is queried on the <code>shipping_address_id</code> field, selecting the records where that address is a child of the one identified in the <code>partner_id</code> value. </p>
			<h3>The value element of a domain condition</h3>
			<p>The third<a id="_idIndexMarker529"/> element is evaluated as a Python expression. It can use literal values, such as numbers, Booleans, strings, or lists, and can use fields and identifiers available in the evaluation context.</p>
			<p>Record objects are not accepted values. Instead, the corresponding ID values should be used. For example, don't use <code>[('user_id', '=', user)]</code> – instead, use <code>[('user_id', '=', user</code><code>)]</code>.</p>
			<p>For record rules, the evaluation context has the following names available:</p>
			<ul>
				<li><code>user</code>: A record for the current user (equivalent to <code>self.env.user</code>). Use <code>user.id</code> to get the corresponding ID.</li>
				<li><code>company_id</code>: The ID of a record for the active company (equivalent to <code>self.env.company.id</code>).</li>
				<li><code>company_ids</code>: A list of IDs for the allowed companies (equivalent to <code>self.env.companies.ids</code>).</li>
				<li><code>time</code>: The Python time module, exposing date and time functions. The official reference can be found at <a href="https://docs.python.org/3/library/time.html">https://docs.python.org/3/library/time.html</a>.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <code>company_id</code> and <code>company_ids</code> context values are available for record rule evaluation since Odoo 13, and the approach from the previous version, using <code>user.company_id.id</code>, should not be used anymore. For example, the previously frequently used <code>['|', ('company_id', '=', False), ('company_id', 'child_of', [user.company_id.id])]</code> domain should now be written as <code>[('company_id', 'in', company_ids)]</code>.</p></li>
			</ul>
			<h3>Searching on to-many fields</h3>
			<p>When the searched <a id="_idIndexMarker530"/>field is a <em class="italic">to-many</em>, the operator is applied to each of the field values, and the evaluated record is included in the result if any of the field values match the domain condition.</p>
			<p>The <code>=</code> and <code>in</code> operators behave like a <em class="italic">contains</em> operation. They both check if <em class="italic">any</em> of the field values match any of the list of values searched for. Symmetrically, the <code>!=</code> and <code>not in</code> operators check that <em class="italic">none</em> of the field values match any of the list of values searched for.</p>
			<h3>Composing a domain expression with multiple conditions</h3>
			<p>A domain expression<a id="_idIndexMarker531"/> is a list of items and can contain several condition tuples. By default, these conditions will implicitly be combined using the AND logical operator. This means that it will only return records meeting all of the conditions.</p>
			<p>Explicit logic operators<a id="_idIndexMarker532"/> can also be used – for example, the ampersand symbol (<code>&amp;</code>) for AND operations (the default) and the pipe symbol (<code>|</code>) for OR operations. These will operate on the next two items, working in a recursive way. We'll look at this in more detail in a moment.</p>
			<p>For a slightly<a id="_idIndexMarker533"/> more formal definition, a domain expression uses prefix notation, also known as <strong class="bold">Polish notation</strong> (<strong class="bold">PN</strong>), where operators precede operands. The AND and OR operators are binary operators, while NOT is a unary operator.</p>
			<p>The exclamation point (<code>!</code>) represents the NOT operator and it operates on the following item. So, it should be placed before the item to be negated. For example, the <code>['!', ('is_done','=',True)]</code> expression will filter all <em class="italic">not done</em> records.</p>
			<p>Operator items, such as (<code>!</code>) or (<code>|</code>), can be nested, allowing the definition of <code>AND</code>/<code>OR</code>/<code>NOT</code> complex conditions. Let's illustrate this with an example.</p>
			<p>In server-side record rules, we can find domain expressions similar to this one:</p>
			<pre>['|',
    ('message_follower_ids', 'in', [user.partner_id.id]),
    '|',
        ('user_id', '=', user.id),
        ('user_id', '=', False)
]</pre>
			<p>This domain filters all of the records where:</p>
			<p>- the current user is a follower, or</p>
			<p>- the current user is the record's responsible (user_id), or</p>
			<p>- the record has no responsible user set.</p>
			<p>The following<a id="_idIndexMarker534"/> diagram illustrates the abstract syntax tree representation of the previous domain expression example:</p>
			<div><div><img src="img/Figure_7.1_B16119.jpg" alt="Figure 7.1 – A diagram illustrating a composed domain expression&#13;&#10;" width="1209" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A diagram illustrating a composed domain expression</p>
			<p>The first <code>|</code> (<em class="italic">OR</em>) operator acts on the follower's condition plus the result of the next condition. The next condition is again the union of two other conditions  - records where either the user ID is set to the current user, or the user ID is not set.</p>
			<h3>Special domain conditions</h3>
			<p>Some special domain conditions<a id="_idIndexMarker535"/> are also supported for the cases where an <em class="italic">always true</em> or <em class="italic">always false</em> expression is needed.</p>
			<p>The <code>(1, "=", 1)</code> condition represents an <em class="italic">always true</em> expression. It can be used on record rules to give a higher user group access to all records, previously limited by a lower user group. For example, it is used on the <code>User: All Documents</code> group, to override the record access limitation in the inherited <code>User: Own Documents only</code> group. For an example of this, see <code>addons/sales_team/security/sales_team_security.xml</code> in the Odoo source code.</p>
			<p>The <code>(0, "=", 1)</code> condition is also supported and represents an <em class="italic">always false</em> expression.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Grouping by fields and aggregate data</h2>
			<p>Sometimes, we need to group records<a id="_idIndexMarker536"/> by their data field. Odoo can do this using the <code>read_group()</code> method. The method arguments are as follows:</p>
			<ul>
				<li>The <code>domain</code> argument is a list with a domain expression to filter the records to retrieve.</li>
				<li>The <code>fields</code> argument is a list of field names, along with an aggregation function to apply in the format of <code>field:aggr</code>. Aggregation functions are the ones allowed by <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>count</code>, and <code>count_distinct</code>. For example: <code>["subtotal:sum"]</code>.</li>
				<li>The <code>groupby</code> argument is a list with the data field names to group by.</li>
				<li>The <code>limit</code> argument is an optional maximum number of groups to return.</li>
				<li>The <code>offset</code> argument is an optional number of records to skip.</li>
				<li>The <code>orderby</code> argument is an optional string with an <em class="italic">order by</em> clause to apply to the result (similar to what <code>search()</code> supports).</li>
				<li>The <code>lazy</code> argument, if set to <code>True</code>, only groups by the first field, and adds the remaining group of fields to the <code>__context</code> result. This argument defaults to <code>True</code>, so set it to <code>False</code> to have all <em class="italic">group by fields</em> immediately applied.</li>
			</ul>
			<p>Here is an  example grouping partner record by country, and count the number of different states found:</p>
			<pre>&gt;&gt;&gt; self.env["res.partner"].read_group([("display_name", "like", "Azure")], fields=["state_id:count_distinct",], groupby=["country_id"], lazy=False)
[{'__count': 4, 'state_id': 1, 'country_id': (233, &lt;odoo.tools.func.lazy object at 0x7f197b65fc00&gt;), '__domain': ['&amp;', ('country_id', '=', 233), ('display_name', 'like', 'Azure')]}]</pre>
			<p>This returned a <a id="_idIndexMarker537"/>list with a single group result for the <code>233</code> country ID. Running <code>self.env["res.country"].browse(233).name</code>, we can see that the country is <code>United Sates</code>. The <code>__count</code> key shows that there are <code>4</code> partners in the <code>233</code> country ID, and the <code>state_id</code> object shows the <code>count</code> distinct aggregation results: <code>1</code> distinct state is used by these partners.</p>
			<p>We now know how to create recordsets. Next, we will want to read the data in them. In many cases, this is a trivial operation, but for some field types, there are a few details involved that are worth noting. The next section will help us with that.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor205"/>Accessing data in recordsets</h1>
			<p>Once we have a <a id="_idIndexMarker538"/>recordset, we want to inspect the data contained in it. So, in the following sections, we will explore how to access data in recordsets.</p>
			<p>We can get field <a id="_idIndexMarker539"/>values for individual records called <em class="italic">singletons</em>. Relational fields have special properties, and we can use dot-notation to navigate through linked records. Finally, we will discuss some considerations for when we need to handle date and time records and convert them between different formats.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>Accessing individual record data</h2>
			<p>When a<a id="_idIndexMarker540"/> recordset has only one record it is called a <strong class="bold">singleton</strong>. Singletons are still<a id="_idIndexMarker541"/> recordsets and can be used wherever a recordset is expected.</p>
			<p>But unlike multi-element recordsets, singletons can access their fields using dot-notation, as follows:</p>
			<pre>&gt;&gt;&gt; print(self.name)
OdooBot</pre>
			<p>In the next example, we can see that the same <code>self</code> singleton recordset also behaves as a recordset, and we can iterate it. It has only one record, so only one name is printed out:</p>
			<pre>&gt;&gt;&gt; for rec in self: print(rec.name)
...
OdooBot</pre>
			<p>Trying to access field values in recordsets with more than one record will result in an error, so this can be an issue in cases where we are not sure if we are working with a singleton recordset.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Although using dot-notation to access fields won't work on multiple records, it is possible to access them in bulk by mapping the values to a recordset. This is done using <code>mapped()</code>. For example, <code>rset.mapped("name")</code> returns a list with the <code>name</code> values.</p>
			<p>For methods designed to work only with a singleton, we can check this using <code>self.ensure_one()</code> at the beginning. It will raise an error if <code>self</code> is not a singleton.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>ensure_one()</code> function also raises an error if the record is empty. To check if a <code>rset</code> has one or zero records, you can use <code>rset or rset.ensure_one()</code>.</p>
			<p>An empty record is also a singleton. This is convenient because accessing field values will return a <code>None</code> value instead of raising an error. This is also true for relational fields, and accessing related records using dot notation won't raise errors.</p>
			<p>So, in practice, there<a id="_idIndexMarker542"/> is no need to check for an empty recordset before accessing their field values. For example, instead of <code>if record: print(record.name)</code>, we can safely write the simpler <code>print(record.name)</code> method. A default value for an empty value can also be provided by using an <code>or</code> condition: <code>print(record.name</code><code>)</code>.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor207"/>Accessing relational fields</h2>
			<p>As we saw earlier, models can<a id="_idIndexMarker543"/> have relational fields—<strong class="bold">many-to-one</strong>, <strong class="bold">one-to-many</strong>, and <strong class="bold">many-to-many</strong>. These field types have recordsets as values.</p>
			<p>In the case of many-to-one fields, the value can be a singleton or an empty recordset. In both cases, we can directly access their field values. As an example, the following instructions are correct and safe:</p>
			<pre>&gt;&gt;&gt; self.company_id
res.company(1,)
&gt;&gt;&gt; self.company_id.name
'YourCompany'
&gt;&gt;&gt; self.company_id.currency_id
res.currency(1,)
&gt;&gt;&gt; self.company_id.currency_id.name
'EUR'</pre>
			<p>An empty recordset conveniently also behaves like a singleton, and accessing its fields does not return an error but just returns <code>False</code>. Because of this, we can traverse records using dot-notation without worrying about errors from empty values, as shown here:</p>
			<pre>&gt;&gt;&gt; self.company_id.parent_id
res.company()
&gt;&gt;&gt; self.company_id.parent_id.name
False</pre>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor208"/>Accessing date and time values</h2>
			<p>In recordsets, <code>date</code> and <code>datetime</code> values<a id="_idIndexMarker544"/> are represented as native Python objects. For example, when <a id="_idIndexMarker545"/>we look up the last login date for the <code>admin</code> user:</p>
			<pre>&gt;&gt;&gt; self.browse(2).login_date
datetime.datetime(2021, 11, 2, 16, 47, 57, 327756)</pre>
			<p>Since the <code>date</code> and <code>datetime</code> values are Python objects, they have all of the manipulation features available for these objects.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <code>date</code> and <code>datetime</code> field values are now represented as Python objects, unlike previous Odoo versions, where the <code>date</code> and <code>datetime</code> values were represented as text strings. These field type values can still be set using text representations in the same way as previous Odoo versions.</p>
			<p>Dates and times are<a id="_idIndexMarker546"/> stored in the database in a native <code>datetime</code> values seen on recordsets are also in UTC. When presented to the user by the web client, the <code>datetime</code> values are converted into the user's time zone by using the current session's time zone setting that is stored in the context <code>tz</code> key, for example, <code>{'tz': 'Europe/Brussels'}</code>. This conversion is a web client responsibility, as it isn't done by the server.</p>
			<p>For example, an 11:00 AM datetime value entered by a Brussels (UTC+1) user is stored in the database as 10:00 AM UTC, and will be seen by a New York (UTC-4) user as 06:00 AM. The Odoo server log message timestamps use the UTC time and not the local server time.</p>
			<p>The opposite conversion—from the session time zone to UTC—also needs to be done by the web client when sending the user's <code>datetime</code> input back to the server.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that the date and time data stored in the database and handled by the server code is always represented in UTC. Even the server log message timestamps are represented in UTC.</p>
			<p>We have now reviewed the details of how to access record data. However, our application will provide some automation for business processes, so inevitably we will also need to write to recordsets. Let's look at this in detail in the next section.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor209"/>Writing to records</h1>
			<p>We have two different <a id="_idIndexMarker547"/>ways to write to records: using the object-style direct assignment or using the <code>write()</code> method. The <code>write()</code> method is the low-level method in charge of performing write operations, and it is still used directly when using the external API or when loading XML records. The object-style direct assignment was added later into the ORM model. It implements the <strong class="bold">active record</strong> pattern and can be used in Python code logic.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">In Odoo 13, the ORM model introduced a new database writing approach called <code>flush()</code> method is automatically called to perform the corresponding database operations in a single go.</p>
			<p>Next, we will look at both of these methods and their differences.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Using object-style value assignments</h2>
			<p>Recordsets implement the <strong class="bold">active record pattern</strong>. This means that we can assign values to them and these changes<a id="_idIndexMarker549"/> will be made persistent in the database. This is an intuitive and convenient way to manipulate data.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Assigning values to a recordset with more than one record is supported as of Odoo 13. Up to Odoo 12, only writing values to single records was supported, and the <code>write()</code> method had to be used to write to multiple records.</p>
			<p>Here is an example:</p>
			<pre>&gt;&gt;&gt; root = self.env["res.users"].browse(1)
&gt;&gt;&gt; print(root.name) 
System
&gt;&gt;&gt; <strong class="bold">root.name = "Superuser"</strong>
&gt;&gt;&gt; print(root.name) 
Superuser</pre>
			<p>When using the <em class="italic">active record</em> pattern, the value of relational fields can be set by assigning a recordset.</p>
			<p>Date and time fields can be assigned values as either Python native objects or string representations in the Odoo default format:</p>
			<pre>&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; self.date = date(2020, 12, 1)
&gt;&gt;&gt; self.date
datetime.date(2020, 12, 1)
&gt;&gt;&gt; self.date = "2020-12-02"
&gt;&gt;&gt; self.date
datetime.date(2020, 12, 2)</pre>
			<p>Binary fields should be assigned <code>base64</code> encoded values. For example, when having raw binary data read from a file, that value must be converted using <code>base64.b64encode()</code> before being assigned to a field:</p>
			<pre>&gt;&gt;&gt; import base64
&gt;&gt;&gt; blackdot_binary = b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x04\x00\x00\x00\xb5\x1c\x0c\x02\x00\x00\x00\x0bIDATx\xdacd\xf8\x0f\x00\x01\x05\x01\x01'\x18\xe3f\x00\x00\x00\x00IEND\xaeB'\x82"
&gt;&gt;&gt; self.image_1920 = base64.b64encode(blackdot_binary).decode("utf-8")</pre>
			<p>When assigning values on<a id="_idIndexMarker550"/> many-to-one fields, the value assigned must be a single record (that is, a <strong class="bold">singleton recordset</strong>).</p>
			<p>For to-many fields, the value can also be assigned with a recordset, replacing the list of linked records (if any) with a new one. Here, a recordset of any size is allowed.</p>
			<p>To set an empty value on a relational field, set it with <code>None</code> or <code>False</code>:</p>
			<pre>&gt;&gt;&gt; self.child_ids = None
&gt;&gt;&gt; self.child_ids
res.partner()</pre>
			<p>To append or remove a record on the assigned list, use the record manipulation operations.</p>
			<p>For example, imagine a company record also has a related partner record that is used to hold address details. Suppose that we want to add the current user as a company child contact. This can be done with the following:</p>
			<pre>&gt;&gt;&gt; mycompany_partner = self.company_id.partner_id
&gt;&gt;&gt; myaddress = self.partner_id
&gt;&gt;&gt; <strong class="bold">mycompany_partner.child_ids = mycompany_partner.child_ids | myaddress</strong></pre>
			<p>Here, the pipe operator (<code>|</code>) was used to join a record to obtain a larger recordset.</p>
			<p>The compact append and assign operator (<code>|=</code>) could have been used for the same effect:</p>
			<pre>&gt;&gt;&gt; <strong class="bold">mycompany_partner.child_ids |= myaddress</strong></pre>
			<p>More details on record <a id="_idIndexMarker551"/>manipulation operations are given later in this chapter in the <em class="italic">Composing recordsets</em> section.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor211"/>Using the write() method</h2>
			<p>The <code>write()</code> method can<a id="_idIndexMarker552"/> also be used to update data in records. It accepts a dictionary with the field names and values to assign. It can be more convenient to use in some cases, for example, where the dictionary is prepared first, and the assignment is performed later. It is also useful in older versions of Odoo (up to Odoo 12) for cases where direct assignment can't be used.</p>
			<p>The <code>write()</code> method receives a dictionary with the fields and values to assign and updates the recordset with them:</p>
			<pre>&gt;&gt;&gt; Partner = self.env['res.partner']
&gt;&gt;&gt; recs = Partner.search( [("name", "ilike", "Azure")])
&gt;&gt;&gt; recs.write({"comment": "Hello!"})
True</pre>
			<p>Date and time fields can be assigned with values of the corresponding Python objects or by using string text representations, just like with object-style assignments.</p>
			<p>Since Odoo 13, <code>write()</code> can use recordsets to set values on to-one and to-many relational fields, just like with object-style assignments.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">The <code>write()</code> method can use recordsets to assign values on relational fields. Up to Odoo 12, many-to-one fields were set using an ID value, and to-many fields were set using a special syntax, for example, <code>(4, &lt;id&gt;, _)</code> to add a record and <code>(6, 0, [&lt;ids&gt;])</code> to set the full record list. This syntax is discussed in more detail in <a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Importing, Exporting, and Module Data</em>.</p>
			<p>For example, suppose we have two Partner records, <code>address1</code> and <code>address2</code>, and we want to set them on the <code>self.child_ids</code> field.</p>
			<p>Using the <code>write()</code> method, we would use the following:</p>
			<pre>self.write({ 'child_ids': address1 | address2})</pre>
			<p>Another option (needed for versions before Odoo 13) is as follows:</p>
			<pre>self.write({ 'child_ids': [(6, 0, [address1.id, address2.id])]})</pre>
			<p>The <code>write()</code> method <a id="_idIndexMarker553"/>is used to write dates on existing records. But we also need to create and delete records, which we will discuss in the next section.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor212"/>Creating and deleting records</h2>
			<p>The <code>create()</code> and <code>unlink()</code> model methods allow us to create and delete existing records, respectively.</p>
			<p>The <code>create()</code> method<a id="_idIndexMarker554"/> takes <a id="_idIndexMarker555"/>a dictionary with the fields and values for the record to be created, using the same syntax as <code>write()</code>. Default values are automatically applied as expected, as shown in this example:</p>
			<pre>&gt;&gt;&gt; Partner = self.env['res.partner']
&gt;&gt;&gt; new = <strong class="bold">Partner.create({'name': 'ACME', 'is_company': True})</strong>
&gt;&gt;&gt; print(new)
res.partner(59,)</pre>
			<p>The <code>unlink()</code> method<a id="_idIndexMarker556"/> deletes the<a id="_idIndexMarker557"/> records in the recordset, as done in the next example:</p>
			<pre>&gt;&gt;&gt; rec = Partner.search([('name', '=', 'ACME')])
&gt;&gt;&gt; <strong class="bold">rec.unlink()</strong>
2021-11-15 18:40:10,090 3756 INFO library odoo.models.unlink: User #1 deleted mail.message records with IDs: [20]
2021-11-15 18:40:10,146 3756 INFO library odoo.models.unlink: User #1 deleted res.partner records with IDs: [59]
2021-11-15 18:40:10,160 3756 INFO library odoo.models.unlink: User #1 deleted mail.followers records with IDs: [9]
True</pre>
			<p>The <code>unlink()</code> method returns a <code>True</code> value. Also, during the <code>delete</code> operation, it triggers log messages informing<a id="_idIndexMarker558"/> the cascade deletion of related records, such as Chatter messages and followers.</p>
			<p>Another way to create a<a id="_idIndexMarker559"/> record is to duplicate an existing one. The <code>copy()</code> model method<a id="_idIndexMarker560"/> is available for this. It accepts an optional argument with a dictionary, which contains values to override when creating the new record.</p>
			<p>For example, to create a new user from the <code>demo</code> user, we could use the following:</p>
			<pre>&gt;&gt;&gt; demo = self.env.ref("base.user_demo")
&gt;&gt;&gt; new = demo.copy({"name": "John", "login": "john@example.com"})</pre>
			<p>The fields with the <code>copy=False</code> attribute won't be automatically copied. To-many relational fields have this flag disabled by default, so they won't be copied.</p>
			<p>In the previous sections, we have learned how to access data in recordsets and create and write to recordsets. However, there are some field types that deserve more attention. In the next section, we will discuss specific techniques for working with date and time fields.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor213"/>Working with date and time fields</h1>
			<p>In the <em class="italic">Accessing data in recordsets</em> section, we saw how to read date and time values from records. It is<a id="_idIndexMarker561"/> common to also need to perform date calculations and to convert<a id="_idIndexMarker562"/> dates between their native format and string representations. Here, we will see how to perform these kinds of operations.</p>
			<p>Odoo provides a few useful functions to create new date and time objects.</p>
			<p>The <code>odoo.fields.Date</code> object provides these helper functions:</p>
			<ul>
				<li>The <code>fields.Date.today()</code> function<a id="_idIndexMarker563"/> returns a string with the current date in the format expected by the server, using UTC as a reference. This is adequate to compute default values. It can be used directly in a date field definition by using <code>default=fields.Date.today</code>.</li>
				<li>The <code>fields.Date.context_today(record, timestamp=None)</code> function returns a string with the current date in the session's context. The time zone value is taken from the record's context. The optional <code>timestamp</code> parameter is a <code>datetime</code> object and will be used instead of the current time if provided.</li>
			</ul>
			<p>The <code>odoo.fields.Datetime</code> objects provide these datetime creation functions:</p>
			<ul>
				<li>The <code>fields.Datetime.now()</code> function <a id="_idIndexMarker564"/>returns a string with the current <code>datetime</code> in the format expected by the server, using UTC as a reference. This is adequate to compute default values. It can be used directly in a <code>datetime</code> field definition by using <code>default=fields.Datetime.now</code>.</li>
				<li>The <code>fields.Datetime.context_timestamp(record, timestamp)</code> function converts a naive <code>datetime</code> value (without time zone) into a time zone-aware <code>datetime</code> value. The time zone is extracted from the record's context, hence the name of the function.</li>
			</ul>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor214"/>Adding and subtracting time</h2>
			<p>Date objects can<a id="_idIndexMarker565"/> be compared and subtracted to find the time elapsed between both dates. This time elapsed is a <code>timedelta</code> object. A <code>timedelta</code> object can be added to or subtracted from <code>date</code> and <code>datetime</code> objects, performing date arithmetic.</p>
			<p>These objects are provided by the Python standard library <code>datetime</code> module. Here is a sample of the essential operations we can do with them:</p>
			<pre>&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; date.today()
datetime.date(2021, 11, 3)
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; date(2021, 11, 3) + timedelta(days=7)
datetime.date(2021, 11, 10)</pre>
			<p>A full reference for the <code>date</code>, <code>datetime</code>, and <code>timedelta</code> data types can be found at <a href="https://docs.python.org/3/library/datetime.html">https://docs.python.org/3/library/datetime.html</a>.</p>
			<p>The <code>timedelta</code> object supports weeks, days, hours, seconds, and more. But it doesn't support years or months.</p>
			<p>To perform date<a id="_idIndexMarker566"/> arithmetic using months or years, we should use the <code>relativedelta</code> object. Here is an example of adding one year and one month:</p>
			<pre>&gt;&gt;&gt; from dateutil.relativedelta import relativedelta
&gt;&gt;&gt; date(2021, 11, 3) + relativedelta(years=1, months=1)
datetime.date(2022, 12, 3)</pre>
			<p>The <code>relativedelta</code> object supports advanced date arithmetic, including leap years and Easter calculations. The documentation for it can be found at <a href="https://dateutil.readthedocs.io">https://dateutil.readthedocs.io</a>.</p>
			<p>Odoo also provides a few additional functions in the <code>odoo.tools.date_utils</code> module:</p>
			<ul>
				<li>The <code>start_of(value, granularity)</code> function returns the start of a time period with the specified granularity, which is a string value with one of <code>year</code>, <code>quarter</code>, <code>month</code>, <code>week</code>, <code>day</code>, or <code>hour</code>.</li>
				<li>The <code>end_of(value, granularity)</code> function returns the end of a time period with the specified granularity.</li>
				<li>The <code>add(value, **kwargs)</code> function adds a time interval to the given value. The <code>**kwargs</code> arguments are to be used by a <code>relativedelta</code> object to define the time interval. These arguments can be <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, and so on.</li>
				<li>The <code>subtract(value, **kwargs)</code> function subtracts a time interval from the given value. </li>
			</ul>
			<p>These utility functions are also exposed in the <code>odoo.fields.Date</code> and the <code>odoo.fields.Datetime</code> objects.</p>
			<p>Here are a few examples using the previous functions:</p>
			<pre>&gt;&gt;&gt; from odoo.tools import date_utils
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime(2020, 11, 3, 0, 0, 0)
&gt;&gt;&gt; date_utils.start_of(now, 'week')
datetime.datetime(2020, 11, 2, 0, 0)
&gt;&gt;&gt; date_utils.end_of(now, 'week')
datetime.datetime(2020, 11, 8, 23, 59, 59, 999999)
&gt;&gt;&gt; today = date(2020, 11, 3)
&gt;&gt;&gt; date_utils.add(today, months=2)
datetime.date(2021, 1, 3)
&gt;&gt;&gt; date_utils.subtract(today, months=2)
datetime.date(2020, 9, 3)</pre>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor215"/>Converting date and time objects to text representations</h2>
			<p>There will<a id="_idIndexMarker567"/> be cases where we need to <a id="_idIndexMarker568"/>convert a Python <code>date</code> object into a text representation. This may be needed, for example, to prepare a user message or to format data to send to another system.</p>
			<p>The Odoo field objects provide helper functions to convert the native Python objects to string representations:</p>
			<ul>
				<li>The <code>fields.Date.to_string(value)</code> function converts a <code>date</code> object into a string in the format expected by the Odoo server.</li>
				<li>The <code>fields.Datetime.to_string(value)</code> function converts a <code>datetime</code> object into a string in the format expected by the Odoo server.</li>
			</ul>
			<p>These use the Odoo server predefined defaults, which are defined in the following constants:</p>
			<ul>
				<li><code>odoo.tools.DEFAULT_SERVER_DATE_FORMAT</code></li>
				<li><code>odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT</code></li>
			</ul>
			<p>These map to <code>%Y-%m-%d</code> and <code>%Y-%m-%d %H:%M:%S</code>, respectively.</p>
			<p>The <code>date.strftime</code> and <code>datetime.strftime</code> functions accept a format string parameter<a id="_idIndexMarker569"/> that can be used for other<a id="_idIndexMarker570"/> conversions to text.</p>
			<p>For example, consider the following:</p>
			<pre>&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; date(2020, 11, 3).strftime("%d/%m/%Y")
'03/11/2020'</pre>
			<p>Further details on the available format codes can be found at <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</a>.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor216"/>Converting text-represented dates and times</h2>
			<p>There are cases where dates <a id="_idIndexMarker571"/>arrive formatted as text strings and need to be converted to Python <code>date</code> or <code>datetime</code> objects. This was frequently needed up to Odoo 11, where stored dates were read as text representations. Some tools are provided to help with this conversion from text into native data types and then back into text.</p>
			<p>To facilitate this conversion between formats, the <code>fields.Date</code> and <code>fields.Datetime</code> objects provide these functions:</p>
			<ul>
				<li>The <code>fields.Date.to_date</code> function converts a string into a <code>date</code> object.</li>
				<li>The <code>fields.Datetime.to_datetime(value)</code> function converts a string into a <code>datetime</code> object.</li>
			</ul>
			<p>An example of a usage of <code>to_datetime</code> is as follows:</p>
			<pre>&gt;&gt;&gt; from odoo import fields
&gt;&gt;&gt; fields.Datetime.to_datetime("2020-11-21 23:11:55")
datetime.datetime(2020, 11, 21, 23, 11, 55)</pre>
			<p>The preceding example uses the Odoo internal date format to parse the provided string and convert it into a Python <code>datetime</code> object.</p>
			<p>For other date and time formats, the <code>strptime</code> method from the <code>date</code> and <code>datetime</code> object can be used:</p>
			<pre>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.strptime("03/11/2020", "%d/%m/%Y")
datetime.datetime(2020, 11, 3, 0, 0)</pre>
			<p>In most cases, the<a id="_idIndexMarker572"/> text-represented time will not be in UTC, as expected by the Odoo server. The time must be converted to UTC before it can be stored in the Odoo database.</p>
			<p>For example, if the user is in the Europe/Brussels timezone (at +1:00 hours from UTC) the <code>2020-12-01 00:30:00</code> user time should be stored in UTC as <code>2020-11-30 23:30:00</code>. Here is the code recipe for this:</p>
			<pre>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; naive_date = datetime(2020, 12, 1, 0, 30, 0)
&gt;&gt;&gt; client_tz = self.env.context["tz"]
&gt;&gt;&gt; client_date = pytz.timezone(client_tz).localize(naive_date)
&gt;&gt;&gt; utc_date = client_date.astimezone(pytz.utc)
&gt;&gt;&gt; print(utc_date)
2020-11-30 23:30:00+00:00</pre>
			<p>This code gets the user time zone name from the context and then uses it to convert the naive date to a time zone-aware date. The final step is to convert the client time zone date to a UTC date by using <code>astimezone(pytz.utc)</code>.</p>
			<p>We've now learned specific techniques to work with date and time in Odoo. There are also specific techniques to work with recordsets and the values stored in relational fields, which we'll discuss in the next section.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor217"/>Working with recordsets</h1>
			<p>A <strong class="bold">recordset</strong> is a <a id="_idIndexMarker573"/>collection of records, and Python business logic frequently needs to use them. There are several operations that can be performed on recordsets, such as mapping and filtering. We can also compose new recordsets by adding or removing records. Other common operations are inspecting the contents of a recordset to check if a particular record is there or not, for example.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">Since Odoo 10, recordset manipulation has preserved the record order. This is unlike previous Odoo versions, where recordset manipulation was not guaranteed to preserve the record order, although addition and slicing maintained the record order.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor218"/>Recordset operations</h2>
			<p>Recordsets have a <a id="_idIndexMarker574"/>few functions available to perform useful actions on them, such as <strong class="bold">sorting</strong> or <strong class="bold">filtering records</strong>.</p>
			<p>These are the supported functions and attributes:</p>
			<ul>
				<li>The <code>recordset.ids</code> attribute returns a list with the IDs of the recordset elements.</li>
				<li>The <code>recordset.ensure_one()</code> function checks whether it's a single record (that is, a singleton); if it's not, a <code>ValueError</code> exception is raised.</li>
				<li>The <code>recordset.filtered(&lt;function or str&gt;)</code> function returns a filtered recordset, and this function is a test function to filter records. The argument can instead be a string containing a dot-separated sequence of fields to evaluate. The records evaluating to a truthy value are selected.</li>
				<li>The <code>recordset.mapped(&lt;function or str&gt;)</code> function returns a list of values, and the function returns a value for each record. The argument can instead be a string containing a dot-separated sequence of fields to evaluate to reach the field to return. To-many relations are safe to use in the field sequence.</li>
				<li>The <code>recordset.sorted(&lt;function ot str&gt;)</code> function returns the recordset with a specific element order. The function returns a value for each record, which are used to sort the recordset. The argument can instead be a string with the name of the field to sort by. Note that a dot-notation sequence of fields is not<a id="_idIndexMarker575"/> allowed. An optional <code>reverse=True</code> argument is also available.</li>
			</ul>
			<p>Here are some usage examples for these functions:</p>
			<pre>&gt;&gt;&gt; rs0 = self.env["res.partner"].search([("display_name", "like", "Azure")])
&gt;&gt;&gt; len(rs0)  # how many records?
4
&gt;&gt;&gt; rs0.filtered(lambda r: r.name.startswith("Nicole"))
res.partner(27,)
&gt;&gt;&gt; rs0.filtered("is_company")
res.partner(14,)
&gt;&gt;&gt; rs0.mapped("name")
['Azure Interior', 'Brandon Freeman', 'Colleen Diaz', 'Nicole Ford']
&gt;&gt;&gt; rs0.sorted("name", reverse=True).mapped("name")
['Nicole Ford', 'Colleen Diaz', 'Brandon Freeman', 'Azure Interior']
&gt;&gt;&gt; rs0.mapped(lambda r: (r.id, r.name))
[(14, 'Azure Interior'), (26, 'Brandon Freeman'), (33, 'Colleen Diaz'), (27, 'Nicole Ford')]</pre>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor219"/>The composition of a recordset</h2>
			<p>Recordsets <a id="_idIndexMarker576"/>are immutable, meaning that their values can't be directly modified. Instead, we can compose a new recordset based on existing ones. <strong class="bold">Slice notation</strong>, which is<a id="_idIndexMarker577"/> commonly used with Python lists, can be used on recordsets to extract a subset of the records. Here are a few examples:</p>
			<ul>
				<li><code>rs[0]</code> and <code>rs[-1]</code> retrieve the first element and the last element, respectively.</li>
				<li><code>rs[1:]</code> results in a copy of the recordset without the first element.</li>
				<li><code>rs[:1]</code> returns the first element of the recordset.<p class="callout-heading">Tip</p><p class="callout">For a fail-safe way to retrieve the first element of a recordset, use <code>rs[:1]</code> instead of <code>rs[0]</code>. The latter results in an error if <code>rs</code> is empty, whereas the former will just return an empty recordset in this case. Another option is to use the <code>first()</code> function from the <code>odoo.fields</code> module: <code>fields.first(rs)</code>.</p></li>
			</ul>
			<p>Recordsets also<a id="_idIndexMarker578"/> support the following set operations:</p>
			<ul>
				<li>The  <code>rs1 | rs2</code> operation is a <em class="italic">union</em> set operation and results in a recordset with all elements from both recordsets. This is a set-like operation and won't result in duplicate elements. </li>
				<li>For example, <code>self.env.user | self.env.user</code> returns a single record, such as <code>res.users(1,)</code>.</li>
				<li>The  <code>rs1 &amp; rs2</code> operation is an <em class="italic">intersection</em> set operation and results in a recordset with only the elements present in both recordsets.</li>
				<li>The  <code>rs1 - rs2</code> operation is a <em class="italic">difference</em> set operation and results in a recordset with the <code>rs1</code> elements not present in <code>rs2</code>.<p class="callout-heading">Tip</p><p class="callout">Recordsets also support the addition operation (<code>+</code>), however, it should be avoided. It has a different behavior from the union operation (<code>|</code>) and allows for duplicate elements in a recordset. However, this is rarely what we want. For example, <code>self.env.user + self.env.user</code> returns two records, such as <code>res.users(1, 1)</code>.</p></li>
			</ul>
			<p>We can use these <a id="_idIndexMarker579"/>operations directly with a value assignment for shorter notation:</p>
			<ul>
				<li>The <code>self.author_ids |= author1</code> operation adds the <code>author1</code> record if it is not in the recordset.</li>
				<li>The <code>self.author_ids &amp;= author1</code> operation keeps only the records also present in the <code>author1</code> recordset.</li>
				<li>The <code>self.author_ids -= author1</code> operation removes the specific <code>author1</code> record if it is present in the recordset.</li>
			</ul>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor220"/>Recordset accumulation</h2>
			<p>In some cases, we<a id="_idIndexMarker580"/> want to loop through some logic and accumulate records resulting from each iteration of the loop. The ORM way to accumulate a recordset is to start with an empty recordset and then add records to it. To get an empty recordset, create a reference to the model. For example, consider the following:</p>
			<pre>Partner = self.env["res.partner"]
recs = self.env["res.partner"]
for i in range(3):
    rec = Partner.create({"name": "Partner %s" % i})
    recs |= rec</pre>
			<p>The previous code loops three times and on each loop it creates a new partner record before accumulating it to the <code>recs</code> recordset. As it is a recordset, the <code>recs</code> variable can be used in cases where recordsets are expected, such as assigning a value to a to-many field.</p>
			<p>However, accumulating recordsets is not time-efficient and should be avoided inside loops. The reason for this is that Odoo recordsets are immutable objects and any operation on a recordset implies copying it to get the modified version. When appending a record to a recordset, the original recordset is not modified. Instead, a copy of it is made with the record appended to it. This copy operation consumes time, and the larger the recordset is, the longer it takes.</p>
			<p>As a result, alternatives should be considered. For the preceding example, we could have accumulated all of the record data dictionaries in a Python list and then made a single <code>create()</code> call to create all of the records. This is possible because the <code>create()</code> method can accept a list of dictionaries.</p>
			<p>So, the loop could look like this:</p>
			<pre>values = []
for i in range(3):
    value = {"name": "Partner %s" % i}
    values.append(value)
recs = self.env["res.partner"].create(values)</pre>
			<p>However, this <a id="_idIndexMarker581"/>solution won't work in all cases. Another option is to use a Python list to accumulate records. Python lists are mutable objects, and appending elements is an efficient operation for them. As Python lists are not actually recordsets, this option can't be used where a recordset is expected, for example, an assignment to a to-many field.</p>
			<p>The following is an example of accumulating records to a Python list:</p>
			<pre>Partner = self.env["res.partner"]
recs = []
for i in range(3):
    rec = Partner.create({"name": "Partner %s" % i})
    recs.append(new_rec)</pre>
			<p>The previous examples illustrate a few techniques that can be used in loops to build recordsets from individual elements. However, there are many cases where the loop is not strictly needed and operations such as <code>mapped()</code> and <code>filtered()</code> can provide more efficient ways to achieve the desired aim.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor221"/>Recordset comparisons</h2>
			<p>There are<a id="_idIndexMarker582"/> cases where we need to compare the content of a recordset to decide what further action is needed. Recordsets support the expected comparison operations.</p>
			<p>To check if a <code>&lt;rec&gt;</code> record is an element of a <code>&lt;my_recordset&gt;</code> recordset, the following code can be used:</p>
			<ul>
				<li><code>&lt;rec&gt; in &lt;my_recordset&gt;</code></li>
				<li><code>&lt;rec&gt; not in &lt;my_recordset&gt;</code></li>
			</ul>
			<p>Recordsets can also be compared to check if one is contained in another. To compare two recordsets, use <code>set1</code> and <code>set2</code>:</p>
			<ul>
				<li>Using <code>set1 &lt;= set2</code> and <code>set1 &lt; set2</code> returns <code>True</code> if all of the elements in <code>set1</code> are also in <code>set2</code>. The <code>&lt;</code> operators return <code>False</code> if both recordsets have the same elements.</li>
				<li>Using <code>set1 &gt;= set2</code> and <code>set1 &gt; set2</code> returns <code>True</code> if all of the elements in <code>set2</code> are also in <code>set1</code>. The <code>&gt;</code> operators return <code>False</code> if both recordsets have the same elements.</li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor222"/>Transactions and low-level SQL</h1>
			<p>ORM methods that are called from a client run in a <em class="italic">transaction</em>. Transactions ensure correctness in the case of concurrent <a id="_idIndexMarker583"/>writes or failures. During a transaction, the data records used are locked, protecting them from other concurrent transactions and ensuring that they are not unexpectedly changed. In case of failure, all the transaction changes are rolled back, returning to the initial state.</p>
			<p>Transaction support is provided by the <a id="_idIndexMarker584"/>PostgreSQL database. When an ORM method is called from a client, a new transaction is initiated. If an error occurs during the method execution, any changes that have been made are reverted. If the method execution completes with no errors, then the changes made are committed, making them effective and visible to all other transactions.</p>
			<p>This is automatically handled for us, and we usually don't need to worry about it. However, in some advanced use cases, it might be useful to have control over the current transaction.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Since Odoo 13, database write operations are not done while the method is running. Instead, they accumulate in a memory cache, and the actual database writing is delayed to the end of the execution of the method, which is performed by a <code>flush()</code> call that is invoked automatically at that point.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor223"/>Controlling database transactions</h2>
			<p>There are cases where<a id="_idIndexMarker585"/> controlling the transaction can be useful and the <code>self.env.cr</code> database cursor can be used for this. An example of this is looping through records to perform an operation on each of them, where we want to skip the ones with operation errors without affecting the other ones.</p>
			<p>For this, the object provides the following:</p>
			<ul>
				<li><code>self.env.cr.commit()</code> commits the transaction's buffered write operations, making them effective in the database.</li>
				<li><code>self.env.cr.rollback()</code> cancels the transaction's <code>write</code> operations since the last commit or all of them if no commit was made.<p class="callout-heading">Tip</p><p class="callout">An Odoo <code>shell</code> session mimics a method execution context. This means that the database writes are not performed until <code>self.env.cr.commit()</code> is called.</p></li>
			</ul>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor224"/>Executing raw SQL</h2>
			<p>SQL can be run<a id="_idIndexMarker586"/> directly in the database by using the cursor <code>execute()</code> method. This takes a string with the SQL statement to run and a second optional argument with the values to use as parameters for the SQL.</p>
			<p>The values parameter can be a tuple or a dict. When using a tuple, the parameters are replaced with <code>%s</code>, and when using a dict, they are replaced with <code>%(&lt;name&gt;)s</code>. Here are examples of both approaches:</p>
			<pre>&gt;&gt;&gt; self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%s OR id=%s", ("demo", 1))
&gt;&gt;&gt; self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%(login)s OR id=%(id)s", {"login": "demo", "id": 1})</pre>
			<p>Any of the previous instructions run the SQL, replacing the parameters and preparing a cursor with the results that needs to be fetched. More details on this can be found in the <code>psycopg2</code> documentation at <a href="https://www.psycopg.org/docs/usage.html#query-parameters">https://www.psycopg.org/docs/usage.html#query-parameters</a>.</p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">With <code>cr.execute()</code>, we should not directly compose the SQL query concatenating parameters. Doing so is known to be a security risk that can be exploited through SQL injection attacks. Always use the <code>%s</code> placeholders with the second parameter to pass values.</p>
			<p>To fetch the results, the <code>fetchall()</code> function can be used, returning the rows' <code>tuples</code>:</p>
			<pre>&gt;&gt;&gt; self.env.cr.fetchall()
[(6, 'demo'), (1, '__system__')]</pre>
			<p>The <code>dictfetchall()</code> function can also be used to retrieve records as dicts:</p>
			<pre>&gt;&gt;&gt; self.env.cr.dictfetchall()
[{'id': 6, 'login': 'demo'}, {'id': 1, 'login': '__system__'}]</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>self.env.cr</code> database cursor object is an Odoo-specific wrapper around the PostgreSQL library, <code>psycopg2</code>. This means that the <code>psycopg2</code> documentation is helpful to understand how to fully use the object:</p>
			<p class="callout"><a href="https://www.psycopg.org/docs/cursor.html">https://www.psycopg.org/docs/cursor.html</a></p>
			<p>It is also <a id="_idIndexMarker587"/>possible to run <code>UPDATE</code> and <code>INSERT</code>. The Odoo environment relies on a data cache, and it may become inconsistent with the database when these DML instructions are executed. For this reason, after running using raw DML, the environment cached should be invalidated by using <code>self.env.cache.invalidate(fnames=None, ids=None)</code>.</p>
			<p><code>fnames</code> is a list with the names of the fields to invalidate and refresh. If this is not provided, all fields will be invalidated.</p>
			<p><code>ids</code> is a list with the record IDs to invalidate and refresh. If this is not provided, all will be invalidated.</p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">Executing SQL directly in the database bypasses the ORM validations and dependencies and can lead to inconsistent data. You should use it only if you're sure of what you are doing.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor225"/>Summary</h1>
			<p>In this chapter, we learned how to work with model data to perform <strong class="bold">CRUD</strong> operations—that is, <strong class="bold">creating</strong>, <strong class="bold">reading</strong>, <strong class="bold">updating</strong>, and <strong class="bold">deleting</strong> data—and all the techniques needed to make use of and manipulate <em class="italic">recordsets</em>. This provides the foundation needed for us to implement our business logic and automation code.</p>
			<p>To experiment with the ORM API, we used the Odoo interactive shell. We ran our commands in an environment accessible through <code>self.env</code>. The environment is similar to the one provided in the model method, and so it is a useful playground for exploring the Odoo API.</p>
			<p>The environment allows us to query data from any Odoo model that is made available as a recordset. We learned about the different ways to create recordsets and then how to read the data provided, including special data types such as dates, binary values, and relational fields.</p>
			<p>Another fundamental capability in Odoo is to write back data. In this chapter, we also learned how to create new records, write to existing records, and delete records.</p>
			<p>We also looked at working with date and time values by using the Python built-in tools and a few additional helper functions included in the Odoo framework.</p>
			<p>Recordsets can be manipulated to add elements, filter out records, reorder, or accumulate values, as well as to compare them or check for the inclusion of particular records. Any of these operations may be needed when implementing business logic, and this chapter presented the essential techniques for all of these.</p>
			<p>Finally, in some cases, we may need to skip using the ORM model and use low-level SQL operations to directly access the database or have finer control over transactions. These allow us to address the occasional cases where the ORM model is not the best tool for the job.</p>
			<p>With all these tools under our belt, we are ready for the next chapter, where we will add the business logic layer for our models and implement model methods that use the ORM API to automate actions.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor226"/>Further reading</h1>
			<p>The official Odoo documentation for recordsets can be found at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a>.</p>
		</div>
	</div></body></html>