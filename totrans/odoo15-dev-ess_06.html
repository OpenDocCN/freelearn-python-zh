<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer058">
			<h1 id="_idParaDest-190"><a id="_idTextAnchor194"/><a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>: Recordsets – Working with Model Data</h1>
			<p>In the previous chapters, we gave an overview of model creation and loading data into models. Now that we have a data model and some data to work with, it's time to learn more about how to programmatically interact with it.</p>
			<p>A business application needs business logic to compute data, perform validations, or automate operations. The <strong class="bold">Odoo</strong> framework API provides the tools for a developer to implement this business logic. Most of the time, this means querying, transforming, and writing data.</p>
			<p>Odoo implements an<strong class="bold"> Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) layer on top of the lower level database. The ORM objects provide the<strong class="bold"> Application Programming Interface</strong> (<strong class="bold">API</strong>) to be used to interact with the data. This API provides an execution environment and the creation of <strong class="bold">recordsets</strong>, that are objects  used to work the data stored in the database.</p>
			<p>This chapter explains how to use the execution environment and recordsets so that you have all the tools needed to implement the business processes.</p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Using the shell command to interactively explore the ORM API</li>
				<li>Understanding the execution environment and context</li>
				<li>Querying data using recordsets and domains</li>
				<li>Accessing data in recordsets</li>
				<li>Writing to records</li>
				<li>Working with date and time</li>
				<li>Working with recordsets</li>
				<li>Transactions and low-level SQL</li>
			</ul>
			<p>By the end of this chapter, you should be able to use Odoo code to perform all of these actions, and you will also be ready to use these tools to implement your own business processes.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor195"/>Technical requirements</h1>
			<p>The code examples in this chapter will be executed in an interactive shell and do not require any code from the previous chapters. A copy of the code can be found in the <strong class="bold">GitHub</strong> repository for this book (<a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>) in the <strong class="source-inline">ch07/ch07_recorsets_code.py</strong> file.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor196"/>Using the shell command</h1>
			<p><strong class="bold">Python</strong> includes a<a id="_idIndexMarker510"/> command-line interface that is a great way to explore the language. Odoo includes a similar feature through the <strong class="source-inline">shell</strong> command option. These commands can be executed interactively to better understand how they work.</p>
			<p>To use it, add the <strong class="source-inline">shell</strong> command when starting Odoo, plus any Odoo options that we would usually use when starting Odoo:</p>
			<p class="source-code">(env15) $ odoo shell -c library.conf</p>
			<p>This will initiate the usual server startup sequence in the terminal, but instead of launching an HTTP server listening for requests, it will start a Python prompt waiting for input.</p>
			<p>This interactive command interface simulates the environment found inside a <strong class="source-inline">class</strong> method, running under the <strong class="source-inline">OdooBot</strong> superuser. The <strong class="source-inline">self</strong> variable is available and is set to the <strong class="source-inline">OdooBot</strong> superuser record object.</p>
			<p>For example, these commands inspect the <strong class="source-inline">self</strong> recordset:</p>
			<p class="source-code">&gt;&gt;&gt; self</p>
			<p class="source-code">res.users(1,)</p>
			<p class="source-code">&gt;&gt;&gt; self._name</p>
			<p class="source-code">'res.users'</p>
			<p class="source-code">&gt;&gt;&gt; self.name</p>
			<p class="source-code">'OdooBot'</p>
			<p class="source-code">&gt;&gt;&gt; self.login</p>
			<p class="source-code">'__system__'</p>
			<p>The previous <a id="_idIndexMarker511"/>commands print out the following:</p>
			<ul>
				<li>The <strong class="source-inline">self</strong> variable contains a <strong class="source-inline">res.users</strong> recordset containing a record with <strong class="source-inline">ID 1</strong>.</li>
				<li>The recordset model name, inspecting <strong class="source-inline">self._name</strong>, is <strong class="source-inline">res.users</strong>, as expected.</li>
				<li>The value for the record <strong class="source-inline">name</strong> field is <strong class="source-inline">OdooBot</strong>.</li>
				<li>The value for the record <strong class="source-inline">login</strong> field is <strong class="source-inline">__system__</strong>.<p class="callout-heading">Changes in Odoo 12</p><p class="callout">The <strong class="source-inline">ID 1</strong> superuser changed from <strong class="source-inline">admin</strong> to the internal <strong class="source-inline">__system__</strong> user. The <strong class="source-inline">admin</strong> user is now the <strong class="source-inline">ID 2</strong> user, and not a superuser, although the Odoo standard apps are careful to automatically grant it full access to them. The main reason for this change was to avoid having users perform day-to-day activities with the superuser account. Doing so is dangerous because this change bypasses all access rules and may cause inconsistent data, such as cross-company relationships. It's now meant to be used only for troubleshooting or very specific cross-company operations.</p></li>
			</ul>
			<p>As with Python, to exit the prompt, press <em class="italic">Ctrl</em> + <em class="italic">D</em>. This will also close the server process and return to the system shell prompt.</p>
			<p>We now know how to start an Odoo shell session. This is important for us to discover the Odoo API features. So, let's use it to explore the execution environment.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>The execution environment</h1>
			<p>Odoo recordsets <a id="_idIndexMarker512"/>operate in an <strong class="bold">environment</strong> context, providing relevant information about the context where the operation was triggered. For example,  the database cursor being used, the current Odoo user, and more.</p>
			<p>Python code running inside a model method has access to the <strong class="source-inline">self</strong> recordset variable, and the local environment can be accessed with <strong class="source-inline">self.env</strong>. The server shell environment also provides a <strong class="source-inline">self</strong> reference in a similar way to what is found inside a method.</p>
			<p>In this section, we will learn about the attributes made available by the execution environment and how to use them.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Environment attributes</h2>
			<p>As we <a id="_idIndexMarker513"/>have seen, <strong class="source-inline">self</strong> is a recordset. Recordsets carry environment information with them such as the user browsing the data and additional context-related information (for example, the active language and time zone).</p>
			<p>The current environment can be accessed using the <strong class="source-inline">env</strong> attribute of a recordset, as shown in this example:</p>
			<p class="source-code">&gt;&gt;&gt; self.env</p>
			<p class="source-code">&lt;odoo.api.Environment object at 0x7f6882f7df40&gt;</p>
			<p>The execution environment in <strong class="source-inline">self.env</strong> has the following attributes available:</p>
			<ul>
				<li>The <strong class="source-inline">env.cr</strong> attribute is the database cursor being used.</li>
				<li>The <strong class="source-inline">env.user</strong> attribute is the record for the current user.</li>
				<li>The <strong class="source-inline">env.uid</strong> attribute is the ID for the session user. It is the same as <strong class="source-inline">env.user.id</strong>.</li>
				<li>The <strong class="source-inline">env.context</strong> attribute is an immutable dictionary containing the session context data.</li>
				<li>The <strong class="source-inline">env.company</strong> attribute is the active company.</li>
				<li>The <strong class="source-inline">env.companies</strong> attributes are the user's allowed companies.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <strong class="source-inline">env.company</strong> and <strong class="source-inline">env.companies</strong> attributes were introduced in Odoo 13. In previous versions, this information was read from the user record by using <strong class="source-inline">env.user.company_id</strong> and <strong class="source-inline">env.user.company_ids</strong>.</p></li>
			</ul>
			<p>The <a id="_idIndexMarker514"/>environment also provides access to the registry where all installed models are available. For example, <strong class="source-inline">self.env["res.partner"]</strong> returns a reference to the <strong class="source-inline">partner</strong> model. We can then use <strong class="source-inline">search()</strong> or <strong class="source-inline">browse()</strong> on it to create recordsets:</p>
			<p class="source-code">&gt;&gt;&gt; self.env["res.partner"].search([("display_name", "like", "Azure")])</p>
			<p class="source-code">res.partner(14, 26, 33, 27)</p>
			<p>In this example, the returned recordset for the <strong class="source-inline">res.partner</strong> model contains three records, with IDs <strong class="source-inline">14</strong>, <strong class="source-inline">26</strong>, <strong class="source-inline">33</strong>, and <strong class="source-inline">27</strong>. The recordset is not ordered by ID, as the default order for the corresponding model was used. In the case of the partner model, the default object <strong class="source-inline">_order</strong> is <strong class="source-inline">display_name</strong>.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>The environment context</h2>
			<p>The <strong class="source-inline">context</strong> object is<a id="_idIndexMarker515"/> a dictionary carrying session data that can be used on both the client-side user interface and the server-side ORM and business logic.</p>
			<p>From the client side, it can carry information from one view to the next—such as the ID of the record active on the previous view after following a link or a button—or it can provide default values to be used in the next view.</p>
			<p>On the server side, some recordset field values can depend on the locale settings provided by the context. In particular, the <strong class="source-inline">lang</strong> key affects the value of the translatable fields.</p>
			<p>Context can also provide signals for server-side code. For example, the <strong class="source-inline">active_test</strong> key, when set to <strong class="source-inline">False</strong>, changes the behavior of the ORM <strong class="source-inline">search()</strong> method so that it does not apply the automatic filter on inactive records, ignoring the <strong class="source-inline">active</strong> record field.</p>
			<p>An initial context from the web client looks like this:</p>
			<p class="source-code">&gt;&gt;&gt; self.env.context</p>
			<p class="source-code">{'lang': 'en_US', 'tz': 'Europe/Brussels'}</p>
			<p>Here, you can see the <strong class="source-inline">lang</strong> key with the user language and <strong class="source-inline">tz</strong> with the time zone information. The content in records might be different depending on the current context:</p>
			<ul>
				<li>Translated fields can have different values depending on the active <strong class="source-inline">lang</strong> language.</li>
				<li>Datetime fields, when returned to clients, can show different times depending on the active <strong class="source-inline">tz</strong> timezone.</li>
			</ul>
			<p>When opening a <a id="_idIndexMarker516"/>view from a link or a button in a previous view, the web client will automatically add a few keys to the context, providing information on the record we are navigating from:</p>
			<ul>
				<li><strong class="source-inline">active_model</strong> is the previous model name.</li>
				<li><strong class="source-inline">active_id</strong> is the ID of the original record the user was positioned at.</li>
				<li><strong class="source-inline">active_ids</strong> is a list of the IDs selected in cases where the user is navigating from a list view.</li>
			</ul>
			<p>Wizard assistants frequently use these keys to find the records they are expected to act on.</p>
			<p>The context can be used to set default values and activate default filters on the target web client view by using keys with these specific prefixes:</p>
			<ul>
				<li>The <strong class="source-inline">default_</strong> prefix added to a field name sets a default value for that field. For example, <strong class="source-inline">{'default_user_id': uid}</strong> sets the current user as a default value.</li>
				<li>The <strong class="source-inline">default_search_</strong> prefix added to a filter name will automatically enable that filter. For example, <strong class="source-inline">{'default_search_filter_my_tasks': 1}</strong> activates the filter with name <strong class="source-inline">filter_my_books</strong>.</li>
			</ul>
			<p>These prefixes are frequently used in <strong class="bold">window actions</strong> and in views in <strong class="source-inline">&lt;field context="{...}"&gt;</strong> elements.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor200"/>Modifying the recordset execution environment and context</h2>
			<p>The recordset execution context can be modified to take advantage of the behaviors described in the previous section or to add information to be used in methods called on that recordset.</p>
			<p>The environment <a id="_idIndexMarker517"/>and its context can be modified <a id="_idIndexMarker518"/>through the following methods. Each of these returns a new recordset, along with a copy of the original with a modified environment:</p>
			<ul>
				<li>The <strong class="source-inline">&lt;recordset&gt;.with_context(&lt;dictionary&gt;)</strong> method replaces the context with the one provided in the dictionary.</li>
				<li>The <strong class="source-inline">&lt;recordset&gt;.with_context(key=value, ...)</strong> method modifies the context by setting the provided attributes on it.</li>
				<li>The <strong class="source-inline">&lt;recordset&gt;.sudo([flag=True])</strong> method enables or disables the superuser mode, allowing it to bypass security rules. The context user is kept the same.</li>
				<li>The <strong class="source-inline">&lt;recordset&gt;.with_user(&lt;user&gt;)</strong> method modifies the user to the one provided, which is either a user record or an ID number.</li>
				<li>The <strong class="source-inline">&lt;recordset&gt;.with_company(&lt;company&gt;)</strong> method modifies the company to the one provided, which is either a company record or an ID number.</li>
				<li>The <strong class="source-inline">&lt;recordset&gt;.with_env(&lt;env&gt;)</strong> method modifies the full environment of the recordset to the one provided.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <strong class="source-inline">with_user()</strong> and <strong class="source-inline">with_company()</strong> methods were introduced in Odoo 13. To switch users, previous versions used the <strong class="source-inline">sudo([&lt;user&gt;])</strong> method, which could be provided to a specific user to switch to the superuser context. To switch companies, previous versions used <strong class="source-inline">with_context(force=company=&lt;id&gt;)</strong>, setting a <strong class="source-inline">context</strong> key that was checked in the relevant business logic.</p></li>
			</ul>
			<p>Additionally, the environment object provides the <strong class="source-inline">env.ref()</strong> function, taking a string with an external identifier and returning the corresponding record, as shown in the following example:</p>
			<p class="source-code">&gt;&gt;&gt; self.env.ref('base.user_root')</p>
			<p class="source-code">res.users(1,)</p>
			<p>If the external identifier does not exist, a <strong class="source-inline">ValueError</strong> exception is raised.</p>
			<p>We learned more about the execution environments when running Python code in the Odoo server. The next step is to interact with data. In this case, the first thing to learn is how to query data and create recordsets, which is discussed in the next section.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor201"/>Querying data with recordsets and domains</h1>
			<p>Odoo business logic will need to read data from the database to perform actions based on it. This is done through <em class="italic">recordsets</em>, which query the raw data and expose it as Python objects we can manipulate.</p>
			<p>Odoo <a id="_idIndexMarker519"/>Python will usually be running in a class method, where <strong class="source-inline">self</strong> represents the recordset to work with. In some cases, we need to create recordsets for <a id="_idIndexMarker520"/>other models. For that, we should get a<a id="_idIndexMarker521"/> reference to the models and then query it to create the recordset.</p>
			<p>The environment object, usually accessible as <strong class="source-inline">self.env</strong>, holds references to all the models available, and these can be accessed using dictionary-like syntax. For example, to get a reference to the <strong class="source-inline">partner</strong> model, use <strong class="source-inline">self.env['res.partner']</strong> or <strong class="source-inline">self.env.get('res.partner')</strong>. This model reference can then be used to create recordsets, as we will see next.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor202"/>Creating recordsets</h2>
			<p>The <strong class="source-inline">search()</strong> method <a id="_idIndexMarker522"/>takes a domain expression and returns a recordset with the records matching those conditions. For example, <strong class="source-inline">[('name', 'like', 'Azure')]</strong> will return all records with a <strong class="source-inline">name</strong> field containing <strong class="source-inline">Azure</strong>.</p>
			<p>If the model has the <strong class="source-inline">active</strong> special field then by default, only the records with <strong class="source-inline">active=True</strong> will be considered.</p>
			<p>The following keyword arguments can also be used:</p>
			<ul>
				<li>The <strong class="source-inline">order</strong> keyword is a string to be used as the <strong class="source-inline">ORDER BY</strong> clause in the database query. This is usually a comma-separated list of field names. Each field name may be followed by the <strong class="source-inline">DESC</strong> keyword to indicate a descending order.</li>
				<li>The <strong class="source-inline">limit</strong> keyword sets a maximum number of records to retrieve.</li>
				<li>The <strong class="source-inline">offset</strong> keyword ignores the first <strong class="source-inline">n</strong> results; it can be used with <strong class="source-inline">limit</strong> to query blocks of records at a time.</li>
			</ul>
			<p>Sometimes, we just need to know the number of records meeting certain conditions. For that, we can use <strong class="source-inline">search_count()</strong>, which returns the record count instead of a recordset in a more efficient way.</p>
			<p>The <strong class="source-inline">browse()</strong> method takes a list of IDs or a single ID and returns a recordset with those records. This can be convenient in cases where we already know the IDs of the records we want.</p>
			<p>For example, to<a id="_idIndexMarker523"/> get all the partner records containing <strong class="source-inline">Lumber</strong> in the display name, use the following <strong class="source-inline">search()</strong> call:</p>
			<p class="source-code">&gt;&gt;&gt; self.env['res.partner'].search([('display_name', 'like', 'Lumber')])</p>
			<p class="source-code">res.partner(15, 34)</p>
			<p>In the case the IDs to query are known, use a <strong class="source-inline">browse()</strong> call, as in the following example:</p>
			<p class="source-code">&gt;&gt;&gt; self.env['res.partner'].browse([15, 34]) </p>
			<p class="source-code">res.partner(15, 34)</p>
			<p>Most of the time the IDs are not known, so the <strong class="source-inline">search()</strong> method is used more often than <strong class="source-inline">browse()</strong>.</p>
			<p>To make good use of <strong class="source-inline">search()</strong>, a good understanding of the domain filter syntax is needed. So, we will focus on this in the next section.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Domain expressions</h2>
			<p>A <strong class="bold">domain</strong> is <a id="_idIndexMarker524"/>used to filter data records. It uses a specific syntax that the Odoo ORM parses to produce the SQL <strong class="source-inline">WHERE</strong> expressions that are used to query the database. A <strong class="bold">domain expression</strong> is a<a id="_idIndexMarker525"/> list of conditions, and each condition is a <strong class="source-inline">('&lt;field&gt;', '&lt;operator&gt;', &lt;value&gt;)</strong> tuple. For example, the following is a valid domain expression, with a single condition: <strong class="source-inline">[('is_done', '=', False)]</strong>. A domain expression with no conditions is also allowed. This translates to an empty list (<strong class="source-inline">[]</strong>) and the result is a query returning all records.</p>
			<p>There are actually two possible evaluation contexts for domains: on the client side, such as in <em class="italic">window actions</em> and web client <em class="italic">views</em>, and on the server side, such as in security <em class="italic">record rules</em> and model method Python code. What can be used in the <strong class="source-inline">&lt;field&gt;</strong> and <strong class="source-inline">&lt;value&gt;</strong> elements may depend on the evaluation context.</p>
			<p>Next, we will look at a detailed explanation for each element of a domain condition: <strong class="bold">field</strong>, <strong class="bold">operator</strong>, and <strong class="bold">value</strong>.</p>
			<h3>The field element of a domain condition</h3>
			<p>The first condition element is a<a id="_idIndexMarker526"/> string with the name of the field being filtered. When the domain expression is used on the server side, the field element can use dot-notation to access the values of related models. For example, we could use something like <strong class="source-inline">'publisher_id.name'</strong>, or even <strong class="source-inline">'publisher_id.country_id.name'</strong>.</p>
			<p>On the client side, dot-notation is not allowed, and only simple field names can be used.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In cases where a related record value is needed for a client-side domain expression because dot-notation can't be used, the solution is to add to the model a related field by using a <strong class="source-inline">related=</strong> attribute. This way, the value is accessible as a directly accessible model field.</p>
			<h3>The operator element of a domain condition</h3>
			<p>The second <a id="_idIndexMarker527"/>condition element is the operator to apply on the field being filtered. What follows is a list of the allowed operators:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="Images/Table_7.1_B16119.jpg" alt="" width="1650" height="1883"/>
				</div>
			</div>
			<p>These operators <a id="_idIndexMarker528"/>are applied to the field provided in the first element, using the value provided in the third element. For example, <strong class="source-inline">('shipping_address_id', 'child_of', partner_id)</strong> checks the evaluation context for a <strong class="source-inline">partner_id</strong> variable and reads its value. The database is queried on the <strong class="source-inline">shipping_address_id</strong> field, selecting the records where that address is a child of the one identified in the <strong class="source-inline">partner_id</strong> value. </p>
			<h3>The value element of a domain condition</h3>
			<p>The third<a id="_idIndexMarker529"/> element is evaluated as a Python expression. It can use literal values, such as numbers, Booleans, strings, or lists, and can use fields and identifiers available in the evaluation context.</p>
			<p>Record objects are not accepted values. Instead, the corresponding ID values should be used. For example, don't use <strong class="source-inline">[('user_id', '=', user)]</strong> – instead, use <strong class="source-inline">[('user_id', '=', user</strong><strong class="bold">.id</strong><strong class="source-inline">)]</strong>.</p>
			<p>For record rules, the evaluation context has the following names available:</p>
			<ul>
				<li><strong class="source-inline">user</strong>: A record for the current user (equivalent to <strong class="source-inline">self.env.user</strong>). Use <strong class="source-inline">user.id</strong> to get the corresponding ID.</li>
				<li><strong class="source-inline">company_id</strong>: The ID of a record for the active company (equivalent to <strong class="source-inline">self.env.company.id</strong>).</li>
				<li><strong class="source-inline">company_ids</strong>: A list of IDs for the allowed companies (equivalent to <strong class="source-inline">self.env.companies.ids</strong>).</li>
				<li><strong class="source-inline">time</strong>: The Python time module, exposing date and time functions. The official reference can be found at <a href="https://docs.python.org/3/library/time.html">https://docs.python.org/3/library/time.html</a>.<p class="callout-heading">Changes in Odoo 13</p><p class="callout">The <strong class="source-inline">company_id</strong> and <strong class="source-inline">company_ids</strong> context values are available for record rule evaluation since Odoo 13, and the approach from the previous version, using <strong class="source-inline">user.company_id.id</strong>, should not be used anymore. For example, the previously frequently used <strong class="source-inline">['|', ('company_id', '=', False), ('company_id', 'child_of', [user.company_id.id])]</strong> domain should now be written as <strong class="source-inline">[('company_id', 'in', company_ids)]</strong>.</p></li>
			</ul>
			<h3>Searching on to-many fields</h3>
			<p>When the searched <a id="_idIndexMarker530"/>field is a <em class="italic">to-many</em>, the operator is applied to each of the field values, and the evaluated record is included in the result if any of the field values match the domain condition.</p>
			<p>The <strong class="source-inline">=</strong> and <strong class="source-inline">in</strong> operators behave like a <em class="italic">contains</em> operation. They both check if <em class="italic">any</em> of the field values match any of the list of values searched for. Symmetrically, the <strong class="source-inline">!=</strong> and <strong class="source-inline">not in</strong> operators check that <em class="italic">none</em> of the field values match any of the list of values searched for.</p>
			<h3>Composing a domain expression with multiple conditions</h3>
			<p>A domain expression<a id="_idIndexMarker531"/> is a list of items and can contain several condition tuples. By default, these conditions will implicitly be combined using the AND logical operator. This means that it will only return records meeting all of the conditions.</p>
			<p>Explicit logic operators<a id="_idIndexMarker532"/> can also be used – for example, the ampersand symbol (<strong class="source-inline">&amp;</strong>) for AND operations (the default) and the pipe symbol (<strong class="source-inline">|</strong>) for OR operations. These will operate on the next two items, working in a recursive way. We'll look at this in more detail in a moment.</p>
			<p>For a slightly<a id="_idIndexMarker533"/> more formal definition, a domain expression uses prefix notation, also known as <strong class="bold">Polish notation</strong> (<strong class="bold">PN</strong>), where operators precede operands. The AND and OR operators are binary operators, while NOT is a unary operator.</p>
			<p>The exclamation point (<strong class="source-inline">!</strong>) represents the NOT operator and it operates on the following item. So, it should be placed before the item to be negated. For example, the <strong class="source-inline">['!', ('is_done','=',True)]</strong> expression will filter all <em class="italic">not done</em> records.</p>
			<p>Operator items, such as (<strong class="source-inline">!</strong>) or (<strong class="source-inline">|</strong>), can be nested, allowing the definition of <strong class="source-inline">AND</strong>/<strong class="source-inline">OR</strong>/<strong class="source-inline">NOT</strong> complex conditions. Let's illustrate this with an example.</p>
			<p>In server-side record rules, we can find domain expressions similar to this one:</p>
			<p class="source-code">['|',</p>
			<p class="source-code">    ('message_follower_ids', 'in', [user.partner_id.id]),</p>
			<p class="source-code">    '|',</p>
			<p class="source-code">        ('user_id', '=', user.id),</p>
			<p class="source-code">        ('user_id', '=', False)</p>
			<p class="source-code">]</p>
			<p>This domain filters all of the records where:</p>
			<p>- the current user is a follower, or</p>
			<p>- the current user is the record's responsible (user_id), or</p>
			<p>- the record has no responsible user set.</p>
			<p>The following<a id="_idIndexMarker534"/> diagram illustrates the abstract syntax tree representation of the previous domain expression example:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="Images/Figure_7.1_B16119.jpg" alt="Figure 7.1 – A diagram illustrating a composed domain expression&#13;&#10;" width="1209" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A diagram illustrating a composed domain expression</p>
			<p>The first <strong class="source-inline">|</strong> (<em class="italic">OR</em>) operator acts on the follower's condition plus the result of the next condition. The next condition is again the union of two other conditions  - records where either the user ID is set to the current user, or the user ID is not set.</p>
			<h3>Special domain conditions</h3>
			<p>Some special domain conditions<a id="_idIndexMarker535"/> are also supported for the cases where an <em class="italic">always true</em> or <em class="italic">always false</em> expression is needed.</p>
			<p>The <strong class="source-inline">(1, "=", 1)</strong> condition represents an <em class="italic">always true</em> expression. It can be used on record rules to give a higher user group access to all records, previously limited by a lower user group. For example, it is used on the <strong class="source-inline">User: All Documents</strong> group, to override the record access limitation in the inherited <strong class="source-inline">User: Own Documents only</strong> group. For an example of this, see <strong class="source-inline">addons/sales_team/security/sales_team_security.xml</strong> in the Odoo source code.</p>
			<p>The <strong class="source-inline">(0, "=", 1)</strong> condition is also supported and represents an <em class="italic">always false</em> expression.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Grouping by fields and aggregate data</h2>
			<p>Sometimes, we need to group records<a id="_idIndexMarker536"/> by their data field. Odoo can do this using the <strong class="source-inline">read_group()</strong> method. The method arguments are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">domain</strong> argument is a list with a domain expression to filter the records to retrieve.</li>
				<li>The <strong class="source-inline">fields</strong> argument is a list of field names, along with an aggregation function to apply in the format of <strong class="source-inline">field:aggr</strong>. Aggregation functions are the ones allowed by <strong class="bold">PostgreSQL</strong>, such as <strong class="source-inline">sum</strong>, <strong class="source-inline">avg</strong>, <strong class="source-inline">min</strong>, <strong class="source-inline">max</strong>, <strong class="source-inline">count</strong>, and <strong class="source-inline">count_distinct</strong>. For example: <strong class="source-inline">["subtotal:sum"]</strong>.</li>
				<li>The <strong class="source-inline">groupby</strong> argument is a list with the data field names to group by.</li>
				<li>The <strong class="source-inline">limit</strong> argument is an optional maximum number of groups to return.</li>
				<li>The <strong class="source-inline">offset</strong> argument is an optional number of records to skip.</li>
				<li>The <strong class="source-inline">orderby</strong> argument is an optional string with an <em class="italic">order by</em> clause to apply to the result (similar to what <strong class="source-inline">search()</strong> supports).</li>
				<li>The <strong class="source-inline">lazy</strong> argument, if set to <strong class="source-inline">True</strong>, only groups by the first field, and adds the remaining group of fields to the <strong class="source-inline">__context</strong> result. This argument defaults to <strong class="source-inline">True</strong>, so set it to <strong class="source-inline">False</strong> to have all <em class="italic">group by fields</em> immediately applied.</li>
			</ul>
			<p>Here is an  example grouping partner record by country, and count the number of different states found:</p>
			<p class="source-code">&gt;&gt;&gt; self.env["res.partner"].read_group([("display_name", "like", "Azure")], fields=["state_id:count_distinct",], groupby=["country_id"], lazy=False)</p>
			<p class="source-code">[{'__count': 4, 'state_id': 1, 'country_id': (233, &lt;odoo.tools.func.lazy object at 0x7f197b65fc00&gt;), '__domain': ['&amp;', ('country_id', '=', 233), ('display_name', 'like', 'Azure')]}]</p>
			<p>This returned a <a id="_idIndexMarker537"/>list with a single group result for the <strong class="source-inline">233</strong> country ID. Running <strong class="source-inline">self.env["res.country"].browse(233).name</strong>, we can see that the country is <strong class="source-inline">United Sates</strong>. The <strong class="source-inline">__count</strong> key shows that there are <strong class="source-inline">4</strong> partners in the <strong class="source-inline">233</strong> country ID, and the <strong class="source-inline">state_id</strong> object shows the <strong class="source-inline">count</strong> distinct aggregation results: <strong class="source-inline">1</strong> distinct state is used by these partners.</p>
			<p>We now know how to create recordsets. Next, we will want to read the data in them. In many cases, this is a trivial operation, but for some field types, there are a few details involved that are worth noting. The next section will help us with that.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor205"/>Accessing data in recordsets</h1>
			<p>Once we have a <a id="_idIndexMarker538"/>recordset, we want to inspect the data contained in it. So, in the following sections, we will explore how to access data in recordsets.</p>
			<p>We can get field <a id="_idIndexMarker539"/>values for individual records called <em class="italic">singletons</em>. Relational fields have special properties, and we can use dot-notation to navigate through linked records. Finally, we will discuss some considerations for when we need to handle date and time records and convert them between different formats.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>Accessing individual record data</h2>
			<p>When a<a id="_idIndexMarker540"/> recordset has only one record it is called a <strong class="bold">singleton</strong>. Singletons are still<a id="_idIndexMarker541"/> recordsets and can be used wherever a recordset is expected.</p>
			<p>But unlike multi-element recordsets, singletons can access their fields using dot-notation, as follows:</p>
			<p class="source-code">&gt;&gt;&gt; print(self.name)</p>
			<p class="source-code">OdooBot</p>
			<p>In the next example, we can see that the same <strong class="source-inline">self</strong> singleton recordset also behaves as a recordset, and we can iterate it. It has only one record, so only one name is printed out:</p>
			<p class="source-code">&gt;&gt;&gt; for rec in self: print(rec.name)</p>
			<p class="source-code">...</p>
			<p class="source-code">OdooBot</p>
			<p>Trying to access field values in recordsets with more than one record will result in an error, so this can be an issue in cases where we are not sure if we are working with a singleton recordset.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Although using dot-notation to access fields won't work on multiple records, it is possible to access them in bulk by mapping the values to a recordset. This is done using <strong class="source-inline">mapped()</strong>. For example, <strong class="source-inline">rset.mapped("name")</strong> returns a list with the <strong class="source-inline">name</strong> values.</p>
			<p>For methods designed to work only with a singleton, we can check this using <strong class="source-inline">self.ensure_one()</strong> at the beginning. It will raise an error if <strong class="source-inline">self</strong> is not a singleton.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">ensure_one()</strong> function also raises an error if the record is empty. To check if a <strong class="source-inline">rset</strong> has one or zero records, you can use <strong class="source-inline">rset or rset.ensure_one()</strong>.</p>
			<p>An empty record is also a singleton. This is convenient because accessing field values will return a <strong class="source-inline">None</strong> value instead of raising an error. This is also true for relational fields, and accessing related records using dot notation won't raise errors.</p>
			<p>So, in practice, there<a id="_idIndexMarker542"/> is no need to check for an empty recordset before accessing their field values. For example, instead of <strong class="source-inline">if record: print(record.name)</strong>, we can safely write the simpler <strong class="source-inline">print(record.name)</strong> method. A default value for an empty value can also be provided by using an <strong class="source-inline">or</strong> condition: <strong class="source-inline">print(record.name</strong><strong class="bold"> or "None"</strong><strong class="source-inline">)</strong>.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor207"/>Accessing relational fields</h2>
			<p>As we saw earlier, models can<a id="_idIndexMarker543"/> have relational fields—<strong class="bold">many-to-one</strong>, <strong class="bold">one-to-many</strong>, and <strong class="bold">many-to-many</strong>. These field types have recordsets as values.</p>
			<p>In the case of many-to-one fields, the value can be a singleton or an empty recordset. In both cases, we can directly access their field values. As an example, the following instructions are correct and safe:</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id</p>
			<p class="source-code">res.company(1,)</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id.name</p>
			<p class="source-code">'YourCompany'</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id.currency_id</p>
			<p class="source-code">res.currency(1,)</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id.currency_id.name</p>
			<p class="source-code">'EUR'</p>
			<p>An empty recordset conveniently also behaves like a singleton, and accessing its fields does not return an error but just returns <strong class="source-inline">False</strong>. Because of this, we can traverse records using dot-notation without worrying about errors from empty values, as shown here:</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id.parent_id</p>
			<p class="source-code">res.company()</p>
			<p class="source-code">&gt;&gt;&gt; self.company_id.parent_id.name</p>
			<p class="source-code">False</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor208"/>Accessing date and time values</h2>
			<p>In recordsets, <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> values<a id="_idIndexMarker544"/> are represented as native Python objects. For example, when <a id="_idIndexMarker545"/>we look up the last login date for the <strong class="source-inline">admin</strong> user:</p>
			<p class="source-code">&gt;&gt;&gt; self.browse(2).login_date</p>
			<p class="source-code">datetime.datetime(2021, 11, 2, 16, 47, 57, 327756)</p>
			<p>Since the <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> values are Python objects, they have all of the manipulation features available for these objects.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> field values are now represented as Python objects, unlike previous Odoo versions, where the <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> values were represented as text strings. These field type values can still be set using text representations in the same way as previous Odoo versions.</p>
			<p>Dates and times are<a id="_idIndexMarker546"/> stored in the database in a native <strong class="bold">Coordinated Universal Time</strong> (<strong class="bold">UTC</strong>) format, which is not time zone-aware. The <strong class="source-inline">datetime</strong> values seen on recordsets are also in UTC. When presented to the user by the web client, the <strong class="source-inline">datetime</strong> values are converted into the user's time zone by using the current session's time zone setting that is stored in the context <strong class="source-inline">tz</strong> key, for example, <strong class="source-inline">{'tz': 'Europe/Brussels'}</strong>. This conversion is a web client responsibility, as it isn't done by the server.</p>
			<p>For example, an 11:00 AM datetime value entered by a Brussels (UTC+1) user is stored in the database as 10:00 AM UTC, and will be seen by a New York (UTC-4) user as 06:00 AM. The Odoo server log message timestamps use the UTC time and not the local server time.</p>
			<p>The opposite conversion—from the session time zone to UTC—also needs to be done by the web client when sending the user's <strong class="source-inline">datetime</strong> input back to the server.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that the date and time data stored in the database and handled by the server code is always represented in UTC. Even the server log message timestamps are represented in UTC.</p>
			<p>We have now reviewed the details of how to access record data. However, our application will provide some automation for business processes, so inevitably we will also need to write to recordsets. Let's look at this in detail in the next section.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor209"/>Writing to records</h1>
			<p>We have two different <a id="_idIndexMarker547"/>ways to write to records: using the object-style direct assignment or using the <strong class="source-inline">write()</strong> method. The <strong class="source-inline">write()</strong> method is the low-level method in charge of performing write operations, and it is still used directly when using the external API or when loading XML records. The object-style direct assignment was added later into the ORM model. It implements the <strong class="bold">active record</strong> pattern and can be used in Python code logic.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">In Odoo 13, the ORM model introduced a new database writing approach called <strong class="bold">in-memory ORM</strong>. In previous<a id="_idIndexMarker548"/> Odoo versions, every write would immediately generate the corresponding database SQL command, and this came with a performance penalty, especially when complex interdependencies caused repeated updates on the same records. Since Odoo 13, these operations are instead saved in a memory cache, and at the end of the transaction, the new <strong class="source-inline">flush()</strong> method is automatically called to perform the corresponding database operations in a single go.</p>
			<p>Next, we will look at both of these methods and their differences.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Using object-style value assignments</h2>
			<p>Recordsets implement the <strong class="bold">active record pattern</strong>. This means that we can assign values to them and these changes<a id="_idIndexMarker549"/> will be made persistent in the database. This is an intuitive and convenient way to manipulate data.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Assigning values to a recordset with more than one record is supported as of Odoo 13. Up to Odoo 12, only writing values to single records was supported, and the <strong class="source-inline">write()</strong> method had to be used to write to multiple records.</p>
			<p>Here is an example:</p>
			<p class="source-code">&gt;&gt;&gt; root = self.env["res.users"].browse(1)</p>
			<p class="source-code">&gt;&gt;&gt; print(root.name) </p>
			<p class="source-code">System</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">root.name = "Superuser"</strong></p>
			<p class="source-code">&gt;&gt;&gt; print(root.name) </p>
			<p class="source-code">Superuser</p>
			<p>When using the <em class="italic">active record</em> pattern, the value of relational fields can be set by assigning a recordset.</p>
			<p>Date and time fields can be assigned values as either Python native objects or string representations in the Odoo default format:</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import date</p>
			<p class="source-code">&gt;&gt;&gt; self.date = date(2020, 12, 1)</p>
			<p class="source-code">&gt;&gt;&gt; self.date</p>
			<p class="source-code">datetime.date(2020, 12, 1)</p>
			<p class="source-code">&gt;&gt;&gt; self.date = "2020-12-02"</p>
			<p class="source-code">&gt;&gt;&gt; self.date</p>
			<p class="source-code">datetime.date(2020, 12, 2)</p>
			<p>Binary fields should be assigned <strong class="source-inline">base64</strong> encoded values. For example, when having raw binary data read from a file, that value must be converted using <strong class="source-inline">base64.b64encode()</strong> before being assigned to a field:</p>
			<p class="source-code">&gt;&gt;&gt; import base64</p>
			<p class="source-code">&gt;&gt;&gt; blackdot_binary = b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x04\x00\x00\x00\xb5\x1c\x0c\x02\x00\x00\x00\x0bIDATx\xdacd\xf8\x0f\x00\x01\x05\x01\x01'\x18\xe3f\x00\x00\x00\x00IEND\xaeB'\x82"</p>
			<p class="source-code">&gt;&gt;&gt; self.image_1920 = base64.b64encode(blackdot_binary).decode("utf-8")</p>
			<p>When assigning values on<a id="_idIndexMarker550"/> many-to-one fields, the value assigned must be a single record (that is, a <strong class="bold">singleton recordset</strong>).</p>
			<p>For to-many fields, the value can also be assigned with a recordset, replacing the list of linked records (if any) with a new one. Here, a recordset of any size is allowed.</p>
			<p>To set an empty value on a relational field, set it with <strong class="source-inline">None</strong> or <strong class="source-inline">False</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; self.child_ids = None</p>
			<p class="source-code">&gt;&gt;&gt; self.child_ids</p>
			<p class="source-code">res.partner()</p>
			<p>To append or remove a record on the assigned list, use the record manipulation operations.</p>
			<p>For example, imagine a company record also has a related partner record that is used to hold address details. Suppose that we want to add the current user as a company child contact. This can be done with the following:</p>
			<p class="source-code">&gt;&gt;&gt; mycompany_partner = self.company_id.partner_id</p>
			<p class="source-code">&gt;&gt;&gt; myaddress = self.partner_id</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">mycompany_partner.child_ids = mycompany_partner.child_ids | myaddress</strong></p>
			<p>Here, the pipe operator (<strong class="source-inline">|</strong>) was used to join a record to obtain a larger recordset.</p>
			<p>The compact append and assign operator (<strong class="source-inline">|=</strong>) could have been used for the same effect:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">mycompany_partner.child_ids |= myaddress</strong></p>
			<p>More details on record <a id="_idIndexMarker551"/>manipulation operations are given later in this chapter in the <em class="italic">Composing recordsets</em> section.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor211"/>Using the write() method</h2>
			<p>The <strong class="source-inline">write()</strong> method can<a id="_idIndexMarker552"/> also be used to update data in records. It accepts a dictionary with the field names and values to assign. It can be more convenient to use in some cases, for example, where the dictionary is prepared first, and the assignment is performed later. It is also useful in older versions of Odoo (up to Odoo 12) for cases where direct assignment can't be used.</p>
			<p>The <strong class="source-inline">write()</strong> method receives a dictionary with the fields and values to assign and updates the recordset with them:</p>
			<p class="source-code">&gt;&gt;&gt; Partner = self.env['res.partner']</p>
			<p class="source-code">&gt;&gt;&gt; recs = Partner.search( [("name", "ilike", "Azure")])</p>
			<p class="source-code">&gt;&gt;&gt; recs.write({"comment": "Hello!"})</p>
			<p class="source-code">True</p>
			<p>Date and time fields can be assigned with values of the corresponding Python objects or by using string text representations, just like with object-style assignments.</p>
			<p>Since Odoo 13, <strong class="source-inline">write()</strong> can use recordsets to set values on to-one and to-many relational fields, just like with object-style assignments.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">The <strong class="source-inline">write()</strong> method can use recordsets to assign values on relational fields. Up to Odoo 12, many-to-one fields were set using an ID value, and to-many fields were set using a special syntax, for example, <strong class="source-inline">(4, &lt;id&gt;, _)</strong> to add a record and <strong class="source-inline">(6, 0, [&lt;ids&gt;])</strong> to set the full record list. This syntax is discussed in more detail in <a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Importing, Exporting, and Module Data</em>.</p>
			<p>For example, suppose we have two Partner records, <strong class="source-inline">address1</strong> and <strong class="source-inline">address2</strong>, and we want to set them on the <strong class="source-inline">self.child_ids</strong> field.</p>
			<p>Using the <strong class="source-inline">write()</strong> method, we would use the following:</p>
			<p class="source-code">self.write({ 'child_ids': address1 | address2})</p>
			<p>Another option (needed for versions before Odoo 13) is as follows:</p>
			<p class="source-code">self.write({ 'child_ids': [(6, 0, [address1.id, address2.id])]})</p>
			<p>The <strong class="source-inline">write()</strong> method <a id="_idIndexMarker553"/>is used to write dates on existing records. But we also need to create and delete records, which we will discuss in the next section.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor212"/>Creating and deleting records</h2>
			<p>The <strong class="source-inline">create()</strong> and <strong class="source-inline">unlink()</strong> model methods allow us to create and delete existing records, respectively.</p>
			<p>The <strong class="source-inline">create()</strong> method<a id="_idIndexMarker554"/> takes <a id="_idIndexMarker555"/>a dictionary with the fields and values for the record to be created, using the same syntax as <strong class="source-inline">write()</strong>. Default values are automatically applied as expected, as shown in this example:</p>
			<p class="source-code">&gt;&gt;&gt; Partner = self.env['res.partner']</p>
			<p class="source-code">&gt;&gt;&gt; new = <strong class="bold">Partner.create({'name': 'ACME', 'is_company': True})</strong></p>
			<p class="source-code">&gt;&gt;&gt; print(new)</p>
			<p class="source-code">res.partner(59,)</p>
			<p>The <strong class="source-inline">unlink()</strong> method<a id="_idIndexMarker556"/> deletes the<a id="_idIndexMarker557"/> records in the recordset, as done in the next example:</p>
			<p class="source-code">&gt;&gt;&gt; rec = Partner.search([('name', '=', 'ACME')])</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">rec.unlink()</strong></p>
			<p class="source-code">2021-11-15 18:40:10,090 3756 INFO library odoo.models.unlink: User #1 deleted mail.message records with IDs: [20]</p>
			<p class="source-code">2021-11-15 18:40:10,146 3756 INFO library odoo.models.unlink: User #1 deleted res.partner records with IDs: [59]</p>
			<p class="source-code">2021-11-15 18:40:10,160 3756 INFO library odoo.models.unlink: User #1 deleted mail.followers records with IDs: [9]</p>
			<p class="source-code">True</p>
			<p>The <strong class="source-inline">unlink()</strong> method returns a <strong class="source-inline">True</strong> value. Also, during the <strong class="source-inline">delete</strong> operation, it triggers log messages informing<a id="_idIndexMarker558"/> the cascade deletion of related records, such as Chatter messages and followers.</p>
			<p>Another way to create a<a id="_idIndexMarker559"/> record is to duplicate an existing one. The <strong class="source-inline">copy()</strong> model method<a id="_idIndexMarker560"/> is available for this. It accepts an optional argument with a dictionary, which contains values to override when creating the new record.</p>
			<p>For example, to create a new user from the <strong class="source-inline">demo</strong> user, we could use the following:</p>
			<p class="source-code">&gt;&gt;&gt; demo = self.env.ref("base.user_demo")</p>
			<p class="source-code">&gt;&gt;&gt; new = demo.copy({"name": "John", "login": "john@example.com"})</p>
			<p>The fields with the <strong class="source-inline">copy=False</strong> attribute won't be automatically copied. To-many relational fields have this flag disabled by default, so they won't be copied.</p>
			<p>In the previous sections, we have learned how to access data in recordsets and create and write to recordsets. However, there are some field types that deserve more attention. In the next section, we will discuss specific techniques for working with date and time fields.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor213"/>Working with date and time fields</h1>
			<p>In the <em class="italic">Accessing data in recordsets</em> section, we saw how to read date and time values from records. It is<a id="_idIndexMarker561"/> common to also need to perform date calculations and to convert<a id="_idIndexMarker562"/> dates between their native format and string representations. Here, we will see how to perform these kinds of operations.</p>
			<p>Odoo provides a few useful functions to create new date and time objects.</p>
			<p>The <strong class="source-inline">odoo.fields.Date</strong> object provides these helper functions:</p>
			<ul>
				<li>The <strong class="source-inline">fields.Date.today()</strong> function<a id="_idIndexMarker563"/> returns a string with the current date in the format expected by the server, using UTC as a reference. This is adequate to compute default values. It can be used directly in a date field definition by using <strong class="source-inline">default=fields.Date.today</strong>.</li>
				<li>The <strong class="source-inline">fields.Date.context_today(record, timestamp=None)</strong> function returns a string with the current date in the session's context. The time zone value is taken from the record's context. The optional <strong class="source-inline">timestamp</strong> parameter is a <strong class="source-inline">datetime</strong> object and will be used instead of the current time if provided.</li>
			</ul>
			<p>The <strong class="source-inline">odoo.fields.Datetime</strong> objects provide these datetime creation functions:</p>
			<ul>
				<li>The <strong class="source-inline">fields.Datetime.now()</strong> function <a id="_idIndexMarker564"/>returns a string with the current <strong class="source-inline">datetime</strong> in the format expected by the server, using UTC as a reference. This is adequate to compute default values. It can be used directly in a <strong class="source-inline">datetime</strong> field definition by using <strong class="source-inline">default=fields.Datetime.now</strong>.</li>
				<li>The <strong class="source-inline">fields.Datetime.context_timestamp(record, timestamp)</strong> function converts a naive <strong class="source-inline">datetime</strong> value (without time zone) into a time zone-aware <strong class="source-inline">datetime</strong> value. The time zone is extracted from the record's context, hence the name of the function.</li>
			</ul>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor214"/>Adding and subtracting time</h2>
			<p>Date objects can<a id="_idIndexMarker565"/> be compared and subtracted to find the time elapsed between both dates. This time elapsed is a <strong class="source-inline">timedelta</strong> object. A <strong class="source-inline">timedelta</strong> object can be added to or subtracted from <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> objects, performing date arithmetic.</p>
			<p>These objects are provided by the Python standard library <strong class="source-inline">datetime</strong> module. Here is a sample of the essential operations we can do with them:</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import date</p>
			<p class="source-code">&gt;&gt;&gt; date.today()</p>
			<p class="source-code">datetime.date(2021, 11, 3)</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import timedelta</p>
			<p class="source-code">&gt;&gt;&gt; date(2021, 11, 3) + timedelta(days=7)</p>
			<p class="source-code">datetime.date(2021, 11, 10)</p>
			<p>A full reference for the <strong class="source-inline">date</strong>, <strong class="source-inline">datetime</strong>, and <strong class="source-inline">timedelta</strong> data types can be found at <a href="https://docs.python.org/3/library/datetime.html">https://docs.python.org/3/library/datetime.html</a>.</p>
			<p>The <strong class="source-inline">timedelta</strong> object supports weeks, days, hours, seconds, and more. But it doesn't support years or months.</p>
			<p>To perform date<a id="_idIndexMarker566"/> arithmetic using months or years, we should use the <strong class="source-inline">relativedelta</strong> object. Here is an example of adding one year and one month:</p>
			<p class="source-code">&gt;&gt;&gt; from dateutil.relativedelta import relativedelta</p>
			<p class="source-code">&gt;&gt;&gt; date(2021, 11, 3) + relativedelta(years=1, months=1)</p>
			<p class="source-code">datetime.date(2022, 12, 3)</p>
			<p>The <strong class="source-inline">relativedelta</strong> object supports advanced date arithmetic, including leap years and Easter calculations. The documentation for it can be found at <a href="https://dateutil.readthedocs.io">https://dateutil.readthedocs.io</a>.</p>
			<p>Odoo also provides a few additional functions in the <strong class="source-inline">odoo.tools.date_utils</strong> module:</p>
			<ul>
				<li>The <strong class="source-inline">start_of(value, granularity)</strong> function returns the start of a time period with the specified granularity, which is a string value with one of <strong class="source-inline">year</strong>, <strong class="source-inline">quarter</strong>, <strong class="source-inline">month</strong>, <strong class="source-inline">week</strong>, <strong class="source-inline">day</strong>, or <strong class="source-inline">hour</strong>.</li>
				<li>The <strong class="source-inline">end_of(value, granularity)</strong> function returns the end of a time period with the specified granularity.</li>
				<li>The <strong class="source-inline">add(value, **kwargs)</strong> function adds a time interval to the given value. The <strong class="source-inline">**kwargs</strong> arguments are to be used by a <strong class="source-inline">relativedelta</strong> object to define the time interval. These arguments can be <strong class="source-inline">years</strong>, <strong class="source-inline">months</strong>, <strong class="source-inline">weeks</strong>, <strong class="source-inline">days</strong>, <strong class="source-inline">hours</strong>, <strong class="source-inline">minutes</strong>, and so on.</li>
				<li>The <strong class="source-inline">subtract(value, **kwargs)</strong> function subtracts a time interval from the given value. </li>
			</ul>
			<p>These utility functions are also exposed in the <strong class="source-inline">odoo.fields.Date</strong> and the <strong class="source-inline">odoo.fields.Datetime</strong> objects.</p>
			<p>Here are a few examples using the previous functions:</p>
			<p class="source-code">&gt;&gt;&gt; from odoo.tools import date_utils</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import datetime</p>
			<p class="source-code">&gt;&gt;&gt; now = datetime(2020, 11, 3, 0, 0, 0)</p>
			<p class="source-code">&gt;&gt;&gt; date_utils.start_of(now, 'week')</p>
			<p class="source-code">datetime.datetime(2020, 11, 2, 0, 0)</p>
			<p class="source-code">&gt;&gt;&gt; date_utils.end_of(now, 'week')</p>
			<p class="source-code">datetime.datetime(2020, 11, 8, 23, 59, 59, 999999)</p>
			<p class="source-code">&gt;&gt;&gt; today = date(2020, 11, 3)</p>
			<p class="source-code">&gt;&gt;&gt; date_utils.add(today, months=2)</p>
			<p class="source-code">datetime.date(2021, 1, 3)</p>
			<p class="source-code">&gt;&gt;&gt; date_utils.subtract(today, months=2)</p>
			<p class="source-code">datetime.date(2020, 9, 3)</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor215"/>Converting date and time objects to text representations</h2>
			<p>There will<a id="_idIndexMarker567"/> be cases where we need to <a id="_idIndexMarker568"/>convert a Python <strong class="source-inline">date</strong> object into a text representation. This may be needed, for example, to prepare a user message or to format data to send to another system.</p>
			<p>The Odoo field objects provide helper functions to convert the native Python objects to string representations:</p>
			<ul>
				<li>The <strong class="source-inline">fields.Date.to_string(value)</strong> function converts a <strong class="source-inline">date</strong> object into a string in the format expected by the Odoo server.</li>
				<li>The <strong class="source-inline">fields.Datetime.to_string(value)</strong> function converts a <strong class="source-inline">datetime</strong> object into a string in the format expected by the Odoo server.</li>
			</ul>
			<p>These use the Odoo server predefined defaults, which are defined in the following constants:</p>
			<ul>
				<li><strong class="source-inline">odoo.tools.DEFAULT_SERVER_DATE_FORMAT</strong></li>
				<li><strong class="source-inline">odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT</strong></li>
			</ul>
			<p>These map to <strong class="source-inline">%Y-%m-%d</strong> and <strong class="source-inline">%Y-%m-%d %H:%M:%S</strong>, respectively.</p>
			<p>The <strong class="source-inline">date.strftime</strong> and <strong class="source-inline">datetime.strftime</strong> functions accept a format string parameter<a id="_idIndexMarker569"/> that can be used for other<a id="_idIndexMarker570"/> conversions to text.</p>
			<p>For example, consider the following:</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import date</p>
			<p class="source-code">&gt;&gt;&gt; date(2020, 11, 3).strftime("%d/%m/%Y")</p>
			<p class="source-code">'03/11/2020'</p>
			<p>Further details on the available format codes can be found at <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</a>.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor216"/>Converting text-represented dates and times</h2>
			<p>There are cases where dates <a id="_idIndexMarker571"/>arrive formatted as text strings and need to be converted to Python <strong class="source-inline">date</strong> or <strong class="source-inline">datetime</strong> objects. This was frequently needed up to Odoo 11, where stored dates were read as text representations. Some tools are provided to help with this conversion from text into native data types and then back into text.</p>
			<p>To facilitate this conversion between formats, the <strong class="source-inline">fields.Date</strong> and <strong class="source-inline">fields.Datetime</strong> objects provide these functions:</p>
			<ul>
				<li>The <strong class="source-inline">fields.Date.to_date</strong> function converts a string into a <strong class="source-inline">date</strong> object.</li>
				<li>The <strong class="source-inline">fields.Datetime.to_datetime(value)</strong> function converts a string into a <strong class="source-inline">datetime</strong> object.</li>
			</ul>
			<p>An example of a usage of <strong class="source-inline">to_datetime</strong> is as follows:</p>
			<p class="source-code">&gt;&gt;&gt; from odoo import fields</p>
			<p class="source-code">&gt;&gt;&gt; fields.Datetime.to_datetime("2020-11-21 23:11:55")</p>
			<p class="source-code">datetime.datetime(2020, 11, 21, 23, 11, 55)</p>
			<p>The preceding example uses the Odoo internal date format to parse the provided string and convert it into a Python <strong class="source-inline">datetime</strong> object.</p>
			<p>For other date and time formats, the <strong class="source-inline">strptime</strong> method from the <strong class="source-inline">date</strong> and <strong class="source-inline">datetime</strong> object can be used:</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import datetime</p>
			<p class="source-code">&gt;&gt;&gt; datetime.strptime("03/11/2020", "%d/%m/%Y")</p>
			<p class="source-code">datetime.datetime(2020, 11, 3, 0, 0)</p>
			<p>In most cases, the<a id="_idIndexMarker572"/> text-represented time will not be in UTC, as expected by the Odoo server. The time must be converted to UTC before it can be stored in the Odoo database.</p>
			<p>For example, if the user is in the Europe/Brussels timezone (at +1:00 hours from UTC) the <strong class="source-inline">2020-12-01 00:30:00</strong> user time should be stored in UTC as <strong class="source-inline">2020-11-30 23:30:00</strong>. Here is the code recipe for this:</p>
			<p class="source-code">&gt;&gt;&gt; from datetime import datetime</p>
			<p class="source-code">&gt;&gt;&gt; import pytz</p>
			<p class="source-code">&gt;&gt;&gt; naive_date = datetime(2020, 12, 1, 0, 30, 0)</p>
			<p class="source-code">&gt;&gt;&gt; client_tz = self.env.context["tz"]</p>
			<p class="source-code">&gt;&gt;&gt; client_date = pytz.timezone(client_tz).localize(naive_date)</p>
			<p class="source-code">&gt;&gt;&gt; utc_date = client_date.astimezone(pytz.utc)</p>
			<p class="source-code">&gt;&gt;&gt; print(utc_date)</p>
			<p class="source-code">2020-11-30 23:30:00+00:00</p>
			<p>This code gets the user time zone name from the context and then uses it to convert the naive date to a time zone-aware date. The final step is to convert the client time zone date to a UTC date by using <strong class="source-inline">astimezone(pytz.utc)</strong>.</p>
			<p>We've now learned specific techniques to work with date and time in Odoo. There are also specific techniques to work with recordsets and the values stored in relational fields, which we'll discuss in the next section.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor217"/>Working with recordsets</h1>
			<p>A <strong class="bold">recordset</strong> is a <a id="_idIndexMarker573"/>collection of records, and Python business logic frequently needs to use them. There are several operations that can be performed on recordsets, such as mapping and filtering. We can also compose new recordsets by adding or removing records. Other common operations are inspecting the contents of a recordset to check if a particular record is there or not, for example.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">Since Odoo 10, recordset manipulation has preserved the record order. This is unlike previous Odoo versions, where recordset manipulation was not guaranteed to preserve the record order, although addition and slicing maintained the record order.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor218"/>Recordset operations</h2>
			<p>Recordsets have a <a id="_idIndexMarker574"/>few functions available to perform useful actions on them, such as <strong class="bold">sorting</strong> or <strong class="bold">filtering records</strong>.</p>
			<p>These are the supported functions and attributes:</p>
			<ul>
				<li>The <strong class="source-inline">recordset.ids</strong> attribute returns a list with the IDs of the recordset elements.</li>
				<li>The <strong class="source-inline">recordset.ensure_one()</strong> function checks whether it's a single record (that is, a singleton); if it's not, a <strong class="source-inline">ValueError</strong> exception is raised.</li>
				<li>The <strong class="source-inline">recordset.filtered(&lt;function or str&gt;)</strong> function returns a filtered recordset, and this function is a test function to filter records. The argument can instead be a string containing a dot-separated sequence of fields to evaluate. The records evaluating to a truthy value are selected.</li>
				<li>The <strong class="source-inline">recordset.mapped(&lt;function or str&gt;)</strong> function returns a list of values, and the function returns a value for each record. The argument can instead be a string containing a dot-separated sequence of fields to evaluate to reach the field to return. To-many relations are safe to use in the field sequence.</li>
				<li>The <strong class="source-inline">recordset.sorted(&lt;function ot str&gt;)</strong> function returns the recordset with a specific element order. The function returns a value for each record, which are used to sort the recordset. The argument can instead be a string with the name of the field to sort by. Note that a dot-notation sequence of fields is not<a id="_idIndexMarker575"/> allowed. An optional <strong class="source-inline">reverse=True</strong> argument is also available.</li>
			</ul>
			<p>Here are some usage examples for these functions:</p>
			<p class="source-code">&gt;&gt;&gt; rs0 = self.env["res.partner"].search([("display_name", "like", "Azure")])</p>
			<p class="source-code">&gt;&gt;&gt; len(rs0)  # how many records?</p>
			<p class="source-code">4</p>
			<p class="source-code">&gt;&gt;&gt; rs0.filtered(lambda r: r.name.startswith("Nicole"))</p>
			<p class="source-code">res.partner(27,)</p>
			<p class="source-code">&gt;&gt;&gt; rs0.filtered("is_company")</p>
			<p class="source-code">res.partner(14,)</p>
			<p class="source-code">&gt;&gt;&gt; rs0.mapped("name")</p>
			<p class="source-code">['Azure Interior', 'Brandon Freeman', 'Colleen Diaz', 'Nicole Ford']</p>
			<p class="source-code">&gt;&gt;&gt; rs0.sorted("name", reverse=True).mapped("name")</p>
			<p class="source-code">['Nicole Ford', 'Colleen Diaz', 'Brandon Freeman', 'Azure Interior']</p>
			<p class="source-code">&gt;&gt;&gt; rs0.mapped(lambda r: (r.id, r.name))</p>
			<p class="source-code">[(14, 'Azure Interior'), (26, 'Brandon Freeman'), (33, 'Colleen Diaz'), (27, 'Nicole Ford')]</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor219"/>The composition of a recordset</h2>
			<p>Recordsets <a id="_idIndexMarker576"/>are immutable, meaning that their values can't be directly modified. Instead, we can compose a new recordset based on existing ones. <strong class="bold">Slice notation</strong>, which is<a id="_idIndexMarker577"/> commonly used with Python lists, can be used on recordsets to extract a subset of the records. Here are a few examples:</p>
			<ul>
				<li><strong class="source-inline">rs[0]</strong> and <strong class="source-inline">rs[-1]</strong> retrieve the first element and the last element, respectively.</li>
				<li><strong class="source-inline">rs[1:]</strong> results in a copy of the recordset without the first element.</li>
				<li><strong class="source-inline">rs[:1]</strong> returns the first element of the recordset.<p class="callout-heading">Tip</p><p class="callout">For a fail-safe way to retrieve the first element of a recordset, use <strong class="source-inline">rs[:1]</strong> instead of <strong class="source-inline">rs[0]</strong>. The latter results in an error if <strong class="source-inline">rs</strong> is empty, whereas the former will just return an empty recordset in this case. Another option is to use the <strong class="source-inline">first()</strong> function from the <strong class="source-inline">odoo.fields</strong> module: <strong class="source-inline">fields.first(rs)</strong>.</p></li>
			</ul>
			<p>Recordsets also<a id="_idIndexMarker578"/> support the following set operations:</p>
			<ul>
				<li>The  <strong class="source-inline">rs1 | rs2</strong> operation is a <em class="italic">union</em> set operation and results in a recordset with all elements from both recordsets. This is a set-like operation and won't result in duplicate elements. </li>
				<li>For example, <strong class="source-inline">self.env.user | self.env.user</strong> returns a single record, such as <strong class="source-inline">res.users(1,)</strong>.</li>
				<li>The  <strong class="source-inline">rs1 &amp; rs2</strong> operation is an <em class="italic">intersection</em> set operation and results in a recordset with only the elements present in both recordsets.</li>
				<li>The  <strong class="source-inline">rs1 - rs2</strong> operation is a <em class="italic">difference</em> set operation and results in a recordset with the <strong class="source-inline">rs1</strong> elements not present in <strong class="source-inline">rs2</strong>.<p class="callout-heading">Tip</p><p class="callout">Recordsets also support the addition operation (<strong class="source-inline">+</strong>), however, it should be avoided. It has a different behavior from the union operation (<strong class="source-inline">|</strong>) and allows for duplicate elements in a recordset. However, this is rarely what we want. For example, <strong class="source-inline">self.env.user + self.env.user</strong> returns two records, such as <strong class="source-inline">res.users(1, 1)</strong>.</p></li>
			</ul>
			<p>We can use these <a id="_idIndexMarker579"/>operations directly with a value assignment for shorter notation:</p>
			<ul>
				<li>The <strong class="source-inline">self.author_ids |= author1</strong> operation adds the <strong class="source-inline">author1</strong> record if it is not in the recordset.</li>
				<li>The <strong class="source-inline">self.author_ids &amp;= author1</strong> operation keeps only the records also present in the <strong class="source-inline">author1</strong> recordset.</li>
				<li>The <strong class="source-inline">self.author_ids -= author1</strong> operation removes the specific <strong class="source-inline">author1</strong> record if it is present in the recordset.</li>
			</ul>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor220"/>Recordset accumulation</h2>
			<p>In some cases, we<a id="_idIndexMarker580"/> want to loop through some logic and accumulate records resulting from each iteration of the loop. The ORM way to accumulate a recordset is to start with an empty recordset and then add records to it. To get an empty recordset, create a reference to the model. For example, consider the following:</p>
			<p class="source-code">Partner = self.env["res.partner"]</p>
			<p class="source-code">recs = self.env["res.partner"]</p>
			<p class="source-code">for i in range(3):</p>
			<p class="source-code">    rec = Partner.create({"name": "Partner %s" % i})</p>
			<p class="source-code">    recs |= rec</p>
			<p>The previous code loops three times and on each loop it creates a new partner record before accumulating it to the <strong class="source-inline">recs</strong> recordset. As it is a recordset, the <strong class="source-inline">recs</strong> variable can be used in cases where recordsets are expected, such as assigning a value to a to-many field.</p>
			<p>However, accumulating recordsets is not time-efficient and should be avoided inside loops. The reason for this is that Odoo recordsets are immutable objects and any operation on a recordset implies copying it to get the modified version. When appending a record to a recordset, the original recordset is not modified. Instead, a copy of it is made with the record appended to it. This copy operation consumes time, and the larger the recordset is, the longer it takes.</p>
			<p>As a result, alternatives should be considered. For the preceding example, we could have accumulated all of the record data dictionaries in a Python list and then made a single <strong class="source-inline">create()</strong> call to create all of the records. This is possible because the <strong class="source-inline">create()</strong> method can accept a list of dictionaries.</p>
			<p>So, the loop could look like this:</p>
			<p class="source-code">values = []</p>
			<p class="source-code">for i in range(3):</p>
			<p class="source-code">    value = {"name": "Partner %s" % i}</p>
			<p class="source-code">    values.append(value)</p>
			<p class="source-code">recs = self.env["res.partner"].create(values)</p>
			<p>However, this <a id="_idIndexMarker581"/>solution won't work in all cases. Another option is to use a Python list to accumulate records. Python lists are mutable objects, and appending elements is an efficient operation for them. As Python lists are not actually recordsets, this option can't be used where a recordset is expected, for example, an assignment to a to-many field.</p>
			<p>The following is an example of accumulating records to a Python list:</p>
			<p class="source-code">Partner = self.env["res.partner"]</p>
			<p class="source-code">recs = []</p>
			<p class="source-code">for i in range(3):</p>
			<p class="source-code">    rec = Partner.create({"name": "Partner %s" % i})</p>
			<p class="source-code">    recs.append(new_rec)</p>
			<p>The previous examples illustrate a few techniques that can be used in loops to build recordsets from individual elements. However, there are many cases where the loop is not strictly needed and operations such as <strong class="source-inline">mapped()</strong> and <strong class="source-inline">filtered()</strong> can provide more efficient ways to achieve the desired aim.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor221"/>Recordset comparisons</h2>
			<p>There are<a id="_idIndexMarker582"/> cases where we need to compare the content of a recordset to decide what further action is needed. Recordsets support the expected comparison operations.</p>
			<p>To check if a <strong class="source-inline">&lt;rec&gt;</strong> record is an element of a <strong class="source-inline">&lt;my_recordset&gt;</strong> recordset, the following code can be used:</p>
			<ul>
				<li><strong class="source-inline">&lt;rec&gt; in &lt;my_recordset&gt;</strong></li>
				<li><strong class="source-inline">&lt;rec&gt; not in &lt;my_recordset&gt;</strong></li>
			</ul>
			<p>Recordsets can also be compared to check if one is contained in another. To compare two recordsets, use <strong class="source-inline">set1</strong> and <strong class="source-inline">set2</strong>:</p>
			<ul>
				<li>Using <strong class="source-inline">set1 &lt;= set2</strong> and <strong class="source-inline">set1 &lt; set2</strong> returns <strong class="source-inline">True</strong> if all of the elements in <strong class="source-inline">set1</strong> are also in <strong class="source-inline">set2</strong>. The <strong class="source-inline">&lt;</strong> operators return <strong class="source-inline">False</strong> if both recordsets have the same elements.</li>
				<li>Using <strong class="source-inline">set1 &gt;= set2</strong> and <strong class="source-inline">set1 &gt; set2</strong> returns <strong class="source-inline">True</strong> if all of the elements in <strong class="source-inline">set2</strong> are also in <strong class="source-inline">set1</strong>. The <strong class="source-inline">&gt;</strong> operators return <strong class="source-inline">False</strong> if both recordsets have the same elements.</li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor222"/>Transactions and low-level SQL</h1>
			<p>ORM methods that are called from a client run in a <em class="italic">transaction</em>. Transactions ensure correctness in the case of concurrent <a id="_idIndexMarker583"/>writes or failures. During a transaction, the data records used are locked, protecting them from other concurrent transactions and ensuring that they are not unexpectedly changed. In case of failure, all the transaction changes are rolled back, returning to the initial state.</p>
			<p>Transaction support is provided by the <a id="_idIndexMarker584"/>PostgreSQL database. When an ORM method is called from a client, a new transaction is initiated. If an error occurs during the method execution, any changes that have been made are reverted. If the method execution completes with no errors, then the changes made are committed, making them effective and visible to all other transactions.</p>
			<p>This is automatically handled for us, and we usually don't need to worry about it. However, in some advanced use cases, it might be useful to have control over the current transaction.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Since Odoo 13, database write operations are not done while the method is running. Instead, they accumulate in a memory cache, and the actual database writing is delayed to the end of the execution of the method, which is performed by a <strong class="source-inline">flush()</strong> call that is invoked automatically at that point.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor223"/>Controlling database transactions</h2>
			<p>There are cases where<a id="_idIndexMarker585"/> controlling the transaction can be useful and the <strong class="source-inline">self.env.cr</strong> database cursor can be used for this. An example of this is looping through records to perform an operation on each of them, where we want to skip the ones with operation errors without affecting the other ones.</p>
			<p>For this, the object provides the following:</p>
			<ul>
				<li><strong class="source-inline">self.env.cr.commit()</strong> commits the transaction's buffered write operations, making them effective in the database.</li>
				<li><strong class="source-inline">self.env.cr.rollback()</strong> cancels the transaction's <strong class="source-inline">write</strong> operations since the last commit or all of them if no commit was made.<p class="callout-heading">Tip</p><p class="callout">An Odoo <strong class="source-inline">shell</strong> session mimics a method execution context. This means that the database writes are not performed until <strong class="source-inline">self.env.cr.commit()</strong> is called.</p></li>
			</ul>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor224"/>Executing raw SQL</h2>
			<p>SQL can be run<a id="_idIndexMarker586"/> directly in the database by using the cursor <strong class="source-inline">execute()</strong> method. This takes a string with the SQL statement to run and a second optional argument with the values to use as parameters for the SQL.</p>
			<p>The values parameter can be a tuple or a dict. When using a tuple, the parameters are replaced with <strong class="source-inline">%s</strong>, and when using a dict, they are replaced with <strong class="source-inline">%(&lt;name&gt;)s</strong>. Here are examples of both approaches:</p>
			<p class="source-code">&gt;&gt;&gt; self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%s OR id=%s", ("demo", 1))</p>
			<p class="source-code">&gt;&gt;&gt; self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%(login)s OR id=%(id)s", {"login": "demo", "id": 1})</p>
			<p>Any of the previous instructions run the SQL, replacing the parameters and preparing a cursor with the results that needs to be fetched. More details on this can be found in the <strong class="source-inline">psycopg2</strong> documentation at <a href="https://www.psycopg.org/docs/usage.html#query-parameters">https://www.psycopg.org/docs/usage.html#query-parameters</a>.</p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">With <strong class="source-inline">cr.execute()</strong>, we should not directly compose the SQL query concatenating parameters. Doing so is known to be a security risk that can be exploited through SQL injection attacks. Always use the <strong class="source-inline">%s</strong> placeholders with the second parameter to pass values.</p>
			<p>To fetch the results, the <strong class="source-inline">fetchall()</strong> function can be used, returning the rows' <strong class="source-inline">tuples</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; self.env.cr.fetchall()</p>
			<p class="source-code">[(6, 'demo'), (1, '__system__')]</p>
			<p>The <strong class="source-inline">dictfetchall()</strong> function can also be used to retrieve records as dicts:</p>
			<p class="source-code">&gt;&gt;&gt; self.env.cr.dictfetchall()</p>
			<p class="source-code">[{'id': 6, 'login': 'demo'}, {'id': 1, 'login': '__system__'}]</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">self.env.cr</strong> database cursor object is an Odoo-specific wrapper around the PostgreSQL library, <strong class="source-inline">psycopg2</strong>. This means that the <strong class="source-inline">psycopg2</strong> documentation is helpful to understand how to fully use the object:</p>
			<p class="callout"><a href="https://www.psycopg.org/docs/cursor.html">https://www.psycopg.org/docs/cursor.html</a></p>
			<p>It is also <a id="_idIndexMarker587"/>possible to run <strong class="bold">data manipulation language</strong> (<strong class="bold">DML</strong>) instructions, such <a id="_idIndexMarker588"/>as <strong class="source-inline">UPDATE</strong> and <strong class="source-inline">INSERT</strong>. The Odoo environment relies on a data cache, and it may become inconsistent with the database when these DML instructions are executed. For this reason, after running using raw DML, the environment cached should be invalidated by using <strong class="source-inline">self.env.cache.invalidate(fnames=None, ids=None)</strong>.</p>
			<p><strong class="source-inline">fnames</strong> is a list with the names of the fields to invalidate and refresh. If this is not provided, all fields will be invalidated.</p>
			<p><strong class="source-inline">ids</strong> is a list with the record IDs to invalidate and refresh. If this is not provided, all will be invalidated.</p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">Executing SQL directly in the database bypasses the ORM validations and dependencies and can lead to inconsistent data. You should use it only if you're sure of what you are doing.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor225"/>Summary</h1>
			<p>In this chapter, we learned how to work with model data to perform <strong class="bold">CRUD</strong> operations—that is, <strong class="bold">creating</strong>, <strong class="bold">reading</strong>, <strong class="bold">updating</strong>, and <strong class="bold">deleting</strong> data—and all the techniques needed to make use of and manipulate <em class="italic">recordsets</em>. This provides the foundation needed for us to implement our business logic and automation code.</p>
			<p>To experiment with the ORM API, we used the Odoo interactive shell. We ran our commands in an environment accessible through <strong class="source-inline">self.env</strong>. The environment is similar to the one provided in the model method, and so it is a useful playground for exploring the Odoo API.</p>
			<p>The environment allows us to query data from any Odoo model that is made available as a recordset. We learned about the different ways to create recordsets and then how to read the data provided, including special data types such as dates, binary values, and relational fields.</p>
			<p>Another fundamental capability in Odoo is to write back data. In this chapter, we also learned how to create new records, write to existing records, and delete records.</p>
			<p>We also looked at working with date and time values by using the Python built-in tools and a few additional helper functions included in the Odoo framework.</p>
			<p>Recordsets can be manipulated to add elements, filter out records, reorder, or accumulate values, as well as to compare them or check for the inclusion of particular records. Any of these operations may be needed when implementing business logic, and this chapter presented the essential techniques for all of these.</p>
			<p>Finally, in some cases, we may need to skip using the ORM model and use low-level SQL operations to directly access the database or have finer control over transactions. These allow us to address the occasional cases where the ORM model is not the best tool for the job.</p>
			<p>With all these tools under our belt, we are ready for the next chapter, where we will add the business logic layer for our models and implement model methods that use the ORM API to automate actions.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor226"/>Further reading</h1>
			<p>The official Odoo documentation for recordsets can be found at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a>.</p>
		</div>
	</div></body></html>