<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Marc-André Lemburg</h1></div></div></div><div><img src="img/B08180_19_01.jpg" alt="Marc-André Lemburg"/></div><p>Marc-André Lemburg<a id="id198" class="indexterm"/> is a German software developer and entrepreneur. He is the CEO and founder of eGenix, which provides Python training and consulting services. Marc-André is a core developer for Python and the creator of a set of popular Python extensions. He is a founding member of the Python Software Foundation (PSF) and has served as a director twice. Marc-André is the co-founder of the Python Meeting Düsseldorf and the chair of the EuroPython Society (EPS). He regularly gives talks at Python conferences around the world.</p><div><blockquote class="blockquote"><p>
<strong>Discussion themes: mx packages, the PSF, v2.7/v3.x.</strong>
</p><p>
<strong>Catch up with Marc-André Lemburg here: @malemburg</strong>
</p></blockquote></div><p>
<strong>Mike Driscoll</strong>: So why did<a id="id199" class="indexterm"/> you become a programmer?</p><p>
<strong>Marc-André Lemburg</strong>: My father worked at IBM, so I was exposed to programming computers quite early.</p><p>I loved technology and making things work, but at the time (late in the 1970s), computers were still pretty much out of reach for kids of my age. I played around with "programs" which were written down on a piece of paper and "run" by imagining how a real computer would probably execute them.</p><p>I learned programming <a id="id200" class="indexterm"/>aged 11, after my dad purchased a Sinclair ZX81. First, I learned BASIC and then later Z80 assembler, since the ZX81 was a rather slow machine. Assembler was particularly fun. I had to write the programs by literally putting together the opcodes bit by bit, based on a Z80 manual. I then converted the opcodes to hex and entered them into a hex editor for the ZX81 by hand, in order to run the routines.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'I learned to appreciate performance, as well as pay attention to details.'</strong>
</p></blockquote></div><p>The effort was worth it, since the routines ran much faster than the ZX81 BASIC. I learned to appreciate performance, as well as pay attention to details. A bug in the assembler code usually meant having to restart the ZX81, after running the program and having to reload everything all over again. Given the cassette drive interface, this took quite a while.</p><p>About two years later, my dad bought the first IBM PC1 and I started to learn MS BASIC, Turbo Pascal, and Turbo C. In school, I continued to work a lot with computers and during university I founded my first company.</p><p>
<strong>Driscoll</strong>: So how did you <a id="id201" class="indexterm"/>come across Python?</p><p>
<strong>Lemburg</strong>: I first found out about Python when looking through an OS/2 Freeware CD called Hobbes in 1994. Python was listed as one of the programming languages and included in version 1.1.</p><p>I read Guido van Rossum's tutorial in an afternoon and was immediately convinced that I had found what I had always been looking for. Python is a language which has all of the important data structures, implemented in a way that is easy to use, with a clear syntax and no need for explicit memory management or parentheses to define blocks.</p><p>At the time, I was mostly writing C code, so I had to deal with all of the difficulties of a system language on a regular basis. Problems included memory allocation, pointer arithmetic, overflows, segfaults, long sessions in debuggers, and the slow edit-compile-run-debug cycle.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'Python had everything that made me happy.'</strong>
</p></blockquote></div><p>Python had everything that<a id="id202" class="indexterm"/> made me happy: an interpreter for interactive experiments, good documentation, a fairly complete standard library and a really nice C API, with everything needed to interface Python to existing C code. This included a detail which I found particularly interesting: the interpreter was using the data structures it provided for the language to also implement its own internals.</p><p>
<strong>Driscoll</strong>: Could you explain how you became an entrepreneur and founded your own company?</p><p>
<strong>Lemburg</strong>: I started working in IT at the age of 17. In 1993, while at university, I formed my first company called IKDS and worked as a freelancer for local companies that wanted to enter the then new market of online business.</p><p>After finishing university in 1997, I used my experience from building several website engines, to start working on a new web application server. My aim was to build a system that would make it easy and efficient to develop online web systems. The system would leverage object-oriented technology, relational databases, and the simplicity and elegance of Python.</p><p>After three years of hard work, I had finished the first release, with everything that was needed for a commercial enterprise product. I then started a limited company to market the product early in 2000. The development of the application server resulted in me entering the world of open source.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'The development of the application server resulted in me entering the world of open source.'</strong>
</p></blockquote></div><p>Since I did not have enough resources available to thoroughly test the software that I was writing, I decided to make the basic modules used in the application server open source. This is how the popular mx Extensions came to be. Commercially, the application server was not a success. I found that the market simply didn't yet understand the benefits of such a product.</p><p>I then focused more on consulting and running projects for other companies. One of the more interesting projects was a financial trading system that was completely written in Python. Similar projects are keeping me fairly busy these days, so I unfortunately don't have much time to contribute to CPython development anymore.</p><p>
<strong>Driscoll</strong>: Can you explain a little more about the mx Extensions<a id="id203" class="indexterm"/> that your company distributes and maintains?</p><p>
<strong>Lemburg</strong>: I started working on the mx Extensions<a id="id204" class="indexterm"/> while developing the web application server in 1997. At the time, I found that Python was lacking a good general-purpose database module.</p><p>There was an old Windows-based ODBC interface, but it wasn't really up to the task of providing a viable and performant interface to databases across Windows and Unix platforms. I started writing mxODBC to <a id="id205" class="indexterm"/>address this need. I wanted to create a fast and portable interface for ODBC drivers, which would allow me to connect the application server to all of the popular databases.</p><p>While working on mxODBC, the lack of a good date/time handling module became apparent. mxDateTime<a id="id206" class="indexterm"/> was born to fix this and became a standard in the Python world for many years, until the Python stdlib grew its own datetime module in Python 2.3.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'mxDateTime was born...and became a standard in the Python world for many years.'</strong>
</p></blockquote></div><p>mxTextTools and several of the other mx packages were the result of needing fast parsing for templating in the application server. This was later used by other people to write parsing engines, for example Biopython (parsing genome data), or drive parsers implementing user-defined grammars.</p><p>The Tagging Engine in mxTextTools works a bit like a Turing state machine, because it provides very fast parsing primitives, which can be assembled using Python tuples. Several utility functions help with using the parsing results for implementing search and replace. mxTextTools was first written for 8-bit text and binary data. A few years later, a client hired me to extend this to Unicode.</p><p>The lesser known mxStack and mxQueue played a role as fast data structures in the application server. The mxTools package is a collection of fast built-ins that I also wrote for the application server. Several of the ideas in mxTools were eventually added to core Python in some form.</p><p>
<strong>Driscoll</strong>:  So how did you become a <a id="id207" class="indexterm"/>Python core developer?</p><p>
<strong>Lemburg</strong>: While starting to write the mx Extensions, I had a lot of contact with the Python C API and its internals. I <a id="id208" class="indexterm"/>contributed back patches to CPython and became a core developer later in 1997.</p><p>Probably more people know about my contributions to CPython in the form of the Unicode integration. In 1999, Guido contacted Fredrik Lundh and me and asked us to bring Unicode to Python. This was initiated by a grant from HP to the Python Consortium (a Python Software Foundation predecessor).</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'Guido contacted Fredrik Lundh and me and asked us to bring Unicode to Python.' </strong>
</p></blockquote></div><p>Fredrik worked on a new regular expression engine. I added native Unicode support to Python. I also designed and wrote the codec subsystem in Python. The initial release was in 2000, with Python 1.6/2.0. I helped to maintain this part of CPython 2.0 for more than 10 years.</p><p>
<strong>Driscoll</strong>: What are some of the other contributions<a id="id209" class="indexterm"/> that you have made to Python?</p><p>
<strong>Lemburg</strong>: I contributed the source code encoding system, the platform module and parts of the locale module. I was also responsible for the pybench suite for measuring enhancements to CPython and several patches and ideas to make Python run faster, or to make it more comfortable.</p><p>
<strong>Driscoll</strong>: What challenges have you had as <a id="id210" class="indexterm"/>a core developer of Python?</p><p>
<strong>Lemburg</strong>: In the early years, being a core developer was a lot of fun, since the processes were a lot less formal than they are today. The only real challenge was that discussions targeting Unicode often resulted in endless discussions and sometimes flame wars.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'Discussions targeting Unicode often resulted in endless discussions and sometimes flame wars.' </strong>
</p></blockquote></div><p>I don't know whether this was because Unicode was at the core of working with text, or simply due to the many strong egos participating in the discussions. I took most of these discussions with a grain of salt and good humor.</p><p>Since then, we've seen several generations of core developers come and move on. Integrating the new developers was often not easy and involved lots of discussions. We had to try to explain how Python development worked and move all of the new energy in the right directions.</p><p>
<strong>Driscoll</strong>: Python is one of<a id="id211" class="indexterm"/> the major languages used in AI and machine<a id="id212" class="indexterm"/> learning. Why do you think this is?</p><p>
<strong>Lemburg</strong>: Python is very easy to understand for scientists who are often not trained in computer science. It removes many of the complexities that you have to deal with, when trying to drive the external libraries that you need to perform research.</p><p>After Numeric (now NumPy) started the development, the addition of IPython Notebooks (now Jupyter Notebooks), matplotlib, and many other tools to make things even more intuitive, Python has allowed scientists to mainly think about solutions to problems and not so much about the technology needed to drive these solutions.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'Python has allowed scientists to mainly think about solutions to problems and not so much about the technology needed to drive these solutions.' </strong>
</p></blockquote></div><p>As in other areas, Python is an ideal integration language, which binds technologies together with ease. Python allows users to focus on the real problems, rather than spending time on implementation details. Apart from making things easier for the user, Python also shines as an ideal glue platform for the people who develop the low-level integrations with external libraries. This is mainly due to Python being very accessible via a nice and very complete C API.</p><p>
<strong>Driscoll</strong>: How could <a id="id213" class="indexterm"/>Python be improved for AI and machine learning?</p><p>
<strong>Lemburg</strong>: I think that Python is already one of the best choices that you have for AI and machine learning. With a vibrant community engaged in making the language even better, Python is going to have a long and great future in this area.</p><p>
<strong>Mike Driscoll: Can you explain how the Python Software Foundation (PSF) was founded?</strong>
</p><p>
<strong>Lemburg</strong>: Before the PSF we had the Python Software Activity group (PSA), for which you had to pay a small amount each year. We also had the lesser known Python Consortium, for companies to support Python development, which paid big bucks each year.</p><p>Both groups did not <a id="id214" class="indexterm"/>really provide enough support for Python. The copyright in Python was also scattered across several different companies (see the Python license stack). Two companies that had significantly invested in Python, Zope Corporation, and ActivePython, started a project to potentially address all of these issues with a new non-profit organization.</p><p>This became the PSF and it was founded at IPC9, the commercial International Python Conference 9. We had 16 Python core developers at the time and the two companies as founding members. The core developers, including Guido, licensed their contributions to the PSF by signing contributor agreements and all subsequent releases were done in the name of the PSF.</p><p>Initially, the PSF did nothing more than work as a legal body for maintaining the copyright in Python distribution. Later, the PSF also received the trademark rights to the wordmark Python from CNRI.</p><p>In 2003, the PSF then underwrote the first PyCon US conference in Washington. This new development introduced a revenue stream for the PSF, which opened up new possibilities for helping the Python community.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'This new development introduced a revenue stream for the PSF, which opened up new possibilities for helping the Python community.' </strong>
</p></blockquote></div><p>As PyCon US grew and commercial sponsors started supporting it more, the revenue also grew. This resulted in the PSF turning into a more mature organization over the years. I was on the PSF board for several years to help with these developments.</p><p>
<strong>Driscoll</strong>: I know that you helped to organize the first EuroPython. Could you tell me about that?</p><p>
<strong>Lemburg</strong>: In 2001, a group of<a id="id215" class="indexterm"/> European Python and Zope users and <a id="id216" class="indexterm"/>companies started a long discussion about the desire to have a Python conference in Europe.</p><p>The Python workshops and the IPC conferences were all in the US. There wasn't much going on for Python in Europe at the time. I was one of the participants in the discussions and they did not seem to want to end. Closer to the event, I then joined the executive committee to actually make the EuroPython conference happen. That's how EuroPython 2002 came to be.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'There wasn't much going on for Python in Europe at the time.'</strong>
</p></blockquote></div><p>The whole event was run by volunteers, unlike the commercial Python conferences in the US at the time. We were on a very small budget. As such, EuroPython also predates PyCon US, which was the first conference that was run by volunteers in the US.</p><p>EuroPython 2002 was held in Charleroi. It was a lot of fun to be able to run a first major European Python conference. EuroPython was also quite successful, with even Guido attending. Nowadays, there are lots of national Python events happening each year, so while EuroPython doesn't want to compete with other national Python events, it's definitely operating in that space.</p><p>
<strong>Driscoll</strong>: How has EuroPython changed over the years?</p><p>
<strong>Lemburg</strong>: Since the early days, EuroPython has grown a lot and it passed the 1000 attendee mark in 2014. The conference is still run by volunteers, but it's no longer an operation which can be run on the side.</p><p>The EuroPython Society, which organizes EuroPython, has a lot of work to do each year to put on the conference. I'm the chair of the organization at the moment and have been on the board for several years. Each year, we're growing the event into a more professional setup. Still, it's a challenge staying on top of everything that needs to be done to put on a conference. The board members typically have to work between 200 and 400 hours each to make an event happen.</p><p>
<strong>Driscoll</strong>: What are you most excited about in Python today?</p><p>
<strong>Lemburg</strong>: I'm most excited about the native async I/O support. With the addition of new keywords, this has finally become usable in Python and will go a long way in helping to use the full CPU power that's available on today's machines.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'I'm most excited about the native async I/O support.'</strong>
</p></blockquote></div><p>As an aside, I find the Python type annotations to be the least exciting development in today's Python. They take away a lot of the elegance of Python programs. Even though type annotations are optional, many companies will enforce their use via corporate policy. This will eventually result in more and more Python being written using these annotations and will make Python look a lot like any other modern statically typed scripting language.</p><p>
<strong>Driscoll</strong>: What do you think about Python 2.7? Should everyone be moving over to the latest version?</p><p>
<strong>Lemburg</strong>: Yes, they should, but <a id="id217" class="indexterm"/>you have to consider the amount of work which has to go into a port from Python 2.7 to 3.x. Many companies have huge code bases written for Python 2.x, including my own company eGenix. Commercially, it doesn't always make sense to port to Python 3.x, so the divide between the two worlds will continue to exist well beyond 2020.</p><div><blockquote class="blockquote"><p>
<strong>Marc-André Lemburg: 'Commercially, it doesn't always make sense to port to Python 3.x, so the divide between the two worlds will continue to exist well beyond 2020.' </strong>
</p></blockquote></div><p>Python 2.7 does have its advantages because it became the LTS version of Python. Corporate users generally like these long-term support versions, since they reduce porting efforts from one version to the next.</p><p>I believe that Python will have to come up with an LTS 3.x version as well, to be able to sustain success in the corporate world. Once we settle on such a version, this will also make a more viable case for a Python 2.7 port, since the investment will then be secured for a good number of years.</p><p>
<strong>Driscoll</strong>: What changes would<a id="id218" class="indexterm"/> you like to see in future Python releases?</p><p>
<strong>Lemburg</strong>: Python will need to make it easier to use the full number of cores and CPUs that you have in today's machines. Async I/O has helped by making better use of a single core, but it's not the answer to multi-core deployments.</p><p>Removing the Global <a id="id219" class="indexterm"/>Interpreter Lock (GIL) and replacing it with more fine-grained locking mechanisms would be one approach, but it's going to be a long and rocky path to such a world. We should be careful not to underestimate the complexities and possible breakage to the many C extensions. Alienating these would set back Python a lot, since they are essential drivers of Python's success. As a result, we would have to provide a smooth upgrade path for the existing extensions, perhaps by keeping the GIL in place while they are in control.</p><p>In my opinion, we should also investigate other approaches, such as making inter-process communication more efficient and user friendly, perhaps even by adding new keywords to automatically run code in parallel.</p><p>
<strong>Driscoll</strong>: Thank you, Marc-André Lemburg.</p></div></body></html>