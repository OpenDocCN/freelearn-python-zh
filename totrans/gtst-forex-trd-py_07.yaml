- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical Analysis and Its Implementation in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we considered fundamental factors and saw how they
    may impact market prices. We noted that, although such an impact may be significant
    and potentially quite lucrative for trading, most of the time, it’s difficult
    to suggest a quantitative model that could generate unambiguous trading rules
    (when to enter the market, to which direction, and when to exit it) that wouldn’t
    require human discretion. For clarity’s sake, let’s note that there exist various
    fully quantitative approaches to evaluating fundamental factors, even political
    ones, but they are based on complex cross-discipline subjects, such as semantic
    analysis, and thus require solid knowledge of respective sciences. Is it possible
    to avoid this complexity and find a method to analyze market behavior using only
    price data? Or, maybe, some additional data, but only in numeric form?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, and this kind of market analysis is called **technical analysis**.
    In this chapter, we will consider its premises, learn about the most common technical
    indicators, and discover how they may be used to quantitatively describe various
    processes that go on in the market. We will also consider the implementations
    of key technical indicators in Python and introduce the concept of the sliding
    window, which will be used throughout all future codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical analysis – ideal for computing, but missing real market processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Momentum and RSI as indicators to measure the velocity of the market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital filters and moving averages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatility indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of technical indicators in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical analysis – ideal for computing, but missing real market processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea that lies in the foundation of **technical analysis**, or **TA**
    for short, is that *price includes everything in itself*. From this standpoint,
    if we see a price movement up or down, large or small, we don’t really want to
    know the reason behind this movement; instead, we just acknowledge that it was
    caused by some fundamental factors and try to focus on the future price development
    in regard to the observed price movement only.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, TA can analyze a *series* of data and not just a single data point.
    In this regard, TA studies help in identifying *patterns* or repeating sequences
    in price time series that bear resemblance to each other. TA suggests that if
    we observe a pattern that we already saw in the past, then the following price
    development will also be similar to what happened in the past; therefore, we can
    be prepared and exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: With TA, we don’t want and don’t need to know the actual fundamental factors
    that affected the price, we are only looking for *footprints* of something that
    happened behind the scenes and will then take action depending on the form of
    these footprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the difference in the foundations of fundamental and
    technical analyses, let’s see how this difference impacts the two main practical
    points of any market analysis: its time horizon and precision.'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental analysis focuses on macroeconomic factors, which are always longer
    term by nature, so the time horizon for fundamental forecasts is normally days
    and above, up to years. On the contrary, technical studies may analyze extremely
    short-living processes (for example, momentary imbalances in the order book),
    and therefore, it’s normal that technical studies may have a forecast horizon
    of 1 second, 1 millisecond, and sometimes even a few microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main differences between fundamental and technical analyses are summarized
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Fundamental analysis** | **Technical analysis** |'
  prefs: []
  type: TYPE_TB
- en: '| Key focus | Macroeconomics, politics, industry news, and the sentiment of
    investors | Price, volume, open interest, spreads, liquidity, and other quantitative
    parameters |'
  prefs: []
  type: TYPE_TB
- en: '| Forecast horizon | Days to years | Microseconds to days, and rarely, weeks
    and months |'
  prefs: []
  type: TYPE_TB
- en: '| Forecast precision | Very volatile | Depends on the timeframe |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Key differences between fundamental and technical analyses
  prefs: []
  type: TYPE_NORMAL
- en: The building block of any TA study is an **indicator**. It is a combination
    of price, time, volume, and/or any other market data that can be quantitatively
    measured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indicators are usually plotted as lines, dots, histograms, and other graphical
    objects *on* a price chart, *below* a price chart, or both. Normally, technical
    analysts use two to five indicators, each of them showing a particular feature
    of the examined price time series. *Figure 7**.1* shows a typical example of such
    a combination of TA indicators in a single chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Typical layout of TA indicators with a price chart](img/B19145_7_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Typical layout of TA indicators with a price chart
  prefs: []
  type: TYPE_NORMAL
- en: Excessive use of TA indicators may lead to a mess when it’s really hard to understand
    what each of them shows and what the author of this mess really wanted to achieve.
    You probably can’t believe it, but the example in the following figure is not
    my fantasy, but something similar to what I saw with my own eyes so many times
    on various trading forums!
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.2 – How the excessive use of TA indicators may lead to \uFEFFabuse](img/B19145_7_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – How the excessive use of TA indicators may lead to abuse
  prefs: []
  type: TYPE_NORMAL
- en: There is one thing common for all TA indicators – their values are always synchronized
    with the original price time series on which they are based.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we build an indicator based on a 1-minute chart, then the
    values of this indicator will be updated every minute; for an hourly chart, the
    values will be updated every hour, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if we use a tick chart as the source data to calculate the values
    of a TA indicator, then these values will be updated on every tick. When we work
    with live data feeds, TA indicators show fixed, unchanged values for all historical
    bars (well, we can’t change history, can we?), but update the latest reading with
    every new tick that comes in for a bar that is not completed yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of their complexity, almost all TA indicators can be classified
    into four major groups: velocity of the market, digital filters, range indicators,
    and volatility indicators. Let’s consider each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: An important note before we proceed
  prefs: []
  type: TYPE_NORMAL
- en: In all the following discussions about technical indicators, we will use the
    term **current bar**. This doesn’t mean that we are talking only about the last
    (rightmost) bar on the chart. This means that when we plot charts, indicators,
    backtest strategies, and so on, we always move (imaginarily) from left to right,
    from historically older data to historically present, and we calculate anything
    *on every bar that we encounter*. This bar, for which we are calculating any values
    *at the moment*, is referred to as the **current bar**. We use this term because
    when we go live with our developments, the current bar will actually mean the
    price data that we receive *at this very moment*, so we don’t have to modify anything
    in our study or strategy code.
  prefs: []
  type: TYPE_NORMAL
- en: With this important note in mind, let’s go ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity of the market
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These indicators try to answer the question, *How fast is the price moving?*.
    Indeed, if we compare a normal average day in the FX market with a release of
    important economic news or a political event, then we clearly see the difference.
    And of course, it would be nice to assess this difference quantitatively. We will
    consider only the two most well-known indicators of this kind – momentum and RSI
    – but any more sophisticated market speed indicator will be inevitably built on
    the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: Momentum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is probably the oldest technical indicator and definitely the simplest.
    It is really hard to imagine a simpler formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *C*0 means the current closing price and *C*-1 means the closing price
    of the previous bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we calculate these differences for every bar, store them in an array, and
    plot the indicator below the chart, we will see that its values no longer follow
    the price movements and, overall, it looks more like noise rather than a clear
    trending price pattern. However, this noise is quite informative. Even from a
    quick glance at the chart in *Figure 7**.3*, we can conclude a number of important
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Basic momentum plotted below a price chart](img/B19145_7_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Basic momentum plotted below a price chart
  prefs: []
  type: TYPE_NORMAL
- en: First, we can see that the readings of momentum seldom remain in the positive
    or negative zone for more than two or three data points in a row. Since the momentum’s
    value is the difference between the current and the previous closing prices of
    just two adjacent bars, we can say that it’s not usual for this market that the
    price grew or declined steadily for more than three bars in a row. In other words,
    if we see more than two bars closing up, we may expect a bar to close down rather
    than another bar closing up. Technical analysts call these bars **corrections**;
    they may even appear inside quite long and steady trends, as in *Figure 7**.3*,
    but they do not break the trend. So, overall, we can say that this market is really
    prone to corrections.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if we estimate the amplitude of the momentum indicator, we can see that
    it is different during different market regimes. While the market remained more
    or less *flat* (at the beginning of the chart), the amplitude of the momentum
    hardly exceeded 0.002 points, but as the uptrend was developing, its values increased
    to 0.004 by absolute value – that is, two times the *idle* market. So, we can
    assume that the *market speed* has some correlation with the market regime and
    could potentially use it in our own studies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the momentum indicator has one parameter – the number of bars between
    which we calculate the difference. In the classical formula at the beginning of
    this section, we compared the closing prices of two adjacent bars; of course,
    we can compare the price of the current bar with that of any bar in the past.
    If we continue doing that for every bar, we will get to a modified formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *n* means the number of bars *back* from the current bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we set *n* to 24, then we calculate the difference in closing
    prices between the current bar and 24 bars ago (which, for an hourly chart, means
    the price strictly 24 hours or 1 day ago), we will see a somewhat different picture,
    as shown in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate
    of change for 24 hours](img/B19145_7_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate
    of change for 24 hours
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the *market speed*, or the price rate of change for 24 hours,
    looks totally different from the preceding chart, where we considered the difference
    in closing prices of just two neighbor bars. There’s no *noise* here anymore;
    instead, we observe longer-term changes in the momentum values. But the observations
    we made previously (regarding the corrections and correlations between *market
    speed* and range/trend markets) remain valid, as only the scale and proportions
    of these phenomena increased.
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, the momentum indicator is useful to determine the idle market
    phases (when its readings are close to zero) and the highly active market (when
    its readings exceed a certain threshold). However, I hope you can see the evident
    shortcoming of this indicator in its present form – to decide whether the present
    market is active or not, we must specify this very *certain threshold* we just
    mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: What is this threshold? In the first example (*Figure 7**.3*), the momentum
    values never exceeded 0.006, while in the second one (*Figure 7**.4*), it reaches
    almost 0.02, which is *a order of magnitude* greater. So, if we say that market
    speed above 0.004 is *abnormally big*, then we have to agree that in the second
    example, the market is in *abnormally big* mode half of the time.
  prefs: []
  type: TYPE_NORMAL
- en: It becomes clear that for the classical momentum indicator, there is no such
    threshold as a single unique numeric value. It depends on the market, the data
    resolution, and the momentum period. And it would be great if we could adjust
    the threshold value automatically, without the need for doing that manually every
    time, and consequently, eliminating possible human discretion bias.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we get rid of subjectivity when setting such a threshold?
  prefs: []
  type: TYPE_NORMAL
- en: RSI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem of answering the key question, *Is it big enough or still small*
    discussed in the previous section was solved for the momentum indicator by *J.*
    *Welles Wilder Jr.* in 1978\. In his book, *New Concepts in Technical Trading
    Systems*, he introduced the **relative strength index** (**RSI**), a new TA indicator
    that he suggested using in order to determine the *overbought* and *oversold*
    states of the market. In his terminology, *overbought* corresponds to the situation
    when prices grow *too quickly*, basically meaning that the market speed we discussed
    previously is too high. *Oversold* zones correspond to situations when prices
    fall *too quickly*, meaning the momentum is still greater than average by its
    absolute value but has a negative sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'RSI solves the problem of specifying a universal threshold for the momentum
    indicator by *normalizing* its values. Normalization is a process of scaling data
    so that all values fit into a certain range. For example, we have two datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to compare *apples to apples*, and thus we want to scale
    both of them so the minimum and the maximum values of each dataset are the same.
    Typically, a range of 0 to 100 is used (it’s convenient: if we normalize data
    to this range we can then consider the values as a percentage). So, if we scale
    the first dataset to the range *0:100*, we will get an obvious sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But when we scale the second one, then `0` remains `0`, and the maximum value,
    which is `0.4`, becomes `100`, so the scaling coefficient is *100/0.4 = 250*.
    Then, the normalized dataset will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we can compare, for example, the rate of change of data points in both datasets
    using the same metrics, despite the fact that, originally, the second dataset
    contains values of *a order of magnitude smaller* than values in the first one.
  prefs: []
  type: TYPE_NORMAL
- en: So, the idea of the normalization of TA indicators is to scale them *automatically*
    so that their values always remain in the *0:100* range, or sometimes, *-100:100*.
    Let’s do it for the momentum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Welles Wilder suggests calculating RSI in two steps: first, we calculate the
    **relative strength** (**RS**), and second, the RSI.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that as with any other TA indicator, RSI uses *period*, a parameter
    that determines the number of data points we take into consideration. In the first
    example of the momentum indicator from the previous section, the period was just
    1, and in the second example, it was 24.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the RS, we should first calculate the *gains* and *losses* for
    the period. A gain, in Wilder’s terminology, happened when a bar closed up, and
    a loss when a bar closed down. Then, we calculate the average of gains and the
    average of losses separately. And finally, we calculate the relative strength
    for the period:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This formula is similar to the original momentum, only the momentum measures
    the *difference* between prices, and the RS measures the *ratio*. Using ratios
    is always preferred when we want to become independent of the original value range,
    where subtracting 0.01 from 0.1 will result in 0.09, while subtracting 10 from
    100 results in 90, and it’s evident that 90 and 0.09 differ by *4 orders of magnitude*,
    so it’s impossible to compare them directly. However, dividing 0.01 by 0.1 and
    dividing 10 by 100 produces exactly the same value, that is, 0.1, so in terms
    of market speed, this value is indeed the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we normalize the RS by keeping it always within the range of 0 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now plot the RSI along with the momentum on the same chart, we can see
    that the two indicators are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart](img/B19145_7_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart
  prefs: []
  type: TYPE_NORMAL
- en: Since RSI is normalized to a range of 0 to 100, typically, the values above
    70 are considered an *overbought* market, while values below 30 are spoken of
    as *oversold*. In the preceding chart, the *overbought* market corresponds to
    an uptrend, and absence of *oversold* state can be interpreted as a strong upside
    bias in the market sentiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more market speed indicators than momentum and RSI, but all of them
    are used to determine the following market regimes:'
  prefs: []
  type: TYPE_NORMAL
- en: Idle versus active market (prices move slowly or quickly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overbought/oversold zones (prices went *too high* or *too low*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharp bursts of prices mostly caused by liquidity issues (*spikes* on momentum
    charts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, momentum is good for detecting relatively short-living market situations.
    But what about something longer-term? Are there indicators that could show us
    a more global sentiment, a long-term tendency? Let’s move on to another class
    of TA indicators that is normally used for this very purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Digital filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you listen to music of any genre, and I hope you do, there’s a good chance
    that you are familiar with high-pass filters, low-pass filters, and equalizers.
    Any car audio, desktop, or mobile audio player offers this functionality. And
    I do hope that if you played with audio settings at least once in your life, you
    will remember what happens if you turn off treble and boost the bass to the maximum
    – that is, instead of music, you now hear only *boom-boom-boom*.
  prefs: []
  type: TYPE_NORMAL
- en: However, cutting off higher frequencies can also be quite useful if you want
    to focus on the rhythm, on the bass line, and probably on the chords and base
    (as opposed to harmonics) tones. And this is what lots of technical analysts dream
    of – to strip away all the *noise* from the market prices, leaving only the *bass
    line* or *rhythm*, – that is, the key trends and major price movements that last
    relatively long and, potentially, bring profits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, or not, all TA indicators that do this job work *exactly* the
    same as low or high-pass filters in audio because they are based on *exactly the
    same* mathematical principles. That’s why we put them all in one section: digital
    filters.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving averages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A moving average is also one of the oldest technical indicators. It is calculated
    as the average of prices for the period and recalculated on every bar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discuss TA indicators, we always use two terms: *period* and *current
    bar*. So let me just quickly remind you that a *period* means a number of data
    points (ticks, bars, any other samples from a time series) that the TA indicator
    analyzes, and the *current bar* changes one by one, left to right, as we reconstruct
    the historical values of the indicator, along with the historical values of the
    market price itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a simple example, let’s consider the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s calculate an average of three data points starting from the leftmost
    one. For the first element in the original dataset, it’s impossible to do because
    we have only one data point and we require three. The same for the second data
    point. So, we can start calculating the moving average from the third data point,
    and its value will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we move on to the fourth data point and again calculate the value of
    the moving average, but this time, we start calculating from the second element
    in our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Proceeding in this way, we will get a new dataset that represents the average
    values of three data points in a row, recalculated for each data point from left
    to right. Therefore, for the first two data points, we don’t have any value (as
    the number of original data points was insufficient to calculate a three-point
    average):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you got the point: we always take three samples from the dataset, calculate
    the average, store this value in a new dataset, and move on to the next sample.
    This technique is called the **moving window** and is the basis for the calculation
    of all TA indicators.'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, **moving averages** (**MAs**) are calculated based on the closing
    prices of bars, but nothing prevents us from using them with any other price (such
    as high, low, or trade) or non-price data (such as volume, liquidity, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: It’s evident that an MA with a period of one equals the original time series.
    How will values of MAs with greater periods correspond to the original data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot the original price time series in form of just dots, not bars, where
    each dot will denote a closing price of the bar. And let’s plot 3 different MAs
    along with the original series with periods of 2, 3, 5, and 10, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD](img/B19145_7_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.6* plots the original time series as bars, and 3, 7, and 13-period
    MAs as dashes, crosses, and solid lines, respectively. We can see that the smaller
    the period of an MA, the closer its values are to the original series, and the
    greater the period, the *smoother* the change in the MA’s values.'
  prefs: []
  type: TYPE_NORMAL
- en: This *smoothing* is the very effect of a low-pass filter. Surprisingly, an MA,
    calculated using simple mathematics, *is* a digital filter, pretty close to those
    used in audio processing. The greater the period of the MA, the lower the maximum
    frequency passed by such a filter. So, if applied to an audio signal, such a filter
    will leave us with *boom-boom*, and now we can see this *boom-boom* in the market
    prices. Ultimately, using MAs with a period of 20, 50, or 200 will show only longer-term
    changes in the market prices, considering minor price movements as high-frequency
    noise.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.7* shows the same hourly chart of EURUSD with closing prices only,
    plotted as big black dots, and 20-, 50-, and 200-period MAs on top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing
    prices of EURUSD](img/B19145_7_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing
    prices of EURUSD
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can see that the MA with the greatest period (200) only
    grows with slight changes in the growth rate, while MAs with shorter periods grow
    and decline, and the smaller the period of the MA, the closer its values are to
    the original series.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, MAs are the simplest digital filters and are designed to detect *tendencies*
    rather than immediate activity. They are used in TA to solve the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: To determine long- and medium-term trends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To distinguish bullish and bearish markets (normally, when daily prices close
    above the 200-period MA, the market is considered bullish, and vice versa)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To smoothen *occasional* or *abnormal* sharp price movements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very frequently, MAs are used in combination with momentum indicators – for
    example, an MA can be used to determine whether the market is bullish (closing
    prices above 200-period MA), and momentum can determine the moment when the market
    speed is high, so potentially, it could be a good time to buy.
  prefs: []
  type: TYPE_NORMAL
- en: However, you probably already heard about traders who lost their fortune buying
    when prices were already too high or selling when prices were already too low.
    I hope now that we have so thoroughly examined the design of market speed indicators
    and digital filters, you have already spotted the bottleneck here – *too high*
    or *too low*. But how do we decide that it’s already *too* high or still *not
    so* high? The answer is in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Range indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common methods to solve the problem of identifying whether the
    current price is in any extreme zone (too high or too low) is using range indicators.
    Normally, a **price range** is a difference between the maximum price and the
    minimum price for, well (I’m sure I heard you say that), a *period*. As always,
    with technical indicators, we’re bound to a certain timespan, a moving window
    that we slide along the chart from left to right. So, when we talk about range,
    we have to define the period for which this range is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the chart shown in *Figure 7**.8*. The rectangle shows the maximum
    and minimum price of a 24-bar span (since it’s an hourly chart, this means the
    rectangle corresponds to 1 day):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage
    of range, EURUSD, 1-hour](img/B19145_7_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage
    of range, EURUSD, 1-hour
  prefs: []
  type: TYPE_NORMAL
- en: Two closing prices are marked with small arrows. Horizontal lines are drawn
    through these closing prices to visualize the price levels relative to the range
    rather than absolute values. So, for the first (left to right) closing price,
    the absolute value is 1.1260, but relative to the range, it’s right at 50% of
    it. The second closing price is 1.1292, but relative to the range, it’s about
    85% of it.
  prefs: []
  type: TYPE_NORMAL
- en: Got the point? We can replace absolute price values that don’t say much with
    relative price levels, which could be interpreted pretty much as we interpreted
    RSI values (see the *RSI* section). For example, we can say that when the price
    is above 80% of the range level, then the price is *too high*, and when the price
    is below 20% of the range level, then the price is *too low*.
  prefs: []
  type: TYPE_NORMAL
- en: The first and the most well-known range indicator is the **stochastic oscillator**.
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic oscillator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stochastic** is quite a popular word among traders, but unfortunately, it
    is often used improperly. In mathematics, the term *stochastic* means a variety
    of random processes. To understand what it means, let’s consider an example.'
  prefs: []
  type: TYPE_NORMAL
- en: If you go out to buy some bread, then you will most likely go down the same
    streets, end your route at the same local grocery store, and spend more or less
    the same amount of time as usual. This is an example of a *deterministic process*
    – although there can be some *fluctuations* or deviations down the road (for example,
    you decide to walk on this or that side of the street), the overall route and
    destination remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you go out with no particular goal in mind and stop at any
    shop, bar, or movie theater you like, spend any amount of time in each, and decide
    where to go next by tossing a coin. Every time you take such a trip, its trajectory,
    destinations, and time spent, both on each leg and the entire journey, will differ.
    Although the area where you’re traveling is confined and you visit the same places,
    the map of your actual movements will be different because of the *randomness*
    of your decisions. Such a process is called *stochastic* or *random* or *probabilistic*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Market price movements are also considered random or stochastic processes by
    many researchers, who have suggested various probabilistic models that describe
    price behavior. Although this standpoint can also be criticized, such an academic
    debate is definitely outside the scope of this book, so the main points we should
    take away from this brief *lyrical digression* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes with a definite trajectory, target, and time are called **deterministic**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes where every next step has just some probability and you never know
    for sure where and when it reaches any target are called **stochastic**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in market prices can be considered a **stochastic process**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stochastic oscillator has nothing in common with **stochastic processes**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The stochastic oscillator in its original form shows exactly what we considered
    at the very end of the previous section – it shows where the current price is
    as a percentage of a certain price range. So, in order to calculate the stochastic
    oscillator, we should choose a period (number of data points), then find the maximum
    and the minimum price for this period, and then calculate the value of the stochastic
    oscillator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P*0 means the current price, *L* means the lowest price for the period,
    and *H* means the highest price for the period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again open an hourly chart of a currency pair, but this time, the Japanese
    yen for a change, and let’s plot this indicator with a period of 24 below it (thus
    tracking changes in price as a percentage of a day’s range):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart
    of USDJPY](img/B19145_7_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart of
    USDJPY
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.9*, we can see that the stochastic oscillator indeed *oscillates*
    in a range from 0 to 100 (what a surprise). During trends (right half of the picture),
    it tends to stay above 50, and in sideways markets (middle part of the picture)
    it can oscillate full scale.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the possible application of the stochastic oscillator?
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, it’s used to answer the question of whether the price is
    *too high* or *too low* (I hope you remember this Shakespearean question from
    the end of the previous section). We can say, for example, that when the price
    is above the level of 80 – which means that the price is greater than 80% of the
    price range – then it is indeed *too high*. Likewise, being under 20% of the range
    could mean that the price is *too low*.
  prefs: []
  type: TYPE_NORMAL
- en: Second, some technical traders like to use stochastic and similar oscillators
    to determine trends. We already saw that, during trends, the stochastic oscillator
    tends to remain above (for uptrends) or below (for downtrends) 50% of the range
    for quite a long time. It’s no wonder that trends are special market regimes where
    corrections in prices are much smaller and last for a much shorter time than the
    movements in the direction of the trend. So, prices will indeed remain in the
    upper or lower half of the range for many hours, days, or sometimes even weeks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous modifications of the stochastic oscillator. For example,
    adding an MA to its values (and we remember that we can add an MA to any time
    series, not necessarily price) gives us a so-called *slow stochastic*. Some authors
    suggest using the original indicator and the averaged one on the same chart, but
    the essence remains the same – this is a range oscillator and can, therefore,
    be used to solve the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying whether the price is *too high* or *too low*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying trends as long-term periods when prices are above or below 50% of
    the range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggesting buy signals when the oscillator starts going up from *too* *low*
    levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggesting sell signals when the oscillator starts going down from *too* *high*
    levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a speed indicator (momentum or RSI) that tells us that the
    market is moving fast, a digital filter (MAs) that confirms that the main tendency
    in the market is still positive, and a range indicator (stochastic) that shows
    that the asset is currently oversold, it may look like it’s a good time to buy.
  prefs: []
  type: TYPE_NORMAL
- en: But!
  prefs: []
  type: TYPE_NORMAL
- en: Even if we calculated the timing of our entry with the highest degree of perfection,
    markets still remain stochastic processes (remember what we started with at the
    beginning of this section?) and it is normal that price may go against you for
    some time. The key question here is whether this adverse price movement is only
    a small correction and it’s wise to just wait till red turns green, or you were
    wrong with your trading decision (which, by the way, is also absolutely normal)
    and should liquidate your losing position before it drains your account completely.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, this problem is solved by adding volatility studies to the trading
    strategy logic.
  prefs: []
  type: TYPE_NORMAL
- en: Volatility indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look up the definition of volatility in Merriam-Webster, the first suggested
    meaning would be *a tendency to change quickly and unpredictably*. Sounds good,
    but how can we measure this tendency, this ability to change?
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia ([https://en.wikipedia.org/wiki/Volatility_(finance)](https://en.wikipedia.org/wiki/Volatility_(finance)))
    suggests a different definition: *“volatility (usually denoted by σ) is the degree
    of variation of a trading price series over time, usually measured by the standard
    deviation of logarithmic returns.”* If you are not familiar with mathematical
    statistics, this may sound like a foreign language to you, but don’t worry, let’s
    take a quick tour of the theory of probability.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the same example with a random walk around bars and movie theaters.
    Let’s measure the distance between the starting point (your home, presumably)
    and the ending point (where you decide to finish your walk for the day). Every
    day, we will get different values because you make your travel decisions randomly.
    However, we can calculate the average value and say that, on average, you walk,
    say, three kilometers per walk.
  prefs: []
  type: TYPE_NORMAL
- en: The devil is always in the details, and the devil of averaging is called **dispersion**.
    This is a measure of how much the actual values of a certain random variable differ
    from the average, or *mean* value. Let’s consider two examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s go back to a deterministic process when you go out to a local
    grocery. We record travel distances for each trip and put them into a dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s calculate the mean value of this dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, subtract this mean value from each element of the original dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the difference between almost all recorded values and their
    mean is *a order of magnitude smaller* than the mean itself. The only exception
    is the last values in the `D` dataset: the difference between it and the mean
    is comparable to the value itself. Such a value is called an **outlier** and is
    most likely explained by incorrect measurements or something exceptional that
    happened to you down the road.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s record the distances traveled each time you took a random walk around
    the local bars and movie theaters. In some cases, you found a nice place to stay
    almost as soon as you left your house; in other cases, you walked quite a lot
    and still returned home unsatisfied, hence the difference in the distance you
    traveled each time. We will get a dataset like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Its mean value is 1.645\. If we now do the same as previously (that is, subtract
    this mean from each element of the dataset), we will see that the differences
    now are quite comparable to the mean value, and in some cases, nearly exceed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The process in which the differences between values and their mean are way smaller
    than the values themselves is a *deterministic process*, and now we have a more
    math-looking definition of it (although it’s still not formally correct). Conversely,
    the process where the differences between values and their mean are comparable
    to the mean itself is a *stochastic* or *random* process.
  prefs: []
  type: TYPE_NORMAL
- en: So, back to the market stuff. If we do the same math with prices (for example,
    recording the changes in price for each bar and then calculating their mean value
    and the difference), then we can use this difference as the measure of *volatility*.
    It will indeed match the Merriam-Webster definition – the greater the differences
    in question, the less predictable the values and the quicker the possible changes
    in prices.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, a bit more complex calculation is used to determine market volatility.
    One of the commonly used metrics that estimate *how far the values of a dataset
    are from their mean* is called **standard deviation**. If you are interested in
    learning more about it and the mathematics behind the concept of volatility, I
    encourage you to first read the basics about mathematical statistics to get familiar
    with the terminology and the key concepts. The article in Wikipedia ([https://en.wikipedia.org/wiki/Mathematical_statistics](https://en.wikipedia.org/wiki/Mathematical_statistics))
    could be a good starting point. In the meantime, we continue in a somewhat informal
    manner and remember that standard deviation is used to estimate the volatility
    in any stochastic process and market prices in particular.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am sure you now perfectly understand that **standard deviation** (or **stddev**
    for short) also requires a period quite like any other TA indicator. This period
    is the length of the dataset for which we measure the volatility. So, what we’re
    plotting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be shown in the form of an equation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *c*i means the closing price of the *i*-th bar, ![](img/Formula_B19145_07_011.png)
    denotes the mean value, and *24* means the number of data points (closing prices
    of bars) for which we calculate `stddev`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.10* shows the same 1-hour chart of GBPUSD as in the previous example,
    but now with the 24-period standard deviation indicator below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing
    prices](img/B19145_7_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing prices
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that volatility is something that doesn’t have any evident relationships
    with the direction of the market prices or with trend/sideways market regimes.
    What we *can* see though is a number of important observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard deviation is always positive; it disregards the direction of the price
    movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sudden increase in the market activity does increase values of the standard
    deviation of closing prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The longer the price remains at new levels (see the jump in price on July 27
    and a congestion zone following it the next day), the greater the increase in
    values of the standard deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximums and minimums in the `stddev` indicator do not correspond to maximums
    and minimums in the price chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interesting picture, but there’s one questionable assumption here, and I hope
    you already exclaimed, “*Wait! But we measure the standard deviation of an incorrect
    dataset! Why do we measure it for the price itself when we should have done that
    for* *price increments?*”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, the market process can be considered a stochastic process from a number
    of standpoints. We can consider every closing price as an independent value of
    a random process, or we can look at price movements as a random walk process,
    where we’re interested only in how much the price changed since the last observation
    (bar). So instead of calculating the standard deviation of *closing prices*, we
    should rather calculate the standard deviation of *changes in price* for each
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_B19145_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *C*i means the current bar, *C*i-1 means the previous bar, and the delta
    symbol means the price increment per bar (positive or negative – and this is the
    key difference from calculating standard deviations for prices, as they can only
    be positive).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether there’s any difference between the standard deviation of
    closing prices and the standard deviation of *differences* of closing prices.
    *Figure 7**.11* still shows the same chart of GBPUSD with both standard deviations
    plotted below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Two versions of the standard deviation-based volatility indicator](img/B19145_7_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Two versions of the standard deviation-based volatility indicator
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is pathetic! There are no longer *smooth* changes in volatility.
    Instead, we observe periods of high and low volatility abruptly switching from
    one to another. Now the picture is more adequate to what we observe in the market
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharp price movements always and immediately cause our volatility indicator
    to jump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High volatility often means a reversal in price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longer-term trends (the right part of the chart) are accompanied by low volatility
    (surprise!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that sharp price movements cause volatility to also increase sharply
    is used in *volatility breakout* strategies; the idea is buying or selling the
    asset in the direction of the already started sharp price movement. And the fact
    that the volatility is relatively low during trends is used in various *trend-following*
    or *mean-reversion* strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Our study on volatility would definitely be incomplete without one of the most
    well-known and popular TA indicators, Bollinger bands.
  prefs: []
  type: TYPE_NORMAL
- en: Bollinger bands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This indicator was introduced by John Bollinger in the 1980s. The idea is to
    determine whether the price of an asset lies outside of the *normal* range. In
    this indicator, the *normal* range is defined as the mean value plus or minus
    two standard deviations (or two *sigma*). Therefore, Bollinger bands consist of
    *two* lines, one always going above the price (*B+*) and the other, always below
    (*B-*):'
  prefs: []
  type: TYPE_NORMAL
- en: B+ =![](img/Formula_B19145_07_013.png)
  prefs: []
  type: TYPE_NORMAL
- en: B- = ![](img/Formula_B19145_07_014.png)
  prefs: []
  type: TYPE_NORMAL
- en: Why two *stddev*, not one? If you want to learn the correct, formal answer,
    I would recommend that you refer to any book on mathematical statistics or the
    same Wikipedia article as earlier. Without going into details, let us just take
    it for granted that for a stochastic process, 90% of data points fall into the
    mean *± 2* sigma range. So, the idea of Bollinger bands is that drawing lines
    in a *2* sigma distance from the mean could help isolate outliers – that is, the
    prices that lie outside the *±2* stddev range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what it looks like in reality. *Figure 7**.12* shows a 1-minute chart
    of AUDUSD with 20-period Bollinger bands on it:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands\uFEFF](img/B19145_7_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands
  prefs: []
  type: TYPE_NORMAL
- en: This chart represents the mean or moving average (solid line in the middle)
    and two Bollinger bands (gray lines above and below). Bold black dots mark the
    closing prices that lie above the upper band or below the lower band. Both are
    *outliers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technical traders use Bollinger bands for various purposes as other TA indicators
    as well, though:'
  prefs: []
  type: TYPE_NORMAL
- en: Outliers can be interpreted as breakouts – moments when the price starts its
    movement to a certain direction – so can be used in strategies that attempt to
    buy or sell *along with* the movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outliers can be interpreted as liquidity issues and thus considered as good
    points for mean reversion – so can be used as entry points to buy or sell *against*
    the current price movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key takeaways – what TA indicators are all about and how to use them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The world of technical indicators is really vast. However, most of them are
    just variations of the same old classical indicators of the four main types:'
  prefs: []
  type: TYPE_NORMAL
- en: Momentum, or *market speed*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t forget this when you stumble upon a new *unique* indicator that promises
    *fantastic* results. Give it a thorough examination first and you will see what
    it actually shows.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that no indicator can build you a robust trading strategy. They
    serve only to quantitatively identify various situations in the market, and it
    is still up to you as the trading strategy developer how you actually exploit
    these situations in the logic of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to see how we can implement technical indicators in native Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of TA indicators in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am sure you remember that any TA indicator uses a certain period as a parameter.
    This period means a number of data points that we take into consideration. To
    calculate an indicator on every bar, we start from the oldest one (the leftmost
    on the chart) and then move one by one, updating our dataset with each new bar.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are talking about an absolutely essential thing that lies in the foundation
    of all TA, let me be very detailed here – probably too detailed – but I want to
    leave no place for ambiguity or misunderstanding in the following concepts and
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the core concept of time series processing: the sliding window.'
  prefs: []
  type: TYPE_NORMAL
- en: Sliding windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go back to the example of a random walk (around bars and movies) that
    we considered in the previous section. The entire dataset, or historical data,
    consists of 10 data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we are interested in analyzing the activity only for the last 3 days,
    then we get the following subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, we apply a TA indicator to each subset, one by one, left to right, older
    to newer.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is known as the **sliding window**, and is the cornerstone of
    all technical trading, from plotting simple indicators to backtesting and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Peeking ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main problem of working with historical data while using sliding windows
    is the potential ability to *peek ahead*, or look into the future (see [*Chapter
    4*](B19145_04.xhtml#_idTextAnchor073), *Trading Application – What’s Inside?*,
    in the *Trading logic – this is where a small mistake may cost a fortune* section,
    for the discussion on the peeking ahead issue). If we reconstruct your random
    walk movements from the `S1` dataset (see the *Stochastic oscillator* section
    in this chapter), we should take particular care about *not* using data from *tomorrow*
    when we analyze what happened *today*. Let’s add dates to our data samples to
    give them more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we reconstruct what happened on or before January 6, 2001, we are allowed
    to take into consideration only data from the prior period. We *cannot, should
    not, and have no right* to use data from January 7 or later. If we do, we face
    this peek-ahead issue.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you’re developing a trading strategy and want to test it using
    past data. The goal of such a test is to reconstruct what *would have happened*
    on that particular day at that particular time *if* your strategy actually worked
    then. If you reconstruct what your strategy would have done on January 6, you
    have no right to peek ahead and use data from January 7, even 1 second past the
    test date, because you have no time machine (or so I assume) and when you run
    your strategy *live*, you will be also unable to retrieve data from the future.
  prefs: []
  type: TYPE_NORMAL
- en: However, peeking ahead is, surprisingly, quite a common mistake, and this is
    why I go into so much detail on this issue here. Remember that *if your strategy
    delivers unrealistically good returns, then most likely, they are indeed not realistic
    and are caused by* *peeking ahead.*
  prefs: []
  type: TYPE_NORMAL
- en: How is it possible to peek ahead non-intentionally, occasionally? Well, it’s
    very easy if you store price time series in a list or any similar iterable structure,
    and retrieve data to do calculations by an index. In the previous example, I can
    get data from January 7 while testing a strategy for January 6 simply by calling
    `S1[4:7]`. Even if you use dictionaries, you can get erroneous data by retrieving
    it with an incorrectly specified datetime index.
  prefs: []
  type: TYPE_NORMAL
- en: But having said all that, is there a method to guarantee that your code will
    never try to retrieve data from the future? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate solution to the peek-ahead issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To suggest such a solution, we should recall that when we use *live* data, we
    are physically unable to get data from the future because ticks or any other data
    packets arrive at your trading application one by one. So, if we want to fully
    guarantee no peeking ahead during the testing phase of the development, we may
    want to emulate the very incoming data stream and write the rest of the code as
    if we plan to work with live data, not historical data stored on disk.
  prefs: []
  type: TYPE_NORMAL
- en: The first step toward this universal architecture was made in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, where we suggested using queues
    and threads to accommodate for receiving large amounts of incoming ticks. Now,
    let’s look at the problem of calculating TA indicators from the same standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure you remember that *any* TA indicator analyzes a subset of price time
    series, and the length of this subset is called a **period**. When we looked at
    charts, we always noted that for the reconstruction of the indicator’s values
    on historical price data, we need to move this period from left to right, from
    the oldest to the newest data points. We called this approach a **sliding window**.
  prefs: []
  type: TYPE_NORMAL
- en: But now let’s think about what we should do in case we try to build the indicator’s
    values *on the fly*, live, as market data is coming in. There’s no history, no
    stored values, only live ticks. So how can we create such a sliding window?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is obvious: we do create a *window*, but we don’t create a *sliding*
    window because there’s nothing to slide on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s recall how a queue works (see also [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*). Generally speaking, a queue
    is a list with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: When a new element comes in, it is added to the end of the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we retrieve an element from the queue, it is taken from the beginning and
    removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a special queue where the oldest elements (those at the beginning)
    are not retrieved, but automatically removed as soon as a new element is added.
    Let’s look at the diagram in *Figure 7**.13* to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Queue with a fixed length and automatic removal of the oldest
    element upon arrival of a new element](img/B19145_7_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Queue with a fixed length and automatic removal of the oldest
    element upon arrival of a new element
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s start filling this queue with price time series, starting from the
    oldest data points. What do we get then?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do it with our `S1` sample data from the preceding example. Imagine that
    we created such a queue with a length of three. Then, we start pushing data points
    to this queue, removing the oldest points as new points come in. We will get the
    following subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And so on.
  prefs: []
  type: TYPE_NORMAL
- en: What are these subsets now?
  prefs: []
  type: TYPE_NORMAL
- en: Wow, these are exactly what we got using a sliding window!
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of storing data in a database or any other storage and then retrieving
    it for the purpose of building a TA indicator, we do that *on the fly* as new
    data is coming in. In this case, we will never be able to peek ahead because we
    will never be able to receive data from the future. All we need to do is emulate
    the data feed using historical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution has another evident and huge benefit: if we develop our application
    using an emulated data feed, then we can switch to a live data feed *without changing
    a single line of code*. So, this approach not only guarantees that the results
    of our tests are always honest but also that we save a massive amount of time
    by developing a *universal* application from the very beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: Enough talk, let’s get to coding.
  prefs: []
  type: TYPE_NORMAL
- en: Sliding window as a queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we’re ready to implement the sliding window using a Python queue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a class for our sliding windows first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a container for our sliding window and fill it with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the only method that appends a new element to this window and
    immediately deletes the oldest one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create an instance of this class with a length of just `5` (for demo purposes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the code that we created in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*. It already contains the global
    queue (data stream) that can be used to transfer any data from any object or module
    to any other. All we want now is to add two functions: one that reads data from
    a compressed file (bars) and sends it to the global data stream, and the other
    that reads bars from this data stream and pushes them to the sliding window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that we have completely reused the function that we created in [*Chapter
    5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving and Handling Market Data with
    Python*, when we learned how to handle data stored in files. Here, we read a bar
    from a CSV ASCII file, parse it, and convert it into a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s send this sample to the global queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, this is similar to what we did in the previous chapter, the only difference
    is that we now use a different function that gets data from a file. Anyway, the
    result is the same: we put the new sample into the global data stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that the delay here is added only for the sake of debugging and
    demonstration to emulate samples arriving at the application one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have finished the code that emulates the incoming data. Let’s look
    at it: any code written from this point and retrieving data from the global queue
    will be *independent* of any particular data source. If you want to replace the
    source or switch from testing to live trading, then all you need to do is to re-write
    the `emulate_bar_stream()` function. The rest of the code will remain unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need a function that reads from the global data queue and does something
    meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our present case, we will take only the closing price of the bar, push it
    to the sliding window, and then call any function that calculates a TA indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Making output to the console from a function is definitely a bad practice, but
    it’s added here only temporarily, to quickly check the correctness of the code
    during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start two threads: one that reads data from a file (or, in the future,
    from any other source) and the other that processes the received data. Don’t forget
    to import the `threading` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you did everything correctly, you should see something like this in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can see now how our sliding window is being filled with values from right
    to left, pushing older values out – *exactly* like a bar or tick chart on screen.
    So at any given moment, we have a *ready* sliding window of the specified length
    filled with any data we need to calculate an indicator – or to do any other thing
    we only could imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how easily we can build indicators using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Moving average – implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate an MA with our setup, we only need to calculate an average of
    all values in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It is indeed that simple! We don’t have to worry about any parameters because
    we already specified the length of the sliding window when we instantiated from
    the `sliding_window` class and specified the type of data (in our example, closing
    prices) when we fill the window with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our program now, we will get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This explains why we always disregard the first *N-1* values from a sliding
    window with a length of *N*; until *all* elements of the window are filled with
    meaningful data, the indicator’s value is meaningless and should be ignored. So,
    since in our example *N == 5*, we disregard the first 4 values.
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic oscillator – implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now see how we calculate a range indicator like a stochastic oscillator.
    Since this indicator requires three values per bar (`high`, `low`, and `close`),
    we may want to modify our code slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s replace the generic name of our sliding window from `sw` to `close`
    and add two more sliding windows for highs and lows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the function that calculates the stochastic indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `close[-1]` stands for the last available closing price (the one we will
    just receive if we run the code in real time).
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, let’s slightly modify the `retrieve_bars()` function so it adds
    data points to all three sliding windows (`high`, `low`, and `close`) and calculates
    the values of the stochastic indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run our code now, we will get something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Again, as always, we should disregard the first *N-1* values, so reasonable
    readings start from *line 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, it’s been a long and – I hope – interesting trip, so it’s time now to
    summarize what we learned.
  prefs: []
  type: TYPE_NORMAL
- en: Technical analysis assumes that price includes everything in itself and attempts
    to find repeating patterns of behavior, suggesting that the price action following
    a similar pattern will also be similar to what already happened in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just four major classes of technical studies, despite their visual
    diversity at first glance: market speed or momentum, digital filters, range, and
    volatility. Each type of study can be used to detect a certain situation in the
    market, but none of them can produce a ready profitable trading strategy on its
    own.'
  prefs: []
  type: TYPE_NORMAL
- en: The cornerstone of all technical studies is the sliding window, and the bane
    of technical trading is peeking ahead during development and testing. Using queues
    to emulate incoming data streams and to organize sliding windows solves the problem
    of peeking ahead once and for all.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, this approach makes your application scalable, flexible, and modular
    with the ability to connect to a live data source after testing without rewriting
    your trading code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have plenty of data points, we definitely want to visualize all
    of them to be able to quickly check the results or even trade live. So, let’s
    move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
