- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Technical Analysis and Its Implementation in Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术分析及其在Python中的实现
- en: In the previous chapter, we considered fundamental factors and saw how they
    may impact market prices. We noted that, although such an impact may be significant
    and potentially quite lucrative for trading, most of the time, it’s difficult
    to suggest a quantitative model that could generate unambiguous trading rules
    (when to enter the market, to which direction, and when to exit it) that wouldn’t
    require human discretion. For clarity’s sake, let’s note that there exist various
    fully quantitative approaches to evaluating fundamental factors, even political
    ones, but they are based on complex cross-discipline subjects, such as semantic
    analysis, and thus require solid knowledge of respective sciences. Is it possible
    to avoid this complexity and find a method to analyze market behavior using only
    price data? Or, maybe, some additional data, but only in numeric form?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们考虑了基本因素，并看到了它们如何可能影响市场价格。我们指出，尽管这种影响可能非常显著，并且可能对交易非常有利可图，但大多数时候，很难提出一个能够生成明确的交易规则（何时进入市场、朝哪个方向以及何时退出）的定量模型，而这些规则不需要人为判断。为了清楚起见，请注意，存在各种完全定量的方法来评估基本因素，甚至包括政治因素，但它们基于复杂的跨学科主题，如语义分析，因此需要对这些科学有扎实的知识。是否有可能避免这种复杂性，并找到一种仅使用价格数据来分析市场行为的方法？或者，也许，一些额外的数据，但仅以数字形式？
- en: The answer is yes, and this kind of market analysis is called **technical analysis**.
    In this chapter, we will consider its premises, learn about the most common technical
    indicators, and discover how they may be used to quantitatively describe various
    processes that go on in the market. We will also consider the implementations
    of key technical indicators in Python and introduce the concept of the sliding
    window, which will be used throughout all future codes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，这种市场分析被称为**技术分析**。在本章中，我们将考虑其前提，了解最常见的技术指标，并发现它们如何被用来定量描述市场上发生的过程。我们还将考虑关键技术指标在Python中的实现，并介绍滑动窗口的概念，该概念将在所有未来的代码中使用。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Technical analysis – ideal for computing, but missing real market processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术分析——适合计算，但缺少真实市场过程
- en: Momentum and RSI as indicators to measure the velocity of the market
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动量和RSI作为衡量市场速度的指标
- en: Digital filters and moving averages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字滤波器和移动平均线
- en: Range indicators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围指示器
- en: Volatility indicators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波动性指标
- en: Implementation of technical indicators in Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中实现技术指标
- en: Technical analysis – ideal for computing, but missing real market processes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术分析——适合计算，但缺少真实市场过程
- en: The main idea that lies in the foundation of **technical analysis**, or **TA**
    for short, is that *price includes everything in itself*. From this standpoint,
    if we see a price movement up or down, large or small, we don’t really want to
    know the reason behind this movement; instead, we just acknowledge that it was
    caused by some fundamental factors and try to focus on the future price development
    in regard to the observed price movement only.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 技术分析（或简称**TA**）的基础主要思想是*价格包含了一切*。从这个角度来看，如果我们看到价格上升或下降，大或小，我们并不真正想知道这种运动的背后原因；相反，我们只是承认它是由于某些基本因素造成的，并试图仅关注观察到的价格运动相关的未来价格走势。
- en: Of course, TA can analyze a *series* of data and not just a single data point.
    In this regard, TA studies help in identifying *patterns* or repeating sequences
    in price time series that bear resemblance to each other. TA suggests that if
    we observe a pattern that we already saw in the past, then the following price
    development will also be similar to what happened in the past; therefore, we can
    be prepared and exploit it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，技术分析可以分析一系列数据，而不仅仅是单个数据点。在这方面，技术分析研究有助于识别价格时间序列中的*模式*或重复的序列，它们彼此相似。技术分析建议，如果我们观察到过去已经看到的模式，那么接下来的价格走势也将类似于过去发生的情况；因此，我们可以做好准备并利用它。
- en: With TA, we don’t want and don’t need to know the actual fundamental factors
    that affected the price, we are only looking for *footprints* of something that
    happened behind the scenes and will then take action depending on the form of
    these footprints.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用技术分析（TA），我们不想也不需要知道影响价格的实际基本因素，我们只是在寻找幕后发生的事情的*痕迹*，然后根据这些痕迹的形式采取行动。
- en: 'Now that we understand the difference in the foundations of fundamental and
    technical analyses, let’s see how this difference impacts the two main practical
    points of any market analysis: its time horizon and precision.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本面分析和技术分析基础上的差异，让我们看看这种差异如何影响任何市场分析的两大主要实践点：其时间范围和精度。
- en: Fundamental analysis focuses on macroeconomic factors, which are always longer
    term by nature, so the time horizon for fundamental forecasts is normally days
    and above, up to years. On the contrary, technical studies may analyze extremely
    short-living processes (for example, momentary imbalances in the order book),
    and therefore, it’s normal that technical studies may have a forecast horizon
    of 1 second, 1 millisecond, and sometimes even a few microseconds.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本面分析侧重于宏观经济因素，这些因素在本质上总是长期性的，因此基本面预测的时间范围通常是几天以上，直至数年。相反，技术研究可能分析极其短暂的过程（例如，订单簿中的即时不平衡），因此，技术研究的预测范围可能为1秒、1毫秒，有时甚至几微秒，这是正常的。
- en: 'The main differences between fundamental and technical analyses are summarized
    in the following table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基本面分析和技术分析之间的主要区别总结在下表中：
- en: '|  | **Fundamental analysis** | **Technical analysis** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  | **基本面分析** | **技术分析** |'
- en: '| Key focus | Macroeconomics, politics, industry news, and the sentiment of
    investors | Price, volume, open interest, spreads, liquidity, and other quantitative
    parameters |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 关键关注点 | 宏观经济、政治、行业新闻和投资者的情绪 | 价格、成交量、开盘兴趣、价差、流动性和其他定量参数 |'
- en: '| Forecast horizon | Days to years | Microseconds to days, and rarely, weeks
    and months |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 预测范围 | 天到年 | 微秒到天，很少见的是周和月 |'
- en: '| Forecast precision | Very volatile | Depends on the timeframe |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 预测精度 | 非常波动 | 取决于时间框架 |'
- en: Table 7.1 – Key differences between fundamental and technical analyses
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – 基本面分析和技术分析的关键区别
- en: The building block of any TA study is an **indicator**. It is a combination
    of price, time, volume, and/or any other market data that can be quantitatively
    measured.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何技术分析研究的基石是一个**指标**。它是由价格、时间、成交量以及/或任何其他可以定量测量的市场数据组合而成的。
- en: 'Indicators are usually plotted as lines, dots, histograms, and other graphical
    objects *on* a price chart, *below* a price chart, or both. Normally, technical
    analysts use two to five indicators, each of them showing a particular feature
    of the examined price time series. *Figure 7**.1* shows a typical example of such
    a combination of TA indicators in a single chart:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 指标通常以线条、点、直方图和其他图形对象的形式绘制在价格图表上，位于价格图表下方，或者两者都有。通常，技术分析师使用两个到五个指标，每个指标都显示所考察的价格时间序列的特定特征。*图7.1*显示了这种技术分析指标组合在单个图表中的典型例子：
- en: '![Figure 7.1 – Typical layout of TA indicators with a price chart](img/B19145_7_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 技术分析指标与价格图表的典型布局](img/B19145_7_01.jpg)'
- en: Figure 7.1 – Typical layout of TA indicators with a price chart
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 技术分析指标与价格图表的典型布局
- en: Excessive use of TA indicators may lead to a mess when it’s really hard to understand
    what each of them shows and what the author of this mess really wanted to achieve.
    You probably can’t believe it, but the example in the following figure is not
    my fantasy, but something similar to what I saw with my own eyes so many times
    on various trading forums!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用技术分析指标可能导致混乱，真的很难理解每个指标显示的是什么，以及这个混乱的作者真正想要实现什么。你可能无法相信，但下图中所示的例子不是我的幻想，而是我在各种交易论坛上亲眼所见多次的类似情况！
- en: "![Figure 7.2 – How the excessive use of TA indicators may lead to \uFEFFabuse](img/B19145_7_02.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 过度使用技术分析指标可能导致滥用](img/B19145_7_02.jpg)'
- en: Figure 7.2 – How the excessive use of TA indicators may lead to abuse
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 过度使用技术分析指标可能导致滥用
- en: There is one thing common for all TA indicators – their values are always synchronized
    with the original price time series on which they are based.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有技术分析指标都有一个共同点 – 它们的值总是与它们所基于的原价时间序列保持同步。
- en: This means that if we build an indicator based on a 1-minute chart, then the
    values of this indicator will be updated every minute; for an hourly chart, the
    values will be updated every hour, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们基于1分钟图表构建一个指标，那么这个指标的价值将每分钟更新一次；对于小时图表，值将每小时更新一次，依此类推。
- en: As you can see, if we use a tick chart as the source data to calculate the values
    of a TA indicator, then these values will be updated on every tick. When we work
    with live data feeds, TA indicators show fixed, unchanged values for all historical
    bars (well, we can’t change history, can we?), but update the latest reading with
    every new tick that comes in for a bar that is not completed yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们使用tick图表作为计算技术指标值的源数据，那么这些值将在每个tick上更新。当我们处理实时数据流时，技术指标对于所有历史柱显示固定、未更改的值（嗯，我们无法改变历史，对吧？），但对于尚未完成的柱，会随着每个新tick的到来更新最新的读数。
- en: 'Regardless of their complexity, almost all TA indicators can be classified
    into four major groups: velocity of the market, digital filters, range indicators,
    and volatility indicators. Let’s consider each of them.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不论它们的复杂性如何，几乎所有技术指标都可以分为四大主要类别：市场速度、数字滤波器、范围指标和波动性指标。让我们逐一考虑它们。
- en: An important note before we proceed
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请注意一个重要事项
- en: In all the following discussions about technical indicators, we will use the
    term **current bar**. This doesn’t mean that we are talking only about the last
    (rightmost) bar on the chart. This means that when we plot charts, indicators,
    backtest strategies, and so on, we always move (imaginarily) from left to right,
    from historically older data to historically present, and we calculate anything
    *on every bar that we encounter*. This bar, for which we are calculating any values
    *at the moment*, is referred to as the **current bar**. We use this term because
    when we go live with our developments, the current bar will actually mean the
    price data that we receive *at this very moment*, so we don’t have to modify anything
    in our study or strategy code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有以下关于技术指标讨论中，我们将使用术语**当前柱**。这并不意味着我们只谈论图表上最后的（最右侧）柱。这意味着当我们绘制图表、指标、回测策略等时，我们总是从左到右移动（想象中），从历史较老的数据到历史当前的数据，并且我们在遇到的每一根柱上计算任何东西。这根柱，对于我们在此时计算任何值的，被称为**当前柱**。我们使用这个术语是因为当我们将我们的开发上线时，当前柱实际上将意味着我们此刻收到的价格数据，所以我们不需要在我们的研究或策略代码中做任何修改。
- en: With this important note in mind, let’s go ahead.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重要事项的提示下，让我们继续前进。
- en: Velocity of the market
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 市场速度
- en: These indicators try to answer the question, *How fast is the price moving?*.
    Indeed, if we compare a normal average day in the FX market with a release of
    important economic news or a political event, then we clearly see the difference.
    And of course, it would be nice to assess this difference quantitatively. We will
    consider only the two most well-known indicators of this kind – momentum and RSI
    – but any more sophisticated market speed indicator will be inevitably built on
    the same principles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标试图回答问题，“价格移动有多快？”。确实，如果我们比较外汇市场的一个正常平均日与重要经济新闻发布或政治事件，那么我们可以清楚地看到差异。当然，能够定量评估这种差异会更好。我们将仅考虑这类指标中最著名的两个——动量和RSI——但任何更复杂的市场速度指标都将不可避免地建立在相同的原则之上。
- en: Momentum
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动量
- en: 'This is probably the oldest technical indicator and definitely the simplest.
    It is really hard to imagine a simpler formula:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最古老的技术指标，并且绝对是最简单的。一个简单的公式真的很难想象：
- en: '![](img/Formula_B19145_07_001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![公式 B19145_07_001](img/Formula_B19145_07_001.png)'
- en: Here, *C*0 means the current closing price and *C*-1 means the closing price
    of the previous bar.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*C*0表示当前收盘价，而*C*-1表示前一根柱的收盘价。
- en: 'If we calculate these differences for every bar, store them in an array, and
    plot the indicator below the chart, we will see that its values no longer follow
    the price movements and, overall, it looks more like noise rather than a clear
    trending price pattern. However, this noise is quite informative. Even from a
    quick glance at the chart in *Figure 7**.3*, we can conclude a number of important
    points:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每一根柱计算这些差异，将它们存储在一个数组中，并在图表下方绘制指标，我们会看到其值不再跟随价格变动，整体上看起来更像噪声，而不是一个清晰的趋势价格模式。然而，这种噪声非常有信息量。即使快速浏览*图7.3*，我们也可以得出几个重要结论：
- en: '![Figure 7.3 – Basic momentum plotted below a price chart](img/B19145_7_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 基本动量绘制在价格图表下方](img/B19145_7_03.jpg)'
- en: Figure 7.3 – Basic momentum plotted below a price chart
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 基本动量绘制在价格图表下方
- en: First, we can see that the readings of momentum seldom remain in the positive
    or negative zone for more than two or three data points in a row. Since the momentum’s
    value is the difference between the current and the previous closing prices of
    just two adjacent bars, we can say that it’s not usual for this market that the
    price grew or declined steadily for more than three bars in a row. In other words,
    if we see more than two bars closing up, we may expect a bar to close down rather
    than another bar closing up. Technical analysts call these bars **corrections**;
    they may even appear inside quite long and steady trends, as in *Figure 7**.3*,
    but they do not break the trend. So, overall, we can say that this market is really
    prone to corrections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到动量的读数很少连续超过两个或三个数据点。由于动量的值是两个相邻柱子的当前和上一个收盘价之间的差异，我们可以说，在这个市场中，价格连续增长或下降超过三根柱子是不寻常的。换句话说，如果我们看到超过两根柱子收盘价上涨，我们可能会预期一根柱子收盘价下跌，而不是另一根柱子收盘价上涨。技术分析师将这些柱子称为**纠正**；它们甚至可能出现在相当长且稳定的趋势中，如*图7.3*所示，但它们不会打破趋势。因此，总的来说，我们可以说这个市场真的很容易发生纠正。
- en: Second, if we estimate the amplitude of the momentum indicator, we can see that
    it is different during different market regimes. While the market remained more
    or less *flat* (at the beginning of the chart), the amplitude of the momentum
    hardly exceeded 0.002 points, but as the uptrend was developing, its values increased
    to 0.004 by absolute value – that is, two times the *idle* market. So, we can
    assume that the *market speed* has some correlation with the market regime and
    could potentially use it in our own studies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果我们估计动量指标的范围，我们可以看到它在不同的市场阶段是不同的。当市场保持或多或少*平稳*（图表的开始部分）时，动量的幅度几乎没有超过0.002点，但随着上升趋势的发展，其绝对值增加到0.004
    – 也就是说，是*闲置*市场的两倍。因此，我们可以假设*市场速度*与市场阶段有一定的相关性，并且我们可以在自己的研究中潜在地使用它。
- en: 'Normally, the momentum indicator has one parameter – the number of bars between
    which we calculate the difference. In the classical formula at the beginning of
    this section, we compared the closing prices of two adjacent bars; of course,
    we can compare the price of the current bar with that of any bar in the past.
    If we continue doing that for every bar, we will get to a modified formula:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，动量指标有一个参数 – 我们计算差异的柱子数。在本节开头提到的经典公式中，我们比较了两个相邻柱子的收盘价；当然，我们可以比较当前柱子的价格与过去任何柱子的价格。如果我们继续对每一根柱子这样做，我们将得到一个修改后的公式：
- en: '![](img/Formula_B19145_07_002.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_B19145_07_002.png)'
- en: Here, *n* means the number of bars *back* from the current bar.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*n*表示从当前柱子往回数的柱子数。
- en: 'For example, if we set *n* to 24, then we calculate the difference in closing
    prices between the current bar and 24 bars ago (which, for an hourly chart, means
    the price strictly 24 hours or 1 day ago), we will see a somewhat different picture,
    as shown in *Figure 7**.4*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们把*n*设为24，那么我们计算当前柱子和24小时前的收盘价之间的差异（对于一个小时图来说，这意味着严格24小时或1天前的价格），我们将看到一幅不同的画面，如图*图7.4*所示：
- en: '![Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate
    of change for 24 hours](img/B19145_7_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 基于小时图的24小时动量表示24小时的价格变动率](img/B19145_7_04.jpg)'
- en: Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate
    of change for 24 hours
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 基于小时图的24小时动量表示24小时的价格变动率
- en: We can see that the *market speed*, or the price rate of change for 24 hours,
    looks totally different from the preceding chart, where we considered the difference
    in closing prices of just two neighbor bars. There’s no *noise* here anymore;
    instead, we observe longer-term changes in the momentum values. But the observations
    we made previously (regarding the corrections and correlations between *market
    speed* and range/trend markets) remain valid, as only the scale and proportions
    of these phenomena increased.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，*市场速度*，或者说24小时的价格变动率，与前一张图表中我们考虑的两个相邻柱子的收盘价差异完全不同。这里不再有*噪声*；相反，我们观察到动量值的长周期变化。但之前我们做出的观察（关于*市场速度*与范围/趋势市场之间的纠正和相关性）仍然有效，因为这些现象的规模和比例只是增加了。
- en: So, to summarize, the momentum indicator is useful to determine the idle market
    phases (when its readings are close to zero) and the highly active market (when
    its readings exceed a certain threshold). However, I hope you can see the evident
    shortcoming of this indicator in its present form – to decide whether the present
    market is active or not, we must specify this very *certain threshold* we just
    mentioned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，动量指标对于确定市场闲置阶段（当其读数接近零时）和高度活跃的市场（当其读数超过某个阈值时）是有用的。然而，我希望你能看到这个指标在当前形式下的明显不足——要决定当前市场是否活跃，我们必须指定我们刚才提到的这个*特定阈值*。
- en: What is this threshold? In the first example (*Figure 7**.3*), the momentum
    values never exceeded 0.006, while in the second one (*Figure 7**.4*), it reaches
    almost 0.02, which is *a order of magnitude* greater. So, if we say that market
    speed above 0.004 is *abnormally big*, then we have to agree that in the second
    example, the market is in *abnormally big* mode half of the time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阈值是什么？在第一个例子（*图7**.3*）中，动量值从未超过0.006，而在第二个例子（*图7**.4*）中，它达到了几乎0.02，这是*一个数量级*的差距。因此，如果我们说市场速度超过0.004是*异常大*的，那么我们必须同意在第二个例子中，市场有一半的时间处于*异常大*模式。
- en: It becomes clear that for the classical momentum indicator, there is no such
    threshold as a single unique numeric value. It depends on the market, the data
    resolution, and the momentum period. And it would be great if we could adjust
    the threshold value automatically, without the need for doing that manually every
    time, and consequently, eliminating possible human discretion bias.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经典动量指标，没有这样一个作为单一唯一数值的阈值。它取决于市场、数据分辨率和动量周期。如果能自动调整阈值值，而不需要每次都手动进行，那就太好了，从而消除可能的人为判断偏差。
- en: So, how can we get rid of subjectivity when setting such a threshold?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在设置这样的阈值时消除主观性呢？
- en: RSI
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSI
- en: The problem of answering the key question, *Is it big enough or still small*
    discussed in the previous section was solved for the momentum indicator by *J.*
    *Welles Wilder Jr.* in 1978\. In his book, *New Concepts in Technical Trading
    Systems*, he introduced the **relative strength index** (**RSI**), a new TA indicator
    that he suggested using in order to determine the *overbought* and *oversold*
    states of the market. In his terminology, *overbought* corresponds to the situation
    when prices grow *too quickly*, basically meaning that the market speed we discussed
    previously is too high. *Oversold* zones correspond to situations when prices
    fall *too quickly*, meaning the momentum is still greater than average by its
    absolute value but has a negative sign.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节讨论的关键问题“*是否足够大或仍然很小*”的问题，在1978年由*J.* *Welles Wilder Jr.*为动量指标解决了。在他的著作《新技术交易系统概念》中，他介绍了**相对强弱指数**（**RSI**），这是一种新的技术分析指标，他建议使用它来确定市场的*超买*和*超卖*状态。在他的术语中，*超买*对应于价格增长*过快*的情况，基本上意味着我们之前讨论的市场速度太高。*超卖*区域对应于价格下跌*过快*的情况，意味着动量在绝对值上仍然大于平均水平，但带有负号。
- en: 'RSI solves the problem of specifying a universal threshold for the momentum
    indicator by *normalizing* its values. Normalization is a process of scaling data
    so that all values fit into a certain range. For example, we have two datasets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RSI通过*归一化*其值来解决为动量指标指定一个通用阈值的难题。归一化是一个将数据缩放以便所有值都适合一定范围的过程。例如，我们有两个数据集：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We want to be able to compare *apples to apples*, and thus we want to scale
    both of them so the minimum and the maximum values of each dataset are the same.
    Typically, a range of 0 to 100 is used (it’s convenient: if we normalize data
    to this range we can then consider the values as a percentage). So, if we scale
    the first dataset to the range *0:100*, we will get an obvious sequence:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够比较*苹果与苹果*，因此我们希望将它们都缩放，使得每个数据集的最小值和最大值相同。通常，使用0到100的范围（这很方便：如果我们将数据归一化到这个范围，我们就可以将值视为百分比）。因此，如果我们将第一个数据集缩放到*0:100*的范围，我们将得到一个明显的序列：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But when we scale the second one, then `0` remains `0`, and the maximum value,
    which is `0.4`, becomes `100`, so the scaling coefficient is *100/0.4 = 250*.
    Then, the normalized dataset will look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们缩放第二个数据集时，`0`仍然是`0`，最大值，即`0.4`，变成了`100`，因此缩放系数是`100/0.4 = 250`。然后，归一化后的数据集将如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we can compare, for example, the rate of change of data points in both datasets
    using the same metrics, despite the fact that, originally, the second dataset
    contains values of *a order of magnitude smaller* than values in the first one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以比较，例如，两个数据集数据点的变化率，尽管最初第二个数据集包含的值比第一个数据集小*一个数量级*。
- en: So, the idea of the normalization of TA indicators is to scale them *automatically*
    so that their values always remain in the *0:100* range, or sometimes, *-100:100*.
    Let’s do it for the momentum.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，技术分析指标标准化的想法是*自动*缩放它们，使它们的值始终保持在*0:100*范围内，有时是*-100:100*。让我们为动量做这件事。
- en: 'Welles Wilder suggests calculating RSI in two steps: first, we calculate the
    **relative strength** (**RS**), and second, the RSI.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 威尔·威尔德建议分两步计算RSI：首先，我们计算**相对强度**（**RS**），然后计算RSI。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget that as with any other TA indicator, RSI uses *period*, a parameter
    that determines the number of data points we take into consideration. In the first
    example of the momentum indicator from the previous section, the period was just
    1, and in the second example, it was 24.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，与其他任何技术分析指标一样，RSI使用*周期*，这是一个确定我们考虑的数据点数量的参数。在前一节中动量指标的第一个例子中，周期是1，而在第二个例子中，它是24。
- en: 'To calculate the RS, we should first calculate the *gains* and *losses* for
    the period. A gain, in Wilder’s terminology, happened when a bar closed up, and
    a loss when a bar closed down. Then, we calculate the average of gains and the
    average of losses separately. And finally, we calculate the relative strength
    for the period:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算RS，我们首先应该计算该期间的*盈利*和*亏损*。在威尔德的说法中，盈利发生在柱状图收盘价上涨时，亏损发生在柱状图收盘价下跌时。然后，我们分别计算盈利和亏损的平均值。最后，我们计算该期间的相对强度：
- en: '![](img/Formula_B19145_07_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![公式B19145_07_003](img/Formula_B19145_07_003.jpg)'
- en: This formula is similar to the original momentum, only the momentum measures
    the *difference* between prices, and the RS measures the *ratio*. Using ratios
    is always preferred when we want to become independent of the original value range,
    where subtracting 0.01 from 0.1 will result in 0.09, while subtracting 10 from
    100 results in 90, and it’s evident that 90 and 0.09 differ by *4 orders of magnitude*,
    so it’s impossible to compare them directly. However, dividing 0.01 by 0.1 and
    dividing 10 by 100 produces exactly the same value, that is, 0.1, so in terms
    of market speed, this value is indeed the same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式与原始动量类似，只是动量衡量的是价格的*差异*，而RS衡量的是*比率*。当我们想要摆脱原始值域的依赖时，使用比率总是更受欢迎，例如从0.1中减去0.01将得到0.09，而从100中减去10将得到90，很明显90和0.09相差*4个数量级*，因此无法直接比较。然而，将0.01除以0.1和将10除以100会产生完全相同的结果，即0.1，因此从市场速度的角度来看，这个值确实是相同的。
- en: 'Now, we normalize the RS by keeping it always within the range of 0 to 100:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过保持RS始终在0到100的范围内来标准化RS：
- en: '![](img/Formula_B19145_07_004.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![公式B19145_07_004](img/Formula_B19145_07_004.jpg)'
- en: 'If we now plot the RSI along with the momentum on the same chart, we can see
    that the two indicators are very similar:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将RSI与动量在同一张图表上绘制，我们可以看到这两个指标非常相似：
- en: '![Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart](img/B19145_7_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 动量（顶部）和RSI（底部）在同一价格图表上绘制](img/B19145_7_05.jpg)'
- en: Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 动量（顶部）和RSI（底部）在同一价格图表上绘制
- en: Since RSI is normalized to a range of 0 to 100, typically, the values above
    70 are considered an *overbought* market, while values below 30 are spoken of
    as *oversold*. In the preceding chart, the *overbought* market corresponds to
    an uptrend, and absence of *oversold* state can be interpreted as a strong upside
    bias in the market sentiment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RSI被标准化到0到100的范围内，通常，高于70的值被认为是*超买*的市场，而低于30的值则被认为是*超卖*。在前面的图表中，*超买*的市场对应上涨趋势，而*超卖*状态的不存在可以解释为市场情绪强烈的看涨倾向。
- en: 'There are more market speed indicators than momentum and RSI, but all of them
    are used to determine the following market regimes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 市场速度指标比动量和RSI更多，但它们都用于确定以下市场状态：
- en: Idle versus active market (prices move slowly or quickly)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悠闲与活跃市场（价格移动缓慢或快速）
- en: Overbought/oversold zones (prices went *too high* or *too low*)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超买/超卖区域（价格*过高*或*过低*）
- en: Sharp bursts of prices mostly caused by liquidity issues (*spikes* on momentum
    charts)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于流动性问题导致的剧烈价格波动（动量图上的*尖峰*）
- en: So, momentum is good for detecting relatively short-living market situations.
    But what about something longer-term? Are there indicators that could show us
    a more global sentiment, a long-term tendency? Let’s move on to another class
    of TA indicators that is normally used for this very purpose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，动量对于检测相对短暂的市场情况是好的。但关于长期的东西呢？有没有指标可以显示给我们更全局的情绪，长期趋势？让我们继续探讨另一类通常用于此目的的技术分析指标。
- en: Digital filters
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字滤波器
- en: If you listen to music of any genre, and I hope you do, there’s a good chance
    that you are familiar with high-pass filters, low-pass filters, and equalizers.
    Any car audio, desktop, or mobile audio player offers this functionality. And
    I do hope that if you played with audio settings at least once in your life, you
    will remember what happens if you turn off treble and boost the bass to the maximum
    – that is, instead of music, you now hear only *boom-boom-boom*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你听过任何类型的音乐，我希望你确实听过，那么你很可能熟悉高通滤波器、低通滤波器和均衡器。任何汽车音响、桌面或移动音频播放器都提供这种功能。我确实希望，如果你在一生中至少调整过一次音频设置，你会记得如果你关闭高音并将低音提升到最大——那就是，你现在听到的不再是音乐，而是只有*砰砰砰*的声音。
- en: However, cutting off higher frequencies can also be quite useful if you want
    to focus on the rhythm, on the bass line, and probably on the chords and base
    (as opposed to harmonics) tones. And this is what lots of technical analysts dream
    of – to strip away all the *noise* from the market prices, leaving only the *bass
    line* or *rhythm*, – that is, the key trends and major price movements that last
    relatively long and, potentially, bring profits.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要专注于节奏、低音线，也许还有和弦和基音（而不是泛音）的话，截断更高频率的数据也可以非常有用。这正是许多技术分析师梦寐以求的——从市场价格中剥离所有*噪声*，只留下*低音线*或*节奏*——也就是说，关键趋势和持续时间相对较长的主要价格变动，这可能会带来利润。
- en: 'Surprisingly, or not, all TA indicators that do this job work *exactly* the
    same as low or high-pass filters in audio because they are based on *exactly the
    same* mathematical principles. That’s why we put them all in one section: digital
    filters.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶或不惊讶的是，所有执行这项工作的技术分析指标都和音频中的低通或高通滤波器*完全相同*，因为它们基于*完全相同*的数学原理。这就是为什么我们将它们都放在一个部分：数字滤波器。
- en: Moving averages
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动平均线
- en: A moving average is also one of the oldest technical indicators. It is calculated
    as the average of prices for the period and recalculated on every bar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均线也是最早的技术指标之一。它是通过计算周期内的价格平均值来计算的，并且在每个柱上重新计算。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we discuss TA indicators, we always use two terms: *period* and *current
    bar*. So let me just quickly remind you that a *period* means a number of data
    points (ticks, bars, any other samples from a time series) that the TA indicator
    analyzes, and the *current bar* changes one by one, left to right, as we reconstruct
    the historical values of the indicator, along with the historical values of the
    market price itself.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论技术分析指标时，我们总是使用两个术语：*周期*和*当前柱*。所以，让我快速提醒你一下，一个*周期*指的是技术分析指标分析的数据点（tick、柱、任何其他时间序列样本）的数量，而*当前柱*会一个接一个地变化，从左到右，随着我们重建指标的历史值以及市场价格本身的历史值。
- en: 'To give you a simple example, let’s consider the following dataset:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个简单的例子，让我们考虑以下数据集：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s calculate an average of three data points starting from the leftmost
    one. For the first element in the original dataset, it’s impossible to do because
    we have only one data point and we require three. The same for the second data
    point. So, we can start calculating the moving average from the third data point,
    and its value will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最左边的一个数据点开始计算三个数据点的平均值。对于原始数据集中的第一个元素，这是不可能的，因为我们只有一个数据点，而我们需要三个。第二个数据点也是如此。因此，我们可以从第三个数据点开始计算移动平均线，其值如下：
- en: '![](img/Formula_B19145_07_005.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_B19145_07_005.jpg)'
- en: 'Then, we move on to the fourth data point and again calculate the value of
    the moving average, but this time, we start calculating from the second element
    in our dataset:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们移动到第四个数据点，并再次计算移动平均线的值，但这次，我们从我们的数据集中的第二个元素开始计算：
- en: '![](img/Formula_B19145_07_006.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_B19145_07_006.jpg)'
- en: 'Proceeding in this way, we will get a new dataset that represents the average
    values of three data points in a row, recalculated for each data point from left
    to right. Therefore, for the first two data points, we don’t have any value (as
    the number of original data points was insufficient to calculate a three-point
    average):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式进行，我们将得到一个新的数据集，它表示连续三个数据点的平均值，并从左到右对每个数据点重新计算。因此，对于前两个数据点，我们没有任何值（因为原始数据点的数量不足以计算三个点的平均值）：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'I hope you got the point: we always take three samples from the dataset, calculate
    the average, store this value in a new dataset, and move on to the next sample.
    This technique is called the **moving window** and is the basis for the calculation
    of all TA indicators.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们已经明白了：我们总是从数据集中取三个样本，计算平均值，将这个值存储在新数据集中，然后继续下一个样本。这种技术被称为**移动窗口**，是所有技术分析指标计算的基础。
- en: Normally, **moving averages** (**MAs**) are calculated based on the closing
    prices of bars, but nothing prevents us from using them with any other price (such
    as high, low, or trade) or non-price data (such as volume, liquidity, and so on).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**移动平均线（MAs**）是基于柱状图的收盘价计算的，但没有任何东西阻止我们使用其他价格（如高、低或交易）或非价格数据（如成交量、流动性等）。
- en: It’s evident that an MA with a period of one equals the original time series.
    How will values of MAs with greater periods correspond to the original data?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，周期为1的移动平均线等于原始时间序列。那么，周期更长的移动平均线的值将如何对应原始数据？
- en: 'Let’s plot the original price time series in form of just dots, not bars, where
    each dot will denote a closing price of the bar. And let’s plot 3 different MAs
    along with the original series with periods of 2, 3, 5, and 10, respectively:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以点而不是柱状图的形式绘制原始价格时间序列，其中每个点将表示柱状的收盘价。然后让我们绘制3个不同的移动平均线，分别以2、3、5和10个周期与原始序列一起绘制：
- en: '![Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD](img/B19145_7_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 在EURUSD收盘价1小时图表上绘制的3、7和13周期移动平均线](img/B19145_7_06.jpg)'
- en: Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 在EURUSD收盘价1小时图表上绘制的3、7和13周期移动平均线
- en: '*Figure 7**.6* plots the original time series as bars, and 3, 7, and 13-period
    MAs as dashes, crosses, and solid lines, respectively. We can see that the smaller
    the period of an MA, the closer its values are to the original series, and the
    greater the period, the *smoother* the change in the MA’s values.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6* 以柱状图形式绘制原始时间序列，以及3、7和13周期的移动平均线分别以虚线、交叉线和实线表示。我们可以看到，移动平均线的周期越小，其值越接近原始序列，周期越大，移动平均线值的变动就越*平滑*。'
- en: This *smoothing* is the very effect of a low-pass filter. Surprisingly, an MA,
    calculated using simple mathematics, *is* a digital filter, pretty close to those
    used in audio processing. The greater the period of the MA, the lower the maximum
    frequency passed by such a filter. So, if applied to an audio signal, such a filter
    will leave us with *boom-boom*, and now we can see this *boom-boom* in the market
    prices. Ultimately, using MAs with a period of 20, 50, or 200 will show only longer-term
    changes in the market prices, considering minor price movements as high-frequency
    noise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*平滑*正是低通滤波器的效果。令人惊讶的是，使用简单数学计算的移动平均线*确实*是一个数字滤波器，与音频处理中使用的那些相当接近。移动平均线的周期越长，通过该滤波器的最大频率就越低。因此，如果应用于音频信号，这样的滤波器将只留下*砰砰*声，现在我们可以在市场价格中看到这种*砰砰*声。最终，使用20、50或200周期的移动平均线将只显示市场价格的长周期变化，将较小的价格变动视为高频噪声。
- en: '*Figure 7**.7* shows the same hourly chart of EURUSD with closing prices only,
    plotted as big black dots, and 20-, 50-, and 200-period MAs on top of it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.7* 展示了EURUSD的相同小时图表，只有收盘价，以大黑点表示，并在其上方绘制了20、50和200周期的移动平均线：'
- en: '![Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing
    prices of EURUSD](img/B19145_7_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 在EURUSD收盘价1小时图表上绘制的20、50和200周期移动平均线](img/B19145_7_07.jpg)'
- en: Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing
    prices of EURUSD
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 在EURUSD收盘价1小时图表上绘制的20、50和200周期移动平均线
- en: In this example, we can see that the MA with the greatest period (200) only
    grows with slight changes in the growth rate, while MAs with shorter periods grow
    and decline, and the smaller the period of the MA, the closer its values are to
    the original series.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到，周期最长的移动平均线（200）只随着增长率的一点点变化而增长，而周期较短的移动平均线则增长和下降，移动平均线的周期越小，其值就越接近原始序列。
- en: 'So, MAs are the simplest digital filters and are designed to detect *tendencies*
    rather than immediate activity. They are used in TA to solve the following problems:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，移动平均线是最简单的数字滤波器，旨在检测*趋势*而不是即时活动。它们在技术分析（TA）中用于解决以下问题：
- en: To determine long- and medium-term trends
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确定长期和中期趋势
- en: To distinguish bullish and bearish markets (normally, when daily prices close
    above the 200-period MA, the market is considered bullish, and vice versa)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了区分牛市和熊市（通常，当每日价格收盘价高于200周期移动平均线时，市场被认为是牛市，反之亦然）
- en: To smoothen *occasional* or *abnormal* sharp price movements
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了平滑偶尔或异常剧烈的价格波动
- en: Very frequently, MAs are used in combination with momentum indicators – for
    example, an MA can be used to determine whether the market is bullish (closing
    prices above 200-period MA), and momentum can determine the moment when the market
    speed is high, so potentially, it could be a good time to buy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的是，移动平均线（MAs）与动量指标结合使用 – 例如，移动平均线可以用来判断市场是否看涨（收盘价高于200周期移动平均线），而动量可以确定市场速度高的时刻，因此，这可能是一个买入的好时机。
- en: However, you probably already heard about traders who lost their fortune buying
    when prices were already too high or selling when prices were already too low.
    I hope now that we have so thoroughly examined the design of market speed indicators
    and digital filters, you have already spotted the bottleneck here – *too high*
    or *too low*. But how do we decide that it’s already *too* high or still *not
    so* high? The answer is in the following section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经听说过那些在价格已经过高时买入或价格已经过低时卖出而损失财富的交易者。我希望现在我们已经彻底研究了市场速度指标和数字滤波器的设计，你已经发现了这里的瓶颈
    – 过高或过低。但我们是怎样决定它已经过高或仍然不算高呢？答案将在下一节中揭晓。
- en: Range indicators
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围指标
- en: One of the most common methods to solve the problem of identifying whether the
    current price is in any extreme zone (too high or too low) is using range indicators.
    Normally, a **price range** is a difference between the maximum price and the
    minimum price for, well (I’m sure I heard you say that), a *period*. As always,
    with technical indicators, we’re bound to a certain timespan, a moving window
    that we slide along the chart from left to right. So, when we talk about range,
    we have to define the period for which this range is calculated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决识别当前价格是否处于任何极端区域（过高或过低）的最常见方法之一是使用范围指标。通常，**价格范围**是最高价和最低价之间的差异，嗯（我确信你说过），在一个*周期*内。像往常一样，与技术指标一样，我们被限制在某个时间段内，一个沿着图表从左到右滑动的移动窗口。因此，当我们谈论范围时，我们必须定义这个范围是针对哪个周期计算的。
- en: 'Let’s look at the chart shown in *Figure 7**.8*. The rectangle shows the maximum
    and minimum price of a 24-bar span (since it’s an hourly chart, this means the
    rectangle corresponds to 1 day):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图7*.*8*中显示的图表。矩形显示了24个周期内的最高价和最低价（由于这是一个小时图表，这意味着矩形对应1天）：
- en: '![Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage
    of range, EURUSD, 1-hour](img/B19145_7_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 24小时价格范围，显示为范围百分比的2个收盘价，EURUSD，1小时](img/B19145_7_08.jpg)'
- en: Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage
    of range, EURUSD, 1-hour
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 24小时价格范围，显示为范围百分比的2个收盘价，EURUSD，1小时
- en: Two closing prices are marked with small arrows. Horizontal lines are drawn
    through these closing prices to visualize the price levels relative to the range
    rather than absolute values. So, for the first (left to right) closing price,
    the absolute value is 1.1260, but relative to the range, it’s right at 50% of
    it. The second closing price is 1.1292, but relative to the range, it’s about
    85% of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两个收盘价用小箭头标记。通过这些收盘价画水平线，以可视化价格水平相对于范围而不是绝对值。因此，对于第一个（从左到右）收盘价，绝对值是1.1260，但相对于范围，它正好是50%。第二个收盘价是1.1292，但相对于范围，它大约是85%。
- en: Got the point? We can replace absolute price values that don’t say much with
    relative price levels, which could be interpreted pretty much as we interpreted
    RSI values (see the *RSI* section). For example, we can say that when the price
    is above 80% of the range level, then the price is *too high*, and when the price
    is below 20% of the range level, then the price is *too low*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？我们可以用相对价格水平来代替没有太多信息的绝对价格值，这些水平可以解释得和解释RSI值（见*RSI*部分）差不多。例如，我们可以说，当价格高于范围水平的80%时，那么价格就是*过高*的，而当价格低于范围水平的20%时，那么价格就是*过低*的。
- en: The first and the most well-known range indicator is the **stochastic oscillator**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名且广为人知的范围指标是 **随机振荡器**。
- en: Stochastic oscillator
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机振荡器
- en: '**Stochastic** is quite a popular word among traders, but unfortunately, it
    is often used improperly. In mathematics, the term *stochastic* means a variety
    of random processes. To understand what it means, let’s consider an example.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机**在交易者中是一个非常流行的词，但不幸的是，它经常被错误地使用。在数学中，*随机* 这个术语意味着各种随机过程。为了理解它的含义，让我们考虑一个例子。'
- en: If you go out to buy some bread, then you will most likely go down the same
    streets, end your route at the same local grocery store, and spend more or less
    the same amount of time as usual. This is an example of a *deterministic process*
    – although there can be some *fluctuations* or deviations down the road (for example,
    you decide to walk on this or that side of the street), the overall route and
    destination remain the same.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你出去买一些面包，那么你很可能会走相同的街道，在同一个当地杂货店结束你的路线，并且花费的时间与平时差不多。这是一个 *确定性过程* 的例子——尽管在路上可能会有一些
    *波动* 或偏差（例如，你决定走这条或那条街道），但整体路线和目的地保持不变。
- en: Now, imagine that you go out with no particular goal in mind and stop at any
    shop, bar, or movie theater you like, spend any amount of time in each, and decide
    where to go next by tossing a coin. Every time you take such a trip, its trajectory,
    destinations, and time spent, both on each leg and the entire journey, will differ.
    Although the area where you’re traveling is confined and you visit the same places,
    the map of your actual movements will be different because of the *randomness*
    of your decisions. Such a process is called *stochastic* or *random* or *probabilistic*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，你出去时没有特定的目标，在任何你喜欢的商店、酒吧或电影院停下来，在每个地方花费任意时间，并通过抛硬币来决定下一步去哪里。每次你进行这样的旅行，其轨迹、目的地以及在每个阶段和整个旅程中所花费的时间都会不同。尽管你旅行的区域是有限的，并且你访问了相同的地方，但由于你决策的
    *随机性*，你实际移动的地图将会不同。这样的过程被称为 *随机*、*随机* 或 *概率*。
- en: 'Market price movements are also considered random or stochastic processes by
    many researchers, who have suggested various probabilistic models that describe
    price behavior. Although this standpoint can also be criticized, such an academic
    debate is definitely outside the scope of this book, so the main points we should
    take away from this brief *lyrical digression* are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究人员也将市场价格变动视为随机或随机过程，他们提出了各种概率模型来描述价格行为。尽管这种观点也可以受到批评，但这种学术辩论显然超出了本书的范围，所以我们应该从这次简短的
    *抒情插叙* 中吸取的主要观点如下：
- en: Processes with a definite trajectory, target, and time are called **deterministic**
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有明确轨迹、目标和时间的过程被称为 **确定性**。
- en: Processes where every next step has just some probability and you never know
    for sure where and when it reaches any target are called **stochastic**
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每下一步都有一定概率，并且你永远不知道它何时何地达到任何目标的过程被称为 **随机**。
- en: Changes in market prices can be considered a **stochastic process**
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场价格的变化可以被视为一个 **随机过程**。
- en: The stochastic oscillator has nothing in common with **stochastic processes**
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机振荡器与 **随机过程** 没有任何共同之处。
- en: 'The stochastic oscillator in its original form shows exactly what we considered
    at the very end of the previous section – it shows where the current price is
    as a percentage of a certain price range. So, in order to calculate the stochastic
    oscillator, we should choose a period (number of data points), then find the maximum
    and the minimum price for this period, and then calculate the value of the stochastic
    oscillator:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随机振荡器在其原始形式中恰好显示了我们在上一节最后所考虑的内容——它显示了当前价格作为某个价格范围的百分比。因此，为了计算随机振荡器，我们应该选择一个周期（数据点数量），然后找到这个周期内的最高价和最低价，然后计算随机振荡器的值：
- en: '![](img/Formula_B19145_07_008.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/Formula_B19145_07_008.jpg)'
- en: Here, *P*0 means the current price, *L* means the lowest price for the period,
    and *H* means the highest price for the period.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*P*0 表示当前价格，*L* 表示该期间内的最低价格，而 *H* 表示该期间内的最高价格。
- en: 'Let’s again open an hourly chart of a currency pair, but this time, the Japanese
    yen for a change, and let’s plot this indicator with a period of 24 below it (thus
    tracking changes in price as a percentage of a day’s range):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开一个货币对的每小时图表，但这次，为了改变一下，我们来看日元，并在其下方绘制这个指标，周期为 24（因此跟踪价格作为一天范围内的百分比变化）：
- en: '![Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart
    of USDJPY](img/B19145_7_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 美元/日元1小时图表下的基本24周期随机振荡器](img/B19145_7_09.jpg)'
- en: Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart of
    USDJPY
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 美元/日元1小时图表下的基本24周期随机振荡器
- en: In *Figure 7**.9*, we can see that the stochastic oscillator indeed *oscillates*
    in a range from 0 to 100 (what a surprise). During trends (right half of the picture),
    it tends to stay above 50, and in sideways markets (middle part of the picture)
    it can oscillate full scale.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.9*中，我们可以看到随机振荡器确实在0到100的范围内*振荡*（真是个惊喜）。在趋势期间（图片的右半部分），它倾向于保持在50以上，而在横向市场中（图片的中间部分）它可以全范围振荡。
- en: So, what’s the possible application of the stochastic oscillator?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，随机振荡器可能的用途是什么？
- en: First and foremost, it’s used to answer the question of whether the price is
    *too high* or *too low* (I hope you remember this Shakespearean question from
    the end of the previous section). We can say, for example, that when the price
    is above the level of 80 – which means that the price is greater than 80% of the
    price range – then it is indeed *too high*. Likewise, being under 20% of the range
    could mean that the price is *too low*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它被用来回答价格是否*过高*或*过低*的问题（我希望你能记住上一节末尾的这个问题）。例如，我们可以这样说，当价格高于80的水平时——这意味着价格高于价格范围的80%——那么它确实*过高*。同样，低于20%的范围可能意味着价格*过低*。
- en: Second, some technical traders like to use stochastic and similar oscillators
    to determine trends. We already saw that, during trends, the stochastic oscillator
    tends to remain above (for uptrends) or below (for downtrends) 50% of the range
    for quite a long time. It’s no wonder that trends are special market regimes where
    corrections in prices are much smaller and last for a much shorter time than the
    movements in the direction of the trend. So, prices will indeed remain in the
    upper or lower half of the range for many hours, days, or sometimes even weeks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一些技术交易者喜欢使用随机振荡器及其类似振荡器来确定趋势。我们已经看到，在趋势期间，随机振荡器往往会保持在（对于上升趋势）或低于（对于下降趋势）范围50%以上相当长的时间。因此，趋势是特殊的市场状态，其中价格修正幅度较小，持续时间比趋势方向的移动时间短得多。所以，价格确实会在范围的上下半部分保持许多小时、几天，有时甚至几周。
- en: 'There are numerous modifications of the stochastic oscillator. For example,
    adding an MA to its values (and we remember that we can add an MA to any time
    series, not necessarily price) gives us a so-called *slow stochastic*. Some authors
    suggest using the original indicator and the averaged one on the same chart, but
    the essence remains the same – this is a range oscillator and can, therefore,
    be used to solve the following problems:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随机振荡器有许多修改版本。例如，将其值添加到移动平均线（我们记得我们可以将移动平均线添加到任何时间序列，而不仅仅是价格）给我们一个所谓的*慢速随机振荡器*。一些作者建议在同一图表上使用原始指标和平均指标，但本质仍然是相同的——这是一个范围振荡器，因此可以用来解决以下问题：
- en: Identifying whether the price is *too high* or *too low*
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别价格是否*过高*或*过低*
- en: Identifying trends as long-term periods when prices are above or below 50% of
    the range
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当价格高于或低于50%的范围时，识别趋势作为长期时期
- en: Suggesting buy signals when the oscillator starts going up from *too* *low*
    levels
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当振荡器从*过低*水平开始上升时，提出买入信号
- en: Suggesting sell signals when the oscillator starts going down from *too* *high*
    levels
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当振荡器从*过高*水平开始下降时，提出卖出信号
- en: Now that we have a speed indicator (momentum or RSI) that tells us that the
    market is moving fast, a digital filter (MAs) that confirms that the main tendency
    in the market is still positive, and a range indicator (stochastic) that shows
    that the asset is currently oversold, it may look like it’s a good time to buy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个速度指标（动量或RSI），它告诉我们市场正在快速移动，一个数字滤波器（移动平均线）确认市场的主要趋势仍然是积极的，以及一个范围指标（随机振荡器）显示资产目前超卖，看起来现在是买入的好时机。
- en: But!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但是！
- en: Even if we calculated the timing of our entry with the highest degree of perfection,
    markets still remain stochastic processes (remember what we started with at the
    beginning of this section?) and it is normal that price may go against you for
    some time. The key question here is whether this adverse price movement is only
    a small correction and it’s wise to just wait till red turns green, or you were
    wrong with your trading decision (which, by the way, is also absolutely normal)
    and should liquidate your losing position before it drains your account completely.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将进入市场的时机计算得非常完美，市场仍然保持随机过程（记得本节开头我们提到的吗？）并且价格可能一段时间内对你不利是正常的。这里的关键问题是这种不利的价格变动是否只是一个小幅修正，并且明智地等待直到红色变为绿色，或者你的交易决策是错误的（顺便说一句，这也是绝对正常的），你应该在账户被完全耗尽之前平仓亏损头寸。
- en: Normally, this problem is solved by adding volatility studies to the trading
    strategy logic.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个问题是通过将波动性研究添加到交易策略逻辑中解决的。
- en: Volatility indicators
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 波动性指标
- en: If we look up the definition of volatility in Merriam-Webster, the first suggested
    meaning would be *a tendency to change quickly and unpredictably*. Sounds good,
    but how can we measure this tendency, this ability to change?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查阅Merriam-Webster对波动性的定义，第一个建议的含义将是*快速且不可预测地变化的倾向*。听起来不错，但我们如何衡量这种倾向，这种变化的能力？
- en: 'Wikipedia ([https://en.wikipedia.org/wiki/Volatility_(finance)](https://en.wikipedia.org/wiki/Volatility_(finance)))
    suggests a different definition: *“volatility (usually denoted by σ) is the degree
    of variation of a trading price series over time, usually measured by the standard
    deviation of logarithmic returns.”* If you are not familiar with mathematical
    statistics, this may sound like a foreign language to you, but don’t worry, let’s
    take a quick tour of the theory of probability.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科（[https://en.wikipedia.org/wiki/Volatility_(finance)](https://en.wikipedia.org/wiki/Volatility_(finance))）提出了不同的定义：*“波动性（通常用σ表示）是交易价格序列随时间变化的程度，通常通过对数收益的标准差来衡量。”*
    如果你对数学统计学不熟悉，这可能会听起来像一门外语，但别担心，让我们快速浏览一下概率论的理论。
- en: Let’s use the same example with a random walk around bars and movie theaters.
    Let’s measure the distance between the starting point (your home, presumably)
    and the ending point (where you decide to finish your walk for the day). Every
    day, we will get different values because you make your travel decisions randomly.
    However, we can calculate the average value and say that, on average, you walk,
    say, three kilometers per walk.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用同样的例子，在酒吧和电影院周围进行随机漫步。让我们测量起点（你的家，假设）和终点（你决定当天结束散步的地方）之间的距离。每天，你都会得到不同的值，因为你随机做出旅行决定。然而，我们可以计算平均值，并说平均每次散步你走了大约三公里。
- en: The devil is always in the details, and the devil of averaging is called **dispersion**.
    This is a measure of how much the actual values of a certain random variable differ
    from the average, or *mean* value. Let’s consider two examples.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恶魔总是在细节中，平均的恶魔被称为**分散度**。这是衡量某个随机变量的实际值与平均值或*均值*差异的程度。让我们考虑两个例子。
- en: 'First, let’s go back to a deterministic process when you go out to a local
    grocery. We record travel distances for each trip and put them into a dataset:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下当你去当地杂货店时的确定性过程。我们记录每次旅行的距离，并将它们放入数据集中：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s calculate the mean value of this dataset:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算这个数据集的平均值：
- en: '![](img/Formula_B19145_07_009.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/Formula_B19145_07_009.jpg)'
- en: 'Now, subtract this mean value from each element of the original dataset:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这个原始数据集的每个元素中减去这个平均值：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that the difference between almost all recorded values and their
    mean is *a order of magnitude smaller* than the mean itself. The only exception
    is the last values in the `D` dataset: the difference between it and the mean
    is comparable to the value itself. Such a value is called an **outlier** and is
    most likely explained by incorrect measurements or something exceptional that
    happened to you down the road.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，几乎所有记录的值与它们的平均值之间的差异都比平均值本身小一个数量级。唯一的例外是`D`数据集中的最后几个值：它与平均值的差异与它本身的值相当。这样的值被称为**异常值**，最可能是由错误的测量或你在路上遇到的某些异常情况所解释。
- en: 'Now, let’s record the distances traveled each time you took a random walk around
    the local bars and movie theaters. In some cases, you found a nice place to stay
    almost as soon as you left your house; in other cases, you walked quite a lot
    and still returned home unsatisfied, hence the difference in the distance you
    traveled each time. We will get a dataset like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们记录你每次在本地酒吧和电影院周围随机漫步时走过的距离。在某些情况下，你几乎在你离开家的时候就能找到一个不错的住处；在其他情况下，你走了相当长的一段路，但仍然不满意地回到家，因此你每次走过的距离有所不同。我们将得到一个类似这样的数据集：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Its mean value is 1.645\. If we now do the same as previously (that is, subtract
    this mean from each element of the dataset), we will see that the differences
    now are quite comparable to the mean value, and in some cases, nearly exceed it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它的平均值是1.645。如果我们现在像之前一样做（即从数据集的每个元素中减去这个平均值），我们会看到差异现在与平均值相当，在某些情况下，几乎超过了它：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The process in which the differences between values and their mean are way smaller
    than the values themselves is a *deterministic process*, and now we have a more
    math-looking definition of it (although it’s still not formally correct). Conversely,
    the process where the differences between values and their mean are comparable
    to the mean itself is a *stochastic* or *random* process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当值与其平均值之间的差异远小于值本身时，这个过程被称为**确定性过程**，现在我们有一个更数学化的定义（尽管它仍然不是正式正确的）。相反，当值与其平均值之间的差异与平均值本身相当的过程是一个**随机**或**随机**过程。
- en: So, back to the market stuff. If we do the same math with prices (for example,
    recording the changes in price for each bar and then calculating their mean value
    and the difference), then we can use this difference as the measure of *volatility*.
    It will indeed match the Merriam-Webster definition – the greater the differences
    in question, the less predictable the values and the quicker the possible changes
    in prices.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，回到市场相关的话题。如果我们对价格做同样的数学运算（例如，记录每个柱状图的价格变化，然后计算它们的平均值和差异），那么我们可以使用这个差异作为**波动性**的衡量标准。这确实符合Merriam-Webster的定义——所讨论的差异越大，值就越不可预测，价格的可能变化就越快。
- en: In practice, a bit more complex calculation is used to determine market volatility.
    One of the commonly used metrics that estimate *how far the values of a dataset
    are from their mean* is called **standard deviation**. If you are interested in
    learning more about it and the mathematics behind the concept of volatility, I
    encourage you to first read the basics about mathematical statistics to get familiar
    with the terminology and the key concepts. The article in Wikipedia ([https://en.wikipedia.org/wiki/Mathematical_statistics](https://en.wikipedia.org/wiki/Mathematical_statistics))
    could be a good starting point. In the meantime, we continue in a somewhat informal
    manner and remember that standard deviation is used to estimate the volatility
    in any stochastic process and market prices in particular.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，为了确定市场波动性，通常会使用稍微复杂一些的计算。用于估计“数据集的值与其平均值之间差异程度”的常用指标被称为**标准差**。如果您想了解更多关于它以及波动性概念背后的数学知识，我鼓励您首先阅读有关数学统计学的基础知识，以便熟悉术语和关键概念。维基百科上的文章（[https://en.wikipedia.org/wiki/Mathematical_statistics](https://en.wikipedia.org/wiki/Mathematical_statistics)）可以作为一个良好的起点。同时，我们以一种较为非正式的方式继续讨论，并记住标准差被用来估计任何随机过程以及特别是市场价格的波动性。
- en: 'I am sure you now perfectly understand that **standard deviation** (or **stddev**
    for short) also requires a period quite like any other TA indicator. This period
    is the length of the dataset for which we measure the volatility. So, what we’re
    plotting is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在完全理解了**标准差**（或简称为**stddev**）也需要一个周期，就像其他任何技术分析指标一样。这个周期是我们用来测量波动性的数据集长度。因此，我们绘制的如下：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be shown in the form of an equation like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下形式的方程表示：
- en: '![](img/Formula_B19145_07_010.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![公式图片](img/Formula_B19145_07_010.jpg)'
- en: Here, *c*i means the closing price of the *i*-th bar, ![](img/Formula_B19145_07_011.png)
    denotes the mean value, and *24* means the number of data points (closing prices
    of bars) for which we calculate `stddev`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*c*i 表示第 *i* 个柱状图的收盘价，![](img/Formula_B19145_07_011.png) 表示平均值，*24* 表示我们计算`stddev`的数据点（柱状图的收盘价）数量。
- en: '*Figure 7**.10* shows the same 1-hour chart of GBPUSD as in the previous example,
    but now with the 24-period standard deviation indicator below it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.10*显示了与上一个例子中相同的GBPUSD 1小时图表，但现在在下面添加了24周期标准差指标：'
- en: '![Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing
    prices](img/B19145_7_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – GBPUSD的每小时图表，显示收盘价的标准差](img/B19145_7_10.jpg)'
- en: Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing prices
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – GBPUSD的每小时图表，显示收盘价的标准差
- en: 'We can see that volatility is something that doesn’t have any evident relationships
    with the direction of the market prices or with trend/sideways market regimes.
    What we *can* see though is a number of important observations:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，波动性与市场价格的走势或趋势/横向市场制度之间没有明显的关联。尽管如此，我们可以观察到一些重要的观察结果：
- en: Standard deviation is always positive; it disregards the direction of the price
    movement
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准差始终为正；它不考虑价格变动的方向
- en: A sudden increase in the market activity does increase values of the standard
    deviation of closing prices
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场活动突然增加确实会增加收盘价标准差值
- en: The longer the price remains at new levels (see the jump in price on July 27
    and a congestion zone following it the next day), the greater the increase in
    values of the standard deviation
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格在新水平上停留的时间越长（参见7月27日的价格跳跃以及次日的拥堵区域），标准差值增加得就越大
- en: Maximums and minimums in the `stddev` indicator do not correspond to maximums
    and minimums in the price chart
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stddev`指标中的最大值和最小值与价格图中的最大值和最小值不对应'
- en: Interesting picture, but there’s one questionable assumption here, and I hope
    you already exclaimed, “*Wait! But we measure the standard deviation of an incorrect
    dataset! Why do we measure it for the price itself when we should have done that
    for* *price increments?*”.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的画面，但这里有一个值得怀疑的假设，我希望你已经喊出了，“**等等！但我们测量的是错误数据集的标准差！为什么我们应该测量价格本身的标准差，而不是**价格变动**的标准差呢？”。
- en: 'Indeed, the market process can be considered a stochastic process from a number
    of standpoints. We can consider every closing price as an independent value of
    a random process, or we can look at price movements as a random walk process,
    where we’re interested only in how much the price changed since the last observation
    (bar). So instead of calculating the standard deviation of *closing prices*, we
    should rather calculate the standard deviation of *changes in price* for each
    bar:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，从多个角度来看，市场过程可以被视为一个随机过程。我们可以将每个收盘价视为随机过程的独立值，或者我们可以将价格变动视为随机游走过程，我们只对价格自上次观察（柱）以来变化了多少感兴趣。因此，我们与其计算**收盘价**的标准差，不如计算每个柱的**价格变动**的标准差：
- en: '![](img/Formula_B19145_07_012.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_B19145_07_012.jpg)'
- en: Here, *C*i means the current bar, *C*i-1 means the previous bar, and the delta
    symbol means the price increment per bar (positive or negative – and this is the
    key difference from calculating standard deviations for prices, as they can only
    be positive).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*C*i代表当前柱，*C*i-1代表前一个柱，而delta符号代表每根柱的价格变动（正或负——这是与计算价格标准差的关键区别，因为它们只能为正）。
- en: 'Let’s see whether there’s any difference between the standard deviation of
    closing prices and the standard deviation of *differences* of closing prices.
    *Figure 7**.11* still shows the same chart of GBPUSD with both standard deviations
    plotted below it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看收盘价的标准差和收盘价**差异**的标准差之间是否有任何区别。**图7.11**仍然显示了GBPUSD的相同图表，其中两个标准差都绘制在其下方：
- en: '![Figure 7.11 – Two versions of the standard deviation-based volatility indicator](img/B19145_7_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 基于标准差波动性的两种版本指标](img/B19145_7_11.jpg)'
- en: Figure 7.11 – Two versions of the standard deviation-based volatility indicator
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 基于标准差波动性的两种版本指标
- en: 'The difference is pathetic! There are no longer *smooth* changes in volatility.
    Instead, we observe periods of high and low volatility abruptly switching from
    one to another. Now the picture is more adequate to what we observe in the market
    itself:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 差异是微不足道的！波动性不再有**平滑**的变化。相反，我们观察到高波动性和低波动性突然从一个切换到另一个。现在这幅图更符合我们在市场上观察到的实际情况：
- en: Sharp price movements always and immediately cause our volatility indicator
    to jump
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急剧的价格变动总是立即导致我们的波动性指标跳跃
- en: High volatility often means a reversal in price
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高波动性通常意味着价格的反转
- en: Longer-term trends (the right part of the chart) are accompanied by low volatility
    (surprise!)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期趋势（图表的右侧）伴随着低波动性（惊讶！）
- en: The fact that sharp price movements cause volatility to also increase sharply
    is used in *volatility breakout* strategies; the idea is buying or selling the
    asset in the direction of the already started sharp price movement. And the fact
    that the volatility is relatively low during trends is used in various *trend-following*
    or *mean-reversion* strategies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 突然的价格变动会导致波动率急剧增加的事实被用于*波动率突破*策略；其理念是在已经开始的急剧价格变动方向上买入或卖出资产。而波动率在趋势期间相对较低的事实被用于各种*趋势跟踪*或*均值回归*策略。
- en: Our study on volatility would definitely be incomplete without one of the most
    well-known and popular TA indicators, Bollinger bands.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 没有包括最著名且最受欢迎的技术分析指标之一，布林带，我们的波动率研究肯定是不完整的。
- en: Bollinger bands
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布林带
- en: 'This indicator was introduced by John Bollinger in the 1980s. The idea is to
    determine whether the price of an asset lies outside of the *normal* range. In
    this indicator, the *normal* range is defined as the mean value plus or minus
    two standard deviations (or two *sigma*). Therefore, Bollinger bands consist of
    *two* lines, one always going above the price (*B+*) and the other, always below
    (*B-*):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该指标由约翰·布林格在 1980 年代提出。其理念是确定资产价格是否位于*正常*范围之外。在这个指标中，*正常*范围被定义为平均值加减两个标准差（或两个*sigma*）。因此，布林带由*两条*线组成，一条始终位于价格之上（*B+*），另一条始终位于价格之下（*B-*）：
- en: B+ =![](img/Formula_B19145_07_013.png)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: B+ = ![公式 B19145_07_013](img/Formula_B19145_07_013.png)
- en: B- = ![](img/Formula_B19145_07_014.png)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: B- = ![公式 B19145_07_014](img/Formula_B19145_07_014.png)
- en: Why two *stddev*, not one? If you want to learn the correct, formal answer,
    I would recommend that you refer to any book on mathematical statistics or the
    same Wikipedia article as earlier. Without going into details, let us just take
    it for granted that for a stochastic process, 90% of data points fall into the
    mean *± 2* sigma range. So, the idea of Bollinger bands is that drawing lines
    in a *2* sigma distance from the mean could help isolate outliers – that is, the
    prices that lie outside the *±2* stddev range.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是两个*stddev*而不是一个？如果你想了解正确、正式的答案，我建议你参考任何一本关于数学统计学的书籍或之前提到的相同维基百科文章。不深入细节，我们只需假设对于随机过程，90%的数据点都落在平均值*±
    2* sigma范围内。因此，布林带的理念是在距离平均值*2* sigma的位置画线可以帮助隔离异常值——也就是说，那些位于*±2* stddev范围之外的价格。
- en: 'Let’s see what it looks like in reality. *Figure 7**.12* shows a 1-minute chart
    of AUDUSD with 20-period Bollinger bands on it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现实中的样子。*图 7.12* 显示了一个带有 20 期布林带的 AUDUSD 1 分钟图表：
- en: "![Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands\uFEFF](img/B19145_7_12.jpg)"
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 带有布林带的 AUDUSD 1 分钟图表](img/B19145_7_12.jpg)'
- en: Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 带有布林带的 AUDUSD 1 分钟图表
- en: This chart represents the mean or moving average (solid line in the middle)
    and two Bollinger bands (gray lines above and below). Bold black dots mark the
    closing prices that lie above the upper band or below the lower band. Both are
    *outliers*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表表示平均值或移动平均（中间的实线）和两条布林带（上方的灰色线和下方的灰色线）。粗体黑点标记的是位于上轨之上或下轨之下的收盘价。这两者都是*异常值*。
- en: 'Technical traders use Bollinger bands for various purposes as other TA indicators
    as well, though:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 技术交易者像使用其他技术分析指标一样，使用布林带用于各种目的，尽管如此：
- en: Outliers can be interpreted as breakouts – moments when the price starts its
    movement to a certain direction – so can be used in strategies that attempt to
    buy or sell *along with* the movement
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值可以解释为突破——价格开始向某个方向移动的时刻——因此可以用于尝试买入或卖出*伴随*该移动的策略
- en: Outliers can be interpreted as liquidity issues and thus considered as good
    points for mean reversion – so can be used as entry points to buy or sell *against*
    the current price movement
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值可以解释为流动性问题，因此被认为是均值回归的好点——因此可以用作买入或卖出*逆*当前价格变动的入场点
- en: Key takeaways – what TA indicators are all about and how to use them
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键要点 – 技术指标的全部内容及其使用方法
- en: 'The world of technical indicators is really vast. However, most of them are
    just variations of the same old classical indicators of the four main types:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 技术指标的世界确实非常广泛。然而，其中大部分只是四种主要类型经典指标的变化形式：
- en: Momentum, or *market speed*
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动量，或*市场速度*
- en: Digital filters
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字滤波器
- en: Range
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Volatility
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波动率
- en: Don’t forget this when you stumble upon a new *unique* indicator that promises
    *fantastic* results. Give it a thorough examination first and you will see what
    it actually shows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到一个承诺*神奇*结果的*独特*新指标时，别忘了这一点。首先对其进行彻底检查，你就会看到它实际上显示的内容。
- en: Don’t forget that no indicator can build you a robust trading strategy. They
    serve only to quantitatively identify various situations in the market, and it
    is still up to you as the trading strategy developer how you actually exploit
    these situations in the logic of your code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，没有任何指标能为你构建一个稳健的交易策略。它们仅用于定量识别市场中的各种情况，而如何实际利用这些情况在你的代码逻辑中，则取决于你作为交易策略开发者。
- en: Now, it’s time to see how we can implement technical indicators in native Python
    code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看我们如何在原生Python代码中实现技术指标了。
- en: Implementation of TA indicators in Python
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现TA指标
- en: I am sure you remember that any TA indicator uses a certain period as a parameter.
    This period means a number of data points that we take into consideration. To
    calculate an indicator on every bar, we start from the oldest one (the leftmost
    on the chart) and then move one by one, updating our dataset with each new bar.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你记得任何TA指标都使用一个特定时期作为参数。这个时期意味着我们考虑的数据点的数量。为了在每个条形图上计算指标，我们从最老的开始（图表最左边的一个），然后逐个移动，每次添加新的条形图来更新我们的数据集。
- en: Since we are talking about an absolutely essential thing that lies in the foundation
    of all TA, let me be very detailed here – probably too detailed – but I want to
    leave no place for ambiguity or misunderstanding in the following concepts and
    code samples.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论一个所有TA基础都绝对必要的事情，让我在这里非常详细地说明——可能过于详细——但我希望以下概念和代码示例中没有任何歧义或误解。
- en: 'Let’s start with the core concept of time series processing: the sliding window.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从时间序列处理的核心概念开始：滑动窗口。
- en: Sliding windows
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动窗口
- en: 'Let’s go back to the example of a random walk (around bars and movies) that
    we considered in the previous section. The entire dataset, or historical data,
    consists of 10 data points:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一节中考虑的随机游走（围绕酒吧和电影）的例子。整个数据集，或历史数据，由10个数据点组成：
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if we are interested in analyzing the activity only for the last 3 days,
    then we get the following subsets:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想分析最近3天的活动，那么我们会得到以下子集：
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, we apply a TA indicator to each subset, one by one, left to right, older
    to newer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们逐个将TA指标应用于每个子集，从左到右，从旧到新。
- en: This technique is known as the **sliding window**, and is the cornerstone of
    all technical trading, from plotting simple indicators to backtesting and optimization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为**滑动窗口**，是所有技术交易的基础，从绘制简单的指标到回测和优化。
- en: Peeking ahead
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前查看
- en: 'The main problem of working with historical data while using sliding windows
    is the potential ability to *peek ahead*, or look into the future (see [*Chapter
    4*](B19145_04.xhtml#_idTextAnchor073), *Trading Application – What’s Inside?*,
    in the *Trading logic – this is where a small mistake may cost a fortune* section,
    for the discussion on the peeking ahead issue). If we reconstruct your random
    walk movements from the `S1` dataset (see the *Stochastic oscillator* section
    in this chapter), we should take particular care about *not* using data from *tomorrow*
    when we analyze what happened *today*. Let’s add dates to our data samples to
    give them more clarity:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用滑动窗口处理历史数据时，主要问题是潜在的*提前查看*能力，或看到未来（参见[*第4章*](B19145_04.xhtml#_idTextAnchor073)，*交易应用——里面有什么？*，在*交易逻辑——这里的一个小错误可能代价巨大*部分，关于提前查看问题的讨论）。如果我们从`S1`数据集（参见本章的*随机振荡器*部分）重建你的随机游走动作，我们应该特别注意*不要*在分析今天发生的事情时使用*明天的*数据。让我们给我们的数据样本添加日期以使其更清晰：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we reconstruct what happened on or before January 6, 2001, we are allowed
    to take into consideration only data from the prior period. We *cannot, should
    not, and have no right* to use data from January 7 or later. If we do, we face
    this peek-ahead issue.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重建2001年1月6日或之前发生的事情，我们只能考虑前期数据。我们*不能，也不应该，没有权利*使用1月7日或之后的数据。如果我们这样做，我们将面临这种提前查看的问题。
- en: Now, imagine that you’re developing a trading strategy and want to test it using
    past data. The goal of such a test is to reconstruct what *would have happened*
    on that particular day at that particular time *if* your strategy actually worked
    then. If you reconstruct what your strategy would have done on January 6, you
    have no right to peek ahead and use data from January 7, even 1 second past the
    test date, because you have no time machine (or so I assume) and when you run
    your strategy *live*, you will be also unable to retrieve data from the future.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你正在开发一个交易策略，并想使用过去的数据对其进行测试。这种测试的目标是重建在特定时间那天，如果您的策略当时确实有效，会发生什么。如果你重建了你在1月6日会采取的策略，你就没有权利提前查看并使用1月7日的数据，即使是在测试日期后的1秒钟，因为你没有时光机（或者至少我是这样假设的），当你实时运行你的策略时，你也将无法从未来检索数据。
- en: However, peeking ahead is, surprisingly, quite a common mistake, and this is
    why I go into so much detail on this issue here. Remember that *if your strategy
    delivers unrealistically good returns, then most likely, they are indeed not realistic
    and are caused by* *peeking ahead.*
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，意外地，提前查看是一个相当常见的错误，这就是为什么我在这里对此问题进行了如此详细的说明。记住，*如果你的策略产生了不切实际的优秀回报，那么它们很可能确实不是现实的，并且是由*
    *提前查看* *引起的*。
- en: How is it possible to peek ahead non-intentionally, occasionally? Well, it’s
    very easy if you store price time series in a list or any similar iterable structure,
    and retrieve data to do calculations by an index. In the previous example, I can
    get data from January 7 while testing a strategy for January 6 simply by calling
    `S1[4:7]`. Even if you use dictionaries, you can get erroneous data by retrieving
    it with an incorrectly specified datetime index.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何在不经意间偶尔提前查看呢？好吧，如果你将价格时间序列存储在列表或任何类似的可迭代结构中，并通过索引检索数据来进行计算，这非常简单。在先前的例子中，我可以通过调用`S1[4:7]`来获取1月7日的数据，同时测试1月6日的策略。即使你使用字典，你也可以通过使用错误指定的日期时间索引来检索错误的数据。
- en: But having said all that, is there a method to guarantee that your code will
    never try to retrieve data from the future? Let’s find out!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但话虽如此，有没有一种方法可以保证你的代码永远不会尝试从未来检索数据？让我们来看看！
- en: The ultimate solution to the peek-ahead issue
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前查看问题的最终解决方案
- en: To suggest such a solution, we should recall that when we use *live* data, we
    are physically unable to get data from the future because ticks or any other data
    packets arrive at your trading application one by one. So, if we want to fully
    guarantee no peeking ahead during the testing phase of the development, we may
    want to emulate the very incoming data stream and write the rest of the code as
    if we plan to work with live data, not historical data stored on disk.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要提出这样的解决方案，我们应该回想一下，当我们使用*实时*数据时，我们实际上无法从未来获取数据，因为交易应用会逐个接收跳动或任何其他数据包。因此，如果我们想在开发测试阶段完全保证不提前查看数据，我们可能需要模拟实际传入的数据流，并像计划与实时数据而不是存储在磁盘上的历史数据一起工作一样编写其余的代码。
- en: The first step toward this universal architecture was made in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, where we suggested using queues
    and threads to accommodate for receiving large amounts of incoming ticks. Now,
    let’s look at the problem of calculating TA indicators from the same standpoint.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 向这种通用架构迈出的第一步是在[*第五章*](B19145_05.xhtml#_idTextAnchor086)中，*使用Python检索和处理市场数据*，我们建议使用队列和线程来适应接收大量传入的跳动。现在，让我们从相同的角度来看待计算技术指标的问题。
- en: I’m sure you remember that *any* TA indicator analyzes a subset of price time
    series, and the length of this subset is called a **period**. When we looked at
    charts, we always noted that for the reconstruction of the indicator’s values
    on historical price data, we need to move this period from left to right, from
    the oldest to the newest data points. We called this approach a **sliding window**.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你记得，*任何*技术分析指标都是分析价格时间序列的一个子集，而这个子集的长度被称为**周期**。当我们查看图表时，我们总是注意到，为了在历史价格数据上重建指标值，我们需要将这个周期从左到右移动，从最老的数据点到最新的数据点。我们将这种方法称为**滑动窗口**。
- en: But now let’s think about what we should do in case we try to build the indicator’s
    values *on the fly*, live, as market data is coming in. There’s no history, no
    stored values, only live ticks. So how can we create such a sliding window?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们思考一下，如果我们试图在市场数据实时传入时*即时*构建指标值，我们应该怎么做。没有历史，没有存储的值，只有实时跳动。那么我们如何创建这样的滑动窗口呢？
- en: 'The answer is obvious: we do create a *window*, but we don’t create a *sliding*
    window because there’s nothing to slide on.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很明显：我们确实创建了一个*窗口*，但我们没有创建一个*滑动*窗口，因为没有可以滑动的东西。
- en: 'Let’s recall how a queue works (see also [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*). Generally speaking, a queue
    is a list with the following properties:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下队列是如何工作的（也参见[*第5章*](B19145_05.xhtml#_idTextAnchor086)，*使用Python检索和处理市场数据*)。一般来说，队列是一个具有以下属性的列表：
- en: When a new element comes in, it is added to the end of the queue
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新元素到来时，它将被添加到队列的末尾
- en: When we retrieve an element from the queue, it is taken from the beginning and
    removed
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们从队列中检索一个元素时，它将从开始处取出并移除
- en: 'Now, let’s create a special queue where the oldest elements (those at the beginning)
    are not retrieved, but automatically removed as soon as a new element is added.
    Let’s look at the diagram in *Figure 7**.13* to see how it works:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个特殊的队列，其中最旧的元素（那些在开始处的元素）不会被检索，而是在新元素添加时自动移除。让我们看看*图7.13*中的图解，看看它是如何工作的：
- en: '![Figure 7.13 – Queue with a fixed length and automatic removal of the oldest
    element upon arrival of a new element](img/B19145_7_13.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 固定长度队列，新元素到来时自动移除最旧的元素](img/B19145_7_13.jpg)'
- en: Figure 7.13 – Queue with a fixed length and automatic removal of the oldest
    element upon arrival of a new element
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 固定长度队列，新元素到来时自动移除最旧的元素
- en: Now, let’s start filling this queue with price time series, starting from the
    oldest data points. What do we get then?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始用价格时间序列填充这个队列，从最旧的数据点开始。那么我们得到什么呢？
- en: 'Let’s do it with our `S1` sample data from the preceding example. Imagine that
    we created such a queue with a length of three. Then, we start pushing data points
    to this queue, removing the oldest points as new points come in. We will get the
    following subsets:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用前面例子中的`S1`样本数据来做这件事。想象一下，我们创建了一个长度为三的队列。然后，我们开始向这个队列推送数据点，随着新点的到来，移除最旧的点。我们将得到以下子集：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And so on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后依次类推。
- en: What are these subsets now?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子集现在是什么？
- en: Wow, these are exactly what we got using a sliding window!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这正是我们使用滑动窗口得到的结果！
- en: Now, instead of storing data in a database or any other storage and then retrieving
    it for the purpose of building a TA indicator, we do that *on the fly* as new
    data is coming in. In this case, we will never be able to peek ahead because we
    will never be able to receive data from the future. All we need to do is emulate
    the data feed using historical data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再将数据存储在数据库或其他存储中，然后为了构建TA指标的目的检索它，而是在新数据到来时*即时*进行。在这种情况下，我们将永远无法提前查看，因为我们永远无法从未来接收数据。我们唯一需要做的是使用历史数据模拟数据源。
- en: 'This solution has another evident and huge benefit: if we develop our application
    using an emulated data feed, then we can switch to a live data feed *without changing
    a single line of code*. So, this approach not only guarantees that the results
    of our tests are always honest but also that we save a massive amount of time
    by developing a *universal* application from the very beginning.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案还有一个明显的巨大好处：如果我们使用模拟数据源开发我们的应用程序，那么我们可以切换到实时数据源，而无需更改任何一行代码。因此，这种方法不仅保证了我们测试的结果始终是诚实的，而且我们还通过从一开始就开发一个*通用*应用程序来节省了大量时间。
- en: Enough talk, let’s get to coding.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 言语已经足够，让我们开始编码吧。
- en: Sliding window as a queue
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动窗口作为队列
- en: 'Now, we’re ready to implement the sliding window using a Python queue:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用Python队列实现滑动窗口：
- en: 'Let’s create a class for our sliding windows first:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为我们的滑动窗口创建一个类：
- en: '[PRE14]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we create a container for our sliding window and fill it with zeros.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的滑动窗口创建一个容器并将其填充为零。
- en: 'Now, let’s add the only method that appends a new element to this window and
    immediately deletes the oldest one:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个唯一的方法，该方法将新元素追加到这个窗口中，并立即删除最旧的元素：
- en: '[PRE17]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, create an instance of this class with a length of just `5` (for demo purposes):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个长度仅为`5`（用于演示目的）的该类实例：
- en: '[PRE20]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That’s it!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Now, let’s use the code that we created in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*. It already contains the global
    queue (data stream) that can be used to transfer any data from any object or module
    to any other. All we want now is to add two functions: one that reads data from
    a compressed file (bars) and sends it to the global data stream, and the other
    that reads bars from this data stream and pushes them to the sliding window:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们在[*第5章*](B19145_05.xhtml#_idTextAnchor086)中创建的代码，*使用Python检索和处理市场数据*。它已经包含了可以用于将任何数据从任何对象或模块传输到任何其他对象的全球队列（数据流）。我们现在只想添加两个函数：一个用于从压缩文件（条形图）中读取数据并将其发送到全局数据流，另一个用于从该数据流中读取条形图并将其推送到滑动窗口：
- en: '[PRE21]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that we have completely reused the function that we created in [*Chapter
    5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving and Handling Market Data with
    Python*, when we learned how to handle data stored in files. Here, we read a bar
    from a CSV ASCII file, parse it, and convert it into a dictionary.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当我们学习如何处理存储在文件中的数据时，我们完全重新使用了在[*第5章*](B19145_05.xhtml#_idTextAnchor086)中创建的函数，*使用Python检索和处理市场数据*。在这里，我们从CSV
    ASCII文件中读取一个条形图，解析它，并将其转换为字典。
- en: 'Now, let’s send this sample to the global queue:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这个样本发送到全局队列：
- en: '[PRE34]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, this is similar to what we did in the previous chapter, the only difference
    is that we now use a different function that gets data from a file. Anyway, the
    result is the same: we put the new sample into the global data stream.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们在上一章中做的是类似的，唯一的区别是我们现在使用了一个不同的函数来从文件中获取数据。无论如何，结果是相同的：我们将新的样本放入全局数据流。
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget that the delay here is added only for the sake of debugging and
    demonstration to emulate samples arriving at the application one by one.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，这里的延迟只是为了调试和演示的目的，以模拟样本逐个到达应用程序。
- en: 'Now, we have finished the code that emulates the incoming data. Let’s look
    at it: any code written from this point and retrieving data from the global queue
    will be *independent* of any particular data source. If you want to replace the
    source or switch from testing to live trading, then all you need to do is to re-write
    the `emulate_bar_stream()` function. The rest of the code will remain unchanged.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了模拟传入数据的代码。让我们看看它：从这一点开始编写的任何代码，以及从全局队列中检索数据，都将与任何特定的数据源无关。如果您想更换源或从测试切换到实时交易，那么您需要做的就是重新编写`emulate_bar_stream()`函数。其余的代码将保持不变。
- en: Finally, we need a function that reads from the global data queue and does something
    meaningful.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个函数，它从全局数据队列中读取并执行一些有意义的事情。
- en: 'In our present case, we will take only the closing price of the bar, push it
    to the sliding window, and then call any function that calculates a TA indicator:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们当前的情况下，我们将只取条形图的收盘价，将其推送到滑动窗口，然后调用任何计算技术分析（TA）指标的函数：
- en: '[PRE38]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Making output to the console from a function is definitely a bad practice, but
    it’s added here only temporarily, to quickly check the correctness of the code
    during debugging.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数中向控制台输出内容绝对是一种不良做法，但在这里只是临时添加，以便在调试期间快速检查代码的正确性。
- en: 'Now, let’s start two threads: one that reads data from a file (or, in the future,
    from any other source) and the other that processes the received data. Don’t forget
    to import the `threading` module:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们启动两个线程：一个用于从文件（或在未来，从任何其他来源）读取数据，另一个用于处理接收到的数据。别忘了导入`threading`模块：
- en: '[PRE43]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you did everything correctly, you should see something like this in the
    console:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一切操作正确，您应该在控制台看到类似以下内容：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see now how our sliding window is being filled with values from right
    to left, pushing older values out – *exactly* like a bar or tick chart on screen.
    So at any given moment, we have a *ready* sliding window of the specified length
    filled with any data we need to calculate an indicator – or to do any other thing
    we only could imagine.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以看到我们的滑动窗口是如何从右到左填充值的，将旧值推出——*完全*像屏幕上的条形图或tick图。所以，在任何给定时刻，我们都有一个*就绪*的、指定长度的滑动窗口，其中填充了我们需要计算指标或执行任何其他我们只能想象的事情所需的数据。
- en: Let’s now see how easily we can build indicators using this approach.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何轻松地使用这种方法构建指标。
- en: Moving average – implementation
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平均 – 实现
- en: 'To calculate an MA with our setup, we only need to calculate an average of
    all values in the window:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的设置计算移动平均（MA），我们只需要计算窗口内所有值的平均值：
- en: '[PRE49]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is indeed that simple! We don’t have to worry about any parameters because
    we already specified the length of the sliding window when we instantiated from
    the `sliding_window` class and specified the type of data (in our example, closing
    prices) when we fill the window with data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很简单！我们不必担心任何参数，因为我们从`sliding_window`类实例化时已经指定了滑动窗口的长度，当我们用数据填充窗口时，也指定了数据类型（在我们的例子中，是收盘价）。
- en: 'If we run our program now, we will get something like the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的程序，我们会得到以下类似的结果：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This explains why we always disregard the first *N-1* values from a sliding
    window with a length of *N*; until *all* elements of the window are filled with
    meaningful data, the indicator’s value is meaningless and should be ignored. So,
    since in our example *N == 5*, we disregard the first 4 values.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么我们总是忽略长度为*N*的滑动窗口中的前*N-1*个值；直到窗口中的所有元素都填充了有意义的数值，指标值才具有意义，否则应该被忽略。因此，在我们的例子中*N
    == 5*，我们忽略前4个值。
- en: Stochastic oscillator – implementation
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机振荡器——实现
- en: 'Let’s now see how we calculate a range indicator like a stochastic oscillator.
    Since this indicator requires three values per bar (`high`, `low`, and `close`),
    we may want to modify our code slightly:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何计算像随机振荡器这样的范围指标。由于这个指标需要每个柱状图三个值（`high`、`low`和`close`），我们可能需要稍微修改一下我们的代码：
- en: 'First, let’s replace the generic name of our sliding window from `sw` to `close`
    and add two more sliding windows for highs and lows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将我们的滑动窗口的通用名称从`sw`改为`close`，并添加两个用于高点和低点的滑动窗口：
- en: '[PRE51]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s write the function that calculates the stochastic indicator:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写计算随机指标值的函数：
- en: '[PRE54]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, `close[-1]` stands for the last available closing price (the one we will
    just receive if we run the code in real time).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`close[-1]`代表最后一个可用的收盘价（如果我们实时运行代码，我们将接收到的那个）。
- en: 'And finally, let’s slightly modify the `retrieve_bars()` function so it adds
    data points to all three sliding windows (`high`, `low`, and `close`) and calculates
    the values of the stochastic indicator:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们稍微修改一下`retrieve_bars()`函数，使其向所有三个滑动窗口（`high`、`low`和`close`）添加数据点，并计算随机指标值：
- en: '[PRE58]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we run our code now, we will get something similar to the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的代码，我们会得到以下类似的结果：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Again, as always, we should disregard the first *N-1* values, so reasonable
    readings start from *line 5*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一如既往，我们应该忽略前*N-1*个值，所以合理的读数从*第5行*开始。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Well, it’s been a long and – I hope – interesting trip, so it’s time now to
    summarize what we learned.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这已经是一次漫长且——我希望——有趣的旅程了，现在是时候总结一下我们学到了什么。
- en: Technical analysis assumes that price includes everything in itself and attempts
    to find repeating patterns of behavior, suggesting that the price action following
    a similar pattern will also be similar to what already happened in the past.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 技术分析假设价格包含了自身的一切，并试图找到重复的行为模式，这表明在类似模式之后的交易价格行动也将与过去已经发生的情况相似。
- en: 'There are just four major classes of technical studies, despite their visual
    diversity at first glance: market speed or momentum, digital filters, range, and
    volatility. Each type of study can be used to detect a certain situation in the
    market, but none of them can produce a ready profitable trading strategy on its
    own.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管乍一看它们的视觉多样性很大，但技术分析只有四大主要类别：市场速度或动量、数字滤波器、范围和波动性。每种类型的研究都可以用来检测市场中的某种情况，但没有任何一种研究可以单独产生一个现成的盈利交易策略。
- en: The cornerstone of all technical studies is the sliding window, and the bane
    of technical trading is peeking ahead during development and testing. Using queues
    to emulate incoming data streams and to organize sliding windows solves the problem
    of peeking ahead once and for all.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有技术分析的基础是滑动窗口，而技术交易的大敌是在开发和测试过程中提前查看。使用队列来模拟传入的数据流和组织滑动窗口可以一劳永逸地解决提前查看的问题。
- en: Besides that, this approach makes your application scalable, flexible, and modular
    with the ability to connect to a live data source after testing without rewriting
    your trading code.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法使你的应用程序可扩展、灵活且模块化，在测试后能够连接到实时数据源而无需重写交易代码。
- en: Now that we have plenty of data points, we definitely want to visualize all
    of them to be able to quickly check the results or even trade live. So, let’s
    move on to the next chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的数据点，我们肯定想可视化所有这些数据，以便能够快速检查结果，甚至进行实时交易。所以，让我们进入下一章。
