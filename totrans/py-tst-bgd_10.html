<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Other Testing Tools and Techniques</h1></div></div></div><p>
<em>We've covered the core elements of testing in Python, but there are a number of peripheral methods and tools that will make your life easier. In this chapter, we'll go over several of them in brief.</em>
</p><p>In this chapter, we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discuss code coverage, and learn about <code class="literal">coverage.py</code></li><li class="listitem" style="list-style-type: disc">Discuss continuous integration, and learn about buildbot</li><li class="listitem" style="list-style-type: disc">Learn how to integrate automated testing into popular version control systems</li></ul></div><p>So let's get on with it!</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Code coverage</h1></div></div></div><a class="indexterm" id="id593"/><p>Tests tell you when the code you're testing doesn't work the way you thought it would, but they don't tell you a thing about the code that you're not testing. They don't even tell you that the code you're not testing isn't being tested.</p><p>Code coverage is a technique, which can be used to address that shortcoming. A code coverage tool watches while your tests are running, and keeps track of which lines of code are (and aren't) executed. After the tests have run, the tool will give you a report describing how well your tests cover the whole body of code.</p><p>It's desirable to have the coverage approach 100%, as you probably figured out already. Be careful not to focus on the coverage number too intensely though, it can be a bit misleading. Even if your tests execute every line of code in the program, they can easily not test everything that needs to be tested. That means you can't take 100% coverage as certain proof that your tests are complete. On the other hand, there are times when some code really, truly doesn't need to be covered by the tests—some debugging support code, for example—and so less than 100% coverage can be completely acceptable.</p><p>Code coverage is a tool to give you insight into what your tests are doing, and what they may be overlooking. It's not the definition of a good test suite.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>coverage.py</h2></div></div></div><a class="indexterm" id="id594"/><a class="indexterm" id="id595"/><p>We're going to be working with a module called <code class="literal">coverage.py</code>, which is—unsurprisingly—a code coverage tool for Python.</p><p>Since <code class="literal">coverage.py</code> isn't built in to Python, we'll need to download and install it. You can download the latest version from the Python Package Index at <a class="ulink" href="http://pypi.python.org/pypi/coverage">http://pypi.python.org/pypi/coverage</a>. As before, users of Python 2.6 or later can install the package by unpacking the archive, changing to the directory, and typing:</p><div><pre class="programlisting">
<strong>$ python setup.py install --user </strong>
</pre></div><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Users of older versions of Python need write permission to the system-wide <code class="literal">site-packages</code> directory, which is part of the Python installation. Anybody who has such permission can install coverage by typing:</p><p>
<code class="literal">$ python setup.py install</code>
</p><p>At the time of this writing, Windows users also had the option of downloading a Windows installer file from the Python Package Index and running it to install <code class="literal">coverage.py</code>.</p></div></div><p>We'll walk through the steps of using <code class="literal">coverage.py</code> here, but if you want more information you can find it on the <code class="literal">coverage.py</code> home page at <a class="ulink" href="http://nedbatchelder.com/code/coverage/">http://nedbatchelder.com/code/coverage/</a>.<a class="indexterm" id="id596"/>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Time for action – using coverage.py</h1></div></div></div><a class="indexterm" id="id597"/><p>We'll create a little <code class="literal">toy</code> code module with tests, and then apply <code class="literal">coverage.py</code> to find out how much of the code the tests actually use.</p><div><ol class="orderedlist arabic"><li class="listitem">Place the following test code into <code class="literal">test_toy.py</code>. There are several problems with these tests, which we'll discuss later, but they ought to run.<div><pre class="programlisting">from unittest import TestCase
import toy

class test_global_function(TestCase):
    def test_positive(self):
        self.assertEqual(toy.global_function(3), 4)

    def test_negative(self):
        self.assertEqual(toy.global_function(-3), -2)

    def test_large(self):
        self.assertEqual(toy.global_function(2**13), 2**13 + 1)

class test_example_class(TestCase):
    def test_timestwo(self):
        example = toy.example_class(5)
        self.assertEqual(example.timestwo(), 10)

    def test_repr(self):
        example = toy.example_class(7)
        self.assertEqual(repr(example), '&lt;example param="7"&gt;')</pre></div></li><li class="listitem">Put the following code into <code class="literal">toy.py</code>. Notice the <code class="literal">if __name__ == '__main__'</code> clause at the bottom. We haven't dealt with one of those in a while, so I'll remind you that the code inside that block runs doctest if we were to run the module with <code class="literal">python toy.py</code>.<div><pre class="programlisting">def global_function(x):
    r"""<a class="indexterm" id="id598"/>
    &gt;&gt;&gt; global_function(5)
    6
    """
    return x + 1

class example_class:
    def __init__(self, param):
        self.param = param

    def timestwo(self):
        return self.param * 2

    def __repr__(self):
        return '&lt;example param="%s"&gt;' % self.param
if __name__ == '__main__':
    import doctest
    doctest.testmod()</pre></div></li><li class="listitem">Go ahead and run Nose. It should find them, run them, and report that all is well. The problem is, some of the code isn't ever tested.</li><li class="listitem">Let's run it again, only this time we'll tell Nose to use <code class="literal">coverage.py</code> to measure coverage while it's running the tests.<div><pre class="programlisting">
<strong>$ nosetests --with-coverage --cover-erase </strong>
</pre></div><div><img alt="Time for action – using coverage.py" src="img/8846_10_01.jpg"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>
<em>What just happened?</em>
</h2></div></div></div><p>In step 1, we have a couple of <code class="literal">TestCase</code> classes with some very basic tests in them. T<a class="indexterm" id="id599"/>hese tests wouldn't be much use in a real world situation, but all we need them for is to illustrate how the code coverage tool works.</p><p>In step 2, we have the code that satisfies the tests from step 1. Like the tests themselves, this code wouldn't be much use, but it serves as an illustration.</p><p>In step 4, we passed <code class="literal">--with-coverage</code> and <code class="literal">--cover-erase</code> as command line parameters when we ran Nose. What did they do? Well, <code class="literal">--with-coverage</code> is pretty straightforward: it told Nose to look for <code class="literal">coverage.py</code> and to use it while the tests execute. That's just what we wanted. The second parameter, <code class="literal">--cover-erase</code>, tells Nose to forget about any coverage information that was acquired during previous runs. By default, coverage information is aggregated across all of the uses of <code class="literal">coverage.py</code>. This allows you to run a set of tests using different testing frameworks or mechanisms, and then check the cumulative coverage. You still want to erase the data from previous test runs at the beginning of that process, though, and the <code class="literal">--cover-erase</code> command line is how you tell Nose to tell <code class="literal">coverage.py</code> that you're starting anew.</p><p>What the coverage report tells us is that 9/12 (in other words, 75%) of the executable statements in the toy module were executed during our tests, and that the missing lines were line 16 and a lines 19 through 20. Looking back at our code, we see that line 16 is the <code class="literal">__repr__</code> method. We really should have tested that, so the coverage check has revealed a hole in our tests that we should fix. Lines 19 and 20 are just code to run doctest, though. They're not something that we ought to be using under normal circumstances, so we can just ignore that coverage hole.</p><p>Code coverage can't detect problems with the tests themselves, in most cases. In the above test code, the test for the <code class="literal">timestwo</code> method violates the isolation of units and invokes two different methods of <code class="literal">example_class</code>. Since one of the methods is the constructor, this may be acceptable, but the coverage checker isn't in a position to even see that there might be a problem. All it saw was more lines of code being covered. That's not a problem— it's how a coverage checker ought to work— but it's something to keep in mind. Coverage is useful, but high coverage doesn't equal good tests.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Pop quiz – code coverage</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">What does a high coverage percentage mean?</li><li class="listitem">If your boss asks you for a quantifiable measure of test quality, will you use the coverage percentage?</li><li class="listitem">What is the most useful information on the coverage report?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Have a go hero – checking coverage in earlier chapters</h2></div></div></div><p>Go back through the code from earlier chapters and use code coverage to check for things that should have been tested, but weren't. Try it on some of your own tested code too.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Version control hooks</h1></div></div></div><p>M<a class="indexterm" id="id600"/>ost version control systems have the ability to run a program that you've written in response to various events, as a way of customizing the version control system's behavior. These programs are commonly called hooks.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>Version control systems are programs for keeping track of changes to a source code tree, even when those changes are made by different people. In a sense, they provide an universal undo history and change log for the whole project, going all the way back to the moment you started using the version control system. They also make it much easier to combine work done by different people into a single, unified entity, and to keep track of different editions of the same project.</p></div></div><p>You can do all kinds of things by installing the right hook programs, but we'll only focus on one use. We can make the version control program automatically run our tests, when we commit a new version of the code to the version control repository.</p><p>This is a fairly nifty trick, because it makes it difficult for test-breaking bugs to get into the repository unnoticed. Somewhat like code coverage, though there's potential for trouble if it becomes a matter of policy rather than simply being a tool to make your life easier.</p><p>In most systems, you can write the hooks such that it's impossible to commit code that breaks tests. That may sound like a good idea at first, but it's really not. One reason for this is that one of the major purposes of a version control system is communication between developers, and interfering with that tends to be unproductive in the long run. Another reason is that it prevents anybody from committing partial solutions to problems, which means that things tend to get dumped into the repository in big chunks. Big commits are a problem because they make it hard to keep track of what changed, which adds to the confusion. There are better ways to make sure you always have a working codebase socked away somewhere, such as version control branches.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>Bazaar</h2></div></div></div><p>B<a class="indexterm" id="id601"/>
<a class="indexterm" id="id602"/>azaar is a distributed version control system, which means that it is capable of operating without a central server or master copy of the source code. One consequence of the distributed nature of Bazaar is that each user has their own set of hooks, which can be added, modified, or removed without involving anyone else. Bazaar is available on the Internet at <a class="ulink" href="http://bazaar-vcs.org/">http://bazaar-vcs.org/</a>.</p><p>If you don't have Bazaar already installed, and don't plan on using it, you can skip this section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Time for action – installing Nose as a Bazaar post-commit hook</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">B<a class="indexterm" id="id603"/>azaar hooks go in your <code class="literal">plugins</code> directory. On Unix-like systems, that's <code class="literal">~/.bazaar/plugins/</code>, while on Windows it's <code class="literal">C:\Documents and Settings\&lt;username&gt;\Application Data\Bazaar\&lt;version&gt;\plugins\</code>. In either case, you may have to create the <code class="literal">plugins</code> subdirectory, if it doesn't already exist.</li><li class="listitem">Place the following code into a file called <code class="literal">run_nose.py</code> in the <code class="literal">plugins</code> directory. Bazaar hooks are written in Python:<div><pre class="programlisting">from bzrlib import branch
from os.path import join, sep
from os import chdir
from subprocess import call

def run_nose(local, master, old_num, old_id, new_num, new_id):
    try:
        base = local.base
    except AttributeError:
        base = master.base

    if not base.startswith('file://'):
        return
    try:
        chdir(join(sep, *base[7:].split('/')))
    except OSError:
        return

    call(['nosetests'])

branch.Branch.hooks.install_named_hook('post_commit',
                                       run_nose,
                                       'Runs Nose after eachcommit')</pre></div></li><li class="listitem">Make a new directory in your working files, and put the following code into it in a file called <code class="literal">test_simple.py</code>. These simple (and silly) tests are just to give Nose something to do, so that we can see that the hook is working.<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same")</pre></div></li><li class="listitem">S<a class="indexterm" id="id604"/>till in the same directory as <code class="literal">test_simple.py</code>, run the following commands to create a new repository and commit the tests to it. The output you see might differ in details, but it should be quite similar overall.<div><pre class="programlisting">
<strong>$ bzr init</strong>
<strong>$ bzr add</strong>
<strong>$ bzr commit</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Bazaar post-commit hook" src="img/8846_10_02.jpg"/></div></li><li class="listitem">Notice that there's a Nose test report after the commit notification. From now on, any time you commit to a Bazaar repository, Nose will search for and run whatever tests it can find within that repository.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec108"/>
<em>W<a class="indexterm" id="id605"/>hat just happened?
</em>
</h2></div></div></div><p>Bazaar hooks are written in Python, so we've written our hook as a function called <code class="literal">run_nose</code>. Our <code class="literal">run_nose</code> function checks to make sure that the repository which we're working on is local, and then it changes directories into the repository and runs nose. We registered <code class="literal">run_nose</code> as a hook by calling <code class="literal">branch.Branch.hooks.install_named_hook</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Mercurial</h2></div></div></div><p><a class="indexterm" id="id606"/>
<a class="indexterm" id="id607"/>Like Bazaar, Mercurial is a distributed version control system, with hooks that are managed by each user individually. Mercurial's hooks themselves, though, take a rather different form. You can find Mercurial on the web at <a class="ulink" href="http://www.selenic.com/mercurial/">http://www.selenic.com/mercurial/</a>.</p><p>If you don't have Mercurial installed and don't plan to use it, you can skip this section.</p><p>Mercurial hooks can go in several different places. The two most useful are in your personal configuration file and in your repository configuration file.</p><p>Your personal configuration file is <code class="literal">~/.hgrc</code> on Unix-like systems, and <code class="literal">%USERPROFILE%\Mercurial.ini</code> (which usually means <code class="literal">c:\Documents and Settings\&lt;username&gt;\Mercurial.ini</code>) on Windows-based systems. </p><p>Your repository configuration file is stored in a subdirectory of the repository, specifically <code class="literal">.hg/hgrc</code>, on all systems.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Time for action – installing Nose as a Mercurial post-commit hook</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id608"/>We'll use the repository configuration file to store the hook, which means that the first thing we have to do is have a repository to work with. Make a new directory at a convenient place and execute the following command in it:<div><pre class="programlisting">
<strong>$ hg init</strong>
</pre></div></li><li class="listitem">One side-effect of that command is that a <code class="literal">.hg</code> subdirectory got created. Change to that directory, and then create a text file called <code class="literal">hgrc</code> containing the following text:<div><pre class="programlisting">[hooks]
commit = nosetests</pre></div></li><li class="listitem">Back in the repository directory (i.e. the parent of the <code class="literal">.hg</code> directory), we need some tests for Nose to run. Create a file called <code class="literal">test_simple.py</code> containing the following (admittedly silly) tests:<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same")</pre></div></li><li class="listitem">Run the following commands to add the test file and commit it to the repository:<div><pre class="programlisting">
<a class="indexterm" id="id609"/>
<strong>$ hg add</strong>
<strong>$ hg commit</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Mercurial post-commit hook" src="img/8846_10_03.jpg"/></div></li><li class="listitem">Notice that the commit triggered a run-through of the tests. Since we put the hook in the repository configuration file, it will only take effect on commits to this repository. If we'd instead put it into your personal configuration file, it would be called when you committed to <em>any</em> repository.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec110"/>
<em>What just happened?</em>
</h2></div></div></div><p>Mercurial's hooks are commands, just like you would enter into your operating systems command shell (also known as a DOS prompt on Windows). We just had to edit Mercurial's configuration file and tell it which command to run. Since we wanted it to run our Nose test suite when we commit, we set the commit hook to <code class="literal">nosetests</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec111"/>Git</h2></div></div></div><p>Git<a class="indexterm" id="id610"/>
<a class="indexterm" id="id611"/> is a distributed version control system. Similar to Bazaar and Mercurial, it allows every user to control their own hooks, without involving other developers or server administrators.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>Git hooks are stored in the <code class="literal">.git/hooks/</code> subdirectory of the repository, each in its own file.</p></div></div><p>If you don't have Git installed, and don't plan to use it, you can skip this section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Time for action – installing Nose as a Git post-commit hook</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The<a class="indexterm" id="id612"/> hooks are stored in a subdirectory of a Git repository, so the first thing that we need to do is initialize a repository. Make a new directory for the Git repository and execute the following command inside of it:<div><pre class="programlisting">
<strong>$ git init</strong>
</pre></div></li><li class="listitem">Git hooks are executable programs, so they can be written in any language. To run Nose, it makes sense to use a shell script (on Unix-like systems) or batch file (on Windows) for the hook. If you're using a Unix-like system, place the following two lines into a file called post-commit in the <code class="literal">.git/hooks/</code> subdirectory, and then use the <code class="literal">chmod +x post-commit</code> command to make it executable.<div><pre class="programlisting">#!/bin/sh
nosetests</pre></div><p>If you're using a Windows system, place the following lines inside a file called <code class="literal">post-commit.bat</code> in the <code class="literal">.git\hooks\</code> subdirectory.</p><div><pre class="programlisting">@echo off
nosetests</pre></div></li><li class="listitem">We need to put some test code in the repository directory (that is, the parent of the <code class="literal">.git</code> directory), so that Nose has something to do. Place the following (useless) code into a file called <code class="literal">test_simple.py</code>:<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same")</pre></div></li><li class="listitem">Run the following commands to add the test file and commit it to the repository:<div><pre class="programlisting">
<strong>$ git add test_simple.py</strong>
<strong>$ git commit -a</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Git post-commit hook" src="img/8846_10_04.jpg"/></div></li><li class="listitem"><a class="indexterm" id="id613"/>Notice that the commit triggered an execution of Nose and printed out the test results.<p>Because each repository has its own hooks, only the repositories that were specifically configured to run Nose will do so.</p></li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec112"/>
<em>What just happened?</em>
</h2></div></div></div><p>Git finds its hooks by looking for programs with specific names, so we could have used any programming language to write our hook, as long as we could give the program the right name. However, all that we want is to run the <code class="literal">nosetests</code> command, so that we can use a simple shell script or batch file. All this simple program does is invoke the <code class="literal">nosetests</code> program, and then terminate.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Darcs</h2></div></div></div><p><a class="indexterm" id="id614"/>
<a class="indexterm" id="id615"/>Darcs is a distributed version control system. Each user has control over their own set of hooks.</p><p>If you don't have Darcs installed, and you don't plan to use it, you can skip this section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Time for action – installing Nose as a Darcs post-record hook</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Each<a class="indexterm" id="id616"/> local repository has its own set of hooks, so the first thing we need to do is create a repository. Make a directory to work in, and execute the following command in it:<div><pre class="programlisting">
<strong>$ darcs initialize</strong>
</pre></div></li><li class="listitem">We need to put some test code in the repository directory so that Nose has something to do. Place the following (useless) code into a file called <code class="literal">test_simple.py</code>.<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same")</pre></div></li><li class="listitem">Run the following command to add the test file to the repository:<div><pre class="programlisting">
<strong>$ darcs add test_simple.py</strong>
</pre></div></li><li class="listitem">Darcs hooks are identified using command line options. In this case, we want to run <code class="literal">nosetests</code> after we tell Darcs to record changes, so we use the following command:<div><pre class="programlisting">
<a class="indexterm" id="id617"/>
<strong>$ darcs record --posthook=nosetests</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Darcs post-record hook" src="img/8846_10_05.jpg"/></div></li><li class="listitem">Notice that Darcs ran our test suite once it was done recording the changes, and reported the results to us.</li><li class="listitem">That's well and good, but Darcs doesn't remember that we want <code class="literal">nosetests</code> to be a post-record hook. As far as it's concerned, that was a one-time deal. Fortunately, we can tell it otherwise. Create a file called <code class="literal">defaults</code> in the <code class="literal">_darcs/prefs/ </code>subdirectory, and place the following text into it:<div><pre class="programlisting">record posthook nosetests</pre></div></li><li class="listitem">Now if we change the code and record again, <code class="literal">nosetests</code> should run without us specifically asking for it. Make the following change to <code class="literal">test_simple.py</code>:<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same!")</pre></div></li><li class="listitem"><a class="indexterm" id="id618"/>Run the following command to record the change and run the tests:<div><pre class="programlisting">
<strong>darcs record</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Darcs post-record hook" src="img/8846_10_06.jpg"/></div></li><li class="listitem">If you want to skip the tests for a commit, you can pass the <code class="literal">--no-posthook</code> command line option when you record your changes.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec114"/>
<em>What just happened?</em>
</h2></div></div></div><p>Darcs hooks are specified as command line options, so when we issue the <code class="literal">record</code> command we need to specify a program to run as a hook. Since we don't want to do that manually every time we record changes, we make use of Darcs' ability to accept additional command line options in its configuration file. This allows us to make running <code class="literal">nosetests</code> as a hook into the default behavior.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Subversion</h2></div></div></div><p>U<a class="indexterm" id="id619"/>nlike the other version control systems that we've discussed, Subversion is a centralized one. There is a single server tasked with keeping track of everybody's changes, which also handles running hooks. This means that there is a single set of hooks that applies to everybody, probably under control of a system administrator.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Subversion hooks are stored in files in the <code class="literal">hooks/</code> subdirectory of the server's repository.</p></div></div><p>I<a class="indexterm" id="id620"/>f you don't have Subversion and don't plan on using it, you can skip this section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Time for action – installing Nose as a Subversion post-commit hook</h1></div></div></div><p>B<a class="indexterm" id="id621"/>ecause Subversion operates on an centralized, client-server architecture, we'll need both the client and server set up for this example. They can both be on the same computer, but they'll need to be in different directories.</p><div><ol class="orderedlist arabic"><li class="listitem">First we need a server. You can create one by making a new directory called <code class="literal">svnrepo</code> and executing the following command:<div><pre class="programlisting">
<strong>$ svnadmin create svnrepo/</strong>
</pre></div></li><li class="listitem">Now we need to configure the server to accept commits from us. To do this, we open up the file called <code class="literal">conf/passwd</code> and add the following line at the bottom:<div><pre class="programlisting">testuser = testpass</pre></div></li><li class="listitem">Then we need to edit <code class="literal">conf/svnserve.conf</code>, and change the line reading <code class="literal"># password-db = passwd</code> to <code class="literal">password-db = passwd</code>.</li><li class="listitem">The Subversion server needs to be running, before we can interact with it. This is done by making sure that we're in the <code class="literal">svnrepo</code> directory and then running the following command:<div><pre class="programlisting">
<strong>svnserve -d -r ..</strong>
</pre></div></li><li class="listitem">Next we need to import some test code into the Subversion repository. Make a directory and place the following (simple and silly) code into it in a file called <code class="literal">test_simple.py</code>:<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same")</pre></div><p>You can perform the import by executing:</p><div><pre class="programlisting">
<strong>$ svn import --username=testuser --password=testpass svn://localhost/svnrepo/</strong>
</pre></div><p>T<a class="indexterm" id="id622"/>hat command is likely to print out a gigantic, scary message about remembering passwords. In spite of the warnings, just say <code class="literal">yes</code>.</p></li><li class="listitem">Now that we've got the code imported, we need to check out a copy of it to work on. We can do this with the following command:<div><pre class="programlisting">
<strong>$ svn checkout --username=testuser --password=testpass svn://localhost/svnrepo/ svn</strong>
</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>From here on in this example, we'll assume that the Subversion server is running in a Unix-like environment (the clients might be running on Windows, we don't care). The reason for this, is that the details of the post-commit hook are significantly different on systems that don't have a Unix style shell scripting language, although the concepts remain the same.</p></div></div></li><li class="listitem">The following code goes into a file called <code class="literal">hooks/post-commit</code> inside the subversion server's repository. (The <code class="literal">svn update</code> and <code class="literal">svn checkout</code> lines have been wrapped around to fit on the page. In actual use, this wrapping should not be present.)<div><pre class="programlisting">#!/bin/sh
REPO="$1"

if /usr/bin/test -e "$REPO/working"; then
    /usr/bin/svn update --username=testuser --password=testpass "$REPO/working/";
else
    /usr/bin/svn checkout --username=testuser --password=testpass svn://localhost/svnrepo/ "$REPO/working/";
fi

cd "$REPO/working/"

exec /usr/bin/nosetests</pre></div></li><li class="listitem">Use the <code class="literal">chmod +x post-commit</code> command to make the hook executable.</li><li class="listitem">Change to the <code class="literal">svn</code> directory created by the checkout in step 5, and edit <code class="literal">test_simple.py</code> to make one of the tests fail. We do this because if the tests all pass, Subversion won't show us anything to indicate that they were run at all. We only get feedback if they fail.<div><pre class="programlisting">from unittest import TestCase

class test_simple(TestCase):
    def test_one(self):
        self.assertNotEqual("Testing", "Hooks")

    def test_two(self):
        self.assertEqual("Same", "Same!")</pre></div></li><li class="listitem">N<a class="indexterm" id="id623"/>ow commit the changes using the following command:<div><pre class="programlisting">
<strong>$ svn commit --username=testuser --password=testpass</strong>
</pre></div><div><img alt="Time for action – installing Nose as a Subversion post-commit hook" src="img/8846_10_07.jpg"/></div></li><li class="listitem">Notice that the commit triggered the execution of Nose, and that if any of the tests fail, Subversion shows us the errors.</li></ol></div><p>Because Subversion has one central set of hooks, they apply automatically to anybody who uses the repository.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec116"/>
<em>W<a class="indexterm" id="id624"/>hat just happened?
</em>
</h2></div></div></div><p>Subversion hooks are run on the server. Subversion locates its hooks by looking for programs with specific names, so we needed to create a program called <code class="literal">post-commit</code> to be the post-commit hook. We could have used any programming language to write the hook, as long as the program had the right name, but we chose to use shell scripting language, for simplicity's sake.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec117"/>Pop quiz – version control hooks</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">In what ways can hooking your automated tests into your version control system help you?</li><li class="listitem">What are a couple of the things you could do with version control hooks, but shouldn't?</li><li class="listitem">What is the biggest difference between hooks in distributed version control systems, and hooks in centralized version control systems?</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Automated continuous integration</h1></div></div></div><p><a class="indexterm" id="id625"/>Automated continuous integration tools are a step beyond using a version control hook to run your tests when you commit code to the repository. Instead of running your test suite once, an automated continuous integration system compiles your code (if need be) and runs your tests many times, in many different environments.</p><p>An automated continuous integration system might, for example,  run your tests under Python versions 2.4, 2.5, and 2.6 on each of Windows, Linux, and Mac OS X. This not only lets you know about errors in your code, but also about unexpected problems caused by the external environment. It's nice to know when that last patch broke the program on Windows, even though it worked like a charm on your Linux box.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Buildbot</h2></div></div></div><p><a class="indexterm" id="id626"/>
<a class="indexterm" id="id627"/>Buildbot is a popular automated continuous integration tool. Using Buildbot, you can create a network of 'build slaves' that will check your code each time you commit to you commit it to your repository. This network can be quite large, and it can be distributed around the Internet, so Buildbot works even for projects with lots of developers spread around the world.</p><p>Buildbot's home page is at <a class="ulink" href="http://buildbot.net/">http://buildbot.net/</a>. Following links from that site, you can find the manual and download the latest version of the tool. Glossing over details that we've discussed several times before, installation requires you to unpack the archive, and then run the commands <code class="literal">python setup.py build</code>, and <code class="literal">python setup.py install --user</code>.</p><p><a class="indexterm" id="id628"/>Buildbot operates in one of two modes, termed <code class="literal">buildmaster</code> and <code class="literal">buildslave</code>. <a class="indexterm" id="id629"/>A buildmaster manages a network of buildslaves, while the buildslaves run the tests in their assorted environments.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Time for action – using Buildbot with Bazaar</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To<a class="indexterm" id="id630"/> set up a buildmaster, create a directory for it to operate in and then run the command:<div><pre class="programlisting">
<strong>$ buildbot create-master &lt;directory&gt;</strong>
</pre></div><p>where <code class="literal">&lt;directory&gt;</code> is the directory you just created for buildbot to work in.</p></li><li class="listitem">Similarly, to set up a buildslave, create a directory for it to operate in and then run the command:<div><pre class="programlisting">
<strong>$ buildbot create-slave &lt;directory&gt; &lt;host:port&gt; &lt;name&gt; &lt;password&gt;</strong>
</pre></div><p>where <code class="literal">&lt;directory&gt;</code> is the directory you just created for the buildbot to work in, <code class="literal">&lt;host:port&gt;</code> are the internet host and port where the buildmaster can be found, and <code class="literal">&lt;name&gt;</code> and <code class="literal">&lt;password&gt;</code> are the login information that identifies this buildslave to the buildmaster. All of this information (except the directory) is determined by the operator of the buildmaster.</p></li><li class="listitem">You should edit <code class="literal">&lt;directory&gt;/info/admin</code> and <code class="literal">&lt;directory&gt;/info/host</code> to contain the email address you want associated with this buildslave and a description of the buildslave's operating environment, respectively.</li><li class="listitem">On both the buildmaster and the buildslave, you'll need to start up the buildbot background process. To do this, use the command:<div><pre class="programlisting">
<strong>$ buildbot start &lt;directory&gt;</strong>
</pre></div></li><li class="listitem">Configuring a buildmaster is a significant topic in itself (and one that we' won't be addressing in detail). It's fully described in Buildbot's own documentation. We will provide a simple configuration file, though, for reference and quick setup. This particular configuration file assumes that you're using Bazaar, but it is not significantly different for other version control systems. The following goes in the master <code class="literal">&lt;directory&gt;/master.cfg</code> file:<div><pre class="programlisting"># -*- python -*-
# ex: set syntax=python:

c = BuildmasterConfig = {}

c['projectName'] = "&lt;replace with project name&gt;"
c['projectURL'] = "&lt;replace with project url&gt;"
c['buildbotURL'] = "http://&lt;replace with master url&gt;:8010/"

c['status'] = []
from buildbot.status import html
c['status'].append(html.WebStatus(http_port=8010,
                                  allowForce=True))

c<a class="indexterm" id="id631"/>['slavePortnum'] = 9989

from buildbot.buildslave import BuildSlave
c['slaves'] = [
    BuildSlave("bot1name", "bot1passwd"),
    ]

from buildbot.changes.pb import PBChangeSource
c['change_source'] = PBChangeSource()

from buildbot.scheduler import Scheduler
c['schedulers'] = []
c['schedulers'].append(Scheduler(name="all", branch=None,
                                 treeStableTimer=2 * 60,
                                 builderNames=["buildbot-full"]))

from buildbot.process import factory
from buildbot.steps.source import Bzr
from buildbot.steps.shell import Test
f1 = factory.BuildFactory()
f1.addStep(Bzr(repourl="&lt;replace with repository url&gt;"))
f1.addStep(Test(command = 'nosetests'))

b1 = {'name': "buildbot-full",
      'slavename': "bot1name",
      'builddir': "full",
      'factory': f1,
      }
c['builders'] = [b1]</pre></div></li><li class="listitem">To make effective use of that Buildbot config, you also need to install a version control hook that notifies Buildbot of changes. Generically, this can be done by calling the <code class="literal">buildbot sendchange</code> command from the hook, but there's a nicer way to tie in with Bazaar: copy the <code class="literal">contrib/bzr_buildbot.py</code> file from the buildbot distribution archive into your Bazaar plugins directory, and then edit the <code class="literal">locations.conf</code> file, which you should find right next to the <code class="literal">plugins</code> directory. Add the following entry to <code class="literal">locations.conf</code>:<div><pre class="programlisting">[&lt;your repository path&gt;]
buildbot_on = change
buildbot_server = &lt;internet address of your buildmaster&gt;
buildbot_port = 9989</pre></div><p>You'll need to add similar entries for each repository that you want to be connected to buildbot.</p></li><li class="listitem"><a class="indexterm" id="id632"/>Once you have the buildmaster and buildslaves configured, and have hooked buildbot into your version control system, and have started the buildmaster and buildslaves, you're in business.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec119"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just set up Buildbot to run our tests, whenever it notices that our source code has been unchanged for two hours.</p><p>We told it to run the tests by adding a build step that runs nosetests:</p><div><pre class="programlisting">f1.addStep(Test(command = 'nosetests'))</pre></div><p>We told it to wait for the source code to be unchanged for two hours by adding a build scheduler:</p><div><pre class="programlisting">c['schedulers'].append(Scheduler(name="all", branch=None,
                                 treeStableTimer=2 * 60,
                                 builderNames=["buildbot-full"]))</pre></div><p>You'll be able to see a report of the Buildbot status in your web browser, by navigating to the <code class="literal">buildbotURL</code> that you configured in the <code class="literal">master.cfg</code> file. One of the most useful reports is the so-called 'waterfall' view. If the most recent commit passes the tests, you should see something similar to this:</p><div><img alt="What just happened?" src="img/8846_10_08.jpg"/></div><p>On the other hand, when the commit fails to pass the tests, you'll see something more like this:</p><div><img alt="What just happened?" src="img/8846_10_09.jpg"/></div><p>Either way, you'll also see a history of earlier versions, and whether or not they passed the tests, as well as who made the changes, when, and what the output of the test command looked like.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Pop<a class="indexterm" id="id633"/> quiz – Buildbot
</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">What kind of projects benefit most from Buildbot and other such tools?</li><li class="listitem">When is it better to use Buildbot, as opposed to just running Nose from a version control hook?</li><li class="listitem">When is it worse?</li><li class="listitem">Aside from running tests, what sort of tasks would Buildbot be useful for?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Have a go hero</h2></div></div></div><p>This is an open-ended assignment: take what you've learned and put it to use. Try a small project first (but make it test-driven), with tests integrated into your version control system. Once you have an implementation, use code coverage to help you have a comprehensive test suite. If it makes sense for your project, use Buildbot.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about code coverage and plugging our tests into the other automation systems that we use while writing software.</p><p>Specifically, we covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What code coverage is, and what it can tell us about our tests</li><li class="listitem" style="list-style-type: disc">How to run Nose automatically when our version control software detects changes in the source code</li><li class="listitem" style="list-style-type: disc">How to set up the Buildbot automated continuous integration system</li></ul></div><p>Now that we've learned about code coverage, version control hooks, and automated continuous integration, you're ready to tackle more or less anything. Congratulations!</p></div></body></html>