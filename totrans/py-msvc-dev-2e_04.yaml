- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Jeeves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Understanding Microservices*, we said that the natural way
    to build a microservices-based app is to start with a monolithic version that
    implements all the features, and then to split it into microservices that make
    the most sense. When you are designing software, you have enough to worry about
    with the flow of information through the system, meeting requirements, and working
    out how it all fits together. Having a design that encounters reality is when
    you start getting a good idea of what types of components you should have, and
    as you gain experience, it will become easier to spot potential microservices
    earlier on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go through this process by building a monolithic application
    and implementing the required features. We will cover how each component works
    and why it's there, as well as how information flows through the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized into two main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation of our application and its user stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Jeeves can be built as a monolithic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, in reality, the splitting process happens over time once the monolithic
    app design has some time to mature. But for the purpose of this book, we'll assume
    that the first version of the application has been used for a while and offered
    us some insights as to how it can be split in the right way, thanks to our time
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: The Jeeves bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jeeves** is an example application that was created for this book. Don''t
    look for it in the Apple or Play Store, as it''s not released or deployed for
    real users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the application does work, and you can study its different components
    on GitHub in the PythonMicroservices organization: [https://github.com/PythonMicroservices/](https://github.com/PythonMicroservices/).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be connecting to Slack, a popular communication platform, primarily
    used to send text messages in channels, similar to the older IRC service. Jeeves
    will be our personal assistant—a name taken from the stories of *P. G. Wodehouse*—and
    used for other software bots and at least one search engine. We will be using
    the name for its familiarity and not because of any connection with other people's
    work. The Jeeves presented here offers an interactive service to users of a Slack
    workspace and can be easily adapted to other chat environments. It also offers
    a web view to configure essential settings.
  prefs: []
  type: TYPE_NORMAL
- en: Once Jeeves is connected to a Slack workspace, a user can send the bot messages
    and receive replies. Users can also visit the web page and register for any third-party
    services they might need to connect to thanks to the standard OAuth2 mechanism.
    See more at [https://oauth.net/2/](https://oauth.net/2/).
  prefs: []
  type: TYPE_NORMAL
- en: We will be using **Strava** ([https://www.strava.com](https://www.strava.com))
    as an example of a third-party site, although this could easily be GitHub, Google
    services, Atlassian's JIRA, or some other useful service.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth2 standard is based on the idea of authorizing a third-party application
    to call a service with an access token that is unique to the user of the service.
    The token is generated by the service and usually has a limited scope in what
    calls can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the features through their user stories.
  prefs: []
  type: TYPE_NORMAL
- en: User stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, what should our application do? A good way to describe our goals is
    by covering the desired behavior in different scenarios. If you've been involved
    in Agile development before, this will be familiar in the guise of "user stories."
    User stories are very simple descriptions of all the interactions a user can have
    with an application, and is often the first high-level document that is written
    when a project starts, as some of the stories appear in the justification or proposal
    for the work to begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to fill lots of detail early on can also make life harder; start
    with high-level stories and add detail as they are revisited. Sometimes a user
    story might be discarded if it''s not feasible—it depends very much on how the
    work progresses and on the feasibility of each idea. User stories are also helpful
    to detect when it''s worth splitting a feature into its microservice: a story
    that stands on its own could be a good candidate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Jeeves, we can start with this small set:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Slack workspace user, I can send messages to a bot and get updates about
    the weather without leaving Slack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Slack workspace user, I expect the bot to remember facts that I have told
    it about myself, such as my location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Slack workspace user, I can visit the bot's control panel and authenticate
    third-party services, such as GitHub and Strava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an admin of the bot, I can get statistics regarding the bot's usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an admin of the bot, I can disable or change the configuration of various
    features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can create an account on a third-party site that the bot knows
    about, and then use the bot to perform tasks there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are already a few components emerging from this set of user stories.
    In no particular order, these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The app needs to store the contents of some types of messages it receives. These
    may be stored against a specific Slack identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user should be able to navigate to a web interface for third-party site authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app will authenticate web users with a password or a URL with a provided
    token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app should be able to perform periodic scheduled tasks to alert the user
    if a condition is true, such as for bad weather.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These descriptions are enough to get us started. The next section describes
    how the application can be designed and coded.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents extracts from the source code of the monolithic version
    of Jeeves. If you want to study it in detail, then the whole application can be
    found at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith).
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to consider is the retrieval of data from Slack into our application.
    There will be a single endpoint for this, as Slack sends all its events to the
    URL that the application developer configures. Later on, we can also add other
    endpoints to work with other environments, such as IRC, Microsoft Teams, or Discord.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a small interface to allow people to adjust the settings outside
    Slack, as controlling third-party authentication tokens and updating permissions
    for those tools is much easier using a web page. We will also need a small database
    to store all this information, along with other settings that we want our microservice
    to have.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will need some code to actually perform the actions our bot should
    do on behalf of the person who has sent it messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A design pattern that is often referred to when building applications is the
    **Model-View-Controller** (**MVC**) pattern, which separates the code into three
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This manages the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This displays the model for a particular context (web view, PDF view,
    and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This manipulates the model to change its state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLAlchemy` is a library that can aid with the model part, allowing us to
    specify tables, relationships, and wrappers around reading and writing data in
    our Python source code. In a microservice, the view and controller distinction
    can be a bit vague, because what is called a view is a function that receives
    a request and sends back a response—and that function can both display and manipulate
    the data, allowing it to act as both a View and as a Controller.'
  prefs: []
  type: TYPE_NORMAL
- en: The Django project uses **Model-View-Template** (**MVT**) to describe that pattern,
    where View is the Python callable, and Template is the template engine, or whatever
    is in charge of producing a response in a particular format, given some data.
    `Quart` uses Jinja2 for all sorts of useful template rendering—most commonly generating
    HTML and filling in the contents with values that it obtains from variables using
    the `render_template()` function. We will use this approach for views that present
    data to a human; for API views that return JSON, we will use `json.dumps()` to
    generate the response. In any case, the first step of designing our application
    is to define the model.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a `Quart` application based on SQLAlchemy, the model is described through
    classes, which represent the database schema. For Jeeves, the database tables
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: This contains information about each user, including their credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: This is a list of the available services the bot can provide,
    and whether or not they are active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log**: A log of bot activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the **SQLAlchemy** ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))
    library, each table is created as a subclass of the base class provided by the
    module, allowing us to avoid duplicating effort and leaving the classes in our
    own code clean and focused on the data that we want to work with. SQLAlchemy has
    asynchronous interfaces that can be used to keep the performance benefits of our
    async application while accessing the database. To use these features, we must
    install both `sqlalchemy` and `aiosqlite`. The full example can be found in the
    code samples'' GitHub repository as the `sqlachemy-async.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `User` table mostly stores some Unicode strings, but it's also worth noting
    the two `Boolean` values that guarantee that we do not need to interpret another
    system's way of storing `True` and `False`. There is also a JSON column for storing
    entire data structures—a feature available in an increasing number of backend
    databases, including PostgreSQL and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: When used in a `Quart` app, SQLAlchemy allows us to write an interface to avoid
    writing SQL directly; instead, we can call functions that query and filter the
    data. We can go one step further and create a **data access layer** (**DAL**)
    that handles all of the database session management for us. In the following code,
    we have written an access layer that can be used as a context manager, while providing
    methods to create and find users. The `create_user` method is simply using the
    model we defined previously to create a new Python object—without all the fields,
    to make the example clearer—and then adding it to the database session, ensuring
    the data has been written out before returning the value written to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on that, we can then use the `get_all_users` method to return all
    the records stored using the `User` model, using `select()` to retrieve them,
    and `get_user` to return just one record, while using the `where` method to filter
    the results to only display the ones that match the argument provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the DAL set up, we can use a feature provided by Python''s own `contextlib`
    to create an asynchronous context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All of this is a lot to set up, but once done, it allows us to access any of
    the data stored behind the `User` model with only a context manager to control
    the database session. We will use all this code in our views.
  prefs: []
  type: TYPE_NORMAL
- en: View and template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a request is received, a view is invoked through the URL mapping, and
    we can use the context manager we created above to query and update the database.
    The following `Quart` view will allow us to view all the users in the database
    when the `/users` endpoint is queried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `user_dal` context is created, we gain access to all the methods within
    it, and so we can easily call the `get_all_users` method and return the values
    to the client. Let''s put all of the above together into one example application,
    adding in some of our missing fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A human-readable view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we were to want this information presented in an easily readable format,
    we could use a Jinja2 template and pass the results of the query to fill in the
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Without any configuration to tell it otherwise, Jinja looks for its templates
    in a subdirectory of the Python application called `templates/`, which is often
    enough for small applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `users.html` template has some HTML in it, but also some directives that
    are bounded by curly braces. There is a `for` loop that allows us to iterate over
    the data that is passed to the template, and we can see that instructions sent
    to Jinja are surrounded by `{% and %}`. Another common instruction in a template
    would be `{% if … %}` to only include a piece of text if the condition is true.
    Inside the `for` loop, we see some variable expansions inside `{{` and `}}`, signaling
    to Jinja that it should look for a variable with that name. It''s possible to
    apply filters to variables, which is especially useful when formatting dates.
    Here is a simple template that loops over all of the users it is given and displays
    both their email address and Slack ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For editing data through the web, WTForms can be used to generate forms for
    each model. WTForms is a library that generates HTML forms with Python definitions,
    takes care of extracting data from incoming requests, and validating them before
    you update your model. Find out more at [http://wtforms.readthedocs.io](http://wtforms.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: The Flask-WTF project wraps WTForms for `Quart` and adds some useful integration,
    such as securing forms with **Cross-Site Request Forgery** (**CSRF**) tokens.
    Find out more at [https://flask-wtf.readthedocs.io/](https://flask-wtf.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: CSRF tokens will ensure that no malicious third-party website can send valid
    forms to your app when you are logged in. *Chapter 7*, *Securing Your Services*,
    will explain in detail how CSRF works and why it is important for your app security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following module implements a form for the `User` table, using `FlaskForm`
    as its basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `display` attribute is just a helper to assist the template in iterating
    into a particular ordered list of fields when rendering the form. Everything else
    is using WTForms basic fields classes to create a form for the user table. The
    WTForm's Fields documentation provides the full list at [https://wtforms.readthedocs.io/en/2.3.x/fields/](https://wtforms.readthedocs.io/en/2.3.x/fields/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, `UserForm` can be used in a view that has two goals. The first
    one is to display the form on `GET` calls, and the second one is to update the
    database on `POST` calls when the user submits the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `UserForm` class has a method to validate the incoming `POST` data, using
    the validators we provide. When some data is invalid, the form instance will keep
    the list of errors in `field.errors` in case the template wants to display them
    for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_user.html` template iterates through the form field list, and WTForm
    takes care of rendering the proper HTML tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `form.hidden_tag()` method will render all hidden fields, such as the CSRF
    token. Once this form is working, it's easy to reuse the same pattern for every
    form needed in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Forms are often adjusted regularly during development and, by necessity, they
    are tightly coupled to the structure of the database. Because of this, when we
    look at splitting Jeeves up into microservices, we will consider whether these
    forms need to be provided by the database microservice to avoid schema dependencies
    appearing in other services.
  prefs: []
  type: TYPE_NORMAL
- en: Slack workspaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Slack allows people to connect apps to a workspace. If you are an administrator
    of the FunCorp Slack instance, you could visit the following link and create a
    new bot user: [https://api.slack.com/apps?new_app=1](https://api.slack.com/apps?new_app=1).'
  prefs: []
  type: TYPE_NORMAL
- en: The exact process and web page layout may change—as web services frequently
    do—but there will be an opportunity to enable Event Subscriptions and provide
    a URL to which Slack messages should be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A token will be generated, which you should copy and place in your application''s
    settings so that it can authenticate to Slack when sending messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image3.png](img/B17108_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Subscribing to Slack bot events'
  prefs: []
  type: TYPE_NORMAL
- en: The `Request` URL that you give to Slack will need to be reachable from Slack's
    own servers, and so running this on your laptop may not be enough. If you run
    into trouble, then using a virtual server in a cloud provider is a quick and easy
    way to get going. We will cover this in more detail in *Chapter 10*, *Deploying
    on AWS*, where we discuss deploying our application in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the bot''s endpoint is verified, it will start receiving the messages
    it has subscribed to. This means that if you have selected `app_mention` events,
    then messages that don''t mention the bot by name will not be sent, but any others
    will. Your bot will need some permissions—known as scopes—to read and send messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image2.png](img/B17108_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Example Slack bot permissions to receive messages'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON data that is sent for an event arrives with all the data categorized.
    Using the example below, when the person types *@jeeves hello*, the API endpoint
    will receive a JSON object that identifies the workspace, the timestamp, what
    sort of event it was, what user typed it, and the component parts of the message
    itself—such as a mention (`@jeeves`) and the text, *hello*. Any user ID that is
    sent will not be recognizable to a human as they are the internal text strings
    used to represent users and workspaces. This does mean that when we connect a
    user to our application, we never really learn the username they chose in Slack
    unless we ask Slack for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a trimmed copy of the JSON data our service gets when we ask for the
    weather in our Slack workspace. It is easy to see that the values for the user
    and team are not human-friendly, but the JSON is also helpful in that it has already
    broken up a potentially complicated message into sections for us so that we don''t
    need to worry about safely removing mentions of other users, links, or other special
    elements that can be in the post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Taking actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our bot should be able to do useful things for the people who send it messages,
    and we should keep these actions as self-contained as possible. Even without using
    a microservice-based design, it is far safer to create well-defined boundaries
    between different components.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know which action to take? After receiving a message from Slack, we
    need to understand the data we have been given and look for the appropriate keywords.
    When we find something that matches, we can then check to see what function we
    should call.
  prefs: []
  type: TYPE_NORMAL
- en: The `Quart` view we use to handle Slack messages should be as simple as possible,
    and so we do just enough processing to extract information from the data we are
    given and pass it on to a message processor. This processor is responsible for
    examining the text the bot has been sent, and deciding on a course of action.
    Arranging the code this way also means that if we add support from other chat
    services, we can use the same message processor, and so consult the same list
    of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may require a more complex or dynamic action configuration later, but for
    now, let''s start with a simple mapping in the configuration file. The dictionary
    keys will be some text to look for at the start of the message, and the value
    is the name of a function to be called when it matches. Each of those functions
    will take the same arguments, to make our life simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By using this approach, adding new actions to our bot does not involve any changes
    to the `process_message` function, and so no changes are made to the tests for
    that function; instead, we just change a dictionary near the top of the file.
    It will also be easier to move the `ACTION_MAP` into a database or configuration
    file later if we discover that this would be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The actions might make good use of the metadata, and so we pass that information
    along. Looking up the weather, for example, can make use of any stored location
    that the person has told us about.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OAuth2** ([https://oauth.net/2/](https://oauth.net/2/)) allows us to make
    an authenticated request to someone else''s site. We could request read-only access
    to someone''s Google calendar, permission to post issues to GitHub, or the ability
    to read information about our recorded exercises in a fitness application. We
    can do all of this without ever asking for someone''s password to a different
    site—something no one should ever do!'
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will connect to Slack to allow the people using our bot
    to log in and update information about themselves. We can also use this to fetch
    information about them, such as the details of their Slack profile—if they allow
    us to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will present people visiting a web page with a button they can use to log
    in to the site using Slack, which will send the web browser off to Slack''s page
    to authorize our application. If they agree, then our application is given a code,
    which we can then use to request an access token. That access token will let us
    contact Slack and verify that the token is still valid, and let us ask for the
    information the person has allowed us to view—or change! For this example, we
    will need HTTPS enabled and a valid site certificate. The easiest way to do this
    will be to use a proxy and a "Let''s Encrypt" certificate. We will cover setting
    up this proxy and certificate in *Chapter 7*, *Securing Your Services*. For now,
    let''s look at how we log users in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have introduced **aiohttp** ([https://docs.aiohttp.org/](https://docs.aiohttp.org/))
    here, which is a useful asynchronous library for making outgoing web requests.
    We are also not handling the error responses that our callback view receives,
    or storing this useful data in a database to use later on. In that view, `@login_required`
    and `current_user` are part of the authentication and authorization processes
    presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our monolithic application is almost ready but it also requires a way to handle
    authentication and authorization. Simply put:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** is proving that you are who you claim to be'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization** is determining what actions you are permitted to perform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a careful—but critically important—distinction to make. In most services,
    there is an administrator, who must provide authentication—prove who they are—to
    be granted permission to perform configuration updates. A regular user of the
    service still must prove who they are, but the things they can do will not include
    the same access rights as used by administrators.
  prefs: []
  type: TYPE_NORMAL
- en: For Jeeves, we need to connect our Slack users to our web service user interface
    so that people can authenticate with external services. We are setting up the
    third-party authentication this way so that we don't need to perform any complicated
    changes to a standard OAuth process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Slack uses an internal identifier for most users, we won''t see—nor do
    we need to—the friendly name they have chosen to display to other people. Instead,
    we will know them by a short nine-character string: You can view your own by checking
    your Slack profile, and it will be visible under the **More** menu. How do we
    connect that with the web interface? The quickest way would be to get a sign-in
    link from the bot. If a user sends Jeeves a message asking to log in, Jeeves can
    reply with a URL. Once visited, that URL will let the user set a password and
    use all the web features.'
  prefs: []
  type: TYPE_NORMAL
- en: For our monolithic solution, we have just seen how we can let people log in
    using Slack without us ever having to handle a password. Using the `quart-auth`
    library makes managing session information for a user straightforward as it provides
    useful helper functions to create and store session cookies so that we will be
    remembered between visits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the changes, our welcome page no longer presents the login button
    in its template, but instead now has a new decorator, `@login_required`, which
    will only allow the view to be loaded if we have declared that the current visitor
    has successfully authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If a visitor to the site is not authenticated, then their visit will be handled
    by the `errorhandler` we set, which here redirects them to the login page. The
    login page does the same job as our previous welcome page and shows the user the
    login button to press:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Slack OAuth2 process continues as it did before, and we receive a message
    in our callback. If the message indicates that things went well, then we can use
    the `AuthUser` calls of `quart-auth` and the `login_user` calls to set a session
    for this user. Let''s put the whole thing together in a working example, making
    use of the `secrets` library to generate a secure, but temporary, secret key for
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you do need to store passwords, the simplest form of protection is to make
    sure that they are not stored in the clear in a database; instead, store them
    in a hashed form that cannot be converted back to the original password. That
    will minimize the risk of leaking passwords if your server is compromised. For
    the authentication process, it just means that when the user logs in, you need
    to hash the incoming password to compare it to the stored hash. Always check to
    see what the latest recommendations are for hashing algorithms, as inventing your
    own or using one that is obsolete can be very risky.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer is not usually the weak spot in application security. Thanks
    to the hard work of security professionals working on **Transport Layer Security**
    (**TLS**), we only need to concern ourselves with what happens inside the service
    once the request is received.
  prefs: []
  type: TYPE_NORMAL
- en: In the same vein, more granular permission verifications can be done by looking
    at the `current_user` variable that `quart_auth` sets in the application context.
    For example, you could use this to allow a user to change their data, but prevent
    them from changing any other users' data.
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, our application has several features that would be useful to run as
    scheduled tasks, without user interaction: our weather action could check for
    weather alerts in a user''s area and send a message to them; a calendar action
    could report on your scheduled meetings at the start of the working day; a monthly
    report of the actions that have been undertaken could be produced and emailed
    to the person looking after the bot.'
  prefs: []
  type: TYPE_NORMAL
- en: These are background tasks, and they need to run on their own outside the HTTP
    request/response cycle. Most operating systems have some form of scheduled task
    feature, such as cron on Unix or Scheduled Tasks in Windows. These features may
    not be ideal for our application, as it means we are connected to a specific platform
    when we should ideally be platform-agnostic, and able to run inside containers,
    or migrate to a serverless platform if our needs change.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular way to run repetitive background tasks in Python web apps is to use
    **Celery**, a distributed task queue that can execute some work in a standalone
    process: [http://docs.celeryproject.org](http://docs.celeryproject.org).'
  prefs: []
  type: TYPE_NORMAL
- en: To run these pieces of work, an intermediate called a message broker is in charge
    of passing messages back and forth between the application and Celery. For instance,
    if the app wants Celery to run something, it will add a message in the broker;
    Celery will poll it and do the job.
  prefs: []
  type: TYPE_NORMAL
- en: A message broker can be any service that can store messages and provide a way
    to retrieve them. The Celery project works out of the box with **Advanced Message
    Queuing Protocol** (**AMQP**) services such as **RabbitMQ** ([http://www.rabbitmq.com](http://www.rabbitmq.com)),
    **Redis** ([http://redis.io](http://redis.io)), and **Amazon SQS** ([https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/)).
    AMQP provides a standard set of techniques for routing and delivering messages
    in a reliable way. We will be using RabbitMQ in our examples when we investigate
    the microservices design in more detail in the next chapter, where RabbitMQ will
    be responsible for making sure that messages reach their destination, and Celery
    is responsible for acting on those messages.
  prefs: []
  type: TYPE_NORMAL
- en: The component that executes the job is called a worker, and Celery provides
    a class to start one. To use Celery from a `Quart` application, you can create
    a `background.py` module that instantiates a Celery object and marks your background
    tasks with an `@celery.``task` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are using Celery to set up a task that will fetch
    weather reports for every user who has a location and a Slack username set in
    our database. While, in practice, we would want people to opt-in to this feature,
    it allows us to show how a task is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the database we created earlier in this chapter and assume we have
    added a location field to it. We should also add a function to let us search for
    user accounts with a location set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up a worker to do the task. The only difficulty is needing to
    wrap the function we call to do the work. To use the asynchronous database engine,
    it must be an `async` function, but Celery can only call synchronous functions,
    so we use a helper found in the `asgiref` library to convert it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Celery will need RabbitMQ running in order to work—there are tutorials on RabbitMQ''s
    website, but below we assume you have Docker installed and can run containers.
    If you don''t, then don''t worry; we will discuss containers in more detail in
    *Chapter 10*, *Deploying on AWS*. We run the Celery background worker, which will
    wait for messages to arrive asking it to do work, and in another terminal, we
    start the scheduler, or beat, which will use the periodic task we set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This Celery worker also connects to RabbitMQ using AMQP, so that tasks can be
    triggered by sending a message through the broker. This will be especially useful
    if we don't need to send an immediate response to the caller, but instead expect
    a longer-running process to perform some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing our setup, we can look at the scheduler. Every 10 seconds is probably
    a bit too frequent for a report like this. We should instead use the crontab feature
    from Celery, which lets us specify a schedule while using the more familiar Unix
    crontab settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the Celery service is invoked by the `Quart` application by passing messages,
    it could be considered as a microservice in and of itself. That is also interesting
    in terms of deployment since both the RabbitMQ server and the Celery app can be
    deployed on another server. Our asynchronous function can then use the current
    app context to access the database, run queries, and then use the features of
    our application to run tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Putting together the monolithic design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This monolithic design is a solid foundation and should be the kind of result
    you would aim for in your first development iteration. Everything should be created
    with tests and documentation, as explained in *Chapter 3*, *Coding, Testing, and
    Documentation: the Virtuous Cycle*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a short and clean implementation on top of a relational database that
    can be deployed with a PostgreSQL, MySQL, or a cloud provider''s own SQL database.
    Thanks to the SQLAlchemy abstractions, a local version can run with SQLite 3 and
    facilitate your day-to-day development and local testing. To build this app, we''ve
    used the following extensions and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**aiohttp**: This handles all the outgoing HTTP requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLAlchemy**: This is used for the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flask-WTF** and **WTForms**: These are used for all the forms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Celery and RabbitMQ**: These are used for background processes and periodic
    tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**quart-auth**: This is used for managing authentication and authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overall design can be represented in a diagram, as shown in *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17108_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The components of our first design'
  prefs: []
  type: TYPE_NORMAL
- en: A typical early deployment will put all of these services on the same server.
    It's certainly simpler that way, and it often feels straightforward to give an
    application a more powerful computer—this is known as scaling vertically. A single
    computer, whether it's a virtual machine in a cloud provider or a physical server
    in your building, has a limited number of resources available, and so there is
    a practical upper limit to vertical scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Whether your application is running out of memory, network throughput, CPU processing
    availability, or some other bottleneck, the best solution is to update the architecture
    so that the service can be run across many different computers. This is scaling
    horizontally, and is one of the benefits of using microservices. If a microservice
    needs more I/O throughput to serve all its requests than a single computer can
    provide, that's not a problem if it can run across dozens or hundreds of computers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jeeves bot is a typical web app that interacts with a database and a few
    backend services. The only unusual feature is that it receives most of its workload
    from one endpoint. Building this application with a monolithic architecture has
    allowed us to quickly iterate over several choices and get a prototype that works
    well during development and low-volume usage.
  prefs: []
  type: TYPE_NORMAL
- en: From our discussions about the actions, it should be clear that there are good
    candidates for migration to a microservice. If we run this bot for dozens or hundreds
    of Slack workspaces, then we may find that one component is used much more than
    others, or has reliability issues that are difficult to address in the current
    architecture. How should the application scale up? What happens when an external
    service it relies upon is encountering errors? What happens if one of our own
    components—our database or message broker—goes down?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look at these issues: how to change the architecture
    of Jeeves so that it is more resilient, and how to make careful, measured changes
    to the service.'
  prefs: []
  type: TYPE_NORMAL
