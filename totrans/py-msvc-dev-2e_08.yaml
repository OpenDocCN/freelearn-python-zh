- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Making a Dashboard
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作仪表板
- en: Most of the work done so far has focused on building microservices and making
    them interact with each other. It is time to bring humans into the equation, adding
    a **User Interface** (**UI**) through which our end users can use the system with
    a browser and change settings that may be awkward or unwise to do through Slack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大部分工作都集中在构建微服务和使它们相互交互上。现在是时候将人类纳入方程，通过**用户界面**（**UI**）让我们的最终用户能够通过浏览器使用系统，并更改可能通过Slack进行操作显得尴尬或不智的设置。
- en: Modern web applications greatly rely on client-side JavaScript (JS, also known
    as ECMAScript). Some JS frameworks go all the way in terms of providing a full
    **Model-View-Controller** (**MVC**) system, which runs in the browser and manipulates
    the **Document Object Model** (**DOM**), the structured representation of the
    web page that is rendered in a browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用在很大程度上依赖于客户端JavaScript（JS，也称为ECMAScript）。一些JS框架在提供完整的**模型-视图-控制器**（**MVC**）系统方面做到了极致，该系统在浏览器中运行并操作**文档对象模型**（**DOM**），这是在浏览器中渲染的网页的结构化表示。
- en: The web development paradigm has shifted from rendering everything on the side
    of the server, to rendering everything on the client side with data collected
    from the server on demand. The reason is that modern web applications change portions
    of a loaded web page dynamically instead of calling the server for a full rendering.
    It is faster, requires less network bandwidth, and offers a richer user experience.
    Delays of a few seconds can cause a user to navigate away from your page, unless
    they have a strong need to visit it, such as, more specifically, a need to shop
    or read. One of the biggest examples of this client-side shift is the Gmail app,
    which pioneered these techniques around 2004.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发范式已经从在服务器端渲染一切转变为在客户端渲染一切，客户端根据需要从服务器收集数据。原因是现代Web应用动态地更改已加载网页的部分，而不是调用服务器进行完整渲染。这更快，需要的网络带宽更少，并提供了更丰富的用户体验。几秒钟的延迟可能导致用户离开你的页面，除非他们有强烈的访问需求，比如更具体地说，有购物或阅读的需求。这一客户端转变的最大例子之一是Gmail应用，它在大约2004年开创了这些技术。
- en: Tools like Facebook's **ReactJS** ([https://facebook.github.io/react/](https://facebook.github.io/react/))
    provide high-level APIs to avoid manipulating the DOM directly and offer a level
    of abstraction which makes client-side web development as comfortable as building
    Quart applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Facebook的**ReactJS**([https://facebook.github.io/react/](https://facebook.github.io/react/))这样的工具提供了高级API，以避免直接操作DOM，并提供了一种抽象级别，使得客户端Web开发如同构建Quart应用一样舒适。
- en: That said, there seems to be a new JS framework every other week, and it is
    often hard to decide which one to use. **AngularJS** ([https://angularjs.org/](https://angularjs.org/))
    used to be the coolest toy, but now many developers have switched to implementing
    most of their application UIs with ReactJS. There are also newer languages, such
    as **Elm** ([https://elm-lang.org](https://elm-lang.org)), which offers a functional
    programming language that compiles to JavaScript, allowing the compile-time detection
    of many common programming errors while also having a runtime that will work with
    any browser. In the future, no doubt, another new player will be popular.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，每两周似乎都会出现一个新的JS框架，而且往往很难决定使用哪一个。**AngularJS**([https://angularjs.org/](https://angularjs.org/))曾经是最酷的玩具，但现在许多开发者已经转向使用ReactJS来实现他们的大部分应用UI。还有一些新的语言，例如**Elm**([https://elm-lang.org](https://elm-lang.org))，它提供了一种编译到JavaScript的函数式编程语言，允许在编译时检测许多常见的编程错误，同时其运行时也能与任何浏览器兼容。毫无疑问，未来还将有新的参与者变得流行。
- en: 'This volatility is not a bad sign at all. It simply means much innovation is
    happening in the JavaScript and browser ecosystem. Features like service workers
    allow developers to run JS code in the background natively: [https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API](https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种波动性根本不是什么坏信号。它仅仅意味着在JavaScript和浏览器生态系统中发生了大量的创新。例如，服务工作者（service workers）功能允许开发者以原生方式在后台运行JS代码：[https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API](https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API)。
- en: '`WebAssembly` ([https://webassembly.org/](https://webassembly.org/)), an extremely
    fast and safe sandboxed environment, allows developers to produce resource-intensive
    tools, such as 3D rendered environments, all running in a web browser.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly`([https://webassembly.org/](https://webassembly.org/))，一个极快且安全的沙箱环境，允许开发者创建资源密集型的工具，如3D渲染环境，所有这些都在Web浏览器中运行。'
- en: If you have a clean separation between your UI and the rest of the system, moving
    from one JS framework to another should not be too hard. This means that you should
    not change how your microservices publish data to make them specific to a JS framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 UI 与系统其他部分进行了清晰的分离，从一种 JS 框架迁移到另一种应该不会太难。这意味着你不应该改变你的微服务发布数据的方式，使其特定于 JS
    框架。
- en: For our purposes, we shall use ReactJS to build our little dashboard, and we
    will wrap it in a dedicated Quart application that bridges it to the rest of the
    system. We will also see how that app can interact with all our microservices.
    We have chosen this approach due to ReactJS's current popularity, though you will
    also get excellent results in any of the other popular environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将使用 ReactJS 来构建我们的小型仪表板，并将其包装在一个专门的 Quart 应用程序中，该应用程序将其与系统其他部分连接起来。我们还将看到该应用程序如何与所有我们的微服务交互。我们选择这种方法是因为
    ReactJS 当前的流行，尽管你也会在其他任何流行的环境中获得优秀的结果。
- en: 'This chapter is composed of the following three parts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章由以下三个部分组成：
- en: Building a ReactJS dashboard—a short introduction to ReactJS with an example
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 ReactJS 仪表板——ReactJS 简介及示例
- en: How to embed ReactJS in a Quart app and structure the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Quart 应用程序中嵌入 ReactJS 并构建应用程序结构
- en: Authentication and authorization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: By the end of this chapter, you should have a good understanding of how to build
    a web UI using Quart, with the knowledge of how to make it interact with microservices—whether
    you choose to use ReactJS or not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对如何使用 Quart 构建 Web UI 有很好的理解，并了解如何使其与微服务交互——无论你是否选择使用 ReactJS。
- en: Building a ReactJS dashboard
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 ReactJS 仪表板
- en: The ReactJS framework implements its abstraction of the DOM and provides fast
    and efficient machinery to support dynamic events. Creating a ReactJS UI involves
    creating classes with a few standard methods, which will get called when events
    happen, such as the DOM being ready, the React class having been loaded, or user
    input occurring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 框架实现了对 DOM 的抽象，并提供快速高效的机制来支持动态事件。创建 ReactJS UI 涉及创建具有一些标准方法的类，这些方法将在事件发生时被调用，例如
    DOM 准备就绪、React 类已加载或用户输入发生。
- en: In a similar way to a web server such as nginx, taking care of all the difficult
    and common parts of the network traffic and leaving you to deal with the logic
    in your endpoints, ReactJS lets you concentrate on the implementation in your
    methods instead of worrying about the state of the DOM and the browser. Implementing
    classes for React can be done in pure JavaScript, or using an extension called
    JSX. We will discuss JSX in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 nginx 这样的网络服务器，处理所有困难和常见的网络流量部分，让你专注于端点的逻辑，ReactJS 允许你专注于方法实现，而不是担心 DOM
    和浏览器状态。React 的类可以通过纯 JavaScript 实现，或者使用一个名为 JSX 的扩展。我们将在下一节讨论 JSX。
- en: The JSX syntax
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 语法
- en: Representing XML markup in a programming language can be hard work. A seemingly
    simple approach might be to treat all the markup as strings and format the content
    as if it were a template, but this approach means that your code does not understand
    what all that markup means. The other extreme would be creating each markup element
    as an object and rendering it all to the text representation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中表示 XML 标记可能是一项艰巨的工作。一种看似简单的方法可能是将所有标记视为字符串，并将内容格式化为模板，但这种方法意味着你的代码并不理解所有这些标记的含义。另一种极端的做法是创建每个标记元素作为对象，并将它们全部渲染为文本表示。
- en: Instead, there is a better, hybrid model using a transpiler – a type of compiler
    that generates a different form of source code instead of a runnable program.
    The JSX syntax extension ([https://facebook.github.io/jsx/](https://facebook.github.io/jsx/))
    adds XML tags to JavaScript and can be transpiled into pure JavaScript, either
    in the browser or beforehand. JSX is promoted by the ReactJS community as the
    best way to write React apps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有一个更好的混合模型，使用转换器——一种生成不同形式源代码而不是可执行程序的编译器。JSX 语法扩展（[https://facebook.github.io/jsx/](https://facebook.github.io/jsx/））向
    JavaScript 添加 XML 标签，并可以转换为纯 JavaScript，无论是在浏览器中还是在之前。JSX 被 ReactJS 社区推广为编写 React
    应用程序的最佳方式。
- en: 'In the following example, a `<script>` section contains a `greeting` variable
    whose value is an XML structure representing a `div`; this syntax is valid JSX.
    From there, the `ReactDOM.render()` function can render the `greeting` variable
    in the DOM at the `id` you specify:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，一个`<script>`部分包含一个`greeting`变量，其值是一个表示`div`的XML结构；这种语法是有效的JSX。从那里，`ReactDOM.render()`函数可以在你指定的`id`处将`greeting`变量渲染到DOM中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The two ReactJS scripts are part of the React distribution, and here we are
    using the development versions, which will provide more helpful error messages
    while we are still writing our code. Smaller, encoded versions—known as minified—are
    preferred for production use, as they use less network bandwidth and cache storage
    space. The `babel.min.js` file is part of the Babel distribution and needs to
    be loaded before the browser encounters any JSX syntax.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个ReactJS脚本都是React分发的部分，在这里我们使用的是开发版本，它们在编写代码时将提供更有帮助的错误信息。较小的、编码过的版本——称为压缩版本——在生产使用中更受欢迎，因为它们使用更少的网络带宽和缓存存储空间。`babel.min.js`文件是Babel分发的部分，需要在浏览器遇到任何JSX语法之前加载。
- en: Babel (`https://babeljs.io/`) is a transpiler that can convert JSX to JS on
    the fly, among other available conversions. To use it, you simply need to mark
    a script as being of type `text/babel`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Babel（`https://babeljs.io/`）是一个转换器，可以将JSX即时转换为JS，以及其他可用的转换。要使用它，你只需将脚本标记为`text/babel`类型。
- en: The JSX syntax is the only specific syntax difference to know about React, as
    everything else is done with common JavaScript. From there, building a ReactJS
    application involves creating classes to render markup and respond to events,
    and these will be used to render the web pages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JSX语法是了解React的唯一特定语法差异，因为其他所有操作都是使用常见的JavaScript完成的。从那里，构建ReactJS应用程序涉及创建类来渲染标记并响应用户事件，这些类将被用来渲染网页。
- en: Let's now look at the heart of ReactJS – components.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看ReactJS的核心——组件。
- en: React components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React组件
- en: ReactJS is based on the idea that a web page can be constructed from basic components,
    which are invoked to render different parts of the display and respond to events
    such as typing, clicks, and new data appearing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS基于这样的想法：网页可以从基本组件构建，这些组件被调用以渲染显示的不同部分并响应用户事件，如键入、点击和新数据的出现。
- en: As an example, if you want to display a list of people, you can create a `Person`
    class that is in charge of rendering a single person's information, given its
    values, and a `People` class that iterates through a list of people and calls
    the `Person` class to render each item.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想显示人员列表，你可以创建一个`Person`类，该类负责根据其值渲染单个人员的详细信息，以及一个`People`类，它遍历人员列表并调用`Person`类来渲染每个项目。
- en: 'Each class is created with the `React.createClass()` function, which receives
    a mapping containing the future class methods. The `createClass()` function generates
    a new class, and sets a `props` attribute to hold some properties alongside the
    provided methods. In the following example, in a new JavaScript file, we define
    a `Person` class with a `render()` function, which returns a `<div>` tag, and
    a `People` class which assembles the `Person` instances:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都是通过`React.createClass()`函数创建的，该函数接收一个包含未来类方法的映射。`createClass()`函数生成一个新的类，并设置一个`props`属性来存储一些属性以及提供的方法。在下面的示例中，在一个新的JavaScript文件中，我们定义了一个具有`render()`函数的`Person`类，该函数返回一个`<div>`标签，以及一个`People`类，它组装`Person`实例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Person` class returns a `div`—a section or division—containing details
    about the person by referring to the `props` attribute in the instance. Updating
    these properties will update the object, and so update the display.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类返回一个`div`——一个部分或分区——通过引用实例中的`props`属性来包含关于该人的详细信息。更新这些属性将更新对象，从而更新显示。'
- en: The `props` array is populated when the `Person` instance is created; this is
    what happens in the `render()` method of the `People` class. The `peopleNodes`
    variable iterates through the `People.props.data` list, which contains a list
    of the people we want to show. Each `Person` class is also provided with a unique
    key so that it can be referred to later if needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`Person`实例时，`props`数组会被填充；这就是在`People`类的`render()`方法中发生的事情。`peopleNodes`变量遍历`People.props.data`列表，其中包含我们要展示的人的列表。每个`Person`类还提供了一个唯一的键，以便在需要时可以引用。
- en: All that is left to do is instantiate a `People` class and put a list of people
    to be displayed by React in its `props.data` list. In our Jeeves app, this list
    can be provided by the appropriate microservice—the data service for information
    that we store, or a different service if we are fetching data from a third party.
    We can load the data asynchronously using an **Asynchronous JavaScript and XML**
    (**AJAX**) pattern using the built-in fetch method, or another helper library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是实例化一个 `People` 类，并将要由 React 显示的人员列表放入其 `props.data` 列表中。在我们的 Jeeves 应用中，这个列表可以由适当的微服务提供——存储信息的数据服务，或者如果我们是从第三方获取数据，则可能是另一个服务。我们可以使用内置的
    fetch 方法，或者另一个辅助库，通过异步 JavaScript 和 XML（**AJAX**）模式加载数据。
- en: 'That is what happens in the `loadPeopleFromServer()` method in the following
    code, which builds on the previous example – add it to the same `jsx` file. The
    code calls our data service on the endpoint that lists all users, using a `GET`
    request and expecting some JSON as a response. Then, it sets the properties of
    the React component with the result, which propagates down through the other classes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的 `loadPeopleFromServer()` 方法就是这种情况，它基于前面的示例——将其添加到同一个 `jsx` 文件中。代码在列出所有用户的端点上调用我们的数据服务，使用
    `GET` 请求并期望得到一些 JSON 响应。然后，它使用结果设置 React 组件的属性，这些属性会向下传播到其他类：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the state changes, an event is passed to the `React` class to update the
    DOM with the new data. The framework calls the `render()` method, which displays
    the `<div>` containing `People`. The `People` instance, in turn, passes data down
    to each `Person` instance in a cascade.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态发生变化时，一个事件会被传递给 `React` 类以更新 DOM 中的新数据。框架调用 `render()` 方法，该方法显示包含 `People`
    的 `<div>`。反过来，`People` 实例将数据逐级传递给每个 `Person` 实例。
- en: To trigger the `loadPeopleFromServer()` method, the class implements the `componentDidMount()`
    method, which gets called once the class instance is created and mounted in React,
    ready to be displayed. Last, but not least, the class's constructor provides an
    empty set of data so that in the time before anything has loaded, the display
    is not broken.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发 `loadPeopleFromServer()` 方法，类实现了 `componentDidMount()` 方法，该方法在类实例在 React
    中创建并挂载后调用，准备显示。最后但同样重要的是，类的构造函数提供了一个空的数据集，这样在数据加载之前，显示就不会中断。
- en: 'This whole process of decomposition and chaining may seem complicated at first
    but, once in place, it is powerful and straightforward to use: it allows you to
    focus on rendering each component and letting React deal with how to do it in
    the most efficient way in the browser.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分解和链式的过程一开始可能看起来很复杂，但一旦实施，它就非常强大且易于使用：它允许你专注于渲染每个组件，并让 React 处理如何在浏览器中以最有效的方式完成它。
- en: Each component has a state, and when something changes, React first updates
    its own internal representation of the DOM—the virtual DOM. Once that virtual
    DOM is changed, React can apply the required changes efficiently on the actual
    DOM.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有一个状态，当某个东西发生变化时，React 首先更新其自身对 DOM 的内部表示——虚拟 DOM。一旦虚拟 DOM 发生变化，React 就可以在实际的
    DOM 上高效地应用所需的更改。
- en: All the JSX code we've seen in this section can be saved in a JSX file – it's
    static content, so let's place it in a directory called `static` – and used in
    an HTML page as follows. There is also a small helper microservice to serve these
    files in the code samples at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中看到的所有 JSX 代码都可以保存到一个 JSX 文件中——它是静态内容，所以让我们将其放在一个名为 `static` 的目录中——并在以下方式中用于
    HTML 页面。还有一个小的辅助微服务，用于在代码示例中提供这些文件，请参阅 [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample)。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PeopleBox` class is instantiated with the `/api/users` URL for this demonstration,
    and once the web page has loaded and been processed, the `componentDidMount` methods
    are triggered, React calls that URL, and it expects to get back a list of people,
    which it passes down the chain of components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，`PeopleBox` 类使用 `/api/users` URL 实例化，一旦网页加载并处理完毕，`componentDidMount`
    方法就会被触发，React 调用该 URL，并期望返回一个人员列表，然后将其传递给组件链。
- en: 'Notice that we have also set up where to render the components in the last
    two lines: first, we find the element in the HTML with the right identifier, and
    then tell React to render a class within it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在最后两行中也设置了组件的渲染位置：首先，我们找到 HTML 中具有正确标识符的元素，然后告诉 React 在其中渲染一个类。
- en: Using transpilation directly in the browser is unnecessary, as it can be done
    while building and releasing the application, as we will see in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中直接使用转译是不必要的，因为它可以在构建和发布应用程序时完成，正如我们将在下一节中看到的。
- en: This section described a very basic usage of the ReactJS library and did not
    dive into all its possibilities. If you want to get more info on React, you should
    try the tutorial at [https://reactjs.org/tutorial/tutorial.html](https://reactjs.org/tutorial/tutorial.html)
    as your first step. This tutorial shows you how your React components can interact
    with the user through events, which is the next step once you know how to do some
    basic rendering.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 ReactJS 库的非常基本的用法，并没有深入探讨其所有可能性。如果您想了解更多关于 React 的信息，应该尝试在 [https://reactjs.org/tutorial/tutorial.html](https://reactjs.org/tutorial/tutorial.html)
    上的教程，这是您的第一步。这个教程展示了您的 React 组件如何通过事件与用户交互，这是您在了解如何进行基本渲染之后的下一步。
- en: Pre-processing JSX
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理 JSX
- en: So far, we have relied on the web browser to convert the JSX files for us. We
    could still do that, however, it will be the same work being done by each web
    browser that visits our site. Instead, we can process our own JSX files and provide
    pure JavaScript to people visiting our site. To do that we must install some tools.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖网络浏览器为我们转换 JSX 文件。然而，我们仍然可以这样做，但这将是每个访问我们网站的浏览器所做的工作。相反，我们可以处理自己的
    JSX 文件，并向访问我们网站的人提供纯 JavaScript。为此，我们必须安装一些工具。
- en: 'Firstly, we need a JavaScript package manager. The most important one to use
    is `npm` ([https://www.npmjs.com/](https://www.npmjs.com/)). The `npm` package
    manager is installed via `Node.js`. On macOS, the `brew install node` command
    does the trick, or you can go to the **Node.js** home page ([https://nodejs.org/en/](https://nodejs.org/en/))
    and download it to the system. Once Node.js and `npm` are installed, you should
    be able to call the `npm` command from the shell as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个 JavaScript 包管理器。最重要的一个是要使用 `npm` ([https://www.npmjs.com/](https://www.npmjs.com/))。`npm`
    包管理器通过 `Node.js` 安装。在 macOS 上，`brew install node` 命令可以完成这项工作，或者您可以访问 **Node.js**
    主页 ([https://nodejs.org/en/](https://nodejs.org/en/)) 并将其下载到系统中。一旦安装了 Node.js
    和 `npm`，您应该能够在 shell 中调用 `npm` 命令，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Converting our JSX files is straightforward. Move the `.jsx` file we have created
    from `static/` to a new directory called `js-src`. Our directory layout should
    now look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 JSX 文件转换过来很简单。将我们从 `static/` 创建的 `.jsx` 文件移动到一个名为 `js-src` 的新目录中。我们的目录结构现在应该看起来像这样：
- en: '`mymicroservice/`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymicroservice/`'
- en: '`templates/` – all of our `html` files'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/` – 我们所有的 `html` 文件'
- en: '`js-src/` – our `jsx` source code'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js-src/` – 我们的 `jsx` 源代码'
- en: '`static/` – the JavaScript results of the transpilation'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static/` – 转译后的 JavaScript 结果'
- en: 'We can then install the tools we need using:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装我们需要的工具：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, for our development, we can start a command that will continuously watch
    our `js-src` directory for any changes to the files, and automatically update
    them, in much the same way that the development version of Quart will reload Python
    files automatically. In a new terminal, type:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了我们的开发，我们可以启动一个命令，该命令将连续监视我们的 `js-src` 目录中的任何文件更改，并自动更新它们，这与 Quart 的开发版本自动重新加载
    Python 文件的方式非常相似。在一个新的终端中，输入：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can then see that it creates `.js` files for you and does so each time you
    save your changes to the JSX files in `js-src/`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它为您创建了 `.js` 文件，并且每次您在 `js-src/` 中的 JSX 文件上保存更改时，它都会这样做。
- en: 'To deploy our application, we can either generate the JavaScript files and
    commit them into the repository or generate them as part of the CI process. In
    either case, the command to process the files once is remarkably similar—we just
    don''t watch the directory, and we use the production presets:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的应用程序，我们可以生成 JavaScript 文件并将它们提交到仓库，或者作为 CI 流程的一部分生成它们。在两种情况下，处理文件一次的命令都非常相似——我们只是不监视目录，并使用生产预设：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With all the changes, the final `index.html` file just needs a small change
    to use the `.js` file instead of the `.jsx` one:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有更改完成后，最终的 `index.html` 文件只需要进行一个小改动，使用 `.js` 文件而不是 `.jsx` 文件：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have the basic layout for building a React-based UI, let's see how
    we can embed it in our Quart world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建基于 React 的 UI 的基本布局，让我们看看我们如何将其嵌入到我们的 Quart 世界中。
- en: ReactJS and Quart
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS 和 Quart
- en: From the perspective of the server, the JavaScript code is a static file, and
    so serving React apps with Quart is no trouble at all. The HTML page can be rendered
    with Jinja2, and the transpiled JSX files can be provided as static content alongside
    it, much like you would do for plain JavaScript files. We can also get the React
    distribution and serve those files, or rely on a **Content Delivery Network**
    (**CDN**) to provide them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器的角度来看，JavaScript 代码是一个静态文件，因此使用 Quart 提供 React 应用程序根本不是问题。HTML 页面可以使用 Jinja2
    渲染，并且可以将其与转换后的 JSX 文件一起作为静态内容提供，就像您为纯 JavaScript 文件所做的那样。我们还可以获取 React 分发版并提供服务这些文件，或者依赖
    **内容分发网络**（**CDN**）来提供它们。
- en: 'In many cases a CDN is the better option, as retrieving the files will be faster,
    and the browser then has the option of recognizing that it has already downloaded
    these files and can use a cached copy to save time and bandwidth. Let''s name
    our Quart application `dashboard`, and start off with a simple structure like
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，CDN 是更好的选择，因为检索文件将更快，浏览器随后可以选择识别它已经下载了这些文件，并可以使用缓存的副本来节省时间和带宽。让我们将我们的
    Quart 应用程序命名为 `dashboard`，并从以下简单结构开始：
- en: '`setup.py`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`'
- en: '`dashboard/`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard/`'
- en: '`__init__.py`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`app.py`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`'
- en: '`templates/`'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/`'
- en: '`index.html`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '`static/`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static/`'
- en: '`people.jsx`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`people.jsx`'
- en: 'The basic Quart application that serves the unique HTML file will look like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Quart 应用程序，用于服务独特的 HTML 文件，将看起来像这样：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thanks to Quart's convention on static assets, all the files contained inside
    the `static/` directory are served under the `/static` URL. The `index.html` template
    looks like the one described in the previous section and can grow into something
    Quart-specific later on. That is all we need to serve a ReactJS-based app through
    Quart.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Quart 对静态资源的约定，所有包含在 `static/` 目录中的文件都将在 `/static` URL 下提供服务。`index.html`
    模板看起来就像前一个章节中描述的那样，并且以后可以发展成为 Quart 特有的模板。这就是我们通过 Quart 提供基于 ReactJS 的应用程序所需的所有内容。
- en: Throughout this section, we have worked on the assumption that the JSON data
    that React picked was served by the same Quart app. Doing AJAX calls on the same
    domain is not an issue, but in case you need to call a microservice that belongs
    to another domain, there are a few changes required on both the server and the
    client side.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们一直假设 React 选择的 JSON 数据是由同一个 Quart 应用程序提供的。在同一域上进行 AJAX 调用不是问题，但如果你需要调用属于另一个域的微服务，服务器和客户端都需要进行一些更改。
- en: Cross-origin resource sharing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨源资源共享
- en: Allowing client-side JavaScript to perform cross-domain requests is a potential
    security risk. If the JS code that's executed in the client page for your domain
    tries to request a resource from another domain that you don't own, it could potentially
    run malicious JS code and harm your users. This is why all browsers use the W3C
    standard for cross-origin resources ([https://www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/))
    when a request is made. They ensure that the requests can only be made to the
    domain that served the page to us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 允许客户端 JavaScript 执行跨域请求是一个潜在的安全风险。如果执行在您的域客户端页面上的 JS 代码试图请求您不拥有的另一个域的资源，它可能会执行恶意
    JS 代码并损害您的用户。这就是为什么所有浏览器在发起请求时都使用 W3C 标准（[https://www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/)）进行跨源资源。它们确保请求只能发送到为我们提供页面的域。
- en: Beyond security, it is also a good way to prevent someone from using your bandwidth
    for their web app. For instance, if you provide a few font files on your website,
    you might not want another website to use them on their page and use your bandwidth
    without any control. However, there are legitimate use cases for wanting to share
    your resources with other domains, and you can set up rules on your service to
    allow other domains to reach your resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全之外，这也是防止某人使用您的带宽来运行他们的 Web 应用程序的好方法。例如，如果您在网站上提供了一些字体文件，您可能不希望其他网站在他们的页面上使用它们，并且在不加控制的情况下使用您的带宽。然而，有一些合法的理由想要与其他域共享您的资源，并且您可以在您的服务上设置规则以允许其他域访问您的资源。
- en: That is what **Cross-Origin Resource Sharing** (**CORS**) is all about. When
    the browser sends a request to your service, an `Origin` header is added, and
    you can control whether it is in the list of authorized domains. If not, the CORS
    protocol requires that you send back a few headers listing the allowed domains.
    There is also a `preflight` mechanism where the browser questions the endpoint
    via an `OPTIONS` call to know whether the request it wants to make is authorized
    and what capabilities the server has available. On the client side, you do not
    have to worry about setting up these mechanisms. The browser makes the decisions
    for you, depending on your requests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**跨源资源共享**（**CORS**）的全部内容。当浏览器向你的服务发送请求时，会添加一个`Origin`头，你可以控制它是否在授权域的列表中。如果不是，CORS协议要求你发送一些包含允许域的头信息。还有一个`preflight`机制，浏览器通过`OPTIONS`调用询问端点，以了解它想要发出的请求是否被授权以及服务器有哪些可用功能。在客户端，你不必担心设置这些机制。浏览器会根据你的请求为你做出决定。
- en: 'On the server side, however, you need to make sure your endpoints answer the
    `OPTIONS` calls, and you need to decide which domains can reach your resources.
    If your service is public, you can authorize all domains with a wildcard. However,
    for a microservice-based application where you control the client side, you should
    restrict the domains. The **Quart-CORS** ([https://gitlab.com/pgjones/quart-cors/](https://gitlab.com/pgjones/quart-cors/))
    project allows us to add support for this very simply:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，然而，你需要确保你的端点能够响应`OPTIONS`调用，并且你需要决定哪些域可以访问你的资源。如果你的服务是公开的，你可以使用通配符授权所有域。然而，对于一个基于微服务的应用程序，其中你控制客户端，你应该限制域。**Quart-CORS**
    ([https://gitlab.com/pgjones/quart-cors/](https://gitlab.com/pgjones/quart-cors/))
    项目允许我们非常简单地添加对此的支持：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When running this app and using `curl` to do a `GET` request, we can see the
    results in the `Access-Control-Allow-Origin: * header`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '当运行此应用程序并使用`curl`进行`GET`请求时，我们可以在`Access-Control-Allow-Origin: *`头中看到结果：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quart-CORS allows finer-grained permissions, with decorators that allow protecting
    a single resource or blueprint instead of the whole app, or limiting methods to
    `GET`, `POST`, or others. It's also possible to set configuration using environment
    variables, which helps the app remain flexible and get the correct settings at
    runtime.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Quart-CORS允许更细粒度的权限，使用装饰器可以保护单个资源或蓝图，而不是整个应用程序，或者限制方法为`GET`、`POST`或其他。还可以使用环境变量设置配置，这有助于应用程序保持灵活性，并在运行时获得正确的设置。
- en: 'For an in-depth understanding of CORS, the MDN page is a great resource that
    can be found here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
    In this section, we have looked at how to set up CORS headers in our services
    to allow cross-domain calls, which are useful in JS apps. What''s still missing
    to make our JS app fully functional is authentication and authorization.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解CORS，MDN页面是一个很好的资源，可以在以下链接找到：[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。在本节中，我们探讨了如何在我们的服务中设置CORS头以允许跨域调用，这在JS应用程序中非常有用。要使我们的JS应用程序完全功能，我们还需要认证和授权。
- en: Authentication and authorization
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: The React dashboard needs to be able to authenticate its users and perform authorized
    calls on some microservices. It also needs to enable the user to grant access
    to any third-party sites we support, such as Strava or GitHub.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: React仪表板需要能够验证其用户并在某些微服务上执行授权调用。它还需要允许用户授权访问我们支持的任何第三方网站，例如Strava或GitHub。
- en: 'We assume that the dashboard only works when you are authenticated and that
    there are two kinds of users: first-time and returning. The following is the user
    story for first-time users:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设仪表板只有在用户认证的情况下才能工作，并且有两种用户：新用户和回访用户。以下是新用户的用户故事：
- en: As a first-time user, when I visit the dashboard, there's a "login" link. When
    I click on it, the dashboard redirects me to Slack to grant access to my resources.
    Slack then redirects me back to the dashboard, and I am connected. The dashboard
    then starts to fill with my data.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一名新用户，当我访问仪表板时，有一个“登录”链接。当我点击它时，仪表板将我重定向到Slack以授权我的资源。Slack然后把我重定向回仪表板，我就连接上了。然后仪表板开始填充我的数据。
- en: As described, our Quart app performs an OAuth2 conversation with Slack to authenticate
    users—and we know that since we are setting up a Slack bot, people should already
    have an account there. Connecting to Slack also means we need to store the access
    token in the user profile so we can use it to fetch data later on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述所述，我们的Quart应用与Slack进行OAuth2会话以验证用户——我们知道，由于我们正在设置Slack机器人，人们应该已经在那里有账户了。连接到Slack还意味着我们需要在用户配置文件中存储访问令牌，以便我们可以在以后使用它来获取数据。
- en: 'Before going further, we need to make a design decision: do we want the dashboard
    merged with the dataservice, or do we want to have two separate apps?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论之前，我们需要做出一个设计决策：我们希望仪表板与数据服务合并，还是希望有两个独立的应用？
- en: A note about Micro Frontends
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于微前端的一些说明
- en: Now we are discussing authenticating our users with a web frontend, there is
    the question of where we should put the corresponding code. One recent trend in
    frontend architecture is the idea of Micro Frontends. Facing many of the same
    scaling and interoperability troubles as the backend has faced, some organizations
    are shifting towards small, self-contained user interface components that can
    be included in a larger site.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在讨论使用Web前端验证我们的用户，这就引出了一个问题：我们应该把相应的代码放在哪里。前端架构中的一个近期趋势是微前端的概念。面对与后端相同的许多扩展性和互操作性难题，一些组织正在转向小型、自包含的用户界面组件，这些组件可以包含在一个更大的网站上。
- en: 'Let''s imagine a shopping website. When you visit the front page, there will
    be several different parts, including:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个购物网站。当你访问首页时，会有几个不同的部分，包括：
- en: Shopping categories
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物类别
- en: Site-wide news and events, such as upcoming sales
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站范围内的新闻和活动，例如即将到来的销售
- en: Highlighted and promoted items for sale, including customized recommendations
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售的突出和推广商品，包括定制推荐
- en: A list of items you have recently viewed
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你最近查看的商品列表
- en: A widget allowing you to sign in or register for an account, plus other administrative
    tools
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许你登录或注册账户的小部件，以及其他管理工具
- en: If we develop a single web page to deal with all of these elements, it can become
    large and complex very quickly, especially if we need to repeat elements across
    different pages on the site. With many sites, these different features are kept
    separate by separating out the `<div>` tags that anchor them in the page, and
    keeping the code in separate JavaScript files—whether or not those files are separate
    by the time they are loaded into the web page, as they have likely been compiled
    and minified.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开发一个单独的网页来处理所有这些元素，它很快就会变得庞大而复杂，尤其是如果我们需要在网站上的不同页面上重复元素的话。在许多网站上，这些不同的功能通过分离锚定它们的`<div>`标签来保持独立，并将代码保存在单独的JavaScript文件中——无论这些文件在加载到网页时是否是分开的，因为它们很可能已经被编译和压缩。
- en: This approach introduces some of the same complications that a monolithic backend
    suffers from. A change to any of the backend or its user interface means updating
    a microservice and the user interface elements that query it, and those may well
    be in different source control repositories or managed by different teams. Perhaps
    support for both the old and new ways has to be introduced for a managed migration,
    or careful timing with different deployment mechanisms has to happen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法引入了一些与单体后端相同的复杂性。对后端或其用户界面的任何更改都意味着更新微服务及其查询的用户界面元素，而这些可能位于不同的源代码控制存储库中，或者由不同的团队管理。可能需要引入对旧方法和新方法的支持，以便进行管理的迁移，或者需要通过不同的部署机制进行谨慎的时间安排。
- en: By using a Micro Frontend architecture, these UI features can all be the responsibility
    of different teams and services. If the "recommendations" feature suddenly requires
    a new backend or a different JavaScript framework, that is possible, as the main
    site only knows about it as a self-contained feature to be included. Any change
    can also be self-contained, as the Micro Frontend UI components for the recommendations
    engine would live in the same repository and be provided by the same service.
    As long as the technique to include the Micro Frontend component doesn't change,
    the main user interface doesn't need to be changed; changes can be controlled
    entirely through the microservice it depends on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用微前端架构，这些UI功能都可以由不同的团队和服务负责。如果“推荐”功能突然需要新的后端或不同的JavaScript框架，这是可能的，因为主站只知道它是一个要包含的自包含功能。任何更改也可以是自包含的，因为推荐引擎的微前端UI组件将位于同一个存储库中，并由同一个服务提供。只要包含微前端组件的技术不改变，主用户界面就不需要改变；更改可以通过它所依赖的微服务完全控制。
- en: This also frees up the people working on each component, as they can release
    new features and bug fixes on their own schedule without large cross-team coordination
    to deploy updated features in multiple areas. The teams just have to ensure their
    UI is included in a consistent manner, accepts the same data, such as a customer
    identifier, and returns a UI element of the desired size.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解放了每个组件的工作人员，因为他们可以在自己的时间表上发布新功能和错误修复，而无需进行大量跨团队协调来部署多个区域的新功能。团队只需确保他们的UI以一致的方式包含在内，接受相同的数据，例如客户标识符，并返回所需大小的UI元素。
- en: 'Let''s look at the Packt website as an example. When loading the main web page,
    we get to see a banner along the top containing the usual options we expect, a
    banner below for current promotions and events, and then a listing of recently
    added stock to be brought to the reader''s attention:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Packt网站为例。当加载主网页时，我们可以看到顶部有一条横幅，包含我们通常期望的选项，下面有一条横幅用于显示当前促销和活动，然后是最近添加的库存列表，以引起读者的注意：
- en: '![](img/B17108_08_01.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_08_01.png)'
- en: 'Figure 8.1: Packt home page and its constituent parts'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：Packt主页及其组成部分
- en: 'If we were designing this page, we could construct at least three different
    micro-frontends: an authentication component that handles sessions and logging
    in, an events component that can display and react to upcoming conferences and
    promotions, and an inventory component that can display current stock. This approach
    isn''t ideal for all situations; on many occasions, a user interface needs to
    interact closely with other elements, or perhaps the spread of knowledge within
    an organization doesn''t allow it to produce many small user interface components
    this way.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计这个页面，我们可以构建至少三个不同的微前端：一个处理会话和登录的认证组件，一个可以显示和响应对即将到来的会议和促销的事件组件，以及一个可以显示当前库存的库存组件。这种方法并不适用于所有情况；在许多情况下，用户界面需要与其他元素紧密交互，或者组织内部的知识传播可能不允许以这种方式产生许多小的用户界面组件。
- en: It is also worth noting that this architecture does not require many different
    URLs. The same nginx load balancer could be configured to route different URLs
    to different backend services without the client being any the wiser—and this
    may give a useful approach to migrating to such an architecture, as it lowers
    the chance of you needing to update the endpoint URLs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种架构不需要很多不同的URL。同一个nginx负载均衡器可以被配置为将不同的URL路由到不同的后端服务，而客户端对此一无所知——这可能会为迁移到这种架构提供一种有用的方法，因为它降低了你需要更新端点URL的可能性。
- en: With all that said, the Micro Frontend model is still relatively new, and many
    best practices and even bits of terminology are still in flux. For that reason,
    we shall focus on a simpler variant of this approach and have the authentication
    service provide its own HTML for logging a user in and creating an account that
    can be included in an iframe within another page if desired.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，微前端模型仍然相对较新，许多最佳实践甚至术语都还在变化之中。因此，我们将关注这种方法的简化版本，并让认证服务提供自己的HTML以登录用户并创建账户，如果需要，可以将其包含在另一个页面中的iframe中。
- en: Getting the Slack token
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Slack令牌
- en: Slack provides a typical three-legged OAuth2 implementation, using a simple
    set of HTTP `GET` requests. Implementing the exchange is done by redirecting the
    user to Slack and exposing an endpoint the user's browser is redirected to once
    access has been granted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Slack提供了一个典型的三脚OAuth2实现，使用一组简单的HTTP `GET`请求。实现交换是通过将用户重定向到Slack并暴露一个用户浏览器在访问权限被授予后会被重定向到的端点来完成的。
- en: If we request the special identify scope, then all we get from Slack is confirmation
    of the user's identity and the unique Slack ID string. We can store all this information
    in the Quart session, use it as our login mechanism, and pass the e-mail and token
    values to `DataService` for use with other components if we need to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求特殊的身份识别范围，那么我们从Slack获得的就是用户身份的确认和唯一的Slack ID字符串。我们可以将所有这些信息存储在Quart会话中，用作我们的登录机制，并在需要时将电子邮件和令牌值传递给`DataService`用于其他组件。
- en: 'As we did in *Chapter 4*, *Designing Jeeves*, let us implement the function
    that generates the URL to send the user to, combined with the other information
    Slack needs, which is documented at [https://api.slack.com/legacy/oauth](https://api.slack.com/legacy/oauth):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第4章*，*设计Jeeves*中所做的那样，让我们实现一个生成要发送给用户的URL的函数，结合Slack需要的其他信息，这些信息在[https://api.slack.com/legacy/oauth](https://api.slack.com/legacy/oauth)上有文档说明：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are running our Quart application behind nginx with a Let's Encrypt
    certificate, as we also set up in *Chapter 4*, *Designing Jeeves*. This is why
    we are using a callback URL from our configuration rather than attempting to work
    it out dynamically, as that URL is tied to nginx.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用Let's Encrypt证书在nginx后面运行我们的Quart应用程序，正如我们在*第4章*，*设计Jeeves*中设置的那样。这就是为什么我们使用配置中的回调URL而不是尝试动态处理它，因为这个URL与nginx相关联。
- en: That function uses the `client_id` from the Jeeves application generated in
    Slack and returns a redirection URL we can present to the user. The dashboard
    view can be changed accordingly to pass that URL to the template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用在Slack中生成的Jeeves应用程序的`client_id`，并返回一个我们可以向用户展示的重定向URL。仪表板视图可以根据需要更改，以便将此URL传递给模板。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also pass a `user` variable if there are any stored in the session. The
    template can then use the Strava URL to display a login/logout link as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果会话中存储了任何`user`变量，我们也会传递一个`user`变量。模板可以使用Strava URL来显示登录/注销链接，如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the user clicks on the `login` link, they are redirected to Strava and
    back to our application on the endpoint, defined as `SLACK_REDIRECT_URI`. The
    implementation of that view could be like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`登录`链接时，他们会被重定向到Strava，然后返回到我们定义的`SLACK_REDIRECT_URI`端点的我们的应用程序。该视图的实现可能如下所示：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the response we get from Slack's OAuth2 service, we put the temporary
    code received into a query to convert that into a real access token. Then we can
    store the token in the session or send it to the data service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从Slack的OAuth2服务获得的响应，我们将收到的临时代码放入查询中，将其转换为真实的访问令牌。然后我们可以将令牌存储在会话中或将其发送到数据服务。
- en: We are not detailing how `Dashboard` interacts with `TokenDealer`, since we
    have already shown this in *Chapter 7*, *Securing Your Services*. The process
    is similar—the `Dashboard` app gets a token from `TokenDealer` and uses it to
    access `DataService`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不详细说明`仪表板`如何与`TokenDealer`交互，因为我们已经在*第7章*，*保护您的服务*中展示了这一点。过程是类似的——`仪表板`应用程序从`TokenDealer`获取令牌，并使用它来访问`DataService`。
- en: The last part of authentication is in the ReactJS code, as we will see in the
    next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证的最后部分在ReactJS代码中，我们将在下一节中看到。
- en: JavaScript authentication
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript身份验证
- en: 'When the `Dashboard` app performs the OAuth2 exchange with Slack, it stores
    user information in the session, which is a fine approach for the user authenticating
    on the dashboard. However, when the ReactJS UI calls the `DataService` microservice
    to display the user runs, we need to provide an authentication header. The following
    are two ways to handle this problem:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当`仪表板`应用程序与Slack执行OAuth2交换时，它在会话中存储用户信息，这对于在仪表板上进行身份验证的用户来说是一个很好的方法。然而，当ReactJS
    UI调用`DataService`微服务来显示用户跑步时，我们需要提供一个身份验证头。以下有两种处理此问题的方法：
- en: Proxy all the calls to the microservices via the Dashboard web app using the
    existing session information.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仪表板Web应用程序使用现有的会话信息代理所有对微服务的调用。
- en: Generate a JWT token for the end user, which can be stored and used against
    another microservice.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为最终用户生成一个JWT令牌，该令牌可以存储并用于另一个微服务。
- en: The proxy solution seems simplest as it removes the need to generate one token
    per user for accessing `DataService`, although that does mean that if we want
    to trace a transaction back to an individual user, we have to connect the `DataService`
    event to the frontend's list of events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代理解决方案看起来最简单，因为它消除了为访问 `DataService` 而为每个用户生成一个令牌的需求，尽管这也意味着如果我们想追踪一个交易回一个个人用户，我们必须将
    `DataService` 事件连接到前端事件列表中。
- en: Proxying allows us to hide the `DataService` from public view. Hiding everything
    behind the dashboard means we have more flexibility to change the internals while
    keeping the UI compatible. The problem then is that we are forcing all the traffic
    through the `Dashboard` service even when it is not needed. Our exposed API and
    the `Dashboard` appear, to the end user, to have different routes to the data,
    which may cause confusion. It also means that if there is an outage with the `DataService`,
    then the `Dashboard` is affected and may stop responding to any people trying
    to view the page. If the JavaScript contacts the `DataService` directly, then
    the `Dashboard` will continue operating, and notifications can be put up to let
    people know there is an ongoing problem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许我们隐藏 `DataService` 的公共视图。将所有内容隐藏在仪表板后面意味着我们在保持 UI 兼容性的同时有更多的灵活性来更改内部结构。问题在于我们正在强制所有流量通过
    `Dashboard` 服务，即使它不是必需的。对最终用户来说，我们的公开 API 和 `Dashboard` 看起来有通往数据的不同路由，这可能会引起混淆。这也意味着如果
    `DataService` 发生故障，那么 `Dashboard` 也会受到影响，可能停止对试图查看页面的人做出响应。如果 JavaScript 直接联系
    `DataService`，那么 `Dashboard` 将继续运行，并且可以发布通知让人们知道正在发生问题。
- en: This leads us strongly towards the second solution, generating a token for the
    end user for use in the React frontend. If we are already dealing tokens to the
    other microservices, the web user interface is just one of the clients. However,
    this also means that the client has a second authentication loop, as it must first
    authenticate using OAuth2, and then fetch a JWT token for internal services.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这强烈地引导我们走向第二个解决方案，为最终用户生成一个用于 React 前端的令牌。如果我们已经将令牌处理给其他微服务，那么网络用户界面只是客户端之一。然而，这也意味着客户端有一个第二个身份验证循环，因为它必须首先使用
    OAuth2 进行身份验证，然后获取 JWT 令牌用于内部服务。
- en: As we discussed in the last chapter, we can generate a JWT token once we have
    authenticated, and then use that to communicate with the other services under
    our control. The workflow is exactly the same—it simply gets called from JavaScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，一旦我们进行了身份验证，我们就可以生成一个 JWT 令牌，然后使用它来与其他受我们控制的服务进行通信。工作流程完全相同——它只是从
    JavaScript 中调用。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the fundamentals of building a ReactJS UI dashboard
    served by a Quart application. ReactJS is an excellent way to build a modern interactive
    UI in the browser, as it introduces a new syntax called JSX which speeds up JS
    execution. We also looked at how to use a toolchain, based on `npm`, and `Babel`,
    to manage JS dependencies and transpile JSX files into pure JavaScript.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Quart 应用程序提供的 ReactJS UI 仪表板的构建基础。ReactJS 是在浏览器中构建现代交互式 UI 的绝佳方式，因为它引入了一种名为
    JSX 的新语法，这可以加快 JS 执行速度。我们还探讨了如何使用基于 `npm` 和 `Babel` 的工具链来管理 JS 依赖项并将 JSX 文件转换为纯
    JavaScript。
- en: The Dashboard application uses Slack's OAuth2 API to connect users and authenticate
    them with our own service. We made the design decision to separate the `Dashboard`
    application from `DataService`, so the token is sent to the `DataService` microservice
    for storage. That token can then be used by the periodic workers as well as the
    Jeeves actions to perform tasks on behalf of the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板应用程序使用 Slack 的 OAuth2 API 连接用户，并使用我们的服务进行身份验证。我们做出了将 `Dashboard` 应用程序与 `DataService`
    分离的设计决策，因此令牌被发送到 `DataService` 微服务进行存储。该令牌然后可以被周期性工作进程以及 Jeeves 动作使用，代表用户执行任务。
- en: Lastly, the calls made to different services to build the dashboard are made
    independently of the dashboard, allowing us to focus on doing one thing well in
    each component. Our authorization service deals with all the token generation,
    and our dashboard can focus on being responsive to the viewer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构建仪表板对不同的服务进行的调用是独立于仪表板进行的，这使得我们能够专注于在各个组件中做好一件事。我们的授权服务处理所有令牌生成，而我们的仪表板可以专注于对观众做出响应。
- en: '*Figure 8.2* contains a diagram of the new architecture, which includes the
    `Dashboard` app:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.2* 包含了新架构的图表，其中包括 `Dashboard` 应用程序：'
- en: '![](img/B17108_08_02.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_08_02.png)'
- en: 'Figure 8.2: The full Jeeves microservice architecture'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：完整的 Jeeves 微服务架构
- en: You can find the full code of the `Dashboard` in the PythonMicroservices organization
    on GitHub at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上PythonMicroservices组织找到`Dashboard`的完整代码，链接为[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/).
- en: With several different Quart apps that compose it, developing an application
    like Jeeves can be a challenge when you are a developer. In the next chapter,
    we will look at packaging and running the application to make maintenance and
    upgrading much easier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它由几个不同的Quart应用组成，当您是一名开发者时，开发一个像Jeeves这样的应用程序可能是一个挑战。在下一章中，我们将探讨如何打包和运行应用程序，以便维护和升级变得更加容易。
