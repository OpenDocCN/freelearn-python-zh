- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Built-In Data Structures Part 2: Dictionaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Chapter [4](ch008_split_000.xhtml#x1-2240004), [Built-In Data
    Structures Part 1: Lists and Sets](ch008_split_000.xhtml#x1-2240004), we began
    looking at Python’s rich collection of built-in data structures. These data structures
    are sometimes called ”containers” or ”collections” because they contain a collection
    of individual items.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover the dictionary structure. A dictionary is a mapping
    from keys to values, sometimes called an associative array. It seems sensible
    to separate mappings from the two sequences – lists and sets.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also look at some more advanced topics related to how Python
    handles references to mutable collection objects. This has consequences in the
    way functions need to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes, all related to Python’s
    built-in data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Shrinking dictionaries – the pop() method and the del statement](ch009.xhtml#x1-2980002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing dictionary-related type hints](ch009.xhtml#x1-3040003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with how to create a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Creating dictionaries – inserting and updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dictionary is one kind of Python mapping. The built-in type dict provides
    a number of foundational features. There are some common variations on these features
    defined in the collections module.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe at the beginning of Chapter [4](ch008_split_000.xhtml#x1-2240004), we’ll
    use a dictionary when we have a key that we need to map the key to a given value.
    For example, we might want to map a single word to a long, complex definition
    of the word, or perhaps map some value to a count of the number of times that
    value has occurred in a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at an algorithm for locating the various stages in transaction processing.
    This relies on assigning a unique ID to each request and including that ID with
    each log record written during the transaction. Because a multi-threaded server
    may be handling a number of requests concurrently, the stages for each request’s
    transaction will be interleaved unpredictably. Reorganizing the log by request
    ID helps isolate each transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simulated sequence of log entries for three concurrent requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The lines are long, and may be wrapped haphazardly to fit within the book’s
    margins. Each line has a timestamp. The severity level is INFO for each record
    shown in the example. The next string of 20 characters is a transaction ID. This
    is followed by log information for unique to a step in the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regular expression defines the log records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This pattern captures the four fields of each log entry. For more information
    on regular expression, see the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing these lines will produce a sequence of four-tuples. The resulting object
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need to know how often each unique path is requested. This means ignoring
    some log records and collecting data from the other records. A mapping from the
    path string to a count is an elegant way to gather this data. We’ll look at how
    to implement this in detail. Later, we’ll look at some alternative implementations
    in the collections module.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a number of ways to build dictionary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: We can create a display of a dictionary by using a sequence of key/value
    pairs surrounded by {} characters. We use a : between a key and the associated
    value. Literals look like this: {"num": 355, "den": 113}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversion function: A sequence of two-tuples can be turned into a dictionary
    like this: dict([(’num’, 355), (’den’, 113)]). Each two-tuple becomes a key-value
    pair. The keys must be immutable objects like strings, numbers, or tuples of immutable
    objects. We can also build dictionaries like this: dict(num=355, den=113). Each
    of the parameter names becomes a key. This limits the dictionary keys to strings
    that are also valid Python variable names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insertion: We can use the dictionary [key] = value syntax to set or replace
    a value in a dictionary. We’ll look at this later in this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comprehensions: Similar to lists and sets, we can write a dictionary comprehension
    to build a dictionary from some source of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a dictionary by setting items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We build a dictionary by creating an empty dictionary and then setting items
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty dictionary to map paths to counts. We can also use dict() to
    create an empty dictionary. Since we’re going to create a histogram that counts
    the number of times a path is used, we’ll call it histogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also use the function dict() instead of the literal value {} to create
    an empty dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each of the log lines, filter out the ones that do not have a value that
    starts with path in the item with an index of 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the path is not in the dictionary, we need to add it. Once the value of
    the path_method string is in the dictionary, we can increment the value in the
    dictionary, based on the key from the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This technique adds each new path_method value to the dictionary. Once it has
    been established that the path_method key is in the dictionary, we can increment
    the value associated with the key.
  prefs: []
  type: TYPE_NORMAL
- en: Building a dictionary as a comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last field of each log line had one or two fields inside. There may have
    been a value like path="/openapi.yaml" method=GET with two attributes, path and
    method, or a value like error="invalid query" with only one attribute, error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following regular expression to decompose the final field of
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The findall() method of this regular expression will provide a sequence of
    two-tuples based on the matching text. We can then build a dictionary from the
    sequence of matched groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the log lines, apply the regular expression to create a sequence
    of pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a dictionary comprehension to use the first matching group as the key and
    the second matching group as the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can print the params values and we’ll see the dictionaries like the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using a dictionary for the final fields of each log record makes it easier to
    separate the important pieces of information.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core feature of a dictionary is a mapping from an immutable key to a value
    object of any kind. In the first example, we’ve used an immutable string as the
    key, and an integer as the value. We describe it as dict[str, int] in the type
    hint.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to understand how the += assignment statement works. The implementation
    of += is essentially this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The histogram[customer] value is fetched from the dictionary, a new value is
    computed, and the result is used to update the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: It’s essential that dictionary key objects be immutable. We cannot use a list,
    set, or dictionary as the key in a dictionary mapping. We can, however, transform
    a list into an immutable tuple, or make a set into a frozenset so that we can
    use one of these more complex objects as a key. In the examples shown in this
    recipe, we had immutable strings as the keys to each dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t have to use an if statement to add missing keys. We can use the setdefault()
    method of a dictionary instead. It’s even easier to use one of the classes from
    the collections module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the version using the defaultdict class from the collections module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a defaultdict instance that will initialize any unknown key values
    using the int() function. We provide int—the function object—to the defaultdict
    constructor. The defaultdict instance will evaluate the given function to create
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to use histogram[path_method] += 1\. If the value associated
    with the path_method key was previously in the dictionary, the value will be incremented
    and put back into the dictionary. If the path_method key was not in the dictionary,
    the int() function is called with no argument; this default value will be incremented
    and put into the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way we can accumulate frequency counts is by creating a Counter object.
    We can build the Counter object from the raw data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we used a generator expression to create an iterator over the filtered
    path data; this was assigned to filtered_paths. Then we created a Counter from
    the source of data; the Counter class will scan the data and count the distinct
    occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Shrinking dictionaries – the pop() method and the del statement](ch009.xhtml#x1-2980002)
    recipe, we’ll look at how dictionaries can be modified by removing items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 Shrinking dictionaries – the pop() method and the del statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use case for a dictionary is as an associative store: it keeps an
    association between key and value objects. This means that we may be doing any
    of the CRUD operations on an item in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new key and value pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the value associated with a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the value associated with a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the key (and the corresponding value) from the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great deal of processing supports the need to group items around one (or more)
    different common values. We’ll return to the log data shown in the [Creating dictionaries
    – inserting and updating](ch009.xhtml#x1-2900001) recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use an iterator algorithm that uses the transaction ID as a key in a dictionary.
    The value for this key will be the sequence of steps for the transaction. With
    a very long log, we don’t — generally — want to save every transaction in a gigantic
    dictionary. When we reach the termination of a transaction’s sequence, we can
    yield the list of log entries for the transaction. A function can consume this
    iterator, processing each batch of transactions independently.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The context for this recipe will require an if statement with the condition
    match := log_parser.match(line). This will apply the regular expression, and collect
    the result in the match variable. Given that context, the processing to update
    or delete from a dictionary is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function uses the defaultdict class, and two additional type hints, Iterable
    and Iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a defaultdict object to hold transaction steps. The keys are 20-character
    strings. The values are lists of log records. In this case, each log record will
    have been parsed from the source text into a tuple of individual strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the key for each cluster of log entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update a dictionary item with a log record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this log record completes a transaction, yield the group as part of a generator
    function. Then remove the transaction from the dictionary, since it’s complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end, there may be an non-empty requests dictionary. This reflects a transaction
    that was in process when the log file was switched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a dictionary is a mutable object, we can remove keys from a dictionary.
    A del statement will delete both the key and the value object associated with
    the key. In this example, the key is removed when the data reveals the transaction
    is complete. A moderately busy web server handling an average of 10 transactions
    per second will see 864,000 transactions in a 24-hour period. If there are an
    average of 2.5 log entries per transaction, there will be at least 2,160,000 lines
    in the file.
  prefs: []
  type: TYPE_NORMAL
- en: If we only want to know the elapsed time per resource, we don’t want to keep
    the entire dictionary of 864,000 transactions in memory. We’d rather transform
    the log into an intermediate summary file for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: This idea of transient data leads us to accumulate the parsed log lines into
    a list instance. Each new line is appended to the appropriate list for the transaction
    in which the line belongs. When the final line has been found, the group of lines
    can be purged from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example, we used the del statement. The pop() method can also be used.
    The del statement will raise a KeyError exception if the given item cannot be
    found in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pop() method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will mutate the dictionary in place, removing the item if it exists, or
    raising a KeyError exception.
  prefs: []
  type: TYPE_NORMAL
- en: The pop() method, when provided with a default value, can return the given default
    value instead of raising an exception when a key is not found. In either case,
    the key will no longer be in the dictionary. Note that this method both mutates
    the collection and returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: The popitem() method will remove a key and value pair from the dictionary. The
    pairs are returned in Last-In-First-Out (LIFO) order. This means a dictionary
    is also a kind of stack.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe, we look at how we create dictionaries and fill them with keys and values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.3 Writing dictionary-related type hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at sets and lists, we generally expect each item within a list
    (or a set) to be the same type. When we look at object-oriented class designs,
    in Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll see how a common superclass
    can be the common type for a closely related family of object types. While it’s
    possible to have heterogeneous types in a list or set collection, it often becomes
    quite complex to process, requiring the match statement to do proper type matching.
    A dictionary, however, can be used to create a discriminated union of types. A
    particular key value may be used to define which other keys are present in the
    dictionary. This means a simple if statement can discriminate between heterogeneous
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at two kinds of dictionary type hints, one for homogeneous value
    types and the other for heterogeneous value types. We’ll look at data that starts
    out as one of these kinds of dictionaries but is transformed to have more complex
    type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be starting with the following CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This describes three separate legs of a multi-day trip on a sailboat. The fuel
    is measured by the height in the tank, rather than some indirect method using
    a float or other gauges. Because the tank is approximately rectangular, 31 inches
    of depth is about 75 gallons of fuel.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial use of csv.DictReader will lead to dictionaries with homogeneous
    type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the type of the keys in the dictionary. When reading CSV files, the keys
    are strings, with the type str.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the type of the values in the dictionary. When reading CSV files, the
    values are strings, with the type str.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine the types using the dict type hint. This yields dict[str, str].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example function for reading data from a CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The get_fuel_use() function yields values that match the source data. In this
    case, it’s a dictionary that maps string column names to string cell values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This data, by itself, is difficult to work with. A common second step is to
    apply transformations to the source rows to create more useful data types. We
    can describe the results with a type hint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the various value types that will be needed. In this example, there
    are five fields with three different types, shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The date field is a datetime.date object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The engine on field is a datetime.time object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fuel height on field is an integer, but we know that it will be used in
    a float context, so we’ll create a float directly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The engine off field is a datetime.time object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fuel height off field is also a float value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the TypedDict type definition from the typing module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the subclass of TypedDict with the new heterogeneous dictionary types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is, in part, a teaser for Chapter [7](ch011_split_000.xhtml#x1-3760007).
    It shows a very simple kind of class definition. In this case, the class is dictionaries
    with five specific keys, all of which are required and must have values of the
    given types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, we’ve also renamed the fields to make them into names that
    are valid Python names. Replacing punctuation with _ is the obvious first step.
    We also changed a few because the column names in the CSV file seemed awkward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to perform the transformation can look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function consumes instances of the initial dict[str,str] dictionary and
    creates instances of the dictionary described by the History class. Here’s how
    these two functions work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This shows how the output from the get_fuel_use() function can be processed
    by the make_history() function to create an iterable sequence of dictionaries.
    Each of the resulting dictionaries has the source data converted to a more useful
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core type hint for a dictionary names the key type and the value type, in
    the form dict[key, value]. The TypedDict class lets us be more specific about
    bindings between dictionary keys and a broad domain of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that type hints are only checked by programs like mypy.
    These hints have no runtime impact. We could, for example, write a statement like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This statement claims that the result dictionary will match the type hints in
    the History type definition. The dictionary literal, however, has the wrong type
    for the ’date’ field and a number of other fields are missing. While this will
    execute, it will raise errors from mypy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the mypy program reveals the error as shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For run-time validation of data, a project like [Pydantic](https://docs.pydantic.dev/2.7/)
    can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common cases for heterogeneity in dictionary keys is optional items.
    The type hint Optional[str] or str | None describes this. This is rarely needed
    with a dictionary, since it can be simpler to omit the key-value pair entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we need two variants of the History type:'
  prefs: []
  type: TYPE_NORMAL
- en: The variant shown earlier in this recipe, where all fields are present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two ”incomplete” records, one without an engine off time and ending fuel height,
    and another variant without an engine on time or starting fuel height. These two
    records might be used for an overnight passage under power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, we might need to use the NotRequired annotation for these fields.
    The resulting class definition would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This record permits a great deal of variability in the dictionary values. It
    requires the use of if statements to determine the mix of fields present in the
    data. Furthermore, it also requires somewhat more clever processing in the make_history()
    function to create these variant records based on empty columns in the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: There are some parallels between TypedDict and the NamedTuple type definitions.
    Changing TypedDict to NamedTuple will create a named tuple class instead of a
    typed dictionary class.
  prefs: []
  type: TYPE_NORMAL
- en: Because a NamedTuple class has an _asdict() method, it’s possible to produce
    a dictionary that matches the TypedDict structure from a named tuple.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary that matches the TypedDict hint is mutable. A subclass of NamedTuple,
    however, is immutable. This is one central difference between these two type hints.
    More importantly, a dictionary uses row[’date’] syntax to refer to one item using
    the key ’date’. A named tuple uses row.date syntax to refer to one item using
    a name.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)
    recipe provides more details on the NamedTuple type hint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004) for more about type hints
    for lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009) recipe,
    also in Chapter [4](ch008_split_000.xhtml#x1-2240004), covers this from the view
    of set types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For runtime validation of data, a project like Pydantic can be very helpful.
    See [https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.4 Understanding variables, references, and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do variables really work? What happens when we assign a mutable object to
    two variables? When two variables are sharing references to a common mutable object,
    the behaviors can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the core principle: Python shares references; it doesn’t copy data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what this rule on reference sharing means, we’ll create two data structures:
    one is mutable and one is immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at the two kinds of sequences, although we could do something similar
    with two kinds of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look at what happens when references to these objects are shared.
  prefs: []
  type: TYPE_NORMAL
- en: We can do a similar comparison with a set and a frozenset. We can’t easily do
    this with a mapping because Python doesn’t offer a handy immutable mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will show how to observe the ”spooky action at a distance” when
    there are two references to an underlying mutable object. We’ll look at ways to
    prevent this in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe. Here are the steps for seeing the difference between mutable and immutable
    collections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign each collection to an additional variable. This will create two references
    to the structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have two references to the list [1, 1, 2, 3, 5, 8] and two references
    to the tuple (5, 8, 13, 21).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can confirm this using the is operator. This determines if two variables
    refer to the same underlying object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a change to one of the two references to the collection. For the list
    type, we have methods like extend() or append(). For this example we’ll use the
    + operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can do a similar thing with the immutable structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the other two variables that reference the mutable structure. Because
    the two variables are references to the same underlying list object, each variable
    shows the current state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look at the two variables referring to immutable structures. Initially, the
    two variables shared a common object. When the assignment statement was executed,
    a new tuple was created and only one variable changed to refer to the new tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 5.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two variables, mutable and mutable_b, still refer to the same underlying
    object. Because of that, we can use either variable to change the object and see
    the change reflected in the other variable’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The two variables, immutable_b and immutable, started out referring to the same
    object. Because the object cannot be mutated in place, a change to one variable
    means that a new object is assigned to that variable. The other variable remains
    firmly attached to the original object.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, a variable is a label that’s attached to an object. We can think
    of them like adhesive notes in bright colors that we stick on an object temporarily.
    Multiple labels can be attached to an object. It’s the assignment statement that
    places a variable name on an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the same effect as this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The expression on the right side of = creates a new tuple from the previous
    value of the immutable tuple. The assignment statement then assigns the label
    immutable to the newly-minted object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning to a variable has two possible actions:'
  prefs: []
  type: TYPE_NORMAL
- en: For mutable objects that provide definitions for appropriate in-place assignment
    operators like +=, the assignment is transformed into a special method; in this
    case, __iadd__(). The special method will mutate the object’s internal state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For immutable objects that do not provide definitions for assignment like +=,
    the assignment is transformed into = and +. A new object is built by the + operator
    and the variable name is attached to that new object. Other variables that previously
    referred to the object being replaced are not affected; they will continue to
    refer to old objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python counts the number of places from which an object is referenced. When
    the count of references becomes zero, the object is no longer used anywhere and
    can be removed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some languages have primitive types in addition to objects. In these languages,
    a += statement may leverage a feature of the hardware instructions to tweak the
    value of a primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python doesn’t have this kind of optimization. Numbers are immutable objects;
    there are no special instructions to tweak their values. Consider the following
    assignment statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The processing does not tweak the internal state of the object 355\. The int
    class does not provide an __iadd__() special method. A new immutable integer object
    is created. This new object is given the label a. The old value previously assigned
    to a is no longer needed, and the storage can be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005) recipe,
    we’ll look at ways we can copy mutable structures to prevent shared references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, see [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    for another consequence of the way references are shared in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the CPython implementation, a few objects can be immortal. See [PEP 683](https://peps.python.org/pep-0683/)
    for more on this implementation detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.5 Making shallow and deep copies of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve talked about how assignment statements share
    references to objects. Objects are not normally copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This creates two references to the same underlying object. If the value of the
    b variable has a mutable type, like the list, set, or dict types, then a change
    using either a or b will update the underlying mutable object. For more background,
    see the [Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this is the behavior we want. This is ideal for providing
    mutable objects to functions and having a local variable in the function mutate
    an object created outside the function. There are rare situations in which we
    want to actually have two independent objects created from one original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to break the connection that exists when two variables are
    references to the same underlying object:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a shallow copy of the structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a deep copy of the structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python does not automatically make a copy of an object. We’ve seen several
    kinds of syntax for making a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequences – list, as well as the str, bytes, and tuple types: we can use sequence[:]
    to copy a sequence by using an empty slice expression. This is a special case
    for sequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all collections have a copy() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a type, with an instance of the type as the only argument, returns a
    copy. For example, if d is a dictionary, dict(d) will create a shallow copy of
    d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s important is that these are all shallow copies. When two collections
    are shallow copies, they each contain references to the same underlying objects.
    If the underlying objects are immutable, such as tuples, numbers, or strings,
    this distinction doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a = [1, 1, 2, 3], we can’t perform any mutation on a[0].
    The number 1 in a[0] has no internal state. We can only replace the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions arise, however, when we have a collection that involves mutable objects.
    First, we’ll create an object, then we’ll create a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This example created a shallow copy of the dictionary. The two copies will
    look alike because they both contain references to the same objects. There’s a
    shared reference to the immutable string ’a’ and a shared reference to the mutable
    list [1, 1, 2, 3]. We can display the value of another_dict to see that it looks
    like the some_dict object we started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what happens when we update the shared list that’s inside the copy of
    the dictionary. We’ll change the value of some_dict and see the results are also
    present in another_dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the item is shared by using the id() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Because the two id() values are the same, these are the same underlying object.
    The value associated with the key ’a’ is the same mutable list in both some_dict
    and another_dict. We can also use the is operator to see that they’re the same
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mutation of a shallow copy works for list collections that contain all
    other mutable object types as items as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Because we can’t make a set of mutable objects, we don’t really have to consider
    making shallow copies of sets that share items.
  prefs: []
  type: TYPE_NORMAL
- en: A tuple can contain mutable objects. While the tuple is immutable, the objects
    inside it are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: The immutability of a tuple does not magically propagate to the items within
    the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to completely disconnect two copies? How do we make a deep copy
    instead of a shallow copy?
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python generally works by sharing references. It makes copies of objects reluctantly.
    The default behavior is to make a shallow copy, sharing references to the items
    within a collection. Here’s how we make deep copies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the copy module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the copy.deepcopy() function to duplicate an object and all of the mutable
    items contained within that object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create copies that have no shared references. A change to one copy’s
    mutable internal items won’t have any effect anywhere else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated an item in some_dict and it had no effect on the copy in another_dict.
    We can see that the objects are distinct with the id() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Since the id() values are different, these are distinct objects. We can also
    use the is operator to see that they’re distinct objects.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making a shallow copy is relatively easy. We can even write our own version
    of the algorithm using comprehensions (containing generator expressions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the list case, the items for the new list are references to the items in
    the source list. Similarly, in the dict case, the keys and values are references
    to the keys and values of the source dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The deepcopy() function uses a recursive algorithm to look inside each item
    that’s a mutable collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an object with a list type, the conceptual algorithm is something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This can be used for the collection of types used in JSON documents. For the
    immutable types in the first case clause, there’s no need to make a copy; an object
    of one of these types cannot be mutated. For the two mutable types used in JSON
    documents, empty structures are built, and then copies of each item are inserted.
    The processing involves recursion to assure that — no matter how deeply nested
    — all items that are mutable are copied.
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of the deepcopy() function handles additional types,
    not part of the JSON specification. The point of this example is to show the general
    idea of a deep copy function.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)
    recipe, we look at how Python prefers to create references to objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.6 Avoiding mutable default values for function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter [3](ch007_split_000.xhtml#x1-1610003), we looked at many aspects
    of Python function definitions. In the [Designing functions with optional parameters](ch007_split_000.xhtml#x1-1680002)
    recipe, we showed a recipe for handling optional parameters. At the time, we didn’t
    dwell on the issue of providing a reference to a mutable structure as a default.
    We’ll take a close look at the consequences of a mutable default value for a function
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s imagine a function that either creates or updates a mutable Counter object.
    We’ll call it gather_stats().
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, a small data gathering function could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows a bad design for a function. It has two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first scenario offers no argument value for the summary parameter. When
    this is omitted, the function creates and returns a collection of statistics.
    Here’s the example of this story:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second scenario allows us to provide an explicit argument value for the
    summary parameter. When this argument is provided, this function updates the given
    object. Here’s an example of this story:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve set the random number seed to be sure that the two sequences of random
    values are identical. We provided a Counter object to confirm that the results
    are identical.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The problem arises when we do the following operation after the first scenario
    shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The values in this example are incorrect. They’re doubled. Something has gone
    wrong. This only happens when we use the default scenario more than once. This
    code can pass a simple unit test suite and appear correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe, Python prefers to share references. A consequence of that sharing is the
    object referenced by the s1 variable and the object referenced by the s3b variable
    are the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This means the value of the object referred to by the s1 variable changed when
    the object for the s3b variable was created. From this, it should be apparent
    the function is updating a single, shared collection object and returning the
    reference to the shared collection.
  prefs: []
  type: TYPE_NORMAL
- en: The default value used for the summary parameter of this gather_stats_bad()
    function leads to result values built from a single, shared object. How can we
    avoid this?
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two approaches to solving this problem of a mutable default parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide an immutable default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at the immutable default first. Changing the design is generally
    a better idea. In order to see why it’s better to change the design, we’ll show
    a purely technical solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we provide default values for functions, the default object is created
    exactly once and shared forever after. Here’s the alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace any mutable default parameter value with None:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an if statement to check for an argument value of None and replace it with
    a fresh, new mutable object of the proper type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will assure us that every time the function is evaluated with no argument
    value for a parameter, we create a fresh, new mutable object. We will avoid sharing
    a single mutable object over and over again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noted earlier, Python prefers to share references. It rarely creates copies
    of objects without explicit use of the copy module or the copy() method of an
    object. Therefore, default values for function parameter values will be shared
    objects. Python does not create fresh, new objects for default parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Never use mutable defaults for default values of function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a mutable object (for example, set, list, or dict) as a default,
    use None.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, we should consider changing the design to not offer a default
    value at all. Instead, define two separate functions. One function updates a parameter
    value, and a second function uses this function but provides a fresh, empty mutable
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, they might be called create_stats() and update_stats(), with
    unambiguous parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the summary parameter to the update_stats() function is not optional.
    Similarly, there is no summary object parameter defined for the create_stats()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of optional mutable arguments was not a good idea because the mutable
    object provided as a default value for a parameter is reused.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the standard library, there are some examples of a cool technique that shows
    how we can create fresh default objects. A number of places use a factory function
    as a parameter. This function can be used to create a fresh, new mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to leverage this design pattern, we need to modify the design of our
    update_stats() function. We will no longer update an existing Counter object in
    the function. We’ll always create a fresh, new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that calls a factory function to create a useful default
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: For this version, we’ve defined the Summarizer type to be a function of one
    argument that will create a Counter object. The default value uses the Counter
    class as the one-argument function. We can override the summary_func function
    with any one-argument function that will collect details instead of summarizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using list instead of collections.Counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we provided the list function to create a list with the individual
    random samples in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example without an argument value. It will create a new collections.Counter
    object each time it’s used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ve evaluated the function using the default value for summary_func,
    which creates a collections.Counter object from the random samples.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the Creating dictionaries – inserting and updating recipe, which shows how
    the defaultdict collection works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
