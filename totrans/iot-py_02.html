<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Working with Python on Intel Galileo Gen 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Python on Intel Galileo Gen 2</h1></div></div></div><p>In this chapter, we will start our journey towards Internet of Things (IoT) with Python and the Intel Galileo Gen 2 board. We shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set up the environment to start working with Python as the main programming language</li><li class="listitem" style="list-style-type: disc">Retrieve the board's assigned IP address after it boots a Yocto Linux distribution</li><li class="listitem" style="list-style-type: disc">Connect to the board's operating system and run commands on it</li><li class="listitem" style="list-style-type: disc">Install and upgrade the necessary libraries to interact with the board's component with Python</li><li class="listitem" style="list-style-type: disc">Run our first lines of Python code in the board</li></ul></div><div class="section" title="Setting up the board to work with Python as the programming language"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Setting up the board to work with Python as the programming language</h1></div></div></div><p>There<a id="id53" class="indexterm"/> is some work to be done in order to start working with Python as the main programming language to control this board. We need the following additional elements that aren't included in the board's box:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A microSD card of at least 4 GB with a maximum supported capacity of 32 GB. It is convenient to use a speed class 4 or a faster microSD card. Note that you will lose all the contents of the microSD card.</li><li class="listitem" style="list-style-type: disc">A microSD to SD memory card adapter. The adapter is usually included within a microSD card's package.</li><li class="listitem" style="list-style-type: disc">A computer with an SD memory card reader. Most modern laptops and desktop computers include SD mermory card readers. However, in case you don't have one, you can buy a USB SD memory card reader and plug it to a free USB port in your computer. SD memory card readers are in fact read/write devices, and therefore, we can use them to write to a microSD card via <a id="id54" class="indexterm"/>the microSD to SD memory card adapter.</li><li class="listitem" style="list-style-type: disc">An Ethernet cable.</li><li class="listitem" style="list-style-type: disc">An Ethernet switch or a WiFi router with a free Ethernet port. You will connect the Intel Galileo Gen 2 board to your LAN.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>In case you do not have access to your LAN's switch, you will have to ask your network administrator for advice.</p></div></div><p>The next picture shows an 8 GB speed class 4 microSD card labeled <span class="strong"><strong>SDC4/8GB</strong></span> (left) and a microSD to SD memory card adapter (right).</p><div class="mediaobject"><img src="images/B05042_02_01.jpg" alt="Setting up the board to work with Python as the programming language"/></div><p>We have <a id="id55" class="indexterm"/>to download the latest version of the Yocto Linux meta distribution boot image from<a id="id56" class="indexterm"/> the Intel IoT Development Kit Images Repository website. Open <a class="ulink" href="http://iotdk.intel.com/images/">http://iotdk.intel.com/images/</a> in your Web browser and download the <code class="literal">iot-devkit-latest-mmcblkp0.direct.bz2</code> compressed file with the boot image listed on the Web page. You can also download it by entering the full URL in your Web browser: <a class="ulink" href="http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2">http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>We will use the <code class="literal">devkit-latest-mmcblkp0.direct.bz2</code> file, last modified on July 2, 2015. Make sure that you don't download any version releases sooner than this date because there are many differences in the package names used in previous releases that aren't compatible with the instructions provided later on in this chapter.</p></div></div><p>Once you have downloaded the file, it is necessary to decompress the downloaded image file and write the extracted image to the microSD card. The procedure is different in Windows and Mac OS X.</p><p>In Windows, you can use 7-Zip to extract the contents from the downloaded <code class="literal">.bz2</code> file. 7-Zip is a free <a id="id57" class="indexterm"/>and open source software that you can download from <a class="ulink" href="http://www.7-zip.org">http://www.7-zip.org</a>.</p><p>Once you extract the Yocto Linux meta distribution boot image <code class="literal">iot-devkit-latest-mmcblkp0.direct</code> from the <code class="literal">.bz2</code> file, you have to write this image to the microSD card. Insert the microSD card into the microSD to SD memory card adapter and insert the adapter into the computer's SD memory card reader.</p><p>The <a id="id58" class="indexterm"/>Win32 Disk Imager tool is an image writer for Windows that allows us to write images to USB sticks or SD/CF cards. You can use this free software to write the image to the microSD card. You can download it from <a class="ulink" href="http://sourceforge.net/projects/win32diskimager/files/Archive">http://sourceforge.net/projects/win32diskimager/files/Archive</a>. The installer for the latest version is the <code class="literal">Win32DiskImager-0.9.5-install.exe</code> file. Once you install the software, take into account that you must execute the application as an administrator in Windows. You can right-click on the application's icon and select <span class="strong"><strong>Run as administrator</strong></span>.</p><p>Click on the icon on the right-hand side of the <span class="strong"><strong>Image File</strong></span> textbox and change the files filter from <span class="strong"><strong>Disk Images (*.img *.IMG)</strong></span> to <span class="strong"><strong>*.*</strong></span> so that you can select the Yocto Linux boot image with a <span class="strong"><strong>direct</strong></span> extension.</p><p>Select the drive letter that Windows assigned to the microSD card in the <span class="strong"><strong>Device</strong></span> dropdown.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Make sure that you select the right drive letter because all the contents for the drive will be erased and overwritten with the boot image. If you select the incorrect drive letter, you will lose the contents of the entire drive.</p></div></div><p>Click on <span class="strong"><strong>Write</strong></span> and then click on <span class="strong"><strong>Yes</strong></span> in the confirm overwrite dialog box. Now, wait until the tool finishes writing the contents to the microSD card. The following screenshot shows the <span class="strong"><strong>Win32 Disk Imager</strong></span> tool displaying the progress while it writes the image to the microSD card in Windows 10.</p><div class="mediaobject"><img src="images/B05042_02_02.jpg" alt="Setting up the board to work with Python as the programming language"/></div><p>It will <a id="id59" class="indexterm"/>take a few minutes until the tool finishes writing the image to the microSD card. Once the writing process has finished, the tool will display a <span class="strong"><strong>Complete</strong></span> dialog box with a <span class="strong"><strong>Write successful</strong></span> message. Click on <span class="strong"><strong>OK</strong></span> to close the dialog box and close the Win32 Disk Imager window.</p><p>Eject the microSD card in Windows and then remove the SD memory card adapter from the SD card reader.</p><p>In Mac OS X and Linux, you can use <code class="literal">bunzip2</code> to extract the contents from the downloaded <span class="strong"><strong>bz2</strong></span> file, <code class="literal">diskutil</code> to unmount the microSD card, and <code class="literal">dd</code> to write the image to the microSD card. It is also possible to open a <span class="strong"><strong>Terminal</strong></span> and unzip the downloadeded bz2 file by running the following command in the folder in which you downloaded the file:</p><div class="informalexample"><pre class="programlisting">bunzip -c iot-devkit-latest-mmcblkp0.direct</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>You need to be very careful with the commands to avoid erasing a wrong device such as a partition of your hard drive.</p></div></div><p>It is also possible to unzip the downloaded bz2 file by double-clicking on it on Finder. However, we will be running more commands in the <span class="strong"><strong>Terminal</strong></span> window, and therefore, it is easier to start unzipping the file with a command.</p><p>Once you extract the Yocto Linux boot image <code class="literal">iot-devkit-latest-mmcblkp0.direct</code> from the bz2 file, you have to write this image to the microSD card. Insert the microSD card into the microSD to SD memory card adapter and then insert the adapter into the computer's SD memory card reader. Launch the <span class="strong"><strong>Disk Utility</strong></span> application and check the details for<a id="id60" class="indexterm"/> the media connected to the card reader. For example, in any MacBook laptop, you will find the info by clicking on <span class="strong"><strong>APPLE SD Card Reader Media</strong></span> and then on the <span class="strong"><strong>Info</strong></span> button. Check the name listed in <span class="strong"><strong>Device name</strong></span> or <span class="strong"><strong>BSD device node</strong></span>. We will use this name in a command that will write the boot image to the microSD card. The following picture shows the <span class="strong"><strong>Disk Utility</strong></span> application and the information for a microSD card whose device name is <span class="strong"><strong>disk2</strong></span>. We just need to add <code class="literal">/dev/</code> as a prefix to the gathered device name, and therefore, in this sample case, the complete name is <code class="literal">/dev/disk2</code>.</p><div class="mediaobject"><img src="images/B05042_02_03.jpg" alt="Setting up the board to work with Python as the programming language"/></div><p>It is also<a id="id61" class="indexterm"/> possible to gather the information by running the <code class="literal">diskutil</code> command to list all the devices and find out the device name assigned to the microSD card. However, the information provided by this command is a bit difficult to read and the <span class="strong"><strong>Disk Utility</strong></span> application makes it easy to understand which is the device name for the memory card reader. The following command lists all the devices:</p><div class="informalexample"><pre class="programlisting">diskutil list</pre></div><p>The following is the sample output generated by this command. The highlighted lines show the device name for the microSD card: <code class="literal">/dev/disk2</code>.</p><div class="informalexample"><pre class="programlisting">/dev/disk0 (internal, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        *121.3 GB   disk0
   1:                        EFI EFI                     209.7 MB   disk0s1
   2:          Apple_CoreStorage Macintosh HD            120.5 GB   disk0s2
   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3
/dev/disk1 (internal, virtual):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:                  Apple_HFS Macintosh HD           +120.1 GB   disk1
                                 Logical Volume on disk0s2
                                 4BADDDC3-442C-4E75-B8DC-82E38D8909AD
                                 Unencrypted
<span class="strong"><strong>/dev/disk2 (internal, physical):</strong></span>
<span class="strong"><strong>   #:                       TYPE NAME                    SIZE       IDENTIFIER</strong></span>
<span class="strong"><strong>   0:     FDisk_partition_scheme                        *7.7 GB     disk2</strong></span>
<span class="strong"><strong>   1:                      Linux                         53.5 MB    disk2s1</strong></span>
<span class="strong"><strong>   2:                      Linux                         1.4 GB     disk2s2</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>Make sure that you take note of the right device name because all the contents for the drive will be erased and overwritten with the boot image. If you specify a wrong device name, you will lose the contents of the entire drive.</p></div></div><p>Unmount <a id="id62" class="indexterm"/>the microSD card with the following command. You need to replace <code class="literal">/dev/devicename</code> with <code class="literal">/dev/disk2</code> in case the device name you gathered was <code class="literal">disk2</code>. If not, replace it with the appropriate device name.</p><div class="informalexample"><pre class="programlisting">sudo diskutil unmountDisk /dev/devicename</pre></div><p>The <span class="strong"><strong>Terminal</strong></span> will ask for your password and will unmount the microSD card. Run the following <code class="literal">dd</code> command to write the image in the input file named <code class="literal">iot-devkit-latest-mmcblkp0.direct</code> to the microSD card in the device name you gathered in the previous step. You need to replace <code class="literal">of=/dev/devicename</code> with <code class="literal">of=/dev/disk2</code> in case the device name you gathered was <code class="literal">disk2</code>. If not, replace it with the appropriate device name. The command doesn't include a device name so that you don't overwrite any of your disks by accident.</p><div class="informalexample"><pre class="programlisting">sudo dd if=iot-devkit-latest-mmcblkp0.direct of=/dev/devicename bs=8m</pre></div><p>Then, it <a id="id63" class="indexterm"/>will take some time to write the image to the microSD card. Wait until the command finishes and the <code class="literal">Terminal</code> displays the prompt again. Notice that it usually takes a few minutes and there is no output with any progress indication until the write process finishes. You will see the following output after the command finishes:</p><div class="informalexample"><pre class="programlisting">169+1 records in
169+1 records out
1417675776 bytes transferred in 1175.097452 secs (1206433 bytes/sec)</pre></div><p>Now, unmount the microSD card with the following command. You need to replace <code class="literal">/dev/devicename</code> with <code class="literal">/dev/disk2</code> in case the device name you gathered was <code class="literal">disk2</code>. If not, replace it with the appropriate device name.</p><div class="informalexample"><pre class="programlisting">sudo diskutil unmountDisk /dev/devicename</pre></div><p>Close the terminal window and then remove the SD memory card adapter from the SD card reader.</p><p>Now, we have a microSD card with a Yocto Linux distribution that includes Python 2.7.3 and many useful libraries and utilities. It is time to make the Intel Galileo Gen 2 board boot from the Yocto image written to the microSD card.</p><p>Make sure that the board is unplugged and place the microSD card with the Yocto image in the microSD card slot on the board, labeled <span class="strong"><strong>SDIO</strong></span>. The following picture shows a microSD card inserted in the slot on the board.</p><div class="mediaobject"><img src="images/B05042_02_04.jpg" alt="Setting up the board to work with Python as the programming language"/></div><p>Then, connect <a id="id64" class="indexterm"/>the board to your LAN with the Ethernet cable and plug the board's power supply to turn on the board and start it up. You will notice that the rectangular onboard LED labeled <span class="strong"><strong>SD</strong></span> indicates that there is activity with the microSD card. Wait for approximately 30 seconds to make sure that the board finishes the boot process. You will notice that the LED labeled <span class="strong"><strong>SD</strong></span> stops blinking after the boot process finishes.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Retrieving the board's assigned IP address"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Retrieving the board's assigned IP address</h1></div></div></div><p>The <a id="id65" class="indexterm"/>board has finished the boot process with the Yocto Linux microSD card and is connected to our LAN throught the Ethernet port. The DHCP server has assigned the board an IP address and we need to know it in order to run commands on a Yocto Linux console. There are many ways for us to retrieve the board's assigned IP address. We will explore the different options and you can choose the most convenient one based on your LAN configuration.</p><p>If the board is connected to one of the Ethernet ports of a Wireless router and we have access to the router's Web interface, we can easily know the IP address assigned to the board. Some router's Web interfaces display the wired clients list. As our board is connected through an Ethernet wire, it will be listed as one of the wired clients and the device MAC <a id="id66" class="indexterm"/>address will match the MAC address printer in the adhesive label on the board's Ethernet jacket. The following picture shows the Wired-clients list in a router's Web interface and the list includes a device named <span class="strong"><strong>galileo</strong></span> with <span class="strong"><strong>A1-B2-C3-D4-E5-F6</strong></span> as the MAC address that matches the MAC address printed without hyphens (-) in the board: <span class="strong"><strong>A1B2C3D4E5F6</strong></span>. The IP address assigned to the board is <span class="strong"><strong>192.168.1.104</strong></span>. For security reasons, the original MAC address has been erased and we are using a fake MAC address for our example.</p><div class="mediaobject"><img src="images/B05042_02_05.jpg" alt="Retrieving the board's assigned IP address"/></div><p>Sometimes, the router's Web interface doesn't provide an option that displays the wired clients list. If this is the case for our router, we will always be able to retrieve the DHCP client list that provides all the IP addresses assigned to either the wireless or wired devices connected to the LAN. We just need to find the device that has the MAC address for the board. The following picture shows the DHCP Client List in a router's Web interface and the list includes a device named <span class="strong"><strong>galileo</strong></span> with <span class="strong"><strong>A1-B2-C3-D4-E5-F6</strong></span> as the MAC address that matches the MAC address printed without hyphens (-) in the board: <span class="strong"><strong>A1B2C3D4E5F6</strong></span>. The IP address assigned to the board is <span class="strong"><strong>192.168.1.104</strong></span>.</p><div class="mediaobject"><img src="images/B05042_02_06.jpg" alt="Retrieving the board's assigned IP address"/></div><p>Another <a id="id67" class="indexterm"/>option is to install a Bonjour Browser to discover the board and its services on the LAN automatically through this zero-configuration networking implementation, without knowing the IP assigned to the board.</p><p>In Windows, download, install, and launch the <a id="id68" class="indexterm"/>free Bonjour Browser for Windows from <a class="ulink" href="http://hobbyistsoftware.com/bonjourbrowser">http://hobbyistsoftware.com/bonjourbrowser</a>. The application will display many available Bonjour services with <span class="strong"><strong>galileo</strong></span> as their name. The following screenshot shows the <span class="strong"><strong>_ssh._tcp</strong></span> service type with <span class="strong"><strong>galileo</strong></span> as its name selected with the details. The <span class="strong"><strong>IP Adresses</strong></span> section shows the IP address and the port number for the SSH service: <span class="strong"><strong>192.168.1.105:22</strong></span>. We can use the IP address with any SSH client to connect to the board. In addition, the Bonjour browser lets us know that the board has an SFTP service that will make it easy for us to transfer files from and to the Yocto Linux running on the board.</p><div class="mediaobject"><img src="images/B05042_02_07.jpg" alt="Retrieving the board's assigned IP address"/></div><p>In OS X, download<a id="id69" class="indexterm"/> and run the free <a id="id70" class="indexterm"/>Bonjour Browser from <a class="ulink" href="http://www.tildesoft.com">http://www.tildesoft.com</a>. You can click on <span class="strong"><strong>Reload Services</strong></span> to refresh the discovered devices and their services. The following picture shows a board and its services listed in the Bonjour Browser. You have to click on each right-arrow to expand the details for each listed service. In this case, all the services are provided by the same device named <span class="strong"><strong>galileo</strong></span>. Once you expand the device, the application displays the IPv4 and IPv6 addresses. The <span class="strong"><strong>SSH (_ssh._tcp.)</strong></span> service type lists a device with <span class="strong"><strong>galileo</strong></span> as its name and with <span class="strong"><strong>192.168.1.105:22 </strong></span>as the IPv4 address and the port number. We can use the IP address with any SSH client to connect to the board. The Bonjour Browser also displays the details for the SFTP service.</p><div class="mediaobject"><img src="images/B05042_02_08.jpg" alt="Retrieving the board's assigned IP address"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>SSH stands for Secure Shell Protocol and its default port is 22. Yocto Linux runs the SSH server in the default port, and therefore, there is no need to specify the port in SSH clients, we can just specify the discovered IP address.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Connecting to the board's operating system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Connecting to the board's operating system</h1></div></div></div><p>Now, we <a id="id71" class="indexterm"/>need to use an SSH client to connect to the Yocto Linux running on the board and update some libraries that we will use to interact with the board's components and features. Both OS X and Linux include the <code class="literal">ssh</code> command in the Terminal. However, Windows doesn't include an <code class="literal">ssh</code> command and we have to install an SSH client.</p><p>In Windows, we can use the free and open source PuTTY SSH and telnet client. However, if you have any other preference for an SSH client in Windows, you can use any other software. The commands we execute in the terminal will be the same no matter what SSH client we use.</p><p>We can download and install <a id="id72" class="indexterm"/>PuTTY in Windows from <a class="ulink" href="http://www.putty.org">http://www.putty.org</a> or <a class="ulink" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</a>. Once you install it, launch it and make sure you allow Windows firewall or any other installed firewall to open the necessary ports to make the connections. You will see warnings popping up depending on the firewall software that is running on Windows.</p><p>After <a id="id73" class="indexterm"/>you launch PuTTY, the application will display the <span class="strong"><strong>PuTTY Configuration</strong></span> dialog box. Enter the IP address assigned to your board in the <span class="strong"><strong>Host Name (or IP address)</strong></span> textbox and leave the <span class="strong"><strong>Port</strong></span> value to its default <span class="strong"><strong>22</strong></span> value. The following picture shows the dialog box with the settings to connect to the board whose assigned IP is <span class="strong"><strong>192.168.1.105</strong></span>. You can leave the default settings. However, you should definitely change the <span class="strong"><strong>Window | Appearance</strong></span> settings to change the default font.</p><div class="mediaobject"><img src="images/B05042_02_09.jpg" alt="Connecting to the board's operating system"/></div><p>Click on <span class="strong"><strong>Open</strong></span> and the first time you want to establish a connection; PuTTY will display a security alert because the server's host key is not cached in the registry. You trust your board and the <a id="id74" class="indexterm"/>Yocto Linux that is running on it, and therefore, just click on <span class="strong"><strong>Yes</strong></span>. The following picture shows the security alert.</p><div class="mediaobject"><img src="images/B05042_02_10.jpg" alt="Connecting to the board's operating system"/></div><p>PuTTY will display a new window, specifically a terminal window, with the IP address included in the title. You will see the following message asking you to enter the login user.</p><div class="informalexample"><pre class="programlisting">login as:</pre></div><p>Enter <span class="strong"><strong>root</strong></span> and press <span class="emphasis"><em>Enter</em></span>. You will login as the <code class="literal">root</code> user that doesn't require a password in the Yocto Linux default configuration. Now, you can run any shell commands. For example, you can enter the following command to check the installed python version:</p><div class="informalexample"><pre class="programlisting">python --version</pre></div><p>The following picture shows a PuTTY terminal window with the results of logging in as root and running a few commands:</p><div class="mediaobject"><img src="images/B05042_02_11.jpg" alt="Connecting to the board's operating system"/></div><p>In OS X <a id="id75" class="indexterm"/>and Linux, you can open a <span class="strong"><strong>Terminal</strong></span> and run the <code class="literal">ssh</code> command to connect to the Yocto Linux running on the board. You have to enter <code class="literal">ssh</code> followed by a space, the user name, an arrow (@), and the IP. In this case, we want to connect with root as the user name, and therefore, we will enter <code class="literal">ssh</code> followed by a space, <code class="literal">root@</code>, and then the IP address. The following command works with the board that is running the SSH server in the <code class="literal">192.168.1.105</code> IP address and port number 22. You have to replace <code class="literal">192.168.1.105</code> with the IP address you retrieved.</p><div class="informalexample"><pre class="programlisting">ssh root@192.168.1.105</pre></div><p>The first time you want to establish a connection, the <code class="literal">ssh</code> command will display a security alert because the authenticity of the host can't be established. You trust your board and the Yocto Linux that is running on it, and therefore, answer <span class="strong"><strong>yes</strong></span> to a question that will be similar to the following one and press <span class="emphasis"><em>Enter</em></span>.</p><div class="informalexample"><pre class="programlisting">The authenticity of host '192.168.1.105 (192.168.1.105)' can't be established.
ECDSA key fingerprint is SHA256:Ln7j/g1Np4igsgaUP0ujFC2PPcb1pnkLD8Pk0AK+Vow.
Are you sure you want to continue connecting (yes/no)?</pre></div><p>The <code class="literal">ssh</code> command will display a message similar to the following line after you answer <span class="strong"><strong>yes</strong></span> and press <span class="emphasis"><em>Enter</em></span>:</p><div class="informalexample"><pre class="programlisting">Warning: Permanently added '192.168.1.105' (ECDSA) to the list of known hosts.</pre></div><p>You will log in as the <code class="literal">root</code> user that does not require a password in the Yocto Linux default configuration. Now, you can run any shell command. For example, you can enter the following command to check the installed Python version.</p><div class="informalexample"><pre class="programlisting">python --version</pre></div><p>Notice that <a id="id76" class="indexterm"/>while you see the following prompt <span class="strong"><strong>root@galileo:~#</strong></span>, it means that all your commands are running on the Yocto Linux on the board and not on your OS X Terminal or your Linux Terminal. The following picture shows an OS X <span class="strong"><strong>Terminal</strong></span> window with the results of logging in as <code class="literal">root</code> and running a few commands:</p><div class="mediaobject"><img src="images/B05042_02_12.jpg" alt="Connecting to the board's operating system"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>The Yocto Linux that the board has booted includes Python 2.7.3 pre-installed.</p></div></div><p>We can also run any SSH client in a mobile device such as a tablet or smartphone. There are many SSH clients developed for iOS and Android. It is possible to work with a tablet and a <a id="id77" class="indexterm"/>Bluetooth keyboard linked to it and easily run the commands in the SSH client.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Installing and upgrading the necessary libraries to interact with the board"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Installing and upgrading the necessary libraries to interact with the board</h1></div></div></div><p>Now, we will<a id="id78" class="indexterm"/> run many commands in the SSH client. Make sure that your SSH client is connected to the Yocto Linux SSH server running on the board as explained in the preceding section before running the commands. Specially, if you <a id="id79" class="indexterm"/>are working with either OS X or Linux, you have to make sure that you don't run the commands on your computer instead of doing this on the remote shell. Its simple, just make sure you always see the prompt <span class="strong"><strong>root@galileo:~#</strong></span> before running any command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>Your board should be connected to a LAN with Internet access because we will download content from the Internet.</p></div></div><p>We will use the <code class="literal">opkg</code> utility to download and install the updated version of both the <code class="literal">mraa</code> and <code class="literal">upm</code> libraries. The <code class="literal">mraa</code> library, also known as <code class="literal">libmraa</code>, is a low level C/C++ library with bindings to Python that allows us to interface with the I/O features on the Intel Galileo Gen 2 board and other supported platforms. The <code class="literal">upm</code> library provides high-level interfaces for sensors and actuators that we can plug to the platforms supported by the <code class="literal">mraa</code> library. The <code class="literal">upm</code> library simplifies working with sensors and actuators and includes bindings to Python. We will be working with both libraries in the forthcoming chapters, and therefore, we want to have their latest versions installed.</p><p>The <code class="literal">opkg</code> utility is a lightweight package manager that allows us to easily download and install OpenWrt packages. OpenWrt is a Linux distribution for embedded devices. First, we will check both the mraa and upm installed versions by using the <code class="literal">opkg</code> utility.</p><p>Run the following command to check the installed mraa version:</p><div class="informalexample"><pre class="programlisting">opkg info mraa</pre></div><p>The following lines show the output with the version and dependencies for the mraa package. In this case, the output shows that the installed version for mraa is <span class="strong"><strong>0.7.2-r0</strong></span>.</p><div class="informalexample"><pre class="programlisting">Package: mraa
Version: 0.7.2-r0
Depends: libgcc1 (&gt;= 4.9.1), python-core, libpython2.7-1.0 (&gt;= 2.7.3), libstdc++6 (&gt;= 4.9.1), libc6 (&gt;= 2.20)
Status: install user installed
Architecture: i586
Installed-Time: 1434860546</pre></div><p>Run the following command to check the installed upm version:</p><div class="informalexample"><pre class="programlisting">opkg info upm</pre></div><p>The <a id="id80" class="indexterm"/>following lines show the output with the version and dependencies for the upm package. In this case, the output shows that the installed version for upm is <span class="strong"><strong>0.3.1-r0</strong></span>.</p><div class="informalexample"><pre class="programlisting">Package: upm
Version: 0.3.1-r0
Depends: libgcc1 (&gt;= 4.9.1), libpython2.7-1.0 (&gt;= 2.7.3), libc6 (&gt;= 2.20), python-core, libstdc++6 (&gt;= 4.9.1), mraa (&gt;= 0.7.2)
Status: install user installed
Architecture: i586
Installed-Time: 1434860596</pre></div><p>Run the<a id="id81" class="indexterm"/> following command to check the repository configuration for both the <code class="literal">mraa</code> and upm libraries.</p><div class="informalexample"><pre class="programlisting">cat /etc/opkg/mraa-upm.conf</pre></div><p>If you see the following line as a response, it means that the repository is configured to work with the 1.5 version and we need to change its configuration to make it possible to update both the mraa and upm libraries to their latest versions.</p><div class="informalexample"><pre class="programlisting">src mraa-upm http://iotdk.intel.com/repos/1.5/intelgalactic</pre></div><p>Run the following command to configure the repository for both the mraa and upm libraries to work with version 2.0 instead of 1.5:</p><div class="informalexample"><pre class="programlisting">echo "src mraa-upm http://iotdk.intel.com/repos/2.0/intelgalactic" &gt; /etc/opkg/mraa-upm.conf</pre></div><p>Now, run the following command to check the repository configuration for both the mraa and upm libraries and you will notice that <code class="literal">1.5</code> has been replaced by <code class="literal">2.0</code> in the output.</p><div class="informalexample"><pre class="programlisting">cat /etc/opkg/mraa-upm.conf</pre></div><p>You should see the results shown in the next line:</p><div class="informalexample"><pre class="programlisting">src mraa-upm http://iotdk.intel.com/repos/2.0/intelgalactic</pre></div><p>We will use the <code class="literal">opkg</code> utility to update packages from the previously configured repository located on the Internet. Run the following command to make the <code class="literal">opkg</code> utility update the list of available packages after we changed the configuration of the repositories for both the mraa and upm libraries.</p><div class="informalexample"><pre class="programlisting">opkg update</pre></div><p>The previous command will generate the following output that indicates the list of available <a id="id82" class="indexterm"/>packages that have been updated. Notice that the last lines of the output indicate that the <a id="id83" class="indexterm"/>command has been downloaded from <code class="literal">http://iotdk.intel.com/repos/2.0/intelgalactic/Packages</code> and saved the available packages in <code class="literal">/var/lib/opkg/mraa-upm</code>.</p><div class="informalexample"><pre class="programlisting">Downloading http://iotdk.intel.com/repos/1.5/iotdk/all/Packages.
Updated list of available packages in /var/lib/opkg/iotdk-all.
Downloading http://iotdk.intel.com/repos/1.5/iotdk/i586/Packages.
Updated list of available packages in /var/lib/opkg/iotdk-i586.
Downloading http://iotdk.intel.com/repos/1.5/iotdk/quark/Packages.
Updated list of available packages in /var/lib/opkg/iotdk-quark.
Downloading http://iotdk.intel.com/repos/1.5/iotdk/x86/Packages.
Updated list of available packages in /var/lib/opkg/iotdk-x86.
<span class="strong"><strong>Downloading http://iotdk.intel.com/repos/2.0/intelgalactic/Packages.</strong></span>
<span class="strong"><strong>Updated list of available packages in /var/lib/opkg/mraa-upm.</strong></span>
</pre></div><p>Run the following command to check the versions for both the mraa and upm libraries stored in <code class="literal">/var/lib/opkg/mraa-upm</code>.</p><div class="informalexample"><pre class="programlisting">cat /var/lib/opkg/mraa-upm</pre></div><p>The following lines show the results. Notice that the version numbers might vary because both the mraa and upm libraries are very active projects and they are frequently updated. Thus, the version numbers might be higher when you run the previous command.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Package: mraa</strong></span>
<span class="strong"><strong>Version: 0.9.0</strong></span>
Provides: mraa-dev, mraa-dbg, mraa-doc
Replaces: mraa-dev, mraa-dbg, mraa-doc, libmraa, libmraa-dev, libmraa-doc
Conflicts: mraa-dev, mraa-dbg, mraa-doc
Section: libs
Architecture: i586
Maintainer: Intel IoT-Devkit
MD5Sum: b92167f26a0dc0dba4d485b7bedcfb47
Size: 442236
Filename: mraa_0.9.0_i586.ipk
Source: https://github.com/intel-iot-devkit/mraa
Description:  mraa built using CMake
Priority: optional


<span class="strong"><strong>Package: upm</strong></span>
<span class="strong"><strong>Version: 0.4.1</strong></span>
Depends: mraa (&gt;= 0.8.0)
Provides: upm-dev, upm-dbg, upm-doc
Replaces: upm-dev, upm-dbg, upm-doc
Conflicts: upm-dev, upm-dbg, upm-doc
Section: libs
Architecture: i586
Maintainer: Intel IoT-Devkit
MD5Sum: 13a0782e478f2ed1e65b33249be41424
Size: 16487850
Filename: upm_0.4.1_i586.ipk
Source: https://github.com/intel-iot-devkit/upm
Description:  upm built using CMake
Priority: optional</pre></div><p>In<a id="id84" class="indexterm"/> this case, we have mraa version <span class="strong"><strong>0.9.0</strong></span> and upm version <span class="strong"><strong>0.4.1</strong></span>. The version numbers are higher than the initially installed ones. We definitely want to upgrade mraa <span class="strong"><strong>0.7.2-r0</strong></span> to <span class="strong"><strong>0.9.0</strong></span> and upm <span class="strong"><strong>0.3.1-r0</strong></span> to 0.4.1. As shown in the preceding<a id="id85" class="indexterm"/> lines, upm depends on mraa version 0.8.0 or greater, and therefore, we will upgrade mraa first.</p><p>Run the following command to install the latest available version of the mraa library:</p><div class="informalexample"><pre class="programlisting">opkg install mraa</pre></div><p>The following lines show the results:</p><div class="informalexample"><pre class="programlisting">Upgrading mraa from 0.7.2-r0 to 0.9.0 on root.
Downloading http://iotdk.intel.com/repos/2.0/intelgalactic/mraa_0.9.0_i586.ipk.
Removing package mraa-dev from root...
Removing package mraa-doc from root...
Removing obsolete file /usr/lib/libmraa.so.0.7.2.
Removing obsolete file /usr/bin/mraa-gpio.
Configuring mraa.</pre></div><p>Run the following command to install the latest available version of the upm library:</p><div class="informalexample"><pre class="programlisting">opkg install upm</pre></div><p>The following lines show some lines with the results and the final line. Note that the package installation removes an important number of obsolete files:</p><div class="informalexample"><pre class="programlisting">Upgrading upm from 0.3.1-r0 to 0.4.1 on root.
Downloading http://iotdk.intel.com/repos/2.0/intelgalactic/upm_0.4.1_i586.ipk.
Removing package upm-dev from root...
Removing obsolete file /usr/lib/libupm-wt5001.so.0.3.1.
Removing obsolete file /usr/lib/libupm-adc121c021.so.0.3.1.
Removing obsolete file /usr/lib/libupm-joystick12.so.0.3.1.
Removing obsolete file /usr/lib/libupm-grove.so.0.3.1.
Removing obsolete file /usr/lib/libupm-tm1637.so.0.3.1.
…
Removing obsolete file /usr/lib/libupm-groveloudness.so.0.3.1.
Configuring upm.</pre></div><p>Now, run<a id="id86" class="indexterm"/> the following command to check the installed mraa version:</p><div class="informalexample"><pre class="programlisting">opkg info mraa</pre></div><p>The<a id="id87" class="indexterm"/> following lines show the output with the version and dependencies for the mraa package. The first lines show that mraa version <span class="strong"><strong>0.7.2-r0</strong></span> is not installed anymore and the highlighted lines show that mraa version <span class="strong"><strong>0.9.0</strong></span> is installed.</p><div class="informalexample"><pre class="programlisting">Package: mraa
Version: 0.7.2-r0
Depends: libgcc1 (&gt;= 4.9.1), python-core, libpython2.7-1.0 (&gt;= 2.7.3), libstdc++6 (&gt;= 4.9.1), libc6 (&gt;= 2.20)
Status: unknown ok not-installed
Section: libs
Architecture: i586
Maintainer: Intel IoT Devkit team &lt;meta-intel@yoctoproject.org&gt;
MD5Sum: b877585652e4bc34c5d8b0497de04c4f
Size: 462242
Filename: mraa_0.7.2-r0_i586.ipk
Source: git://github.com/intel-iot-devkit/mraa.git;protocol=git;rev=299bf5ab27191e60ea0280627da2161525fc8990
Description: Low Level Skeleton Library for Communication on Intel platforms  Low
 Level Skeleton Library for Communication on Intel platforms.

<span class="strong"><strong>Package: mraa</strong></span>
<span class="strong"><strong>Version: 0.9.0</strong></span>
Provides: mraa-dev, mraa-dbg, mraa-doc
Replaces: mraa-dev, mraa-dbg, mraa-doc, libmraa, libmraa-dev, libmraa-doc
Conflicts: mraa-dev, mraa-dbg, mraa-doc
Status: install user installed
Section: libs
Architecture: i586
Maintainer: Intel IoT-Devkit
MD5Sum: b92167f26a0dc0dba4d485b7bedcfb47
Size: 442236
Filename: mraa_0.9.0_i586.ipk
Source: https://github.com/intel-iot-devkit/mraa
Description: mraa built using CMake
Installed-Time: 1452800349</pre></div><p>Run the following command to check the installed upm version:</p><div class="informalexample"><pre class="programlisting">opkg info upm</pre></div><p>The <a id="id88" class="indexterm"/>following lines give the output with the version and <a id="id89" class="indexterm"/>dependencies for the upm package. The first lines display that upm version <span class="strong"><strong>0.3.1-r0</strong></span> is not installed anymore and the highlighted lines show that upm version <span class="strong"><strong>0.4.1</strong></span> is installed.</p><div class="informalexample"><pre class="programlisting">Package: upm
Version: 0.3.1-r0
Depends: libgcc1 (&gt;= 4.9.1), libpython2.7-1.0 (&gt;= 2.7.3), libc6 (&gt;= 2.20), python-core, libstdc++6 (&gt;= 4.9.1), mraa (&gt;= 0.7.2)
Status: unknown ok not-installed
Section: libs
Architecture: i586
Maintainer: Intel IoT Devkit team &lt;meta-intel@yoctoproject.org&gt;
MD5Sum: 9c38c6a23db13fbeb8c687336d473200
Size: 10344826
Filename: upm_0.3.1-r0_i586.ipk
Source: git://github.com/intel-iot-devkit/upm.git;protocol=git;rev=3d453811fb7760e14da1a3461e05bfba1893c2bd file://0001-adafruitms1438-CMakeLists.txt-stop-RPATH-being-added.patch
Description: Sensor/Actuator repository for Mraa  Sensor/Actuator repository for Mraa.

<span class="strong"><strong>Package: upm</strong></span>
<span class="strong"><strong>Version: 0.4.1</strong></span>
Depends: mraa (&gt;= 0.8.0)
Provides: upm-dev, upm-dbg, upm-doc
Replaces: upm-dev, upm-dbg, upm-doc
Conflicts: upm-dev, upm-dbg, upm-doc
Status: install user installed
Section: libs
Architecture: i586
Maintainer: Intel IoT-Devkit
MD5Sum: 13a0782e478f2ed1e65b33249be41424
Size: 16487850
Filename: upm_0.4.1_i586.ipk
Source: https://github.com/intel-iot-devkit/upm
Description: upm built using CMake
Installed-Time: 1452800568</pre></div><p>Now, we <a id="id90" class="indexterm"/>have the latest versions of both the mraa and <a id="id91" class="indexterm"/>upm libraries installed and we will be able to use them from any Python program.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Installing pip and additional libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Installing pip and additional libraries</h1></div></div></div><p>By <a id="id92" class="indexterm"/>default, the <code class="literal">pip</code> package management system that makes it easy to install and manage software packages written in Python isn't installed. We are going to use <a id="id93" class="indexterm"/>Python as our main programming language, and therefore, we will definitely benefit from installing <code class="literal">pip</code>.</p><p>Enter the following <code class="literal">curl</code> command to download the <code class="literal">get-pip.py</code> file from <code class="literal">https://bootstrap.pypa.io</code>, into the current folder.</p><div class="informalexample"><pre class="programlisting">curl -L "https://bootstrap.pypa.io/get-pip.py" &gt; get-pip.py</pre></div><p>You will see an output similar to the following lines that will indicate the download progress:</p><div class="informalexample"><pre class="programlisting">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 1379k  100 1379k    0     0   243k      0  0:00:05  0:00:05 --:--:--  411k</pre></div><p>Once the download has finished, run <code class="literal">python</code> with <code class="literal">get-pip.py</code> as an argument.</p><div class="informalexample"><pre class="programlisting">python get-pip.py</pre></div><p>You will see an ouput similar to the following lines that will indicate the installation progress and a few warnings related to the SSLContext. Don't worry about the warnings.</p><div class="informalexample"><pre class="programlisting">Collecting pip
/tmp/tmpe2ukgP/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:90: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  Downloading pip-7.1.2-py2.py3-none-any.whl (1.1MB)
    100% |################################| 1.1MB 11kB/s 
Collecting wheel
  Downloading wheel-0.26.0-py2.py3-none-any.whl (63kB)
    100% |################################| 65kB 124kB/s 
Installing collected packages: pip, wheel
Successfully installed pip-7.1.2 wheel-0.26.0
/tmp/tmpe2ukgP/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:90: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.</pre></div><p>Now, we <a id="id94" class="indexterm"/>can use the <code class="literal">pip</code> installer to easily install additional Python 2.7.3 packages. We will use the <code class="literal">pip</code> installer to get the <code class="literal">wiring-x86</code> package from PyPI, the <a id="id95" class="indexterm"/>Python Package Index, and install it. The <code class="literal">wiring-x86</code> package is a Python module that provides a simple API similar to the WiringPi module to use the general purpose I/O pins on the Intel Galileo Gen 2 board and other supported platforms. We just need to run the following command to install the package:</p><div class="informalexample"><pre class="programlisting">pip install wiring-x86</pre></div><p>The last lines for the ouput will indicate that the <code class="literal">wiring-x86</code> package has been successfully installed. Don't worry about the error messages related to building a wheel for <code class="literal">wiring-x86</code>.</p><div class="informalexample"><pre class="programlisting">Installing collected packages: wiring-x86
  Running setup.py install for wiring-x86
Successfully installed wiring-x86-1.0.0</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Invoking the Python interpreter"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Invoking the Python interpreter</h1></div></div></div><p>We <a id="id96" class="indexterm"/>have installed the most updated versions of the most important libraries we required to interact with the features included in the Intel Galileo Gen 2 board. Now, we can invoke the Python interpreter by typing the classic command:</p><div class="informalexample"><pre class="programlisting">python</pre></div><p>Now, enter the following two lines of Python code:</p><div class="informalexample"><pre class="programlisting">import mraa
mraa.getVersion()</pre></div><p>The Python interpreter will display the following output:</p><div class="informalexample"><pre class="programlisting">'v0.9.0'</pre></div><p>We imported the <code class="literal">mraa</code> library and called the <code class="literal">mraa.getVersion</code> method to check whether Python is able to retrieve the installed version of the <code class="literal">mraa</code> library. The result of calling the<a id="id97" class="indexterm"/> method displays the version we installed for the <code class="literal">mraa</code> library, and therefore, we know that Python is going to work with the version we expect. Note that the Python code is running on the Yocto Linux on the Intel Galileo Gen 2 board.</p><p>Now, enter the following line to check whether the <code class="literal">mraa</code> library has successfully detected the board type:</p><div class="informalexample"><pre class="programlisting">mraa.getPlatformName()</pre></div><p>The Python interpreter will display the following output:</p><div class="informalexample"><pre class="programlisting">'Intel Galileo Gen 2'</pre></div><p>We called the <code class="literal">mraa.getPlatformName</code> method and the result of calling the method displays our board's name: Intel Galileo Gen 2. The following screenshot shows the results of calling the previous methods:</p><div class="mediaobject"><img src="images/B05042_02_13.jpg" alt="Invoking the Python interpreter"/></div><p>Now, open a Web browser in any computer or device connected to your LAN and enter the board's assigned IP address. For example, in case the IP address is <span class="strong"><strong>192.168.1.104</strong></span>, enter it as the URL to browse. The following screenshot shows the content you will see on your Web browser: <span class="strong"><strong>It works!</strong></span>
</p><div class="mediaobject"><img src="images/B05042_02_14.jpg" alt="Invoking the Python interpreter"/></div><p>The board is <a id="id98" class="indexterm"/>working as a Web server and it returns the contents of the <code class="literal">/www/pages/index.html</code> file to the Web browser request.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can access Python 2.7.x on the Intel Galileo Gen 2 board:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">After booting the pre-installed SPI image from the flash memory.</li><li class="listitem">After booting a Yocto Linux from the microSD card, specifically, the IoT Devkit image.</li><li class="listitem">After booting the pre-installed SPI image and pressing the reboot button three times.</li></ol></div></li><li class="listitem">Once an Intel Galileo Gen 2 board is connected to our LAN, we can access its shell with any utility that allows us to use the following interface and protocol:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">SSH.</li><li class="listitem">Telnet.</li><li class="listitem">X.25.</li></ol></div></li><li class="listitem">Which of the following libraries has bindings to Python and allows us to work with the I/O on Intel Galileo Gen 2:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">IotGalileoGen2.</li><li class="listitem">Mraa.</li><li class="listitem">Mupm.</li></ol></div></li><li class="listitem">Which of the following packages is a Python module that provides an API similar to the WiringPi module to use general purpose I/O pins on the Intel Galieo Gen 2:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">wiring-py-galileo.</li><li class="listitem">galileo-gen2-x86.</li><li class="listitem">wiring-x86.</li></ol></div></li><li class="listitem">Which of the following methods return the board that the mraa library automatically detects:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">mraa.getPlatformName().</li><li class="listitem">mraa.getBoardName().</li><li class="listitem">mraa.getGalileoBoardName().</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we followed many procedures to make is possible to work with Python as the main programming language to create IoT projects with our Intel Galileo Gen 2 board. We wrote a Linux Yocto image to a microSD card and we configured the board to make it boot this image, so that we can access Python and other useful libraries to interact with the board. We updated many libraries to use their latest versions and we launched the Python interpreter.</p><p>Now that our board is ready to be coded with Python, we can start wiring electronic components to the board and work with Python and the libraries to write digital values, which is the topic of the next chapter.</p></div></div>
</body></html>