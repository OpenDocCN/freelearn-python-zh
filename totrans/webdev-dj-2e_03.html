<html><head></head><body>
		<div>
			<div id="_idContainer114" class="Content">
			</div>
		</div>
		<div id="_idContainer115" class="Content">
			<h1 id="_idParaDest-121"><a id="_idTextAnchor123"/>3. URL Mapping, Views, and Templates</h1>
		</div>
		<div id="_idContainer124" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to three core concepts of Django: <strong class="bold">views</strong>, <strong class="bold">templates</strong>, and <strong class="bold">URL mapping</strong>. You will start by exploring the two main types of views in Django: <strong class="bold">function-based views</strong> and <strong class="bold">class-based views</strong>. Next, you will learn the basics of Django template language and template inheritance. Using these concepts, you will create a page to display the list of all the books in the <strong class="bold">Bookr</strong> application. You will also create another page to display the details, review comments, and ratings of books.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Introduction</h1>
			<p>In the previous chapter, we were introduced to databases, and we learned how to store, retrieve, update, and delete records from a database. We also learned how to create Django models and apply database migrations.</p>
			<p>However, these database operations alone cannot display the application's data to a user. We need a way to display all the stored information in a meaningful way to the user; for example, displaying all the books present in our Bookr application's database, in a browser, in a presentable format. This is where Django views, templates, and URL mapping come into play. Views are the part of a Django application that takes in a web request and provides a web response. For example, a web request could be a user trying to view a website by entering the website address, and a web response could be the web site's home page loading in the user's browser. Views are one of the most important parts of a Django application, where the application logic is written. This application logic controls interactions with the database, such as creating, reading, updating, or deleting records from the database. It also controls how the data can be displayed to the user. This is done with the help of Django HTML templates, which we will explore in detail in a later section.</p>
			<p>Django views can be broadly classified into two types, <strong class="bold">function-based views</strong> and <strong class="bold">class-based views</strong>. In this chapter, we will learn about function-based views in Django.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this chapter, we will learn only about function-based views. Class-based views, which is a more advanced topic, will be discussed in detail in <a id="_idTextAnchor125"/><em class="italic">Chapter 11</em>, <em class="italic">Advanced Templating and Class-Based Views</em>.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor126"/>Function-Based Views</h1>
			<p>As the name implies, function-based views are implemented as Python functions. To understand how they work, consider the following snippet, which shows a simple view function named <strong class="source-inline">home_page</strong>:</p>
			<p class="source-code">from django.http import HttpResponse</p>
			<p class="source-code">def home_page(request):</p>
			<p class="source-code">    message = "&lt;html&gt;&lt;h1&gt;Welcome to my Website&lt;/h1&gt;&lt;/html&gt;"</p>
			<p class="source-code">    return HttpResponse(message)</p>
			<p>The view function defined here, named <strong class="source-inline">home_page</strong>, takes a <strong class="source-inline">request</strong> object as an argument and returns an <strong class="source-inline">HttpResponse</strong> object having the <strong class="source-inline">Welcome to my Website</strong> message. The advantage of using function-based views is that, since they are implemented as simple Python functions, they are easier to learn and also easily readable for other programmers. The major disadvantage of function-based views is that the code cannot be re-used and made as concise as class-based views for generic use cases.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Class-Based Views</h1>
			<p>As the name implies, class-based views are implemented as Python classes. Using the principles of class inheritance, these classes are implemented as subclasses of Django's generic view classes. Unlike function-based views, where all the view logic is expressed explicitly in a function, Django's generic view classes come with various pre-built properties and methods that can provide shortcuts to writing clean, reusable views. This property comes in handy quite often during web development; for example, developers often need to render an HTML page without needing any data inserted from the database, or any customization specific to the user. In this case, it is possible to simply inherit from Django's <strong class="source-inline">TemplateView</strong>, and specify the path of the HTML file. The following is an example of a class-based view that can display the same message as in the function-based view example:</p>
			<p class="source-code">from django.views.generic import TemplateView</p>
			<p class="source-code">class HomePage(TemplateView):</p>
			<p class="source-code">    template_name = 'home_page.html'</p>
			<p>In the preceding code snippet, <strong class="source-inline">HomePage</strong> is a class-based view inheriting Django's <strong class="source-inline">TemplateView</strong> from the <strong class="source-inline">django.views.generic</strong> module. The class attribute <strong class="source-inline">template_name</strong> defines the template to render when the view is invoked. For the template, we add an HTML file to our <strong class="source-inline">templates</strong> folder with the following content:</p>
			<p class="source-code">&lt;html&gt;&lt;h1&gt;Welcome to my Website&lt;/h1&gt;&lt;/html&gt;</p>
			<p>This is a very basic example of class-based views, which will be explored further in <em class="italic">Chapter 11</em>, <em class="italic">Advanced Templating and Class-Based Views</em>. The major advantage of using class-based views is that fewer lines of code need to be used to implement the same functionality as compared to function-based views. Also, by inheriting Django's generic views, we can keep the code concise and avoid the duplication of code. However, a disadvantage of class-based views is that the code is often less readable for someone new to Django, which means that learning about it is usually a longer process, as compared to function-based views.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor128"/>URL Configuration</h1>
			<p>Django views cannot work on their own in a web application. When a web request is made to the application, Django's URL configuration takes care of routing the request to the appropriate view function to process the request. A typical URL configuration in the <strong class="source-inline">urls.py</strong> file in Django looks like this:</p>
			<p class="source-code">from . import views</p>
			<p class="source-code">urlpatterns = [path('url-path/' views.my_view, name='my-view'),]</p>
			<p>Here, <strong class="source-inline">urlpatterns</strong> is the variable defining the list of URL paths, and <strong class="source-inline">'url-path/'</strong> defines the path to match. </p>
			<p><strong class="source-inline">views.my_view</strong> is the view function to invoke when there is a URL match, and <strong class="source-inline">name='my-view'</strong> is the name of the view function used to refer to the view. There may be a situation wherein, elsewhere in the application, we want to get the URL of this view. We wouldn't want to hardcode the value, as it would then have to be specified twice in the codebase. Instead, we can access the URL by using the name of the view, as follows:</p>
			<p class="source-code">from django.urls import reverse</p>
			<p class="source-code">url = reverse('my-view')</p>
			<p>If needed, we can also use a regular expression in a URL path to match string patterns using <strong class="source-inline">re_path()</strong>:</p>
			<p class="source-code">urlpatterns = [re_path\</p>
			<p class="source-code">               (r'^url-path/(?P&lt;name&gt;pattern)/$', views.my_view, \</p>
			<p class="source-code">                name='my-view')]</p>
			<p>Here, <strong class="source-inline">name</strong> refers to the pattern name, which can be any Python regular expression pattern, and this needs to be matched before calling the defined view function. You can also pass parameters from the URL into the view itself, for example:</p>
			<p class="source-code">urlpatterns = [path(r'^url-path/&lt;int:id&gt;/', views.my_view, \</p>
			<p class="source-code">               name='my-view')]</p>
			<p>In the preceding example, <strong class="source-inline">&lt;int:id&gt;</strong> tells Django to look for URLs that contain an integer at this position in the string, and to assign the value of that integer to the <strong class="source-inline">id</strong> argument. This means that if the user navigates to <strong class="source-inline">/url-path/14/</strong>, the <strong class="source-inline">id=14</strong> keyword argument is passed to the view. This is often useful when a view needs to look up a specific object in the database and return corresponding data. For example, suppose we had a <strong class="source-inline">User</strong> model, and we wanted the view to display the user's name. </p>
			<p>The view could be written as follows:</p>
			<p class="source-code">def my_view(request, id):</p>
			<p class="source-code">    user = User.objects.get(id=id)</p>
			<p class="source-code">    return HttpResponse(f"This user's name is \</p>
			<p class="source-code">    { user.first_name } { user.last_name }")</p>
			<p>When the user accesses <strong class="source-inline">/url-path/14/</strong>, the preceding view is called, and the argument <strong class="source-inline">id=14</strong> is passed into the function.</p>
			<p>Here is the typical workflow when a URL such as <strong class="source-inline">http://0.0.0.0:8000/url-path/</strong> is invoked using a web browser:</p>
			<ol>
				<li>An HTTP request would be made to the running application for the URL path. Upon receiving the request, it reaches for the <strong class="source-inline">ROOT_URLCONF</strong> setting present in the <strong class="source-inline">settings.py</strong> file:<p class="source-code">ROOT_URLCONF = 'project_name.urls'</p><p>This determines the URL configuration file to be used first. In this case, it is the URL file present in the project directory <strong class="source-inline">project_name/urls.py</strong>.</p></li>
				<li>Next, Django goes through the list named <strong class="source-inline">urlpatterns</strong>, and once it matches the <strong class="source-inline">url-path/</strong> with the path present in the URL <strong class="source-inline">http://0.0.0.0:8000/url-path/</strong>, it invokes the corresponding view function.</li>
			</ol>
			<p>URL configuration is sometimes also referred to as URL conf or URL mapping, and these terms are often used interchangeably. To understand views and URL mapping better, let's start with a simple exercise.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor129"/>Exercise 3.01: Implementing a Simple Function-Based View</h2>
			<p>In this exercise, we will write a very basic function-based view and use the associated URL configuration to display the message <strong class="source-inline">Welcome to Bookr!</strong> in a web browser. We will also tell the user how many books we have in the database:</p>
			<ol>
				<li value="1">First, ensure that <strong class="source-inline">ROOT_URLCONF</strong> in <strong class="source-inline">bookr/settings.py</strong> is pointing to the project's URL file by adding in the following command:<p class="source-code">ROOT_URLCONF = 'bookr.urls'</p></li>
				<li>Open the <strong class="source-inline">bookr/reviews/views.py</strong> file and add the following code snippet:<p class="source-code">from django.http import HttpResponse</p><p class="source-code">from .models import Book</p><p class="source-code">def welcome_view(request):</p><p class="source-code">    message = f"&lt;html&gt;&lt;h1&gt;Welcome to Bookr!&lt;/h1&gt; "\</p><p class="source-code">"&lt;p&gt;{Book.objects.count()} books and counting!&lt;/p&gt;&lt;/html&gt;"</p><p class="source-code">    return HttpResponse(message)</p><p>First, we import the <strong class="source-inline">HttpResponse</strong> class from the <strong class="source-inline">django.http</strong> module. Next, we define the <strong class="source-inline">welcome_view</strong> function, which can display the message <strong class="source-inline">Welcome to Bookr!</strong> in a web browser. The request object is a function parameter that carries the HTTP <strong class="source-inline">request</strong> object. The next line defines the <strong class="source-inline">message</strong> variable, which contains HTML that displays the header, followed by a line that counts the number of books available in the database.</p><p>In the last line, we return an <strong class="source-inline">HttpResponse</strong> object with the string associated with the message variable. When the <strong class="source-inline">welcome_view</strong> view function is called, it will display the message <strong class="source-inline">Welcome to Bookr!  2 Books and counting</strong> in the web browser.</p></li>
				<li>Now, create the URL mapping to call the newly created view function. Open the project URL file, <strong class="source-inline">bookr/urls.py</strong>, and add the list of <strong class="source-inline">urlpatterns</strong> as follows:<p class="source-code">from django.contrib import admin</p><p class="source-code">from django.urls import include, path</p><p class="source-code">urlpatterns = [path('admin/', admin.site.urls),\</p><p class="source-code">               path('', include('reviews.urls'))]</p><p>The first line in the list of <strong class="source-inline">urlpatterns</strong>, that is, <strong class="source-inline">path('admin/', admin.site.urls)</strong> routes to the admin URLs if <strong class="source-inline">admin/</strong> is present in the URL path (for example, <strong class="source-inline">http://0.0.0.0:8000/admin</strong>). </p><p>Similarly, consider the second line, <strong class="source-inline">path('', include('reviews.urls'))</strong>. Here, the path mentioned is an empty string, <strong class="source-inline">''</strong>. If the URL does not have any specific path after <strong class="source-inline">http://hostname:port-number/</strong> (for example, <strong class="source-inline">http://0.0.0.0:8000/</strong>), it includes the <strong class="source-inline">urlpatterns</strong> present in <strong class="source-inline">review.urls</strong>.</p><p>The <strong class="source-inline">include</strong> function is a shortcut that allows you to combine URL configurations. It is common to keep one URL configuration per application in your Django project. Here, we've created a separate URL configuration for the <strong class="source-inline">reviews</strong> app and have added it to our project-level URL configuration.</p></li>
				<li>Since we do not have the URL module <strong class="source-inline">reviews.urls</strong> yet, create a file called <strong class="source-inline">bookr/reviews/urls.py</strong>, and add the following lines of code:<p class="source-code">from django.contrib import admin</p><p class="source-code">from django.urls import path</p><p class="source-code">from . import views</p><p class="source-code">urlpatterns = [path('', views.welcome_view, \</p><p class="source-code">                    name='welcome_view'),]</p></li>
				<li>Here, we have used an empty string again for the URL path. So, when the URL <strong class="source-inline">http://0.0.0.0:8000/</strong> is invoked, after getting routed from <strong class="source-inline">bookr/urls.py</strong> into <strong class="source-inline">bookr/reviews/urls.py</strong>, this pattern invokes the <strong class="source-inline">welcome_view</strong> view function.</li>
				<li>After making changes to the two files, we have the necessary URL configuration ready to call the <strong class="source-inline">welcome_view</strong> view. Now, start the Django server with <strong class="source-inline">python manage.py runserver</strong> and type in <strong class="source-inline">http://0.0.0.0:8000</strong> or <strong class="source-inline">http://127.0.0.1:8000</strong> in your web browser. You should be able to see the message <strong class="source-inline">Welcome to Bookr!</strong>:<div id="_idContainer116" class="IMG---Figure"><img src="image/B15509_03_01.jpg" alt="Figure 3.1: Displaying &quot;Welcome to Bookr!&quot; and the number of books on the home page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.1: Displaying "Welcome to Bookr!" and the number of books on the home page</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If there is no URL match, Django invokes error handling, such as displaying a <strong class="source-inline">404 Page not found</strong> message or something similar.</p>
			<p>In this exercise, we learned how to write a basic view function and do the associated URL mapping. We have created a web page that displays a simple message to the user and reports how many books are currently in our database.</p>
			<p>However, the astute reader will have noticed that it doesn't look very nice to have HTML code sitting inside our Python function as in the preceding example. As our views get bigger, this will become even more unsustainable. Therefore, we now turn our attention to where our HTML code is supposed to be – inside templates.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Templates</h1>
			<p>In <em class="italic">Exercise 3.01</em>, <em class="italic">Implementing a Simple Function-Based View</em>, we saw how to create a view, do the URL mapping, and display a message in the browser. But if you recall, we hardcoded the HTML message <strong class="source-inline">Welcome to Bookr!</strong> in the view function itself and returned an <strong class="source-inline">HttpResponse</strong> object, as follows:</p>
			<p class="source-code">message = f"&lt;html&gt;&lt;h1&gt;Welcome to Bookr!&lt;/h1&gt; "\</p>
			<p class="source-code">"&lt;p&gt;{Book.objects.count()} books and counting!&lt;/p&gt;&lt;/html&gt;"</p>
			<p class="source-code">return HttpResponse(message)</p>
			<p>Hardcoding of HTML inside Python modules is not a good practice, because as the content to be rendered in a web page increases, so does the amount of HTML code we need to write for it. Having a lot of HTML code among Python code can make the code hard to read and maintain in the long run.</p>
			<p>For this reason, Django templates provide us with a better way to write and manage HTML templates. Django's templates not only work with static HTML content but also dynamic HTML templates.</p>
			<p>Django's template configuration is done in the <strong class="source-inline">TEMPLATES</strong> variable present in the <strong class="source-inline">settings.py</strong> file. This is how the default configuration looks:</p>
			<p class="source-code">TEMPLATES = \</p>
			<p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\</p>
			<p class="source-code">  'DIRS': [],</p>
			<p class="source-code">  'APP_DIRS': True,</p>
			<p class="source-code">  'OPTIONS': {'context_processors': \</p>
			<p class="source-code">              ['django.template.context_processors.debug',\</p>
			<p class="source-code">               'django.template.context_processors.request',\</p>
			<p class="source-code">               'django.contrib.auth.context_processors.auth',\</p>
			<p class="source-code">               'django.contrib.messages.context_processors\</p>
			<p class="source-code">                .messages',\</p>
			<p class="source-code">            ],\</p>
			<p class="source-code">        },\</p>
			<p class="source-code">    },\</p>
			<p class="source-code">]</p>
			<p>Let's go through each keyword present in the preceding snippet:</p>
			<ul>
				<li><strong class="source-inline">'BACKEND': 'django.template.backends.django.DjangoTemplates'</strong>: This refers to the template engine to be used. A template engine is an API used by Django to work with HTML templates. Django is built with Jinja2 and the <strong class="source-inline">DjangoTemplates</strong> engine. The default configuration is the <strong class="source-inline">DjangoTemplates</strong> engine and Django template language. However, this can be changed to use a different one if required, such as Jinja2 or any other third-party template engine. For our Bookr application though, we will leave this configuration as it is.</li>
				<li><strong class="source-inline">'DIRS': []</strong>: This refers to the list of directories where Django searches for the templates in the given order.</li>
				<li><strong class="source-inline">'APP_DIRS': True</strong>: This tells the Django template engine whether it should look for templates in the installed apps defined under <strong class="source-inline">INSTALLED_APPS</strong> in the <strong class="source-inline">settings.py</strong> file. The default option for this is <strong class="source-inline">True</strong>.</li>
				<li><strong class="source-inline">'OPTIONS'</strong>: This is a dictionary containing template engine-specific settings. Inside this dictionary, there is a default list of context processors, which helps the Python code to interact with templates to create and render dynamic HTML templates. </li>
			</ul>
			<p>The current default settings are mostly fine for our purposes. However, in the next exercise, we will create a new directory for our templates, and we will need to specify the location of this folder. For example, if we have a directory called <strong class="source-inline">my_templates</strong>, we need to specify its location by adding it to the <strong class="source-inline">TEMPLATES</strong> settings as follows:</p>
			<p class="source-code">TEMPLATES = \</p>
			<p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\</p>
			<p class="source-code">  'DIRS': <strong class="bold">[os.path.join(BASE_DIR, 'my_templates')]</strong>,\</p>
			<p class="source-code">  'APP_DIRS': True,\</p>
			<p class="source-code">  'OPTIONS': {'context_processors': \</p>
			<p class="source-code">               ['django.template.context_processors.debug',\</p>
			<p class="source-code">                'django.template.context_processors.request',\</p>
			<p class="source-code">                'django.contrib.auth.context_processors.auth',\</p>
			<p class="source-code">                'django.contrib.messages.context_processors\</p>
			<p class="source-code">                 .messages',\</p>
			<p class="source-code">            ],\</p>
			<p class="source-code">        },\</p>
			<p class="source-code">    },</p>
			<p><strong class="source-inline">BASE_DIR</strong> is the directory path to the project folder. This is defined in the <strong class="source-inline">settings.py</strong> file. The <strong class="source-inline">os.path.join()</strong> method joins the project directory with the <strong class="source-inline">templates</strong> directory, returning the full path for the templates directory.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor131"/>Exercise 3.02: Using Templates to Display a Greeting Message</h2>
			<p>In this exercise, we will create our first Django template, and, just as we did in the previous exercise, we will display the <strong class="source-inline">Welcome to Bookr!</strong> message using the templates:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">templates</strong> in the <strong class="source-inline">bookr</strong> project directory and inside it, create a file called <strong class="source-inline">base.html</strong>. The directory structure should look like <em class="italic">Figure 3.2</em>:<div id="_idContainer117" class="IMG---Figure"><img src="image/B15509_03_02.jpg" alt="Figure 3.2: Directory structure for bookr&#13;&#10;"/></div><p class="figure-caption">Figure 3.2: Directory structure for bookr</p><p class="callout-heading">Note</p><p class="callout">When the default configuration is used, that is when <strong class="source-inline">DIRS</strong> is an empty list, Django searches for templates present only in the app folders' <strong class="source-inline">template</strong> directory (the <strong class="source-inline">reviews/templates</strong> folder in the case of a book review application). Since we included the new template directory in the main project directory, Django's template engine would not be able to find the directory unless the directory is included in the <strong class="source-inline">'DIRS'</strong> list.</p></li>
				<li>Add the folder to the <strong class="source-inline">TEMPLATES</strong> settings:<p class="source-code">TEMPLATES = \</p><p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\</p><p class="source-code">  'DIRS': <strong class="bold">[os.path.join(BASE_DIR, 'templates')]</strong>,</p><p class="source-code">  'APP_DIRS': True,</p><p class="source-code">  'OPTIONS': {'context_processors': \</p><p class="source-code">              ['django.template.context_processors.debug',\</p><p class="source-code">               'django.template.context_processors.request',\</p><p class="source-code">               'django.contrib.auth.context_processors.auth',\</p><p class="source-code">               'django.contrib.messages.context_processors\</p><p class="source-code">               .messages',\</p><p class="source-code">            ],\</p><p class="source-code">        },\</p><p class="source-code">    },\</p><p class="source-code">            ]</p></li>
				<li>Add the following lines of code into the <strong class="source-inline">base.html</strong> file:<p class="source-code">&lt;!doctype html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset=»utf-8»&gt;</p><p class="source-code">    &lt;title&gt;Home Page&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">    &lt;body&gt;</p><p class="source-code">        &lt;h1&gt;Welcome to Bookr!&lt;/h1&gt;</p><p class="source-code">    &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>This is simple HTML that displays the message <strong class="source-inline">Welcome to Bookr!</strong> in the header.</p></li>
				<li>Modify the code inside <strong class="source-inline">bookr/reviews/views.py</strong> so that it looks as follows:<p class="source-code">from django.shortcuts import render</p><p class="source-code">def welcome_view (request):</p><p class="source-code">    return render(request, 'base.html')</p><p>Since we have already configured the <strong class="source-inline">'templates'</strong> directory in the <strong class="source-inline">TEMPLATES</strong> configuration, <strong class="source-inline">base.html</strong> is available for use for the template engine. The code renders the file <strong class="source-inline">base.html</strong> using the imported <strong class="source-inline">render</strong> method from the <strong class="source-inline">django.shortcuts</strong> module.  </p></li>
				<li>Save the files, run <strong class="source-inline">python manage.py runserver</strong>, and open the <strong class="source-inline">http://0.0.0.0:8000/</strong> or <strong class="source-inline">http://127.0.0.1:8000/</strong> URL to check the newly added template loading in the browser:<p> </p><div id="_idContainer118" class="IMG---Figure"><img src="image/B15509_03_03.jpg" alt="Figure 3.3: Displaying &quot;Welcome to Bookr!&quot; on the home page &#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.3: Displaying "Welcome to Bookr!" on the home page </p>
			<p>In this exercise, we created an HTML template and used Django templates and views to return the message <strong class="source-inline">Welcome to Bookr!</strong>. Next, we will learn about the Django template language, which can be used to render the application's data along with HTML templates.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor132"/>Django Template Language</h1>
			<p>Django templates not only return static HTML templates but can also add dynamic application data while generating the templates. Along with data, we can also include some programmatic elements in the templates. All of these put together form the basics of <strong class="bold">Django's template language</strong>. This section looks at some of the basic parts of the Django template language.</p>
			<h3 id="_idParaDest-130"><a id="_idTextAnchor133"/>Template Variables</h3>
			<p>A template variable is represented in between two curly braces, as shown here:</p>
			<p class="source-code">{{ variable }}</p>
			<p>When this is present in the template, the value carried by the variables will be replaced in the template. Template variables help in adding the application's data into the templates:</p>
			<p class="source-code">template_variable = "I am a template variable."</p>
			<p class="source-code">&lt;body&gt;</p>
			<p class="source-code">        {{ template_variable }}</p>
			<p class="source-code">    &lt;/body&gt;</p>
			<h3 id="_idParaDest-131"><a id="_idTextAnchor134"/>Template Tags</h3>
			<p>A tag is similar to a programmatic control flow, such as an <strong class="source-inline">if</strong> condition or a <strong class="source-inline">for</strong> loop. A tag is represented between two curly braces and percentage signs, as shown. Here is an example of a <strong class="source-inline">for</strong> loop iterating over a list using template tags:</p>
			<p class="source-code">{% for element in element_list %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Unlike Python programming, we also add the end of the control flow by adding the <strong class="source-inline">end</strong> tag, such as <strong class="source-inline">{% endfor %}</strong>. This can be used along with template variables to display the elements in the list, as shown here:</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">    {% for element in element_list %}</p>
			<p class="source-code">        &lt;li&gt;{{ element.title }}&lt;/li&gt;</p>
			<p class="source-code">    {% endfor %}</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<h3 id="_idParaDest-132"><a id="_idTextAnchor135"/>Comments</h3>
			<p>Comments in the Django template language can be written as shown here; anything in-between <strong class="source-inline">{% comment %}</strong> and <strong class="source-inline">{% endcomment %}</strong> will be commented out:</p>
			<p class="source-code">{% comment %}</p>
			<p class="source-code">    &lt;p&gt;This text has been commented out&lt;/p&gt;</p>
			<p class="source-code">{% endcomment %}</p>
			<h3 id="_idParaDest-133"><a id="_idTextAnchor136"/>Filters</h3>
			<p>Filters can be used to modify a variable to represent it in a different format. The syntax for a filter is a variable separated from the filter name using a pipe (<strong class="source-inline">|</strong>) symbol:</p>
			<p class="source-code">{{ variable|filter }}</p>
			<p>Here are some examples of built-in filters:</p>
			<ul>
				<li><strong class="source-inline">{{ variable|lower }}</strong>: This converts the variable string into lowercase.</li>
				<li><strong class="source-inline">{{ variable|title}}</strong>: This converts the first letter of every word into uppercase.</li>
			</ul>
			<p>Let's use the concepts we have learned up till now to develop the book review application.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor137"/>Exercise 3.03: Displaying a List of Books and Reviews</h2>
			<p>In this exercise, we will create a web page that can display a list of all books, their ratings, and the number of reviews present in the book review application. For this, we will be using some features of the Django template language such as variables and template tags to pass the book review application data into the templates to display meaningful data on the web page:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">utils.py</strong> under <strong class="source-inline">bookr/reviews/utils.py</strong> and add the following code:<p class="source-code">def average_rating(rating_list):</p><p class="source-code">    if not rating_list:</p><p class="source-code">        return 0</p><p class="source-code">    return round(sum(rating_list) / len(rating_list))</p><p>This is a helper method that will be used to calculate the average rating of a book.</p></li>
				<li>Remove all the code present inside <strong class="source-inline">bookr/reviews/views.py</strong> and add the following code to it:<p class="source-code">from django.shortcuts import render</p><p class="source-code">from .models import Book, Review</p><p class="source-code">from .utils import average_rating</p><p class="source-code">def book_list(request):</p><p class="source-code">    books = Book.objects.all()</p><p class="source-code">    book_list = []</p><p class="source-code">    for book in books:</p><p class="source-code">        reviews = book.review_set.all()</p><p class="source-code">        if reviews:</p><p class="source-code">            book_rating = average_rating([review.rating for \</p><p class="source-code">                                          review in reviews])</p><p class="source-code">            number_of_reviews = len(reviews)</p><p class="source-code">        else:</p><p class="source-code">            book_rating = None</p><p class="source-code">            number_of_reviews = 0</p><p class="source-code">        book_list.append({'book': book,\</p><p class="source-code">                          'book_rating': book_rating,\</p><p class="source-code">                          'number_of_reviews': number_of_reviews})</p><p class="source-code">    context = {</p><p class="source-code">        'book_list': book_list</p><p class="source-code">    }</p><p class="source-code">    return render(request, 'reviews/books_list.html', context)</p><p>This is a view to display the list of books for the book review application. The first three lines import Django modules, model classes, and the helper method we just added.</p><p>Here, <strong class="source-inline">books_list</strong> is the view method. In this method, we start by querying the list of all books. Next, for every book, we calculate the average rating and the number of reviews posted. All this information for each book is appended to a list called <strong class="source-inline">book_list</strong> as a list of dictionaries. This list is then added to a dictionary named context and is passed to the render function.</p><p>The render function takes three parameters, the first one being the request object that was passed into the view, the second being the HTML template <strong class="source-inline">books_list.html</strong>, which will display the list of books, and the third is context, which we pass to the template.</p><p>Since we have passed <strong class="source-inline">book_list</strong> as a part of the context, the template will be using this to render the list of books using template tags and template variables.</p></li>
				<li>Create the <strong class="source-inline">book_list.html</strong> file in the path <strong class="source-inline">bookr/reviews/templates/reviews/books_list.html</strong> and add the following HTML code in the file:<p class="source-code-heading">reviews/templates/reviews/books_list.html</p><p class="source-code">1  &lt;!doctype html&gt;</p><p class="source-code">2  &lt;html lang="en"&gt;</p><p class="source-code">3  &lt;head&gt;</p><p class="source-code">4      &lt;meta charset="utf-8"&gt;</p><p class="source-code">5      &lt;title&gt;Bookr&lt;/title&gt;</p><p class="source-code">6  &lt;/head&gt;</p><p class="source-code">7      &lt;body&gt;</p><p class="source-code">8          &lt;h1&gt;Book Review application&lt;/h1&gt;</p><p class="source-code">9          &lt;hr&gt;</p><p class="source-code-link">You can find the complete code at <a href="http://packt.live/3hnB4Qr">http://packt.live/3hnB4Qr</a>.</p><p>This is a simple HTML template with template tags and variables iterating over <strong class="source-inline">book_list</strong> to display the list of books.</p></li>
				<li>In <strong class="source-inline">bookr/reviews/urls.py</strong>, add the following URL pattern to invoke the <strong class="source-inline">books_list</strong> view:<p class="source-code">from django.urls import path</p><p class="source-code">from . import views</p><p class="source-code">urlpatterns = [path('books/', views.book_list, \</p><p class="source-code">                    name='book_list'),]</p><p>This does the URL mapping for the <strong class="source-inline">books_list</strong> view function.</p></li>
				<li>Save all the modified files and wait for the Django service to restart. Open <strong class="source-inline">http://0.0.0.0:8000/books/</strong> in the browser, and you should see something similar to <em class="italic">Figure 3.4</em>:<div id="_idContainer119" class="IMG---Figure"><img src="image/B15509_03_04.jpg" alt="Figure 3.4: List of books present in the book review application&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.4: List of books present in the book review application</p>
			<p>In this exercise, we created a view function, created templates, and also did the URL mapping, which can display a list of all books present in the application. Although we were able to display a list of books using a single template, next, let's explore a bit about how to work with multiple templates in an application that has common or similar code.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor138"/>Template Inheritance</h2>
			<p>As we build the project, the number of templates will increase. It is highly probable that when we design the application, some of the pages will look similar and have common HTML code for certain features. Using template inheritance, we can inherit the common HTML code into other HTML files. This is similar to class inheritance in Python, where the parent class has all the common code, and the child class has those extras that are unique to the child's requirement.</p>
			<p>For example, let's consider the following to be a parent template that is named <strong class="source-inline">base.html</strong>:</p>
			<p class="source-code">&lt;!doctype html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">    &lt;meta charset="utf-8"&gt;</p>
			<p class="source-code">    &lt;title&gt;Hello World&lt;/title&gt;</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p class="source-code">    &lt;body&gt;</p>
			<p class="source-code">        &lt;h1&gt;Hello World using Django templates!&lt;/h1&gt;</p>
			<p class="source-code">        {% block content %}</p>
			<p class="source-code">        {% endblock %}</p>
			<p class="source-code">    &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>The following is an example of a child template:</p>
			<p class="source-code">{% extends 'base.html' %}</p>
			<p class="source-code">{% block content %}</p>
			<p class="source-code">&lt;h1&gt;How are you doing?&lt;/h1&gt;</p>
			<p class="source-code">{% endblock %}</p>
			<p>In the preceding snippet, the line <strong class="source-inline">{% extends 'base.html' %}</strong> extends the template from <strong class="source-inline">base.html</strong>, which is the parent template. After extending from the parent template, any HTML code in-between the block content will be displayed along with the parent template. Once the child template is rendered, here is how it looks in the browser:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B15509_03_05.jpg" alt="Figure 3.5: Greeting message after extending the base.html template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5: Greeting message after extending the base.html template</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor139"/>Template Styling with Bootstrap</h2>
			<p>We have seen how to display all the books using views, templates, and URL mapping. Although we were able to display all the information in the browser, it would be even better if we could add some styling and make the web page look better. For this, we can add a few elements of <strong class="bold">Bootstrap</strong>. Bootstrap is an open-source <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) framework that is particularly good for designing responsive pages that work across desktop and mobile browsers. </p>
			<p>Using Bootstrap is simple. First, you need to add the Bootstrap CSS to your HTML. You can experiment yourself by creating a new file called <strong class="source-inline">example.html</strong>. Populate it with the following code and open it in a browser:</p>
			<p class="source-code">&lt;!doctype html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    &lt;!-- Required meta tags --&gt;</p>
			<p class="source-code">    &lt;meta charset="utf-8"&gt;</p>
			<p class="source-code">    &lt;meta name="viewport" content="width=device-width,       initial-scale=1, shrink-to-fit=no"&gt;</p>
			<p class="source-code">    &lt;!-- Bootstrap CSS --&gt;</p>
			<p class="source-code">    &lt;link rel="stylesheet"       href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/      css/bootstrap.min.css" integrity="sha384-      Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q       9Ifjh" crossorigin="anonymous"&gt;</p>
			<p class="source-code">  &lt;/head&gt;</p>
			<p class="source-code">  &lt;body&gt;</p>
			<p class="source-code">    Content goes here</p>
			<p class="source-code">  &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>The Bootstrap CSS link in the preceding code adds the bootstrap CSS library to your page. This means that certain HTML element types and classes will inherit their styles from Bootstrap. For example, if you add the <strong class="source-inline">btn-primary</strong> class to the class of a button, the button will be rendered as blue with white text. Try adding the following between <strong class="source-inline">&lt;body&gt;</strong> and <strong class="source-inline">&lt;/body&gt;</strong>:</p>
			<p class="source-code">&lt;h1&gt;Welcome to my Site&lt;/h1&gt;</p>
			<p class="source-code">&lt;button type="button" class="btn btn-primary"&gt;Checkout my   Blog!&lt;/button&gt;</p>
			<p>You will see that the title and button are both styled nicely, using Bootstrap's default styles:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B15509_03_06.jpg" alt="Figure 3.6: Display after applying Bootstrap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6: Display after applying Bootstrap</p>
			<p>This is because in the Bootstrap CSS code, it specifies the color of the <strong class="source-inline">btn-primary</strong> class with the following code:</p>
			<p class="source-code">.btn-primary {</p>
			<p class="source-code">    color: #fff;</p>
			<p class="source-code">    background-color: #007bff;</p>
			<p class="source-code">    border-color: #007bff</p>
			<p class="source-code">}</p>
			<p>You can see that using third-party CSS libraries such as Bootstrap allows you to quickly create nicely styled components without needing to write too much CSS.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We recommend that you explore Bootstrap further with their tutorial here: <a href="https://getbootstrap.com/docs/4.4/getting-started/introduction/">https://getbootstrap.com/docs/4.4/getting-started/introduction/</a>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor140"/>Exercise 3.04: Adding Template Inheritance and a Bootstrap Navigation Bar</h2>
			<p>In this exercise, we will use template inheritance to inherit the template elements from a base template and re-use them in the <strong class="source-inline">book_list</strong> template to display the list of books. We will also use certain elements of Bootstrap in the base HTML file to add a navigation bar to the top of our page. The bootstrap code for <strong class="source-inline">base.html</strong> was taken from <a href="https://getbootstrap.com/docs/4.4/getting-started/introduction/">https://getbootstrap.com/docs/4.4/getting-started/introduction/</a> and <a href="https://getbootstrap.com/docs/4.4/components/navbar/">https://getbootstrap.com/docs/4.4/components/navbar/</a>:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">base.html</strong> file from the location <strong class="source-inline">bookr/templates/base.html</strong>. Remove any existing code and replace it with the following code:<p class="source-code-heading">bookr/templates/base_html</p><p class="source-code">1  &lt;!doctype html&gt;</p><p class="source-code">2  {% load static %}</p><p class="source-code">3  &lt;html lang="en"&gt;</p><p class="source-code">4    &lt;head&gt;</p><p class="source-code">5      &lt;!-- Required meta tags --&gt;</p><p class="source-code">6      &lt;meta charset="utf-8"&gt;</p><p class="source-code">7      &lt;meta name="viewport" content="width=device-width,          initial-scale=1, shrink-to-fit=no"&gt;</p><p class="source-code">8  </p><p class="source-code">9      &lt;!-- Bootstrap CSS --&gt;</p><p class="source-code-link">You can view the entire code for this file at <a href="http://packt.live/3mTjlBn">http://packt.live/3mTjlBn</a>.</p><p>This is a <strong class="source-inline">base.html</strong> file with all the Bootstrap elements for styling and the navigation bar.</p></li>
				<li>Next, open the template at <strong class="source-inline">bookr/reviews/templates/reviews/books_list.html</strong>, remove all the existing code, and replace it with the following code:<p class="source-code-heading">reviews/templates/reviews/books_list.html</p><p class="source-code">1  {% extends 'base.html' %}</p><p class="source-code">2  </p><p class="source-code">3  {% block content %}</p><p class="source-code">4  &lt;ul class="list-group"&gt;</p><p class="source-code">5    {% for item in book_list %}</p><p class="source-code">6    &lt;li class="list-group-item"&gt;</p><p class="source-code">7        &lt;span class="text-info"&gt;Title: &lt;/span&gt; &lt;span&gt;{{            item.book.title }}&lt;/span&gt;</p><p class="source-code">8        &lt;br&gt;</p><p class="source-code">9        &lt;span class="text-info"&gt;Publisher: &lt;/span&gt;&lt;span&gt;{{            item.book.publisher }}&lt;/span&gt;</p><p class="source-code-link">You can view the complete code for this file at <a href="http://packt.live/3aPJv5O">http://packt.live/3aPJv5O</a>.</p><p>This template has been configured to inherit the <strong class="source-inline">base.html</strong> file and it has also been added with a few styling elements to display the list of books. The part of the template that helps in inheriting the <strong class="source-inline">base.html</strong> file is as follows:</p><p class="source-code">{% extends 'base.html' %}</p><p class="source-code">{% block content %}</p><p class="source-code">{% endblock %}</p></li>
				<li>After adding the two new templates, open either of the URLs <strong class="source-inline">http://0.0.0.0:8000/books/</strong> or <strong class="source-inline">http://127.0.0.1:8000/books/</strong> in your web browser to see the books list page, which should now look neatly formatted:<div id="_idContainer122" class="IMG---Figure"><img src="image/B15509_03_07.jpg" alt="Figure 3.7: Neatly formatted book list page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.7: Neatly formatted book list page</p>
			<p>In this exercise, we added some styling into the application using Bootstrap and we also used template inheritance while we displayed the list of books from the book review application. So far, we have worked extensively on displaying all the books present in the application. In the next activity, you will display details and reviews of an individual book.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor141"/>Activity 3.01: Implement the Book Details View</h2>
			<p>In this activity, you will implement a new view, template, and URL mapping, to display these details of a book: title, publisher, publication date, and overall rating. In addition to these details, the page should also display all the review comments, specifying the name of the commenter and the dates on which the comments were written and (if applicable) modified. The following steps will help you complete this activity:</p>
			<ol>
				<li value="1">Create a book details endpoint that extends the base template.</li>
				<li>Create a book details view that takes a specific book's primary key as the argument and returns an HTML page listing the book's details and any associated reviews.</li>
				<li>Do the required URL mapping in <strong class="source-inline">urls.py</strong>. The book details view URL should be <strong class="source-inline">http://0.0.0.0:8000/books/1/</strong> (where <strong class="source-inline">1</strong> will represent the <strong class="source-inline">ID</strong> of the book being accessed). You can use the <strong class="source-inline">get_object_or_404</strong> method to retrieve the book with the given primary key.<p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">get_object_or_404</strong> function is a useful shortcut for retrieving an instance based on its primary key. You could also do this using the .<strong class="source-inline">get()</strong> method described in <em class="italic">Chapter 2</em>, <em class="italic">Models and Migrations</em>, <strong class="source-inline">Book.objects.get(pk=pk)</strong>. However, <strong class="source-inline">get_object_or_404</strong> has the added advantage of returning an <strong class="source-inline">HTTP 404 Not Found</strong> response if the object does not exist. If we simply use <strong class="source-inline">get()</strong> and someone attempts to access an object that does not exist, our Python code will hit an exception and return an <strong class="source-inline">HTTP 500 Server Error</strong> response. This is undesirable because it looks as though our server has failed to handle the request correctly.</p></li>
				<li>At the end of the activity, you should be able to click the <strong class="source-inline">Reviews</strong> button on the book list page and get the detail view of the book. The detail view should have all the details displayed in the following screenshot:<div id="_idContainer123" class="IMG---Figure"><img src="image/B15509_03_08.jpg" alt="Figure 3.8: Page displaying the book details&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.8: Page displaying the book details</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor142"/>Summary</h1>
			<p>This chapter covered the core infrastructure required to handle an HTTP request to our website. The request is first mapped via URL patterns to an appropriate view. Parameters from the URL are also passed into the view to specify the object displayed on the page. The view is responsible for compiling any necessary information to display on the website, and then passes this dictionary through to a template that renders the information as HTML code that can be returned as a response to the user. We covered both class- and function-based views and learned about the Django template language and template inheritance. We created two new pages for the book review application, one displaying all the books present and the other being the book details view page. In the next chapter, we will learn about Django admin and superuser, registering models, and performing CRUD operations using the admin site.</p>
		</div>
		<div>
			<div id="_idContainer125" class="Content">
			</div>
		</div>
	</body></html>