<html><head></head><body>
		<div><h1 id="_idParaDest-262" class="chapter-number"><a id="_idTextAnchor266"/>9</h1>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor267"/>Utilizing Other Advanced Features</h1>
			<p>The previous chapters have already showcased several essential core features of the FastAPI framework. However, there are features not truly inherent to the framework that can help fine-tune performance and patch missing links in our implementations. These include session handling, managing <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>)-related issues, and selecting the appropriate rendition types for an application.</p>
			<p>Aside from the built-in features, there are workaround solutions proven to work with FastAPI when applied to the application, such as its session handling mechanism, which can function well using a <code>SessionMiddleware</code>. Concerning middleware, this chapter will also explore ways of customizing request and response filters other than applying the <code>@app.middleware</code> decorator. Other issues such as using custom <code>APIRoute</code> and <code>Request</code> will be covered in this chapter to guide us on managing incoming <em class="italic">byte</em> <em class="italic">body</em>, <em class="italic">form</em>, or <em class="italic">JSON</em> data. Moreover, this chapter will highlight how to test FastAPI components using the <code>pytest</code> framework and the <code>fastapi.testclient</code> library and how we can document the endpoint using the <em class="italic">OpenAPI 3.x</em> specification.</p>
			<p>Overall, the main objective of this chapter is to provide us with other solutions that can help us complete our microservice applications. In this chapter, the following topics are included:</p>
			<ul>
				<li>Applying session management</li>
				<li>Managing the CORS mechanism</li>
				<li>Customizing <code>APIRoute</code> and <code>Request</code></li>
				<li>Choosing appropriate responses</li>
				<li>Applying the OpenAPI 3.x specification</li>
				<li>Testing the API endpoints</li>
			</ul>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor268"/>Technical requirements</h1>
			<p>Although not data analysis-related, our application prototype for this chapter is the <code>ch09</code> project.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor269"/>Applying session management</h1>
			<p>Session management is<a id="_idIndexMarker735"/> a feature used for managing requests and responses created by a user’s access to an application. It is also about creating and<a id="_idIndexMarker736"/> sharing data across a user session. Many frameworks usually include session handling features in their security plugins but not FastAPI. Creating user sessions and storing session data are two separate programming concerns in FastAPI. We use a JWT to establish a user session and Starlette’s <code>SessionMiddleware</code> to create and retrieve session data. Creating user sessions and storing session data are two entirely different programming solutions in FastAPI. We use JWT to establish a user session and Starlette’s <code>SessionMiddleware</code> to create and retrieve session data.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor270"/>Creating user sessions</h2>
			<p>We have <a id="_idIndexMarker737"/>already proven the importance of JWT when it comes to securing FastAPI microservice applications in <a href="B17975_07.xhtml#_idTextAnchor190"><em class="italic">Chapter 7</em></a><em class="italic">,</em> <em class="italic">Securing the REST APIs</em>. However, here, the JWT is applied to create a session based on user credentials. In the <code>api/login.py</code> router, an <code>authenticate()</code> API service is implemented to create a user session for an authenticated user. It is inherent for FastAPI to generate user sessions utilizing the browser cookies. The following snippet shows the authentication process that uses the cookie values:</p>
			<pre class="source-code">
from util.auth_session import <strong class="bold">secret_key</strong>
from jose import jwt
<strong class="bold">@router.post("/login/authenticate")</strong>
async def authenticate(username:str, password: str, 
   response: Response, engine=Depends(create_db_engine)):
    repo:LoginRepository = LoginRepository(engine)
    <strong class="bold">login = await repo.get_login_username(username, </strong>
                       <strong class="bold">password)</strong>
    if login == None:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, 
                detail="Invalid authentication"
            )
    <strong class="bold">token = jwt.encode({"sub": username}, secret_key)</strong>
    <strong class="bold">response.set_cookie("session", token)</strong>
    return {"username": username}</pre>
			<p>The <a id="_idIndexMarker738"/>service will verify through <code>LoginRepository</code> whether the user is a valid account using its <code>username</code> and <code>password</code> credentials. If the user is a certified one, it will use a JWT to create a token derived from a certain <code>secret_key</code> generated using the following command:</p>
			<pre>openssl rand -hex 32</pre>
			<p>The token key will serve as the session ID of the cookie-based session. With the <code>username</code> credential as its payload, the JWT will be stored as a browser cookie named <code>session</code>.</p>
			<p>To ensure that <code>session</code> has been applied, all subsequent requests must undergo authentication by the cookie-based session through the <code>APIKeyCookie</code> class, an API class of the <code>fastapi.security</code> module that implements cookie-based authentication. The <code>APIKeyCookie</code> class fetches the session before it is injected into a dependable function for the JWT decoding through the <code>secret_key</code> value used to generate the<a id="_idIndexMarker739"/> session ID. The following dependable function in <code>util/auth_session.py</code> will verify every access to each endpoint of the application: </p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import APIKeyCookie</strong>
from jose import jwt
<strong class="bold">cookie_sec = APIKeyCookie(name="session")</strong>
secret_key = "pdCFmblRt4HWKNpWkl52Jnq3emH3zzg4b80f+4AFVC8="
async def get_current_user(<strong class="bold">session: str = </strong>
<strong class="bold">   Depends(cookie_sec)</strong>, engine=Depends(create_db_engine)):
    try:
        <strong class="bold">payload = jwt.decode(session, secret_key)</strong>
        repo:LoginRepository = LoginRepository(engine)
        <strong class="bold">login = await repo.validate_login(</strong>
                    <strong class="bold">payload["sub"])</strong>
        if login == None:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, 
                detail="Invalid authentication"
            )
        else:
            return login
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="Invalid authentication"
        )</pre>
			<p>The preceding function is injected into every API endpoint to impose user session verification. When an endpoint is requested, this function will decode the token and extract the <code>username</code> credential for account validation. Then, it will issue <em class="italic">Status Code 403 (Forbidden)</em> if the <a id="_idIndexMarker740"/>user is an <em class="italic">unauthenticated</em> one or the <em class="italic">session is not valid</em>. An example of an authenticated service can be found in the following implementation:</p>
			<pre class="source-code">
<strong class="bold">from util.auth_session import get_current_user</strong>
<strong class="bold">@router.post("/restaurant/add")</strong>
async def add_restaurant(req:RestaurantReq, 
         engine=Depends(create_db_engine), 
         <strong class="bold">user: str = Depends(get_current_user)</strong>):
    restaurant_dict = req.dict(exclude_unset=True) 
    restaurant_json = dumps(restaurant_dict, 
              default=json_datetime_serializer)
    repo:RestaurantRepository = 
             RestaurantRepository(engine)
    result = await repo.insert_restaurant(
               loads(restaurant_json))
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
         "insert login unsuccessful"}, status_code=500)</pre>
			<p>The <code>add_restaurant()</code> service is an endpoint that adds a restaurant <code>Document</code> to the MongoDB collection. But before <a id="_idIndexMarker741"/>the transaction proceeds, it checks first whether there is a cookie-based session through the injected <code>get_current_user()</code> dependable function. </p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor271"/>Managing session data</h2>
			<p>Unfortunately, adding<a id="_idIndexMarker742"/> and retrieving session data is not part of <code>APIKeyCookie</code>-based session authentication. The JWT payload must only include the username but not all credentials and body of data. To manage session data, we need to create a separate session using Starlette’s <code>SessionMiddleware</code>. Although FastAPI has its <code>fastapi.middleware</code> module, it still supports Starlette’s built-in middleware.</p>
			<p>We mentioned middleware in <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Exploring the Core Features</em>, and showed its implementation using the <code>@app.middleware</code> decorator. And we have proven that it acts as a filter for all incoming requests and outgoing responses to the services. This time, we will not custom implement a middleware but built-in middleware classes.</p>
			<p>Middleware is implemented, configured, and activated in the <code>main.py</code> module where the instance of <code>FastAPI</code> is located because <code>APIRouter</code> cannot add middleware. We enable the <code>middleware</code> parameter of the FastAPI constructor and add to that List-type parameter the built-in <code>SessionMiddleware</code> with its <code>secret_key</code> and the name of the new session as constructor parameters using the injectable class, <code>Middleware</code>. The following code snippet of <code>main.py</code> shows you how to configure this:</p>
			<pre class="source-code">
<strong class="bold">from starlette.middleware.sessions import SessionMiddleware</strong>
app = FastAPI(<strong class="bold">middleware=[</strong>
        <strong class="bold">Middleware(SessionMiddleware, </strong>
        <strong class="bold">secret_key=</strong>
            <strong class="bold">'7UzGQS7woBazLUtVQJG39ywOP7J7lkPkB0UmDhMgBR8=', </strong>
        <strong class="bold">session_cookie="session_vars")]</strong>)</pre>
			<p>Another way of adding middleware is to utilize the <code>add_middleware()</code> function of the <code>FastAPI</code> decorator. Initially, adding <code>SessionMiddleware</code> will create another cookie-based session that will handle <em class="italic">session-scoped data</em>. It is the only way since there is no direct support from FastAPI regarding session handling mechanisms where a user session is created not only for security but also for handling session objects.</p>
			<p>To add <a id="_idIndexMarker743"/>session data to our newly created session, <code>session_vars</code>, we need to inject <code>Request</code> into each endpoint service and utilize its session dictionary to store the session-scoped objects. The following <code>list_restaurants()</code> service retrieves the list of restaurants from the database, extracts all the restaurant names, and shares the list of names across the session through <code>request.session[]</code>:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/restaurant/list/all")</strong>
async def list_restaurants(request: Request, 
       engine=Depends(create_db_engine), 
       user: str = Depends(get_current_user)):
    repo:RestaurantRepository = 
             RestaurantRepository(engine)
    result = await repo.get_all_restaurant()
    <strong class="bold">resto_names = [resto.name for resto in result]</strong>
    <strong class="bold">request.session['resto_names'] = resto_names</strong>
    return result
<strong class="bold">@router.get("/restaurant/list/names")</strong>
async def list_restaurant_names(request: Request, 
           user: str = Depends(get_current_user)):
    <strong class="bold">resto_names = request.session['resto_names']</strong>
    return resto_names</pre>
			<p>On the other hand, the <code>list_restaurant_names()</code> service retrieves the <code>resto_names</code> session data through <code>request.session[]</code> and returns it as its response. By the<a id="_idIndexMarker744"/> way, it is due to <code>SessionMiddleware</code> that <code>session[]</code> exists. Otherwise, the use of this dictionary will raise an change to - exception.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor272"/>Removing the sessions</h2>
			<p>It is always <a id="_idIndexMarker745"/>mandatory to log out from the application when done with the transactions to remove all the sessions created. Since the easiest and most direct way of creating sessions is through browser cookies, removing all the sessions protects the application from any compromise. The following <code>/ch09/logout</code> endpoint removes our sessions, <code>session</code> and <code>session_vars</code>, which technically logs out the user from the application:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/logout")</strong>
async def logout(response: Response, 
            user: str = Depends(get_current_user)):
    <strong class="bold">response.delete_cookie("session")</strong>
    <strong class="bold">response.delete_cookie("session_vars")</strong>
    return {"ok": True}</pre>
			<p>The <code>delete_cookie()</code> method of the <code>Response</code> class removes any existing browser session utilized by the application.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor273"/>Customizing BaseHTTPMiddleware</h2>
			<p>The default <a id="_idIndexMarker746"/>approach in managing FastAPI sessions is through cookies, and it does not offer any other options such as <a id="_idIndexMarker747"/>database-backed, cached, and file-based sessions. The best way to implement non-cookie-based strategies for managing user sessions and session data is to customize <code>BaseHTTPMiddleware</code>. The following custom middleware is a prototype that creates user sessions for authenticated users:</p>
			<pre class="source-code">
from repository.login import LoginRepository
<strong class="bold">from repository.session import DbSessionRepository</strong>
<strong class="bold">from starlette.middleware.base import BaseHTTPMiddleware</strong>
from datetime import date, datetime
import re
from odmantic import AIOEngine
from motor.motor_asyncio import AsyncIOMotorClient
<strong class="bold">class SessionDbMiddleware(BaseHTTPMiddleware):</strong>
    def __init__(self, app, sess_key: str, 
                    sess_name:str, expiry:str):
        super().__init__(app)
        self.sess_key = sess_key
        self.sess_name = sess_name 
        self.expiry = expiry
        self.client_od = 
         AsyncIOMotorClient(f"mongodb://localhost:27017/")
        self.engine = 
         AIOEngine(motor_client=self.client_od, 
            database="orrs")
                
    async def dispatch(self, request: Request, call_next):
        try:
            if re.search(r'\bauthenticate\b', 
                    request.url.path):
                credentials = request.query_params
                username = credentials['username']
                password = credentials['password']
                repo_login:LoginRepository = 
                      LoginRepository(self.engine)
                <strong class="bold">repo_session:DbSessionRepository = </strong>
                      <strong class="bold">DbSessionRepository(self.engine)</strong>
               
                login = await repo_login.
                  get_login_credentials(username, password)
               
                if login == None:
                    self.client_od.close()
                    return JSONResponse(status_code=403) 
                else:
                    <strong class="bold">token = jwt.encode({"sub": username}, </strong>
                        <strong class="bold">self.sess_key)</strong>
                    <strong class="bold">sess_record = dict()</strong>
                    <strong class="bold">sess_record['session_key'] = </strong>
                        <strong class="bold">self.sess_key</strong>
                    <strong class="bold">sess_record['session_name'] = </strong>
                        <strong class="bold">self.sess_name</strong>
                    <strong class="bold">sess_record['token'] = token</strong>
                    <strong class="bold">sess_record['expiry_date'] = </strong>
                       <strong class="bold">datetime.strptime(self.expiry, </strong>
                            <strong class="bold">'%Y-%m-%d')</strong>
                    <strong class="bold">await repo_session.</strong>
                        <strong class="bold">insert_session(sess_record)</strong>
                    <strong class="bold">self.client_od.close()</strong>
                    <strong class="bold">response = await call_next(request)</strong>
                    return response
            else:
                response = await call_next(request)
                return response
        except Exception as e :
            return JSONResponse(status_code=403)</pre>
			<p>As <a id="_idIndexMarker748"/>discussed in <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Exploring the Core Features</em>, <code>SessionDbMiddleware</code> will filter our <code>/ch09/login/authenticate</code> endpoint for the <code>username</code> and <code>password</code> query parameters, check whether the user is a registered one, and <a id="_idIndexMarker750"/>generate a database-backed session from the JWT. Afterward, endpoints can validate all their requests from the session stored in the database. The <code>/ch09/logout</code> endpoint will not include the deletion of the session from the database using its repository transactions, as shown in the following code:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/logout")</strong>
async def logout(response: Response, 
       <strong class="bold">engine=Depends(create_db_engine), </strong>
       user: str = Depends(get_current_user)):
    <strong class="bold">repo_session:DbSessionRepository = </strong>
<strong class="bold">             DbSessionRepository(engine)</strong>
    <strong class="bold">await repo_session.delete_session("session_db")</strong>
    return {"ok": True}</pre>
			<p>Note that <code>DbSessionRepository</code> is a custom repository implementation for our prototype, and<a id="_idIndexMarker751"/> it has a <code>delete_session()</code> method that will remove the session through its <a id="_idIndexMarker752"/>name from the <code>db_session</code> collection of our MongoDB database. </p>
			<p>Another type of middleware that can help FastAPI applications resolve issues regarding the CORS browser mechanism is <code>CORSMiddleware</code>. </p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor274"/>Managing the CORS mechanism</h1>
			<p>When<a id="_idIndexMarker753"/> integrating API endpoints with various frontend frameworks, we often encounter the "<em class="italic">no ‘access-control-allow-origin’ header present</em>" error from our browser. Nowadays, this setup is an HTTP-header-based mechanism of any browser, which requires the backend server to provide the browser with the "origin" details of the server-side application, which includes the server domain, scheme, and port. This mechanism is called CORS, which happens when the frontend application and its web resources belong to a different domain area than the backend app. Nowadays, browsers prohibit cross-origin requests between the server-side and frontend applications for security reasons.</p>
			<p>To resolve this issue, we need our <code>main.py</code> module to place all the origins of our application and other integrated resources used by the prototype inside a <code>List</code>. Then, we import the built-in <code>CORSMiddleware</code> from the <code>fastapi.middleware.cors</code> module and add that to the <code>FastAPI</code> constructor with the list of origins, which should not be too long to avoid overhead from validating each URL. The following code snippet shows the injection of <code>CORSMiddleware</code> into the <code>FastAPI</code> constructor:</p>
			<pre class="source-code">
<strong class="bold">origins = [</strong>
    <strong class="bold">"https://192.168.10.2",</strong>
    <strong class="bold">"http://192.168.10.2",</strong>
    <strong class="bold">"https://localhost:8080",</strong>
    <strong class="bold">"http://localhost:8080"</strong>
<strong class="bold">]</strong>
app = FastAPI(middleware=[
           Middleware(SessionMiddleware, <strong class="bold">secret_key</strong>=
            '7UzGQS7woBazLUtVQJG39ywOP7J7lkPkB0UmDhMgBR8=', 
               session_cookie="session_vars"),
           Middleware(SessionDbMiddleware, <strong class="bold">sess_key</strong>=
            '7UzGQS7woBazLUtVQJG39ywOP7J7lkPkB0UmDhMgBR8=',
              sess_name='session_db', expiry='2020-10-10')
            ])
<strong class="bold">app.add_middleware(CORSMiddleware, max_age=3600,</strong>
     <strong class="bold">allow_origins=origins, allow_credentials=True,</strong>
     <strong class="bold">allow_methods= ["POST", "GET", "DELETE", </strong>
       <strong class="bold">"PATCH", "PUT"], allow_headers=[</strong>
            <strong class="bold">"Access-Control-Allow-Origin", </strong>
            <strong class="bold">"Access-Control-Allow-Credentials", </strong>
            <strong class="bold">"Access-Control-Allow-Headers",</strong>
            <strong class="bold">"Access-Control-Max-Age"</strong>])</pre>
			<p>This time, we <a id="_idIndexMarker754"/>used FastAPI’s <code>add_middleware()</code> function to add CORS support to our application. Aside from <code>allow_origins</code>, we also need to add into <code>CORSMiddleware</code> the <code>allow_credentials</code> parameter, which adds <code>Access-Control-Allow-Credentials: true</code> to the response header for the browser to recognize the domain origin matches and send an <code>Authorization</code> cookie to allow the request. Also, we must include the <code>allow_headers</code> parameter, which registers a list of acceptable header keys during browser interaction. Aside from <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, and <code>Content-Type</code>, which are included by default, we need to register <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Credentials</code>, <code>Access-Control-Allow-Headers</code>, and <code>Access-Control-Max-Age</code> explicitly instead of using the asterisk (<code>*</code>). The <code>allow_headers</code> parameter must also be part of the middleware to specify other HTTP methods that need to be supported by the browser. And lastly, the <code>max_age</code> parameter must also be in the configuration because we need to tell the browser the amount of time it will cache all the resources loaded into the browser.</p>
			<p>If the application<a id="_idIndexMarker755"/> needs additional CORS support features, customizing the <code>CORSMiddleware</code> to extend some built-in utilities and features to manage CORS is a better solution. </p>
			<p>By the way, it is not only the middleware that we can subclass and use to create custom implementations of but also the <code>Request</code> data and API routes. </p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor275"/>Customizing APIRoute and Request</h1>
			<p>Middleware <a id="_idIndexMarker756"/>can process incoming <code>Request</code> data and outgoing <code>Response</code> objects of all API methods in a FastAPI application, except that it cannot manipulate the message body, attach state objects from the <code>Request</code> data, or modify the response object before the client consumes it. Only <code>APIRoute</code> and <code>Request</code> customization can give us a full grasp of how to control the request and response transaction. The control might include determining whether the incoming data is a byte body, form, or JSON and providing an effective logging mechanism, exception handling, content transformation, and extraction.  </p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor276"/>Managing body, form, or JSON data</h2>
			<p>Unlike in <a id="_idIndexMarker757"/>middleware, customizing <code>APIRoute</code> does not apply to all the API endpoints. Implementing <code>APIRoute</code> for some <code>APIRouter</code> will only impose new routing rules to those affected endpoints, while the other services can pursue the default request and response <a id="_idIndexMarker758"/>process. For<a id="_idIndexMarker759"/> instance, the following customization is responsible for data extraction that only applies to the endpoints of <code>api.route_extract.router</code>:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.routing import APIRoute</strong>
from typing import Callable
from fastapi import Request, Response
<strong class="bold">class ExtractContentRoute(APIRoute):</strong>
    def get_route_handler(self) -&gt; Callable:
        original_route_handler = 
                super().get_route_handler()
        
        <strong class="bold">async def custom_route_handler(request: Request) </strong>
                    <strong class="bold">-&gt; Response:</strong>
            <strong class="bold">request = ExtractionRequest(request.scope, </strong>
                        <strong class="bold">request.receive)</strong>
            response: Response = <strong class="bold">await </strong>
                    <strong class="bold">original_route_handler(request)</strong>
            return response
        <strong class="bold">return custom_route_handler</strong></pre>
			<p>Customizing <code>APIRoute</code> requires <a id="_idIndexMarker760"/>the creation of a Python <code>Request</code> and <code>Response</code> flow from <code>APIRoute</code>’s <code>original_route_handler</code>. On the other hand, our <code>ExtractContentRoute</code> filter uses a custom <code>ExtractionRequest</code> that identifies and processes each type of incoming request data separately. The<a id="_idIndexMarker762"/> following is the implementation of <code>ExtractionRequest</code> that will replace the default <code>Request</code> object: </p>
			<pre class="source-code">
<strong class="bold">class ExtractionRequest(Request):</strong>
    <strong class="bold">async def body(self):</strong>
        <strong class="bold">body = await super().body()</strong>
        data = ast.literal_eval(body.decode('utf-8'))
        <strong class="bold">if isinstance(data, list):</strong>
            sum = 0
            for rate in data:
                sum += rate 
            average = sum / len(data)
            self.state.sum = sum 
            self.state.avg = average
        return body 
    
    <strong class="bold">async def form(self):</strong>
        <strong class="bold">body = await super().form()</strong>
        user_details = dict()
        user_details['fname'] = body['firstname']
        user_details['lname'] = body['lastname']
        user_details['age'] = body['age']
        user_details['bday'] = body['birthday']
        self.session["user_details"] = user_details
        return body
    
    <strong class="bold">async def json(self):</strong>
        <strong class="bold">body = await super().json()</strong>
        <strong class="bold">if isinstance(body, dict):</strong>
                
            sum = 0
            for rate in body.values():
                sum += rate  
                    
            average = sum / len(body.values())
            self.state.sum = sum 
            self.state.avg = average
        return body</pre>
			<p>To <a id="_idIndexMarker763"/>activate this <code>ExtractionRequest</code>, we need to set the <code>route_class</code> of the <code>APIRouter</code> of the<a id="_idIndexMarker764"/> endpoints to <code>ExtractContentRoute</code>, as <a id="_idIndexMarker765"/>shown in the following snippet:</p>
			<pre class="source-code">
router = APIRouter()
<strong class="bold">router.route_class = ExtractContentRoute</strong></pre>
			<p>There are three methods of choice to override when managing various request bodies:</p>
			<ul>
				<li><code>body()</code>: This manages incoming request data that is in bytes</li>
				<li><code>form()</code>: This processes incoming form data</li>
				<li><code>json()</code>: This manages incoming parsed JSON data</li>
				<li><code>stream()</code>: This accesses the body via a chunk of bytes using the <code>async for</code> construct</li>
			</ul>
			<p>All of these methods return the original request body in bytes back to the service.</p>
			<p>In <code>ExtractionRequest</code>, we have implemented three interface methods from the given choices to filter and process all incoming requests of the API endpoints defined in the <code>/api/route_extract.py</code> module.</p>
			<p>The following <code>create_profile()</code> service accepts profile data from the client and implements the <code>ExtractContentRoute</code> filter, which will store all of this profile data in the dictionary using session handling:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/user/profile")</strong>
async def create_profile(req: Request, 
        <strong class="bold">firstname: str = Form(...), </strong>
        <strong class="bold">lastname: str = Form(...), age: int = Form(...), </strong>
        <strong class="bold">birthday: date = Form(...), </strong>
        user: str = Depends(get_current_user)):
    user_details = <strong class="bold">req.session["user_details"]</strong>
    return {'profile' : user_details} </pre>
			<p>The overridden <code>form()</code> method of <code>ExtractionRequest</code> is responsible for the <code>user_details</code> attribute containing all the user details.</p>
			<p>On the other<a id="_idIndexMarker766"/> hand, the<a id="_idIndexMarker767"/> given <code>set_ratings()</code> method<a id="_idIndexMarker768"/> has an incoming dictionary of various ratings in which the <code>json()</code> override will derive some basic statistics. All the results will be returned as <code>Request</code>’s state objects or request attributes:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/rating/top/three")</strong>
async def set_ratings(req: Request, data : 
 <strong class="bold">Dict[str, float],</strong> user: str = Depends(get_current_user)):
    stats = dict()
    stats['sum'] = <strong class="bold">req.state.sum</strong>
    stats['average'] = <strong class="bold">req.state.avg</strong>
    return {'stats' : stats } </pre>
			<p>And lastly, the preceding <code>compute_data()</code> service will have an incoming list of ratings as a source of some basic statistics like in the previous service. The <code>body()</code> method override of <code>ExtractionRequest</code> will process the computation:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/rating/data/list")</strong>
async def compute_data(req: Request, <strong class="bold">data: List[float]</strong>, 
  user: str = Depends(get_current_user)):
    stats = dict()
    stats['sum'] = <strong class="bold">req.state.sum</strong>
    stats['average'] = <strong class="bold">req.state.avg</strong>
    return {'stats' : stats }</pre>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor277"/>Encrypting and decrypting the message body</h2>
			<p>Another scenario <a id="_idIndexMarker769"/>where we need to<a id="_idIndexMarker770"/> customize the routing of the endpoints is when we must secure the message body through encryption. The following custom request decrypts an encrypted body using Python’s <code>cryptography</code> module<a id="_idIndexMarker771"/> and the key of the encrypted body:</p>
			<pre class="source-code">
from cryptography.fernet import Fernet
<strong class="bold">class DecryptRequest(Request):</strong>
    async def body(self):
        <strong class="bold">body = await super().body()</strong>
        login_dict = ast.literal_eval(body.decode('utf-8'))
        fernet = Fernet(bytes(login_dict['key'], 
             encoding='utf-8'))
        <strong class="bold">data = fernet.decrypt(</strong>
          <strong class="bold">bytes(login_dict['enc_login'], encoding='utf-8'))</strong>
        self.state.dec_data = json.loads(
             data.decode('utf-8'))
        return body</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <code>cryptography</code> module requires the installation of the <code>itsdangerous</code> extension for the encryption/decryption procedure used in this project.</p>
			<p><code>DecryptRequest</code> will <a id="_idIndexMarker772"/>decrypt the message and return the list of login records as a request <code>state</code> object. The following service provides the encrypted message body and key and returns the decrypted list of login records from <code>DecryptRequest</code> as a response:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/login/decrypt/details")</strong>
async def send_decrypt_login(<strong class="bold">enc_data: EncLoginReq</strong>, 
   req:Request, user: str = Depends(get_current_user)):
    return {"data" : req.state.dec_data}</pre>
			<p>Note that <code>send_decrypt_login()</code> has an <code>EncLoginReq</code> request model that contains the encrypted message body and the encryption key from the client. </p>
			<p>Customizing the<a id="_idIndexMarker773"/> routes and their <code>Request</code> objects <a id="_idIndexMarker774"/>can help optimize and streamline microservice transactions, especially those API endpoints that require heavy loads on message body conversions, transformations, and computations.</p>
			<p>Now, our next discussion will focus on applying different <code>Response</code> types for the API services.</p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor278"/>Choosing the appropriate responses</h1>
			<p>The FastAPI framework offers other options for rendering API endpoint responses other than the <a id="_idIndexMarker775"/>most common <code>JsonResponse</code> option. Here<a id="_idIndexMarker776"/> is a list of some of the response types supported by FastAPI and their corresponding samples from our application:</p>
			<ul>
				<li>The API endpoints can utilize<a id="_idIndexMarker777"/> the <code>PlainTextResponse</code> type if their response is text-based only. The following <code>intro_list_restaurants()</code> service returns a text-based message to the client: <pre><strong class="bold">@router.get("/restaurant/index")</strong>
def intro_list_restaurants():
  return <strong class="bold">PlainTextResponse(content="The Restaurants")</strong></pre></li>
				<li>Services can<a id="_idIndexMarker778"/> use <code>RedirectResponse</code> if they need to pursue navigation to another entirely different application or another endpoint of the same application. The following endpoint jumps to a hypertext reference about some known Michelin-starred restaurants:<pre><strong class="bold">@router.get("/restaurant/michelin")</strong>
def redirect_restaurants_rates():
  return <strong class="bold">RedirectResponse(</strong>
      <strong class="bold">url="https://guide.michelin.com/en/restaurants")</strong></pre></li>
				<li>A <code>FileResponse</code> type <a id="_idIndexMarker779"/>can help <a id="_idIndexMarker780"/>services render some content of a file, preferably text-based files. The following <code>load_questions()</code> service shows the list of questions saved in the <code>questions.txt</code> file placed inside the <code>/file</code> folder of the application:<pre><strong class="bold">@router.get("/question/load/questions")</strong>
async def load_questions(user: str = 
                    Depends(get_current_user)):
    <strong class="bold">file_path = os.getcwd() + </strong>
<strong class="bold">      '\\files\\questions.txt';</strong>
    return <strong class="bold">FileResponse(path=file_path,</strong> 
                 <strong class="bold">media_type="text/plain")</strong></pre></li>
				<li><code>StreamingResponse</code> is another<a id="_idIndexMarker781"/> response type that <a id="_idIndexMarker782"/>can provide us with another approach to the <code>EventSourceResponse</code> type:<pre><strong class="bold">@router.get("/question/sse/list")    </strong>
async def list_questions(req:Request, 
         engine=Depends(create_db_engine), 
            user: str = Depends(get_current_user)):
    async def print_questions():
        repo:QuestionRepository = 
                QuestionRepository(engine)
        result = await repo.get_all_question()
        for q in result:
            disconnected = await req.is_disconnected()
            if disconnected:
                break
            <strong class="bold">yield 'data: {}\n\n.format(</strong>
               <strong class="bold">json.dumps(jsonable_encoder(q), </strong>
                      <strong class="bold">cls=MyJSONEncoder))</strong>
            await asyncio.sleep(1)
    return <strong class="bold">StreamingResponse(print_questions(),</strong> 
                <strong class="bold">media_type="text/event-stream")</strong></pre></li>
				<li>Services<a id="_idIndexMarker784"/> that render images can also use<a id="_idIndexMarker785"/> the <code>StreamingResponse</code> type. The following <code>logo_upload_png()</code> service uploads any <strong class="bold">JPEG</strong> or <strong class="bold">PNG</strong> file and renders it in the browser:<pre><strong class="bold">@router.post("/restaurant/upload/logo")</strong>
async def logo_upload_png(<strong class="bold">logo: UploadFile = File(...)</strong>):
    original_image = Image.open(logo.file)
    original_image = 
         original_image.filter(ImageFilter.SHARPEN)
    <strong class="bold">filtered_image = BytesIO()</strong>
    if logo.content_type == "image/png":
        original_image.save(filtered_image, "PNG")
        filtered_image.seek(0)
        return <strong class="bold">StreamingResponse(filtered_image, </strong>
                 <strong class="bold">media_type="image/png")</strong>
    elif logo.content_type == "image/jpeg":
        original_image.save(filtered_image, "JPEG")
        filtered_image.seek(0)
        return <strong class="bold">StreamingResponse(filtered_image,</strong> 
               <strong class="bold">media_type="image/jpeg") </strong></pre></li>
				<li>The <code>StreamingResponse</code> type is <a id="_idIndexMarker786"/>also effective in rendering videos in various formats such as <code>sample.mp4</code> and publishes it to the browser:<pre><strong class="bold">@router.get("/restaurant/upload/video")</strong>
def video_presentation():
    file_path = os.getcwd() + '\\files\\sample.mp4'
    def load_file():  
        with open(file_path, mode="rb") as video_file:  
            yield from video_file  
    return <strong class="bold">StreamingResponse(load_file(),</strong> 
              <strong class="bold">media_type="video/mp4")</strong></pre></li>
				<li>If the<a id="_idIndexMarker788"/> service wants to publish a simple HTML markup page without making references to static CSS or JavaScript files, then <code>HTMLResponse</code> is the right choice. The <a id="_idIndexMarker789"/>following service renders an HTML page with a Bootstrap framework provided by some CDN libraries:<pre><strong class="bold">@router.get("/signup")</strong>
async def signup(engine=Depends(create_db_engine), 
       user: str = Depends(get_current_user) ):
   signup_content = """
    &lt;html lang='en'&gt;
        &lt;head&gt;
          &lt;meta charset="UTF-8"&gt;
          &lt;script src="https://code.jquery.com/jquery-
                    3.4.1.min.js"&gt;&lt;/script&gt;
          &lt;link rel="stylesheet" 
            href="https://stackpath.bootstrapcdn.com/
              bootstrap/4.4.1/css/bootstrap.min.css"&gt;
          &lt;script src="https://cdn.jsdelivr.net/npm/
            popper.js@1.16.0/dist/umd/popper.min.js"&gt;
          &lt;/script&gt;
          &lt;script   
           src="https://stackpath.bootstrapcdn.com/
       bootstrap/4.4.1/js/bootstrap.min.js"&gt;&lt;/script&gt;
   
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div class="container"&gt;
            &lt;h2&gt;Sign Up Form&lt;/h2&gt;
            &lt;form&gt;
                &lt;div class="form-group"&gt;
                   &lt;label for="firstname"&gt;
                          Firstname:&lt;/label&gt;
                   &lt;input type='text' 
                       class="form-control" 
                       name='firstname' 
                       id='firstname'/&gt;&lt;br/&gt;
                &lt;/div&gt;
                … … … … … … … …
                &lt;div class="form-group"&gt;
                   &lt;label for="role"&gt;Role:&lt;/label&gt;
                   &lt;input type='text' 
                     class="form-control" 
                     name='role' id='role'/&gt;&lt;br/&gt;
                &lt;/div&gt;
                &lt;button type="submit" class="btn 
                    btn-primary"&gt;Sign Up&lt;/button&gt;
            &lt;/form&gt;
           &lt;/div&gt;
        &lt;/body&gt;
    &lt;/html&gt;
    """
    <strong class="bold">return HTMLResponse(content=signup_content, </strong>
               <strong class="bold">status_code=200)</strong></pre></li>
				<li>If the <a id="_idIndexMarker790"/>API endpoints have other rendition types needed to be published, the <code>Response</code> class can customize them through its <code>media_type</code> property. The following is a service that converts JSON data into XML content by setting the <code>media_type</code> property of <code>Response</code> to the <code>application/xml</code> MIME type:  <pre><strong class="bold">@router.get("/keyword/list/all/xml")</strong>
async def 
   convert_to_xml(engine=Depends(create_db_engine), 
        user: str = Depends(get_current_user)): 
    repo:KeyRepository = KeyRepository(engine)
    list_of_keywords = await repo.get_all_keyword()
    root = minidom.Document() 
    xml = root.createElement('keywords') 
    root.appendChild(xml) 
  
    for keyword in list_of_keywords:
        key = root.createElement('keyword')
        word = root.createElement('word')
        key_text = root.createTextNode(keyword.word)
        weight= root.createElement('weight')
        weight_text = 
             root.createTextNode(str(keyword.weight))
        word.appendChild(key_text)
        weight.appendChild(weight_text)
        key.appendChild(word)
        key.appendChild(weight)
        xml.appendChild(key)
    <strong class="bold">xml_str = root.toprettyxml(indent ="\t") </strong>
    return <strong class="bold">Response(content=xml_str,</strong> 
            <strong class="bold">media_type="application/xml")</strong></pre></li>
			</ul>
			<p>Although FastAPI is <a id="_idIndexMarker791"/>not a web framework, it can support Jinja2 templating for rare cases where API services require rendering their response as an HTML page. Let us highlight how API services utilize Jinja2 templates as part of the response. </p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor279"/>Setting up the Jinja2 template engine</h2>
			<p>First, we need to install the <code>jinja2</code> module using <code>pip</code>: </p>
			<pre>pip install jinja2</pre>
			<p>Then, we <a id="_idIndexMarker792"/>need to create a folder that will hold all the Jinja2 templates. Jinja2 must define this folder, usually named <code>templates</code>, by creating the <code>Jinja2Templates</code> instance in <code>FastAPI</code> or any <code>APIRouter</code>. The following snippet is part of the <code>/api/login.py</code> router that <a id="_idIndexMarker793"/>shows the setup and configuration of the Jinja2 templating engine:</p>
			<pre class="source-code">
from fastapi.templating import Jinja2Templates
router = APIRouter()
<strong class="bold">templates = Jinja2Templates(directory="templates")</strong></pre>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor280"/>Setting up the static resources</h2>
			<p>After the<a id="_idIndexMarker794"/> <code>templates</code> folder, the Jinja2 engine requires the application to have a folder named <code>static</code> in the project directory to hold the CSS, JavaScript, images, and other static files for the Jinja2 templates. Then, we need to instantiate the <code>StaticFiles</code> instance to define the <code>static</code> folder and map it with a virtual name. Additionally, the <code>StaticFiles</code> instance must be mounted to a specific path through <code>FastAPI</code>’s <code>mount()</code> method. We also need to set the <code>html</code> property of the <code>StaticFiles</code> instance to <code>True</code> to set the folder in HTML mode. The following configuration shows how to set up the static resource folder in the <code>main.py</code> module:</p>
			<pre class="source-code">
from fastapi.staticfiles import StaticFiles
<strong class="bold">app.mount("/static", StaticFiles(directory="static", </strong>
          <strong class="bold">html=True), name="static")</strong></pre>
			<p>For the FastAPI components to access these static files, the engine needs the <code>aiofiles</code> extension installed: </p>
			<pre>pip install aiofiles</pre>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor281"/>Creating the template layout</h2>
			<p>The following <a id="_idIndexMarker795"/>template is the <code>static</code> folder due to the template engine and <code>aiofiles</code> module:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta http-equiv="X-UA-Compatible" 
              content="IE=edge"&gt;
        &lt;meta name="viewport" content="width=device-width, 
             initial-scale=1.0, shrink-to-fit=no"&gt;
        &lt;meta name="apple-mobile-web-app-capable" 
             content="yes"&gt;
        
        &lt;link rel="stylesheet" type="text/css" 
            href="{{url_for('static', 
               path='/css/bootstrap.min.css')}}"&gt;
        &lt;script src="{{url_for('static', path='/js/
               jquery-3.6.0.js')}}"&gt;&lt;/script&gt;
        &lt;script src="{{url_for('static', 
              path='/js/bootstrap.min.js')}}"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        <strong class="bold">{% block content %}</strong>
        <strong class="bold">{% endblock content %}</strong>
    &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>Other templates can <a id="_idIndexMarker796"/>inherit the structure and design of this <code>layout.html</code> using the <code>{% extends %}</code> tags. The Jinja2 base template, like our <code>layout.html</code>, has these Jinja2 tags, namely the <code>{% block content %}</code> and <code>{% endblock %}</code> tags, which indicate where child templates can insert their content during the translation phase. But for all these templates to work, they must be saved in the <code>/templates</code> directory. The following is a sample child template named <code>users.html</code> that generates a table of profiles from the context data:</p>
			<pre class="source-code">
<strong class="bold">{% extends "layout.html" %}</strong>
<strong class="bold">{% block content %}</strong>
&lt;div class="container"&gt;
&lt;h2&gt;List of users &lt;/h2&gt;
&lt;p&gt;This is a Boostrap 4 table applied to JinjaTemplate.&lt;/p&gt;
&lt;table class="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Login ID&lt;/th&gt;
          &lt;th&gt;Username&lt;/th&gt;
          &lt;th&gt;Password&lt;/th&gt;
          &lt;th&gt;Passphrase&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
    {% for login in data %} 
    &lt;tr&gt;
        &lt;td&gt;{{ login.login_id}}&lt;/td&gt;
        &lt;td&gt;{{ login.username}}&lt;/td&gt;
        &lt;td&gt;{{ login.password}}&lt;/td&gt;
        &lt;td&gt;{{ login.passphrase}}&lt;/td&gt;
    &lt;/tr&gt;
    {% endfor%}
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
<strong class="bold">{% endblock %}</strong></pre>
			<p>Observe <a id="_idIndexMarker797"/>that the child Jinja2 template also has the "block" tags to mark the content to be merged into the parent template. </p>
			<p>For the API to render the templates, the service must use the Jinja2 engine’s <code>TemplateResponse</code> type as the response type. <code>TemplateResponse</code> needs the filename of the template, the <code>Request</code> object, and the context data if there is any. The following is the API service that renders the previous <code>users.html</code> template:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/login/html/list")</strong>
async def list_login_html(req: Request,
       engine=Depends(create_db_engine), 
       user: str = Depends(get_current_user)):
    repo:LoginRepository = LoginRepository(engine)
    result = await repo.get_all_login()
    return <strong class="bold">templates.TemplateResponse("users.html",</strong> 
           <strong class="bold">{"request": req, "data": result})</strong></pre>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor282"/>Using ORJSONResponse and UJSONResponse</h2>
			<p>When it <a id="_idIndexMarker798"/>comes to yielding numerous <a id="_idIndexMarker799"/>dictionaries or JSON-able-components, it is appropriate to <a id="_idIndexMarker800"/>use either <code>ORJSONResponse</code> or <code>UJSONResponse</code>. <code>ORJSONResponse</code> uses <code>orjson</code> to serialize a <a id="_idIndexMarker801"/>humongous listing of dictionary objects into a JSON string as a response. So, first, we need to install <code>orjson</code> using the <code>pip</code> command before using <code>ORJSONResponse</code>. <code>ORJSONResponse</code> serializes UUID, <code>numpy</code>, data classes, and datetime objects faster than the common <code>JSONResponse</code>.</p>
			<p>However, <code>UJSONResponse</code> is relatively faster than <code>ORJSONResponse</code> because it uses the <code>ujson</code> serializer. The <code>ujson</code> serializer must first be installed before using <code>UJSONResponse</code>.</p>
			<p>The following are the two API services that use these two fast alternatives for a JSON serializer:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/login/list/all")</strong>
async def list_all_login(engine=Depends(create_db_engine), 
         user: str = Depends(get_current_user)): 
    repo:LoginRepository = LoginRepository(engine)
    result = await repo.get_all_login()
    return <strong class="bold">ORJSONResponse(content=jsonable_encoder(result),</strong>
             <strong class="bold">status_code=201)</strong>
<strong class="bold">@router.get("/login/account")</strong>
async def get_login(id:int, 
       engine=Depends(create_db_engine), 
       user: str = Depends(get_current_user) ):
    repo:LoginRepository = LoginRepository(engine)
    result = await repo.get_login_id(id)
    return <strong class="bold">UJSONResponse(content=jsonable_encoder(result),</strong> 
             <strong class="bold">status_code=201)</strong></pre>
			<p>We still <a id="_idIndexMarker802"/>need to apply the <code>jsonable_encoder()</code> component to convert <code>BSON</code>’s <code>ObjectId</code> of the result into <code>str</code> before the<a id="_idIndexMarker803"/> two responses pursue their serialization processes. Now, let us focus on how we provide internal API documentation using the OpenAPI 3.0 specification.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor283"/>Applying the OpenAPI 3.x specification</h1>
			<p>The <a id="_idIndexMarker804"/>OpenAPI 3.0 specification is a standard API documentation<a id="_idIndexMarker805"/> and language-agnostic specification that can describe the API services without knowing its sources, reading its documentation, and understanding its business logic. Additionally, FastAPI supports OpenAPI, and it can even automatically generate the default internal documentation of the API based on OpenAPI standards.</p>
			<p>There are three ways to document our API services using the specification:</p>
			<ul>
				<li>By extending the OpenAPI schema definition</li>
				<li>By using the internal code base properties</li>
				<li>By using the <code>Query</code>, <code>Body</code>, <code>Form</code>, and <code>Path</code> functions</li>
			</ul>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor284"/>Extending the OpenAPI schema definition</h2>
			<p>FastAPI <a id="_idIndexMarker806"/>has a <code>get_openapi()</code> method from its <code>fastapi.openapi.utils</code> extension that can override some schema descriptions. We can modify the <code>info</code>, <code>servers</code>, and <code>paths</code> details of the schema definition through the <code>get_openapi()</code> function. The function returns a <code>dict</code> of all details of the OpenAPI schema definition of the application.</p>
			<p>The default OpenAPI schema documentation is always set up in the <code>main.py</code> module because it is consistently associated with the FastAPI instance. For the function to generate the <code>dict</code> of schema<a id="_idIndexMarker807"/> details, it must accept at least the <code>title</code>, <code>version</code>, and <code>routes</code> parameter values. The following custom function extracts the default <em class="italic">OpenAPI</em> schema for updating:</p>
			<pre class="source-code">
def update_api_schema():
   DOC_TITLE = "The Online Restaurant Rating System API"
   DOC_VERSION = "1.0"
   <strong class="bold">openapi_schema = get_openapi(</strong>
       <strong class="bold">title=DOC_TITLE</strong>,
       <strong class="bold">version=DOC_VERSION</strong>,
       <strong class="bold">routes=app.routes</strong>,
   <strong class="bold">)</strong>
<strong class="bold">app.openapi_schema = openapi_schema</strong>
return openapi_schema</pre>
			<p>The <code>title</code> parameter value is the document title, the <code>version</code> parameter value is the version of the API implementation, and <code>routes</code> contains a list of registered API services. Observe that the last line before the <code>return</code> statement updates FastAPI’s built-in <code>openapi_schema</code> defaults. Now, to update the general information details, we use the <code>info</code> key of the schema definition to change some values, as shown in the following sample:</p>
			<pre class="source-code">
<strong class="bold">openapi_schema["info"]</strong> = {
       "title": DOC_TITLE,
       "version": DOC_VERSION,
       "description": "This application is a prototype.",
       "contact": {
           "name": "Sherwin John Tragura",
           "url": "https://ph.linkedin.com/in/sjct",
           "email": "cowsky@aol.com"
       },
       "license": {
           "name": "Apache 2.0",
           "url": "https://www.apache.org/
                  licenses/LICENSE-2.0.html"
       },
   }</pre>
			<p>The<a id="_idIndexMarker808"/> preceding info schema update must also be part of the <code>update_api_schema()</code> function together with the update on the documentation of each registered API service. These details can includeAPI service's description and summary, the POST endpoint's description of its <code>requestBody</code> and GET endpoint's details about its parameters, and the API tags. Add the following <code>paths</code> updates:</p>
			<pre class="source-code">
openapi_schema["paths"]["/ch09/login/authenticate"]["post"]["description"] = "User Authentication Session"
openapi_schema["paths"]["/ch09/login/authenticate"]["post"]["summary"] = "This is an API that stores credentials in session."
openapi_schema["paths"]["/ch09/login/authenticate"]["post"]["tags"] = ["auth"]
   
openapi_schema["paths"]["/ch09/login/add"]["post"]
["description"] = "Adding Login User"
openapi_schema["paths"]["/ch09/login/add"]["post"]
["summary"] = "This is an API adds new user."
openapi_schema["paths"]["/ch09/login/add"]["post"]
["tags"] = ["operation"]
openapi_schema["paths"]["/ch09/login/add"]["post"]
["requestBody"]["description"]="Data for LoginReq"
   
openapi_schema["paths"]["/ch09/login/profile/add"]
["description"] = "Updating Login User"
openapi_schema["paths"]["/ch09/login/profile/add"]
["post"]["summary"] = "This is an API updating existing user record."
openapi_schema["paths"]["/ch09/login/profile/add"]
["post"]["tags"] = ["operation"]
openapi_schema["paths"]["/ch09/login/profile/add"]
["post"]["requestBody"]["description"]="Data for LoginReq"
   
openapi_schema["paths"]["/ch09/login/html/list"]["get"]["description"] = "Renders Jinja2Template with context data."
openapi_schema["paths"]["/ch09/login/html/list"]["get"]["summary"] = "Uses Jinja2 template engine for rendition."
openapi_schema["paths"]["/ch09/login/html/list"]["get"]["tags"] = ["rendition"]
openapi_schema["paths"]["/ch09/login/list/all"]["get"]["description"] = "List all the login records."
openapi_schema["paths"]["/ch09/login/list/all"]["get"]["summary"] = "Uses JsonResponse for rendition."
openapi_schema["paths"]["/ch09/login/list/all"]["get"]["tags"] = ["rendition"]</pre>
			<p>The preceding will give us a new OpenAPI document dashboard, as shown in <em class="italic">Figure 9.1</em>:</p>
			<div><div><img src="img/Figure_9.01_B17975.jpg" alt="Figure 9.1 – A customized OpenAPI dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – A customized OpenAPI dashboard</p>
			<p>Tags are <a id="_idIndexMarker809"/>essential variables of the OpenAPI documentation because they organize the API endpoints according to the routers, business processes, requirements, and modules. It is a best practice to use tags.</p>
			<p>Once all the updates have been set, replace FastAPI’s <code>openapi()</code> function with the new <code>update_api_schema()</code> function.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor285"/>Using the internal code base properties</h2>
			<p>FastAPI’s constructor<a id="_idIndexMarker810"/> has parameters that can replace the default info document details without using the <code>get_openapi()</code> function. The following snippet showcases a sample documentation update on the <code>title</code>, <code>description</code>, <code>version</code>, and <code>servers</code> details of the OpenAPI documentation:</p>
			<pre class="source-code">
app = FastAPI(… … … …, 
            <strong class="bold">title</strong>="The Online Restaurant Rating 
                       System API",
            <strong class="bold">description</strong>="This a software prototype.",
            <strong class="bold">version</strong>="1.0.0",
            <strong class="bold">servers</strong>= [
                {
                    "url": "http://localhost:8000",
                    "description": "Development Server"
                },
                {
                    "url": "https://localhost:8002",
                    "description": "Testing Server",
                }
            ])</pre>
			<p>When <a id="_idIndexMarker811"/>adding documentation to the API endpoints, the path operators of <code>FastAPI</code> and <code>APIRouter</code> also have parameters that allow changes to the default OpenAPI variables attributed to each endpoint. The following is a sample service that updates its <code>summary</code>, <code>description</code>, <code>response_description</code>, and other response details through the <code>post()</code> path operator:</p>
			<pre class="source-code">
@router.post("/restaurant/add",
     <strong class="bold">summary</strong>="This API adds new restaurant details.",
     <strong class="bold">description</strong>="This operation adds new record to the 
          database. ",
     <strong class="bold">response_description</strong>="The message body.",
     <strong class="bold">responses</strong>={
        <strong class="bold">200</strong>: {
            "<strong class="bold">content</strong>": {
                "application/json": {
                    "<strong class="bold">example</strong>": {
                        "restaurant_id": 100,
                        "name": "La Playa",
                        "branch": "Manila",
                        "address": "Orosa St.",
                        "province": "NCR",
                        "date_signed": "2022-05-23",
                        "city": "Manila",
                        "country": "Philippines",
                        "zipcode": 1603
                    }
                }
            },
        },
        <strong class="bold">404</strong>: {
            "<strong class="bold">description</strong>": "An error was encountered during 
                     saving.",
            "<strong class="bold">content</strong>": {
                "application/json": {
                    "<strong class="bold">example</strong>": {"message": "insert login 
                       unsuccessful"}
                }
            },
        },
    },
    tags=["operation"])
async def add_restaurant(req:RestaurantReq, 
        engine=Depends(create_db_engine), 
          user: str = Depends(get_current_user)):
    restaurant_dict = req.dict(exclude_unset=True) 
    restaurant_json = dumps(restaurant_dict, 
           default=json_datetime_serializer)
    repo:RestaurantRepository = 
            RestaurantRepository(engine)
    result = await repo.insert_restaurant(
              loads(restaurant_json))
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={"message": 
           "insert login unsuccessful"}, status_code=500)</pre>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor286"/>Using the Query, Form, Body, and Path functions</h2>
			<p>Aside from the declaration and additional validations, the <code>Query</code>, <code>Path</code>, <code>Form</code>, and <code>Body</code> parameter functions can also be used to add some metadata to the API endpoints. The following <code>authenticate()</code> endpoint has added descriptions and validations<a id="_idIndexMarker812"/> through the <code>Query()</code> function:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/login/authenticate")</strong>
async def authenticate(response: Response, 
    username:str = <strong class="bold">Query(...,</strong> 
       <strong class="bold">description='The username of the credentials.', </strong>
       <strong class="bold">max_length=50</strong>), 
    password: str = <strong class="bold">Query(...,</strong> 
     <strong class="bold">description='The password of the of the credentials.', </strong>
     <strong class="bold">max_length=20</strong>), 
    engine=Depends(create_db_engine)):
    repo:LoginRepository = LoginRepository(engine)
    … … … … … …
    response.set_cookie("session", token)
    return {"username": username}</pre>
			<p>The <a id="_idIndexMarker813"/>following <code>get_login()</code> uses the <code>Path()</code> directive to insert a description of the <code>id</code> parameter:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/login/account/{id}")</strong>
<strong class="bold">async def get_login(id:int = Path(..., </strong>
<strong class="bold">         description="The user ID of the user."), </strong>
   engine=Depends(create_db_engine), 
   user: str = Depends(get_current_user) ):
    … … … … … …
    return UJSONResponse(content=jsonable_encoder(result),
         status_code=201)</pre>
			<p>The <code>description</code> and <code>max_length</code> metadata of the <code>Query()</code> function will become part of the OpenAPI documentation for <code>authenticate()</code>, as shown in <em class="italic">Figure 9.2</em>:</p>
			<div><div><img src="img/Figure_9.02_B17975.jpg" alt="Figure 9.2 – The Query metadata"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The Query metadata</p>
			<p>Additionally, the <code>description</code> metadata <a id="_idIndexMarker814"/>of the <code>Path()</code> directive will also appear in the <code>get_login()</code> documentation, as presented in <em class="italic">Figure 9.3</em>:  </p>
			<div><div><img src="img/Figure_9.03_B17975.jpg" alt="Figure 9.3 – The Path metadata&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The Path metadata</p>
			<p>Likewise, we can add descriptions to form parameters<a id="_idIndexMarker815"/> using the <code>Form</code> directive. The following service shows you how to insert documentation through the <code>Form</code> directive: </p>
			<pre class="source-code">
<strong class="bold">@router.post("/user/profile")</strong>
async def create_profile(req: Request, 
<strong class="bold">        firstname: str = Form(..., </strong>
<strong class="bold">          description='The first name of the user.'), </strong>
<strong class="bold">        lastname: str = Form(..., </strong>
<strong class="bold">          description='The last name of the user.'), </strong>
<strong class="bold">        age: int = Form(..., </strong>
<strong class="bold">          description='The age of the user.'), </strong>
<strong class="bold">        birthday: date = Form(..., </strong>
<strong class="bold">           description='The birthday of the user.'), </strong>
        user: str = Depends(get_current_user)):
    user_details = req.session["user_details"]
    return {'profile' : user_details}
   </pre>
			<p>Moreover, it is<a id="_idIndexMarker816"/> also possible to document all types of HTTP responses or status codes that the API service can throw through the path operator’s <code>responses</code> parameter. The following <code>video_presentation()</code> service provides metadata regarding the nature of its response when it encounters no errors (<em class="italic">HTTP Status Code 200</em>) and with runtime errors (<em class="italic">HTTP Status Code 500</em>):</p>
			<pre class="source-code">
<strong class="bold">from models.documentation.response import Error500Model</strong>
… … … … …
<strong class="bold">@router.get("/restaurant/upload/video",responses={</strong>
<strong class="bold">        200: {</strong>
<strong class="bold">            "content": {"video/mp4": {}},</strong>
<strong class="bold">            "description": "Return an MP4 encoded video.",</strong>
        },
<strong class="bold">        500:{</strong>
<strong class="bold">            "model": Error500Model, </strong>
<strong class="bold">            "description": "The item was not found"</strong>
        }
    },)
def video_presentation():
    file_path = os.getcwd() + '\\files\\sample.mp4'
    def load_file():  
        with open(file_path, mode="rb") as video_file:  
            yield from video_file  
    return StreamingResponse(load_file(), 
<strong class="bold">              media_type="video/mp4")</strong></pre>
			<p><code>Error500Model</code> is a <code>BaseModel</code> class that will give you a clear picture of the response <a id="_idIndexMarker817"/>once the application encounters an <em class="italic">HTTP Status Code 500</em> error and will only be used in the OpenAPI documentation. It contains metadata such as the message that holds a hardcoded error message. <em class="italic">Figure 9.4</em> shows the resulting OpenAPI documentation for <code>video_presentation()</code> after adding the metadata for its responses:</p>
			<div><div><img src="img/Figure_9.04_B17975.jpg" alt="Figure 9.4 – The documentation for API responses&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The documentation for API responses</p>
			<p>And now, for our last discussion, let us explore how we can perform unit testing in FastAPI, which could lead to a test-driven development setup.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor287"/>Testing the API endpoints</h1>
			<p>FastAPI<a id="_idIndexMarker818"/> uses the <code>pytest</code> framework to run its test classes. So, before we create our test classes, first, we need to install the <code>pytest</code> framework using the <code>pip</code> command:</p>
			<pre>pip install pytest</pre>
			<p>FastAPI has a module called <code>fastapi.testclient</code> where all components are <code>Request</code>-based, including the <code>TestClient</code> class. To access all the API endpoints, we need the <code>TestClient</code> object. But first, we need to create a folder such as <code>test</code>, which will contain test modules where we implement our test methods. We place our test methods outside <code>main.py</code> or the router modules to maintain clean code and organization.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor288"/>Writing the unit test cases</h2>
			<p>It is a <a id="_idIndexMarker819"/>best practice to write one test module per router component, except for cases where there is a tight connection between these routers. We place these test modules inside the <code>test</code> directory. To pursue the automated testing, we need to import the <code>APIRouter</code> instance or the <code>FastAPI</code> instance into the test module to set up <code>TestClient</code>. <code>TestClient</code> is almost like Python’s client module, <code>requests</code>, when it comes to the helper methods used to consume APIs.</p>
			<p>The method names of the test cases must start with a <code>test_</code> prefix, which is a <code>pytest</code> requirement. Test methods are all standard Python methods and should not be asynchronous. The following is a test method in <code>test/test_restaurants.py</code> that checks whether the endpoint returns the proper text-based response:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.testclient import TestClient</strong>
from api import restaurant
<strong class="bold">client = TestClient(restaurant.router)</strong>
def test_restaurant_index():
    <strong class="bold">response = client.get("/restaurant/index")</strong>
    <strong class="bold">assert response.status_code == 200</strong>
    <strong class="bold">assert response.text == "The Restaurants"</strong></pre>
			<p><code>TestClient</code> supports assert statements that check the response of its helper methods, like <code>get()</code>, <code>post()</code>, <code>put()</code>, and <code>delete()</code> the status code and response body of the API. The <code>test_restaurant_index()</code>, for instance, uses the <code>get()</code> method of the TestClient API to run <code>/restaurant/index</code> GET service and extract its response. The assert statements are used if the <code>statuc_code</code> and <code>response.text</code> are correct. The endpoint has no imposed dependencies, so the test module is <em class="italic">router-based</em>. </p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor289"/>Mocking the dependencies</h2>
			<p>Testing<a id="_idIndexMarker820"/> API endpoints with dependencies is not as straightforward as the previous example. Our endpoints have session-based security through the JWT and the <code>APIKeyCookie</code> class, so we cannot just run <code>pytest</code> to test them. First, we need to apply <em class="italic">mocking</em> to these dependencies by adding them to the <code>dependency_overrides</code> of the <code>FastAPI</code> instance. Since <code>APIRouter</code> cannot mock dependencies, we need to use the <code>FastAPI</code> instance to set up <code>TestClient</code>. All endpoints can be unit tested if the routers are part of the FastAPI configuration through <code>include_router()</code>:</p>
			<pre class="source-code">
from fastapi.testclient import TestClient
<strong class="bold">from models.data.orrs import Login</strong>
<strong class="bold">from main import app</strong>
<strong class="bold">from util.auth_session import get_current_user</strong>
<strong class="bold">client = TestClient(app)</strong>
<strong class="bold">async def get_user():</strong>
    <strong class="bold">return Login(**{"username": "sjctrags", </strong>
      <strong class="bold">"login_id": 101,  </strong>
      <strong class="bold">"password":"sjctrags", "passphrase": None, </strong>
      <strong class="bold">"profile": None})</strong>
<strong class="bold">app.dependency_overrides[get_current_user] =  get_user</strong>
def test_rating_top_three():
   <strong class="bold"> response = client.post("/ch09/rating/top/three", </strong>
     <strong class="bold">json={</strong>
          "rate1": 10.0, 
          "rate2": 20.0 ,
          "rate3": 30.0
        
    })
    <strong class="bold">assert response.status_code == 200</strong>
    <strong class="bold">assert response.json() == { "stats": {</strong>
          "sum": 60.0,
          "average": 20.0
      }
}</pre>
			<p>The <code>/rating/top/three</code> API from the <code>/api/route_extract.py</code> router requires a <code>dict</code> of ratings<a id="_idIndexMarker821"/> to derive a JSON result containing <code>average</code> and <code>sum</code>. <code>TestClient</code>’s path operators have JSON and data parameters, where we can pass test data to the API. Likewise, <code>TestClient</code>’s response has methods that can derive the expected response body, such as, in this example, the <code>json()</code> function.</p>
			<p>Running the test method will result in some <code>APIKeyCookie</code> exceptions due to the dependency on session-based security. To bypass this issue, we need to create a fake <code>get_current_user()</code> dependable function to proceed with the testing. We add the <code>get_current_user()</code> dependable function into the roster of overrides and map it with the fake ones, such as our <code>get_user()</code> function, to replace its execution. This process is what <a id="_idIndexMarker822"/>we call <strong class="bold">mocking</strong> in the FastAPI context.</p>
			<p>Aside from <a id="_idIndexMarker823"/>security, we can also mock the database connection by creating a mock database object or database engine, depending on whether it is a relational database or a NoSQL database. In the following test case, we are performing a unit test in <code>/ch09/login/list/all</code>, which needs MongoDB connectivity to access the list of login profiles. For the test to work, we need to create a mock <code>AsyncIOMotorClient</code> object with a dummy test database called <code>orrs_test</code>. Here is the <code>test_list_login()</code> test, which implements this database mocking:</p>
			<pre class="source-code">
<strong class="bold">def db_connect():</strong>
<strong class="bold">    client_od = </strong>
<strong class="bold">         AsyncIOMotorClient(f"mongodb://localhost:27017/")</strong>
<strong class="bold">    engine = AIOEngine(motor_client=client_od, </strong>
<strong class="bold">            database="orrs_test")</strong>
<strong class="bold">    return engine</strong>
async def get_user():
    return Login(**{"username": "sjctrags", "login_id": 101,
           "password":"sjctrags", "passphrase": None, 
           "profile": None})
app.dependency_overrides[get_current_user] =  get_user
<strong class="bold">app.dependency_overrides[create_db_engine] = db_connect</strong>
def test_list_login():
    response = client.get("/ch09/login/list/all")
    assert response.status_code == 201</pre>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor290"/>Running test methods</h2>
			<p>Run <a id="_idIndexMarker824"/>the <code>pytest</code> command <a id="_idIndexMarker825"/>on the command line to execute all unit tests. The <code>pytest</code> engine will compile and run all <code>TestClient</code> apps in the <code>test</code> folder, thus running all the test methods. <em class="italic">Figure 9.5</em> shows a snapshot of the test result:</p>
			<div><div><img src="img/Figure_9.05_B17975.jpg" alt="Figure 9.5 – The test result&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The test result</p>
			<p>Learning more about the <code>pytest</code> framework offers a heads-up in understanding the automation of test cases in FastAPI. Organizing all test methods through modules is essential in the testing phase of the application since we run all of them in bulk.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor291"/>Summary</h1>
			<p>This chapter showcased some essential features that were not part of the previous chapters but can help fill some gaps during microservice development. One involves choosing better and more appropriate JSON serializers and de-serializers when converting a huge amount of data into JSON. Also, the advanced customizations, session handling, message body encryption and decryption, and testing API endpoints gave us a clear understanding of the potential of FastAPI to create cutting-edge and progressive microservice solutions. Also, this chapter introduced different API responses supported by FastAPI, including Jinja2’s <code>TemplateResponse</code>. </p>
			<p>The next chapter will show us the strength of FastAPI in cracking numerical and symbolic computations.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>