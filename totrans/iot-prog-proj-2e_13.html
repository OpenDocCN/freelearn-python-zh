<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer282">
<h1 class="chapter-number" id="_idParaDest-207"><a id="_idTextAnchor209"/>13</h1>
<h1 id="_idParaDest-208"><a id="_idTextAnchor210"/>Introducing Advanced Robotic Eyes for Security (A.R.E.S.)</h1>
<p>In this chapter, we will convert our TurtleSim virtual robot to a real-life robot we will call A.R.E.S. (short for Advanced Robotic Eyes for Security). A.R.E.S. will feature a video feed that we view over our local network using the VLC media player. We will control A.R.E.S. using the IoT joystick we created in <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><span class="No-Break">.</span></p>
<p>We will construct A.R.E.S. using a Raspberry Pi as the brain or sensory input and a Raspberry Pi Pico for control of the motors, LEDs, and buzzer. We will use standard motors and a robotics board with our Raspberry Pi Pico H for motor control. We will 3D print the frame using the <strong class="source-inline">.stl</strong> files located in the <strong class="source-inline">Build Files</strong> directory of this chapter’s <span class="No-Break">GitHub repository.</span></p>
<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Exploring our <span class="No-Break">A.R.E.S. application</span></li>
<li><span class="No-Break">Constructing A.R.E.S.</span></li>
<li>Software setup <span class="No-Break">and configuration</span></li>
<li>Programming A.R.E.S. <span class="No-Break">with ROS</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor211"/>Technical requirements</h1>
<p>You will require the following to learn comprehensively from <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>Basic knowledge of the Linux <span class="No-Break">command line</span></li>
<li>A CloudAMQP account for the MQTT <span class="No-Break">server instance</span></li>
<li>IoT joystick from <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a></li>
<li>Access to a 3D printer or 3D <span class="No-Break">printing service</span></li>
<li>Build files for custom cases may be found in our <span class="No-Break">GitHub repository</span></li>
</ul>
<p>Refer to the <em class="italic">Constructing A.R.E.S.</em> section for hardware <span class="No-Break">components required.</span></p>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter13</span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor212"/>Exploring our A.R.E.S. application</h1>
<p>The A.R.E.S. robot presents<a id="_idIndexMarker964"/> an integration of various IoT components. It’s operated via the IoT joystick we created in <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a> and communicates commands through MQTT to the Raspberry Pi. Our design will incorporate both a Raspberry Pi 3B+ and a Raspberry Pi Pico H. In the following diagram, we see the outline of the A.R.E.S. robot, including the connection from the <span class="No-Break">IoT joystick:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer250">
<img alt="Figure 13.1 – The A.R.E.S. robot application" height="432" src="image/B21282_13_1.jpg" width="1163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The A.R.E.S. robot application</p>
<p>The Raspberry<a id="_idIndexMarker965"/> Pi 3B+, serving as the brain, uses <strong class="bold">UART</strong> (short for <strong class="bold">Universal Asynchronous Receiver/Transmitter</strong>) communication to relay commands to a Raspberry Pi Pico H, which in turn controls the car’s movements, LEDs, and buzzer, responding dynamically to inputs. Equipped with a VL53L0X sensor, A.R.E.S. can measure distances, allowing it to avoid obstacles. Additionally, an M5Stack camera mounted on A.R.E.S. streams real-time video, which can be viewed on any computer<a id="_idIndexMarker966"/> using a VLC media player via the <strong class="bold">Real-Time Streaming </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RTSP</strong></span><span class="No-Break">).</span></p>
<p class="callout-heading">Using a Raspberry Pi 3B+ for A.R.E.S.</p>
<p class="callout">For A.R.E.S., we’re selecting<a id="_idIndexMarker967"/> the Raspberry Pi 3B+ over newer models<a id="_idIndexMarker968"/> such as the 4 or 5 due to its power efficiency and cost. Its ability to run on standard cell phone battery packs makes it ideal for our needs, while its lower price and availability as a current model ensure both economic and <span class="No-Break">practical benefits.</span></p>
<p>Kicking off the A.R.E.S. robot project, we’ll first assemble the 3D-printed frame and install the necessary components. A.R.E.S. is engineered for compactness, making it an ideal robotic platform for educational purposes. Once the frame is complete, we’ll move on to software, configuring the operating system<a id="_idIndexMarker969"/> on our Raspberry Pi 3B+ and programming the Raspberry Pi Pico H. Let’s begin with constructing <span class="No-Break">the frame.</span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor213"/>Constructing A.R.E.S.</h1>
<p>A.R.E.S. consists of a frame<a id="_idIndexMarker970"/> made with 3D-printed parts and common components such as DC motors, LEDs, a Raspberry<a id="_idIndexMarker971"/> Pi 3B+, a Raspberry Pi Pico H, <strong class="bold">ToF</strong> (short for <strong class="bold">time of flight</strong>), a sensor, a Wi-Fi camera, battery packs, and various bolts <span class="No-Break">and screws.</span></p>
<p>We will start our construction of A.R.E.S. by identifying the <span class="No-Break">3D-printed parts.</span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor214"/>Identifying the 3D-printed frame parts</h2>
<p>We may find the <strong class="source-inline">.stl</strong> files of these parts<a id="_idIndexMarker972"/> under the <strong class="source-inline">Build Files</strong> directory of this chapter’s GitHub repository. In the following figure, we see the parts <span class="No-Break">printed out:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer251">
<img alt="Figure 13.2 – A.R.E.S. 3D-printed parts" height="849" src="image/B21282_13_2.jpg" width="1151"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – A.R.E.S. 3D-printed parts</p>
<p>The 3D-printed parts<a id="_idIndexMarker973"/> that make up the frame of A.R.E.S. are <span class="No-Break">the following:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">A</em></span><span class="No-Break">: Base</span></li>
<li><span class="No-Break"><em class="italic">B</em></span><span class="No-Break">: Shell</span></li>
<li><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">: Face</span></li>
<li><em class="italic">D</em>: Battery <span class="No-Break">pack riser</span></li>
<li><em class="italic">E</em>: <span class="No-Break">Motor bracket</span></li>
<li><em class="italic">F</em>: Testing stand (optional base used for <span class="No-Break">testing purposes)</span></li>
</ul>
<p>With the 3D-printed frame parts identified, let’s look at the components used to <span class="No-Break">construct A.R.E.S.</span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor215"/>Identifying the components used to create A.R.E.S.</h2>
<p>The components we use to construct<a id="_idIndexMarker974"/> A.R.E.S. are standard electronic components and may be easily purchased online from vendors such as Amazon or AliExpress. The following figure outlines the components <span class="No-Break">we use:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer252">
<img alt="Figure 13.3 – Components that make up the A.R.E.S. robot" height="983" src="image/B21282_13_3.jpg" width="1324"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Components that make up the A.R.E.S. robot</p>
<p>The components to construct A.R.E.S. are <span class="No-Break">the following:</span></p>
<ul>
<li><em class="italic">A</em>: 2 x LED with 220 <span class="No-Break">Ohm resistor</span></li>
<li><em class="italic">B</em>: 2 x 5 mm (8 mm wide) <span class="No-Break">LED holder</span></li>
<li><em class="italic">C</em>: 2 x TT DC <span class="No-Break">robot motor</span></li>
<li><em class="italic">D</em>: M5Stack Timer Camera X with mount (<span class="No-Break">not shown)</span></li>
<li><em class="italic">E</em>: Adafruit VL53L0X <span class="No-Break">ToF sensor</span></li>
<li><em class="italic">F</em>: 2 x TT robot <span class="No-Break">car wheel</span></li>
<li><em class="italic">G</em>: <span class="No-Break">SFM-27 buzzer</span></li>
<li><em class="italic">H</em>: Raspberry <span class="No-Break">Pi 3B+</span></li>
<li><em class="italic">I</em>: Battery pack for 4 AA batteries (<span class="No-Break">with batteries)</span></li>
<li><em class="italic">J</em>: Cell phone USB <span class="No-Break">battery pack</span></li>
<li><em class="italic">K</em>: Raspberry Pi Pico H with Kitronik Simply Robotics Motor <span class="No-Break">Driver Board</span></li>
<li><em class="italic">L</em>: micro-USB to USB <span class="No-Break">cable (short)</span></li>
<li><em class="italic">M</em>: Grove connector to female jumper wire connectors for connecting the camera to the GPIO ports of the Raspberry <span class="No-Break">Pi 3B+</span></li>
<li><em class="italic">N</em>: 4 x 2 mm thick, 18 mm diameter magnets with double-sided <span class="No-Break">adhesive pads</span></li>
<li><em class="italic">O</em>: Caster (32 <span class="No-Break">mm width)</span></li>
<li><em class="italic">NOT SHOWN</em>: 18 x M3 10 mm bolts, 4 x M3 20 mm bolts, 8 x M3 nuts, 6 x M2.5 10 mm bolts, 2 x M4 10 mm bolts, 4 x M2.5 40 mm standoffs, 3 x M3 20 mm standoffs, jumper wires, crimping kit with connectors and wires (optional but recommended), hot glue gun, <span class="No-Break">soldering iron</span></li>
</ul>
<p>With our components<a id="_idIndexMarker975"/> in place, let’s start to build our <span class="No-Break">A.R.E.S. robot.</span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor216"/>Building A.R.E.S.</h2>
<p>Using our 3D-printed frame parts<a id="_idIndexMarker976"/> and electronic components, it is now time to build A.R.E.S. To construct A.R.E.S., we use the following diagram as <span class="No-Break">a guide:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer253">
<img alt="Figure 13.4 – Building the A.R.E.S. robot" height="1321" src="image/B21282_13_4.jpg" width="1067"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Building the A.R.E.S. robot</p>
<p>The steps are<a id="_idIndexMarker977"/> as follows (the numbered steps also correspond to the numbered components in <span class="No-Break">the figure):</span></p>
<ol>
<li>Using double-sided adhesive tape (usually packaged with the product), we secure two magnets (<em class="italic">N</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the shell (<em class="italic">B</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
<li>Using the opposite polarity magnets (<em class="italic">N</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>), we attach the magnets (be sure to test before fastening) to the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
<li>Using two M4 10 mm bolts, we fasten the SFM-27 buzzer (<em class="italic">G</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>). The bolts should tap into the buzzer base; however, M4 nuts may be required. In this step, we also secure the caster (<em class="italic">O</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) using two <span class="No-Break">M3 bolts.</span></li>
<li>We solder 20 cm wires to each of the terminals of the TT motor (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
<li>Using the motor bracket (<em class="italic">E</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>), we fasten the TT motors (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) with the TT robot<a id="_idIndexMarker978"/> car wheel (<em class="italic">F</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
<li>Using two M3 10 mm bolts, we fasten the camera mount that comes with the M5Stack Timer Camera X (<em class="italic">D</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the face (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
<li>Using the LED holders (<em class="italic">B</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) and LEDs with resistors (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>), we thread the LEDs through the appropriate holes in the face (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>). We secure the VL53L0X ToF sensor (<em class="italic">E</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the face (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) using glue from a hot glue gun. We may also glue the LEDs in place to keep them <span class="No-Break">from moving.</span></li>
<li>Access to the GP pins on the Raspberry Pi Pico H is required, but they are engaged<a id="_idIndexMarker979"/> within the motor board’s <strong class="bold">DIP</strong> (short for <strong class="bold">Dual Inline Package</strong>) socket, rendering them inaccessible. To overcome this, we need to solder header pins to the underside of the motor board, enabling us to connect the SFM-27 buzzer (<em class="italic">G</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) and LEDs with resistors (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the Raspberry Pi <span class="No-Break">Pico H.</span></li>
<li>We secure four M2.5 40 mm standoffs to the front of the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) and three M3 20 mm standoffs to the back of the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) using 10 mm M2.5 and 10 mm M3 bolts respectively. We may secure the Raspberry Pi 3B+ (<em class="italic">H</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) and Pico H with the motor board (<em class="italic">K</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>) to the standoffs; however, this will only be temporary as these components will be moved around as we wire up A.R.E.S. We may also temporarily place the battery pack riser (<em class="italic">D</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) in place. We use the riser to cover the wires and provide a flat surface to place the battery pack (<em class="italic">I</em> from <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">13</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">) on.</span></li>
</ol>
<p>With the frame assembled<a id="_idIndexMarker980"/> and components in place, it is now time to wire our components to the Raspberry Pi and <span class="No-Break">Pico H.</span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor217"/>Wiring up A.R.E.S.</h2>
<p>Wiring up A.R.E.S. requires connections<a id="_idIndexMarker981"/> to the Raspberry Pi 3B+ and Kitronik motor board. Using <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em> as a reference, we can see that we connect the VL53L0X ToF sensor and M5Stack Timer Camera X to the Raspberry Pi 3B+, and the TT DC robot motors, LEDs with resistors, and buzzer to the Raspberry Pi Pico H using the motor board. We also wire the Raspberry Pi 3B+ to the Raspberry Pi Pico H to each other for use with <span class="No-Break">UART communication.</span></p>
<p>We start our wiring with robot motors. In the following figure, we see a closeup of the motor board with the terminals to connect the battery pack and <span class="No-Break">motors highlighted:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer254">
<img alt="Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H" height="689" src="image/B21282_13_5.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H</p>
<p>To wire up<a id="_idIndexMarker982"/> our motors, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Attach the wires from the right motor, as depicted in <em class="italic">Step 9</em> of <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.4</em>, to <strong class="bold">Motor0</strong> on the motor board. The polarity of the wires is not critical at this stage since we can correct their orientation later <span class="No-Break">if necessary.</span></li>
<li>Attach the wires from the left motor to <strong class="bold">Motor1</strong> on the <span class="No-Break">motor board.</span></li>
<li>Attach the wires from the AA battery pack to the battery terminals on the motor board, taking polarity <span class="No-Break">into account.</span></li>
</ol>
<p>With the robot motors and battery wires attached, it is now time to wire up the rest of the components. We will be using standard female jumper wires to make the connections. Although not required, having the ability to create our own jumper wires using a crimping kit makes for a clean and organized wiring setup. We use the wiring diagram in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.6</em> <span class="No-Break">for reference:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer255">
<img alt="Figure 13.6 – Component wiring diagram for A.R.E.S." height="1433" src="image/B21282_13_6.jpg" width="1333"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Component wiring diagram for A.R.E.S.</p>
<p>To wire up the rest<a id="_idIndexMarker983"/> of our components, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a grove connector to the female jumper wire connectors (<em class="italic">M</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>), we connect the M5Stack Timer Camera X to the Raspberry Pi 3B+ by attaching 5V from the Raspberry Pi to the V connector on the camera, and GND from the Raspberry Pi to G on <span class="No-Break">the camera.</span></li>
<li>We connect VIN on the ToF sensor to 3.3V on the <span class="No-Break">Raspberry Pi.</span></li>
<li>We connect SDA on the ToF sensor to SDA (GPIO 2) on the <span class="No-Break">Raspberry Pi.</span></li>
<li>We connect SCL on the ToF sensor to SCL (GPIO 3) on the <span class="No-Break">Raspberry Pi.</span></li>
<li>We connect GND on the ToF sensor to GND on the <span class="No-Break">Raspberry Pi.</span></li>
<li>We connect TX (GPIO 14) on the Raspberry Pi to RX (GP5) on the Raspberry Pi Pico H or pin 7 on the <span class="No-Break">motor board.</span></li>
<li>We connect RX (GPIO 15) on the Raspberry Pi to TX (GP4) on the Raspberry Pi Pico H or pin 6 on the <span class="No-Break">motor board.</span></li>
<li>We connect GND on the Raspberry Pi to GND on the Raspberry Pi Pico H or a GND (0V) pin on the <span class="No-Break">motor board.</span></li>
<li>We connect the positive wire on the SFM-27 buzzer to GP0 on the Raspberry Pi Pico H or pin 1 on the <span class="No-Break">motor board.</span></li>
<li>We connect the negative wire on the SFM-27 buzzer to a GND (0V) pin on the <span class="No-Break">motor board.</span></li>
<li>We connect the positive ends of the LEDs with resistors to GP1 and GP2 or pins 2 and 4 on the <span class="No-Break">motor board.</span></li>
<li>We connect the negative ends of the LEDs with resistors to a GND (0V) pin on the <span class="No-Break">motor board.</span></li>
</ol>
<p>We may need to move the Raspberry Pi<a id="_idIndexMarker984"/> and motor board around as we make the connections. Also, it is advisable that we do not attach the face (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) to the base (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>) initially as we require access to the microSD port on the Raspberry <span class="No-Break">Pi 3B+.</span></p>
<p>With the wiring in place, let’s set up the software for A.R.E.S. We will start by installing Ubuntu onto our Raspberry <span class="No-Break">Pi 3B+.</span></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor218"/>Software setup and configuration</h1>
<p>To set up the software architecture<a id="_idIndexMarker985"/> of A.R.E.S., we will run<a id="_idIndexMarker986"/> a script from this chapter’s GitHub repository. The script starts by ensuring that it is run with root privileges, updates and upgrades the system, and installs<a id="_idIndexMarker987"/> essential utilities and interfaces such as <strong class="bold">I2C</strong> (short for <strong class="bold">Inter-Integrated Circuit</strong>) and UART. It then proceeds to install Adafruit Blinka to support CircuitPython libraries, set up ROS Humble Hawksbill for robotics programming, and install the Colcon build system for <span class="No-Break">software compilation.</span></p>
<p>The script also takes care of dependency management through <strong class="source-inline">rosdep</strong> and adds the ROS 2 environment setup to the <strong class="source-inline">bashrc</strong> file for easy access. By the end of the process, our Raspberry Pi 3B+ is fully configured <span class="No-Break">for A.R.E.S.</span></p>
<p>Before running the script, we will use the Raspberry Pi Imager to burn Ubuntu onto a microSD card and install the card onto our Raspberry Pi 3B+. As the slot for the microSD card is in the front of the A.R.E.S. robot, the face will cover it. Thus, we will keep the face disconnected from the base while we install Ubuntu, as we see in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer256">
<img alt="Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access to the microSD card" height="683" src="image/B21282_13_7.jpg" width="854"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access to the microSD card</p>
<p>We will run the<a id="_idIndexMarker988"/> Raspberry Pi Imager<a id="_idIndexMarker989"/> from a computer of our choice. For the examples in this chapter, we will install it on a <span class="No-Break">Windows computer.</span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor219"/>Installing Ubuntu onto our Raspberry Pi 3B+</h2>
<p>The Raspberry Pi Imager<a id="_idIndexMarker990"/> is a versatile tool designed<a id="_idIndexMarker991"/> to simplify the process of installing operating systems on Raspberry Pi devices. Developed by the Raspberry Pi Foundation, this utility allows us to flash various operating systems onto an SD card, which can then be used to boot and run on a <span class="No-Break">Raspberry Pi.</span></p>
<p>While the Raspberry Pi Imager primarily supports the installation<a id="_idIndexMarker992"/> of Raspberry Pi OS (formerly known as Raspbian), its capabilities extend to a range of other operating systems. This allows us to experiment with different environments or require specific functionalities that are better supported by <span class="No-Break">alternative OSs.</span></p>
<p>To use the Raspberry Pi Imager, we simply download and install the application on our computer, select the desired operating system from its extensive list, and then choose the target SD card for installation. The Raspberry Pi Imager can be installed on various operating systems, including Windows, macOS, and Linux. For example, in this chapter, we will install it onto a Windows machine. We will burn a command-line version of Ubuntu 22.04 to correspond to the Humble Hawksbill version <span class="No-Break">of ROS.</span></p>
<p>To use the Raspberry Pi Imager<a id="_idIndexMarker993"/> to install Ubuntu<a id="_idIndexMarker994"/> onto the Raspberry Pi 3B+ on our A.R.E.S. robot, we navigate to the URL and download<a id="_idIndexMarker995"/> the imager for the OS we are using (<a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a>) and proceed to install the tool <span class="No-Break">as follows:</span></p>
<ol>
<li>We insert our microSD into a port on <span class="No-Break">our computer.</span></li>
<li>After installation, we open the tool and select <strong class="bold">RASPBERRY PI 3</strong> for <strong class="bold">Raspberry Pi Device</strong>, <strong class="bold">UBUNTU SERVER 22.04.4 LTS (64-BIT)</strong> for <strong class="bold">Operating System</strong>, and the microSD card we inserted for the <span class="No-Break"><strong class="bold">Storage</strong></span><span class="No-Break"> option:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer257">
<img alt="Figure 13.8 – Setting up the Raspberry Pi Imager" height="489" src="image/B21282_13_8.jpg" width="963"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Setting up the Raspberry Pi Imager</p>
<p class="list-inset">To proceed, we click<a id="_idIndexMarker996"/> on the <strong class="bold">NEXT</strong> button. This will bring<a id="_idIndexMarker997"/> us to the <strong class="bold">Use OS </strong><span class="No-Break"><strong class="bold">customisation?</strong></span><span class="No-Break"> dialog:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer258">
<img alt="Figure 13.9 – Imager customization dialog" height="440" src="image/B21282_13_9.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Imager customization dialog</p>
<ol>
<li value="3">As we would like to set the name of the computer<a id="_idIndexMarker998"/> and the network, we click<a id="_idIndexMarker999"/> on the <strong class="bold">EDIT SETTINGS</strong> button and get the <span class="No-Break">following screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer259">
<img alt="Figure 13.10 – OS Customisation screen" height="662" src="image/B21282_13_10.jpg" width="541"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – OS Customisation screen</p>
<p class="list-inset">We set both the hostname and username to <strong class="source-inline">ares</strong>. We provide a password for the username and enter our SSID (LAN network) and <span class="No-Break">SSID password.</span></p>
<ol>
<li value="4">To enable remote access through SSH, we click on the <strong class="bold">SERVICES</strong> tab at the top and select <span class="No-Break"><strong class="bold">Enable SSH</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer260">
<img alt="" height="502" role="presentation" src="image/B21282_13_11.jpg" width="839"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – Enable SSH</p>
<ol>
<li value="5">To save our settings, we click on the <span class="No-Break"><strong class="bold">SAVE</strong></span><span class="No-Break"> button.</span></li>
<li>To apply<a id="_idIndexMarker1000"/> the settings, we click<a id="_idIndexMarker1001"/> on the <span class="No-Break"><strong class="bold">YES</strong></span><span class="No-Break"> button.</span><p class="list-inset">We will then be presented with <span class="No-Break">a warning:</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer261">
<img alt="" height="489" role="presentation" src="image/B21282_13_12.jpg" width="1086"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Warning message</p>
<ol>
<li value="7">We click on <strong class="bold">YES</strong> as we want to erase any data on our microSD card and replace it with the Ubuntu <span class="No-Break">operating system.</span></li>
</ol>
<p>The Raspberry Pi Imager will then proceed to install the Ubuntu 22.04 operating system onto our microSD card, which we will install onto the Raspberry Pi 3B+ on A.R.E.S. We will not need<a id="_idIndexMarker1002"/> to set up a Wi-Fi network<a id="_idIndexMarker1003"/> or <span class="No-Break">enable SSH.</span></p>
<p>With Ubuntu installed, it is now time to install ROS and the Python libraries we need for A.R.E.S. We will automate this with a specialized script stored in our <span class="No-Break">GitHub repository.</span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor220"/>Running the installation script</h2>
<p>In previous chapters, we manually installed<a id="_idIndexMarker1004"/> development libraries, a thorough yet time-intensive process. Now, leveraging our familiarity with Python libraries, we will streamline the setup of A.R.E.S. with ROS and necessary libraries through a script from our <span class="No-Break">GitHub repository.</span></p>
<p>Executed with root privileges on Ubuntu, this script automates the installation, including ROS. Despite the direct installation into the OS diverging from <em class="italic">best practices</em>, it simplifies the process. For future projects, it is suggested that readers explore containerization with tools such <span class="No-Break">as Docker.</span></p>
<p>To run the A.R.E.S. installation script, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.7</em> as a reference, we ensure that we have access to the ports on the Raspberry <span class="No-Break">Pi 3B+.</span></li>
<li>We connect a monitor, keyboard, and mouse to our Raspberry Pi and insert the freshly imaged <span class="No-Break">microSD card.</span><p class="list-inset">As the server version of Ubuntu is command-line based, we will not be presented with a GUI when we boot up our Raspberry Pi. We log in using the credentials set during the imaging process. We should be in the <strong class="source-inline">home</strong> directory once logged in. We may verify this with the <span class="No-Break"><strong class="source-inline">pwd</strong></span><span class="No-Break"> command:</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer262">
<img alt="Figure 13.13 – Verifying current directory" height="162" src="image/B21282_13_13.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Verifying current directory</p>
<ol>
<li value="3">The setup script<a id="_idIndexMarker1005"/> is in the book’s GitHub repository. To download the script and the Python code we use for the A.R.E.S. robot, we clone the repository onto our Raspberry Pi with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">git clone https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition.git code</strong></pre></li> <li>After running this command, we will have all the GitHub files inside a new directory called <strong class="source-inline">code</strong>. We may verify the creation of the <strong class="source-inline">code</strong> directory by running the <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer263">
<img alt="" height="491" role="presentation" src="image/B21282_13_14.jpg" width="1213"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – Cloning repository</p>
<p class="list-inset">The script is located inside subdirectories<a id="_idIndexMarker1006"/> of the <strong class="source-inline">code</strong> directory. We copy it to our current directory (<strong class="source-inline">.</strong>) with the <span class="No-Break">following command:</span></p>
<pre class="source-code">
<strong class="bold">cp code/Chapter13/code/setup-ares.sh .</strong></pre> <ol>
<li value="5">We verify that our script was copied over successfully with the <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer264">
<img alt="" height="491" role="presentation" src="image/B21282_13_15.jpg" width="1282"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – Verifying successful copy of setup script</p>
<ol>
<li value="6">We execute the script with admin privileges with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo bash setup-ares.sh</strong></pre><p class="list-inset">Executing the script with admin privileges ensures it has the necessary permissions to perform system-level changes and installations without encountering access restrictions. Our script initially updates our system before installing ROS and the necessary Python libraries. It should take several minutes to complete. After completion, we should be presented with the IP address of our machine so that we may log in remotely with SSH. This will be necessary when A.R.E.S. is <span class="No-Break">running remotely:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer265">
<img alt="Figure 13.16 – Result of running the setup script" height="431" src="image/B21282_13_16.jpg" width="1113"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Result of running the setup script</p>
<ol>
<li value="7">With the completion<a id="_idIndexMarker1007"/> of our setup script, we are now able to fasten the robot face to the base plate <span class="No-Break">of A.R.E.S.:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer266">
<img alt="" height="748" role="presentation" src="image/B21282_13_17.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.17 – Front view of A.R.E.S.</p>
<p>With the construction of A.R.E.S. and the OS on our Raspberry Pi 3B+ installed, it is time to install the code on our Raspberry Pi Pico H. Referring to <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em>, we can see that A.R.E.S. uses the Pico<a id="_idIndexMarker1008"/> H to control the motors, LEDs, <span class="No-Break">and buzzer.</span></p>
<p>We will start by writing code to control the LED <span class="No-Break">and buzzer.</span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor221"/>Creating alarm code for the Pico H</h2>
<p>To program our<a id="_idIndexMarker1009"/> Pico H, we will need<a id="_idIndexMarker1010"/> to connect a micro-USB cable to the USB port on the Pico H. Despite our intentions to stagger the heights of the Pico H and Raspberry Pi 3B+, we may need to temporarily dismount the Raspberry Pi 3B+ from its standoffs to attach the micro-USB cable to the <span class="No-Break">Pico H.</span></p>
<p>Once the micro-USB cable<a id="_idIndexMarker1011"/> is attached, we may plug our Pico H into a computer<a id="_idIndexMarker1012"/> of our choice and run Thonny. We will create a class called <strong class="source-inline">Alarm</strong> inside a file called <strong class="source-inline">device_alarm.py</strong> on our Pico H to encapsulate the alarm functionality. For simplicity’s sake, we will couple the flashing of the LEDs with the activation of <span class="No-Break">the buzzer.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Referring to the <em class="italic">Setting up our Raspberry Pi Pico WH</em> section from <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, we install CircuitPython onto our Raspberry Pi Pico although we select  <strong class="bold">Raspberry Pi • Pico / Pico H</strong> for the <strong class="bold">CircuitPython </strong><span class="No-Break"><strong class="bold">variant</strong></span><span class="No-Break"> option:</span></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer267">
<img alt="" height="538" role="presentation" src="image/B21282_13_18.jpg" width="877"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.18 – Installing CircuitPython onto our Raspberry Pi Pico H</p>
<ol>
<li value="2">We then activate the CircuitPython environment on our Pico H by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new editor, we start our code with <span class="No-Break">the imports:</span><pre class="source-code">
import time
import board
import pwmio
import digitalio</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">import time</strong>: Provides time-related<a id="_idIndexMarker1013"/> functions, enabling tasks<a id="_idIndexMarker1014"/> such as introducing delays in the program execution, which is useful for controlling the flow and timing <span class="No-Break">of operations.</span></li><li><strong class="source-inline">import board</strong>: Accesses board-specific pins and hardware interfaces, crucial for interfacing with the GPIO pins on the Raspberry Pi <span class="No-Break">Pico W.</span></li><li><strong class="source-inline">import pwmio</strong>: We use this library to enable precise control over the buzzer by manipulating<a id="_idIndexMarker1015"/> the frequency and duty cycle of <strong class="bold">PWM</strong> (short for <strong class="bold">Pulse Width Modulation</strong>) signals, affecting the pitch and volume of the <span class="No-Break">sound produced.</span></li><li><strong class="source-inline">import digitalio</strong>: Manages digital input and output, such as reading the state of buttons or controlling LEDs, which is essential for digital <span class="No-Break">signal interactions.</span></li></ul></li> <li>We then define an <strong class="source-inline">Alarm</strong> class and create an <span class="No-Break">initialization method:</span><pre class="source-code">
class Alarm:
    def __init__(self, buzzer_pin=board.GP1, led_pin1=board.GP0, led_pin2=board.GP2, frequency=4000):
        self.buzzer = pwmio.PWMOut(buzzer_pin, frequency=frequency, duty_cycle=0)
        self.led1 = digitalio.DigitalInOut(led_pin1)
        self.led1.direction = digitalio.Direction.OUTPUT
        self.led2 = digitalio.DigitalInOut(led_pin2)
        self.led2.direction = digitalio.Direction.OUTPUT</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">We define a class named <strong class="source-inline">Alarm</strong>. The <strong class="source-inline">__init__()</strong> method takes optional parameters for the buzzer pin, two LED pins, and buzzer frequency with <span class="No-Break">default values.</span></li><li class="upper-roman">We then initialize the buzzer<a id="_idIndexMarker1016"/> on the specified pin as a PWM<a id="_idIndexMarker1017"/> output with the given frequency and a duty cycle of <strong class="source-inline">0</strong> (<span class="No-Break">off state).</span></li><li class="upper-roman">Our code sets up two LEDs on the specified pins as digital outputs, ready to be turned on <span class="No-Break">or off.</span></li></ol></li> <li>Our class contains only one <span class="No-Break">method, </span><span class="No-Break"><strong class="source-inline">activate_alarm()</strong></span><span class="No-Break">:</span><pre class="source-code">
    def activate_alarm(self, num_of_times=5):
        blink_rate = 0.5
        for _ in range(num_of_times):
            self.buzzer.duty_cycle = 32768
            self.led1.value = True
            self.led2.value = True
            time.sleep(blink_rate)
            self.buzzer.duty_cycle = 0
            self.led1.value = False
            self.led2.value = False
            time.sleep(blink_rate)</pre><p class="list-inset">In our code, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We define an <strong class="source-inline">activate_alarm()</strong> method within the <strong class="source-inline">Alarm</strong> class to activate the alarm a specified number of times (default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">).</span></li><li class="upper-roman">Inside the method, we set the <strong class="source-inline">blink_rate</strong> variable to <strong class="source-inline">0.5</strong> seconds, then loop for the specified number of times, toggling the buzzer and LEDs on and off according to the <span class="No-Break"><strong class="source-inline">blink_rate</strong></span><span class="No-Break"> variable.</span></li></ol></li> <li>To test our code and wiring, we use the <span class="No-Break">following code:</span><pre class="source-code">
alarm = Alarm(buzzer_pin=board.GP1, led_pin1=board.GP0, led_pin2=board.GP2)
alarm.activate_alarm(10)</pre></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">device_alarm.py</strong> to our Raspberry Pi <span class="No-Break">Pico H.</span></li>
<li>To run our code, we click on the green <strong class="bold">Run</strong> button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should observe<a id="_idIndexMarker1018"/> the buzzer<a id="_idIndexMarker1019"/> and LEDs blink for <span class="No-Break">10 repetitions.</span></li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">To prevent the execution of test code within our application, we either delete or comment out this <span class="No-Break">code segment.</span></p>
<p>With the alarm code written and tested, it is now time to test <span class="No-Break">the motors.</span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor222"/>Testing and controlling the motors</h2>
<p>To encapsulate<a id="_idIndexMarker1020"/> the motor <a id="_idIndexMarker1021"/>control functionality, we create a class called <strong class="source-inline">Wheel</strong> inside a file called <span class="No-Break"><strong class="source-inline">wheel.py</strong></span><span class="No-Break">.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Our code requires the <strong class="source-inline">PicoRobotics.py</strong> library that may be found in this chapter’s GitHub repository under <strong class="source-inline">code</strong> | <strong class="source-inline">PicoH</strong>. To download the library to our Pico H using Thonny, we first find the <strong class="source-inline">lib</strong> directory on our computer. We then right-click on the <strong class="source-inline">lib</strong> directory and select <strong class="bold">Upload </strong><span class="No-Break"><strong class="bold">to /</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer268">
<img alt="Figure 13.19 – Uploading the lib directory to our Pico H from our computer" height="458" src="image/B21282_13_19.jpg" width="613"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.19 – Uploading the lib directory to our Pico H from our computer</p>
<ol>
<li value="2">We open a new editor in Thonny and start our coding by importing the <strong class="source-inline">KitronikPicoRobotics</strong> and <strong class="source-inline">time</strong> libraries into <span class="No-Break">our program:</span><pre class="source-code">
from PicoRobotics import KitronikPicoRobotics
import time</pre></li> <li>These libraries will allow us to interface<a id="_idIndexMarker1022"/> with the Pico robotics board. We then define our class<a id="_idIndexMarker1023"/> <span class="No-Break">and methods:</span><pre class="source-code">
class Wheel:
    def __init__(self, speed):
        self.motor_board = KitronikPicoRobotics()
        self.speed = speed
    def forward(self):
        self.motor_board.motorOn(1, "f", self.speed)
        self.motor_board.motorOn(2, "f", self.speed)
    def reverse(self):
        self.motor_board.motorOn(1, "r", self.speed)
        self.motor_board.motorOn(2, "r", self.speed)
    def turn_right(self):
        self.motor_board.motorOn(1, "r", self.speed)
        self.motor_board.motorOn(2, "f", self.speed)
    def turn_left(self):
        self.motor_board.motorOn(1, "f", self.speed)
        self.motor_board.motorOn(2, "r", self.speed)
    def stop(self):
        self.motor_board.motorOff(1)
        self.motor_board.motorOff(2)</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">We define a <span class="No-Break"><strong class="source-inline">Wheel</strong></span><span class="No-Break"> class.</span></li><li class="upper-roman">The <strong class="source-inline">__init__()</strong> constructor initializes the class, setting instance variables including <strong class="source-inline">motor_board</strong>, which encapsulates the functionality of the Pico robotics motor board, and the <strong class="source-inline">speed</strong> parameter to control <span class="No-Break">motor speed.</span></li><li class="upper-roman">We implement a <strong class="source-inline">forward()</strong> method<a id="_idIndexMarker1024"/> to move both wheels forward<a id="_idIndexMarker1025"/> at the <span class="No-Break">specified speed.</span></li><li class="upper-roman">We implement a <strong class="source-inline">reverse()</strong> method to move both wheels in reverse at the <span class="No-Break">specified speed.</span></li><li class="upper-roman">We then implement a <strong class="source-inline">turn_right()</strong> method to rotate the robot right by running the left wheel forward and the right wheel in reverse at the <span class="No-Break">specified speed.</span></li><li class="upper-roman">We implement a <strong class="source-inline">turn_left()</strong> method to rotate the robot left by running the right wheel in reverse and the left wheel forward at the <span class="No-Break">specified speed.</span></li><li class="upper-roman">We then implement a <strong class="source-inline">stop()</strong> method to stop both motors, halting the <span class="No-Break">robot’s movement.</span></li></ol></li> <li>To test our code and wiring, we use the <span class="No-Break">following code:</span><pre class="source-code">
#Test code
wheel = Wheel()
wheel.forward()
time.sleep(1)
wheel.reverse()
time.sleep(1)
wheel.turn_right()
time.sleep(1)
wheel.turn_left()
time.sleep(1)
wheel.stop()</pre></li> <li>Before we run<a id="_idIndexMarker1026"/> the code, we must ensure<a id="_idIndexMarker1027"/> that the power switch on the motor board is turned on and the AA battery pack <span class="No-Break">is connected:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer269">
<img alt="Figure 13.20 – Closeup of the motor board and AA battery pack" height="630" src="image/B21282_13_20.jpg" width="1374"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.20 – Closeup of the motor board and AA battery pack</p>
<ol>
<li value="6">For testing purposes, we place A.R.E.S. on the testing stand to keep its wheels off the ground (<span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">).</span></li>
<li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">wheel.py</strong> to our Raspberry Pi <span class="No-Break">Pico H.</span></li>
<li>To run our code, we click on the green <strong class="bold">Run</strong> button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
</ol>
<p>We should observe the wheels on A.R.E.S. go through a sequence of moving forward, moving in reverse, moving right, and moving left, <span class="No-Break">before stopping.</span></p>
<p class="callout-heading">Tip</p>
<p class="callout">To avoid having our test code run outside of our test, we comment or delete it and save <strong class="source-inline">wheel.py</strong> onto our Pico <span class="No-Break">H again.</span></p>
<p>At this stage, we ensure the wheels move in the desired direction by adjusting the motor wiring on the motor board, which may involve rearranging the wires at the motor <span class="No-Break">wire terminals.</span></p>
<p>Having correctly configured<a id="_idIndexMarker1028"/> and tested the LEDs, buzzer, and motors connected<a id="_idIndexMarker1029"/> to the Pico H, we will now proceed to test communications between the Raspberry Pi Pico H and the Raspberry Pi 3B+ <span class="No-Break">onboard A.R.E.S.</span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor223"/>Testing communication between Pi and Pico</h2>
<p>In <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em>, we observe that communication<a id="_idIndexMarker1030"/> between the Raspberry Pi 3B+ and the Raspberry<a id="_idIndexMarker1031"/> Pi Pico H on A.R.E.S. is done through UART. Specifically, messages are sent from the Raspberry Pi 3B+ to the Pico H to control the LEDs, buzzer, and motors connected to the Pico H. We wired up the two devices through their respective GPIO ports when we <span class="No-Break">built A.R.E.S.</span></p>
<p>In this section, we will test communication using a Python test script located in this chapter’s GitHub repository and a new file we will create on our Pico H. We will start with our <span class="No-Break">Pico H.</span></p>
<h3>Creating the Pico H script</h3>
<p>To create the code<a id="_idIndexMarker1032"/> on our Pico H that will await commands from the Raspberry Pi 3B+, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We open a new editor in Thonny and start our coding by importing the libraries we need for <span class="No-Break">our program:</span><pre class="source-code">
import board
import busio
import time
from wheel import Wheel
from device_alarm import Alarm</pre><p class="list-inset">In our code, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">board</strong> module for accessing physical <span class="No-Break">pin definitions.</span></li><li class="upper-roman">We then import the <strong class="source-inline">busio</strong> module for bus communication (<span class="No-Break">UART) functionalities.</span></li><li class="upper-roman">We use the <strong class="source-inline">time</strong> module for <span class="No-Break">performing delays.</span></li><li class="upper-roman">We import our <strong class="source-inline">Wheel</strong> class from our <span class="No-Break"><strong class="source-inline">wheel</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">We then import the <strong class="source-inline">Alarm</strong> class from the <strong class="source-inline">device_alarm</strong> module <span class="No-Break">we created.</span></li></ol></li> <li>With our imports in place, we set our <span class="No-Break">variable declarations:</span><pre class="source-code">
wheel = Wheel(20)
alarm = Alarm()
uart = busio.UART(board.GP4, board.GP5, baudrate=115200)</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">wheel = Wheel(20)</strong>: Creates an instance of the <strong class="source-inline">Wheel</strong> class with a speed parameter set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">alarm = Alarm()</strong>: Initializes an instance of the <span class="No-Break"><strong class="source-inline">Alarm</strong></span><span class="No-Break"> class.</span></li><li><strong class="source-inline">uart = busio.UART(board.GP4, board.GP5, baudrate=115200)</strong>: Establishes a UART communication link using pins <strong class="source-inline">GP4</strong> and <strong class="source-inline">GP5</strong> on the Pico H, setting the baud rate <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">115200</strong></span><span class="No-Break">.</span></li></ul></li> <li>We then create a function<a id="_idIndexMarker1033"/> to clear out our UART buffer by continuously reading it until no data remains (to ensure accurate and current data communication by removing old or irrelevant data that could lead <span class="No-Break">to errors):</span><pre class="source-code">
def clear_uart_buffer():
    while uart.in_waiting &gt; 0:
        uart.read(uart.in_waiting)</pre></li> <li>Our code then runs in a continuous loop waiting for messages <span class="No-Break">over UART:</span><pre class="source-code">
while True:
    data = uart.read(uart.in_waiting or 32)
    while '&lt;' in message_buffer and '&gt;' in message_buffer:
        start_index = message_buffer.find('&lt;') + 1
        end_index = message_buffer.find('&gt;', start_index)
        message = message_buffer[start_index:end_index].strip()
        message_buffer = message_buffer[end_index+1:]
        print("Received:", message)
        if message == 'f':
            print("Moving forward")
            wheel.forward()
        elif message == 'b':
            print("Moving in reverse")
            wheel.reverse()
        elif message == 'l':
            print("Left turn")
            wheel.turn_left()
        elif message == 'r':
            print("Right turn")
            wheel.turn_right()
        elif message == 'a':
            print("Alarm")
            wheel.stop()
            alarm.activate_alarm(2)
        elif message == 's':
            print("Stop")
            wheel.stop()</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">We continuously<a id="_idIndexMarker1034"/> read up to 32 bytes of data from the <span class="No-Break">UART connection.</span></li><li class="upper-roman">We strip away the enclosing <span class="No-Break">angle brackets.</span></li><li class="upper-roman">We print out the received message for <span class="No-Break">debugging purposes.</span></li><li class="upper-roman">We use an <strong class="source-inline">if</strong> statement to execute a specific action based on the <span class="No-Break">message content:</span><ul><li>The robot moves forward if the message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'f'</strong></span><span class="No-Break">.</span></li><li>The robot moves in reverse if the message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'b'</strong></span><span class="No-Break">.</span></li><li>The robot turns left if the message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'l'</strong></span><span class="No-Break">.</span></li><li>The robot turns right if the message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'r'</strong></span><span class="No-Break">.</span></li><li>The robot activates an alarm and stops movement if the message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'a'</strong></span><span class="No-Break">.</span></li><li>The robot stops any movement if the message doesn’t match any of the <span class="No-Break">specified commands.</span></li></ul></li><li class="upper-roman">Our code then clears the UART buffer to remove any <span class="No-Break">remaining data.</span></li><li class="upper-roman">We then introduce a brief delay of 0.1 seconds to prevent overwhelming <span class="No-Break">the CPU.</span></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">code.py</strong> to our Raspberry Pi <span class="No-Break">Pico H.</span></li>
<li>To run our code, we click on the green <strong class="bold">Run</strong> button, hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
</ol>
<p>After executing <strong class="source-inline">code.py</strong>, it is expected that our code will not produce any output in the Shell, indicating it is in a state<a id="_idIndexMarker1035"/> of waiting for communication from the Raspberry Pi. With the Pico H set up and waiting for messages it is now time to execute our test script from the <span class="No-Break">Raspberry Pi.</span></p>
<h3>Running UART test code from the Raspberry Pi</h3>
<p>Inside this chapter’s GitHub<a id="_idIndexMarker1036"/> repository, we have a file<a id="_idIndexMarker1037"/> named <strong class="source-inline">uart-test.py</strong> that we may use to test the connection between the Raspberry Pi and Pico H on our A.R.E.S. robot. In this section, we will SSH into our Raspberry Pi from a Windows computer using PuTTY and run the test, all the while keeping our Pico connected <span class="No-Break">through Thonny.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a program such as PuTTY<a id="_idIndexMarker1038"/> on Windows, or a Terminal<a id="_idIndexMarker1039"/> on a Linux-based system, we log in to our Raspberry Pi 3B+ using the IP address (as the hostname) we obtained after running the <span class="No-Break">setup script:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer270">
<img alt="Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+" height="543" src="image/B21282_13_21.jpg" width="669"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+</p>
<ol>
<li value="2">If this is the first time logging in through PuTTY, we may get a security alert. We click <strong class="bold">Accept</strong> <span class="No-Break">to proceed.</span></li>
<li>To copy our test program to the current directory, we run the following command (we must not forget <span class="No-Break">the dot):</span><pre class="source-code">
<strong class="bold">cp code/Chapter13/code/uart-test.py .</strong></pre></li> <li>If we wish to view the script before running it, we may do so using <strong class="source-inline">vi</strong> with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">vi uart-test.py</strong></pre><p class="list-inset">Running the command will produce the <span class="No-Break">following output:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer271">
<img alt="Figure 13.22 – Viewing uart-test.py in the vi editor" height="371" src="image/B21282_13_22.jpg" width="969"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.22 – Viewing uart-test.py in the vi editor</p>
<ol>
<li value="5">We close the editor with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">:q</strong></pre></li> <li>To address the lack of serial port<a id="_idIndexMarker1040"/> access under the default<a id="_idIndexMarker1041"/> username, the test must be conducted with admin privileges. With the Pico H connected to Thonny and <strong class="source-inline">code.py</strong> executing, the following command initiates <span class="No-Break">the test:</span><pre class="source-code">
<strong class="bold">sudo python3 uart-test.py</strong></pre></li> <li>We should observe the LEDs and buzzer activating in two pulses, with Thonny’s output confirming receipt of an <span class="No-Break">alarm message:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer272">
<img alt="Figure 13.23 – Results from running the uart-test.py test script" height="442" src="image/B21282_13_23.jpg" width="1419"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.23 – Results from running the uart-test.py test script</p>
<p>With the successful testing<a id="_idIndexMarker1042"/> of the UART connection<a id="_idIndexMarker1043"/> between the Raspberry Pi and Raspberry Pi Pico H on our A.R.E.S. robot, it is now time to test the <span class="No-Break">distance sensor.</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Testing the ToF sensor</h2>
<p>To measure distances<a id="_idIndexMarker1044"/> in front of A.R.E.S., we will use the VL53L0X ToF sensor from Adafruit. The sensor is capable of measuring distances from 30 mm to 1.2 meters with high accuracy, using a tiny laser to detect light’s travel time. Its narrow beam overcomes<a id="_idIndexMarker1045"/> the limitations of sonar or <strong class="bold">infrared</strong> (<strong class="bold">IR</strong>) sensors, making it ideal for precision tasks in robotics and interactive projects. Compatible with 3-5V and I2C communication, it’s designed for easy use with <span class="No-Break">various microcontrollers.</span></p>
<p>For A.R.E.S., we have the VL53L0X connected to our Raspberry Pi 3B+. We will use it in our design to stop our robot from moving forward once it detects an object less than 10 <span class="No-Break">cm away.</span></p>
<p>To test the sensor, we run a test script available in this chapter’s GitHub repository. To run the test, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system, we log in to our Raspberry Pi 3B+ using the IP address we obtained after running the <span class="No-Break">setup script.</span></li>
<li>To copy our test program<a id="_idIndexMarker1046"/> to the current directory, we run the following command (we must not forget <span class="No-Break">the dot):</span><pre class="source-code">
<strong class="bold">cp code/Chapter13/code/distance-sensor-test.py .</strong></pre></li> <li>To run the test, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 distance-sensor-test.py</strong></pre></li> <li>By positioning a hand at varying distances from the sensor, which is integrated into A.R.E.S.’s mouth, we should observe corresponding variations in the sensor’s output values displayed in <span class="No-Break">the terminal:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer273">
<img alt="Figure 13.24 – Output from the testing of the VL53L0X ToF sensor" height="371" src="image/B21282_13_24.jpg" width="820"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.24 – Output from the testing of the VL53L0X ToF sensor</p>
<p class="callout-heading">Are ToF sensors the same as distance sensors?</p>
<p class="callout">A ToF sensor, measuring<a id="_idIndexMarker1047"/> the time for light to bounce back from<a id="_idIndexMarker1048"/> an object, provides precise distance readings. In contrast, traditional distance sensors, often using ultrasonic or IR technology, gauge distances based on sound waves or light intensity. ToF sensors typically offer higher accuracy and reliability across various ranges compared to these common <span class="No-Break">distance sensors.</span></p>
<p>With the ToF sensor operational, we’re set to configure A.R.E.S.’s camera, which, unlike the Raspberry Pi and Pico H, streams<a id="_idIndexMarker1049"/> video outside the ROS environment, accessible by any <span class="No-Break">network device.</span></p>
<p>We will use the Arduino IDE to program <span class="No-Break">the camera.</span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Streaming video from A.R.E.S.</h2>
<p>For video streaming, we’ll use<a id="_idIndexMarker1050"/> the M5Stack Timer Camera<a id="_idIndexMarker1051"/> X, powered by an ESP32 chip with a 3-million-pixel (ov3660) sensor for up to 2048x1536 pixel images. Although it supports I2C for configuration, we’ll directly power it with the Raspberry Pi 3B+’s 5V supply, bypassing the I2C setup. The camera serves as the nose of our <span class="No-Break">A.R.E.S. robot.</span></p>
<p>We will use the Arduino IDE and a program provided by M5Stack to set up the camera. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a web browser, navigate to the Arduino website<a id="_idIndexMarker1052"/> and download the latest Arduino IDE <span class="No-Break">from </span><a href="https://www.arduino.cc/en/software"><span class="No-Break">https://www.arduino.cc/en/software</span></a><span class="No-Break">.</span></li>
<li>Once downloaded, we install the Arduino IDE and <span class="No-Break">open it.</span></li>
<li>To add our M5Stack Timer Camera X library and example code to the Arduino IDE, we select <strong class="bold">File</strong> | <strong class="bold">Preferences</strong> (in Windows) and add the following URL to the <strong class="bold">Additional boards manager URLs</strong> <span class="No-Break">box: </span><a href="https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json"><span class="No-Break">https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json</span></a><span class="No-Break">.</span></li>
<li>The dialog box should look like <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer274">
<img alt="Figure 13.25 – Adding M5Stack boards to the Arduino IDE" height="587" src="image/B21282_13_25.jpg" width="949"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.25 – Adding M5Stack boards to the Arduino IDE</p>
<ol>
<li value="5">We click <strong class="bold">OK</strong> to close <span class="No-Break">the dialog.</span></li>
<li>Using a USB-C cable, we connect<a id="_idIndexMarker1053"/> our Timer Camera X to the computer<a id="_idIndexMarker1054"/> running the Arduino IDE. We may remove the camera from the face of A.R.E.S. to make it easier to access the <span class="No-Break">USB-C port.</span></li>
<li>To set <strong class="bold">M5TimerCAM</strong> as the device, we click on <strong class="bold">Tools</strong> | <strong class="bold">Board</strong> | <strong class="bold">M5Stack</strong> | <span class="No-Break"><strong class="bold">M5TimerCAM</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer275">
<img alt="Figure 13.26 – Selecting M5TimerCAM" height="698" src="image/B21282_13_26.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.26 – Selecting M5TimerCAM</p>
<ol>
<li value="8">Next, we need to select<a id="_idIndexMarker1055"/> the port our camera<a id="_idIndexMarker1056"/> is connected to. To do this, we click on <strong class="bold">Tools</strong> | <strong class="bold">Port</strong> and select the port our camera is connected to (it helps to only have the camera connected to our computer as there will be only <span class="No-Break">one option).</span></li>
<li>To access the M5Stack Timer Camera example code, we click on <strong class="bold">Tools</strong> | <strong class="bold">Manage Libraries…</strong> and search <span class="No-Break">for </span><span class="No-Break"><strong class="bold">Timer-CAM</strong></span><span class="No-Break">.</span></li>
<li>We then hover our mouse beside the title of the section until three dots appear and select <strong class="bold">Examples</strong> | <span class="No-Break"><strong class="bold">rtsp_stream</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer276">
<img alt="Figure 13.27 – Selecting the rtsp_stream example code" height="456" src="image/B21282_13_27.jpg" width="594"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.27 – Selecting the rtsp_stream example code</p>
<ol>
<li value="11">This will open another<a id="_idIndexMarker1057"/> Arduino window<a id="_idIndexMarker1058"/> with the <span class="No-Break">example code.</span></li>
<li>We need the Serial Monitor to find the address where the video will be broadcast. To load the Serial Monitor, we click on <strong class="bold">Tools</strong> | <span class="No-Break"><strong class="bold">Serial Monitor</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer277">
<img alt="Figure 13.28 – Viewing the Serial Monitor" height="646" src="image/B21282_13_28.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.28 – Viewing the Serial Monitor</p>
<ol>
<li value="13">We set the baud rate to <strong class="source-inline">115200</strong> and enter the SSID name and password into the code (areas annotated in the <span class="No-Break">previous figure).</span></li>
<li>To upload the code<a id="_idIndexMarker1059"/> to our camera, we click<a id="_idIndexMarker1060"/> on the <strong class="bold">Upload</strong> button, which looks like <span class="No-Break">this: <img alt="" height="46" role="presentation" src="image/B21282_13_29.png" width="45"/>.</span></li>
<li>After compilation, the code is uploaded to our camera. We may view the <strong class="source-inline">rtsp</strong> address in the <span class="No-Break">Serial Monitor:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer279">
<img alt="" height="181" role="presentation" src="image/B21282_13_30.jpg" width="651"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.29 – Output to the Serial Monitor</p>
<ol>
<li value="16"> We copy the <strong class="source-inline">rtsp</strong> URL and paste<a id="_idIndexMarker1061"/> it into a VLC media<a id="_idIndexMarker1062"/> player by clicking on <strong class="bold">Media</strong> | <strong class="bold">Open Network Stream…</strong> in the VLC <span class="No-Break">media player:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer280">
<img alt="Figure 13.30 – Video streaming using the VLC media player" height="378" src="image/B21282_13_31.jpg" width="534"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.30 – Video streaming using the VLC media player</p>
<ol>
<li value="17">To begin streaming, we click on the <span class="No-Break"><strong class="bold">Play</strong></span><span class="No-Break"> button.</span></li>
<li>We should observe a feed from <span class="No-Break">our camera:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer281">
<img alt="Figure 13.31 – Video feed from our camera as shown in the VLC media player" height="355" src="image/B21282_13_32.jpg" width="803"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.31 – Video feed from our camera as shown in the VLC media player</p>
<p>A.R.E.S. is currently missing its nose, but after<a id="_idIndexMarker1063"/> testing the camera, we can disconnect the USB-C cable and reattach<a id="_idIndexMarker1064"/> it to A.R.E.S.’s face. This completes the testing phase for A.R.E.S.’s components, paving the way for us to develop a ROS node and enable control of A.R.E.S. over <span class="No-Break">the internet.</span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor226"/>Programming A.R.E.S. with ROS</h1>
<p>Now that A.R.E.S. has been assembled<a id="_idIndexMarker1065"/> and the essential software<a id="_idIndexMarker1066"/> and firmware have been installed, we are ready to employ ROS for remote control over the internet. During our setup, we installed ROS along with all the necessary libraries. Along with our setup script, we downloaded test scripts from our GitHub repository, which we ran to ensure everything was <span class="No-Break">functioning correctly.</span></p>
<p>A pre-existing ROS workspace also exists in our GitHub repository. To create a ROS node with this code, simply transfer the pre-existing workspace to our <strong class="source-inline">home</strong> directory and execute a <strong class="source-inline">colcon </strong><span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system, we log in to our Raspberry Pi 3B+ using the IP address we obtained after running the <span class="No-Break">setup script.</span></li>
<li>To copy our ROS workspace<a id="_idIndexMarker1067"/> to the current directory, we run<a id="_idIndexMarker1068"/> the following command (we must not forget <span class="No-Break">the dot):</span><pre class="source-code">
<strong class="bold">cp -r code/Chapter13/code/ares_ws .</strong></pre></li> <li>We then navigate into our workspace with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd ares_ws</strong></pre></li> <li>We source the ROS environment with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre></li> <li>Before we build our ROS node, let’s look at the code we will be building. To use <strong class="source-inline">nano</strong> to view our code, we type <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">nano src/ares/ares/robot_control.py</strong></pre></li> <li>As our code is very similar to the <strong class="source-inline">robot_control.py</strong> file from <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, we will explore only certain parts of the code. We start with code located inside the initialization method we use to give us the permissions to use the <span class="No-Break"><strong class="source-inline">serial0</strong></span><span class="No-Break"> port:</span><pre class="source-code">
        password = 'sudo-password'
        command = 'chmod a+rw /dev/serial0'
        subprocess.run(f'echo {password} | sudo -S {
    command}', shell=True, check=True)</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">It is highly advisable not to put the admin password inside a file due to security concerns. However, with our application operating in a strictly controlled development environment where access is tightly restricted, we bypass this guideline. We require this password so that we may change permissions on the <strong class="source-inline">serial0</strong> port. Without it, we would not have access and thus could not send commands to the <span class="No-Break">Pico H.</span></p>
<p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p>
<ol>
<li class="upper-roman">We store a <strong class="source-inline">sudo</strong> user’s password in the <strong class="source-inline">password</strong> variable. We set the command to change permissions of <strong class="source-inline">/dev/serial0</strong> to read and write for all users in the <span class="No-Break"><strong class="source-inline">command</strong></span><span class="No-Break"> variable.</span></li>
<li class="upper-roman">Our code then executes<a id="_idIndexMarker1069"/> the command using <strong class="source-inline">sudo</strong> without manual password<a id="_idIndexMarker1070"/> entry by piping the password into <strong class="source-inline">sudo -S</strong>, utilizing <strong class="source-inline">subprocess.run</strong> with shell execution enabled and enforcing command success <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">check=True</strong></span><span class="No-Break">.</span></li>
</ol>
<ol>
<li value="7">Inside the initialization method, we also set the <strong class="source-inline">ser</strong> instance variable to be equal to <strong class="source-inline">serial0</strong>, the port we connect our Pico <span class="No-Break">H to:</span><pre class="source-code">
self.ser = serial.Serial('/dev/serial0', 115200, timeout=1)</pre></li> <li>Our <strong class="source-inline">send_message()</strong> method formats a command to sit within open (<strong class="source-inline">&lt;</strong>) and closed (<strong class="source-inline">&gt;</strong>) angle brackets and sends out messages over the <span class="No-Break">serial port:</span><pre class="source-code">
    def send_message(self, command):
        if command.strip() == 's' and
self.last_command_sent == 's':
            print("Skip sending 's' command
  to avoid sending it two times in a row")
            return
        framed_command = f"&lt;{command}&gt;\n"
        print(f"Sending framed command:
          {framed_command.strip()}")
        self.ser.write(framed_command.encode
        self.get_logger().info(f"Sent command: {command.strip()}")
        self.last_command_sent = command.strip()</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">We check if the current <a id="_idIndexMarker1071"/>command is <strong class="source-inline">'s'</strong> and if the last<a id="_idIndexMarker1072"/> sent command was also <strong class="source-inline">'s'</strong> to prevent sending <strong class="source-inline">'s'</strong> consecutively. This is done as the stop command is the default command when there is no engagement with the IoT joystick and thus can flood the communication channel with redundant signals, potentially causing unnecessary processing and response delays in <span class="No-Break">the system.</span></li><li class="upper-roman">If the preceding condition is met, our code skips sending the command and logs a message <span class="No-Break">about it.</span></li><li class="upper-roman">We then format <strong class="source-inline">command</strong> with opening (<strong class="source-inline">&lt;</strong>) and closing (<strong class="source-inline">&gt;</strong>) angle brackets, followed by <span class="No-Break">a newline.</span></li><li class="upper-roman">We log the framed command being sent. Our code then sends the framed command over the serial port using <strong class="source-inline">.encode()</strong> to convert it <span class="No-Break">to bytes.</span></li><li class="upper-roman">We log the original command (stripped of whitespace) as sent. Our code then updates <strong class="source-inline">self.last_command_sent</strong> with the current command (stripped of whitespace) for <span class="No-Break">future checks.</span></li></ol><p class="list-inset">To build our code, we execute the <span class="No-Break"><strong class="source-inline">colcon</strong></span><span class="No-Break"> command:</span></p><pre class="source-code"><strong class="bold">colcon build</strong></pre></li> <li>After building our node, we source it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source install/setup.bash</strong></pre></li> <li>We are now ready to run our node to have our robot controlled by our IoT Joystick. We do so with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">ros2 run ares robot_control</strong></pre></li> </ol>
<p class="callout-heading">Tip</p>
<p class="callout">It is advisable to have A.R.E.S. up on the test stand before we send it commands. With our node running, we may control A.R.E.S. using the IoT joystick we built in <a href="B21282_12.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><span class="No-Break">.</span></p>
<p>We have just controlled a robot over the internet using MQTT and ROS. Controlling a robot over the internet using MQTT and ROS not only demonstrates the technical feasibility of remote robotic<a id="_idIndexMarker1073"/> operations but also highlights<a id="_idIndexMarker1074"/> the potential for use cases where remote monitoring and intervention<a id="_idIndexMarker1075"/> are critical, such as in <strong class="bold">disaster recovery</strong> (<strong class="bold">DR</strong>), hazardous environment exploration, and <span class="No-Break">healthcare support.</span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor227"/>Summary</h1>
<p>In this chapter, we integrated MQTT and ROS and created the A.R.E.S. robot. Using MQTT, a lightweight messaging protocol, enabled us to have efficient and reliable communication between the robot and our IoT joystick. ROS offers us a robust framework for developing complex robotic applications. By choosing ROS to build A.R.E.S., we leverage its vast ecosystem of tools and libraries, ensuring our robot is not only capable of performing advanced tasks but is also scalable and adaptable for <span class="No-Break">future enhancements.</span></p>
<p>As we built and programmed A.R.E.S., we could easily imagine using our knowledge to build more advanced robots capable of performing complex tasks, interacting seamlessly with humans, and adapting to various environments and <span class="No-Break">challenges autonomously.</span></p>
<p>In our next and final chapter, we will add vision recognition <span class="No-Break">to A.R.E.S.</span></p>
</div>
</div></body></html>