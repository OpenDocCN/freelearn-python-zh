- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Sorting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: Sorting means reorganizing data in such a way that it is in ascending or descending
    order. Sorting is one of the most important algorithms in computer science and
    is widely used in database-related algorithms. For several applications, if the
    data is sorted, it can efficiently be retrieved, for example, if it is a collection
    of names, telephone numbers, or items on a simple to-do list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 排序意味着以升序或降序重新组织数据。排序是计算机科学中最重要算法之一，在数据库相关算法中得到广泛应用。对于一些应用，如果数据已排序，可以有效地检索，例如，如果它是一组名称、电话号码或简单的待办事项列表中的项目。
- en: 'In this chapter, we’ll study some of the most important and popular sorting
    techniques, including the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些最重要和最受欢迎的排序技术，包括以下内容：
- en: Bubble sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Insertion sort
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Selection sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Quicksort
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Timsort
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Timsort
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All source code used to explain the concepts of this chapter is provided in
    the GitHub repository at the following link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解释本章概念所使用的所有源代码都提供在以下GitHub仓库链接中：
- en: '[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11)'
- en: Sorting algorithms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法
- en: Sorting means arranging all the items in a list in ascending or descending order.
    We can compare different sorting algorithms by how much time and memory space
    is required to use them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 排序意味着将列表中的所有项目按升序或降序排列。我们可以通过比较使用不同排序算法所需的时间和内存空间来比较不同的排序算法。
- en: The time taken by an algorithm changes depending on the input size. Moreover,
    some algorithms are relatively easy to implement, but may perform poorly with
    respect to time and space complexity, whereas other algorithms are slightly more
    complex to implement, but can perform well when sorting longer lists of data.
    One of the sorting algorithm, merge sort, we have already discussed in *Chapter
    3*, *Algorithm Design Techniques and Strategies*. We will discuss several more
    sorting algorithms one by one in detail along with their implementation details,
    starting with the bubble sort algorithm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的时间取决于输入大小。此外，一些算法相对容易实现，但在时间和空间复杂度方面可能表现不佳，而其他算法虽然实现起来稍微复杂一些，但在排序较长的数据列表时可以表现良好。我们已经在
    *第3章*，*算法设计技术和策略* 中讨论了其中一种排序算法，即归并排序。我们将逐一详细讨论更多排序算法及其实现细节，从冒泡排序算法开始。
- en: Bubble sort algorithms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序算法
- en: The idea behind the bubble sort algorithm is very simple. Given an unordered
    list, we compare adjacent elements in the list, and after each comparison, we
    place them in the right order according to their values. So, we swap the adjacent
    items if they are not in the correct order. This process is repeated `n-1` times
    for a list of `n` items.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法背后的思想非常简单。给定一个无序列表，我们比较列表中的相邻元素，并在每次比较后，根据它们的值将它们放置在正确的顺序。因此，如果相邻的项目不在正确的顺序，我们就交换它们。这个过程会重复
    `n-1` 次，对于 `n` 个项目的列表。
- en: In each iteration, the largest element of the list is moved to the end of the
    list. After the second iteration, the second largest element will be placed at
    the second-to-last position in the list. The same process is repeated until the
    list is sorted.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，列表中的最大元素被移动到列表的末尾。在第二次迭代后，第二大的元素将被放置在列表的倒数第二位。这个过程会重复进行，直到列表排序完成。
- en: 'Let’s take a list with only two elements, {`5`, `2`}, to understand the concept
    of bubble sort, as shown in *Figure 11.1*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个只有两个元素的列表 `{`5`, `2`}` 来理解冒泡排序的概念，如图 *图11.1* 所示：
- en: '![](img/B17217_11_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_01.png)'
- en: 'Figure 11.1: Example of bubble sort'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：冒泡排序示例
- en: 'To sort this list of two elements, first, we compare `5` and `2`; since `5`
    is greater than `2`, it means they are not in the correct order, so we swap these
    values to put them in the correct order. To swap these two numbers, first, we
    move the element stored at index `0` in a temporary variable (*step 1* of *Figure
    11.2*), then the element stored at index `1` is copied to index `0` (*step 2*
    of *Figure 11.2)*, and finally the first element stored in the temporary variable
    is stored back at index `1` (*step 3* of *Figure 11.2*). So, first, element `5`
    is copied to a temporary variable, `temp`. Then, element `2` is moved to index
    `0`. Finally, `5` is moved from `temp` to index `1`. The list will now contain
    the elements as `[2, 5]`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要对这个包含两个元素的列表进行排序，首先，我们比较`5`和`2`；由于`5`大于`2`，这意味着它们不在正确的顺序中，因此我们需要交换这些值以将它们放置在正确的顺序。为了交换这两个数字，首先，我们将存储在索引`0`的元素移动到一个临时变量中（*图11.2*的第1步），然后存储在索引`1`的元素被复制到索引`0`（*图11.2*的第2步），最后，临时变量中存储的第一个元素被存储回索引`1`（*图11.2*的第3步）。因此，首先，元素`5`被复制到一个临时变量`temp`中。然后，元素`2`被移动到索引`0`。最后，`5`从`temp`移动到索引`1`。列表现在将包含元素`[2,
    5]`：
- en: '![](img/B17217_11_02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_02.png)'
- en: 'Figure 11.2: Swapping of two elements in bubble sort'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：冒泡排序中两个元素的交换
- en: 'The following code will swap the elements of `unordered_list[0]` with `unordered_list[1]`
    if they are not in the right order:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在`unordered_list[0]`和`unordered_list[1]`不在正确顺序的情况下交换它们的元素：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the above code is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have been able to swap a two-element array, it should be simple
    to use this same idea to sort a whole list using bubble sort.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够交换一个包含两个元素的数组，那么使用冒泡排序对这个整个列表进行排序应该很简单。
- en: Let’s consider another example to understand the working of the bubble sort
    algorithm and sort an unordered list of six elements, such as {`45`, `23`, `87`,
    `12`, `32`, `4`}. In the first iteration, we start comparing the first two elements,
    `45` and `23`, and we swap them, as `45` should be placed after `23`. Then, we
    compare the next adjacent values, `45` and `87`, to see whether they are in the
    correct order. As `87` is a higher value than `45`, we do not need to swap them.
    We swap two elements if they are not in the correct order.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子来理解冒泡排序算法的工作原理，并排序一个包含六个元素的未排序列表，例如 `{`45`，`23`，`87`，`12`，`32`，`4`}`。在第一次迭代中，我们开始比较前两个元素，`45`和`23`，并将它们交换，因为`45`应该放在`23`之后。然后，我们比较下一个相邻的值，`45`和`87`，看看它们是否处于正确的顺序。由于`87`的值高于`45`，我们不需要交换它们。如果它们不在正确的顺序中，我们将交换两个元素。
- en: 'We can see, in *Figure 11.3*, that after the first iteration of the bubble
    sort, the largest element, `87`, is placed in the last position of the list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图11.3*中看到，在冒泡排序的第一次迭代之后，最大的元素`87`被放置在列表的最后一个位置：
- en: '![](img/B17217_11_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_03.png)'
- en: 'Figure 11.3: Steps of the first iteration to sort an example array using bubble
    sort'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：使用冒泡排序对示例数组进行第一次迭代的步骤
- en: 'After the first iteration, we just need to arrange the remaining `(n-1)` elements;
    we repeat the same process by comparing the adjacent elements for the remaining
    five elements. After the second iteration, the second largest element, `45`, is
    placed at the second-to-last position in the list, as shown in *Figure 11.4*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代之后，我们只需要排列剩下的`(n-1)`个元素；我们通过比较剩余的五个元素的相邻元素来重复相同的过程。在第二次迭代之后，第二大元素`45`被放置在列表的倒数第二位置，如图*图11.4*所示：
- en: '![](img/B17217_11_04.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_04.png)'
- en: 'Figure 11.4: Steps of the second iteration to sort an example array using bubble
    sort'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：使用冒泡排序对示例数组进行第二次迭代的步骤
- en: 'Next, we have to compare the remaining `(n-2)` elements to arrange them as
    shown in *Figure 11.5*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须比较剩下的`(n-2)`个元素，以按照*图11.5*所示的方式排列它们：
- en: '![](img/B17217_11_05.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_05.png)'
- en: 'Figure 11.5: Steps of the third iteration to sort an example array using bubble
    sort'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：使用冒泡排序对示例数组进行第三次迭代的步骤
- en: 'Similarly, we compare the remaining elements to sort them, as well, as shown
    in *Figure 11.6*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们比较剩下的元素以对它们进行排序，如图*图11.6*所示：
- en: '![](img/B17217_11_06.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_06.png)'
- en: 'Figure 11.6: Steps of the fourth iteration to sort an example array using bubble
    sort'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：使用冒泡排序对示例数组进行第四次迭代的步骤
- en: 'Finally, for the last two remaining elements, we place them in the correct
    order to obtain the final sorted list, as shown in *Figure 11.7*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于剩下的最后两个元素，我们将它们放置在正确的顺序，以获得最终的排序列表，如图*11.7*所示：
- en: '![](img/B17217_11_07.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_07.png)'
- en: 'Figure 11.7: Steps of the fifth iteration to sort an example array using bubble
    sort'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：使用冒泡排序对示例数组进行排序的第五次迭代的步骤
- en: 'The complete Python code of the bubble sort algorithm is shown below, and afterward,
    each step is explained in detail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的完整 Python 代码如下，之后将详细解释每个步骤：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bubble sort is implemented using a double-nested loop, wherein one loop is inside
    another loop. In bubble sort, the inner loop repeatedly compares and swaps the
    adjacent elements in each iteration for a given list, and the outer loop keeps
    track of how many times the inner loop should be repeated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序使用双层循环实现，其中一个循环嵌套在另一个循环中。在冒泡排序中，内循环在每次迭代中重复比较和交换给定列表中的相邻元素，而外循环跟踪内循环应该重复多少次。
- en: Firstly, in the above code, we compute how many times the loop should run to
    complete all swaps; this is equal to the length of the list minus 1 and could
    be written as `iteration_number = len(unordered_list)-1`. Here, the `len` function
    will give the length of the list. We subtract 1 because it gives us exactly the
    maximum number of iterations to run. The outer loop ensures this and executes
    for one minus the size of the list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在上面的代码中，我们计算循环应该运行多少次才能完成所有交换；这等于列表长度减 1，可以写成 `iteration_number = len(unordered_list)-1`。在这里，`len`
    函数将给出列表的长度。我们减去 1，因为它给出了运行的最大迭代次数。外循环确保这一点，并执行列表大小减 1 次的迭代。
- en: 'Further, in the above code, for each iteration, in the inner loop, we compare
    the adjacent elements using the `if` statement, and we check if the adjacent elements
    are in the correct order or not. For the first iteration, the inner loop should
    run for `n` times, for the second iteration, the inner loop should run `n-1` times,
    and so on. For example, to sort a list of three numbers say `[3, 2, 1]`, the inner
    loop runs two times, and we need to swap the elements a maximum of two times as
    shown in *Figure 11.8*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上面的代码中，对于每次迭代，在内循环中，我们使用 `if` 语句比较相邻的元素，并检查相邻的元素是否处于正确的顺序。对于第一次迭代，内循环应该运行
    `n` 次，对于第二次迭代，内循环应该运行 `n-1` 次，依此类推。例如，要排序一个包含三个数字的列表，例如 `[3, 2, 1]`，内循环运行两次，我们最多需要交换两次，如
    *图 11.8* 所示：
- en: '![](img/B17217_11_08.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_08.png)'
- en: 'Figure 11.8: Number of swaps in iteration 1 for an example list [3, 2, 1]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：示例列表 [3, 2, 1] 在第一次迭代中的交换次数
- en: 'Further, after the first iteration, in the second iteration, we execute the
    inner loop once as shown in *Figure 11.9*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第一次迭代之后，在第二次迭代中，我们执行内循环一次，如 *图 11.9* 所示：
- en: '![](img/B17217_11_09.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_09.png)'
- en: 'Figure 11.9: Number of swaps in iteration 2 for an example list [3, 2, 1]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：示例列表 [3, 2, 1] 在第二次迭代中的交换次数
- en: 'The following code snippet can be used to deploy the bubble sort algorithm:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可以用来部署冒泡排序算法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the worst case, the number of comparisons required in the firstiteration
    will be (`n-1`), in the second, the number of comparisons will be (`n-2`), and
    in the third iteration it will be (`n-3`), and so on. Therefore, the total number
    of comparisons required in the bubble sort will be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，第一次迭代所需的比较次数将是 (`n-1`)，第二次迭代时比较次数将是 (`n-2`)，第三次迭代时将是 (`n-3`)，依此类推。因此，冒泡排序所需的总比较次数如下：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The bubble sort algorithm is not an efficient sorting algorithm, as it provides
    a worst-case runtime complexity of `O(n`²`)`, and a best-case complexity of `O(n)`.
    The worst-case situation occurs when we want to sort the given list in ascending
    order and the given list is in descending order, and the best case occurs when
    the given list is already sorted; in that case, there will not be any need for
    swapping.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法不是一个高效的排序算法，因为它提供了最坏情况下的运行时间复杂度为 `O(n²)`，以及最佳情况下的复杂度为 `O(n)`。最坏的情况发生在我们想要按升序排序给定的列表，而给定的列表是降序排列的情况下，而最佳情况发生在给定的列表已经排序的情况下；在这种情况下，将不需要进行交换。
- en: Generally, the bubble sort algorithm should not be used to sort large lists.
    The bubble sort algorithm is suitable for applications where performance is not
    important or the length of the given list is short, and moreover, short and simple
    code is preferred. The bubble sort algorithm performs well on relatively small
    lists.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，冒泡排序算法不应该用于排序大型列表。冒泡排序算法适用于性能不重要或给定列表长度较短的应用，而且更倾向于短而简单的代码。冒泡排序算法在相对较小的列表上表现良好。
- en: Now we shall look into the insertion sort algorithm.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨插入排序算法。
- en: Insertion sort algorithm
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序算法
- en: The idea of insertion sort is that we maintain two sublists (a sublist is a
    part of the original larger list), one that is sorted and one that is not sorted,
    in which elements are added one by one from the unsorted sublist to the sorted
    sublist. So, we take elements from the unsorted sublist and insert them in the
    correct position in the sorted sublist, in such a way that this sublist remains
    sorted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序的想法是，我们维护两个子列表（子列表是原始较大列表的一部分），一个是已排序的，另一个是未排序的，元素逐个从未排序的子列表添加到已排序的子列表中。因此，我们从未排序的子列表中取出元素，并将它们插入到已排序子列表的正确位置，这样这个子列表仍然保持排序状态。
- en: In the insertion sort algorithm, we always start with one element, taking it
    to be sorted, and then take elements one by one from the unsorted sublist and
    place them at the correct positions (in relation to the first element) in the
    sorted sublist. So, after taking one element from the unsorted sublist and adding
    it to the sorted sublist, now we have two elements in the sorted sublist. Then,
    we again take another element from the unsorted sublist, and place it in the correct
    position (in relation to the two already sorted elements) in the sorted sublist.
    We repeatedly follow this process to insert all the elements one by one from the
    unsorted sublist into the sorted sublist. The shaded elements denote the ordered
    sublists in *Figure 11.10*, and in each iteration, an element from the unordered
    sublist is inserted at the correct position in the sorted sublist.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入排序算法中，我们始终从一个元素开始，将其视为已排序，然后逐个从未排序的子列表中取出元素，并将它们放置在已排序子列表中的正确位置（相对于第一个元素）。因此，在从未排序的子列表中取出一个元素并将其添加到已排序的子列表后，现在我们已排序的子列表中有两个元素。然后，我们再次从未排序的子列表中取出另一个元素，并将其放置在已排序子列表中的正确位置（相对于已经排序的两个元素）。我们反复执行此过程，将未排序子列表中的所有元素逐个插入到已排序的子列表中。阴影元素表示*图11.10*中的有序子列表，并且在每次迭代中，未排序子列表中的一个元素被插入到已排序子列表的正确位置。
- en: 'Let’s consider an example to understand the working of the insertion sorting
    algorithm. Let’s say; we have to sort a list of six elements: {`45`, `23`, `87`,
    `12`, `32`, `4`}. Firstly, we start with one element, assuming it to be sorted,
    then take the next element, `23`, from the unsorted sublist and insert it at the
    correct position in the sorted sublist. In the next iteration, we take the third
    element, `87`, from the unsorted sublist, and again insert it into the sorted
    sublist at the correct position. We follow the same process until all elements
    are in the sorted sub-list. This whole process is shown in *Figure 11.10*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解插入排序算法的工作原理。假设；我们需要对一个包含六个元素的列表进行排序：`{45, 23, 87, 12, 32, 4}`。首先，我们从一个元素开始，假设它已经排序，然后从未排序的子列表中取出下一个元素`23`，并将其插入到已排序子列表的正确位置。在下一个迭代中，我们从未排序的子列表中取出第三个元素`87`，并将其再次插入到已排序子列表的正确位置。我们继续这个过程，直到所有元素都在已排序的子列表中。整个过程如*图11.10*所示：
- en: '![](img/B17217_11_10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_10.png)'
- en: 'Figure 11.10: Steps to sort example array elements using the insertion sort
    algorithm'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：使用插入排序算法对示例数组元素进行排序的步骤
- en: 'The complete Python code for insertion sort is given below; each statement
    of the algorithm is further explained in detail with an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面给出了插入排序的完整Python代码；算法的每个语句都通过示例进行了详细的解释：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To understand the implementation of the insertion sort algorithm, let’s take
    another example of five elements, `{5, 1, 100, 2, 10}`, and examine the process
    with a detailed explanation. Let’s consider the following array, as shown in *Figure
    11.11*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解插入排序算法的实现，让我们再举一个包含五个元素的示例，`{5, 1, 100, 2, 10}`，并对其进行详细的解释。让我们考虑以下数组，如*图11.11*所示：
- en: '![](img/B17217_11_11.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_11.png)'
- en: 'Figure 11.11: An example array with index positions'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：一个带有索引位置的示例数组
- en: 'The algorithm starts by using a `for` loop to run between the `1` and `4` indices.
    We start from index `1` because we take the element stored at index `0` to be
    in the sorted subarray and elements between index `1` to `4` are of the unsorted
    sublist, as shown in *Figure 11.12*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先使用一个`for`循环在`1`和`4`索引之间运行。我们从索引`1`开始，因为我们把存储在索引`0`的元素视为已排序的子数组，而索引`1`到`4`之间的元素是未排序的子列表，如*图11.12*所示：
- en: '![](img/B17217_11_12.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_12.png)'
- en: 'Figure 11.12: Demonstration of sorted and unsorted sublists in insertion sorting'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：插入排序中排序和未排序子数组的演示
- en: 'At the start of the execution of the loop, we have the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环执行开始时，我们有以下代码片段：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the beginning of the execution of each run of the `for` loop, the element
    at `unsorted_list[index]` is stored in the `insert_value` variable. Later, when
    we find the appropriate position in the sorted portion of the sublist, `insert_value`
    will be stored at that index in the sorted sublist. The next code snippet is shown
    below:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次`for`循环执行的开始，`unsorted_list[index]`位置的元素被存储在`insert_value`变量中。稍后，当我们找到子列表有序部分的适当位置时，`insert_value`将被存储在该索引的有序子列表中。下面的代码片段显示了：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`search_index` is used to provide information to the `while` loop, that is,
    exactly where to find the next element that needs to be inserted into the sorted
    sublist.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_index`用于向`while`循环提供信息，即确切地找到下一个需要插入到有序子列表中的元素的位置。'
- en: 'The `while` loop traverses the list backward, guided by two conditions. First,
    if `search_index > 0`, then it means that there are more elements in the sorted
    portion of the list; second, for the `while` loop to run, `unsorted_list[search_index-1]`
    must be greater than the `insert_value` variable. The `unsorted_list[search_index-1]`
    array will do either of the following things:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在两个条件的引导下遍历列表。首先，如果`search_index > 0`，则意味着列表的有序部分中还有更多元素；其次，为了使`while`循环运行，`unsorted_list[search_index-1]`必须大于`insert_value`变量。`unsorted_list[search_index-1]`数组将执行以下任一操作：'
- en: Point to the element, just before `unsorted_list[search_index]`, before the
    `while` loop is executed the first time
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次执行`while`循环之前，指向`unsorted_list[search_index]`之前的元素
- en: Point to one element before `unsorted_list[search_index-1]`, after the `while`
    loop has been run the first time
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次`while`循环运行后，指向`unsorted_list[search_index-1]`之前的一个元素
- en: In the example list, the `while` loop will be executed because `5 > 1`. In the
    body of the `while` loop, the element at `unsorted_list[search_index-1]` is stored
    at `unsorted_list[search_index]`. And, `search_index -= 1` moves the list traversal
    backward until it holds a value of `0`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例列表中，由于`5 > 1`，`while`循环将被执行。在`while`循环体中，`unsorted_list[search_index-1]`位置的元素被存储到`unsorted_list[search_index]`。然后，`search_index
    -= 1`将列表遍历向后移动，直到它持有值为`0`。
- en: 'After the `while` loop exits, the last known position of `search_index` (which,
    in this case, is `0`) now helps us to know where to insert `insert_value`. *Figure
    11.13* shows the position of elements after the first iteration:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环退出后，最后一个已知的`search_index`位置（在这种情况下为`0`）现在帮助我们了解在哪里插入`insert_value`。*图11.13*显示了第一次迭代后元素的位置：
- en: '![](img/B17217_11_13.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_13.png)'
- en: 'Figure 11.13: Example list position after 1st iteration'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：第一次迭代后的示例列表位置
- en: On the second iteration of the `for` loop, `search_index` will have a value
    of `2`, which is the index of the third element in the array. At this point, we
    start our comparison in the leftward direction (toward index `0`). `100` will
    be compared with `5`, but because `100` is greater than `5`, the `while` loop
    will not be executed. `100` will be replaced by itself, because the `search_index`
    variable never got decremented. As such, `unsorted_list[search_index] = insert_value`
    will have no effect.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的第二次迭代中，`search_index`将具有`2`的值，这是数组中第三个元素的索引。此时，我们开始从左向右（向索引`0`）进行比较。`100`将与`5`进行比较，但由于`100`大于`5`，`while`循环将不会执行。`100`将保持不变，因为`search_index`变量从未递减。因此，`unsorted_list[search_index]
    = insert_value`将不会有任何效果。
- en: When `search_index` is pointing at index `3`, we compare `2` with `100`, and
    move `100` to where `2` is stored. We then compare `2` with `5` and move `5` to
    where `100` was initially stored. At this point, the `while` loop will break and
    `2` will be stored in index `1`. The array will be partially sorted with the values
    `[1, 2, 5, 100, 10]`. The preceding step will occur one last time for the list
    to be sorted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当`search_index`指向索引`3`时，我们比较`2`与`100`，并将`100`移动到`2`存储的位置。然后，我们比较`2`与`5`，并将`5`移动到`100`最初存储的位置。此时，`while`循环将中断，`2`将被存储在索引`1`。数组将部分排序，值为`[1,
    2, 5, 100, 10]`。上述步骤将最后一次发生，以使列表排序。
- en: 'The following code can be used to create a list of elements, which we can sort
    using the defined `insertion_sort()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来创建一个元素列表，我们可以使用定义的`insertion_sort()`方法对其进行排序：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the above code is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The worst-case time complexity of insertion sort is when the given list of
    elements is sorted in reverse order. In that case, each element will have to be
    compared with each of the other elements. So, we will need one comparison in the
    first iteration, two comparisons inthe second iteration, and three comparisons
    in the third iteration, and (n-1) comparisons in the (n-1)^(th) iteration. Thus,
    the total number of comparisons are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序算法的最坏情况时间复杂度发生在给定的元素列表已按逆序排序时。在这种情况下，每个元素都必须与其他每个元素进行比较。因此，在第一次迭代中需要一次比较，在第二次迭代中需要两次比较，在第三次迭代中需要三次比较，在(n-1)次迭代中需要(n-1)次比较。因此，总的比较次数为：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Hence, the insertion sort algorithm gives a worst-case runtime complexity of
    O(n²). Furthermore, the best-case complexity of the insertion sort algorithm is
    O(n), in the situation when the given input list is already sorted in which each
    element from the unsorted sublist is compared to only the right-most element of
    the sorted sublist in each iteration. The insertion sort algorithm is good to
    use when the given list has a small number of elements, and it is best suited
    when the input data arrives one by one, and we need to keep the list sorted. Now
    we are going to take a look at the selection sort algorithm.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，插入排序算法的最坏情况运行时间复杂度为O(n²)。此外，插入排序算法的最佳情况复杂度为O(n)，在这种情况下，给定的输入列表已经排序，并且每次迭代中未排序子列表的每个元素只与已排序子列表的最右侧元素进行比较。当给定的列表元素数量较少时，插入排序算法很好用，当输入数据逐个到达，并且我们需要保持列表排序时，它是最适合的。现在我们将来看看选择排序算法。
- en: Selection sort algorithm
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序算法
- en: Another popular sorting algorithm is selection sort. The selection sort algorithm
    begins by finding the smallest element in the list and interchanges it with the
    data stored at the first position in the list. Thus, it sorts the sublist sorted
    up to the first element. This process is repeated for `(n-1)` times to sort `n`
    items.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的排序算法是选择排序。选择排序算法首先在列表中找到最小元素，并将其与列表中第一个位置的数据交换。因此，它对到第一个元素为止的子列表进行排序。这个过程重复`(n-1)`次以对`n`个元素进行排序。
- en: Next, the second smallest element, which is the smallest element in the remaining
    list, is identified and interchanged with the second position in the list. This
    makes the initial two elements sorted. The process is repeated, and the smallest
    element remaining in the list is swapped with the element in the third index on
    the list. This means that the first three elements are now sorted.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，找到第二个最小的元素，即剩余列表中的最小元素，并将其与列表的第二个位置交换。这使得前两个元素已排序。重复此过程，列表中剩余的最小元素与列表的第三个索引处的元素交换。这意味着现在前三个元素已排序。
- en: 'Let’s look at an example to understand how the algorithm works. We’ll sort
    the following list of four elements {`15, 12, 65, 10, 7`}, as shown in *Figure
    11.14,* along with their index positions using the selection sort algorithm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解算法的工作原理。我们将使用选择排序算法对以下四个元素的列表 `{`15, 12, 65, 10, 7`}` 进行排序，如图*11.14*所示，同时使用选择排序算法显示它们的索引位置：
- en: '![](img/B17217_11_14.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_14.png)'
- en: 'Figure 11.14: Demonstration of the first iteration of the selection sort'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：选择排序第一次迭代的演示
- en: In the first iteration of the selection sort, we start at index `0`, we search
    for the smallest item in the list, and when the smallest element is found, it
    is exchanged with the first data element of the list at index `0`. We simply repeat
    this process until the list is fully sorted. After the first iteration, the smallest
    element will be placed in the first position in the list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序的第一次迭代中，我们从索引`0`开始，在列表中搜索最小项，当找到最小元素时，将其与列表索引`0`处的第一个数据元素交换。我们简单地重复这个过程，直到列表完全排序。第一次迭代后，最小元素将被放置在列表的第一个位置。
- en: 'Next, we start from the second element of the list at index position `1` and
    search the smallest element in the data list from index position `1` to the length
    of the list. Once we find the smallest element from this remaining list of elements,
    we swap this element with the second element of the list. The step-by-step process
    of the second iteration of the selection sort is shown in *Figure 11.15*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从列表的第二个元素开始，索引位置为`1`，并在索引位置`1`到列表长度的范围内搜索数据列表中的最小元素。一旦从这个剩余元素列表中找到最小元素，我们就将其与列表的第二个元素交换。选择排序第二次迭代的逐步过程如图*11.15*所示：
- en: '![](img/B17217_11_15.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_15.png)'
- en: 'Figure 11.15: Demonstration of the second iteration of the selection sort'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：选择排序第二次迭代的演示
- en: In the next iteration, we find out the smallest element in the remaining list
    in index position `2` to `4` and swap the smallest data element with the data
    element at index `2` in the second iteration. We follow the same process until
    we sort the complete list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，我们在索引位置`2`到`4`的剩余列表中找到最小的元素，并将最小的数据元素与第二次迭代中索引`2`处的数据元素交换。我们遵循相同的步骤，直到整个列表被排序。
- en: 'The following is an implementation of the selection sort algorithm. The argument
    to the function is the unsorted list of items we want to put in ascending order
    of their values:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对选择排序算法的实现。函数的参数是我们想要按值升序排列的未排序元素列表：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above code of selection sort, the algorithm begins with the outer `for`
    loop to go through the list, starting from index `0` to `size_of_list`. Because
    we pass `size_of_list` to the `range` method, it’ll produce a sequence from `0`
    through to `size_of_list-1`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述选择排序的代码中，算法从外层`for`循环开始遍历列表，从索引`0`到`size_of_list`。因为我们把`size_of_list`传递给`range`方法，它会生成从`0`到`size_of_list-1`的序列。
- en: Next, we declare a variable `small`, which stores the index of the smallest
    element. Further, the inner loop is responsible for going through the list and
    we keep track of the index of the smallest value of the list. Once the index of
    the smallest element is found, then we swap this element with the correct position
    in the list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个变量`small`，它存储最小元素的索引。进一步，内层循环负责遍历列表，我们跟踪列表中最小值的索引。一旦找到最小元素的索引，我们就将这个元素与列表中的正确位置交换。
- en: 'The following code can be used to create a list of elements and we use the
    selection sort algorithm to sort the list:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来创建一个元素列表，我们使用选择排序算法来排序这个列表：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the above code is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the selection sort, `(n-1)` comparisons are required in the first iteration,
    and `(n-2)` comparisons are required in the second iteration, and `(n-3)` comparisons
    are required in the third iteration, and so on. So, the total number of comparisons
    required is: `(n-1) + (n-2) + (n-3) + ..... + 1 = n(n-1) / 2` , which nearly equals
    to n². Thus, the worst-case time complexity of the selection sort is O(n²). The
    worst-case situation is when the given list of elements is reverse ordered. The
    selection sorting algorithm gives the best-case runtime complexity of O(n²). The
    selection sorting algorithm can be used when we have a small list of elements.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序中，第一次迭代需要`(n-1)`次比较，第二次迭代需要`(n-2)`次比较，第三次迭代需要`(n-3)`次比较，以此类推。因此，所需的总比较次数是：`(n-1)
    + (n-2) + (n-3) + ... + 1 = n(n-1) / 2`，这几乎等于n²。因此，选择排序的最坏情况时间复杂度是O(n²)。最坏的情况是给定的元素列表是逆序的。选择排序算法的最佳情况运行时间复杂度是O(n²)。当元素列表较小的时候，可以使用选择排序算法。
- en: Next, we will discuss the quicksort algorithm.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论快速排序算法。
- en: Quicksort algorithm
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序算法
- en: Quicksort is an efficient sorting algorithm. The quicksort algorithm is based
    on the divide-and-conquer class of algorithms, similar to the merge sort algorithm,
    where we break (divide) a problem into smaller chunks that are much simpler to
    solve, and further, the final results are obtained by combining the outputs of
    smaller problems (conquer).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种高效的排序算法。快速排序算法基于分而治之的算法类别，类似于归并排序算法，其中我们将问题分解（分）成更小的部分，这些部分更容易解决，并且最终通过组合较小问题的输出（征服）来获得最终结果。
- en: The concept behind quicksorting is partitioning a given list or array. To partition
    the list, we first select a data element from the given list, which is called
    a pivot element.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序背后的概念是将给定的列表或数组分区。为了分区列表，我们首先从给定的列表中选择一个数据元素，这个元素被称为基准元素。
- en: We can choose any element as a pivot element in the list. However, for the sake
    of simplicity, we’ll take the first element in the array as the pivot element.
    Next, all the elements in the list are compared with this pivot element. At the
    end of first iteration, all the elements of the list are arranged in such a way
    that the elements which are less than the pivot element are arranged to the left
    of the pivot, that the elements that are greater than the pivot element are arranged
    to the right of the pivot.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在列表中选择任何元素作为枢轴元素。然而，为了简单起见，我们将选择数组中的第一个元素作为枢轴元素。接下来，列表中的所有元素都与这个枢轴元素进行比较。在第一次迭代结束时，列表中的所有元素都按照以下方式排列：小于枢轴元素的元素排列在枢轴的左侧，而大于枢轴元素的元素排列在枢轴的右侧。
- en: Now, let’s understand the working of the quicksort algorithm with an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个例子来理解快速排序算法的工作原理。
- en: In this algorithm, firstly we partition the given list of unsorted data elements
    into two sublists in such a way that all the elements on the left side of that
    partition point (also called a pivot) should be smaller than the pivot, and all
    the elements on the right side of the pivot should be greater. This means that
    elements of the left sublist and the right sublist will be unsorted, but the pivot
    element will be at its correct position in the complete list. This is shown in
    *Figure 11.16*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，首先我们将给定的未排序数据元素列表分成两个子列表，使得该分区点（也称为枢轴）左侧的所有元素都应该小于枢轴，而枢轴右侧的所有元素都应该大于枢轴。这意味着左右子列表的元素将未排序，但枢轴元素将在整个列表中的正确位置。这如图
    *图 11.16* 所示。
- en: 'Therefore, after the first iteration of the quicksort algorithm, the chosen
    pivot point is placed in the list at its correct position, and after the first
    iteration, we obtain two unordered sublists and follow the same process again
    on these two sublists. Thus, the quicksort algorithm partitions the list into
    two parts and recursively applies the quicksort algorithm to these two sublists
    to sort the whole list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在快速排序算法的第一次迭代之后，所选的枢轴点被放置在列表中的正确位置，然后我们在这两个子列表上再次执行相同的操作。因此，快速排序算法将列表分成两部分，并递归地对这两个子列表应用快速排序算法以对整个列表进行排序：
- en: '![](img/B17217_11_16.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_16.png)'
- en: 'Figure 11.16: Illustration of sublists in quicksort'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：快速排序中子列表的示意图
- en: 'The quicksort algorithm works as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法的工作原理如下：
- en: 'We start by choosing a pivot element with which all the data elements are to
    be compared, and at the end of the first iteration, this pivot element will be
    placed in its correct position in the list. In order to place the pivot element
    in its correct position, we use two pointers, a left pointer, and a right pointer.
    This process is as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先选择一个枢轴元素，所有数据元素都要与之比较，在第一次迭代结束时，这个枢轴元素将在列表中放置在其正确的位置。为了将枢轴元素放置在其正确的位置，我们使用两个指针，一个左指针和一个右指针。这个过程如下：
- en: The left pointer initially points to the value at index `1`, and the right pointer
    points to the value at the last index. The main idea here is to move the data
    items that are on the wrong side of the pivot element. So, we start with the left
    pointer, moving in a left-to-right direction until we reach a position where the
    data item in the list has a greater value than the pivot element.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左指针最初指向索引 `1` 的值，右指针指向最后一个索引的值。这里的主要思想是移动位于枢轴元素错误一侧的数据项。因此，我们从左指针开始，向左到右移动，直到我们到达一个位置，此时列表中的数据项的值大于枢轴元素。
- en: Similarly, we move the right pointer toward the left until we find a data item
    less than the pivot element.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将右指针向左移动，直到我们找到一个小于枢轴元素的数据项。
- en: Next, we swap these two values indicated by the left and right pointers.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们交换这两个由左右指针指示的值。
- en: We repeat the same process until both pointers cross each other, in other words,
    until the right pointer index indicates a value less than that of the left pointer
    index.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复相同的步骤，直到两个指针交叉，换句话说，直到右指针的索引指示的值小于左指针的索引。
- en: After each iteration described in *step 1*, the pivot element will be placed
    at its correct position in the list, and the original list will be divided into
    two unordered sublists, left and right. We follow the same process (as described
    in *step 1*) for both these left and right sublists until each of the sublists
    contains a single element.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤1*中描述的每次迭代之后，枢轴元素将放置在列表中的正确位置，原始列表将分为两个无序的子列表，左和右。我们对这两个左和右子列表都遵循同样的过程（如*步骤1*中描述的），直到每个子列表只包含一个元素。
- en: Finally, all the elements will be placed at their correct positions, which will
    give the sorted list as an output.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，所有元素都将被放置在它们正确的位置，这将给出排序后的列表作为输出。
- en: 'Let’s take an example of a list of numbers, `{45`, `23`, `87`, `12`, `72`,
    `4`, `54`, `32`, `52}`, to understand how the quicksort algorithm works. Let’s
    assume that the pivot element (also called the pivot point) in our list is the
    first element, `45`. We move the left pointer from index `1` in a rightward direction,
    and stop when we reach the value `87`, because `(87>45)`. Next, we move the right
    pointer toward the left and stop when we find the value `32`, because `(32<45)`.
    Now, we swap these two values. This process is shown in *Figure 11.17*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个数字列表为例，`{45, 23, 87, 12, 72, 4, 54, 32, 52}`，来了解快速排序算法是如何工作的。假设我们列表中的枢轴元素（也称为枢轴点）是第一个元素，`45`。我们将左指针从索引`1`向右移动，直到我们达到值`87`，因为`(87>45)`。接下来，我们将右指针向左移动，直到我们找到值`32`，因为`(32<45)`。现在，我们交换这两个值。这个过程在*图11.17*中显示：
- en: '![](img/B17217_11_17.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_17.png)'
- en: 'Figure 11.17: An illustrative example of the quicksort algorithm'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：快速排序算法的说明性示例
- en: 'After that, we repeat the same process and move the left pointer toward the
    right, and stop when we find the value `72`, because `(72 > 45)`. Next, we move
    the right pointer toward the left and stop when we reach the value `4`, because
    `(4 < 45)`. Now, we swap these two values, because they are on the wrong sides
    of the pivot value. We repeat the same process and stop once the right pointer
    index value becomes less than the left pointer index. Here, we find `4` as the
    splitting point, and swap it with the pivot value. This is shown in *Figure 11.18*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们重复同样的过程，将左指针向右移动，直到我们找到值`72`，因为`(72 > 45)`。接下来，我们将右指针向左移动，直到我们达到值`4`，因为`(4
    < 45)`。现在，我们交换这两个值，因为它们位于枢轴值的错误一侧。我们重复同样的过程，直到右指针的索引值小于左指针的索引。在这里，我们找到`4`作为分割点，并将其与枢轴值交换。这如图*图11.18*所示：
- en: '![](img/B17217_11_18.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_18.png)'
- en: 'Figure 11.18: An example of the quicksort algorithm (continued)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：快速排序算法的示例（继续）
- en: It can be observed that after the first iteration of the quicksort algorithm,
    the pivot value `45` is placed at its correct position in the list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，在快速排序算法的第一轮迭代之后，枢轴值`45`被放置在列表中的正确位置。
- en: 'Now we have two sublists:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个子列表：
- en: The sublist to the left of the pivot value, `45`, has values less than `45`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枢轴值`45`左侧的子列表包含小于`45`的值。
- en: 'Another sublist to the right of the pivot value contains values greater than
    `45`. We will apply the quicksort algorithm recursively on these two sublists,
    and repeat it until the whole list is sorted, as shown in *Figure 11.19*:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枢轴值右侧的另一个子列表包含大于`45`的值。我们将对这些两个子列表递归地应用快速排序算法，并重复此过程，直到整个列表被排序，如图*图11.19*所示：
- en: '![](img/B17217_11_19.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_19.png)'
- en: 'Figure 11.19: After the first iteration of the quicksort algorithm on an example
    list of elements'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：在示例元素列表上快速排序算法的第一轮迭代之后
- en: We will take a look at the implementation of the quicksort algorithm in the
    next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看快速排序算法的实现。
- en: Implementation of quicksort
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序的实现
- en: The main task of the quicksort algorithm is to first place the pivot element
    in its correct position so that we divide the given unsorted list into two sublists
    (left and right sublists); this process is called the partitioning step. The partitioning
    step is very important in understanding the implementation of the quicksort algorithm,
    so we will understand the implementation of the partitioning step first with an
    example. In this, given a list of elements, all the elements will be arranged
    in such a way that elements smaller than the pivot element will be on the left
    side of it, and elements greater than the pivot will be arranged to the right
    of the pivot element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法的主要任务是首先将基准元素放置在其正确的位置，以便我们将给定的未排序列表分为两个子列表（左子列表和右子列表）；这个过程称为分区步骤。分区步骤在理解快速排序算法的实现中非常重要，因此我们将首先通过一个示例来理解分区步骤。在这个过程中，给定一个元素列表，所有元素都将按照以下方式排列：小于基准元素的元素将位于其左侧，而大于基准元素的元素将排列在基准元素的右侧。
- en: 'Let’s look at an example to understand the implementation. Consider the following
    list of integers. `[43, 3, 20, 89, 4, 77]`. We shall partition this list using
    the partition function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解实现。考虑以下整数列表。`[43, 3, 20, 89, 4, 77]`。我们将使用分区函数来分区这个列表：
- en: '`[43, 3, 20, 89, 4, 77]`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`[43, 3, 20, 89, 4, 77]`'
- en: 'Consider the code of the partition function below; we will discuss each line
    of this in detail:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的分区函数代码；我们将详细讨论代码的每一行：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The partition function receives, as its parameters, the indices of the first
    and last elements of the array that we need to partition.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分区函数接收作为其参数的数组中需要分区的第一个和最后一个元素的索引。
- en: The value of the pivot is stored in the `pivot` variable, while its index is
    stored in `pivot_index`. We are not using `unsorted_array[0]`, because when the
    unsorted array parameter is called with a segment of an array, index `0` will
    not necessarily point to the first element in that array. The index of the element
    next to the pivot, that is, the **left pointer**, `first_index + 1`, marks the
    position where we begin to look for an element in the array. This array is greater
    than the `pivot` as `greater_than_pivot_index = first_index + 1` suggests. The
    **right pointer** `less_than_pivot_index` variable points to the position of the
    last element in the `less_than_pivot_index = index_of_last_element` list, where
    we begin the search for the element that is less than the pivot.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基准元素的值存储在`pivot`变量中，而其索引存储在`pivot_index`中。我们不是使用`unsorted_array[0]`，因为当使用数组的某个段作为未排序数组参数调用时，索引`0`不一定指向该数组中的第一个元素。紧邻基准元素的元素的索引，即**左指针**`first_index
    + 1`，标记了我们开始查找数组中元素的位置。这个数组中的值大于`pivot`，如`greater_than_pivot_index = first_index
    + 1`所示。**右指针**`less_than_pivot_index`变量指向`less_than_pivot_index = index_of_last_element`列表中最后一个元素的位置，我们从这个位置开始查找小于基准元素的元素。
- en: 'Further, at the beginning of the execution of the main `while` loop, the array
    looks as shown in *Figure 11.20*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在主`while`循环执行开始时，数组看起来如图11.20所示：
- en: '![](img/B17217_11_20.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_20.png)'
- en: 'Figure 11.20: Illustration 1 of an example array for the quicksort algorithm'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：快速排序算法示例数组的说明1
- en: The first inner `while` loop moves one index to the right until it lands on
    index `2` because the value at that index is greater than `43`. At this point,
    the first `while` loop breaks and does not continue. At each test of the condition
    in the first `while` loop, `greater_than_pivot_index += 1` is evaluated only if
    the `while` loop’s test condition evaluates to `True`. This makes the search for
    an element, greater than the pivot, progress to the next element on the right.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个内层`while`循环向右移动一个索引，直到它落在索引`2`上，因为该索引处的值大于`43`。在这个点上，第一个`while`循环中断，不再继续。在第一个`while`循环的条件测试中，只有当`while`循环的测试条件评估为`True`时，才会评估`greater_than_pivot_index
    += 1`。这使得寻找大于基准元素的元素的搜索进展到右侧的下一个元素。
- en: 'The second inner `while` loop moves one index at a time to the left, until
    it lands on index `5`, whose value, `20`, is less than `43`, as shown in *Figure
    11.21*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个内层`while`循环逐个索引向左移动，直到它落在索引`5`上，其值`20`小于`43`，如图11.21所示：
- en: '![](img/B17217_11_21.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_21.png)'
- en: Figure 11.21 Illustration 2 of example array for quicksort algorithm
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 快速排序算法示例数组的说明2
- en: 'Next, at this point, neither of the inner `while` loops can be executed any
    further, and the next code snippet is as shown below:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在这个点上，内层的`while`循环都无法再继续执行，下一个代码片段如下所示：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, since `greater_than_pivot_index < less_than_pivot_index`, the body of
    the `if` statement swaps the element at those indexes. The `else` condition breaks
    the infinite loop any time that `greater_than_pivot_index` becomes greater than
    `less_than_pivot_index`. In such a condition, it means that `greater_than_pivot_index`
    and `less_than_pivot_index` have crossed over each other.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于 `greater_than_pivot_index < less_than_pivot_index`，`if` 语句的主体交换了那些索引处的元素。当
    `greater_than_pivot_index` 变得大于 `less_than_pivot_index` 时，`else` 条件会中断无限循环。在这种情况下，这意味着
    `greater_than_pivot_index` 和 `less_than_pivot_index` 已经交叉。
- en: 'The array now looks as shown in *Figure 11.22*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数组现在看起来如 *图11.22* 所示：
- en: '![](img/B17217_11_22.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_22.png)'
- en: 'Figure 11.22: Illustration 3 of an example array for the quicksort algorithm'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：快速排序算法示例数组的第3个示例说明
- en: The `break` statement is executed when `less_than_pivot_index` is equal to `3`
    and `greater_than_pivot_index` is equal to `4`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `less_than_pivot_index` 等于 `3` 且 `greater_than_pivot_index` 等于 `4` 时执行 `break`
    语句。
- en: 'As soon as we exit the `while` loop, we interchange the element at `unsorted_array[less_than_pivot_index]`
    with that of `less_than_pivot_index`, which is returned as the index of the pivot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦退出 `while` 循环，我们就交换 `unsorted_array[less_than_pivot_index]` 处的元素与 `less_than_pivot_index`
    处的元素，这个索引作为枢轴的索引返回：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Figure 11.23* shows how the code interchanges `4` with `43` as the last step
    in the partitioning process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.23* 展示了代码在分区过程的最后一步将 `4` 与 `43` 交换：'
- en: '![](img/B17217_11_23.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_11_23.png)'
- en: 'Figure 11.23: Illustration 4 of an example array for the quicksort algorithm'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：快速排序算法示例数组的第4个示例说明
- en: To recap, the first time the `quick_sort` function was called, it was partitioned
    at the element at index `0`. After the return of the partitioning function, we
    obtain the array in the order of `[4, 3, 20, 43, 89, 77]`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，第一次调用 `quick_sort` 函数时，它在索引 `0` 的元素处进行了分区。在分区函数返回后，我们获得按顺序排列的数组 `[4, 3,
    20, 43, 89, 77]`。
- en: As you can see, all elements to the right of element `43` are greater than `43`,
    while those to the left are smaller. Thus, the partitioning is complete.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，元素 `43` 右侧的所有元素都大于 `43`，而左侧的元素都较小。因此，分区完成。
- en: Using the split point `43` with index `3`, we will recursively sort the two
    subarrays, `[4, 30, 20]` and `[89, 77]`, using the same process we just went through.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引 `3` 的分割点 `43`，我们将递归地对两个子数组 `[4, 30, 20]` 和 `[89, 77]` 进行排序，使用我们刚才使用的过程。
- en: 'The body of the main `quick_sort` function is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 主要 `quick_sort` 函数的主体如下：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `quick_sort` function is quite simple; initially, the `partition` method
    is called, which returns the partition point. This partition point is in the `unsorted_array`
    array where all elements to the left are less than the pivot value, and all elements
    to the right are greater. We print the state of `unsorted_array` immediately after
    the partition progress to see the status of the array after every call.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_sort` 函数相当简单；最初调用的是 `partition` 方法，它返回分区点。这个分区点位于 `unsorted_array` 数组中，其中所有左边的元素都小于枢轴值，而所有右边的元素都大于枢轴值。我们在分区过程之后立即打印
    `unsorted_array` 的状态，以查看每次调用后的数组状态。'
- en: After the first partition, the first subarray`[4, 3, 20]` will be done; the
    partition of this subarray will stop when `greater_than_pivot_index` is at index
    `2` and `less_than_pivot_index` is at index `1`. At that point, the two markers
    are said to have crossed. Because `greater_than_pivot_index` is greater than `less_than_pivot_index`,
    further execution of the `while` loop will cease. Pivot `4` will be exchanged
    with `3`, while index `1` is returned as the partition point.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次分区后，第一个子数组 `[4, 3, 20]` 将完成；当 `greater_than_pivot_index` 在索引 `2` 且 `less_than_pivot_index`
    在索引 `1` 时，这个子数组的分区将停止。此时，两个标记被认为是交叉的。因为 `greater_than_pivot_index` 大于 `less_than_pivot_index`，进一步执行
    `while` 循环将停止。枢轴 `4` 将与 `3` 交换，而索引 `1` 作为分区点返回。
- en: 'We can use the below code snippet to create a list of elements, and use the
    quicksort algorithm to sort it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段创建一个元素列表，并使用快速排序算法对其进行排序：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the above code is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the quicksort algorithm, the partition algorithm takes `O(n)` time. As the
    quicksort algorithm follows the **divide and conquer** paradigm, it takes `O(logn)`
    time; therefore, the overall average-case runtime complexity of the quicksort
    algorithm is `O(n)` `*` `O(logn)` `= O(nlogn)`. The quicksort algorithm gives
    a worst-case runtime complexity of O(n²). The worst-case complexity for the quicksort
    algorithm would be when it selects the worst pivot point every time, and one of
    the partitions always has a single element. For example, if the list is already
    sorted, the worst-case complexity would occur if the partition picks the smallest
    element as a pivot point. When worst-case complexity does occur, the quicksort
    algorithm can be improved by using the randomized quicksort. The quicksort algorithm
    is efficient when the given list of elements is very long; it works better compared
    to the other aforementioned algorithms for sorting in such situations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速排序算法中，分区算法需要`O(n)`的时间。由于快速排序算法遵循**分而治之**的范式，它需要`O(logn)`的时间；因此，快速排序算法的平均情况运行时间复杂度为`O(n)`
    `*` `O(logn)` `= O(nlogn)`。快速排序算法的最坏情况运行时间复杂度为O(n²)。快速排序算法的最坏情况复杂度会在每次都选择最差的基准点时出现，其中一个分区始终只有一个元素。例如，如果列表已经排序，那么如果分区选择了最小的元素作为基准点，最坏情况复杂度就会发生。当最坏情况复杂度发生时，可以通过使用随机快速排序来改进快速排序算法。当给定的元素列表非常长时，快速排序算法是高效的；与其他上述排序算法相比，在这种情况下排序效果更好。
- en: Timsort algorithm
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Timsort算法
- en: Timsort is used as the default standard sorting algorithm in all Python versions
    >=2.3\. The Timsort algorithm is an optimal algorithm for real-world long lists
    that is based on a combination of the merge sort and insertion sort algorithms.
    The Timsort algorithm utilizes the best of both algorithms; insertion sort works
    best when the array is sorted partially and its size is small, and the merge method
    of the merge sort algorithm works fast when we have to combine small, sorted lists.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Timsort算法是所有Python版本>=2.3的默认标准排序算法。Timsort算法是一种基于归并排序和插入排序算法组合的、适用于现实世界长列表的最优算法。Timsort算法利用了两种算法的优点；当数组部分排序且其大小较小时，插入排序表现最佳，而当我们需要合并小的、已排序的列表时，归并排序算法的合并方法运行得很快。
- en: The main concept of the Timsort algorithm is that it uses the insertion sort
    algorithm to sort small blocks (also known as chunks) of data elements, and then
    it uses the merge sort algorithm to merge all the sorted chunks. The main characteristic
    of the Timsort algorithm is that it takes advantage of already-sorted data elements
    known as “natural runs,” which occur very frequently in real-world data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Timsort算法的主要概念是它使用插入排序算法对小块（也称为块）数据元素进行排序，然后使用归并排序算法合并所有已排序的块。Timsort算法的主要特点是它利用了已知为“自然运行”的已排序数据元素，这在现实世界数据中非常常见。
- en: 'The Timsort algorithm works as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Timsort算法的工作方式如下：
- en: Firstly, we divide the given array of data elements into a number of blocks
    which are also known as a run.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将给定的数据元素数组划分为若干个块，这些块也被称为运行。
- en: 'We generally use 32 or 64 as the size of the run as it is suitable for Timsort;
    however, we can use any other size that can be computed from the length of the
    given array (say `N`). The `minrun` is the minimum length of each run. The size
    of the `minrun` can be computed by following the given principles:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通常使用32或64作为运行的大小，因为它适合Timsort；然而，我们可以使用任何其他可以从给定数组长度（比如说`N`）计算出的大小。`minrun`是每个运行的最小长度。`minrun`的大小可以通过遵循以下原则来计算：
- en: The `minrun` size should not be too long as we use the insertion sort algorithm
    to sort these small blocks, which performs well for short lists of elements.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`minrun`的大小不应过长，因为我们使用插入排序算法对这些小块进行排序，这对于短元素列表表现良好。'
- en: The length of the run should not be very short; in that case, it will result
    in a greater number of runs, which will make the merging algorithm slow.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的长度不应过短；在这种情况下，会导致运行次数更多，从而使合并算法变慢。
- en: Since merge sort works best when we have the number of runs as a power of 2,
    it would be good if the number of runs that compute as `N/minrun` are a power
    of 2.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于归并排序在运行次数为2的幂时表现最佳，因此如果计算为`N/minrun`的运行次数是2的幂，那就很好了。
- en: For example, if we take a run size of 32, then the number of runs will be `(size_of_array/32)`;
    if this is a power of 2, then the merge process will be very efficient.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果我们取运行大小为32，那么运行次数将是`(size_of_array/32)`；如果这是一个2的幂，那么合并过程将非常高效。
- en: Sort each of the runs one by one using the insertion sort algorithm.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用插入排序算法逐个对每个运行进行排序。
- en: Merge all the sorted runs one by one using the merge method of the merge sort
    algorithm.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用归并排序算法的归并方法逐个合并所有已排序的运行。
- en: After each iteration, we double the size of the merged subarray.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次迭代后，我们加倍合并子数组的大小。
- en: 'Let’s take an example to understand the working of the Timsort algorithm. Let’s
    say we have the array `[4, 6, 3, 9, 2, 8, 7, 5]`. We sort it using the Timsort
    algorithm; here, for simplicity, we take the size of the run as 4\. So, we divide
    the given array into two runs, run 1 and run 2\. Next, we sort run 1 using the
    insertion sort algorithm, and then we sort run 2 using the insertion sort algorithm.
    Once we have all the runs sorted, we use the merge method of the merge sort algorithm
    to obtain the final complete sorted list. The complete process is shown in *Figure
    11.24*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解Timsort算法的工作原理。假设我们有一个数组 `[4, 6, 3, 9, 2, 8, 7, 5]`。我们使用Timsort算法对其进行排序；为了简单起见，我们取运行大小为4。因此，我们将给定的数组分为两个运行，运行1和运行2。接下来，我们使用插入排序算法对运行1进行排序，然后我们使用插入排序算法对运行2进行排序。一旦我们有了所有已排序的运行，我们使用归并排序算法的归并方法来获得最终的完整排序列表。整个过程如*图11.24*所示：
- en: '![](img/B17217_11_24.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_11_24.png)'
- en: 'Figure 11.24: Illustration of an example array for the Timsort algorithm'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：Timsort算法示例数组的示意图
- en: 'Next, let’s discuss the implementation of the Timsort algorithm. Firstly, we
    implement the insertion sort algorithm and the merge method of the merge sort
    algorithm. The insertion sort algorithm has already been discussed in detail in
    previous sections. For completeness, it is given below again:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论Timsort算法的实现。首先，我们实现插入排序算法和归并排序算法的归并方法。插入排序算法已经在之前的章节中详细讨论过。为了完整性，下面再次给出：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the above, the insertion sort method is responsible in sorting the run.
    Next, we present the merge method of the merge sort algorithm; this has been discussed
    in detail in *Chapter 3*, *Algorithm Design Techniques and Strategies*. This `Merge()`
    function is used to merge the sorted runs, and it is defined as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述内容中，插入排序方法负责对运行进行排序。接下来，我们介绍归并排序算法的归并方法；这在*第3章*，*算法设计技术和策略*中已经详细讨论过。这个`Merge()`函数用于合并排序的运行，其定义如下：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, let’s discuss the Timsort algorithm. Its implementation is given below.
    Let’s understand it bit by bit:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论Timsort算法。其实现如下。让我们一步步理解它：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the above implementation, we firstly pass two parameters, the array that
    is to be sorted and the size of the run. Next, we use insertion sort to sort the
    individual subarrays by run size in the below code snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述实现中，我们首先传递两个参数，要排序的数组和运行的大小。接下来，我们使用插入排序在下面的代码片段中对单个子数组按运行大小进行排序：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the above code for the example list `[4, 6, 3, 9, 2, 8, 7, 5]`, let’s say
    run size is 2, so we will have a total of four blocks/chunks/runs, and after exiting
    this loop, the array will be like this: `[4, 6, 3, 9, 2, 8, 5, 7]`, indicating
    that all runs of size 2 are sorted. After that we initialize `runSize` and we
    iterate until `runSize` becomes equal to the array length. So, we use the merge
    method for combining the sorted small lists:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的示例列表 `[4, 6, 3, 9, 2, 8, 7, 5]` 中，假设运行大小为2，那么我们将有总共四个块/块/运行，在退出这个循环后，数组将如下所示：`[4,
    6, 3, 9, 2, 8, 5, 7]`，表示所有大小为2的运行都已排序。之后我们初始化 `runSize` 并迭代，直到 `runSize` 等于数组长度。因此，我们使用归并方法来合并排序的小列表：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above code, the `for` loop is using the `Merge` function for merging
    the runs of size `runSize`. For the example above, the `runSize` is `2`. In the
    first iteration, it will merge the left run from index `(0` `to` `1)` and right
    run from index `(2 to 3)` to form a sorted array from index `(0 to 3)`, and the
    array will become `[3, 4, 6, 9, 2, 8, 5, 7]`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`for`循环正在使用`Merge`函数来合并大小为`runSize`的运行。在上述例子中，`runSize`是`2`。在第一次迭代中，它将合并从索引`(0`到`1)`的左运行和从索引`(2`到`3)`的右运行，形成一个从索引`(0`到`3`)的排序数组，数组将变为`[3,
    4, 6, 9, 2, 8, 5, 7]`。
- en: Further, in the second iteration, it will merge the left run from index `(4
    to 5)` and the right run from index `(6 to 7)` to form a sorted run from index
    `(4 to 7)`. After the second iteration the `for` loop will terminate and the array
    will become `[3, 4, 6, 9, 2, 5, 7, 8]`, which indicates the array has been sorted
    from index `(0 to 3)` and `(4 to 7)`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第二次迭代中，它将合并从索引`(4 to 5)`的左运行和从索引`(6 to 7)`的右运行，形成一个从索引`(4 to 7)`的已排序运行。在第二次迭代后，`for`循环将终止，数组将变为`[3,
    4, 6, 9, 2, 5, 7, 8]`，这表明数组已经被从索引`(0 to 3)`和`(4 to 7)`排序。
- en: Now we update the size of the run as `2*runSize` and we repeat the same process
    for the updated `runSize`. So now, `runSize` is `4`. Now, in the first iteration,
    it will merge the left run (index `0` to `3`) and right run (index `4` to `7`)
    to form a sorted array from index (`0` to `7`) and after this the `for` loop will
    terminate and the array will become `[2, 3, 4, 5, 6, 7, 8, 9]`, which indicates
    the array has been sorted.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行的大小更新为`2*runSize`，然后对更新的`runSize`重复相同的步骤。因此，现在`runSize`是`4`。现在，在第一次迭代中，它将合并左边的运行（索引`0`到`3`）和右边的运行（索引`4`到`7`），形成一个从索引`0`到`7`的已排序数组，然后在这个之后，`for`循环将终止，数组将变为`[2,
    3, 4, 5, 6, 7, 8, 9]`，这表明数组已经被排序。
- en: Now, `runSize` will become equal to the array length so the `while` loop will
    terminate, and at last, we will be left with the sorted array.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`runSize`将等于数组长度，所以`while`循环将终止，最后我们将得到一个已排序的数组。
- en: 'We can use the below code snippet to create a list, and then sort the list
    using the Timsort algorithm:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用下面的代码片段来创建一个列表，然后使用Timsort算法对这个列表进行排序：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the above code is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Timsort is very efficient for real-world applications since it has a worst-case
    complexity of `O(n logn)`. Timsort is the best choice for sorting, even if the
    length of the given list is short. In that case, it uses the insertion sort algorithm,
    which is very fast for smaller lists, and the Timsort algorithm works fast for
    long lists due to the merge method; hence, the Timsort algorithm is a good choice
    for sorting due to its adaptability for sorting arrays of any length in real-world
    usage.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Timsort对于实际应用非常高效，因为它具有`O(n logn)`的最坏情况复杂度。即使给定的列表长度较短，Timsort也是排序的最佳选择。在这种情况下，它使用插入排序算法，这对于较短的列表来说非常快，而Timsort算法由于合并方法，对于长列表工作得很快；因此，由于其在实际使用中对任何长度的数组排序的适应性，Timsort算法是排序的一个很好的选择。
- en: 'A comparison of the complexities of different sorting algorithms is given in
    the following table:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格给出了不同排序算法复杂度的比较：
- en: '| **Algorithm** | **worst-case** | **average-case** | **best-case** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **最坏情况** | **平均情况** | **最好情况** |'
- en: '| Bubble sort | `O(n2)` | `O(n2)` | `O(n)` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 冒泡排序 | `O(n²)` | `O(n²)` | `O(n)` |'
- en: '| Insertion sort | `O(n2)` | `O(n2)` | `O(n)` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 插入排序 | `O(n²)` | `O(n²)` | `O(n)` |'
- en: '| Selection sort | `O(n2)` | `O(n2)` | `O(n2)` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 选择排序 | `O(n²)` | `O(n²)` | `O(n²)` |'
- en: '| Quicksort | `O(n2)` | `O(n log n)` | `O(n log n)` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 快速排序 | `O(n²)` | `O(n log n)` | `O(n log n)` |'
- en: '| Timsort | `O(n log n)` | `O(n log n)` | `O(n)` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| Timsort | `O(n log n)` | `O(n log n)` | `O(n)` |'
- en: 'Table 11.1: Comparing the complexity of different sorting algorithms'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1：比较不同排序算法的复杂度
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored important and popular sorting algorithms that
    are very useful for many real-world applications. We have discussed the bubble
    sort, insertion sort, selection sort, quicksort, and Timsort algorithms, along
    with explaining their implementation in Python. In general, the quicksort algorithm
    performs better than the other sorting algorithms, and the Timsort algorithm is
    the best choice to use in real-world applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了重要且流行的排序算法，这些算法在许多实际应用中非常有用。我们讨论了冒泡排序、插入排序、选择排序、快速排序和Timsort算法，并解释了它们在Python中的实现。一般来说，快速排序算法的性能优于其他排序算法，而Timsort算法是实际应用中的最佳选择。
- en: In the next chapter, we will discuss selection algorithms.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论选择算法。
- en: Exercise
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If an array `arr = {55, 42, 4, 31}` is given and bubble sort is used to sort
    the array elements, then how many iterations will be required to sort the array?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果给定一个数组`arr = {55, 42, 4, 31}`，并使用冒泡排序对数组元素进行排序，那么需要多少次迭代才能对数组进行排序？
- en: '3'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0'
- en: What is the worst-case complexity of bubble sort?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡排序的最坏情况复杂度是多少？
- en: '`O(n` `log` `n)`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(n log n)`'
- en: '`O(log` `n)`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(log n)`'
- en: '`O(n)`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(n)`'
- en: '`O(n`²`)`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(n²)`'
- en: Apply quicksort to the sequence (`56, 89, 23, 99, 45, 12, 66, 78, 34`). What
    is the sequence after the first phase, and what pivot is the first element?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对序列 (`56, 89, 23, 99, 45, 12, 66, 78, 34`) 应用快速排序。第一阶段后序列将如何排列，第一个元素是什么枢轴？
- en: 45, 23, 12, 34, 56, 99, 66, 78, 89
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 45, 23, 12, 34, 56, 99, 66, 78, 89
- en: 34, 12, 23, 45, 56, 99, 66, 78, 89
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 34, 12, 23, 45, 56, 99, 66, 78, 89
- en: 12, 45, 23, 34, 56, 89, 78, 66, 99
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 12, 45, 23, 34, 56, 89, 78, 66, 99
- en: 34, 12, 23, 45, 99, 66, 89, 78, 56
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 34, 12, 23, 45, 99, 66, 89, 78, 56
- en: Quicksort is a ___________
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序是一种 ___________
- en: Greedy algorithm
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贪心算法
- en: Divide and conquer algorithm
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: Dynamic programming algorithm
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态规划算法
- en: Backtracking algorithm
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回溯算法
- en: Consider a situation where a swap operation is very costly. Which of the following
    sorting algorithms should be used so that the number of swap operations is minimized?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一种情况，交换操作非常昂贵。以下哪种排序算法应该使用，以使交换操作的数量最小化？
- en: Heap sort
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆排序
- en: Selection sort
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Insertion sort
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Merge sort
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'If the input array `A` `=` `{15`, `9`, `33`, `35`, `100`, `95`, `13`, `11`,
    `2`, `13}` is given, using selection sort, what would the order of the array be
    after the fifth swap? (Note: it counts regardless of whether they exchange places
    or remain in the same position.)'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入数组 `A` `=` `{15`, `9`, `33`, `35`, `100`, `95`, `13`, `11`, `2`, `13}`，使用选择排序，第五次交换后数组的顺序将是什么？（注意：无论它们是否交换位置或保持相同位置，都计算在内。）
- en: 2, 9, 11, 13, 13, 95, 35, 33, 15, 100
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2, 9, 11, 13, 13, 95, 35, 33, 15, 100
- en: 2, 9, 11, 13, 13, 15, 35, 33, 95, 100
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2, 9, 11, 13, 13, 15, 35, 33, 95, 100
- en: 35, 100, 95, 2, 9, 11, 13, 33, 15, 13
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 35, 100, 95, 2, 9, 11, 13, 33, 15, 13
- en: 11, 13, 9, 2, 100, 95, 35, 33, 13, 13
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 11, 13, 9, 2, 100, 95, 35, 33, 13, 13
- en: What will be the number of iterations to sort the elements `{44, 21, 61, 6,
    13, 1}` using insertion sort?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用插入排序对元素 `{44, 21, 61, 6, 13, 1}` 进行排序时，需要多少次迭代？
- en: '6'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5'
- en: '7'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7'
- en: '1'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: How will the array elements `A= [35, 7, 64, 52, 32, 22]` look after the second
    iteration, if the elements are sorted using insertion sort?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用插入排序对数组元素 `A= [35, 7, 64, 52, 32, 22]` 进行排序，第二次迭代后数组元素将如何排列？
- en: 7, 22, 32, 35, 52, 64
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 22, 32, 35, 52, 64
- en: 7, 32, 35, 52, 64, 22
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 32, 35, 52, 64, 22
- en: 7, 35, 52, 64, 32, 22
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 35, 52, 64, 32, 22
- en: 7, 35, 64, 52, 32, 22
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 35, 64, 52, 32, 22
- en: Join our community on Discord
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1421249772551223062.png)'
