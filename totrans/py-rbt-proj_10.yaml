- en: Making a Guard Robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个守卫机器人
- en: I am sure you must have seen the movie *I, Robot* or *Chappie*. After watching
    the movie, a lot of people would be intrigued by the idea of making a robot that
    would work to protect and guard you. However, the security systems that are the
    state of the art can hardly be classified as a robot. In this chapter, we will
    take a step ahead in the lane of vision processing and make a guard robot. Its
    purpose would be to guard your gate and if an unknown person comes over to the
    gate it would start to trigger an alarm. However, the interesting thing is that
    the robot would not trigger any alarm if a known person comes home. What's more
    is that it would clear the way and get out of the door area to let you in. Once
    you are inside, it will automatically be back in its position to guard and get
    back to work yet again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定看过电影《我，机器人》或《超能陆战队》。看完电影后，很多人会对制作一个能够保护你的机器人产生兴趣。然而，最先进的安全系统几乎不能被归类为机器人。在本章中，我们将进一步探索视觉处理领域，制作一个守卫机器人。它的目的是守卫你的大门，如果陌生人来到门口，它会开始触发警报。然而，有趣的是，如果熟悉的人回家，机器人不会触发任何警报。更重要的是，它会清除道路，从门口区域退出，让你进入。一旦你进入，它将自动回到其位置，继续守卫并再次开始工作。
- en: How cool would that be? So let's get going and make this robot a reality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那会多么酷啊？所以让我们开始行动，把这个机器人变成现实。
- en: Face detection
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人脸检测
- en: Now, before we go ahead and detect faces, we need to tell the robot what a face
    is and what it looks like. Raspberry Pi does not know how exactly to classify
    a face from a pumpkin. So firstly, we would be using a dataset to tell the robot
    what our face looks like; thereafter, we will start recognizing the faces as we
    go. So let's go ahead and see how to do it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续进行人脸检测之前，我们需要告诉机器人什么是人脸以及它看起来是什么样子。树莓派不知道如何从南瓜中精确地分类人脸。因此，首先，我们将使用一个数据集来告诉机器人我们的脸看起来是什么样子；然后，我们将开始识别人脸。所以，让我们继续看看如何做到这一点。
- en: 'Firstly, you need to install a dependency called Haar-cascade. This is a cascade-dependent algorithm
    that is used to detect objects rapidly. To do this, go ahead and run the following
    syntax on your terminal:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装一个名为Haar-cascade的依赖项。这是一个用于快速检测对象的级联依赖算法。为此，请在你的终端上运行以下语法：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will save the `haarcascades` file onto your Raspberry Pi and you will
    be ready to use it. Once you are done, see the following code but write it over
    your Raspberry only after you have seen the following explanation line by line:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`haarcascades`文件保存到你的树莓派上，你将准备好使用它。完成之后，查看以下代码，但请在逐行查看以下解释之后，只在你的树莓派上写入：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, this might look like something out of our world and pretty much every
    thing is new, so let''s understand what we are doing here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能会看起来像是来自我们世界之外的东西，几乎所有东西都是新的，所以让我们理解我们在这里做了什么：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have installed Haar-cascade, we are basically taking in the data which
    is already trained onto our Raspberry Pi. In this line, we are opening a classifier,
    which is reading the data from a file named `haarcascade_frontalface_default.xml`.
    This is the file that will tell Raspberry Pi whether the image captured is a frontal
    face or not. This file has a trained dataset to enable the Raspberry to do so.
    Now, we are using a function of OpenCV called `CascadeClassifier()`, which uses
    this learned data from the file mentioned and then classifies the images:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Haar-cascade，我们基本上是在将已经训练好的数据输入到我们的树莓派中。在这一行中，我们正在打开一个分类器，它从名为`haarcascade_frontalface_default.xml`的文件中读取数据。这个文件将告诉树莓派捕获到的图像是否是正面人脸。这个文件有一个训练好的数据集，使树莓派能够做到这一点。现在，我们正在使用OpenCV的一个函数`CascadeClassifier()`，它使用文件中提到的学习数据，然后对图像进行分类：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will capture the video from the camera with the port number `0`. So whenever
    the data needs to be captured, the variable `cap` can be used instead of writing
    the whole program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将捕获来自端口号为`0`的摄像头的视频。所以，每当需要捕获数据时，可以使用变量`cap`而不是编写整个程序。
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have understood this line in the previous chapter. It is simply capturing
    the image from the camera and saving it in the variable called `img` and then `ret`
    will return true if the capture is done or false if there is an error.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中理解了这一行。它只是从摄像头捕获图像并将其保存在名为`img`的变量中，然后`ret`将返回true表示捕获成功或返回false表示有错误。
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have used this line previously as well. What it is doing is, it is simply
    converting the captured image using the `cv2.cvtColour()` function. The arguments
    passed in it are the following `img`, which will basically tell which image needs
    to be converted. Thereafter, `cv2.COLOR_BGR2GRAY` will tell from which image type
    it has to be converted into what.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也使用过这一行。它的作用是，简单地使用`cv2.cvtColor()`函数转换捕获的图像。传递给它的参数如下：`img`，它基本上会告诉需要转换哪张图片。然后，`cv2.COLOR_BGR2GRAY`会告诉从哪种图像类型转换成什么类型。
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `face_cascade.detectMultiScale()` function is a function of `face_cascade`.
    It detects the objects of various sizes and creates a rectangle of a similar size
    around it. The values returned to the variable faces would be the `x` and `y`
    coordinates of the object detected along with the width and height of the object
    as well. Hence, we need to define the size and position of the detected object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`face_cascade.detectMultiScale()`函数是`face_cascade`的一个函数。它检测各种大小的物体，并在其周围创建一个相似大小的矩形。返回变量`faces`的值将是检测到的物体的`x`和`y`坐标，以及物体的宽度和高度。因此，我们需要定义检测到的物体的尺寸和位置。'
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous line of code, we have taken the values of the position and the
    height of the rectangle. However, we still haven't drawn one in the actual picture.
    What this `for` loop will do is, it'll add a rectangle to the image using the
    `cv2.rectangle()` function. `img` is telling which image needs to be worked on. `(x,y)`
    is defining the starting coordinates of the position of the object. The value
    `(x+w, y+h)` is defining the end point of the rectangle. The value `(255,0,0)`
    is defining the color and argument `2` is defining the thickness of the line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们已经取出了矩形的坐标值和高度值。然而，我们还没有在真正的图片中绘制一个矩形。这个`for`循环将要执行的操作是，使用`cv2.rectangle()`函数向图片中添加一个矩形。`img`表示需要处理的图片。`(x,y)`定义了物体的起始坐标。值`(x+w,
    y+h)`定义了矩形的终点。值`(255,0,0)`定义了颜色，而参数`2`定义了线的粗细。
- en: '![](img/ec518dd5-ca51-4f9f-8be4-289922921837.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec518dd5-ca51-4f9f-8be4-289922921837.png)'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this line of code, we simply use the `imshow()` function to give the final
    output, which will have the image overlayed by the rectangle we just drew. This
    will indicate that we have successfully identified the image. The `'img'` argument will
    tell the name of the window and the second `img` will tell the function which
    image needs to be shown.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，我们简单地使用`imshow()`函数给出最终输出，这个输出将包含我们刚刚绘制的矩形覆盖的图像。这将表明我们已经成功识别了图像。`'img'`参数将告诉窗口的名称，第二个`img`将告诉函数需要显示哪张图片。
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line is simply waiting to take the key press of `q`. Whenever the user
    presses the `q` key, the `if` statement would become true, which will thereby
    break the infinite loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码只是在等待用户按下`q`键。当用户按下`q`键时，`if`语句就会变为真，从而打破无限循环。
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we are releasing the cameras using `cap.release()` and then closing
    all the windows using `cv2.destoryAllWindows()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`cap.release()`释放摄像头，然后使用`cv2.destroyAllWindows()`关闭所有窗口。
- en: Now, go ahead and run the code and see whether it is able to detect your face
    or not. Good luck!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行代码并查看它是否能够检测到你的脸。祝你好运！
- en: Knowing the face
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解人脸
- en: All right, we have detected the face by using a few lines of code, but I would
    not consider it to be a very big victory as we were fighting using the sword made
    by other developers. The learning set imported was a generic face learned set.
    However, in this chapter, we will go ahead and make our very own learning set
    to recognize a specific human face. This is really a cool thing and I'm sure you
    will love doing it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经通过几行代码检测到了人脸，但我不会认为这是一个很大的胜利，因为我们是在用其他开发者制作的剑在战斗。导入的学习集是一个通用的面部学习集。然而，在本章中，我们将继续创建我们自己的学习集来识别特定的人脸。这真的非常酷，我相信你会喜欢做这件事的。
- en: So, let's get started. As you did earlier, go through the explanation first
    and then write the code so that you understand it very well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。就像你之前做的那样，先通过解释来理解，然后再编写代码，这样你就能很好地理解它。
- en: 'Firstly, we are using the program to capture the images of the object that
    needs to be detected. In our case, this object will be a person and his face.
    So, let''s see what we need to do:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用程序来捕捉需要检测的物体的图像。在我们的案例中，这个物体将是一个人和他的脸。那么，让我们看看我们需要做什么：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the explanation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解释：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you have seen earlier, we are using the preceding two lines of code to import
    the learned dataset and also to start the camera.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，我们使用前面的两行代码来导入学习数据集并启动摄像头。
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we will be training the system to learn a specific face, it is very important
    that the program knows who it is detecting either by name or ID. This will help
    us clarify who we have detected. So, to go ahead and detect a person by face,
    we need to provide his ID, which is being done in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将训练系统学习特定的面孔，程序知道它检测的是谁（无论是通过名字还是ID）非常重要。这将帮助我们明确我们检测到的是谁。因此，为了继续通过人脸检测一个人，我们需要提供他的ID，这在以下代码中完成：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is exactly the same as we did in the previous section of code. Refer to
    it if you need explanation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在代码的上一部分所做的是完全相同的。如果需要解释，请参考它。
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, this line of code might also sound to you like a repetition; however, there
    is an addition to it. In this function, two arguments have been passed instead
    of one. The first is `grey` and the second is the minimum and maximum size of
    the object that can be detected. This is important to make sure that the object
    detected is big enough for the learning process to happen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一行代码可能听起来也像是重复的；然而，它有所增加。在这个函数中，已经传递了两个参数而不是一个。第一个是`grey`，第二个是可以检测到的对象的最低和最高尺寸。这很重要，以确保检测到的对象足够大，以便学习过程发生。
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we are using the same `for` loop to perform the following condition.
    So the loop will only be true when the face is detected. Whenever it is detected,
    the `sampleNum` variable would be incremented by `1` by counting the number of
    faces detected. Further, to capture the images onto our system, we need the following
    line of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用相同的`for`循环来执行以下条件。因此，当检测到人脸时，循环才会为真。每次检测到人脸时，`sampleNum`变量会通过计算检测到的人脸数量增加`1`。此外，为了将图像捕获到我们的系统中，我们需要以下代码行：
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What it does is, it simply saves the image onto a folder by the name `dataSet/User`.
    It is very important to be able to make a folder by this name yourself. If you
    don't do this, then it would go haywire when it does not find the folder where
    it is supposed to save. `+str(id)` will save the name by the ID of the person
    and increment it with the number of samples counted using `+str(sampleNum)`. Furthermore,
    we have mentioned that the image would be saved by the format `.jpg` and finally `gray[y:y+h,
    x:x+w]` is selecting the part of the image that contains the face.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是，简单地将图像保存到名为`dataSet/User`的文件夹中。能够自己创建这样一个文件夹非常重要。如果你不这样做，当它找不到应该保存的文件夹时，就会出问题。"`+str(id)`"将通过人的ID保存名称，并通过使用`+str(sampleNum)`来增加样本计数。此外，我们已经提到图像将以`.jpg`格式保存，最后`gray[y:y+h,
    x:x+w]`是选择包含人脸的图像部分。
- en: The rest of the program beyond this point is self explanatory and I suspect
    you can understand it on your own. In very simple English, this would save the
    images in a folder and will keep doing so, until it reaches 20 images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，程序的其他部分是自我解释的，我怀疑你可以自己理解。用非常简单的英语来说，这将在一个文件夹中保存图像，并且会一直这样做，直到达到20张图像。
- en: 'Now that we have captured the images, it''s time to make the system learn the
    images and understand how to recognize them. To do this, we need to install something
    called the `pillow` library. Installing it is easy. All you need to do is, write
    the following line in the terminal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了图像，是时候让系统学习这些图像并理解如何识别它们了。为此，我们需要安装一个名为`pillow`的库。安装它很容易。你只需要在终端中写下以下行：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This `pillow` library would help us read the dataset. We will understand more
    in a moment. Once this is installed, let''s go ahead and see how we are doing
    the learning part. So go ahead and understand the following code and then let''s
    get going:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pillow`库将帮助我们读取数据集。我们稍后会了解更多。一旦安装了它，让我们继续看看我们是如何进行学习部分的。所以，请继续理解以下代码，然后我们就可以开始了：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alien might be the word which might come in your head after seeing this code,
    but it sure won''t be alien after you have gone through this explanation. So let''s
    see:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这段代码后，你可能会想到“外星人”这个词，但当你看过这个解释后，它肯定不会是外星的了。所以让我们看看：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is creating a recognizer using the `cv2.face.LBPHFaceRecognizer_create()` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`cv2.face.LBPHFaceRecognizer_create()`函数创建一个识别器。
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This line here tells where the captured data is stored in Raspberry Pi. We have
    already made a folder by this name and it contains the images that we have stored
    previously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行说明了捕获的数据在Raspberry Pi中的存储位置。我们已经用这个名字创建了一个文件夹，它包含我们之前存储的图像。
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we are defining the function named `getImageID(path)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义一个名为`getImageID(path)`的函数。
- en: This join function will join the path with `f`. Now, `f` is a variable containing
    the filename as it loops through the list of files inside the folder defined as
    path using `os.listdir(path)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接函数会将路径与`f`连接起来。现在，`f`是一个变量，它包含文件名，当它通过`os.listdir(path)`遍历定义路径内的文件列表时。
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `for` loop in this line will be true for every image that we have and will
    run the code inside of it. What `Image.open(imagePath).convert('L')` does is,
    it simply covers the image in monochrome format. Using this line, every image
    that we are having would be converted into monochrome.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`for`循环将对每个我们拥有的图像都为真，并运行其内的代码。`Image.open(imagePath).convert('L')`所做的是，它只是将图像转换为单色格式。使用这一行，我们将拥有的每个图像都转换为单色。
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: OpenCV works with `numpy` array; hence, we need to convert the images to the
    desired format. To do this, we are using a `faceNp` variable to call the `np.array()`
    function. This function converts the images into `numpy` array of name `faceImg`
    and with 8-bit integer value, as we have passed the argument `unit8`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV与`numpy`数组一起工作；因此，我们需要将图像转换为所需的格式。为此，我们使用一个名为`faceNp`的变量来调用`np.array()`函数。这个函数将图像转换为名为`faceImg`的`numpy`数组，具有8位整数值，因为我们传递了参数`unit8`。
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this line, we are using a variable to call the `int()` function, which will
    split the path name for the images being captured. Why are we doing this? This
    is done to extract the ID number from the actual filename. Hence, we are doing
    this using the following function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们使用一个变量来调用`int()`函数，该函数将分割正在捕获的图像的路径名。我们为什么要这样做？这是为了从实际文件名中提取ID号码。因此，我们使用以下函数来完成这项工作：
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, using `faces.append(faceNp)`, we are adding the data into the array by
    the name of `faces` and the data being added is `faceNp`. Then, we are printing
    the `ID` of that image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`faces.append(faceNp)`，我们将数据添加到名为`faces`的数组中，添加的数据是`faceNp`。然后，我们打印该图像的`ID`。
- en: Once done, `IDs.append(ID)` will add the `ID` to the array `IDs`. This whole
    process is being done as the function that we would be using for training would
    only take in the values in the form of an array. So we have to convert the entire
    data in the form of an array and fetch it to the trainer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`IDs.append(ID)`将`ID`添加到数组`IDs`中。整个过程是作为我们将要使用的训练函数，它只接受数组形式的值。因此，我们必须将整个数据转换为数组形式并传递给训练器。
- en: So the entire explanation so far was defining the function named `getImageId(Path)`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以到目前为止的整个解释都是定义一个名为`getImageId(Path)`的函数。
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now this line would return the values of `IDs` of the faces which will be further
    used to train the dataset.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这行将返回面部的`IDs`值，这些值将被进一步用于训练数据集。
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first line here, the `getImageID(path)` function would take in the path
    of the any image and return the `Ids` of the images. Then, `faces` would have
    the array data of the images.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的第一行，`getImageID(path)`函数将接受任何图像的路径并返回图像的`Ids`。然后，`faces`将包含图像的数组数据。
- en: Finally, in `recognizer.train(faces, np.array(Ids))`, we are using a function
    of `recognizer` called `train` to train the system based on their images. The
    arguments passed here are that `faces` has the array of the images. Furthermore, `np.array(Ids)`
    is the array, which is returned by the function defined by the name `getImageID()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`recognizer.train(faces, np.array(Ids))`中，我们使用`recognizer`的一个名为`train`的函数来根据它们的图像训练系统。传递给这里的参数是`faces`包含图像数组。此外，`np.array(Ids)`是一个数组，它是通过名为`getImageID()`的函数返回的。
- en: Once the system is trained using the following program, we would save the trained
    data to a file. This is done using the `recognizer.save()` function. The argument
    passed in it is the name and the extension of the file saved.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用以下程序训练了系统，我们将训练数据保存到文件中。这是通过`recognizer.save()`函数完成的。传递给它的参数是保存文件的名称和扩展名。
- en: It can be a little intense and sometimes confusing as well. However, it will
    seem easy once you do it. Now, it's time that you go ahead and make the system
    learn about your face and its data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点复杂，有时也可能令人困惑。然而，一旦你做了，它就会变得简单。现在，是你继续前进并让系统学习你的面部及其数据的时候了。
- en: Recognizing the face
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别面部
- en: 'Now that we have learned how to make our system learn, it''s time to use that
    learned data and recognize the face. So without much talking, let''s go ahead
    and understand how this would be done:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何让我们的系统学习，现在是时候使用这些学习数据来识别面部了。所以，不多说，让我们了解这将如何完成：
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, there are not a lot of new things that you might encounter. It
    is very similar to the first code that we started with in this chapter. Essentially,
    it is also doing the same work. The only difference is that it recognizes the
    person by his ID. So, let's see what is different and how well it performs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，没有太多你可能遇到的新东西。它与我们在本章开始时使用的第一个代码非常相似。本质上，它也在做相同的工作。唯一的区别是它通过ID识别人。所以，让我们看看有什么不同，以及它的表现如何。
- en: 'Now, most of the code is repetitive. So instead of going through all of it,
    I will only touch on the ones which are new. Here we go:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大部分代码都是重复的。所以，我只会涉及到新的部分。下面是：
- en: '[PRE30]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Like last time, we were drawing a rectangle over an identified image. However,
    this time there are places where overlay has to be done with some text as well.
    So here we are choosing the font that we need to use in this program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次一样，我们在一个已识别的图像上画了一个矩形。然而，这次还需要在某个地方用文本进行叠加。所以，我们在这里选择这个程序中需要使用的字体：
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this line, the prediction is taking place using the function of the recognizer
    called `predict()`. This predicts the images and returns the `id` of the detected
    image.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行，预测是通过识别器的`predict()`函数进行的。它预测图像并返回检测到的图像的`id`。
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, finally, if the `id` is equal to `1`, then the value of `id` would be changed
    to `BEN`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，如果`id`等于`1`，那么`id`的值将更改为`BEN`。
- en: '[PRE33]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `putText()` function will put a text on the detected object. The definition
    of each of the arguments is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`putText()` 函数将在检测到的物体上放置文本。每个参数的定义如下：'
- en: '`img`: This is the image on which the text has to be put.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img`: 这是需要放置文本的图像。'
- en: '`str(id)`: This is the string that needs to be printed, in our case it would
    print the ID of the person.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str(id)`: 这是需要打印的字符串，在我们的例子中，它将打印人的ID。'
- en: '`(x, y+h)`: This is the position where the text would be printed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(x, y+h)`: 这是文本将被打印的位置。'
- en: '`font`: This is the font of the printed text. In our case, it would be the
    value of the font defined earlier.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font`: 这是打印文本的字体。在我们的例子中，它将是之前定义的字体值。'
- en: '`2`: This is the font scale, that is, how big the font would be. This can be
    similar to magnification.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`: 这是字体大小，也就是说字体的大小。这可以类似于放大。'
- en: '`(255,0,0)`: This is the color of the font.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(255,0,0)`: 这是字体的颜色。'
- en: '`1`: This is the thickness of the font.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`: 这是字体厚度。'
- en: With this program, we would be able to find out if the learning set is working
    as per our requirement. Once you have written the code, try identifying the people
    with it and see whether it works accurately. If the accuracy is not satisfactory,
    then you may want to take more than 20 samples for learning. Conduct a few trials
    and I am sure you would reach perfection very soon.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个程序，我们可以找出学习集是否按照我们的要求工作。一旦你写好了代码，试着用它来识别人，看看它是否准确。如果准确性不满意，那么你可能需要为学习选择超过20个样本。进行几次试验，我确信你很快就能达到完美。
- en: Making the guard robot
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作守卫机器人
- en: 'Now that we have understood how the learning works and how the learned data
    can be used to identify people, it''s time to put it to use. As the name of the
    chapter suggests, we will be making a guard robot using this technology. Now,
    let''s have a look at the following program. Before you start programming, take
    out the robotic vehicle you had and make the connection like we did before in
    [Chapter 6](17f222ca-2716-430f-a87b-0b37352f5ae0.xhtml), *Bluetooth-Controlled
    Robotic Car*. Attach the motor, motor driver, and Raspberry Pi. Once you have
    done that, then write the following code. This code is utilizing all the learning
    of the previous programs in the chapter and we would be able to distinguish between
    an intruder and a resident of the house based on vision processing. So let''s
    get going:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了学习是如何工作的，以及如何使用学习数据来识别人，现在是时候将其付诸实践了。正如章节的名称所暗示的，我们将使用这项技术制作一个守卫机器人。现在，让我们看看下面的程序。在你开始编程之前，拿出你之前有的机器人车辆，并像我们在[第6章](17f222ca-2716-430f-a87b-0b37352f5ae0.xhtml)中做的那样建立连接，*蓝牙控制机器人车*。连接电机、电机驱动器和树莓派。一旦你完成了这些，然后编写以下代码。这段代码利用了本章前面程序的所有学习内容，我们能够根据视觉处理区分入侵者和房屋居民。所以，让我们开始吧：
- en: '![](img/a9a88f57-272e-415d-a2b4-222f672bcaf4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9a88f57-272e-415d-a2b4-222f672bcaf4.png)'
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As always, we will only be looking at the peculiar changes in the program, a
    lot of it will be carried over from the previous chapter. So we will try not to
    repeat the explanation unless necessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们只会关注程序中的特殊变化，大部分内容将来自上一章。因此，除非必要，我们不会重复解释。
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just as a recap, we are defining two functions, namely, `backwards`, `reverse`,
    and `stop`. These functions will help us move the vehicle in the direction in
    which we want.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像回顾一样，我们定义了两个函数，分别是`backwards`、`reverse`和`stop`。这些函数将帮助我们将车辆移动到我们想要的方向。
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This line is importing the previously learned dataset by the name of `harrcascade_frontalface_default.xml`.
    This will help us recognize any face that comes in front of the camera.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码正在导入名为`harrcascade_frontalface_default.xml`的先前学习的数据集。这将帮助我们识别出现在摄像头前的任何面部。
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this piece of the code, we are identifying the face and taking decisions
    based on it. As we have done earlier, if the face is detected, then its corresponding
    ID would be given by the program. However, no ID would be given if the face is
    not detected by the previously learned dataset in which any face could be detected.
    Hence, according to the program, if the `id == 1`, then the robotic vehicle would
    move forward moving away from the path, thereafter it would stop for `5` seconds
    and get back to where it was earlier. In case the ID generated is anything except
    `1`, then the Buzzer would be turned on for `5` seconds alerting the user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们正在识别面部并根据它做出决策。正如我们之前所做的那样，如果检测到面部，程序会给出相应的ID。然而，如果面部没有被先前学习的数据集检测到，那么就不会给出任何ID，因为这个数据集可以检测到任何面部。因此，根据程序，如果`id
    == 1`，那么机器人车辆会向前移动，偏离路径，然后它会停止`5`秒并回到原来的位置。如果生成的ID不是`1`，那么蜂鸣器会开启`5`秒，提醒用户。
- en: By using this system, anyone who is identified can be let inside the premises;
    however, if the person is not identified, then the alarm would be triggered.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个系统，任何被识别的人都可以被允许进入 premises；然而，如果人员没有被识别，那么就会触发警报。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to detect objects using a prelearned dataset.
    We also learned how to make our very own learned dataset for a specific object.
    Finally, we have used all of that learning to make a guard robot, who will guard
    our home using the power of vision processing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用预学习的数据集检测对象。我们还学习了如何为特定对象创建我们自己的学习数据集。最后，我们利用所有这些学习来制作一个守卫机器人，它将利用视觉处理的力量来守护我们的家园。
