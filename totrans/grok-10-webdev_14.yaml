- en: Chapter 13. Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we have been discussing how Grok offers an agile way
    of working with Zope. However, up to this point, we have neglected to perform
    one activity that is considered most important in agile projects: *testing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Grok offers some tools for testing, and in fact, a project created by `grokproject`
    (as the one that we have been extending) includes a functional test suite. In
    this chapter, we are going to discuss testing, and will then write some tests
    for the functionality that our application has so far.
  prefs: []
  type: TYPE_NORMAL
- en: Testing helps us to avoid bugs, but it does not eliminate them completely, of
    course. There will be times when we will have to dive into the code to find out
    what's going wrong in it. A good set of debugging aids becomes very valuable in
    this situation. We'll see that there are several ways of debugging a Grok application,
    and will try out a couple of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the things that we will cover includes:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in Grok
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the functional test suite provided by `grokproject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other kinds of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to understand that testing should not be treated as an afterthought.
    It's just that in a book like this one, which focuses a lot on testing, it can
    be harder to follow explanations and code in the initial stages of your reading.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, agile methodologies place a lot of emphasis on testing.
    In fact, there's even a methodology called **Test Driven Development** (**TDD**),
    which not only encourages writing tests for our code, but also encourages writing
    tests before writing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various kinds of testing, but here we''ll briefly describe only two:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration or functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of unit testing is to break a program into its constituent parts and
    test each one of them in isolation. Every method or function call is tested separately
    to make sure that it returns the expected results and handles all of the possible
    inputs correctly.
  prefs: []
  type: TYPE_NORMAL
- en: An application that has unit tests that cover a majority of its lines of code
    allows its developers to constantly run the tests after a change, and makes sure
    that modifications to the code do not break the existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional tests are concerned with how the application behaves as a whole.
    In a web application, this means, how it responds to a browser request and whether
    it returns the expected HTML for a given call.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the customer himself has a hand in defining these tests, usually through
    explicit functionality requirements or acceptance criteria. The more formal that
    the requirements from the customer are, the easier it is to define appropriate
    functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Grok
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grok highly encourages the use of both kinds of tests, and in fact includes
    a powerful testing tool that is automatically configured with every project. In
    the Zope world — from where Grok originated — a lot of value is placed in a kind
    of test known as a "doctest", so Grok comes with a sample test suite of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: Doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **doctest** is a test that's written as a text file, with lines of code mixed
    with explanations of what the code is doing. The code is written in a way that
    simulates a Python interpreter session. As tests exercise large portions of the
    code (ideally 100%), they usually offer a good way of finding out of what an application
    does and how. So if an application has no written documentation, its tests would
    be the next obvious way of finding out what it does. Doctests take this idea further,
    by allowing the developer to explain in the text file exactly what each test is
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: Doctests are especially useful for functional testing, because it makes more
    sense to document the high-level operations of a program. Unit tests, on the other
    hand, are expected to evaluate the program bit by bit, and it can be cumbersome
    to write a text explanation for every little piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: A possible drawback of doctests is that they can make the developer think that
    he needs no other documentation for his project. In almost all cases, this is
    not true. Documenting an application or package makes it immediately more accessible
    and useful, so it is strongly recommended that doctests should not be used as
    a replacement for good documentation. We'll show an example of using doctests
    in the *Looking at the test code* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Default test setup for Grok projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Grok projects that are started with the `grokproject`
    tool already include a simple functional test suite, by default. Let's examine
    this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Test configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default test configuration looks for packages or modules that have the word
    'tests' in their name and tries to run the tests inside. For functional tests,
    any files ending with `.txt` or `.rst` are considered.
  prefs: []
  type: TYPE_NORMAL
- en: For functional tests that need to simulate a browser, a special configuration
    is needed to tell Grok which packages to initialize in addition to the Grok infrastructure
    (these are usually the ones that are being worked on). The `ftesting.zcml` file
    in the `package` directory holds this configuration. This file also includes a
    couple of user definitions that are used by certain tests to examine functionality
    that is specific to a certain role, such as manager.
  prefs: []
  type: TYPE_NORMAL
- en: Test files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the already mentioned `ftesting.zcml` file, in the same directory
    there is a `tests.py` file added by `grokproject`, which basically loads the ZCML
    declarations and registers all of the tests in the package.
  prefs: []
  type: TYPE_NORMAL
- en: The actual tests that are included with the default project files are contained
    in the `app.txt` file. These are doctests that perform a functional test run by
    loading the entire Grok environment and imitating a browser. We'll take a look
    at the contents of the file soon, but first let's run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a part of the project's build process, a script named `test` is included
    in the `bin` directory when you create a new project. This is the **test runner**,
    and calling it without arguments finds and executes all of the tests in the packages
    that are included in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t added a single test so far, so if we type `bin/test` in our project
    directory, we''ll see more or less the same thing that doing this on a new project
    would show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between our output and that of a newly created Grok package
    is in the `sqlalchemy` lines. Of course, the most important part of the output
    is the penultimate line, which shows the number of tests that were run and whether
    there were any failures or errors. A *failure* means that a test didn't pass,
    which means that the code is not doing what it's supposed to do and needs to be
    checked. An *error* signifies that the code crashed unexpectedly at some point,
    and the test couldn't even be executed, so it's necessary to find the error and
    correct it before worrying about the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The test runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test runner program looks for modules that contain tests. The test can
    be of three different types: Python tests, simple doctests, and full-functionality
    doctests. To let the test runner know which test file includes which kind of tests,
    a comment similar to the following is placed at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the Python unit test layer will be used to run the tests. The
    other value that we are going to use is doctest, when we learn how to write doctests.
  prefs: []
  type: TYPE_NORMAL
- en: The test runner then finds all of the test modules and runs them in the corresponding
    layer. Although unit tests are considered very important in regular development,
    we may find functional tests more necessary for a Grok web application, as we
    will usually be testing views and forms, which require the full Zope/Grok stack
    to be loaded, in order to work. That's the reason why we find only functional
    doctests in the default setup.
  prefs: []
  type: TYPE_NORMAL
- en: Test layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **test layer** is a specific test setup that is used to differentiate the
    tests that are executed. By default, there is a test layer for each of the three
    types of tests handled by the test runner. It's possible to run a test layer without
    running the others. It is also possible to create new test layers in order to
    cluster together tests that require a specific setup.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the test runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As shown above, running `bin/test` will start the test runner with the default
    options. It's also possible to specify a number of options, and the most important
    ones of these are summarized below. In the following table, command-line options
    are shown to the left. Most options can be expressed using a short form (one dash)
    or a long form (two dashes). Arguments for each option are shown in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-s PACKAGE, --package=PACKAGE, --dir=PACKAGE` | Search the given package''s
    directories for tests. This can be specified more than once, to run tests in multiple
    parts of the source tree. For example, when refactoring interfaces, you don''t
    want to see the way you have broken setups for tests in other packages. You just
    want to run the interface tests. Packages are supplied as dotted names. For compatibility
    with the old test runner, forward and backward slashes in package names are converted
    to dots. (In the special case of packages, which are spread over multiple directories,
    only directories within the test search path are searched.) |'
  prefs: []
  type: TYPE_TB
- en: '| `-m MODULE, --module=MODULE` | Specify a test-module filter as a regular
    expression. This is a case-sensitive regular expression that is used in *search*
    (not match) mode to limit which test modules are searched for tests. The regular
    expressions are checked against dotted module names. In an extension of Python
    regexp notation, a leading "!" is stripped and causes the sense of the remaining
    regexp to be negated (so "!bc" matches any string that does not match "bc", and
    vice versa). This option can specify multiple test-module filters. Test modules
    matching any of the test filters are searched. If no test-module filter is specified,
    then all of the test modules are used. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t TEST, --test=TEST` | Specify a test filter as a regular expression. This
    is a case-sensitive regular expression that is used in *search* (not match) mode
    to limit which tests are run. In an extension of Python regexp notation, a leading
    "!" is stripped and causes the sense of the remaining regexp to be negated (so
    "!bc" matches any string that does not match "bc", and vice versa). This option
    can specify multiple test filters. Tests matching any of the test filters are
    included. If no test filter is specified, then all of the tests are executed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--layer=LAYER` | Specify a test layer to run. This option can be provided
    multiple times in order to specify more than one layer. If not specified, all
    of the layers are executed. It is common for the running script to provide default
    values for this option. Layers are specified regular expressions that are used
    in search mode, for dotted names of objects that define a layer. In an extension
    of Python regexp notation, a leading "!" is stripped and causes the sense of the
    remaining regexp to be negated (so "!bc" matches any string that does not match
    "bc", and vice versa). The layer named ''unit'' is reserved for unit tests; however,
    take note of the *unit* and *non-unit* options. |'
  prefs: []
  type: TYPE_TB
- en: '| `-u, --unit` | Executes only unit tests, ignoring any layer options. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f, --non-unit` | Executes tests other than unit tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v, --verbose` | Makes the output more verbose. |'
  prefs: []
  type: TYPE_TB
- en: '| `-q, --quiet` | Provides minimal output, by overriding any verbosity options.
    |'
  prefs: []
  type: TYPE_TB
- en: Looking at the test code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the three default test files of a Grok project, to see
    what each one does.
  prefs: []
  type: TYPE_NORMAL
- en: ftesting.zcml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we explained earlier, `ftesting.zcml` is a configuration file for the test
    runner. Its main objective is to help us set up the test instance with users,
    so that we can test different roles according to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the configuration simply includes a security
    policy, complete with users and roles, and the packages that should be loaded
    by the instance, in addition to the regular Grok infrastructure. If we run any
    tests that require an authenticated user to work, we'll use these special users.
  prefs: []
  type: TYPE_NORMAL
- en: The includes at the top of the file make sure that the entire Zope Component
    Architecture setup needed by our application is performed prior to running the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: tests.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default test module is very simple. It defines the functional layer and
    registers the tests for our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the imports, the first line gets the path for the `ftesting.zcml` file,
    which is then passed to the layer definition method `ZCMLLayer`. The final line
    in the module tells the test runner to find and register all of the tests in the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: This will be enough for our testing needs in this chapter, but if we needed
    to create another non-Grok package for our application, we would need to add a
    line like the last one to it, so that all of its tests are found by the test runner.
    This is pretty much boilerplate code, as only the package name has to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: app.txt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We finally come to the reason for this entire configuration the actual tests
    that will be executed by the test runner. By default, the tests are included inside
    the `app.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The text file has a title, and immediately after that a `:doctest:` declaration
    a declaration that tells the test runner that these tests need a functional layer
    to be loaded for their execution. Then comes a `:layer:` declaration, which is
    a path that points to the layer that we defined earlier in `tests.py`. After that
    comes the test code. Lines starting with three brackets represent the Python code
    that is tested. Anything else is commentary.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Python interpreter, a line of code may return a value, in which
    case the expected return value must be written immediately below that line. This
    expected value will be compared with the real return value of the tested code,
    and a failure will be reported if the values don't match. Similarly, a line that
    is followed by an empty line will produce a failure when the code is executed
    and a result is returned, because it is assumed that the expected return value
    in that case is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the last line of the Python doctest below the expression `browser.headers.get('Status').upper()`
    is expected to return the value `200 OK`. If anything else at all is returned,
    the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our own tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's add a few functional tests that are specific to our application.
    We will need to emulate a browser for that. The `zope.testbrowser` package includes
    a browser emulator. We can pass any valid URL to this browser by using `browser.open`,
    and it will send a request to our application exactly like a browser would. The
    response from our application will be then available as `browser.contents`, so
    that we can perform our testing comparisons on it.
  prefs: []
  type: TYPE_NORMAL
- en: The Browser class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before writing our tests, it will be useful to see what exactly our `testbrowser`
    can do. Of course, anything that depends on JavaScript will not work here, but
    other than that, we can interact with links and even forms in a very straightforward
    manner. Here''s a look at the main functionality offered by the `Browser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Initialization | >>> from zope.testbrowser.testing import Browser>>> browser
    = Browser() |'
  prefs: []
  type: TYPE_TB
- en: '| Page contents | >>> print browser.contents<html><head><title>Simple Page</title></head><body><h1>Simple
    Page</h1></body></html>>>> ''<h1>Simple Page</h1>'' in browser.contentsTrue |'
  prefs: []
  type: TYPE_TB
- en: '| Headers | >>> print browser.headersStatus: 200 OKContent-Length: 123Content-Type:
    text/html;charset=utf-8X-Powered-By: Zope (www.zope.org), Python (www.python.org)>>>
    browser.headers[''content-type'']''text/html;charset=utf-8'' |'
  prefs: []
  type: TYPE_TB
- en: '| Cookies | >>> browser.cookies[''foo'']''bar''>>> browser.cookies.keys()[''foo'']>>>
    browser.cookies.values()[''bar'']>>> browser.cookies.items()[(''foo'', ''bar'')]>>>
    ''foo'' in browser.cookiesTrue>>> browser.cookies[''sha''] = ''zam'' |'
  prefs: []
  type: TYPE_TB
- en: '| Links | >>> link = browser.getLink(''Link Text'')>>> link<Link text=''Link
    Text''url=''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>>
    link.text''Link Text''>>> link.tag # links can also be image maps.''a''>>> link.url
    # it''s normalized''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>
    link.attrs{''href'': ''navigate.html?message=By+Link+Text''}>>> link.click()>>>
    browser.url''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''
    |'
  prefs: []
  type: TYPE_TB
- en: '| Form controls | >>> control = browser.getControl(''Text Control'')>>> control<Control
    name=''text-value'' type=''text''>>>> browser.getControl(label=''Text Control'')
    # equivalent<Control name=''text-value'' type=''text''>>>> browser.getControl(''Text
    Control'').value = ''Other Text''>>> browser.getControl(''Submit'').click() |'
  prefs: []
  type: TYPE_TB
- en: Now that we know what we can do, let's try our hand at writing some tests.
  prefs: []
  type: TYPE_NORMAL
- en: Our first to-do application tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, we should have been adding a couple of doctests to the `app.txt` file
    every time we added a new functionality to our application. We have gone through
    the reasons why we didn't do so, but let's recover some lost ground. At the very
    least, we'll get a feeling of how doctests work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add our new tests to the existing `app.txt` file. The last test that
    we saw left us at the to-do instance URL. We are not logged in, so if we print
    the browser contents, we will get the login page. Let''s add a test for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, when visiting a URL with the `testbrowser`, the entire
    HTML content of the page is stored in `browser.contents`. Now we know that our
    login page has a username field and a password field, so we simply use a couple
    of `in` expressions and check if these fields evaluate to `True`. If they do,
    it would mean that the browser is effectively looking at the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test for logging in. When we start the application in the tests,
    the user database is empty, therefore, the most economical way of logging in is
    to use basic authentication. This can be easily done by changing the request headers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s log in with the manager user defined in `ftesting.zcml`. To keep things
    simple, let''s use the basic authentication headers to get in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We just add the header, "reload" the home page, and we should be
    logged in. We verify it by looking for the **Logged in as** message, which we
    know has to be there after a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are logged in, we can finally test our application properly. Let''s
    begin by adding a project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in. Let''s create a project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we find the link on the home page that will take us to the 'add form'
    project. This is done easily with the help of the `getLink` method and the text
    of the link. We click on the link and then should have the form ready to fill
    in. We then use `getControl` to find each field by its name, and change its value.
    Finally, we submit the form by getting the submit button control and clicking
    on it. The result is that the project is created and we are redirected to its
    main view. We can confirm this by comparing the `browser url` with the URL that
    we would expect in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a list to the project is just as easy. We get the form controls, assign
    them some values, and click on the submit button. The list and the link for adding
    new items to it should appear in the browser contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a project. Now, we''ll add a list to it. If we are successful,
    we will see a link for adding a new item for the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Good. Let''s see how we are doing so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Not bad. We now have four more working tests than when we started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the test browser handles `HTTP` errors gracefully, returning a string
    similar to what a real browser would return when running into an error. For example,
    take a look at the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's the default behavior because this is how real browsers work, but sometimes,
    when we are debugging, it's better to take a look at the original exception caused
    by our application. In such a case, we can make the browser stop handling errors
    automatically and throw the original exceptions, so that we can handle them. This
    is done by setting the `browser.handleErrors` property to `False:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from functional tests, we can also create pure Python test cases that
    the test runner can find. Whereas functional tests cover application behavior,
    unit tests focus on program correctness. Ideally, every single Python method in
    the application should be tested.
  prefs: []
  type: TYPE_NORMAL
- en: The unit test layer does not load the Grok infrastructure, so tests should not
    take anything that comes with it for granted just the basic Python behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our unit tests, we''ll create a module named `unit_tests.py`. Remember,
    in order for the test runner to find our test modules, their names have to end
    with ''tests''. Here''s what we will put in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `:unittest:` comment at the top, is very important. Without it, the test
    runner will not know in which layer your tests should be executed, and will simply
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are composed of test cases, and, in theory, each should contain several
    tests related to a specific area of the application's functionality. The test
    cases use the `TestCase` class from the Python `unittest` module. In these tests,
    we define a single test case that contains two very simple tests.
  prefs: []
  type: TYPE_NORMAL
- en: We are not getting into the details here. Just notice that the test case can
    include a `setUp` method and a `tearDown` method that can be used to perform any
    common initialization and destruction tasks that are required in order to get
    the tests working and finishing cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Every test inside a test case needs to have the prefix 'test' in its name, so
    we have exactly two tests that fulfill this condition. Both of the tests need
    an instance of the `Todo` class to be executed, so we assign it to the test case
    as a class variable, and create it inside the `setUp` method. The tests are very
    simple and they just verify that the default property values are set upon instance
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the tests use the `assertEqual` method to tell the test runner that
    if the two values passed are different, the test should fail. To see them in action,
    we just run the `bin/test` command once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, both the functional and unit test layers contain some tests, and they are
    both run, one after the other. We can see the subtotal for each layer at the end
    of these tests for that layer, as well as the grand total of the nine passed tests,
    when the test runner finishes its work.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the test suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we have only scratched the surface of which tests should be added
    to our application. If we continue to add tests, we may have hundreds of tests,
    by the time we finish. However, this chapter is not the place to do this.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, it is much easier to have tests for each part of our application,
    if we add them as we code. There's no hiding from the fact that testing is a lot
    of work, but there is great value in having a complete test suite for our applications.
    This is even more so when third parties might use our product independently.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now take a quick look at the debugging facilities offered by Grok. Even
    if we have a very thorough test suite, the chances are there that we will find
    a fair number of bugs in our application. When that happens, we need a quick and
    effective way to inspect the code as it runs and easily find the problem spots.
  prefs: []
  type: TYPE_NORMAL
- en: Often, developers will use `print` statements (placed at key lines) throughout
    the code, in the hopes of finding the problem spot. Although this is usually a
    good way to begin locating sore spots in the code, we often need some way to follow
    the code line by line in order to really find out what's wrong. In the next section,
    we'll see how to use the Python debugger to step through the code and find the
    problem spots. We'll also take a quick look at how to perform post-mortem debugging
    in Grok, which involves jumping into the debugger to analyze the program state
    immediately after an exception has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Grok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For regular debugging, where we need to step through the code to see what''s
    going on inside it, the Python debugger is an excellent tool. To use it, you just
    have to add the next line at the point where you wish to start debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out. Open the `app.py` module and change the `add` method of
    the `AddProjectForm` class (line 108) to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we invoke the debugger at the beginning of the method. Now, start
    the instance, go to the ''add project'' form, fill it in, and submit it. Instead
    of seeing the new project view, the browser will stay at the ''add form'' page,
    and display the **waiting for..**. message. This is because control has been transferred
    to the console in order for the debugger to act. Your console will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The debugger is now active and waiting for input. Notice that the line number
    where debugging started appears right beside the path of the module in which we
    are located. After the line number, comes the name of the method, `add()`. Below
    that, the next line of code to be executed is shown.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger commands are simple. To execute the current line, click on *n:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see the available commands if you type *h:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The list command `id` is used for getting a bird''s eye view of where in the
    code we are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the current line is identified by an arrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to type in the names of objects within the current execution
    context and find out their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can, of course, continue stepping line-by-line through all of the code in
    the application, including Grok's own code, checking values as we proceed. When
    we are through reviewing, we can click on *c* to return control to the browser.
    At this point, we will see the project view.
  prefs: []
  type: TYPE_NORMAL
- en: The Python debugger is very easy to use, and it can be invaluable for finding
    obscure bugs in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The default Ajax debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other kind of debugging is known as *post-mortem debugging*. In the previous
    section, we stepped through the code at leisure while the application was in a
    stable and running condition. Many times, however, we can run into an error condition
    that stops the program and we need to analyze what the state of the program was
    at the time at which the error occurred. That's what post-mortem debugging is
    about.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now intentionally introduce an error in our code. Remove the `import
    pdb` line from the `add` method, and change the first line after that to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Project` class' `__init__` method does not expect this argument, so a `TypeError`
    will be raised. Restart the instance and add a project. Instead of a view, a blank
    screen with the error message **A system error occurred** will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that, so far, we have been using the `deploy.ini` file to start the
    instance, by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To run a post-mortem debugger session, we have to start our instance with the
    debug profile instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to add a project again. Now, instead of the simple error message, a full
    traceback of the error will be shown on screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The default Ajax debugger](img/7481_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One nice thing about the traceback is that it is expandable. Clicking on the
    brackets to the left will show the lines of code around the line where the error
    occurred, while clicking on the plus sign to the right of a module and line message
    will show additional traceback information. Above this information you will also
    see a text box that can be used to evaluate expressions within the current context
    (refer to the next screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: '![The default Ajax debugger](img/7481_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Post-mortem debugging with the Python debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ajax debugger is great, but if you are really used to the Python debugger,
    you might wish to use that instead for your post-mortem analysis. This is no problem;
    Grok comes prepared for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick test, edit the `parts/etc/debug.ini` file in the project and change
    the word `ajax` to `pdb` in the `[filter-app:main]` section. It should look like
    this when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart the instance with the debug profile and try to add a project. Instead
    of seeing the Ajax screen, control will be transferred to the Python debugger
    on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we just modified a file that will be rewritten when we run
    the `buildout` again, so do this only for quick tests, as we just did, and never
    depend upon changes to the files in the `parts/etc` directory. In order to make
    this change permanent, remember to edit the `etc/debug.ini.in` file instead of
    the one in the `parts/etc` directory. You will then need to run the `buildout`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed how to test Grok applications and why it's important
    to do so. We also covered debugging, and looked at some useful debugging tools
    for the Grok developer. Now that we have added tests, in the following chapter,
    we'll see how to deploy our application.
  prefs: []
  type: TYPE_NORMAL
