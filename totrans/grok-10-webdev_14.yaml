- en: Chapter 13. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 测试和调试
- en: 'Throughout this book, we have been discussing how Grok offers an agile way
    of working with Zope. However, up to this point, we have neglected to perform
    one activity that is considered most important in agile projects: *testing*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在讨论Grok如何提供一种敏捷的方式来与Zope协同工作。然而，到目前为止，我们还没有忽视一个被认为在敏捷项目中最重要的活动：*测试*。
- en: Grok offers some tools for testing, and in fact, a project created by `grokproject`
    (as the one that we have been extending) includes a functional test suite. In
    this chapter, we are going to discuss testing, and will then write some tests
    for the functionality that our application has so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Grok提供了一些测试工具，实际上，由`grokproject`（即我们一直在扩展的那个）创建的项目包括一个功能测试套件。在本章中，我们将讨论测试，然后为我们的应用程序迄今为止的功能编写一些测试。
- en: Testing helps us to avoid bugs, but it does not eliminate them completely, of
    course. There will be times when we will have to dive into the code to find out
    what's going wrong in it. A good set of debugging aids becomes very valuable in
    this situation. We'll see that there are several ways of debugging a Grok application,
    and will try out a couple of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试帮助我们避免错误，但当然不能完全消除它们。有时我们不得不深入代码以找出其中的问题。在这种情况下，一套好的调试辅助工具变得非常有价值。我们将看到有几种调试Grok应用程序的方法，并尝试其中的一些。
- en: 'Some of the things that we will cover includes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些内容包括：
- en: The need for testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的需求
- en: Testing in Grok
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grok中的测试
- en: Extending the functional test suite provided by `grokproject`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`grokproject`提供的功能测试套件
- en: Other kinds of testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的测试
- en: Debugging tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具
- en: Testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: It's important to understand that testing should not be treated as an afterthought.
    It's just that in a book like this one, which focuses a lot on testing, it can
    be harder to follow explanations and code in the initial stages of your reading.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 理解测试不应被视为事后之想是很重要的。只是在像这样一本大量关注测试的书中，在阅读的初期阶段，可能更难理解解释和代码。
- en: As mentioned earlier, agile methodologies place a lot of emphasis on testing.
    In fact, there's even a methodology called **Test Driven Development** (**TDD**),
    which not only encourages writing tests for our code, but also encourages writing
    tests before writing a single line of code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，敏捷方法非常重视测试。实际上，甚至有一种名为**测试驱动开发**（**TDD**）的方法，它不仅鼓励为我们的代码编写测试，还鼓励在编写任何代码之前编写测试。
- en: 'There are various kinds of testing, but here we''ll briefly describe only two:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种类型的测试，但在这里我们只简要描述两种：
- en: Unit testing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration or functional tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成或功能测试
- en: Unit testing
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: The idea of unit testing is to break a program into its constituent parts and
    test each one of them in isolation. Every method or function call is tested separately
    to make sure that it returns the expected results and handles all of the possible
    inputs correctly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的想法是将程序分解为其组成部分，并单独测试每一个。每个方法或函数调用都是单独测试的，以确保它返回预期的结果并正确处理所有可能的输入。
- en: An application that has unit tests that cover a majority of its lines of code
    allows its developers to constantly run the tests after a change, and makes sure
    that modifications to the code do not break the existing functionality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个拥有覆盖大部分代码行数的单元测试的应用程序，允许其开发者不断在更改后运行测试，并确保代码的修改不会破坏现有的功能。
- en: Functional tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional tests are concerned with how the application behaves as a whole.
    In a web application, this means, how it responds to a browser request and whether
    it returns the expected HTML for a given call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试关注的是应用程序的整体行为。在一个Web应用程序中，这意味着它如何响应浏览器请求，以及它是否为给定的调用返回预期的HTML。
- en: Ideally, the customer himself has a hand in defining these tests, usually through
    explicit functionality requirements or acceptance criteria. The more formal that
    the requirements from the customer are, the easier it is to define appropriate
    functional tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，客户自己参与定义这些测试，通常是通过明确的功能需求或验收标准。客户的要求越正式，定义适当的函数测试就越容易。
- en: Testing in Grok
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grok中的测试
- en: Grok highly encourages the use of both kinds of tests, and in fact includes
    a powerful testing tool that is automatically configured with every project. In
    the Zope world — from where Grok originated — a lot of value is placed in a kind
    of test known as a "doctest", so Grok comes with a sample test suite of this kind.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Grok强烈鼓励使用这两种测试，实际上，每个项目都自动配置了一个强大的测试工具。在Grok起源的Zope世界中，一种称为“doctest”的测试被赋予了很高的价值，因此Grok附带了一个此类测试的示例测试套件。
- en: Doctests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctests
- en: A **doctest** is a test that's written as a text file, with lines of code mixed
    with explanations of what the code is doing. The code is written in a way that
    simulates a Python interpreter session. As tests exercise large portions of the
    code (ideally 100%), they usually offer a good way of finding out of what an application
    does and how. So if an application has no written documentation, its tests would
    be the next obvious way of finding out what it does. Doctests take this idea further,
    by allowing the developer to explain in the text file exactly what each test is
    doing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**doctest**是一种以文本文件编写的测试，其中包含代码行和解释代码正在做什么的说明。代码以模拟Python解释器会话的方式编写。由于测试会锻炼代码的大部分内容（理想情况下100%），它们通常提供了一种很好的方法来了解应用程序做什么以及如何做。因此，如果一个应用程序没有书面文档，其测试将是了解其功能的下一个明显的方法。Doctests通过允许开发者在文本文件中精确地解释每个测试正在做什么，进一步发展了这个想法。'
- en: Doctests are especially useful for functional testing, because it makes more
    sense to document the high-level operations of a program. Unit tests, on the other
    hand, are expected to evaluate the program bit by bit, and it can be cumbersome
    to write a text explanation for every little piece of code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests在功能测试中特别有用，因为它更有意义地记录了程序的高级操作。另一方面，单元测试则预期逐步评估程序，为每一小段代码编写文本说明可能会很繁琐。
- en: A possible drawback of doctests is that they can make the developer think that
    he needs no other documentation for his project. In almost all cases, this is
    not true. Documenting an application or package makes it immediately more accessible
    and useful, so it is strongly recommended that doctests should not be used as
    a replacement for good documentation. We'll show an example of using doctests
    in the *Looking at the test code* section of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests的一个可能的缺点是它们可能会让开发者认为他不需要为他的项目提供其他文档。在几乎所有情况下，这都不是真的。记录一个应用程序或包可以立即使其更易于访问和有用，因此强烈建议不要将doctests用作良好文档的替代品。我们将在本章的“查看测试代码”部分展示使用doctests的示例。
- en: Default test setup for Grok projects
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grok项目的默认测试设置
- en: As mentioned earlier, Grok projects that are started with the `grokproject`
    tool already include a simple functional test suite, by default. Let's examine
    this in detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用`grokproject`工具启动的Grok项目默认已经包含了一个简单的功能测试套件。让我们详细地来考察一下。
- en: Test configuration
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试配置
- en: The default test configuration looks for packages or modules that have the word
    'tests' in their name and tries to run the tests inside. For functional tests,
    any files ending with `.txt` or `.rst` are considered.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认测试配置会查找名称中包含“tests”一词的包或模块，并尝试在其中运行测试。对于功能测试，任何以`.txt`或`.rst`结尾的文件都被认为是测试文件。
- en: For functional tests that need to simulate a browser, a special configuration
    is needed to tell Grok which packages to initialize in addition to the Grok infrastructure
    (these are usually the ones that are being worked on). The `ftesting.zcml` file
    in the `package` directory holds this configuration. This file also includes a
    couple of user definitions that are used by certain tests to examine functionality
    that is specific to a certain role, such as manager.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要模拟浏览器的功能测试，需要一个特殊的配置来告诉Grok除了Grok基础设施外还需要初始化哪些包（这些通常是正在工作的包）。`package`目录中的`ftesting.zcml`文件包含这个配置。此文件还包括一些用户定义，这些定义被某些测试用来检查特定于某个角色（如经理）的功能。
- en: Test files
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试文件
- en: In addition to the already mentioned `ftesting.zcml` file, in the same directory
    there is a `tests.py` file added by `grokproject`, which basically loads the ZCML
    declarations and registers all of the tests in the package.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经提到的`ftesting.zcml`文件外，在同一目录下，`grokproject`还添加了一个`tests.py`文件，该文件基本上加载ZCML声明并注册包中的所有测试。
- en: The actual tests that are included with the default project files are contained
    in the `app.txt` file. These are doctests that perform a functional test run by
    loading the entire Grok environment and imitating a browser. We'll take a look
    at the contents of the file soon, but first let's run the tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认项目文件中包含的实际测试包含在`app.txt`文件中。这些是通过加载整个Grok环境和模拟浏览器来执行功能测试的doctests。我们很快就会查看文件的内容，但首先让我们运行测试。
- en: Running the tests
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试
- en: As a part of the project's build process, a script named `test` is included
    in the `bin` directory when you create a new project. This is the **test runner**,
    and calling it without arguments finds and executes all of the tests in the packages
    that are included in the configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为项目构建过程的一部分，当你创建一个新项目时，`bin`目录中会包含一个名为`test`的脚本。这是**测试运行器**，不带参数调用它将找到并执行配置中包含的包中的所有测试。
- en: 'We haven''t added a single test so far, so if we type `bin/test` in our project
    directory, we''ll see more or less the same thing that doing this on a new project
    would show:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有添加任何测试，所以如果我们在我们项目的目录中输入`bin/test`，我们会看到与在新项目中执行此操作大致相同的结果：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only difference between our output and that of a newly created Grok package
    is in the `sqlalchemy` lines. Of course, the most important part of the output
    is the penultimate line, which shows the number of tests that were run and whether
    there were any failures or errors. A *failure* means that a test didn't pass,
    which means that the code is not doing what it's supposed to do and needs to be
    checked. An *error* signifies that the code crashed unexpectedly at some point,
    and the test couldn't even be executed, so it's necessary to find the error and
    correct it before worrying about the tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出与新建Grok包输出的唯一区别在于`sqlalchemy`行。当然，输出中最重要的部分是倒数第二行，它显示了运行了多少个测试以及是否有失败或错误。*失败*意味着测试没有通过，这意味着代码没有按照预期执行，需要检查。*错误*表示代码在某个点意外崩溃，测试甚至无法执行，因此有必要在担心测试之前找到错误并纠正它。
- en: The test runner
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试运行器
- en: 'The test runner program looks for modules that contain tests. The test can
    be of three different types: Python tests, simple doctests, and full-functionality
    doctests. To let the test runner know which test file includes which kind of tests,
    a comment similar to the following is placed at the top of the file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器程序会寻找包含测试的模块。测试可以是三种不同类型之一：Python测试、简单的doctests和全功能的doctests。为了让测试运行器知道哪个测试文件包含哪种类型的测试，文件顶部会放置一个类似于以下的注释：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the Python unit test layer will be used to run the tests. The
    other value that we are going to use is doctest, when we learn how to write doctests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用Python单元测试层来运行测试。我们还将使用doctest，当我们学习如何编写doctests时。
- en: The test runner then finds all of the test modules and runs them in the corresponding
    layer. Although unit tests are considered very important in regular development,
    we may find functional tests more necessary for a Grok web application, as we
    will usually be testing views and forms, which require the full Zope/Grok stack
    to be loaded, in order to work. That's the reason why we find only functional
    doctests in the default setup.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器随后会找到所有的测试模块，并在相应的层中运行它们。尽管单元测试在常规开发中被认为非常重要，但我们可能会发现对于Grok Web应用来说，功能测试更为必要，因为我们通常会测试视图和表单，这需要加载完整的Zope/Grok堆栈才能工作。这就是为什么我们在默认设置中只找到功能性的doctests的原因。
- en: Test layers
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试层
- en: A **test layer** is a specific test setup that is used to differentiate the
    tests that are executed. By default, there is a test layer for each of the three
    types of tests handled by the test runner. It's possible to run a test layer without
    running the others. It is also possible to create new test layers in order to
    cluster together tests that require a specific setup.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试层**是一种特定的测试设置，用于区分执行的测试。默认情况下，测试运行器处理的三种测试类型中，每种类型都有一个测试层。可以运行一个测试层而不运行其他层。也可以创建新的测试层，以便将需要特定设置的测试聚集在一起。'
- en: Invoking the test runner
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用测试运行器
- en: As shown above, running `bin/test` will start the test runner with the default
    options. It's also possible to specify a number of options, and the most important
    ones of these are summarized below. In the following table, command-line options
    are shown to the left. Most options can be expressed using a short form (one dash)
    or a long form (two dashes). Arguments for each option are shown in uppercase.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，运行`bin/test`将使用默认选项启动测试运行器。也可以指定多个选项，其中最重要的选项如下总结。在下表中，命令行选项显示在左侧。大多数选项可以使用短形式（一个连字符）或长形式（两个连字符）来表示。每个选项的参数以大写形式显示。
- en: '| Option | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-s PACKAGE, --package=PACKAGE, --dir=PACKAGE` | Search the given package''s
    directories for tests. This can be specified more than once, to run tests in multiple
    parts of the source tree. For example, when refactoring interfaces, you don''t
    want to see the way you have broken setups for tests in other packages. You just
    want to run the interface tests. Packages are supplied as dotted names. For compatibility
    with the old test runner, forward and backward slashes in package names are converted
    to dots. (In the special case of packages, which are spread over multiple directories,
    only directories within the test search path are searched.) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `-s 包, --package=包, --dir=包` | 在指定的包目录中搜索测试。这可以指定多次，以在源树的不同部分运行测试。例如，在重构接口时，你不想看到其他包中测试设置的破坏方式。你只想运行接口测试。包以点分隔的名称提供。为了与旧测试运行器兼容，包名称中的前后斜杠被转换为点。
    （在包的特殊情况下，这些包分布在多个目录中，只有测试搜索路径内的目录将被搜索。） |'
- en: '| `-m MODULE, --module=MODULE` | Specify a test-module filter as a regular
    expression. This is a case-sensitive regular expression that is used in *search*
    (not match) mode to limit which test modules are searched for tests. The regular
    expressions are checked against dotted module names. In an extension of Python
    regexp notation, a leading "!" is stripped and causes the sense of the remaining
    regexp to be negated (so "!bc" matches any string that does not match "bc", and
    vice versa). This option can specify multiple test-module filters. Test modules
    matching any of the test filters are searched. If no test-module filter is specified,
    then all of the test modules are used. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `-m 模块, --module=模块` | 指定一个测试模块过滤器作为正则表达式。这是一个区分大小写的正则表达式，用于*搜索*（而非匹配）模式，以限制搜索哪些测试模块。正则表达式将与点分隔的模块名称进行匹配检查。在Python正则表达式符号的扩展中，一个前导的"!"将被移除，并导致剩余正则表达式的意义被否定（因此"!bc"匹配任何不匹配"bc"的字符串，反之亦然）。此选项可以指定多个测试模块过滤器。匹配任何测试过滤器的测试模块将被搜索。如果没有指定测试模块过滤器，则使用所有测试模块。
    |'
- en: '| `-t TEST, --test=TEST` | Specify a test filter as a regular expression. This
    is a case-sensitive regular expression that is used in *search* (not match) mode
    to limit which tests are run. In an extension of Python regexp notation, a leading
    "!" is stripped and causes the sense of the remaining regexp to be negated (so
    "!bc" matches any string that does not match "bc", and vice versa). This option
    can specify multiple test filters. Tests matching any of the test filters are
    included. If no test filter is specified, then all of the tests are executed.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `-t 测试, --test=测试` | 指定一个测试过滤器作为正则表达式。这是一个区分大小写的正则表达式，用于*搜索*（而非匹配）模式，以限制运行哪些测试。在Python正则表达式符号的扩展中，一个前导的"!"将被移除，并导致剩余正则表达式的意义被否定（因此"!bc"匹配任何不匹配"bc"的字符串，反之亦然）。此选项可以指定多个测试过滤器。匹配任何测试过滤器的测试将被包含。如果没有指定测试过滤器，则执行所有测试。
    |'
- en: '| `--layer=LAYER` | Specify a test layer to run. This option can be provided
    multiple times in order to specify more than one layer. If not specified, all
    of the layers are executed. It is common for the running script to provide default
    values for this option. Layers are specified regular expressions that are used
    in search mode, for dotted names of objects that define a layer. In an extension
    of Python regexp notation, a leading "!" is stripped and causes the sense of the
    remaining regexp to be negated (so "!bc" matches any string that does not match
    "bc", and vice versa). The layer named ''unit'' is reserved for unit tests; however,
    take note of the *unit* and *non-unit* options. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `--layer=LAYER` | 指定要运行的测试层。此选项可以多次提供，以便指定多个层。如果没有指定，将执行所有层。运行脚本通常为此选项提供默认值。层是用于搜索模式中对象点名称的正则表达式。在
    Python 正则表达式记法的一个扩展中，一个前导的 "!" 被移除，导致剩余正则表达式的意义被否定（因此 "!bc" 匹配任何不匹配 "bc" 的字符串，反之亦然）。名为
    ''unit'' 的层保留用于单元测试；然而，请注意 *unit* 和 *non-unit* 选项。'
- en: '| `-u, --unit` | Executes only unit tests, ignoring any layer options. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `-u, --unit` | 仅执行单元测试，忽略任何层选项。|'
- en: '| `-f, --non-unit` | Executes tests other than unit tests. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `-f, --non-unit` | 执行除单元测试之外的其他测试。|'
- en: '| `-v, --verbose` | Makes the output more verbose. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `-v, --verbose` | 使输出更详细。|'
- en: '| `-q, --quiet` | Provides minimal output, by overriding any verbosity options.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `-q, --quiet` | 通过覆盖任何详细程度选项提供最小输出。|'
- en: Looking at the test code
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看测试代码
- en: Let's take a look at the three default test files of a Grok project, to see
    what each one does.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Grok 项目中的三个默认测试文件，看看每个文件的作用。
- en: ftesting.zcml
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ftesting.zcml
- en: As we explained earlier, `ftesting.zcml` is a configuration file for the test
    runner. Its main objective is to help us set up the test instance with users,
    so that we can test different roles according to our needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，`ftesting.zcml` 是测试运行器的配置文件。其主要目的是帮助我们设置带有用户的测试实例，以便我们可以根据需要测试不同的角色。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As shown in the preceding code, the configuration simply includes a security
    policy, complete with users and roles, and the packages that should be loaded
    by the instance, in addition to the regular Grok infrastructure. If we run any
    tests that require an authenticated user to work, we'll use these special users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，配置简单地包含了一个安全策略，包括用户和角色，以及实例应该加载的包，以及除了常规 Grok 基础设施之外的内容。如果我们运行需要经过身份验证的用户才能工作的任何测试，我们将使用这些特殊用户。
- en: The includes at the top of the file make sure that the entire Zope Component
    Architecture setup needed by our application is performed prior to running the
    tests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部的包含确保在运行测试之前执行我们应用程序所需的整个 Zope 组件架构设置。
- en: tests.py
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tests.py
- en: 'The default test module is very simple. It defines the functional layer and
    registers the tests for our package:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认测试模块非常简单。它定义了功能层并注册了我们包的测试：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the imports, the first line gets the path for the `ftesting.zcml` file,
    which is then passed to the layer definition method `ZCMLLayer`. The final line
    in the module tells the test runner to find and register all of the tests in the
    package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，第一行获取 `ftesting.zcml` 文件的路径，然后将其传递给层定义方法 `ZCMLLayer`。模块中的最后一行告诉测试运行器找到并注册包中的所有测试。
- en: This will be enough for our testing needs in this chapter, but if we needed
    to create another non-Grok package for our application, we would need to add a
    line like the last one to it, so that all of its tests are found by the test runner.
    This is pretty much boilerplate code, as only the package name has to be changed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将足够满足我们本章的测试需求，但如果我们需要为我们的应用程序创建另一个非 Grok 包，我们就需要在其上添加类似于最后一行的行，以便测试运行器可以找到所有测试。这基本上是样板代码，因为只需要更改包名。
- en: app.txt
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.txt
- en: 'We finally come to the reason for this entire configuration the actual tests
    that will be executed by the test runner. By default, the tests are included inside
    the `app.txt` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终来到了整个配置的原因所在，即测试运行器将要执行的实际测试。默认情况下，测试被包含在 `app.txt` 文件中：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The text file has a title, and immediately after that a `:doctest:` declaration
    a declaration that tells the test runner that these tests need a functional layer
    to be loaded for their execution. Then comes a `:layer:` declaration, which is
    a path that points to the layer that we defined earlier in `tests.py`. After that
    comes the test code. Lines starting with three brackets represent the Python code
    that is tested. Anything else is commentary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件有一个标题，紧接着是一个 `:doctest:` 声明，这是一个告诉测试运行器这些测试需要加载一个功能层来执行声明的声明。然后是一个 `:layer:`
    声明，它是一个指向我们在 `tests.py` 中之前定义的层的路径。之后是测试代码。以三个括号开头的行代表被测试的 Python 代码。其他任何内容都是注释。
- en: When using the Python interpreter, a line of code may return a value, in which
    case the expected return value must be written immediately below that line. This
    expected value will be compared with the real return value of the tested code,
    and a failure will be reported if the values don't match. Similarly, a line that
    is followed by an empty line will produce a failure when the code is executed
    and a result is returned, because it is assumed that the expected return value
    in that case is `None`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Python 解释器时，一行代码可能会返回一个值，在这种情况下，预期的返回值必须立即写在那行代码下面。这个预期值将与测试代码的实际返回值进行比较，如果值不匹配，将报告失败。同样，如果一行代码后面跟着一个空行，当代码执行并返回结果时，也会产生失败，因为在这种情况下，预期返回值被认为是
    `None`。
- en: For example, in the last line of the Python doctest below the expression `browser.headers.get('Status').upper()`
    is expected to return the value `200 OK`. If anything else at all is returned,
    the test will fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的 Python doctest 的最后一行中，表达式 `browser.headers.get('Status').upper()` 预期返回值
    `200 OK`。如果返回任何其他值，测试将失败。
- en: Adding our own tests
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加我们自己的测试
- en: Now, let's add a few functional tests that are specific to our application.
    We will need to emulate a browser for that. The `zope.testbrowser` package includes
    a browser emulator. We can pass any valid URL to this browser by using `browser.open`,
    and it will send a request to our application exactly like a browser would. The
    response from our application will be then available as `browser.contents`, so
    that we can perform our testing comparisons on it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些针对我们应用程序的特定功能测试。为此，我们需要模拟一个浏览器。`zope.testbrowser` 包包含一个浏览器模拟器。我们可以通过使用
    `browser.open` 将任何有效的 URL 传递给这个浏览器，它将像浏览器一样向我们的应用程序发送请求。然后，我们的应用程序的响应将作为 `browser.contents`
    可用，这样我们就可以在上面执行我们的测试比较。
- en: The Browser class
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器类
- en: 'Before writing our tests, it will be useful to see what exactly our `testbrowser`
    can do. Of course, anything that depends on JavaScript will not work here, but
    other than that, we can interact with links and even forms in a very straightforward
    manner. Here''s a look at the main functionality offered by the `Browser` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的测试之前，查看我们的 `testbrowser` 能做什么将非常有用。当然，任何依赖于 JavaScript 的功能在这里都不会工作，但除此之外，我们可以以非常直接的方式与链接甚至表单进行交互。以下是
    `Browser` 类提供的主要功能：
- en: '| Initialization | >>> from zope.testbrowser.testing import Browser>>> browser
    = Browser() |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 初始化 | >>> from zope.testbrowser.testing import Browser>>> browser = Browser()
    |'
- en: '| Page contents | >>> print browser.contents<html><head><title>Simple Page</title></head><body><h1>Simple
    Page</h1></body></html>>>> ''<h1>Simple Page</h1>'' in browser.contentsTrue |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 页面内容 | >>> print browser.contents<html><head><title>Simple Page</title></head><body><h1>Simple
    Page</h1></body></html>>>> ''<h1>Simple Page</h1>'' in browser.contentsTrue |'
- en: '| Headers | >>> print browser.headersStatus: 200 OKContent-Length: 123Content-Type:
    text/html;charset=utf-8X-Powered-By: Zope (www.zope.org), Python (www.python.org)>>>
    browser.headers[''content-type'']''text/html;charset=utf-8'' |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 头部信息 | >>> print browser.headersStatus: 200 OKContent-Length: 123Content-Type:
    text/html;charset=utf-8X-Powered-By: Zope (www.zope.org), Python (www.python.org)>>>
    browser.headers[''content-type'']''text/html;charset=utf-8'' |'
- en: '| Cookies | >>> browser.cookies[''foo'']''bar''>>> browser.cookies.keys()[''foo'']>>>
    browser.cookies.values()[''bar'']>>> browser.cookies.items()[(''foo'', ''bar'')]>>>
    ''foo'' in browser.cookiesTrue>>> browser.cookies[''sha''] = ''zam'' |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|Cookies | >>> browser.cookies[''foo'']''bar''>>> browser.cookies.keys()[''foo'']>>>
    browser.cookies.values()[''bar'']>>> browser.cookies.items()[(''foo'', ''bar'')]>>>
    ''foo'' in browser.cookiesTrue>>> browser.cookies[''sha''] = ''zam'' |'
- en: '| Links | >>> link = browser.getLink(''Link Text'')>>> link<Link text=''Link
    Text''url=''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>>
    link.text''Link Text''>>> link.tag # links can also be image maps.''a''>>> link.url
    # it''s normalized''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>
    link.attrs{''href'': ''navigate.html?message=By+Link+Text''}>>> link.click()>>>
    browser.url''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 链接 | >>> link = browser.getLink(''Link Text'')>>> link<Link text=''Link Text''url=''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>>
    link.text''Link Text''>>> link.tag # 链接也可以是图像映射.''a''>>> link.url # 它已被标准化''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''>>>
    link.attrs{''href'': ''navigate.html?message=By+Link+Text''}>>> link.click()>>>
    browser.url''http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text''
    |'
- en: '| Form controls | >>> control = browser.getControl(''Text Control'')>>> control<Control
    name=''text-value'' type=''text''>>>> browser.getControl(label=''Text Control'')
    # equivalent<Control name=''text-value'' type=''text''>>>> browser.getControl(''Text
    Control'').value = ''Other Text''>>> browser.getControl(''Submit'').click() |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 表单控件 | >>> control = browser.getControl(''Text Control'')>>> control<Control
    name=''text-value'' type=''text''>>>> browser.getControl(label=''Text Control'')
    # 等效<Control name=''text-value'' type=''text''>>>> browser.getControl(''Text Control'').value
    = ''Other Text''>>> browser.getControl(''Submit'').click() |'
- en: Now that we know what we can do, let's try our hand at writing some tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们可以做什么，让我们尝试编写一些测试。
- en: Our first to-do application tests
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的第一批待办应用测试
- en: Ideally, we should have been adding a couple of doctests to the `app.txt` file
    every time we added a new functionality to our application. We have gone through
    the reasons why we didn't do so, but let's recover some lost ground. At the very
    least, we'll get a feeling of how doctests work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该在每次向我们的应用程序添加新功能时，在`app.txt`文件中添加几个doctests。我们已经讨论了我们为什么没有这样做的原因，但让我们弥补一些失去的地盘。至少，我们将对doctests的工作方式有一个感觉。
- en: 'We''ll add our new tests to the existing `app.txt` file. The last test that
    we saw left us at the to-do instance URL. We are not logged in, so if we print
    the browser contents, we will get the login page. Let''s add a test for this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把新的测试添加到现有的`app.txt`文件中。我们看到的最后一个测试将我们留在了待办实例的URL上。我们没有登录，所以如果我们打印浏览器内容，我们会得到登录页面。让我们为这个情况添加一个测试：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we mentioned earlier, when visiting a URL with the `testbrowser`, the entire
    HTML content of the page is stored in `browser.contents`. Now we know that our
    login page has a username field and a password field, so we simply use a couple
    of `in` expressions and check if these fields evaluate to `True`. If they do,
    it would mean that the browser is effectively looking at the login page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，当使用`testbrowser`访问URL时，页面的整个HTML内容都存储在`browser.contents`中。现在我们知道我们的登录页面有一个用户名字段和一个密码字段，所以我们只需使用几个`in`表达式来检查这些字段是否评估为`True`。如果是，这意味着浏览器实际上正在查看登录页面。
- en: 'Let''s add a test for logging in. When we start the application in the tests,
    the user database is empty, therefore, the most economical way of logging in is
    to use basic authentication. This can be easily done by changing the request headers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为登录添加一个测试。当我们开始在测试中启动应用程序时，用户数据库是空的，因此，最经济的登录方式是使用基本认证。这可以通过更改请求头轻松完成：
- en: 'Let''s log in with the manager user defined in `ftesting.zcml`. To keep things
    simple, let''s use the basic authentication headers to get in:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在`ftesting.zcml`中定义的管理员用户登录。为了使事情简单，让我们使用基本认证头来登录：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it. We just add the header, "reload" the home page, and we should be
    logged in. We verify it by looking for the **Logged in as** message, which we
    know has to be there after a successful login.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。我们只需添加标题，“重新加载”主页，我们应该就登录了。我们通过寻找**登录为**消息来验证它，我们知道在成功登录后必须在那里。
- en: 'Once we are logged in, we can finally test our application properly. Let''s
    begin by adding a project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们就可以最终正确地测试我们的应用程序了。让我们先添加一个项目：
- en: 'We are now in. Let''s create a project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经登录了。让我们创建一个项目：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we find the link on the home page that will take us to the 'add form'
    project. This is done easily with the help of the `getLink` method and the text
    of the link. We click on the link and then should have the form ready to fill
    in. We then use `getControl` to find each field by its name, and change its value.
    Finally, we submit the form by getting the submit button control and clicking
    on it. The result is that the project is created and we are redirected to its
    main view. We can confirm this by comparing the `browser url` with the URL that
    we would expect in this case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在主页上找到将带我们转到 '添加表单' 项目的链接。这可以通过 `getLink` 方法和链接文本轻松完成。我们点击链接，然后应该有一个可以填写的表单。然后我们使用
    `getControl` 通过名称找到每个字段并更改其值。最后，我们通过获取提交按钮控件并点击它来提交表单。结果是项目被创建，并且我们被重定向到其主视图。我们可以通过比较
    `browser url` 与在这种情况下我们预期的 URL 来确认这一点。
- en: 'Adding a list to the project is just as easy. We get the form controls, assign
    them some values, and click on the submit button. The list and the link for adding
    new items to it should appear in the browser contents:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加列表同样简单。我们获取表单控件，分配一些值，然后点击提交按钮。列表和添加新项到其中的链接应该出现在浏览器内容中：
- en: 'We have added a project. Now, we''ll add a list to it. If we are successful,
    we will see a link for adding a new item for the list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个项目。现在，我们将向其中添加一个列表。如果我们成功，我们将看到一个用于添加列表新项的链接：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Good. Let''s see how we are doing so far:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们看看到目前为止我们做得怎么样：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Not bad. We now have four more working tests than when we started.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。我们现在比开始时多了四个工作测试。
- en: 'Note that the test browser handles `HTTP` errors gracefully, returning a string
    similar to what a real browser would return when running into an error. For example,
    take a look at the following test:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试浏览器优雅地处理 `HTTP` 错误，返回一个类似于真实浏览器在遇到错误时返回的字符串。例如，看看以下测试：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's the default behavior because this is how real browsers work, but sometimes,
    when we are debugging, it's better to take a look at the original exception caused
    by our application. In such a case, we can make the browser stop handling errors
    automatically and throw the original exceptions, so that we can handle them. This
    is done by setting the `browser.handleErrors` property to `False:`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认行为，因为这是真实浏览器的行为方式，但有时，当我们调试时，查看由我们的应用程序引起的原始异常会更好。在这种情况下，我们可以让浏览器停止自动处理错误并抛出原始异常，这样我们就可以处理它们。这是通过将
    `browser.handleErrors` 属性设置为 `False` 来实现的：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding unit tests
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加单元测试
- en: Apart from functional tests, we can also create pure Python test cases that
    the test runner can find. Whereas functional tests cover application behavior,
    unit tests focus on program correctness. Ideally, every single Python method in
    the application should be tested.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能测试之外，我们还可以创建纯 Python 测试用例，测试运行器可以找到它们。而功能测试覆盖应用程序行为，单元测试则关注程序的正确性。理想情况下，应用程序中的每个
    Python 方法都应该经过测试。
- en: The unit test layer does not load the Grok infrastructure, so tests should not
    take anything that comes with it for granted just the basic Python behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试层不会加载 Grok 基础设施，因此测试不应该理所当然地接受它所附带的一切，而只接受基本的 Python 行为。
- en: 'To add our unit tests, we''ll create a module named `unit_tests.py`. Remember,
    in order for the test runner to find our test modules, their names have to end
    with ''tests''. Here''s what we will put in this file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的单元测试，我们将创建一个名为 `unit_tests.py` 的模块。记住，为了让测试运行器找到我们的测试模块，它们的名称必须以 'tests'
    结尾。以下是我们将放入此文件的内容：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `:unittest:` comment at the top, is very important. Without it, the test
    runner will not know in which layer your tests should be executed, and will simply
    ignore them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的 `:unittest:` 注释非常重要。没有它，测试运行器将不知道你的测试应该在哪个层执行，它将简单地忽略它们。
- en: Unit tests are composed of test cases, and, in theory, each should contain several
    tests related to a specific area of the application's functionality. The test
    cases use the `TestCase` class from the Python `unittest` module. In these tests,
    we define a single test case that contains two very simple tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试由测试用例组成，理论上，每个测试用例都应该包含与应用程序功能特定区域相关的几个测试。测试用例使用 Python 的 `unittest` 模块中的
    `TestCase` 类。在这些测试中，我们定义了一个包含两个非常简单的测试的单个测试用例。
- en: We are not getting into the details here. Just notice that the test case can
    include a `setUp` method and a `tearDown` method that can be used to perform any
    common initialization and destruction tasks that are required in order to get
    the tests working and finishing cleanly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不深入细节。只需注意，测试用例可以包括一个`setUp`方法和一个`tearDown`方法，这些方法可以用来执行任何必要的公共初始化和销毁任务，以便使测试工作并干净地完成。
- en: Every test inside a test case needs to have the prefix 'test' in its name, so
    we have exactly two tests that fulfill this condition. Both of the tests need
    an instance of the `Todo` class to be executed, so we assign it to the test case
    as a class variable, and create it inside the `setUp` method. The tests are very
    simple and they just verify that the default property values are set upon instance
    creation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例中的每个测试都需要在其名称中包含前缀'test'，所以我们恰好有两个测试满足这个条件。这两个测试都需要`Todo`类的一个实例来执行，因此我们将其分配给测试用例作为类变量，并在`setUp`方法中创建它。这些测试非常简单，它们只是验证在实例创建时设置了默认属性值。
- en: 'Both of the tests use the `assertEqual` method to tell the test runner that
    if the two values passed are different, the test should fail. To see them in action,
    we just run the `bin/test` command once more:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试都使用`assertEqual`方法来告诉测试运行器，如果传递的两个值不同，测试应该失败。为了看到它们在行动中的样子，我们只需再次运行`bin/test`命令：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, both the functional and unit test layers contain some tests, and they are
    both run, one after the other. We can see the subtotal for each layer at the end
    of these tests for that layer, as well as the grand total of the nine passed tests,
    when the test runner finishes its work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，功能测试层和单元测试层都包含一些测试，并且它们是依次运行的。我们可以在这些测试的每个层的末尾看到该层的总计，以及当测试运行器完成其工作时九个通过测试的总计。
- en: Extending the test suite
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展测试套件
- en: Of course, we have only scratched the surface of which tests should be added
    to our application. If we continue to add tests, we may have hundreds of tests,
    by the time we finish. However, this chapter is not the place to do this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们只是触及了表面，关于哪些测试应该添加到我们的应用程序中。如果我们继续添加测试，到我们完成的时候可能会有数百个测试。然而，这一章并不是进行这项工作的地方。
- en: As mentioned earlier, it is much easier to have tests for each part of our application,
    if we add them as we code. There's no hiding from the fact that testing is a lot
    of work, but there is great value in having a complete test suite for our applications.
    This is even more so when third parties might use our product independently.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们边编码边添加测试，那么为应用程序的每个部分编写测试要容易得多。测试确实是一项大量工作，但拥有一个完整的测试套件对我们的应用程序来说价值巨大。尤其是当第三方可能独立使用我们的产品时，这一点更为重要。
- en: Debugging
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: We will now take a quick look at the debugging facilities offered by Grok. Even
    if we have a very thorough test suite, the chances are there that we will find
    a fair number of bugs in our application. When that happens, we need a quick and
    effective way to inspect the code as it runs and easily find the problem spots.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将快速查看Grok提供的调试功能。即使我们有一个非常全面的测试套件，我们也有可能在我们应用程序中发现相当数量的错误。当这种情况发生时，我们需要一种快速有效的方法来检查代码的运行情况，并轻松找到问题所在。
- en: Often, developers will use `print` statements (placed at key lines) throughout
    the code, in the hopes of finding the problem spot. Although this is usually a
    good way to begin locating sore spots in the code, we often need some way to follow
    the code line by line in order to really find out what's wrong. In the next section,
    we'll see how to use the Python debugger to step through the code and find the
    problem spots. We'll also take a quick look at how to perform post-mortem debugging
    in Grok, which involves jumping into the debugger to analyze the program state
    immediately after an exception has occurred.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者会在代码中（放置在关键行）使用`print`语句，希望找到问题所在。尽管这通常是一个开始定位代码中的痛点的好方法，但我们往往需要某种方式逐行跟踪代码，以便真正找出问题所在。在下一节中，我们将看到如何使用Python调试器逐步执行代码并找到问题所在。我们还将快速看一下如何在Grok中执行死后调试，这涉及到在异常发生后立即跳入调试器来分析程序状态。
- en: Debugging in Grok
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grok中的调试
- en: 'For regular debugging, where we need to step through the code to see what''s
    going on inside it, the Python debugger is an excellent tool. To use it, you just
    have to add the next line at the point where you wish to start debugging:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规调试，我们需要逐步执行代码以查看其内部情况，Python调试器是一个出色的工具。要使用它，你只需在你希望开始调试的点添加下一行：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try it out. Open the `app.py` module and change the `add` method of
    the `AddProjectForm` class (line 108) to look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。打开 `app.py` 模块，并将 `AddProjectForm` 类的 `add` 方法（第 108 行）改为以下内容：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that we invoke the debugger at the beginning of the method. Now, start
    the instance, go to the ''add project'' form, fill it in, and submit it. Instead
    of seeing the new project view, the browser will stay at the ''add form'' page,
    and display the **waiting for..**. message. This is because control has been transferred
    to the console in order for the debugger to act. Your console will look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在方法的开头调用了调试器。现在，启动实例，转到“添加项目”表单，填写它，然后提交。您不会看到新的项目视图，浏览器将停留在“添加表单”页面，并显示
    **等待中...** 的信息。这是因为控制权已经转移到控制台，以便调试器可以操作。您的控制台将看起来像这样：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The debugger is now active and waiting for input. Notice that the line number
    where debugging started appears right beside the path of the module in which we
    are located. After the line number, comes the name of the method, `add()`. Below
    that, the next line of code to be executed is shown.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器现在处于活动状态并等待输入。注意，调试开始时的行号就出现在我们所在的模块路径旁边。行号之后是方法名，`add()`。下面显示的是将要执行的下一行代码。
- en: The debugger commands are simple. To execute the current line, click on *n:*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器命令很简单。要执行当前行，点击 *n:*。
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see the available commands if you type *h:*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入 *h:*，您可以看到可用的命令。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The list command `id` is used for getting a bird''s eye view of where in the
    code we are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表命令 `id` 用于获取我们目前在代码中的鸟瞰图：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the current line is identified by an arrow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当前行由一个箭头标识。
- en: 'It''s possible to type in the names of objects within the current execution
    context and find out their values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前执行上下文中，我们可以输入对象的名称并找出它们的值：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can, of course, continue stepping line-by-line through all of the code in
    the application, including Grok's own code, checking values as we proceed. When
    we are through reviewing, we can click on *c* to return control to the browser.
    At this point, we will see the project view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以继续逐行检查应用程序中的所有代码，包括 Grok 的代码，在检查过程中检查值。当我们完成审查后，我们可以点击 *c* 返回控制权到浏览器。此时，我们将看到项目视图。
- en: The Python debugger is very easy to use, and it can be invaluable for finding
    obscure bugs in your code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python 调试器非常易于使用，并且对于查找代码中的隐蔽错误非常有价值。
- en: The default Ajax debugger
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认的 Ajax 调试器
- en: The other kind of debugging is known as *post-mortem debugging*. In the previous
    section, we stepped through the code at leisure while the application was in a
    stable and running condition. Many times, however, we can run into an error condition
    that stops the program and we need to analyze what the state of the program was
    at the time at which the error occurred. That's what post-mortem debugging is
    about.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试方式被称为 *事后调试*。在上一个章节中，我们在应用程序处于稳定和运行状态时随意地逐步执行代码。然而，很多时候，我们可能会遇到一个错误条件，这会停止程序，我们需要分析错误发生时程序的状态。这就是事后调试的内容。
- en: 'We''ll now intentionally introduce an error in our code. Remove the `import
    pdb` line from the `add` method, and change the first line after that to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将故意在我们的代码中引入一个错误。从 `add` 方法中删除 `import pdb` 行，并将之后的第 一行改为以下内容：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Project` class' `__init__` method does not expect this argument, so a `TypeError`
    will be raised. Restart the instance and add a project. Instead of a view, a blank
    screen with the error message **A system error occurred** will be shown.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project` 类的 `__init__` 方法不期望这个参数，因此会引发 `TypeError`。重新启动实例并添加一个项目。而不是一个视图，将显示一个空白屏幕和错误信息
    **系统错误发生**。'
- en: 'Recall that, so far, we have been using the `deploy.ini` file to start the
    instance, by using the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，到目前为止，我们一直使用 `deploy.ini` 文件通过以下命令启动实例：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run a post-mortem debugger session, we have to start our instance with the
    debug profile instead:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个事后调试会话，我们必须使用调试配置启动实例：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Try to add a project again. Now, instead of the simple error message, a full
    traceback of the error will be shown on screen, as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试添加一个项目。现在，屏幕上会显示完整的错误回溯，而不是简单的错误信息，如下截图所示：
- en: '![The default Ajax debugger](img/7481_13_01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![默认的 Ajax 调试器](img/7481_13_01.jpg)'
- en: One nice thing about the traceback is that it is expandable. Clicking on the
    brackets to the left will show the lines of code around the line where the error
    occurred, while clicking on the plus sign to the right of a module and line message
    will show additional traceback information. Above this information you will also
    see a text box that can be used to evaluate expressions within the current context
    (refer to the next screenshot).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于回溯信息的一个优点是它可以展开。点击左侧的括号将显示发生错误的那行代码周围的代码行，而点击模块和行消息右侧的加号将显示额外的回溯信息。在此信息之上，您还将看到一个文本框，可以用来在当前上下文中评估表达式（参见图表）。
- en: '![The default Ajax debugger](img/7481_13_02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![默认的Ajax调试器](img/7481_13_02.jpg)'
- en: Post-mortem debugging with the Python debugger
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python调试器进行事后调试
- en: The Ajax debugger is great, but if you are really used to the Python debugger,
    you might wish to use that instead for your post-mortem analysis. This is no problem;
    Grok comes prepared for this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax调试器很棒，但如果您真的习惯了Python调试器，您可能会希望在使用它进行事后分析时使用Python调试器。这没问题；Grok已经为此做好了准备。
- en: 'For a quick test, edit the `parts/etc/debug.ini` file in the project and change
    the word `ajax` to `pdb` in the `[filter-app:main]` section. It should look like
    this when you are done:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速测试，请编辑项目中的`parts/etc/debug.ini`文件，并在`[filter-app:main]`部分将单词`ajax`更改为`pdb`。完成时，它应该看起来像这样：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, restart the instance with the debug profile and try to add a project. Instead
    of seeing the Ajax screen, control will be transferred to the Python debugger
    on the console.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用调试配置重启实例并尝试添加项目。您将不会看到Ajax屏幕，控制权将转移到控制台上的Python调试器。
- en: Keep in mind that we just modified a file that will be rewritten when we run
    the `buildout` again, so do this only for quick tests, as we just did, and never
    depend upon changes to the files in the `parts/etc` directory. In order to make
    this change permanent, remember to edit the `etc/debug.ini.in` file instead of
    the one in the `parts/etc` directory. You will then need to run the `buildout`
    again.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只是修改了一个文件，当我们再次运行`buildout`时，该文件将被重写，所以像我们刚才做的那样，只进行快速测试，永远不要依赖于`parts/etc`目录中文件的更改。为了使此更改永久，请记住编辑`etc/debug.ini.in`文件而不是`parts/etc`目录中的文件。然后您需要再次运行`buildout`。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed how to test Grok applications and why it's important
    to do so. We also covered debugging, and looked at some useful debugging tools
    for the Grok developer. Now that we have added tests, in the following chapter,
    we'll see how to deploy our application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何测试Grok应用程序以及为什么这样做很重要。我们还介绍了调试，并查看了一些对Grok开发者有用的调试工具。现在我们已经添加了测试，在下一章中，我们将看到如何部署我们的应用程序。
