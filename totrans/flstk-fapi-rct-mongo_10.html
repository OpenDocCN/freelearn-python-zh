<html><head></head><body>
<div><div><div><h1 id="_idParaDest-155" class="contributor"><a id="_idTextAnchor166" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor167" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>10</h1>
			<h1 id="_idParaDest-156" class="contributor"><a id="_idTextAnchor168" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Web Development with Next.js 14</h1>
			<p class="calibre5">Next.js is a React framework for building full stack web applications. While React is a library for building user interfaces (web or native), Next.js is a full-blown framework, built on React, that provides dozens of features and, most importantly, a structure for projects ranging from simple websites (like the one you are going to build in this chapter) to incredibly complex applications.</p>
			<p class="calibre5">While React.js is an unopinionated declarative library for building UIs, as a framework, Next.js provides configurations, tooling, bundling, compiling, and much more, enabling the developer to focus solely on building the application.</p>
			<p class="calibre5">This chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">How to create a Next.js project and deploy it</li>
				<li class="calibre17">The newest Next.js App Router and its features</li>
				<li class="calibre17">The different types of page rendering: dynamic, server-side, static</li>
				<li class="calibre17">Next.js useful tools: the <code>Image</code> component and the <code>Head</code> component</li>
				<li class="calibre17">Server Actions along with cookie-based authentication</li>
			</ul>
			<h1 id="_idParaDest-157" class="contributor"><a id="_idTextAnchor169" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To create the sample application in this chapter, you should have the following:</p>
			<ul class="calibre14">
				<li class="calibre17">Node.js version 18.17 or later</li>
				<li class="calibre17">Python 3.11.7 for running the backend from the previous chapter (either locally or from a deployment, such as Render)</li>
			</ul>
			<p class="calibre5">The requirements are identical to those in the previous chapters, and the new packages you will install will be described as they are introduced.</p>
			<h1 id="_idParaDest-158" class="contributor"><a id="_idTextAnchor170" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Introduction to Next.js</h1>
			<p class="calibre5">Next.js 14 is the latest version of the popular React-based framework for creating full-stack and production-ready web applications.</p>
			<p class="calibre5">Next.js goes as far as providing even the possibility of creating the backend server through a new Next.js feature named <strong class="bold">Route Handlers</strong> (<a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/routing/route-handlers</a>). This feature provides functions that allow you to create custom HTTP request handlers and create full-fledged APIs by using the Web Request and Response APIs.</p>
			<p class="calibre5">These route handlers expose HTTP methods similarly to FastAPI (<code>GET</code>, <code>POST</code>, and so on) and allow building complex APIs that support middleware, caching, dynamic functions, setting and getting cookies and headers, and much more.</p>
			<p class="calibre5">In the next few sections, you’ll be able to plug in your own, Python-based server and have that server run independently, maybe serving other applications simultaneously (a mobile application, for instance). You will be able to unleash the power of Python’s ecosystem for integrating some data science or AI libraries and work quickly to have a great developer experience with Python.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more detailed instructions on a particular topic, you can refer to the following website: <a href="https://nextjs.org/docs" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs</a>.</p>
			<h1 id="_idParaDest-159" class="contributor"><a id="_idTextAnchor171" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating a Next.js 14 project</h1>
			<p class="calibre5">In this project-oriented section, you will learn how to create and deploy your project using your React knowledge. You will create a brand new Next.js app by performing a series of simple steps. The project will use Tailwind CSS (integrated into Next.js) and JavaScript instead of TypeScript.</p>
			<p class="calibre5">The frontend that you will be building in this chapter requires a running backend—from the previous chapter. It can run either on your local machine or, in case you performed the deployment, from <strong class="bold">Render</strong>.com. During development, running the background from the previous chapter locally in a separate terminal will be easier and faster, with the virtual environment activated.</p>
			<p class="calibre5">To create a brand new Next.js project and set it up the way we have specified (JavaScript instead of Typescript, the new App Router, and so on), perform the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the terminal in the folder of your choice and enter the following command:<pre class="source-code">
npx create-next-app@latest</pre><p class="list-inset">The prompt will ask you if you wish to install the latest <code>create-next-app</code> package, which at the time of writing is <em class="italic">version 14.2.4</em>. Confirm the installation.</p><p class="list-inset">After the installation of the <code>create-next-app</code> package and starting it with the previous command, the CLI tool will pose a series of questions (<a href="https://nextjs.org/docs/getting-started/installation" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/getting-started/installation</a>). For your project, you should choose the following:</p><ul class="calibre19"><li class="calibre15">What is your project named?  <code>src/</code> directory?  <code>@/*</code>)?  <code>cd</code> <code>FARM</code> command and run the development server:<pre class="source-code">
npm run dev</pre><p class="list-inset">The CLI will inform you that the server is running on the URL <code>http://127.0.0.1:3000</code>. If you visit this page in your browser, the first render of the page could be a bit delayed, which is normal, because Next.js would be compiling the first and currently only page.</p></li>				<li class="calibre15">The page currently displays a lot of Next.js-specific styles, so to start with a clean slate, open the only automatically defined page in <code>/src/app/page.js</code> and make it an empty React component (you can use the <code>rafce</code> shortcut from the React Snippets extension):<pre class="source-code">
const Home = () =&gt; {
  return (
    &lt;div&gt;Home&lt;/div&gt;
  )
}
export default Home</pre></li>				<li class="calibre15">Also, delete the Next-specific styles from the <code>/src/app/globals.css</code> file and leave just the three Tailwind imports at the top:<pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre></li>			</ol>
			<p class="calibre5">Now you have a blank Next.js application running, and you are ready to define the application pages. Next.js uses a different type of routing system than React Router. In the next section, you will learn how to use the most important features of the Next.js framework as you need them. Before proceeding, you will briefly observe the Next.js project structure and get acquainted with the main folders and files in the next section.</p>
			<h2 id="_idParaDest-160" class="about-the-author"><a id="_idTextAnchor172" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Next.js project structure</h2>
			<p class="calibre5">While the documentation goes into great detail explaining each file and folder’s function (<a href="https://nextjs.org/docs/getting-started/project-structure" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/getting-started/project-structure</a>), it is good to know where you started. The <code>/app</code> folder is the center of the application. Its structure will determine the application routing that will be covered in the following section.</p>
			<p class="calibre5">The most important files and folders that define a Next.js project structure are the following:</p>
			<ul class="calibre14">
				<li class="calibre17">The <code>/public</code> folder in the root project directory can be used for serving static files, and they are referenced by the base URL.</li>
				<li class="calibre17">The <code>next.config.js</code> file is a Node.js module used for configuring your Next.js application—prefixing assets, <code>gzip</code> compression, managing custom headers, allowing remote image hosts, logging, and much more can be configured from this file (<a href="https://nextjs.org/docs/app/api-reference/next-config-js" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/api-reference/next-config-js</a>).</li>
				<li class="calibre17">The <code>globals.css</code> file is the global CSS style imported into every route. In your application, you are keeping it minimal and importing only the Tailwind directives.</li>
				<li class="calibre17">Optionally, you can create a <code>middleware.js</code> function that will contain middleware that will be applied on every or only selected requests. See the documentation on middleware to learn more: <a href="https://nextjs.org/docs/app/building-your-application/routing/middleware" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/routing/middleware</a></li>
				<li class="calibre17">Optionally, you can create a <code>/components</code> directory outside the <code>/app</code> folder (which has the special routing role) and create your React components inside it.</li>
			</ul>
			<p class="calibre5">Now that you’ve gone through the brief project structure, you will create the pages for your application and learn the basics of the Next.js App Router along the way. You will keep styling intentionally to a minimum in order to showcase the functionalities and component boundaries.</p>
			<h2 id="_idParaDest-161" class="about-the-author"><a id="_idTextAnchor173" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Routing with Next.js 14</h2>
			<p class="calibre5">The latest and recommended routing system in Next.js relies on the <code>src/App</code> folder—generally, every URL has a corresponding folder with the appropriate name and a <code>page.js</code> file inside of it. This structure allows you to even replace the <code>page.js</code> file with a <code>route.js</code> file, which is then treated as an API endpoint. You will create a simple route handler for demonstration purposes, but you will not use route handlers in the project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A detailed introduction to the App Router is available on the Next.js documentation website (<a href="https://nextjs.org/docs/pages/building-your-application/routing" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/pages/building-your-application/routing</a>).</p>
			<p class="calibre5">You will now build the basic page structure: a home page, a page for displaying all the cars as well as an individual car, a private page for inserting new cars (for authorized users only), and a login page.</p>
			<h3 class="calibre8">Creating the pages structure with the App Router</h3>
			<p class="calibre5">You already have a <code>page.js</code> file in the root of the <code>App</code> directory; it maps to the <code>/root</code> URL of the website.</p>
			<p class="calibre5">Now, you will build the routes for the remaining pages:</p>
			<ol class="calibre14">
				<li class="calibre15">To create a route for displaying the cars (at <code>/cars</code> in the URL), create a new folder and name it <code>cars</code> in the <code>/app</code> directory, with a simple <code>page.js</code> file inside (the name <code>page.js</code> is mandatory):<pre class="source-code">
const Cars = () =&gt; {
    return (
        &lt;div&gt;Cars&lt;/div&gt;
    )
}
export default Cars</pre></li>				<li class="calibre15">While inside the <code>/src/app/cars</code> directory, create a nested folder for displaying the individual cars based on the ID of the car. Create another folder inside the <code>cars</code> directory and name it <code>[id]</code>. This will tell the router that the route should map to <code>/cars/someID</code>. The <code>/cars/</code> part is based on the fact that the folder is inside the <code>/cars</code> directory, while the brackets syntax notifies Next.js of the presence of a dynamic parameter (<code>id</code>, in this case). Inside the <code>[id]</code> folder create a <code>page.js</code> file and name the component inside <code>CarDetails</code>.</li>
				<li class="calibre15">Repeat the same procedure and create a <code>/app/login/page.js</code> file and a <code>/app/private/page.js</code> file with the corresponding file structure. Run the <code>rafce</code> command and create a simple component corresponding to each page.</li>
			</ol>
			<p class="calibre5">Now, you have the defined pages, and you can test their functionality by manually visiting the various URLs: <code>/</code>, <code>/cars</code>, <code>/private</code>, and <code>/login</code>.</p>
			<p class="calibre5">This is a good moment to compare the App Router to other solutions that we used in the previous chapters—namely, React Router.</p>
			<h3 class="calibre8">Layouts in Next.js</h3>
			<p class="calibre5">Similar to React Router and its <code>Slot</code> component, the Next.js App Router provides a powerful <code>Layout</code> component that blends into the directory structure concept. <code>Layout</code> is a user interface that is shared among routes; it preserves state, remains interactive, and does not re-render. Instead of a <code>Slot</code> component used in React Router, the Next.js layout accepts a <code>children</code> prop that will render inside the base page—practically the entire application will be loaded inside this layout component.</p>
			<p class="calibre5">You can inspect the mandatory root layout that is used throughout the entire Next.js application and is located in <code>/app/layout.js</code>. Try adding an element inside the body and before the <code>{{children}}</code> component and inspect on which pages the element is visible—it should be visible on every page. The root layout isn’t the only layout that you can use; in fact, you can and you should create layouts for related routes that encapsulate common functionality or user interface elements.</p>
			<p class="calibre5">To create a simple layout that will be used for the cars list page and the individual cars (so it will be located inside the <code>/app/cars</code> folder), create a file named <code>layout.js</code> inside the <code>/</code><code>app/cars</code> directory:</p>
			<pre class="source-code">
const layout = ({ children }) =&gt; {
    return (
        &lt;div className="p-4 bg-slate-300 border-2
            border-black"&gt;
            &lt;h2&gt;Cars Layout&lt;/h2&gt;
            &lt;p&gt;More common cars functionality here.&lt;/p&gt;
            {children}
        &lt;/div&gt;
    )
}
export default layout</pre>			<p class="calibre5">You will notice that the layout affects the <code>/cars</code> and <code>/cars/id</code> routes, but not the other ones; it is the location of the layout file that defines when it will be loaded. This functionality enables you to create different nested routes and keep reusable UI functionality based on your application logic.</p>
			<p class="calibre5">Before moving on, there are a couple of features of the Next.js router that need to be mentioned:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>template.js</code> that wraps the entire child layout or page but does not persist across requests. It can be used, for instance, with Framer Motion to add page transitions and animations between different pages.</li>
				<li class="calibre17"><code>[… folderName]</code>. These segments will match more additional path parameters. The Next.js documentation on route segments is available at https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments.</li>
				<li class="calibre17"><strong class="bold">Route groups</strong> are useful when you want to prevent a folder from being included in the route’s URL path, while retaining the layout functionality. Route groups are documented at <a href="https://nextjs.org/docs/app/building-your-application/routing/route-groups" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/routing/route-groups</a>.</li>
			</ul>
			<p class="calibre5">After having created the necessary pages and learned about the main features of the App Router, in the next section, you will learn about Next.js components and how to leverage layouts in your application structure.</p>
			<h3 class="calibre8">Next.js components</h3>
			<p class="calibre5">One of the main new concepts of Next.js is the distinction between <code>localstorage</code>, and so on).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Next.js documentation explains the major but also the more subtle differences here: <a href="https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns</a>.</p>
			<p class="calibre5">Generally speaking, since server components can access data on the server directly, they are preferred for tasks such as data fetching and working with sensitive information (access tokens, API keys, and so on). Client components are a better fit for classic React <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>) tasks: adding interactivity, using React hooks, custom hooks that depend on the state, interfacing with the browser, geolocation, and so on.</p>
			<p class="calibre5">By default, Next.js components are <em class="italic">server</em> components. To turn them into client components, you must add the <code>"use client"</code> directive as the first line. This directive defines a boundary between a server and a client component module.</p>
			<h3 class="calibre8">Creating the navigation component</h3>
			<p class="calibre5">To begin crafting Next.js components, now you will create a simple navigation component and learn about the <code>Link</code> component in Next.js.</p>
			<p class="calibre5">To create a navigation component, implement the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a folder called <code>/src/components/</code> alongside the <code>/app</code> folder (not inside it, since these will not be user-navigable pages) and create the <code>NavBar.js</code> file inside it:<pre class="source-code">
import Link from "next/link"
const Navbar = async () =&gt; {
    return (
        &lt;nav className="flex justify-between
            items-center bg-gray-800 p-4"&gt;
            &lt;h1 className="text-white"&gt;Farm Cars&lt;/h1&gt;
            &lt;div className="flex space-x-4 text-white
                child-hover:text-yellow-400"&gt;
                &lt;Link href="/"&gt;Home&lt;/Link&gt;
                &lt;Link href="/cars"&gt;Cars&lt;/Link&gt;
                &lt;Link href="/private"&gt;Private&lt;/Link&gt;
                &lt;Link href="/login"&gt;Login&lt;/Link&gt;
            &lt;/div&gt;
        &lt;/nav&gt;
    )
}
export default Navbar</pre><p class="list-inset">The <code>NavBar.js</code> component is very similar to the ones created in previous chapters. However, here, you have imported the <code>Link</code> component—the Next.js component that extends the <code>&lt;a&gt;</code> element (the native HTML link component) and provides data pre-fetching (<a href="https://nextjs.org/docs/app/api-reference/components/link" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/api-reference/components/link</a>).</p></li>				<li class="calibre15">The previous code utilizes a Tailwind plugin that enables developers to target descendent selectors directly. To use it, open the <code>tailwind.config.js</code> file and edit the content by changing the <code>plugins</code> array value:<pre class="source-code">
  plugins: [
    function ({ addVariant }) {
      addVariant('child', '&amp; &gt; *');
      addVariant('child-hover', '&amp; &gt; *:hover');
    }
  ],</pre></li>				<li class="calibre15">Now open the root layout, located at <code>/src/app/layout.js</code>, and insert the <code>NavBar.js</code> component before the <code>children</code> props by replacing the existing <code>RootLayout</code> function with the following code:<pre class="source-code">
import Navbar from "@/components/NavBar";
...
export default function RootLayout({ children }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
<strong class="bold">        &lt;Navbar /&gt;</strong>
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</pre></li>			</ol>
			<p class="calibre5">In this step, you added the newly created component to the root layout since it will be displayed on every page.</p>
			<p class="calibre5">You now have defined the routes, scaffolded the basic pages of the application, and created a simple navigation menu. In the next section, you will see how Next.js simplifies data loading through server components.</p>
			<h2 id="_idParaDest-162" class="about-the-author"><a id="_idTextAnchor174" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Data loading with server components</h2>
			<p class="calibre5">The following process will help you learn how to load data from your FastAPI server into the <code>/cars</code> page without resorting to hooks and states, and see how Next.js extends the native fetch functionality.</p>
			<p class="calibre5">To load data from your FastAPI server into the <code>/cars</code> page without hooks, implement the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Before creating the page that should display information about all the cars that are currently present in your cars collection, create a <code>.env</code> file in the root of the Next.js project (parallel to the <code>/src</code>  folder) and use it to map the address of your API:<pre class="source-code">
API_URL=http://127.0.0.1:8000</pre><p class="list-inset">This value will have to change once you deploy and wish to use your Render.com API URL, or whatever backend deployment solution you might choose.</p></li>				<li class="calibre15">Once it has been set in the environment, the address will be available in your code:<pre class="source-code">
process.env.API_URL</pre><p class="list-inset">It is important to remember that in order to be visible in the browser, the environment variables need to be prepended by the <code>NEXT_PUBLIC_</code> string. In this case, however, you are doing data fetching on the server, in a server component, so it is perfectly fine to hide the API address.</p><p class="list-inset">Now you are ready to perform the first server-side fetch. Make sure that your backend server is running on the specified port <code>8000</code>.</p></li>				<li class="calibre15">Open the <code>/app/cars/page.js</code> file and edit it:<pre class="source-code">
import Link from "next/link"
const Cars = async () =&gt; {
    <strong class="bold">const data = await fetch(</strong>
<strong class="bold">        `${process.env.API_URL}/cars/`, {</strong>
<strong class="bold">        next: {</strong>
<strong class="bold">            revalidate: 10</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<strong class="bold">    )</strong>
    const cars = await data.json()
    return (
        &lt;&gt;
            &lt;h1&gt;Cars&lt;/h1&gt;
            &lt;div&gt;
                {cars.map((car) =&gt; (
                    &lt;div key={car._id} className="m-4 bg-white p-2"&gt;
                        &lt;Link href={`/cars/${car._id}`}&gt;
                            &lt;p&gt;{car.brand} {car.make} from {car.year}&lt;/p&gt;
                        &lt;/Link&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
        &lt;/&gt;
    )
}
export default Cars</pre></li>			</ol>
			<p class="calibre5">The previous code might seem simple, but it represents a completely new paradigm in React-based development.</p>
			<p class="calibre5">You used the Next.js <code>fetch</code> function, which extends the native Web API <code>fetch</code> method and provides some additional functionalities. It is an <code>async</code> function, so the entire component is asynchronous, and the call is awaited.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This fetch functionality is explained in great detail on the Next.js website: <a href="https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating</a>.</p>
			<p class="calibre5">While providing various features such as access to headers and cookies, the <code>fetch</code> function allows granular control over caching and revalidating the received data. Revalidation in this context means the cache invalidation and re-fetching of the latest data. Your cars page might have very frequent updates, and you can set a time limit on the content. In the preceding code, the content is revalidated every 10 seconds. In some cases, it might make sense to revalidate the data after a couple of hours or even days.</p>
			<p class="calibre5">Before moving on to specialized components provided by the framework, you will learn about the <code>error.js</code> file, which is used for catching errors while staying within the boundaries of a layout and route group.</p>
			<h3 class="calibre8">Error pages in Next.js</h3>
			<p class="calibre5">To catch unexpected errors that might arise in server components and client components, and to display a fallback user interface, you can create a file called <code>error.js</code> (the name is mandatory) inside the desired folder:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a file, <code>/src/app/cars/error.js</code>, with the following simple content:<pre class="source-code">
"use client"
const error = () =&gt; {
  return (
    &lt;div className="bg-red-800 text-white p-3"&gt;
      There was an error while fetching car data!
    &lt;/div&gt;
  )
}
export default error</pre><p class="list-inset">The component must use the <code>"use client"</code> directive as per the documentation.</p></li>				<li class="calibre15">You can test the error handling page by throwing a generic error inside <code>[id]/page.js</code>:<pre class="source-code">
const SingleCar = () =&gt; {
  throw new Error('Error')
}
export default SingleCar</pre></li>			</ol>
			<p class="calibre5">If you now try to navigate to any car details page, you will see that the page is loaded—the navigation is present, and the main layout and the cars layout are rendered. Only the inside of the innermost route group, which contains the <code>error.js</code> file, displays the error message.</p>
			<p class="calibre5">After learning how to get data inside the page directly from the server, in the following section, you will create a statically generated single-car page and learn about the powerful Next.js <code>Image</code> component.</p>
			<h3 class="calibre8">Static page generation and the Image component</h3>
			<p class="calibre5">Next.js provides yet another way of generating pages—<em class="italic">static rendering</em>. In this case, pages are rendered at build time (instead of at request time), or, in case of data revalidation, in the background. The resulting page is then cached and pushed to the content delivery network, for efficient and fast serving. This makes Next.js effectively behave like a static site generator, much like Gatsby.js or Hugo, and achieve maximum performance in terms of website speed.</p>
			<p class="calibre5">However, not all routes are suitable for static rendering; pages that are personalized and contain user-specific data are examples of pages that shouldn’t be statically generated. Blog posts, documentation pages, or even car ads, however, are not pages that should display different features to different users.</p>
			<p class="calibre5">In this section, you will first generate individual car pages as server-side rendered pages, like the cars page before, and afterward, you will modify the page(s) to be statically rendered.</p>
			<p class="calibre5">Before you begin working with the <code>Image</code> component, modify the <code>next.js.mjs</code> file—the Next.js configuration file—and let Next.js know that it should allow images from an external domain—in your case, Cloudinary—since this is where our car images are hosted.</p>
			<p class="calibre5">Perform the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the <code>next.config.mjs</code> file and edit the configuration:<pre class="source-code">
/** @type {import('next').NextConfig} */
const nextConfig = {
  <strong class="bold">images: {</strong>
<strong class="bold">    remotePatterns: [</strong>
<strong class="bold">      {</strong>
<strong class="bold">        hostname: 'res.cloudinary.com',</strong>
<strong class="bold">      },</strong>
<strong class="bold">    ]</strong>
<strong class="bold">  }</strong>
};
export default nextConfig;</pre></li>				<li class="calibre15">After this modification, restart the Next.js development server manually:<pre class="source-code">
npm run dev</pre><p class="list-inset">Now you will create the server-side rendered version of the cars page.</p></li>				<li class="calibre15">Open <code>/app/cars/[id]/page.js</code> and modify it accordingly:<pre class="source-code">
import {
  redirect
} from "next/navigation"
<strong class="bold">import Image from "next/image"</strong>
const CarDetails = async ({
  params
}) =&gt; {
  const carId = params.id
  const res = await fetch(
    `${process.env.API_URL}/cars/${carId}`, {
      next: {
        revalidate: 10
      }
    }
  )
  if(!res.ok) {
    redirect("/error")
  }
  const data = await res.json()</pre><p class="list-inset">In the preceding code, you imported the <code>next/image</code> component and you destructured the parameters as <code>params</code> from the URL. Then, you performed a similar <code>fetch</code> request and checked the result status. In case of an error, you used the Next.js <code>redirect</code> function to redirect the user to the error page, which is yet to be created.</p></li>				<li class="calibre15">Now, continue editing the component and return some basic JSX:<pre class="source-code">
return (
  &lt;div className="p-4 flex flex-col justify-center
    items-center min-h-full bg-white"&gt;
    &lt;h1&gt;{data.brand} {data.make} ({data.year})&lt;/h1&gt;
    &lt;p&gt;{data.description}&lt;/p&gt;
    &lt;div className="p-2 shadow-md bg-white"&gt;
      &lt;Image src={data.picture_url}
        alt={`${data.brand} ${data.make}`}
        width={600} height={400}
        className="object-cover w-full" /&gt;
    &lt;/div&gt;
    &lt;div className="grid grid-cols-2 gap-3 my-3"&gt;
      {data.pros &amp;&amp; &lt;div className="bg-green-200
        p-5 flex flex-col justify-center
        items-center"&gt;
        &lt;h2&gt;Pros&lt;/h2&gt;
        &lt;ol className="list-decimal"&gt;
          {data.pros.map((pro, index) =&gt; (
            &lt;li key={index}&gt;{pro}&lt;/li&gt;
          ))}
        &lt;/ol&gt;
      &lt;/div&gt;}
      {data.cons &amp;&amp; &lt;div className="bg-red-200 p-5
        flex flex-col justify-center items-center"&gt;
        &lt;h2&gt;Cons&lt;/h2&gt;
        &lt;ol className="list-decimal"&gt;
          {data.cons.map((con, index) =&gt; (
            &lt;li key={index}&gt;{con}&lt;/li&gt;
          ))}
        &lt;/ol&gt;
      &lt;/div&gt;}
    &lt;/div&gt;
  &lt;/div &gt;
  )
}
export default CarDetails</pre><p class="list-inset">The rest of the functional component is rather simple. You have used the <code>Image</code> component and provided the mandatory data, such as the <code>width</code>, <code>height</code>, and <code>alt text</code>. The Image component has a rich API that is documented on the Next.js website (<a href="https://nextjs.org/docs/app/api-reference/components/image" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/api-reference/components/image</a>), and it should be used whenever possible because it vastly improves your site’s performance.</p><p class="list-inset">The <code>redirect</code> function is imported from <code>next/navigation</code> (<a href="https://nextjs.org/docs/app/building-your-application/routing/redirecting" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/routing/redirecting</a>).</p><p class="list-inset">The statically generated version of the page(s) includes providing a <code>generateStaticParams()</code> function to the page and exporting it; Next.js uses this function to know which pages to generate at build time.</p></li>				<li class="calibre15">For your <code>/app/cars/[id]/page.js</code> file, this function will need to loop over all the cars that need a static page (all cars in this case) and provide an array of IDs:<pre class="source-code">
export async function generateStaticParams() {
  const cars = await fetch(
    `${process.env.API_URL}/cars/`).then((res) =&gt;
    res.json())
  return cars.map((car) =&gt; ({id: car._id,}))
}</pre></li>			</ol>
			<p class="calibre5">If you add the preceding <code>generateStaticParams()</code> function to the component, stop the development server and run another Next.js command:</p>
			<pre class="source-code">
npm run build</pre>			<p class="calibre5">Next.js will produce an optimized build of the entire site, rendering the individual car pages at build time as static HTML pages. If you inspect the console, you will see the list of routes and a legend that shows which pages were rendered at build time.</p>
			<p class="calibre5">Running the production build is possible with the following command:</p>
			<pre class="source-code">
npm run start</pre>			<p class="calibre5">Before closing this section, let’s take care of the cases in which the user hits the wrong URL, resulting in a nonexistent car. To handle these <code>404 Page Not Found</code> errors, create a new file called <code>/src/app/not-found.js</code> and populate it:</p>
			<pre class="source-code">
import Link from "next/link"
const NotFoundPage = () =&gt; {
  return (
    &lt;div className="min-h-screen flex flex-col
      justify-center items-center"&gt;
      &lt;h1&gt;Custom Not Found Page&lt;/h1&gt;
      &lt;p&gt;take a look at &lt;Link href="/cars"
        className="text-blue-500"&gt;our cars&lt;/Link&gt;
      &lt;/p&gt;
   &lt;/div&gt;
  )
}
export default NotFoundPage</pre>			<p class="calibre5">This route will cover all the route groups, in a similar way to the <code>*</code> route in the React Router package.</p>
			<p class="calibre5">After having created the dynamic server-side and statically generated pages and exploring some of the most important features of Next.js, you will learn how to authenticate users with the existing API in the next section.</p>
			<h1 id="_idParaDest-163" class="contributor"><a id="_idTextAnchor175" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and Server Actions in Next.js</h1>
			<p class="calibre5">You have learned about quite a few Next.js features that make it stand out as the premier web framework, but the list of the most important functionalities wouldn’t be complete without a very brief introduction to <strong class="bold">Server Actions</strong>.</p>
			<p class="calibre5">Server Actions are simply asynchronous functions executed only on the server and designed to handle data fetching and mutations (through <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> methods), and they can be called through plain form submissions (the default browser form handling method), but also through event handlers (a React-y approach) or by third-party libraries such as Axios.</p>
			<p class="calibre5">The benefits of such an approach are numerous. Performance is improved because the client-side JavaScript is significantly reduced, and since the actions run only on the server, the overall security of the application is enhanced and applications can even run with JavaScript disabled, much like the old-school applications of a couple of decades ago.</p>
			<p class="calibre5">You will now create your first server action that will be used for logging users in, with the help of a package called <code>localStorage</code>: signing and encrypting cookies. The usage is quite simple, and it is documented here: <a href="https://github.com/vvo/iron-session" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://github.com/vvo/iron-session</a>.</p>
			<ol class="calibre14">
				<li class="calibre15">Install the Iron Session package with the following command:<pre class="source-code">
npm i iron-session</pre></li>				<li class="calibre15">To use the <code>iron-session</code> functionality, create a <code>sessionOptions</code> object in a file called <code>/src/lib.js</code>:<pre class="source-code">
export const sessionOptions = {
  password:
   "complex_password_at_least_32_characters_long",
  cookieName: "farmcars_session",
  cookieOptions: {
    httpOnly: true,
    secure: false,
    maxAge: 60 * 60,
  }
};</pre></li>			</ol>
			<p class="calibre5">The configuration object defines the options necessary for the cookie encryption and decryption and you should use a strong, computer-generated random password.</p>
			<p class="calibre5">The Iron Session API is very simple as the session object allows for setting and getting dictionary-like values. You will use it to set two simple values: the currently logged-in username as well as the <code>jwt</code> itself, necessary for performing calls to your FastAPI endpoints.</p>
			<p class="calibre5">Now you will begin creating the server actions needed for the application, beginning from the login action for authenticating users:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a <code>/src/actions.js</code> file and import the necessary packages:<pre class="source-code">
"use server";
import { cookies } from "next/headers"
import { getIronSession } from "iron-session"
import { sessionOptions } from "./lib"
import { redirect } from "next/navigation"
export const getSession = async () =&gt; {
  const session = await getIronSession(
    cookies(), sessionOptions)
    return session
}</pre><p class="list-inset">The previous code imports the cookies from Next.js and the <code>getIronSession()</code> function from Iron Session, as well as the <code>sessionOptions</code> class you defined earlier. You then created a simple function for getting the current session and the data within.</p></li>				<li class="calibre15">Now, in the same file, handle the login functionality:<pre class="source-code">
export const login = async (status, formData) =&gt; {
  const username = formData.get("username")
  const password = formData.get("password")
  const result = await fetch(
    `${process.env.API_URL}/users/login`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ username, password })
    })
  const data = await result.json()
  <strong class="bold">const session = await getSession()</strong>
  if (result.ok) {
<strong class="bold">    session.username = data.username</strong>
<strong class="bold">    session.jwt = data.token</strong>
<strong class="bold">    await session.save()</strong>
    redirect("/private")
    } else {
      session.destroy()
      return { error: data.detail }
  }
}</pre><p class="list-inset">The code is straightforward and not unlike the code you saw in the React Router and <code>localStorage</code> solution. The important parts are the ones related to the session object—if the <code>fetch</code> call returns a successful response, it means that a valid user was found, and the session is set with the username and the corresponding <code>jwt</code>. If not, the session is destroyed.</p><p class="list-inset">A redirect to the <code>/private</code> page is performed only when the user logs in and the session is successfully set.</p><p class="list-inset">Now that you have created your first Server Action, you are ready to create a Next.js client component—the login form that will be used on the login page.</p></li>				<li class="calibre15">Create a new component file, <code>/src/app/components/LoginForm.js</code>:<pre class="source-code">
"use client"
import {login} from "@/actions"
import { useFormState } from "react-dom";
const LoginForm = () =&gt; {
  const [state, formAction] = useFormState(login, {})</pre><p class="list-inset"><code>LoginForm</code> is, unlike the previously created <code>NavBar</code> component, a client component, which means that it will get rendered on the client and thus needs to begin with the <code>"use </code><code>client"</code> directive.</p><p class="list-inset">The <code>useFormState</code> hook is one of the newest additions to the React ecosystem (it is, in fact, imported from the React-Dom package, and not Next.js) and it allows you to update the state based on the form action (<a href="https://pl.react.dev/reference/react-dom/hooks/useFormState" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://pl.react.dev/reference/react-dom/hooks/useFormState</a>).</p></li>				<li class="calibre15">Continue building the <code>LoginForm</code> component:<pre class="source-code">
return (
    &lt;div className="flex flex-col items-center justify-center max-w-sm mx-auto mt-10"&gt;
        &lt;form className="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4" action={formAction}&gt;
            &lt;div className="mb-4"&gt;
                &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="username"&gt;
                    Username
                &lt;/label&gt;
                &lt;input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" id="username" name="username" type="text" placeholder="Username" required /&gt;
            &lt;/div&gt;
            &lt;div className="mb-6"&gt;
                &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="password"&gt;
                    Password
                &lt;/label&gt;
                &lt;input className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" id="password" name="password" type="password" placeholder="******************" required /&gt;
            &lt;/div&gt;
            &lt;div className="flex items-center justify-between"&gt;
                &lt;button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 w-full rounded focus:outline-none focus:shadow-outline" type="submit"&gt;
                    Sign In
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;pre&gt;{JSON.stringify(state, null, 2)}&lt;/pre&gt;
        &lt;/form&gt;
    &lt;/div &gt;
)
}
export default LoginForm</pre><p class="list-inset">This login form uses the <code>useFormState</code> hook, which provides the state—essentially the error object, and <code>formAction</code>. In the form, you are displaying the state as a stringified JSON object, but in a realistic scenario, you can access all the individual errors provided by the server (FastAPI in your case) and display them accordingly.</p></li>				<li class="calibre15">After updating the <code>/src/app/login/page.js</code> page and simply adding the <code>LoginForm</code> component, you will have the following:<pre class="source-code">
import LoginForm from "@/components/LoginForm"
const page = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;Login Page&lt;/h2&gt;
      &lt;LoginForm /&gt;
    &lt;/div&gt;
  )
}
export default page</pre></li>			</ol>
			<p class="calibre5">Now, if you try to navigate to the <code>/login</code> route and insert some invalid credentials, the error will be printed below the form in a stringified JSON format. If the credentials are valid, you should be redirected to the <code>/private</code> route, and in the <code>jwt</code>, available across the entire application.</p>
			<p class="calibre5">You have added the authentication functionality through the use of the <code>iron-session</code> package and with the Next.js Server Actions.</p>
			<p class="calibre5">In the next section, you will create a protected page that is visible only to authenticated users. Although there are different ways of protecting pages in Next.js, including the use of Next.js middleware, you are going to protect just one page with a simple session verification.</p>
			<h2 id="_idParaDest-164" class="about-the-author"><a id="_idTextAnchor176" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating protected pages</h2>
			<p class="calibre5">In this section, you will create one protected page—the page for inserting new cars into the MongoDB database collection. Use Iron Session to check the validity of the cookie and to pass the value of the logged-in user’s username and <code>jwt</code> across pages.</p>
			<p class="calibre5">You will create a protected page by verifying the data from the session. If the session is present (and includes a username and <code>jwt</code>), the user will be able to navigate to it and perform an action to create new cars through the form and an associated Server Action. If not, the user will be redirected to the login page.</p>
			<p class="calibre5">The only authenticated page that you will need in this application is the one for inserting new cars, and Iron Session makes this job very easy:</p>
			<ol class="calibre14">
				<li class="calibre15">Open <code>/src/app/private/page.js</code> and edit the file:<pre class="source-code">
import { getSession } from "@/actions"
import { redirect } from "next/navigation"
const page = async () =&gt; {
  <strong class="bold">const session = await getSession()</strong>
<strong class="bold">  if (!session?.jwt) {</strong>
<strong class="bold">    redirect("/login")</strong>
<strong class="bold">  }</strong>
  return (
    &lt;div className="p-4"&gt;
      &lt;h1&gt;Private Page&lt;/h1&gt;
      &lt;pre&gt;{JSON.stringify(session, null, 2)}&lt;/pre&gt;
    &lt;/div&gt;
  )
}
export default page</pre><p class="list-inset">The previous code uses the Iron Session object: if <code>jwt</code> in the session is present, the user is able to see the page that currently contains the session data. If the session is invalid, the user is redirected to the <code>/</code><code>login</code> page.</p></li>				<li class="calibre15">To add logout functionality with the session, add another action to the <code>/</code><code>src/actions.js</code> file:<pre class="source-code">
export const logout = async () =&gt; {
  const session = await getSession()
  session.destroy()
  redirect("/")
}</pre><p class="list-inset">This action can now be invoked from the <code>NavBar</code> component, and the session object can be used to show or hide the login and logout links accordingly.</p></li>				<li class="calibre15">To incorporate the logout functionality into the website, create a simple one-button form for logging the user out in a new <code>LogoutForm.js</code> file:<pre class="source-code">
import { logout } from "@/actions"
const LogoutForm = () =&gt; {
  return (
    &lt;form action={<strong class="bold">logout</strong>}&gt;
      &lt;button className="bg-blue-500
          hover:bg-blue-700" type="submit"&gt;
          Logout
      &lt;/button&gt;
   &lt;/form&gt;
  )
}
export default LogoutForm</pre><p class="list-inset"><code>LogoutForm</code> consists of only one button that invokes the logout action defined earlier. Let’s add it to the navigation (<code>NavBar.js</code>) component with some conditional logic.</p></li>				<li class="calibre15">Open the <code>src/components/Navbar.js</code> file and edit the navigation component:<pre class="source-code">
import Link from "next/link"
import { getSession } from "@/actions";
import LogoutForm from "./LogoutForm";</pre><p class="list-inset">After importing the <code>getSession</code> function—to track whether the user is logged in or not—and the <code>LogoutForm</code> button, you can define the component:</p><pre class="source-code">const Navbar = async () =&gt; {
  const session = await getSession()
  return (
    &lt;nav className="flex justify-between items-center
      bg-gray-800 p-4"&gt;
      &lt;h1 className="text-white"&gt;Farm Cars&lt;/h1&gt;
      &lt;div className="flex space-x-4 text-white
        child-hover:text-yellow-400"&gt;
        &lt;Link href="/"&gt;Home&lt;/Link&gt;
        &lt;Link href="/cars"&gt;Cars&lt;/Link&gt;
        &lt;Link href="/private"&gt;Private&lt;/Link&gt;
        {!session?.jwt &amp;&amp; &lt;Link
          href="/login"&gt;Login&lt;/Link&gt;}
        {session?.jwt &amp;&amp; &lt;LogoutForm /&gt;}
      &lt;/div&gt;
    &lt;/nav&gt;
  )
}
export default Navbar</pre></li>			</ol>
			<p class="calibre5">The component now keeps track of the logged user and displays conditionally the login or logout link depending on the user’s logged-in status. The private link is deliberately always visible, but you can test it out; if you are not logged in, you will not be able to visit the page and you will get redirected to the login page.</p>
			<p class="calibre5">You have now completely implemented the login functionality. There are a couple of factors to consider, starting with the duration of the cookie—set through the <code>maxAge</code> property in the file <code>/src/lib.js</code>—which should match the duration of <code>jwt</code> provided by FastAPI from the backend. The application intentionally lacks user registration functionality since the idea is to have a couple of employees—users who can be created through the API directly. As an exercise, you could write the page for registering users and using the FastAPI <code>/</code><code>users/register</code> endpoint.</p>
			<p class="calibre5">In the next section, you will finalize the application by creating a private page that’s visible only to authenticated users and will allow only salespeople to insert new cars.</p>
			<h2 id="_idParaDest-165" class="about-the-author"><a id="_idTextAnchor177" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Implementing the new car page</h2>
			<p class="calibre5">In this section, you will create the form for inserting new cars. You will not use a form validation library, since that was covered in <a href="B22406_08.xhtml#_idTextAnchor137" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 8</em></a>, <em class="italic">Building the Frontend of the Application</em>, with the Zod library. In a realistic application, the form would definitely have a similar type of validation. You will create a new Server Action for performing the POST API call and again use <code>useFormState</code>—the same pattern that you used for logging the users in.</p>
			<p class="calibre5">As the form for inserting cars contains a lot of fields (and there could be many, many more), you will start by abstracting the form field into a separate component. The implementation of the new car advert creation will be broken into the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new <code>Field</code> component in a file named <code>/src/components/InputField.js</code>:<pre class="source-code">
const InputField = ({ props }) =&gt; {
  // eslint-disable-next-line react/prop-types
  const { name, type } = props
  return (
    &lt;div className="mb-4"&gt;
      &lt;label className="block text-gray-700
        text-sm font-bold mb-2" htmlFor={name}&gt;
          {name}
      &lt;/label&gt;
      &lt;input className="shadow appearance-none
        border rounded w-full py-2 px-3
        text-gray-700 leading-tight
        focus:outline-none focus:shadow-outline"
        id={name}
        name={name}
        type={type}
        placeholder={name}
        required
        autoComplete="off"
      /&gt;
    &lt;/div&gt;
  )
}
export default InputField</pre><p class="list-inset">With <code>InputField</code> now out of the way, create <code>CarForm</code>.</p></li>				<li class="calibre15">Create a new component in the <code>/src/components/CarForm.js</code> file and begin with the imports and the array of fields that will be needed:<pre class="source-code">
"use client"
import { createCar } from "@/actions"
import { useFormState } from "react-dom"
import InputField from "./InputField"
const CarForm = () =&gt; {
  let formArray = [
    {
      name: "brand",
      type: "text"
    },
    {
      name: "make",
      type: "text"
    },
    {
      name: "year",
      type: "number"
    },
    {
      name: "price",
      type: "number"
    },
    {
      name: "km",
      type: "number"
    },
    {
      name: "cm3",
      type: "number"
    },
    {
      name: "picture",
      type: "file"
    }
  ]</pre><p class="list-inset">The component uses the <code>useFormState</code> hook; you already know that it needs to be a client component.</p></li>				<li class="calibre15">The rest of the component is just a mapping over the <code>fields</code> array and the implementation of the hook:<pre class="source-code">
const [state, formAction] = useFormState(
  <strong class="bold">createCar</strong>, {})
  return (
    &lt;div className="flex items-center justify-center"&gt;
      &lt;pre&gt;{JSON.stringify(state, null, 2)}&lt;/pre&gt;
        &lt;div className="w-full max-w-xs"&gt;
          &lt;form className="bg-white shadow-md rounded
            px-8 pt-6 pb-8 mb-4"
            action={formAction}&gt;
              &lt;h2 className="text-center text-2xl
                font-bold mb-6"&gt;Insert new car
              &lt;/h2&gt;
              {formArray.map((item, index) =&gt; (
              &lt;InputField key={index}
                props={{
                name: item.name, type: item.type
                }} /&gt;
               ))}
               &lt;div className="flex items-center
                 justify-between"&gt;
                 &lt;button className="bg-gray-900
                   hover:bg-gray-700 text-white w-full
                   font-bold py-2 px-4 rounded
                   focus:outline-none
                   focus:shadow-outline"
                   type="submit"&gt;Save new car
                 &lt;/button&gt;
               &lt;/div&gt;
             &lt;/form&gt;
           &lt;/div&gt;
         &lt;/div&gt;
       )
  }
export default CarForm</pre><p class="list-inset">The form uses the <code>createCar</code> action that you will be defining in the <code>actions.js</code> file in a future step.</p></li>				<li class="calibre15">The form needs to be displayed on the private page, so edit the <code>/</code><code>src/app/private/page.js</code> file:<pre class="source-code">
import <strong class="bold">CarForm</strong> from "@/components/CarForm"
import {getSession} from "@/actions"
import { redirect } from "next/navigation"
const page = async () =&gt; {
  const session = await getSession()
  if (!session?.jwt) {
    redirect("/login")
    }
  return (
    &lt;div className="p-4"&gt;
      &lt;h1&gt;Private Page&lt;/h1&gt;
<strong class="bold">      &lt;CarForm /&gt;</strong>
    &lt;/div&gt;
  )
}
export default page</pre><p class="list-inset">The form is created, and it is displayed on the <code>/private</code> page. The only thing that is missing is the corresponding action, which you will create in the next step.</p></li>				<li class="calibre15">Open the <code>/src/actions.js</code> file and add the following action to the end of the file for creating a new car:<pre class="source-code">
export const createCar = async (state, formData) =&gt; {
  const session = await getSession()
  const jwt = session.jwt
  const result = await fetch(`${
    process.env.API_URL}/cars/`,
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${jwt}`,
        },
        body: formData
    })
    const data = await result.json()
    if (result.ok) {
      redirect("/")
    } else {
      return { error: data.detail }
    }
}</pre></li>			</ol>
			<p class="calibre5">The action is straightforward—that is the beauty of Server Actions. It is just a function that checks the session and <code>jwt</code> and performs the <code>API POST</code> request. The function should also include an earlier redirect to the login page in case <code>jwt</code> is not found, but this way, you let the <code>useFormState</code> hook display any errors coming from the backend.</p>
			<p class="calibre5">You have implemented the website specification—users are able to log in and insert new cars and, after the period of revalidation (15-20 seconds), the cars are displayed on the <code>/car</code> page as well as on the dedicated page for the newly inserted car.</p>
			<p class="calibre5">In the next section, you will deploy your application to Netlify and learn how to streamline the process, while providing environment variables and configuring settings for a deployment.</p>
			<h2 id="_idParaDest-166" class="about-the-author"><a id="_idTextAnchor178" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Providing metadata</h2>
			<p class="calibre5">One of the main features of Next.js is the ability to provide better <strong class="bold">search engine optimization</strong> (<strong class="bold">SEO</strong>) than SPAs. While generating static content that is easily picked up by crawlers is important, providing useful page metadata is essential.</p>
			<p class="calibre5">Metadata is an important feature of every web application or site, and Next.js solves this problem in an elegant way with the <code>Metadata</code> component. Metadata enables direct communication with search engines (such as Google), providing precise information about the site’s content, title, and description, as well as page-specific information.</p>
			<p class="calibre5">In this brief section, you will learn how to set the title tags of pages. The Next.js documentation is very detailed (<a href="https://nextjs.org/docs/app/building-your-application/optimizing/metadata" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://nextjs.org/docs/app/building-your-application/optimizing/metadata</a>) and explains the various pieces of information that can be set, but in this case, you are only going to set the page titles:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the <code>src/app/layout.js</code> page and edit the <code>metadata</code> part:<pre class="source-code">
export const metadata = {
  title: "Farm Cars App",
  description: "Next.js + FastAPI + MongoDB App",
};</pre><p class="list-inset">This simple change will cause all the pages within the layout to have the newly set title and description. Since you have edited the <code>Root</code> layout, which encloses all the pages, this means that every page on the website will be affected. These can be overridden on a per-page basis.</p></li>				<li class="calibre15">Open <code>/src/app/cars/[id]/page.js</code> for the individual cars page and add the following export:<pre class="source-code">
export async function generateMetadata({ params }, parent) {
    const carId = params.id
    const car = await fetch(`${process.env.API_URL}/cars/${carId}`).then((res) =&gt; res.json())
    const title = `FARM Cars App - ${car.brand} ${car.make} (${car.year})`
    return { title }
}</pre></li>			</ol>
			<p class="calibre5">The preceding export signals to Next.js that only these pages should have the title that is returned from the function, while the other pages will have the unaltered title.</p>
			<p class="calibre5">You have successfully edited the pages’ metadata, and now it is time to deploy the application on the internet, which the next section will detail.</p>
			<h1 id="_idParaDest-167" class="contributor"><a id="_idTextAnchor179" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Deployment on Netlify</h1>
			<p class="calibre5">Next.js is arguably the most popular full-stack and frontend framework, and there is a plethora of deployment options.</p>
			<p class="calibre5">In this section, you will learn how to deploy your Next.js application on Netlify—one of the most popular web platforms for deployment, content orchestration, continuous integration, and much more.</p>
			<p class="calibre5">In order to deploy your website on Netlify, you will need to deploy the FastAPI backend. If you haven’t already done so, please refer to <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 7</em></a>,<em class="italic"> Building a Backend with FastAPI</em>, on how to do that. Once you have the backend address (in your example, the URL of the deployed FastAPI application is <a href="https://chapter9backend2ed.onrender.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://chapter9backend2ed.onrender.com</a>), it will be used as the API URL for the Next.js frontend.</p>
			<p class="calibre5">In order to perform the deployment to Netlify, perform the following steps:</p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Create a Netlify account</strong>: Log in with your GitHub account and create a free Netlify account, since Netlify will pick your code from the repository that you will make for the Next.js app.</li>
				<li class="calibre17"><strong class="bold">Create a GitHub repository</strong>: In order to be able to deploy to Netlify (or Vercel for that matter), you will need to create a GitHub repository for your Next.js project.</li>
			</ul>
			<p class="calibre5">To create a GitHub repository, implement the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">In your terminal, enter the project folder and type the following:<pre class="source-code">
git add .</pre><p class="list-inset">This command adds the modified and newly created files to the repository.</p></li>				<li class="calibre15">Next, commit the changes:<pre class="source-code">
git commit -m "Next.js project"</pre></li>				<li class="calibre15">Now that your project is under version control, create a new repository in your GitHub account and choose an appropriate name. In your case, the repository is named <code>chapter10frontend</code>.</li>
			</ol>
			<h2 id="_idParaDest-168" class="about-the-author"><a id="_idTextAnchor180" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pushing the changes to GitHub</h2>
			<p class="calibre5">Now you can add the new origin to your local repository. In the same terminal inside the project, type the following commands:</p>
			<ol class="calibre14">
				<li class="calibre15">First, set the name of the branch to <code>main</code>:<pre class="source-code">
git branch -M main</pre></li>				<li class="calibre15">Then, set the origin to the newly created repository:<pre class="source-code">
git remote add origin https://github.com/&lt;your username&gt;/&lt;name_of_the_repo&gt;.git</pre><p class="list-inset">Here, you need to replace the name of the repository and your username: <code>(&lt;username&gt;</code> and <code>&lt;name_of_the_repo&gt;</code>).</p></li>				<li class="calibre15">Finally, push the project to GitHub:<pre class="source-code">
git push -u origin main</pre></li>			</ol>
			<p class="calibre5">Now, you can deploy the repository on Netlify in the following manner:</p>
			<ol class="calibre14">
				<li class="calibre15"><code>chapter10frontend</code> in your case).</li>
				<li class="calibre15"><code>main</code> as that is your only branch</li><li class="calibre15">Base directory: Leave empty</li><li class="calibre15">Build command: Leave it as <code>npm </code><code>run build</code></li><li class="calibre15">Publish directory: Leave it as <code>.next</code></li><li class="calibre15">Set the only environment variable: Click the <code>API_URL</code> and the value will be the FastAPI backend URL. If you followed the steps from the previous chapter to host your backend on Render, the value will be <a href="https://chapter9backend2ed.onrender.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://chapter9backend2ed.onrender.com</a>.</li></ol></li>
				<li class="calibre15">Hit the <strong class="bold">Deploy</strong> (<strong class="bold">&lt;name of your </strong><strong class="bold">repo&gt;</strong>) button!</li>
			</ol>
			<p class="calibre5">After a while, you should have your website deployed to the address indicated on the page. Bear in mind, however, that the API must be working, and since the free tier of Render.com, for instance (if you used Render as your backend deployment option), can take up to a minute to wake up after going stale, be prepared to wake up the API. The recommendation is to wait until the backend is responsive—you can check it by simply visiting the API address—and then begin the deployment process. This way, you will prevent potential deployment and page generation errors.</p>
			<p class="calibre5">This is a good moment to analyze the command that you provided to Netlify to build the site—the <code>build</code> command. If you run <code>npm run build</code> in your Next.js command line, Next.js performs a series of operations and produces an optimized build.</p>
			<p class="calibre5">These operations include code optimizations (such as minification and code splitting), the creation of a <code>.next</code> directory that contains the optimized, production-ready code, and the directory that actually gets served on the internet.</p>
			<p class="calibre5">The <code>build</code> command also generates the static pages and the route handlers. You can test the build after it successfully completes, with the following command:</p>
			<pre class="source-code">
npm run start</pre>			<p class="calibre5">You have now successfully deployed an optimized FastAPI MongoDB-powered Next.js website and you are ready to tackle a host of web development tasks with an incredibly powerful and flexible stack.</p>
			<h1 id="_idParaDest-169" class="contributor"><a id="_idTextAnchor181" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you have learned the basics of Next.js, a popular React-based full-stack framework that, coupled with FastAPI and MongoDB, allows you to build any virtually any type of web application.</p>
			<p class="calibre5">You have learned how to create a new Next.js project, how to implement routing with the new App Router, and how to fetch data with server components.</p>
			<p class="calibre5">Important Next.js concepts, such as Server Actions, form handling, and cookies were also introduced and implemented. Apart from this, you explored some of the Next.js optimizations such as the <code>Image</code> component for serving optimized images, the <code>Metadata</code> tags, and how to create a production build.</p>
			<p class="calibre5">Finally, you deployed your Next.js application on Netlify, but the underlying principles of deployment remain the same for other providers.</p>
			<p class="calibre5">Next.js is a rich and complex ecosystem in its own right, and you should consider this chapter as a starting point for your next application, which blends the best of the three worlds: FastAPI, MongoDB, and React, with the addition of external third-party services that your application might need.</p>
			<p class="calibre5">The next chapter will share some practical advice for you while working with the FARM stack, along with project ideas that can help you get started right away.</p>
		</div>
	</div>
</div>
</body></html>