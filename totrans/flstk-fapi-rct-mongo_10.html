<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><div id="_idContainer039" class="calibre4">
			<h1 id="_idParaDest-155" class="contributor"><a id="_idTextAnchor166" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor167" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>10</h1>
			<h1 id="_idParaDest-156" class="contributor"><a id="_idTextAnchor168" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Web Development with Next.js 14</h1>
			<p class="calibre5">Next.js is a React framework for building full stack web applications. While React is a library for building user interfaces (web or native), Next.js is a full-blown framework, built on React, that provides dozens of features and, most importantly, a structure for projects ranging from simple websites (like the one you are going to build in this chapter) to incredibly <span>complex applications.</span></p>
			<p class="calibre5">While React.js is an unopinionated declarative library for building UIs, as a framework, Next.js provides configurations, tooling, bundling, compiling, and much more, enabling the developer to focus solely on building <span>the application.</span></p>
			<p class="calibre5">This chapter will cover the <span>following topics:</span></p>
			<ul class="calibre14">
				<li class="calibre17">How to create a Next.js project and <span>deploy it</span></li>
				<li class="calibre17">The newest Next.js App Router and <span>its features</span></li>
				<li class="calibre17">The different types of page rendering: dynamic, <span>server-side, static</span></li>
				<li class="calibre17">Next.js useful tools: the <strong class="source-inline">Image</strong> component and the <span><strong class="source-inline">Head</strong></span><span> component</span></li>
				<li class="calibre17">Server Actions along with <span>cookie-based authentication</span></li>
			</ul>
			<h1 id="_idParaDest-157" class="contributor"><a id="_idTextAnchor169" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">To create the sample application in this chapter, you should have <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Node.js version 18.17 <span>or later</span></li>
				<li class="calibre17">Python 3.11.7 for running the backend from the previous chapter (either locally or from a deployment, such <span>as Render)</span></li>
			</ul>
			<p class="calibre5">The requirements are identical to those in the previous chapters, and the new packages you will install will be described as they <span>are introduced.</span></p>
			<h1 id="_idParaDest-158" class="contributor"><a id="_idTextAnchor170" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Introduction to Next.js</h1>
			<p class="calibre5">Next.js 14 is the latest version of the popular React-based framework for creating full-stack and production-ready <span>web applications.</span></p>
			<p class="calibre5">Next.js goes as far as providing even the possibility of creating the backend server through a new Next.js feature named <strong class="bold">Route Handlers</strong> (<a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://nextjs.org/docs/app/building-your-application/routing/route-handlers</span></a>). This feature provides functions that allow you to create custom HTTP request handlers and create full-fledged APIs by using the Web Request and <span>Response APIs.</span></p>
			<p class="calibre5">These route handlers expose HTTP methods similarly to FastAPI (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and so on) and allow building complex APIs that support middleware, caching, dynamic functions, setting and getting cookies and headers, and <span>much more.</span></p>
			<p class="calibre5">In the next few sections, you’ll be able to plug in your own, Python-based server and have that server run independently, maybe serving other applications simultaneously (a mobile application, for instance). You will be able to unleash the power of Python’s ecosystem for integrating some data science or AI libraries and work quickly to have a great developer experience <span>with Python.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more detailed instructions on a particular topic, you can refer to the following website: <a href="https://nextjs.org/docs" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs</span></span></a><span>.</span></p>
			<h1 id="_idParaDest-159" class="contributor"><a id="_idTextAnchor171" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating a Next.js 14 project</h1>
			<p class="calibre5">In this project-oriented section, you will learn how to create and deploy your project using your React knowledge. You will create a brand new Next.js app by performing a series of simple steps. The project will use Tailwind CSS (integrated into Next.js) and JavaScript instead <span>of TypeScript.</span></p>
			<p class="calibre5">The frontend that you will be building in this chapter requires a running backend—from the previous chapter. It can run either on your local machine or, in case you performed the deployment, from <strong class="bold">Render</strong>.com. During development, running the background from the previous chapter locally in a separate terminal will be easier and faster, with the virtual <span>environment activated.</span></p>
			<p class="calibre5">To create a brand new Next.js project and set it up the way we have specified (JavaScript instead of Typescript, the new App Router, and so on), perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open the terminal in the folder of your choice and enter the <span>following command:</span><pre class="source-code">
npx create-next-app@latest</pre><p class="list-inset">The prompt will ask you if you wish to install the latest <strong class="source-inline">create-next-app</strong> package, which at the time of writing is <em class="italic">version 14.2.4</em>. Confirm <span>the installation.</span></p><p class="list-inset">After the installation of the <strong class="source-inline">create-next-app</strong> package and starting it with the previous command, the CLI tool will pose a series of questions (<a href="https://nextjs.org/docs/getting-started/installation" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://nextjs.org/docs/getting-started/installation</span></a>). For your project, you should choose <span>the following:</span></p><ul class="calibre19"><li class="calibre15">What is your project named?  <span><strong class="bold">farm</strong></span></li><li class="calibre15">Would you like to use TypeScript?  <span><strong class="bold">No</strong></span></li><li class="calibre15">Would you like to use ESLint?  <span><strong class="bold">Yes</strong></span></li><li class="calibre15">Would you like to use Tailwind CSS?  <span><strong class="bold">Yes</strong></span></li><li class="calibre15">Would you like to use the <strong class="source-inline">src/</strong> directory?  <span><strong class="bold">Yes</strong></span></li><li class="calibre15">Would you like to use App Router? (recommended)  <span><strong class="bold">Yes</strong></span></li><li class="calibre15">Would you like to customize the default import alias (<strong class="source-inline">@/*</strong>)?  <span><strong class="bold">No</strong></span></li></ul></li>				<li class="calibre15">Change the directory through the terminal with the <strong class="source-inline">cd</strong> <strong class="source-inline">FARM</strong> command and run the <span>development server:</span><pre class="source-code">
npm run dev</pre><p class="list-inset">The CLI will inform you that the server is running on the URL <strong class="source-inline">http://127.0.0.1:3000</strong>. If you visit this page in your browser, the first render of the page could be a bit delayed, which is normal, because Next.js would be compiling the first and currently <span>only page.</span></p></li>				<li class="calibre15">The page currently displays a lot of Next.js-specific styles, so to start with a clean slate, open the only automatically defined page in <strong class="source-inline">/src/app/page.js</strong> and make it an empty React component (you can use the <strong class="source-inline">rafce</strong> shortcut from the React <span>Snippets extension):</span><pre class="source-code">
const Home = () =&gt; {
  return (
    &lt;div&gt;Home&lt;/div&gt;
  )
}
export default Home</pre></li>				<li class="calibre15">Also, delete the Next-specific styles from the <strong class="source-inline">/src/app/globals.css</strong> file and leave just the three Tailwind imports at <span>the top:</span><pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre></li>			</ol>
			<p class="calibre5">Now you have a blank Next.js application running, and you are ready to define the application pages. Next.js uses a different type of routing system than React Router. In the next section, you will learn how to use the most important features of the Next.js framework as you need them. Before proceeding, you will briefly observe the Next.js project structure and get acquainted with the main folders and files in the <span>next section.</span></p>
			<h2 id="_idParaDest-160" class="about-the-author"><a id="_idTextAnchor172" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Next.js project structure</h2>
			<p class="calibre5">While the documentation goes into great detail explaining each file and folder’s function (<a href="https://nextjs.org/docs/getting-started/project-structure" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://nextjs.org/docs/getting-started/project-structure</span></a>), it is good to know where you started. The <strong class="source-inline">/app</strong> folder is the center of the application. Its structure will determine the application routing that will be covered in the <span>following section.</span></p>
			<p class="calibre5">The most important files and folders that define a Next.js project structure are <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17">The <strong class="source-inline">/public</strong> folder in the root project directory can be used for serving static files, and they are referenced by the <span>base URL.</span></li>
				<li class="calibre17">The <strong class="source-inline">next.config.js</strong> file is a Node.js module used for configuring your Next.js application—prefixing assets, <strong class="source-inline">gzip</strong> compression, managing custom headers, allowing remote image hosts, logging, and much more can be configured from this <span>file (</span><a href="https://nextjs.org/docs/app/api-reference/next-config-js" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/api-reference/next-config-js</span></span></a><span>).</span></li>
				<li class="calibre17">The <strong class="source-inline">globals.css</strong> file is the global CSS style imported into every route. In your application, you are keeping it minimal and importing only the <span>Tailwind directives.</span></li>
				<li class="calibre17">Optionally, you can create a <strong class="source-inline">middleware.js</strong> function that will contain middleware that will be applied on every or only selected requests. See the documentation on middleware to learn <span>more: </span><a href="https://nextjs.org/docs/app/building-your-application/routing/middleware" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/building-your-application/routing/middleware</span></span></a></li>
				<li class="calibre17">Optionally, you can create a <strong class="source-inline">/components</strong> directory outside the <strong class="source-inline">/app</strong> folder (which has the special routing role) and create your React components <span>inside it.</span></li>
			</ul>
			<p class="calibre5">Now that you’ve gone through the brief project structure, you will create the pages for your application and learn the basics of the Next.js App Router along the way. You will keep styling intentionally to a minimum in order to showcase the functionalities and <span>component boundaries.</span></p>
			<h2 id="_idParaDest-161" class="about-the-author"><a id="_idTextAnchor173" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Routing with Next.js 14</h2>
			<p class="calibre5">The latest and recommended routing system in Next.js relies on the <strong class="bold">App Router</strong>, which you chose to implement while creating the project. The App Router is based on a file structure that resides inside the <strong class="source-inline">src/App</strong> folder—generally, every URL has a corresponding folder with the appropriate name and a <strong class="source-inline">page.js</strong> file inside of it. This structure allows you to even replace the <strong class="source-inline">page.js</strong> file with a <strong class="source-inline">route.js</strong> file, which is then treated as an API endpoint. You will create a simple route handler for demonstration purposes, but you will not use route handlers in <span>the project.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A detailed introduction to the App Router is available on the Next.js documentation <span>website (</span><a href="https://nextjs.org/docs/pages/building-your-application/routing" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/pages/building-your-application/routing</span></span></a><span>).</span></p>
			<p class="calibre5">You will now build the basic page structure: a home page, a page for displaying all the cars as well as an individual car, a private page for inserting new cars (for authorized users only), and a <span>login page.</span></p>
			<h3 class="calibre8">Creating the pages structure with the App Router</h3>
			<p class="calibre5">You already have a <strong class="source-inline">page.js</strong> file in the root of the <strong class="source-inline">App</strong> directory; it maps to the <strong class="source-inline">/root</strong> URL of <span>the website.</span></p>
			<p class="calibre5">Now, you will build the routes for the <span>remaining pages:</span></p>
			<ol class="calibre14">
				<li class="calibre15">To create a route for displaying the cars (at <strong class="source-inline">/cars</strong> in the URL), create a new folder and name it <strong class="source-inline">cars</strong> in the <strong class="source-inline">/app</strong> directory, with a simple <strong class="source-inline">page.js</strong> file inside (the name <strong class="source-inline">page.js</strong> <span>is mandatory):</span><pre class="source-code">
const Cars = () =&gt; {
    return (
        &lt;div&gt;Cars&lt;/div&gt;
    )
}
export default Cars</pre></li>				<li class="calibre15">While inside the <strong class="source-inline">/src/app/cars</strong> directory, create a nested folder for displaying the individual cars based on the ID of the car. Create another folder inside the <strong class="source-inline">cars</strong> directory and name it <strong class="source-inline">[id]</strong>. This will tell the router that the route should map to <strong class="source-inline">/cars/someID</strong>. The <strong class="source-inline">/cars/</strong> part is based on the fact that the folder is inside the <strong class="source-inline">/cars</strong> directory, while the brackets syntax notifies Next.js of the presence of a dynamic parameter (<strong class="source-inline">id</strong>, in this case). Inside the <strong class="source-inline">[id]</strong> folder create a <strong class="source-inline">page.js</strong> file and name the component <span>inside </span><span><strong class="source-inline">CarDetails</strong></span><span>.</span></li>
				<li class="calibre15">Repeat the same procedure and create a <strong class="source-inline">/app/login/page.js</strong> file and a <strong class="source-inline">/app/private/page.js</strong> file with the corresponding file structure. Run the <strong class="source-inline">rafce</strong> command and create a simple component corresponding to <span>each page.</span></li>
			</ol>
			<p class="calibre5">Now, you have the defined pages, and you can test their functionality by manually visiting the various URLs: <strong class="source-inline">/</strong>, <strong class="source-inline">/cars</strong>, <strong class="source-inline">/private</strong>, <span>and </span><span><strong class="source-inline">/login</strong></span><span>.</span></p>
			<p class="calibre5">This is a good moment to compare the App Router to other solutions that we used in the previous chapters—namely, <span>React Router.</span></p>
			<h3 class="calibre8">Layouts in Next.js</h3>
			<p class="calibre5">Similar to React Router and its <strong class="source-inline">Slot</strong> component, the Next.js App Router provides a powerful <strong class="source-inline">Layout</strong> component that blends into the directory structure concept. <strong class="source-inline">Layout</strong> is a user interface that is shared among routes; it preserves state, remains interactive, and does not re-render. Instead of a <strong class="source-inline">Slot</strong> component used in React Router, the Next.js layout accepts a <strong class="source-inline">children</strong> prop that will render inside the base page—practically the entire application will be loaded inside this <span>layout component.</span></p>
			<p class="calibre5">You can inspect the mandatory root layout that is used throughout the entire Next.js application and is located in <strong class="source-inline">/app/layout.js</strong>. Try adding an element inside the body and before the <strong class="source-inline">{{children}}</strong> component and inspect on which pages the element is visible—it should be visible on every page. The root layout isn’t the only layout that you can use; in fact, you can and you should create layouts for related routes that encapsulate common functionality or user <span>interface elements.</span></p>
			<p class="calibre5">To create a simple layout that will be used for the cars list page and the individual cars (so it will be located inside the <strong class="source-inline">/app/cars</strong> folder), create a file named <strong class="source-inline">layout.js</strong> inside the <strong class="source-inline">/</strong><span><strong class="source-inline">app/cars</strong></span><span> directory:</span></p>
			<pre class="source-code">
const layout = ({ children }) =&gt; {
    return (
        &lt;div className="p-4 bg-slate-300 border-2
            border-black"&gt;
            &lt;h2&gt;Cars Layout&lt;/h2&gt;
            &lt;p&gt;More common cars functionality here.&lt;/p&gt;
            {children}
        &lt;/div&gt;
    )
}
export default layout</pre>			<p class="calibre5">You will notice that the layout affects the <strong class="source-inline">/cars</strong> and <strong class="source-inline">/cars/id</strong> routes, but not the other ones; it is the location of the layout file that defines when it will be loaded. This functionality enables you to create different nested routes and keep reusable UI functionality based on your <span>application logic.</span></p>
			<p class="calibre5">Before moving on, there are a couple of features of the Next.js router that need to <span>be mentioned:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Templates</strong> are defined with a file named <strong class="source-inline">template.js</strong> that wraps the entire child layout or page but does not persist across requests. It can be used, for instance, with Framer Motion to add page transitions and animations between <span>different pages.</span></li>
				<li class="calibre17"><strong class="bold">Catch-all segments</strong> are routes defined with an ellipsis inside the brackets, such as <strong class="source-inline">[… folderName]</strong>. These segments will match more additional path parameters. The Next.js documentation on route segments is available <span>at </span><span><span>https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments</span></span><span>.</span></li>
				<li class="calibre17"><strong class="bold">Route groups</strong> are useful when you want to prevent a folder from being included in the route’s URL path, while retaining the layout functionality. Route groups are documented <span>at </span><a href="https://nextjs.org/docs/app/building-your-application/routing/route-groups" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/building-your-application/routing/route-groups</span></span></a><span>.</span></li>
			</ul>
			<p class="calibre5">After having created the necessary pages and learned about the main features of the App Router, in the next section, you will learn about Next.js components and how to leverage layouts in your <span>application structure.</span></p>
			<h3 class="calibre8">Next.js components</h3>
			<p class="calibre5">One of the main new concepts of Next.js is the distinction between <strong class="bold">server</strong> and <strong class="bold">client</strong> components. The most important difference is that <em class="italic">server components</em> allow you to create user interfaces that will be rendered and cached on the server, while <em class="italic">client components</em> can be prerendered on the server and then can use client JavaScript code for browser and user interactivity (React Hooks, browser APIs such as <strong class="source-inline">localstorage</strong>, and <span>so on).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Next.js documentation explains the major but also the more subtle differences here: <a href="https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns</span></span></a><span>.</span></p>
			<p class="calibre5">Generally speaking, since server components can access data on the server directly, they are preferred for tasks such as data fetching and working with sensitive information (access tokens, API keys, and so on). Client components are a better fit for classic React <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>) tasks: adding interactivity, using React hooks, custom hooks that depend on the state, interfacing with the browser, geolocation, and <span>so on.</span></p>
			<p class="calibre5">By default, Next.js components are <em class="italic">server</em> components. To turn them into client components, you must add the <strong class="source-inline">"use client"</strong> directive as the first line. This directive defines a boundary between a server and a client <span>component module.</span></p>
			<h3 class="calibre8">Creating the navigation component</h3>
			<p class="calibre5">To begin crafting Next.js components, now you will create a simple navigation component and learn about the <strong class="source-inline">Link</strong> component <span>in Next.js.</span></p>
			<p class="calibre5">To create a navigation component, implement the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a folder called <strong class="source-inline">/src/components/</strong> alongside the <strong class="source-inline">/app</strong> folder (not inside it, since these will not be user-navigable pages) and create the <strong class="source-inline">NavBar.js</strong> file <span>inside it:</span><pre class="source-code">
import Link from "next/link"
const Navbar = async () =&gt; {
    return (
        &lt;nav className="flex justify-between
            items-center bg-gray-800 p-4"&gt;
            &lt;h1 className="text-white"&gt;Farm Cars&lt;/h1&gt;
            &lt;div className="flex space-x-4 text-white
                child-hover:text-yellow-400"&gt;
                &lt;Link href="/"&gt;Home&lt;/Link&gt;
                &lt;Link href="/cars"&gt;Cars&lt;/Link&gt;
                &lt;Link href="/private"&gt;Private&lt;/Link&gt;
                &lt;Link href="/login"&gt;Login&lt;/Link&gt;
            &lt;/div&gt;
        &lt;/nav&gt;
    )
}
export default Navbar</pre><p class="list-inset">The <strong class="source-inline">NavBar.js</strong> component is very similar to the ones created in previous chapters. However, here, you have imported the <strong class="source-inline">Link</strong> component—the Next.js component that extends the <strong class="source-inline">&lt;a&gt;</strong> element (the native HTML link component) and provides data <span>pre-fetching (</span><a href="https://nextjs.org/docs/app/api-reference/components/link" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/api-reference/components/link</span></span></a><span>).</span></p></li>				<li class="calibre15">The previous code utilizes a Tailwind plugin that enables developers to target descendent selectors directly. To use it, open the <strong class="source-inline">tailwind.config.js</strong> file and edit the content by changing the <strong class="source-inline">plugins</strong> <span>array value:</span><pre class="source-code">
  plugins: [
    function ({ addVariant }) {
      addVariant('child', '&amp; &gt; *');
      addVariant('child-hover', '&amp; &gt; *:hover');
    }
  ],</pre></li>				<li class="calibre15">Now open the root layout, located at <strong class="source-inline">/src/app/layout.js</strong>, and insert the <strong class="source-inline">NavBar.js</strong> component before the <strong class="source-inline">children</strong> props by replacing the existing <strong class="source-inline">RootLayout</strong> function with the <span>following code:</span><pre class="source-code">
import Navbar from "@/components/NavBar";
...
export default function RootLayout({ children }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
<strong class="bold">        &lt;Navbar /&gt;</strong>
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</pre></li>			</ol>
			<p class="calibre5">In this step, you added the newly created component to the root layout since it will be displayed on <span>every page.</span></p>
			<p class="calibre5">You now have defined the routes, scaffolded the basic pages of the application, and created a simple navigation menu. In the next section, you will see how Next.js simplifies data loading through <span>server components.</span></p>
			<h2 id="_idParaDest-162" class="about-the-author"><a id="_idTextAnchor174" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Data loading with server components</h2>
			<p class="calibre5">The following process will help you learn how to load data from your FastAPI server into the <strong class="source-inline">/cars</strong> page without resorting to hooks and states, and see how Next.js extends the native <span>fetch functionality.</span></p>
			<p class="calibre5">To load data from your FastAPI server into the <strong class="source-inline">/cars</strong> page without hooks, implement the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Before creating the page that should display information about all the cars that are currently present in your cars collection, create a <strong class="source-inline">.env</strong> file in the root of the Next.js project (parallel to the <strong class="source-inline">/src</strong>  folder) and use it to map the address of <span>your API:</span><pre class="source-code">
API_URL=http://127.0.0.1:8000</pre><p class="list-inset">This value will have to change once you deploy and wish to use your Render.com API URL, or whatever backend deployment solution you <span>might choose.</span></p></li>				<li class="calibre15">Once it has been set in the environment, the address will be available in <span>your code:</span><pre class="source-code">
process.env.API_URL</pre><p class="list-inset">It is important to remember that in order to be visible in the browser, the environment variables need to be prepended by the <strong class="source-inline">NEXT_PUBLIC_</strong> string. In this case, however, you are doing data fetching on the server, in a server component, so it is perfectly fine to hide the <span>API address.</span></p><p class="list-inset">Now you are ready to perform the first server-side fetch. Make sure that your backend server is running on the specified <span>port </span><span><strong class="source-inline">8000</strong></span><span>.</span></p></li>				<li class="calibre15">Open the <strong class="source-inline">/app/cars/page.js</strong> file and <span>edit it:</span><pre class="source-code">
import Link from "next/link"
const Cars = async () =&gt; {
    <strong class="bold">const data = await fetch(</strong>
<strong class="bold">        `${process.env.API_URL}/cars/`, {</strong>
<strong class="bold">        next: {</strong>
<strong class="bold">            revalidate: 10</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<strong class="bold">    )</strong>
    const cars = await data.json()
    return (
        &lt;&gt;
            &lt;h1&gt;Cars&lt;/h1&gt;
            &lt;div&gt;
                {cars.map((car) =&gt; (
                    &lt;div key={car._id} className="m-4 bg-white p-2"&gt;
                        &lt;Link href={`/cars/${car._id}`}&gt;
                            &lt;p&gt;{car.brand} {car.make} from {car.year}&lt;/p&gt;
                        &lt;/Link&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
        &lt;/&gt;
    )
}
export default Cars</pre></li>			</ol>
			<p class="calibre5">The previous code might seem simple, but it represents a completely new paradigm in React-based <span>development.</span></p>
			<p class="calibre5">You used the Next.js <strong class="source-inline">fetch</strong> function, which extends the native Web API <strong class="source-inline">fetch</strong> method and provides some additional functionalities. It is an <strong class="source-inline">async</strong> function, so the entire component is asynchronous, and the call <span>is awaited.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This fetch functionality is explained in great detail on the Next.js <span>website: </span><a href="https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating</span></span></a><span>.</span></p>
			<p class="calibre5">While providing various features such as access to headers and cookies, the <strong class="source-inline">fetch</strong> function allows granular control over caching and revalidating the received data. Revalidation in this context means the cache invalidation and re-fetching of the latest data. Your cars page might have very frequent updates, and you can set a time limit on the content. In the preceding code, the content is revalidated every 10 seconds. In some cases, it might make sense to revalidate the data after a couple of hours or <span>even days.</span></p>
			<p class="calibre5">Before moving on to specialized components provided by the framework, you will learn about the <strong class="source-inline">error.js</strong> file, which is used for catching errors while staying within the boundaries of a layout and <span>route group.</span></p>
			<h3 class="calibre8">Error pages in Next.js</h3>
			<p class="calibre5">To catch unexpected errors that might arise in server components and client components, and to display a fallback user interface, you can create a file called <strong class="source-inline">error.js</strong> (the name is mandatory) inside the <span>desired folder:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a file, <strong class="source-inline">/src/app/cars/error.js</strong>, with the following <span>simple content:</span><pre class="source-code">
"use client"
const error = () =&gt; {
  return (
    &lt;div className="bg-red-800 text-white p-3"&gt;
      There was an error while fetching car data!
    &lt;/div&gt;
  )
}
export default error</pre><p class="list-inset">The component must use the <strong class="source-inline">"use client"</strong> directive as per <span>the documentation.</span></p></li>				<li class="calibre15">You can test the error handling page by throwing a generic error <span>inside </span><span><strong class="source-inline">[id]/page.js</strong></span><span>:</span><pre class="source-code">
const SingleCar = () =&gt; {
  throw new Error('Error')
}
export default SingleCar</pre></li>			</ol>
			<p class="calibre5">If you now try to navigate to any car details page, you will see that the page is loaded—the navigation is present, and the main layout and the cars layout are rendered. Only the inside of the innermost route group, which contains the <strong class="source-inline">error.js</strong> file, displays the <span>error message.</span></p>
			<p class="calibre5">After learning how to get data inside the page directly from the server, in the following section, you will create a statically generated single-car page and learn about the powerful Next.js <span><strong class="source-inline">Image</strong></span><span> component.</span></p>
			<h3 class="calibre8">Static page generation and the Image component</h3>
			<p class="calibre5">Next.js provides yet another way of generating pages—<em class="italic">static rendering</em>. In this case, pages are rendered at build time (instead of at request time), or, in case of data revalidation, in the background. The resulting page is then cached and pushed to the content delivery network, for efficient and fast serving. This makes Next.js effectively behave like a static site generator, much like Gatsby.js or Hugo, and achieve maximum performance in terms of <span>website speed.</span></p>
			<p class="calibre5">However, not all routes are suitable for static rendering; pages that are personalized and contain user-specific data are examples of pages that shouldn’t be statically generated. Blog posts, documentation pages, or even car ads, however, are not pages that should display different features to <span>different users.</span></p>
			<p class="calibre5">In this section, you will first generate individual car pages as server-side rendered pages, like the cars page before, and afterward, you will modify the page(s) to be <span>statically rendered.</span></p>
			<p class="calibre5">Before you begin working with the <strong class="source-inline">Image</strong> component, modify the <strong class="source-inline">next.js.mjs</strong> file—the Next.js configuration file—and let Next.js know that it should allow images from an external domain—in your case, Cloudinary—since this is where our car images <span>are hosted.</span></p>
			<p class="calibre5">Perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open the <strong class="source-inline">next.config.mjs</strong> file and edit <span>the configuration:</span><pre class="source-code">
/** @type {import('next').NextConfig} */
const nextConfig = {
  <strong class="bold">images: {</strong>
<strong class="bold">    remotePatterns: [</strong>
<strong class="bold">      {</strong>
<strong class="bold">        hostname: 'res.cloudinary.com',</strong>
<strong class="bold">      },</strong>
<strong class="bold">    ]</strong>
<strong class="bold">  }</strong>
};
export default nextConfig;</pre></li>				<li class="calibre15">After this modification, restart the Next.js development <span>server manually:</span><pre class="source-code">
npm run dev</pre><p class="list-inset">Now you will create the server-side rendered version of the <span>cars page.</span></p></li>				<li class="calibre15">Open <strong class="source-inline">/app/cars/[id]/page.js</strong> and modify <span>it accordingly:</span><pre class="source-code">
import {
  redirect
} from "next/navigation"
<strong class="bold">import Image from "next/image"</strong>
const CarDetails = async ({
  params
}) =&gt; {
  const carId = params.id
  const res = await fetch(
    `${process.env.API_URL}/cars/${carId}`, {
      next: {
        revalidate: 10
      }
    }
  )
  if(!res.ok) {
    redirect("/error")
  }
  const data = await res.json()</pre><p class="list-inset">In the preceding code, you imported the <strong class="source-inline">next/image</strong> component and you destructured the parameters as <strong class="source-inline">params</strong> from the URL. Then, you performed a similar <strong class="source-inline">fetch</strong> request and checked the result status. In case of an error, you used the Next.js <strong class="source-inline">redirect</strong> function to redirect the user to the error page, which is yet to <span>be created.</span></p></li>				<li class="calibre15">Now, continue editing the component and return some <span>basic JSX:</span><pre class="source-code">
return (
  &lt;div className="p-4 flex flex-col justify-center
    items-center min-h-full bg-white"&gt;
    &lt;h1&gt;{data.brand} {data.make} ({data.year})&lt;/h1&gt;
    &lt;p&gt;{data.description}&lt;/p&gt;
    &lt;div className="p-2 shadow-md bg-white"&gt;
      &lt;Image src={data.picture_url}
        alt={`${data.brand} ${data.make}`}
        width={600} height={400}
        className="object-cover w-full" /&gt;
    &lt;/div&gt;
    &lt;div className="grid grid-cols-2 gap-3 my-3"&gt;
      {data.pros &amp;&amp; &lt;div className="bg-green-200
        p-5 flex flex-col justify-center
        items-center"&gt;
        &lt;h2&gt;Pros&lt;/h2&gt;
        &lt;ol className="list-decimal"&gt;
          {data.pros.map((pro, index) =&gt; (
            &lt;li key={index}&gt;{pro}&lt;/li&gt;
          ))}
        &lt;/ol&gt;
      &lt;/div&gt;}
      {data.cons &amp;&amp; &lt;div className="bg-red-200 p-5
        flex flex-col justify-center items-center"&gt;
        &lt;h2&gt;Cons&lt;/h2&gt;
        &lt;ol className="list-decimal"&gt;
          {data.cons.map((con, index) =&gt; (
            &lt;li key={index}&gt;{con}&lt;/li&gt;
          ))}
        &lt;/ol&gt;
      &lt;/div&gt;}
    &lt;/div&gt;
  &lt;/div &gt;
  )
}
export default CarDetails</pre><p class="list-inset">The rest of the functional component is rather simple. You have used the <strong class="source-inline">Image</strong> component and provided the mandatory data, such as the <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, and <strong class="source-inline">alt text</strong>. The Image component has a rich API that is documented on the Next.js website (<a href="https://nextjs.org/docs/app/api-reference/components/image" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://nextjs.org/docs/app/api-reference/components/image</span></a>), and it should be used whenever possible because it vastly improves your <span>site’s performance.</span></p><p class="list-inset">The <strong class="source-inline">redirect</strong> function is imported from <span><strong class="source-inline">next/navigation</strong></span><span> (</span><a href="https://nextjs.org/docs/app/building-your-application/routing/redirecting" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://nextjs.org/docs/app/building-your-application/routing/redirecting</span></span></a><span>).</span></p><p class="list-inset">The statically generated version of the page(s) includes providing a <strong class="source-inline">generateStaticParams()</strong> function to the page and exporting it; Next.js uses this function to know which pages to generate at <span>build time.</span></p></li>				<li class="calibre15">For your <strong class="source-inline">/app/cars/[id]/page.js</strong> file, this function will need to loop over all the cars that need a static page (all cars in this case) and provide an array <span>of IDs:</span><pre class="source-code">
export async function generateStaticParams() {
  const cars = await fetch(
    `${process.env.API_URL}/cars/`).then((res) =&gt;
    res.json())
  return cars.map((car) =&gt; ({id: car._id,}))
}</pre></li>			</ol>
			<p class="calibre5">If you add the preceding <strong class="source-inline">generateStaticParams()</strong> function to the component, stop the development server and run another <span>Next.js command:</span></p>
			<pre class="source-code">
npm run build</pre>			<p class="calibre5">Next.js will produce an optimized build of the entire site, rendering the individual car pages at build time as static HTML pages. If you inspect the console, you will see the list of routes and a legend that shows which pages were rendered at <span>build time.</span></p>
			<p class="calibre5">Running the production build is possible with the <span>following command:</span></p>
			<pre class="source-code">
npm run start</pre>			<p class="calibre5">Before closing this section, let’s take care of the cases in which the user hits the wrong URL, resulting in a nonexistent car. To handle these <strong class="source-inline">404 Page Not Found</strong> errors, create a new file called <strong class="source-inline">/src/app/not-found.js</strong> and <span>populate it:</span></p>
			<pre class="source-code">
import Link from "next/link"
const NotFoundPage = () =&gt; {
  return (
    &lt;div className="min-h-screen flex flex-col
      justify-center items-center"&gt;
      &lt;h1&gt;Custom Not Found Page&lt;/h1&gt;
      &lt;p&gt;take a look at &lt;Link href="/cars"
        className="text-blue-500"&gt;our cars&lt;/Link&gt;
      &lt;/p&gt;
   &lt;/div&gt;
  )
}
export default NotFoundPage</pre>			<p class="calibre5">This route will cover all the route groups, in a similar way to the <strong class="source-inline">*</strong> route in the React <span>Router package.</span></p>
			<p class="calibre5">After having created the dynamic server-side and statically generated pages and exploring some of the most important features of Next.js, you will learn how to authenticate users with the existing API in the <span>next section.</span></p>
			<h1 id="_idParaDest-163" class="contributor"><a id="_idTextAnchor175" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication and Server Actions in Next.js</h1>
			<p class="calibre5">You have learned about quite a few Next.js features that make it stand out as the premier web framework, but the list of the most important functionalities wouldn’t be complete without a very brief introduction to <span><strong class="bold">Server Actions</strong></span><span>.</span></p>
			<p class="calibre5">Server Actions are simply asynchronous functions executed only on the server and designed to handle data fetching and mutations (through <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> methods), and they can be called through plain form submissions (the default browser form handling method), but also through event handlers (a React-y approach) or by third-party libraries such <span>as Axios.</span></p>
			<p class="calibre5">The benefits of such an approach are numerous. Performance is improved because the client-side JavaScript is significantly reduced, and since the actions run only on the server, the overall security of the application is enhanced and applications can even run with JavaScript disabled, much like the old-school applications of a couple of <span>decades ago.</span></p>
			<p class="calibre5">You will now create your first server action that will be used for logging users in, with the help of a package called <strong class="bold">Iron Session</strong>—a stateless session utility based on cookies that takes care of all the work that you implemented earlier with <strong class="source-inline">localStorage</strong>: signing and encrypting cookies. The usage is quite simple, and it is documented <span>here: </span><a href="https://github.com/vvo/iron-session" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://github.com/vvo/iron-session</span></span></a><span>.</span></p>
			<ol class="calibre14">
				<li class="calibre15">Install the Iron Session package with the <span>following command:</span><pre class="source-code">
npm i iron-session</pre></li>				<li class="calibre15">To use the <strong class="source-inline">iron-session</strong> functionality, create a <strong class="source-inline">sessionOptions</strong> object in a file <span>called </span><span><strong class="source-inline">/src/lib.js</strong></span><span>:</span><pre class="source-code">
export const sessionOptions = {
  password:
   "complex_password_at_least_32_characters_long",
  cookieName: "farmcars_session",
  cookieOptions: {
    httpOnly: true,
    secure: false,
    maxAge: 60 * 60,
  }
};</pre></li>			</ol>
			<p class="calibre5">The configuration object defines the options necessary for the cookie encryption and decryption and you should use a strong, computer-generated <span>random password.</span></p>
			<p class="calibre5">The Iron Session API is very simple as the session object allows for setting and getting dictionary-like values. You will use it to set two simple values: the currently logged-in username as well as the <strong class="source-inline">jwt</strong> itself, necessary for performing calls to your <span>FastAPI endpoints.</span></p>
			<p class="calibre5">Now you will begin creating the server actions needed for the application, beginning from the login action for <span>authenticating users:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a <strong class="source-inline">/src/actions.js</strong> file and import the <span>necessary packages:</span><pre class="source-code">
"use server";
import { cookies } from "next/headers"
import { getIronSession } from "iron-session"
import { sessionOptions } from "./lib"
import { redirect } from "next/navigation"
export const getSession = async () =&gt; {
  const session = await getIronSession(
    cookies(), sessionOptions)
    return session
}</pre><p class="list-inset">The previous code imports the cookies from Next.js and the <strong class="source-inline">getIronSession()</strong> function from Iron Session, as well as the <strong class="source-inline">sessionOptions</strong> class you defined earlier. You then created a simple function for getting the current session and the <span>data within.</span></p></li>				<li class="calibre15">Now, in the same file, handle the <span>login functionality:</span><pre class="source-code">
export const login = async (status, formData) =&gt; {
  const username = formData.get("username")
  const password = formData.get("password")
  const result = await fetch(
    `${process.env.API_URL}/users/login`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ username, password })
    })
  const data = await result.json()
  <strong class="bold">const session = await getSession()</strong>
  if (result.ok) {
<strong class="bold">    session.username = data.username</strong>
<strong class="bold">    session.jwt = data.token</strong>
<strong class="bold">    await session.save()</strong>
    redirect("/private")
    } else {
      session.destroy()
      return { error: data.detail }
  }
}</pre><p class="list-inset">The code is straightforward and not unlike the code you saw in the React Router and <strong class="source-inline">localStorage</strong> solution. The important parts are the ones related to the session object—if the <strong class="source-inline">fetch</strong> call returns a successful response, it means that a valid user was found, and the session is set with the username and the corresponding <strong class="source-inline">jwt</strong>. If not, the session <span>is destroyed.</span></p><p class="list-inset">A redirect to the <strong class="source-inline">/private</strong> page is performed only when the user logs in and the session is <span>successfully set.</span></p><p class="list-inset">Now that you have created your first Server Action, you are ready to create a Next.js client component—the login form that will be used on the <span>login page.</span></p></li>				<li class="calibre15">Create a new component <span>file, </span><span><strong class="source-inline">/src/app/components/LoginForm.js</strong></span><span>:</span><pre class="source-code">
"use client"
import {login} from "@/actions"
import { useFormState } from "react-dom";
const LoginForm = () =&gt; {
  const [state, formAction] = useFormState(login, {})</pre><p class="list-inset"><strong class="source-inline">LoginForm</strong> is, unlike the previously created <strong class="source-inline">NavBar</strong> component, a client component, which means that it will get rendered on the client and thus needs to begin with the <strong class="source-inline">"use </strong><span><strong class="source-inline">client"</strong></span><span> directive.</span></p><p class="list-inset">The <strong class="source-inline">useFormState</strong> hook is one of the newest additions to the React ecosystem (it is, in fact, imported from the React-Dom package, and not Next.js) and it allows you to update the state based on the form <span>action (</span><a href="https://pl.react.dev/reference/react-dom/hooks/useFormState" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://pl.react.dev/reference/react-dom/hooks/useFormState</span></span></a><span>).</span></p></li>				<li class="calibre15">Continue building the <span><strong class="source-inline">LoginForm</strong></span><span> component:</span><pre class="source-code">
return (
    &lt;div className="flex flex-col items-center justify-center max-w-sm mx-auto mt-10"&gt;
        &lt;form className="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4" action={formAction}&gt;
            &lt;div className="mb-4"&gt;
                &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="username"&gt;
                    Username
                &lt;/label&gt;
                &lt;input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" id="username" name="username" type="text" placeholder="Username" required /&gt;
            &lt;/div&gt;
            &lt;div className="mb-6"&gt;
                &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="password"&gt;
                    Password
                &lt;/label&gt;
                &lt;input className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" id="password" name="password" type="password" placeholder="******************" required /&gt;
            &lt;/div&gt;
            &lt;div className="flex items-center justify-between"&gt;
                &lt;button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 w-full rounded focus:outline-none focus:shadow-outline" type="submit"&gt;
                    Sign In
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;pre&gt;{JSON.stringify(state, null, 2)}&lt;/pre&gt;
        &lt;/form&gt;
    &lt;/div &gt;
)
}
export default LoginForm</pre><p class="list-inset">This login form uses the <strong class="source-inline">useFormState</strong> hook, which provides the state—essentially the error object, and <strong class="source-inline">formAction</strong>. In the form, you are displaying the state as a stringified JSON object, but in a realistic scenario, you can access all the individual errors provided by the server (FastAPI in your case) and display <span>them accordingly.</span></p></li>				<li class="calibre15">After updating the <strong class="source-inline">/src/app/login/page.js</strong> page and simply adding the <strong class="source-inline">LoginForm</strong> component, you will have <span>the following:</span><pre class="source-code">
import LoginForm from "@/components/LoginForm"
const page = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;Login Page&lt;/h2&gt;
      &lt;LoginForm /&gt;
    &lt;/div&gt;
  )
}
export default page</pre></li>			</ol>
			<p class="calibre5">Now, if you try to navigate to the <strong class="source-inline">/login</strong> route and insert some invalid credentials, the error will be printed below the form in a stringified JSON format. If the credentials are valid, you should be redirected to the <strong class="source-inline">/private</strong> route, and in the <strong class="bold">Application</strong> tab of the Chrome or Firefox developer tools, you will be able to see a secure cookie with the encrypted data—the username and <strong class="source-inline">jwt</strong>, available across the <span>entire application.</span></p>
			<p class="calibre5">You have added the authentication functionality through the use of the <strong class="source-inline">iron-session</strong> package and with the Next.js <span>Server Actions.</span></p>
			<p class="calibre5">In the next section, you will create a protected page that is visible only to authenticated users. Although there are different ways of protecting pages in Next.js, including the use of Next.js middleware, you are going to protect just one page with a simple <span>session verification.</span></p>
			<h2 id="_idParaDest-164" class="about-the-author"><a id="_idTextAnchor176" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating protected pages</h2>
			<p class="calibre5">In this section, you will create one protected page—the page for inserting new cars into the MongoDB database collection. Use Iron Session to check the validity of the cookie and to pass the value of the logged-in user’s username and <strong class="source-inline">jwt</strong> <span>across pages.</span></p>
			<p class="calibre5">You will create a protected page by verifying the data from the session. If the session is present (and includes a username and <strong class="source-inline">jwt</strong>), the user will be able to navigate to it and perform an action to create new cars through the form and an associated Server Action. If not, the user will be redirected to the <span>login page.</span></p>
			<p class="calibre5">The only authenticated page that you will need in this application is the one for inserting new cars, and Iron Session makes this job <span>very easy:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open <strong class="source-inline">/src/app/private/page.js</strong> and edit <span>the file:</span><pre class="source-code">
import { getSession } from "@/actions"
import { redirect } from "next/navigation"
const page = async () =&gt; {
  <strong class="bold">const session = await getSession()</strong>
<strong class="bold">  if (!session?.jwt) {</strong>
<strong class="bold">    redirect("/login")</strong>
<strong class="bold">  }</strong>
  return (
    &lt;div className="p-4"&gt;
      &lt;h1&gt;Private Page&lt;/h1&gt;
      &lt;pre&gt;{JSON.stringify(session, null, 2)}&lt;/pre&gt;
    &lt;/div&gt;
  )
}
export default page</pre><p class="list-inset">The previous code uses the Iron Session object: if <strong class="source-inline">jwt</strong> in the session is present, the user is able to see the page that currently contains the session data. If the session is invalid, the user is redirected to the <strong class="source-inline">/</strong><span><strong class="source-inline">login</strong></span><span> page.</span></p></li>				<li class="calibre15">To add logout functionality with the session, add another action to the <strong class="source-inline">/</strong><span><strong class="source-inline">src/actions.js</strong></span><span> file:</span><pre class="source-code">
export const logout = async () =&gt; {
  const session = await getSession()
  session.destroy()
  redirect("/")
}</pre><p class="list-inset">This action can now be invoked from the <strong class="source-inline">NavBar</strong> component, and the session object can be used to show or hide the login and logout <span>links accordingly.</span></p></li>				<li class="calibre15">To incorporate the logout functionality into the website, create a simple one-button form for logging the user out in a new <span><strong class="source-inline">LogoutForm.js</strong></span><span> file:</span><pre class="source-code">
import { logout } from "@/actions"
const LogoutForm = () =&gt; {
  return (
    &lt;form action={<strong class="bold">logout</strong>}&gt;
      &lt;button className="bg-blue-500
          hover:bg-blue-700" type="submit"&gt;
          Logout
      &lt;/button&gt;
   &lt;/form&gt;
  )
}
export default LogoutForm</pre><p class="list-inset"><strong class="source-inline">LogoutForm</strong> consists of only one button that invokes the logout action defined earlier. Let’s add it to the navigation (<strong class="source-inline">NavBar.js</strong>) component with some <span>conditional logic.</span></p></li>				<li class="calibre15">Open the <strong class="source-inline">src/components/Navbar.js</strong> file and edit the <span>navigation component:</span><pre class="source-code">
import Link from "next/link"
import { getSession } from "@/actions";
import LogoutForm from "./LogoutForm";</pre><p class="list-inset">After importing the <strong class="source-inline">getSession</strong> function—to track whether the user is logged in or not—and the <strong class="source-inline">LogoutForm</strong> button, you can define <span>the component:</span></p><pre class="source-code">const Navbar = async () =&gt; {
  const session = await getSession()
  return (
    &lt;nav className="flex justify-between items-center
      bg-gray-800 p-4"&gt;
      &lt;h1 className="text-white"&gt;Farm Cars&lt;/h1&gt;
      &lt;div className="flex space-x-4 text-white
        child-hover:text-yellow-400"&gt;
        &lt;Link href="/"&gt;Home&lt;/Link&gt;
        &lt;Link href="/cars"&gt;Cars&lt;/Link&gt;
        &lt;Link href="/private"&gt;Private&lt;/Link&gt;
        {!session?.jwt &amp;&amp; &lt;Link
          href="/login"&gt;Login&lt;/Link&gt;}
        {session?.jwt &amp;&amp; &lt;LogoutForm /&gt;}
      &lt;/div&gt;
    &lt;/nav&gt;
  )
}
export default Navbar</pre></li>			</ol>
			<p class="calibre5">The component now keeps track of the logged user and displays conditionally the login or logout link depending on the user’s logged-in status. The private link is deliberately always visible, but you can test it out; if you are not logged in, you will not be able to visit the page and you will get redirected to the <span>login page.</span></p>
			<p class="calibre5">You have now completely implemented the login functionality. There are a couple of factors to consider, starting with the duration of the cookie—set through the <strong class="source-inline">maxAge</strong> property in the file <strong class="source-inline">/src/lib.js</strong>—which should match the duration of <strong class="source-inline">jwt</strong> provided by FastAPI from the backend. The application intentionally lacks user registration functionality since the idea is to have a couple of employees—users who can be created through the API directly. As an exercise, you could write the page for registering users and using the FastAPI <strong class="source-inline">/</strong><span><strong class="source-inline">users/register</strong></span><span> endpoint.</span></p>
			<p class="calibre5">In the next section, you will finalize the application by creating a private page that’s visible only to authenticated users and will allow only salespeople to insert <span>new cars.</span></p>
			<h2 id="_idParaDest-165" class="about-the-author"><a id="_idTextAnchor177" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Implementing the new car page</h2>
			<p class="calibre5">In this section, you will create the form for inserting new cars. You will not use a form validation library, since that was covered in <a href="B22406_08.xhtml#_idTextAnchor137" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 8</em></span></a>, <em class="italic">Building the Frontend of the Application</em>, with the Zod library. In a realistic application, the form would definitely have a similar type of validation. You will create a new Server Action for performing the POST API call and again use <strong class="source-inline">useFormState</strong>—the same pattern that you used for logging the <span>users in.</span></p>
			<p class="calibre5">As the form for inserting cars contains a lot of fields (and there could be many, many more), you will start by abstracting the form field into a separate component. The implementation of the new car advert creation will be broken into the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a new <strong class="source-inline">Field</strong> component in a file <span>named </span><span><strong class="source-inline">/src/components/InputField.js</strong></span><span>:</span><pre class="source-code">
const InputField = ({ props }) =&gt; {
  // eslint-disable-next-line react/prop-types
  const { name, type } = props
  return (
    &lt;div className="mb-4"&gt;
      &lt;label className="block text-gray-700
        text-sm font-bold mb-2" htmlFor={name}&gt;
          {name}
      &lt;/label&gt;
      &lt;input className="shadow appearance-none
        border rounded w-full py-2 px-3
        text-gray-700 leading-tight
        focus:outline-none focus:shadow-outline"
        id={name}
        name={name}
        type={type}
        placeholder={name}
        required
        autoComplete="off"
      /&gt;
    &lt;/div&gt;
  )
}
export default InputField</pre><p class="list-inset">With <strong class="source-inline">InputField</strong> now out of the way, <span>create </span><span><strong class="source-inline">CarForm</strong></span><span>.</span></p></li>				<li class="calibre15">Create a new component in the <strong class="source-inline">/src/components/CarForm.js</strong> file and begin with the imports and the array of fields that will <span>be needed:</span><pre class="source-code">
"use client"
import { createCar } from "@/actions"
import { useFormState } from "react-dom"
import InputField from "./InputField"
const CarForm = () =&gt; {
  let formArray = [
    {
      name: "brand",
      type: "text"
    },
    {
      name: "make",
      type: "text"
    },
    {
      name: "year",
      type: "number"
    },
    {
      name: "price",
      type: "number"
    },
    {
      name: "km",
      type: "number"
    },
    {
      name: "cm3",
      type: "number"
    },
    {
      name: "picture",
      type: "file"
    }
  ]</pre><p class="list-inset">The component uses the <strong class="source-inline">useFormState</strong> hook; you already know that it needs to be a <span>client component.</span></p></li>				<li class="calibre15">The rest of the component is just a mapping over the <strong class="source-inline">fields</strong> array and the implementation of <span>the hook:</span><pre class="source-code">
const [state, formAction] = useFormState(
  <strong class="bold">createCar</strong>, {})
  return (
    &lt;div className="flex items-center justify-center"&gt;
      &lt;pre&gt;{JSON.stringify(state, null, 2)}&lt;/pre&gt;
        &lt;div className="w-full max-w-xs"&gt;
          &lt;form className="bg-white shadow-md rounded
            px-8 pt-6 pb-8 mb-4"
            action={formAction}&gt;
              &lt;h2 className="text-center text-2xl
                font-bold mb-6"&gt;Insert new car
              &lt;/h2&gt;
              {formArray.map((item, index) =&gt; (
              &lt;InputField key={index}
                props={{
                name: item.name, type: item.type
                }} /&gt;
               ))}
               &lt;div className="flex items-center
                 justify-between"&gt;
                 &lt;button className="bg-gray-900
                   hover:bg-gray-700 text-white w-full
                   font-bold py-2 px-4 rounded
                   focus:outline-none
                   focus:shadow-outline"
                   type="submit"&gt;Save new car
                 &lt;/button&gt;
               &lt;/div&gt;
             &lt;/form&gt;
           &lt;/div&gt;
         &lt;/div&gt;
       )
  }
export default CarForm</pre><p class="list-inset">The form uses the <strong class="source-inline">createCar</strong> action that you will be defining in the <strong class="source-inline">actions.js</strong> file in a <span>future step.</span></p></li>				<li class="calibre15">The form needs to be displayed on the private page, so edit the <strong class="source-inline">/</strong><span><strong class="source-inline">src/app/private/page.js</strong></span><span> file:</span><pre class="source-code">
import <strong class="bold">CarForm</strong> from "@/components/CarForm"
import {getSession} from "@/actions"
import { redirect } from "next/navigation"
const page = async () =&gt; {
  const session = await getSession()
  if (!session?.jwt) {
    redirect("/login")
    }
  return (
    &lt;div className="p-4"&gt;
      &lt;h1&gt;Private Page&lt;/h1&gt;
<strong class="bold">      &lt;CarForm /&gt;</strong>
    &lt;/div&gt;
  )
}
export default page</pre><p class="list-inset">The form is created, and it is displayed on the <strong class="source-inline">/private</strong> page. The only thing that is missing is the corresponding action, which you will create in the <span>next step.</span></p></li>				<li class="calibre15">Open the <strong class="source-inline">/src/actions.js</strong> file and add the following action to the end of the file for creating a <span>new car:</span><pre class="source-code">
export const createCar = async (state, formData) =&gt; {
  const session = await getSession()
  const jwt = session.jwt
  const result = await fetch(`${
    process.env.API_URL}/cars/`,
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${jwt}`,
        },
        body: formData
    })
    const data = await result.json()
    if (result.ok) {
      redirect("/")
    } else {
      return { error: data.detail }
    }
}</pre></li>			</ol>
			<p class="calibre5">The action is straightforward—that is the beauty of Server Actions. It is just a function that checks the session and <strong class="source-inline">jwt</strong> and performs the <strong class="source-inline">API POST</strong> request. The function should also include an earlier redirect to the login page in case <strong class="source-inline">jwt</strong> is not found, but this way, you let the <strong class="source-inline">useFormState</strong> hook display any errors coming from <span>the backend.</span></p>
			<p class="calibre5">You have implemented the website specification—users are able to log in and insert new cars and, after the period of revalidation (15-20 seconds), the cars are displayed on the <strong class="source-inline">/car</strong> page as well as on the dedicated page for the newly <span>inserted car.</span></p>
			<p class="calibre5">In the next section, you will deploy your application to Netlify and learn how to streamline the process, while providing environment variables and configuring settings for <span>a deployment.</span></p>
			<h2 id="_idParaDest-166" class="about-the-author"><a id="_idTextAnchor178" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Providing metadata</h2>
			<p class="calibre5">One of the main features of Next.js is the ability to provide better <strong class="bold">search engine optimization</strong> (<strong class="bold">SEO</strong>) than SPAs. While generating static content that is easily picked up by crawlers is important, providing useful page metadata <span>is essential.</span></p>
			<p class="calibre5">Metadata is an important feature of every web application or site, and Next.js solves this problem in an elegant way with the <strong class="source-inline">Metadata</strong> component. Metadata enables direct communication with search engines (such as Google), providing precise information about the site’s content, title, and description, as well as <span>page-specific information.</span></p>
			<p class="calibre5">In this brief section, you will learn how to set the title tags of pages. The Next.js documentation is very detailed (<a href="https://nextjs.org/docs/app/building-your-application/optimizing/metadata" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://nextjs.org/docs/app/building-your-application/optimizing/metadata</span></a>) and explains the various pieces of information that can be set, but in this case, you are only going to set the <span>page titles:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Open the <strong class="source-inline">src/app/layout.js</strong> page and edit the <span><strong class="source-inline">metadata</strong></span><span> part:</span><pre class="source-code">
export const metadata = {
  title: "Farm Cars App",
  description: "Next.js + FastAPI + MongoDB App",
};</pre><p class="list-inset">This simple change will cause all the pages within the layout to have the newly set title and description. Since you have edited the <strong class="source-inline">Root</strong> layout, which encloses all the pages, this means that every page on the website will be affected. These can be overridden on a <span>per-page basis.</span></p></li>				<li class="calibre15">Open <strong class="source-inline">/src/app/cars/[id]/page.js</strong> for the individual cars page and add the <span>following export:</span><pre class="source-code">
export async function generateMetadata({ params }, parent) {
    const carId = params.id
    const car = await fetch(`${process.env.API_URL}/cars/${carId}`).then((res) =&gt; res.json())
    const title = `FARM Cars App - ${car.brand} ${car.make} (${car.year})`
    return { title }
}</pre></li>			</ol>
			<p class="calibre5">The preceding export signals to Next.js that only these pages should have the title that is returned from the function, while the other pages will have the <span>unaltered title.</span></p>
			<p class="calibre5">You have successfully edited the pages’ metadata, and now it is time to deploy the application on the internet, which the next section <span>will detail.</span></p>
			<h1 id="_idParaDest-167" class="contributor"><a id="_idTextAnchor179" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Deployment on Netlify</h1>
			<p class="calibre5">Next.js is arguably the most popular full-stack and frontend framework, and there is a plethora of <span>deployment options.</span></p>
			<p class="calibre5">In this section, you will learn how to deploy your Next.js application on Netlify—one of the most popular web platforms for deployment, content orchestration, continuous integration, and <span>much more.</span></p>
			<p class="calibre5">In order to deploy your website on Netlify, you will need to deploy the FastAPI backend. If you haven’t already done so, please refer to <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>,<em class="italic"> Building a Backend with FastAPI</em>, on how to do that. Once you have the backend address (in your example, the URL of the deployed FastAPI application is <a href="https://chapter9backend2ed.onrender.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://chapter9backend2ed.onrender.com</span></a>), it will be used as the API URL for the <span>Next.js frontend.</span></p>
			<p class="calibre5">In order to perform the deployment to Netlify, perform the <span>following steps:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="bold">Create a Netlify account</strong>: Log in with your GitHub account and create a free Netlify account, since Netlify will pick your code from the repository that you will make for the <span>Next.js app.</span></li>
				<li class="calibre17"><strong class="bold">Create a GitHub repository</strong>: In order to be able to deploy to Netlify (or Vercel for that matter), you will need to create a GitHub repository for your <span>Next.js project.</span></li>
			</ul>
			<p class="calibre5">To create a GitHub repository, implement the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">In your terminal, enter the project folder and type <span>the following:</span><pre class="source-code">
git add .</pre><p class="list-inset">This command adds the modified and newly created files to <span>the repository.</span></p></li>				<li class="calibre15">Next, commit <span>the changes:</span><pre class="source-code">
git commit -m "Next.js project"</pre></li>				<li class="calibre15">Now that your project is under version control, create a new repository in your GitHub account and choose an appropriate name. In your case, the repository is <span>named </span><span><strong class="source-inline">chapter10frontend</strong></span><span>.</span></li>
			</ol>
			<h2 id="_idParaDest-168" class="about-the-author"><a id="_idTextAnchor180" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Pushing the changes to GitHub</h2>
			<p class="calibre5">Now you can add the new origin to your local repository. In the same terminal inside the project, type the <span>following commands:</span></p>
			<ol class="calibre14">
				<li class="calibre15">First, set the name of the branch <span>to </span><span><strong class="source-inline">main</strong></span><span>:</span><pre class="source-code">
git branch -M main</pre></li>				<li class="calibre15">Then, set the origin to the newly <span>created repository:</span><pre class="source-code">
git remote add origin https://github.com/&lt;your username&gt;/&lt;name_of_the_repo&gt;.git</pre><p class="list-inset">Here, you need to replace the name of the repository and your username: <strong class="source-inline">(&lt;username&gt;</strong> <span>and </span><span><strong class="source-inline">&lt;name_of_the_repo&gt;</strong></span><span>).</span></p></li>				<li class="calibre15">Finally, push the project <span>to GitHub:</span><pre class="source-code">
git push -u origin main</pre></li>			</ol>
			<p class="calibre5">Now, you can deploy the repository on Netlify in the <span>following manner:</span></p>
			<ol class="calibre14">
				<li class="calibre15"><strong class="bold">Create a new site on Netlify</strong>: After logging in to Netlify, click the <strong class="bold">Add new site</strong> button and select <strong class="bold">Import an existing project</strong>. You will be prompted to select a provider, and you will select GitHub since that is where you committed your Next.js project. From the list of projects belonging to your account (or the account that you logged in to Netlify with), search for the Next.js project (<strong class="source-inline">chapter10frontend</strong> in <span>your case).</span></li>
				<li class="calibre15"><strong class="bold">Set up the site settings</strong>: You will be presented with a page that will ask you to fill in some details about the project, which are <span>as follows:</span><ol class="calibre19"><li class="calibre15">Branch to deploy: Leave it as <strong class="source-inline">main</strong> as that is your <span>only branch</span></li><li class="calibre15">Base directory: <span>Leave empty</span></li><li class="calibre15">Build command: Leave it as <strong class="source-inline">npm </strong><span><strong class="source-inline">run build</strong></span></li><li class="calibre15">Publish directory: Leave it <span>as </span><span><strong class="source-inline">.next</strong></span></li><li class="calibre15">Set the only environment variable: Click the <strong class="bold">Add environment variables</strong> button and set a new variable where the key (the name) will be <strong class="source-inline">API_URL</strong> and the value will be the FastAPI backend URL. If you followed the steps from the previous chapter to host your backend on Render, the value will <span>be </span><a href="https://chapter9backend2ed.onrender.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://chapter9backend2ed.onrender.com</span></span></a><span>.</span></li></ol></li>
				<li class="calibre15">Hit the <strong class="bold">Deploy</strong> (<strong class="bold">&lt;name of your </strong><span><strong class="bold">repo&gt;</strong></span><span>) button!</span></li>
			</ol>
			<p class="calibre5">After a while, you should have your website deployed to the address indicated on the page. Bear in mind, however, that the API must be working, and since the free tier of Render.com, for instance (if you used Render as your backend deployment option), can take up to a minute to wake up after going stale, be prepared to wake up the API. The recommendation is to wait until the backend is responsive—you can check it by simply visiting the API address—and then begin the deployment process. This way, you will prevent potential deployment and page <span>generation errors.</span></p>
			<p class="calibre5">This is a good moment to analyze the command that you provided to Netlify to build the site—the <strong class="source-inline">build</strong> command. If you run <strong class="source-inline">npm run build</strong> in your Next.js command line, Next.js performs a series of operations and produces an <span>optimized build.</span></p>
			<p class="calibre5">These operations include code optimizations (such as minification and code splitting), the creation of a <strong class="source-inline">.next</strong> directory that contains the optimized, production-ready code, and the directory that actually gets served on <span>the internet.</span></p>
			<p class="calibre5">The <strong class="source-inline">build</strong> command also generates the static pages and the route handlers. You can test the build after it successfully completes, with the <span>following command:</span></p>
			<pre class="source-code">
npm run start</pre>			<p class="calibre5">You have now successfully deployed an optimized FastAPI MongoDB-powered Next.js website and you are ready to tackle a host of web development tasks with an incredibly powerful and <span>flexible stack.</span></p>
			<h1 id="_idParaDest-169" class="contributor"><a id="_idTextAnchor181" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you have learned the basics of Next.js, a popular React-based full-stack framework that, coupled with FastAPI and MongoDB, allows you to build any virtually any type of <span>web application.</span></p>
			<p class="calibre5">You have learned how to create a new Next.js project, how to implement routing with the new App Router, and how to fetch data with <span>server components.</span></p>
			<p class="calibre5">Important Next.js concepts, such as Server Actions, form handling, and cookies were also introduced and implemented. Apart from this, you explored some of the Next.js optimizations such as the <strong class="source-inline">Image</strong> component for serving optimized images, the <strong class="source-inline">Metadata</strong> tags, and how to create a <span>production build.</span></p>
			<p class="calibre5">Finally, you deployed your Next.js application on Netlify, but the underlying principles of deployment remain the same for <span>other providers.</span></p>
			<p class="calibre5">Next.js is a rich and complex ecosystem in its own right, and you should consider this chapter as a starting point for your next application, which blends the best of the three worlds: FastAPI, MongoDB, and React, with the addition of external third-party services that your application <span>might need.</span></p>
			<p class="calibre5">The next chapter will share some practical advice for you while working with the FARM stack, along with project ideas that can help you get started <span>right away.</span></p>
		</div>
	</div>
</div>
</body></html>