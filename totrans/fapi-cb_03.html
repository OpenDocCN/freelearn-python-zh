<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor091"/>3</h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>Building RESTful APIs with FastAPI</h1>
<p>In this chapter, we delve into the essentials of <a id="_idIndexMarker152"/>building <strong class="bold">RESTful APIs</strong>. RESTful APIs are the backbone of web services, enabling applications to communicate and exchange data efficiently.</p>
<p>You will build a RESTful API for a Task Manager application. The application will interact with a CSV file, although the typical approach for such applications would be to use a database such as SQL or NoSQL. This approach is unconventional and not recommended for most scenarios due to scalability and performance limitations. However, in certain contexts, particularly in legacy systems or when dealing with large volumes of structured data files, managing data through CSV can be a practical solution.</p>
<p>Our Task Manager API will allow users to <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) tasks, each represented as a record in a CSV file. This example will provide insights into handling data in non-standard formats within FastAPI.</p>
<p>We will see how to test the API’s endpoint. As your API grows, managing complex queries and filtering becomes essential. We’ll explore techniques to implement advanced query capabilities, enhancing the usability and flexibility of your API.</p>
<p>Furthermore, we’ll tackle the important aspect of versioning your API. Versioning is key to evolving your API over time without breaking existing clients. You’ll learn strategies to manage API versions, ensuring backward compatibility and smooth transitions for users.</p>
<p>Lastly, we’ll cover securing API with OAuth2, an industry-standard protocol for authorization. Security is paramount in API development, and you’ll gain practical experience in implementing authentication and protecting your endpoints.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Creating CRUD operations</li>
<li>Creating RESTful endpoints</li>
<li>Testing your RESTful API</li>
<li>Handling complex queries and filtering</li>
<li>Versioning your API</li>
<li>Securing your API with OAuth2</li>
<li>Documenting your API with Swagger and Redoc</li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>To fully engage with this chapter in our <em class="italic">FastAPI Cookbook</em> and effectively build RESTful APIs, you’ll need to have the following technologies and tools installed and configured:</p>
<ul>
<li><strong class="bold">Python</strong>: Make sure you have a Python version higher than 3.9 in your environment.</li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all required dependencies. If you haven’t done it from the previous chapters, you can do so simply from your terminal with the following command:<pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> <li><strong class="bold">Pytest</strong>: You can install this framework by running the following:<pre class="source-code">
<strong class="bold">$ pip install pytest</strong></pre></li> </ul>
<p>Note that it can be very useful to already have some knowledge of the Pytest framework to better follow the <em class="italic">Testing your RESTful </em><em class="italic">API</em> recipe.</p>
<p>The code used in the chapter is available on GitHub at the address: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03</a>.</p>
<p>Feel free to follow along or consult it in case you get stuck.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Creating CRUD operations</h1>
<p>This recipe will<a id="_idIndexMarker153"/> show you how to make the basic CRUD operations work with the CSV file that acts as a database.</p>
<p>We will begin by making a draft for a simple list of tasks in CSV format and we will put the operations in a separate Python module. By the end of the recipe, you will have all the operations ready to be used by the API’s endpoints.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>How to do it…</h2>
<p>Let’s start by creating a project root directory called <code>task_manager_app</code> to host our code base for our application:</p>
<ol>
<li>Move into the root project folder and create a <code>tasks.csv</code> file, which we will use as a database and put a few tasks inside<a id="_idTextAnchor096"/>:<pre class="source-code">
id,title,description,status
1,Task One,Description One,Incomplete
2,Task Two,Description Two,Ongoing</pre></li> <li>Then, create a file called <code>models.py</code>, containing the Pydantic models that we will use<a id="_idIndexMarker154"/> internally for the code. It will look like the following:<pre class="source-code">
from pydantic import BaseModel
class Task(BaseModel):
    title: str
    description: str
    status: str
class TaskWithID(Task):
    id: int</pre><p class="list-inset">We created two separate classes for task objects because <code>id</code> won’t be used all along the code.</p></li> <li>In a new file called <code>operations.py</code>, we will define the function that interacts with our database.<p class="list-inset">We can start creating the CRUD operation</p><p class="list-inset">Create a<a id="_idIndexMarker155"/> function to retrieve all the tasks from a <code>.</code><code>csv</code> file:</p><pre class="source-code">
import csv
from typing import Optional
from models import Task, TaskWithID
DATABASE_FILENAME = "tasks.csv"
column_fields = [
    "id", "title", "description", "status"
]
def read_all_tasks() -&gt; list[TaskWithID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskWithID(**row) for row in reader]</pre></li> <li>Now, we need to create a function to read a specific task based on <code>id</code>:<pre class="source-code">
def read_task(task_id) -&gt; Optional[TaskWithID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        for row in reader:
            if int(row["id"]) == task_id:
                return TaskWithID(**row)</pre></li> <li>To write a task, we need a strategy to assign a new <code>id</code> to the task that will written into the database.<p class="list-inset">A good strategy can be to implement a logic based on the IDs already present in the database, then write the task into our CSV file, and group both operations into a new function. We can split the create task operation into three functions.</p><p class="list-inset">First, let’s<a id="_idIndexMarker156"/> create the function that retrieves the new ID based on the existing ones in the database:</p><pre class="source-code">
def get_next_id():
    try:
        with open(DATABASE_FILENAME, "r") as csvfile:
            reader = csv.DictReader(csvfile)
            max_id = max(
                int(row["id"]) for row in reader
            )
            return max_id + 1
    except (FileNotFoundError, ValueError):
        return 1</pre><p class="list-inset">Then, we define the function to write the task with the ID in the CSV file:</p><pre class="source-code">def write_task_into_csv(
    task: TaskWithID
):
    with open(
        DATABASE_FILENAME, mode="a", newline=""
    ) as file:
        writer = csv.DictWriter(
            file,
            fieldnames=column_fields,
        )
        writer.writerow(task.model_dump())</pre><p class="list-inset">After that, we can<a id="_idIndexMarker157"/> leverage these last two functions to define the function that creates the task:</p><pre class="source-code">def create_task(
    task: Task
) -&gt; TaskWithID:
    id = get_next_id()
    task_with_id = TaskWithID(
        id=id, **task.model_dump()
    )
    write_task_into_csv(task_with_id)
    return task_with_id</pre></li> <li>Then, let’s create the function to modify the task:<pre class="source-code">
def modify_task(
    id: int, task: dict
) -&gt; Optional[TaskWithID]:
    updated_task: Optional[TaskWithID] = None
    tasks = read_all_tasks()
    for number, task_ in enumerate(tasks):
        if task_.id == id:
            tasks[number] = (
                updated_task
            ) = task_.model_copy(update=task)
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfile,
            fieldnames=column_fields,
        )
        writer.writeheader()
        for task in tasks:
            writer.writerow(task.model_dump())
    if updated_task:
        return updated_task</pre></li> <li>Finally, let’s create<a id="_idIndexMarker158"/> the function to remove the task with a specific <code>id</code>:<pre class="source-code">
def remove_task(id: int) -&gt; bool:
    deleted_task: Optional[Task] = None
    tasks = read_all_tasks()
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfile,
            fieldnames=column_fields,
        )
        writer.writeheader()
        for task in tasks:
            if task.id == id:
                deleted_task = task
                continue
            writer.writerow(task.model_dump())
    if deleted_task:
        dict_task_without_id = (
            deleted_task.model_dump()
        )
        del dict_task_without_id["id"]
        return Task(**dict_task_wihtout_id)</pre></li> </ol>
<p>You’ve just created the<a id="_idIndexMarker159"/> basic CRUD operations. We are now ready to expose those operations through the API endpoints.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>How it works...</h2>
<p>The structure of your API is fundamental in RESTful design. It involves defining endpoints (URIs) and associating them with HTTP methods to perform the desired operations.</p>
<p>In our Task Management system, we’ll create endpoints to handle tasks, mirroring common CRUD operations. Here’s an overview:</p>
<ul>
<li><code>List Tasks</code> (<code>GET /tasks</code>) retrieves a list of all tasks</li>
<li><code>Retrieve Task</code> (<code>GET /tasks/{task_id}</code>) gets details of a specific task</li>
<li><code>Create Task</code> (<code>POST /task</code>) adds a new task</li>
<li><code>Update Task</code> (<code>PUT /tasks/{task_id}</code>) modifies an existing task</li>
<li><code>Delete Task</code> (<code>DELETE /tasks/{task_id}</code>) removes a task</li>
</ul>
<p>Each endpoint represents a specific function in the API, clearly defined and purpose driven. FastAPI’s routing <a id="_idIndexMarker160"/>system allows us to map these operations to Python functions easily.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">Try to write your unit tests for each one of the CRUD operations. If you follow along with the GitHub repository, you can find the tests in the <code>Chapter03/task_manager_rest_api/test_operations.py</code> file.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor098"/>Creating RESTful Endpoints</h1>
<p>Now, we will create <a id="_idIndexMarker161"/>the routes to expose each of the CRUD operations with a specific endpoint. In this recipe, we will see how FastAPI leverages Python type annotations to define expected request and response data types, streamlining the process of validation and serializing data.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Getting ready…</h2>
<p>Before starting the recipe, make sure you know how to set up your local environment and create a basic FastAPI server. You can review it in the <em class="italic">Creating a new FastAPI project</em> and <em class="italic">Understanding FastAPI basics</em> recipes in <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps </em><em class="italic">with FastAPI</em>.</p>
<p>Also, we will use the CRUD operations created in the previous recipe.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor100"/>How to do it…</h2>
<p>Let’s create a <code>main.py</code> file in the project root folder to code the server with the endpoints. FastAPI simplifies the implementation of different HTTP methods, aligning them with the corresponding CRUD operations.</p>
<p>Let’s now write the endpoints for each operation:</p>
<ol>
<li>Create the server with the endpoint to list all the tasks by using the <code>read_all_tasks</code> operation:<pre class="source-code">
from fastapi import FastAPI, HTTPException
from models import (
    Task,
    TaskWithID,
)
from operations import read_all_tasks
app = FastAPI()
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks():
    tasks = read_all_tasks()
    return tasks</pre></li> <li>Now, let’s write<a id="_idIndexMarker162"/> the endpoint to read a specific task based on <code>id</code>:<pre class="source-code">
@app.get("/task/{task_id}")
def get_task(task_id: int):
    task = read_task(task_id)
    if not task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return task</pre></li> <li>The endpoint to add a task will be as follows:<pre class="source-code">
from operations import create_task
@app.post("/task", response_model=TaskWithID)
def add_task(task: Task):
    return create_task(task)</pre></li> <li>To update the task, we can modify each field (<code>description</code>, <code>status</code>, or <code>title</code>). To do this, we <a id="_idIndexMarker163"/>create a specific model to be used in the body called <code>UpdateTask</code>. The endpoint will look like this:<pre class="source-code">
from operations import modify_task
class UpdateTask(BaseModel):
    title: str | None = None
    description: str | None = None
    status: str | None = None
@app.put("/task/{task_id}", response_model=TaskWithID)
def update_task(
    task_id: int, task_update: UpdateTask
):
    modified = modify_task(
        task_id,
        task_update.model_dump(exclude_unset=True),
    )
    if not modified:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return modified</pre></li> <li>Finally, here<a id="_idIndexMarker164"/> is the endpoint to delete a task:<pre class="source-code">
from operations import remove_task
@app.delete("/task/{task_id}", response_model=Task)
def delete_task(task_id: int):
    removed_task = remove_task(task_id)
    if not removed_task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return removed_task</pre></li> </ol>
<p>You have just implemented the operations to interact with the CSV file used as a database.</p>
<p>From a command terminal at the project root folder level, spin up the server with the <code>uvicorn</code> command:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>In the browser, go to <code>http://localhost:8000/docs</code> and you will see the endpoints of your RESTful API that you just made.</p>
<p>You can experiment <a id="_idIndexMarker165"/>by creating some tasks, then listing them, updating them, and deleting some of them directly with the interactive documentation.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Testing your RESTful API</h1>
<p>Testing is a critical <a id="_idIndexMarker166"/>part of API development. In FastAPI, you can use various testing frameworks such as <code>pytest</code> to write tests for your API endpoints.</p>
<p>In this recipe, we are going to write unit tests for each of the endpoints we created earlier.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Getting ready…</h2>
<p>If not done yet, ensure you have <code>pytest</code> installed in your environment by running:</p>
<pre class="console">
$ pip install pytest</pre> <p>It’s a good practice in testing to use a dedicated database to avoid interaction with the production one. To accomplish this, we will create a test fixture that generates the database before each test.</p>
<p>We will define this in a <code>conftest.py</code> module so that the fixture is applied to all tests under the project’s root folder. Let’s create the module in the project root folder and start by defining a list of test tasks and the name of the CSV file used for the tests:</p>
<pre class="source-code">
TEST_DATABASE_FILE = "test_tasks.csv"
TEST_TASKS_CSV = [
    {
        "id": "1",
        "title": "Test Task One",
        "description": "Test Description One",
        "status": "Incomplete",
    },
    {
        "id": "2",
        "title": "Test Task Two",
        "description": "Test Description Two",
        "status": "Ongoing",
    },
]
TEST_TASKS = [
    {**task_json, "id": int(task_json["id"])}
    for task_json in TEST_TASKS_CSV
]</pre> <p>We can now create a fixture that will be used for all the tests. This fixture will set up the test database before <a id="_idIndexMarker167"/>each test function execution.</p>
<p>We can achieve this by passing the <code>autouse=True</code> argument to the <code>pytest.fixture</code> decorator, which indicates that the feature will run before every single test:</p>
<pre class="source-code">
import csv
import os
from pathlib import Path
from unittest.mock import patch
import pytest
@pytest.fixture(autouse=True)
def create_test_database():
    database_file_location = str(
        Path(__file__).parent / TEST_DATABASE_FILE
    )
    with patch(
        "operations.DATABASE_FILENAME",
        database_file_location,
    ) as csv_test:
        with open(
            database_file_location, mode="w", newline=""
        ) as csvfile:
            writer = csv.DictWriter(
                csvfile,
                fieldnames=[
                    "id",
                    "title",
                    "description",
                    "status",
                ],
            )
            writer.writeheader()
            writer.writerows(TEST_TASKS_CSV)
            print("")
        yield csv_test
        os.remove(database_file_location)</pre> <p>Since the fixture is defined in a <code>conftest.py</code> module, each test module will automatically import it.</p>
<p>Now, we can proceed with creating the actual unit test functions for the endpoints created in the previous recipe.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>How to do it...</h2>
<p>To test the endpoints, FastAPI provides a specific <code>TestClient</code> class that allows the testing of the <a id="_idIndexMarker168"/>endpoints without running the server.</p>
<p>In a new module called <code>test_main.py</code>, let’s define our test client:</p>
<pre class="source-code">
from main import app
from fastapi.testclient import TestClient
client = TestClient(app)</pre> <p>We can create the tests for each endpoint as follows.</p>
<ol>
<li>Let’s start with the <code>GET /tasks</code> endpoint, which lists all the tasks in the database:<pre class="source-code">
from conftest import TEST_TASKS
def test_endpoint_read_all_tasks():
    response = client.get("/tasks")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS</pre><p class="list-inset">We are asserting the response’s status code and the <code>json</code> body.</p></li> <li>As easy as that, we can go on by creating the test for <code>GET /tasks/{task_id}</code> to read a task with a specific <code>id</code>:<pre class="source-code">
def test_endpoint_get_task():
    response = client.get("/task/1")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS[0]
    response = client.get("/task/5")
    assert response.status_code == 404</pre><p class="list-inset">Besides the <code>200</code> status<a id="_idIndexMarker169"/> code for an existing task, we also asserted the status code is equal to <code>404</code> when the task does not exist in the database.</p></li> <li>In a similar way, we can test the <code>POST /task</code> endpoint to add a new task into the database by asserting the new assigned <code>id</code> for the task:<pre class="source-code">
from operations import read_all_tasks
def test_endpoint_create_task():
    task = {
        "title": "To Define",
        "description": "will be done",
        "status": "Ready",
    }
    response = client.post("/task", json=task)
    assert response.status_code == 200
    assert response.json() == {**task, "id": 3}
    assert len(read_all_tasks()) == 3</pre></li> <li>The test for the <code>PUT /tasks/{task_id}</code> endpoint to modify a task will then be the<a id="_idIndexMarker170"/> following:<pre class="source-code">
from operations import read_task
def test_endpoint_modify_task():
    updated_fields = {"status": "Finished"}
    response = client.put(
        "/task/2", json=updated_fields
    )
    assert response.status_code == 200
    assert response.json() == {
         *TEST_TASKS[1],
         *updated_fields,
    }
    response = client.put(
        "/task/3", json=updated_fields
    )
    assert response.status_code == 404</pre></li> <li>Finally, we test the <code>DELETE /tasks/{task_id}</code> endpoint to delete a task:<pre class="source-code">
def test_endpoint_delete_task():
    response = client.delete("/task/2")
    assert response.status_code == 200
    expected_response = TEST_TASKS[1]
    del expected_response["id"]
    assert response.json() == expected_response
    assert read_task(2) is None</pre></li> </ol>
<p>You’ve just <a id="_idIndexMarker171"/>written all the unit tests for each of the API endpoints.</p>
<p>You can now run the tests from the project root folder by running in the terminal, or with the GUI support of your favorite editor:</p>
<pre class="console">
$ pytest .</pre> <p>Pytest will collect all the tests and run them. If everything is correctly done, you will see a message that says you got a 100% score in the output of the console if you have written the tests correctly.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor104"/>See also</h2>
<p>You can check test fixtures<a id="_idIndexMarker172"/> in the Pytest documentation:</p>
<ul>
<li><em class="italic">Pytest Fixtures </em><em class="italic">Reference</em>: <a href="https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml">https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml</a></li>
</ul>
<p>You can dig into FastAPI testing<a id="_idIndexMarker173"/> tools and the <code>TestClient</code> API in the official documentation:</p>
<ul>
<li><em class="italic">FastAPI </em><em class="italic">Testing</em>: <a href="https://fastapi.tiangolo.com/tutorial/testing/">https://fastapi.tiangolo.com/tutorial/testing/</a></li>
<li><em class="italic">FastAPI </em><em class="italic">TestClient</em>: <a href="https://fastapi.tiangolo.com/reference/testclient/">https://fastapi.tiangolo.com/reference/testclient/</a></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor105"/>Handling complex queries and filtering</h1>
<p>In any RESTful API, providing <a id="_idIndexMarker174"/>the functionality to filter data based on certain criteria is essential. In this recipe, we’ll enhance our Task Manager API to allow users to filter tasks based on different parameters and create a search endpoint.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Getting ready…</h2>
<p>The filtering functionality will be implemented in the existing <code>GET /tasks</code> endpoint to show how to overcharge an endpoint, while the search functionality will be shown on a brand-new endpoint. Make sure you have at least the CRUD operations already in place before continuing.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>How to do it...</h2>
<p>We will start by overcharging <code>GET /tasks</code> endpoint with filters. We modify the endpoint to accept two query parameters: <code>status</code> and <code>title</code>.</p>
<p>The endpoint will then look like the following:</p>
<pre class="source-code">
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks(
<strong class="bold">    status: Optional[str] = None,</strong>
<strong class="bold">    title: Optional[str] = None,</strong>
):
    tasks = read_all_tasks()
<strong class="bold">    if status:</strong>
<strong class="bold">        tasks = [</strong>
<strong class="bold">            task</strong>
<strong class="bold">            for task in tasks</strong>
<strong class="bold">            if task.status == status</strong>
<strong class="bold">        ]</strong>
<strong class="bold">    if title:</strong>
<strong class="bold">        tasks = [</strong>
<strong class="bold">            task for task in tasks if task.title == title</strong>
<strong class="bold">        ]</strong>
    return tasks</pre> <p>The two parameters can be optionally specified to filter the tasks that match their value.</p>
<p>Next, we implement a search functionality. Beyond basic filtering, implementing a search functionality<a id="_idIndexMarker175"/> can significantly improve the usability of an API. We’ll add a search feature that allows users to find tasks based on a keyword present in the title or description in a new endpoint:</p>
<pre class="source-code">
@app.get("/tasks/search", response_model=list[TaskWithID])
def search_tasks(keyword: str):
    tasks = read_all_tasks()
    filtered_tasks = [
        task
        for task in tasks
        if keyword.lower()
        in (task.title + task.description).lower()
    ]
    return filtered_tasks</pre> <p>In the <code>search_tasks</code> endpoint, the function filters tasks to include only those where the keyword appears in either the title or the description.</p>
<p>To start the server as usual, run this command from the command line:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, go to the interactive documentation address at <code>http://localhost:8000/docs</code>, and you will see the new endpoint we’ve just made.</p>
<p>Play around by<a id="_idIndexMarker176"/> specifying some keywords that could be in the title or the description of one of your tasks.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor108"/>Versioning your API</h1>
<p><strong class="bold">API versioning</strong> is <a id="_idIndexMarker177"/>essential in maintaining<a id="_idIndexMarker178"/> and evolving web services without disrupting the existing users. It allows developers to introduce changes, improvements, or even breaking changes while providing backward compatibility. In this recipe, we will implement versioning in our Task Manager API.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Getting ready…</h2>
<p>To follow the recipe, you will need to have endpoints already defined. If you don’t have them, you can first check the <em class="italic">Creating RESTful </em><em class="italic">endpoints</em> recipe.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor110"/>How to do it...</h2>
<p>There are several strategies for API versioning. We will use the most common approach, URL path versioning, for our API.</p>
<p>Let’s consider that we want to improve the task information by adding a new <code>str</code> field called <code>priority</code> that is set to <code>"lower"</code> by default. Let's do it through the following steps.</p>
<ol>
<li>Let’s create a <code>TaskV2</code> object class in the <code>models.py</code> module:<pre class="source-code">
from typing import Optional
class TaskV2(BaseModel):
    title: str
    description: str
    status: str
    priority: str | None = "lower"
class TaskV2WithID(TaskV2):
    id: int</pre></li> <li>In the <code>operations.py</code> module, let’s create a new function called <code>read_all_tasks_v2</code>, which<a id="_idIndexMarker179"/> reads <a id="_idIndexMarker180"/>all the tasks, and add the <code>priority</code> field:<pre class="source-code">
from models import TaskV2WIthID
def read_all_tasks_v2() -&gt; list[TaskV2WIthID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskV2WIthID(**row) for row in reader]</pre></li> <li>We have now all we need to create version two of <code>read_all_tasks</code> function. We will do this in the <code>main.py</code> module:<pre class="source-code">
from models import TaskV2WithID
@app.get(
    "/v2/tasks",
    response_model=list[TaskV2WithID]
)
def get_tasks_v2():
    tasks = read_all_tasks_v2()
    return tasks</pre></li> </ol>
<p>You’ve just created version two of the endpoint. In this way, you can develop and improve your<a id="_idIndexMarker181"/> API with several versions of <a id="_idIndexMarker182"/>your endpoint.</p>
<p>To test it, let's modify our <code>tasks.csv</code> file by manually adding the new field to test the new endpoint:</p>
<pre class="source-code">
id,title,description,status,<strong class="bold">priority</strong>
1,Task One,Description One,Incomplete
2,Task Two,Description Two,Ongoing,<strong class="bold">higher</strong></pre> <p>Start the server once more from the command line:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Now, the interactive documentation at <code>http://localhost:8000/docs</code> will show the new <code>GET /v2/tasks</code> endpoint to list all the tasks in version 2 mode.</p>
<p>Check that the endpoint lists the tasks with the new <code>priority</code> field and that the old <code>GET /tasks</code> is still working as expected.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">You might have noticed that using a CSV file as a database might not be the most reliable solution. If the process crashes during an update or removal, you can lose all of the data. So, improve the API with a newer version of the endpoints that use operational functions that interact with an SQLite database.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>There’s more…</h2>
<p>When you version<a id="_idIndexMarker183"/> an API, you are essentially providing a way to differentiate between different releases or versions of your API, allowing clients to choose which version they want to interact with.</p>
<p>Besides the URL-based approach<a id="_idIndexMarker184"/> that we used in the recipe, there are other common approaches to API versioning, such as the following:</p>
<ul>
<li><strong class="bold">Query parameter versioning</strong>: Version information is passed as a query parameter in the API request. For example, see the following:<pre class="source-code">
https://api.example.com/resource?version=1</pre><p class="list-inset">This method keeps the base URL uniform across versions.</p></li> <li><strong class="bold">Header versioning</strong>: The version is specified in a custom header of the HTTP request:<pre class="source-code">
GET /resource HTTP/1.1
Host: api.example.com
X-API-Version: 1</pre><p class="list-inset">This keeps the URL clean but requires clients to explicitly set the version in their requests.</p></li> <li><strong class="bold">Consumer-based versioning</strong>: This strategy allows customers to choose the version they need. The version available at their first interaction is saved with their details and used in all future interactions unless they make changes.</li>
</ul>
<p>Furthermore, it can be relevant<a id="_idIndexMarker185"/> to use <code>MAJOR.MINOR.PATCH</code>). Changes in the <code>MAJOR</code> version indicate incompatible API changes, while <code>MINOR</code> and <code>PATCH</code> versions indicate backward-compatible changes.</p>
<p>Versioning allows API providers to introduce changes (such as adding new features, modifying existing behavior, or deprecating endpoints and sunset policies) without breaking existing client integrations.</p>
<p>It also gives consumers control over when and how they adopt new versions, minimizing disruptions and maintaining stability in the API ecosystem.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>See also</h2>
<p>You can have a look at an interesting <a id="_idIndexMarker186"/>article from the Postman blog on API versioning strategies:</p>
<ul>
<li><em class="italic">Postman Blog API </em><em class="italic">Versioning</em>: <a href="https://www.postman.com/api-platform/api-versioning/">https://www.postman.com/api-platform/api-versioning/</a></li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor113"/>Securing your API with OAuth2</h1>
<p>In web applications, securing <a id="_idIndexMarker187"/>endpoints from<a id="_idIndexMarker188"/> unauthorized users is crucial. <strong class="bold">OAuth2</strong> is a common authorization framework that enables applications to be accessed by user accounts with restricted permissions. It works by issuing tokens instead of credentials. This recipe will show how to use OAuth2 in our Task Manager API to protect endpoints.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor114"/>Getting ready…</h2>
<p>FastAPI provides support for OAuth2 with a password, including the use of external tokens. Data compliance regulations require that passwords are not stored in plain text. Instead, a usual method is to store the outcome of the hashing operation, which changes the plain text into a string that is not readable by humans and cannot be reversed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">With the only purpose of showing the functionality, we will fake the hashing mechanism as well the token creation with trivial ones. For obvious security reasons, do not use it in a production environment.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor115"/>How to do it…</h2>
<p>Let’s start by creating a <code>security.py</code> module in the project root folder where we are going to implement all tools used to secure our service. Then let's create a secured endpoint as follows.</p>
<ol>
<li>First, let’s create a dictionary containing a list of users with their usernames and passwords:<pre class="source-code">
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "hashed_password": "hashedsecret",
    },
    "janedoe": {
        "username": "janedoe",
        "hashed_password": "hashedsecret2",
    },
}</pre></li> <li>Passwords <a id="_idIndexMarker189"/>should<a id="_idIndexMarker190"/> not be stored in plain text, but encrypted or hashed. To demonstrate the feature, we fake the hashing mechanism by inserting <code>"hashed"</code> before the password string:<pre class="source-code">
def fakely_hash_password(password: str):
    return f"hashed{password}"</pre></li> <li>Let’s create the classes to handle the users and a function to retrieve the user from the <code>dict</code> database we created:<pre class="source-code">
class User(BaseModel):
    username: str
class UserInDB(User):
    hashed_password: str
def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)</pre></li> <li>Using a similar<a id="_idIndexMarker191"/> logic<a id="_idIndexMarker192"/> to what we’ve just used for hashing, let’s make a fake token generator and a fake token resolver:<pre class="source-code">
def fake_token_generator(user: UserInDB) -&gt; str:
    # This doesn't provide any security at all
    return f"tokenized{user.username}"
def fake_token_resolver(
    token: str
) -&gt; UserInDB | None:
    if token.startswith("tokenized"):
        user_id = token.removeprefix("tokenized")
        user = get_user(fake_users_db, user_id)
        return user</pre></li> <li>Now, let’s create a function to retrieve the user from the token. To this, we will make use of the <code>Depends</code> class to use dependency injection provided by FastAPI (see <a href="https://fastapi.tiangolo.com/tutorial/dependencies/">https://fastapi.tiangolo.com/tutorial/dependencies/</a>), with the <code>OAuthPasswordBearer</code> class to handle the token:<pre class="source-code">
from fastapi import Depends, HTTPException, status
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
def get_user_from_token(
    token: str = Depends(oauth2_scheme),
) -&gt; UserInDB:
    user = fake_token_resolver(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=(
                "Invalid authentication credentials"
            ),
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user</pre><p class="list-inset"><code>oauth2scheme</code> contains<a id="_idIndexMarker193"/> the <code>/token</code> URL<a id="_idIndexMarker194"/> endpoint that will be used by the interactive documentation to authenticate the browser.</p></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">We have used a dependency injection to retrieve the token from the <code>get_user_token</code> function with the <code>fastapi.Depends</code> object. A dependency injection pattern is not native to the Python language and it is strictly related to the FastAPI framework. In <a href="B21025_08.xhtml#_idTextAnchor262"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Features and Best Practices</em>, you will find a dedicated recipe about that called <em class="italic">Implementing </em><em class="italic">dependency injection</em>.</p>
<ol>
<li value="6">Let’s create<a id="_idIndexMarker195"/> the<a id="_idIndexMarker196"/> endpoint in the <code>main.py</code> module:<pre class="source-code">
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordRequestForm
from security import (
    UserInDB,
    fake_token_generator,
    fakely_hash_password,
    fake_users_db
)
@app.post("/token")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    user = UserInDB(**user_dict)
    hashed_password = fakely_hash_password(
        form_data.password
    )
    if not hashed_password == user.hashed_password:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    token = fake_token_generator(user)
    return {
        "access_token": token,
        "token_type": "bearer"
    }</pre><p class="list-inset">We now have all we <a id="_idIndexMarker197"/>need <a id="_idIndexMarker198"/>to create a secured endpoint with OAuth2 authentication.</p></li> <li>The endpoint we are going to create will return information about the current user from the token provided. If the token does not have authorization, it will return a <code>400</code> exception:<pre class="source-code">
from security import get_user_from_token
@app.get("/users/me", response_model=User)
def read_users_me(
    current_user: User = Depends(get_user_from_token),
):
    return current_user</pre><p class="list-inset">The endpoint we just created will be reachable only by allowed users.</p></li> </ol>
<p>Let's now test our secured endpoint. From the command line terminal at the project root folder level, spin up the server by running:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, open the browser, go to <code>http://localhost:8000/docs</code>, and you will notice the new <code>token</code> and <code>users/me</code> endpoints in the interactive documentation.</p>
<p>You might notice a little padlock icon on the <code>users/me</code> endpoint. If you click on it, you will see a form <a id="_idIndexMarker199"/>window <a id="_idIndexMarker200"/>that allows you to get the token and store it directly in your browser, so you don’t have to provide it each time you call the secured endpoint.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">You’ve just learned how to create a secured endpoint for your RESTful API. Now, try to secure some of the endpoints you created in the previous recipes.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>There’s more…</h2>
<p>With OAuth2, we can define a <strong class="bold">scope</strong> parameter, which is used to specify the level of access that an access <a id="_idIndexMarker201"/>token grants to a client application when it is used to access a protected resource. Scopes can be used to define what actions or resources the client application is allowed to perform or access on behalf of the user.</p>
<p>When a client requests authorization from the resource owner (user), it includes one or more scopes in the authorization request. In FastAPI, these scopes are represented as <code>dict</code>, where keys represent the scope’s name and the value is a description.</p>
<p>The authorization server then uses these scopes to determine the appropriate access controls and permissions to grant to the client application when issuing an access token.</p>
<p>It is not the purpose of this recipe to go into the details of implementing OAuth2 scopes in FastAPI. However, you<a id="_idIndexMarker202"/> can find practical examples on the official documentation page at the link: <a href="https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/">https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/</a>.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>See also</h2>
<p>You can check on how FastAPI integrates OAuth2 at the following link:</p>
<ul>
<li><em class="italic">Simple OAuth2 with Password and </em><em class="italic">Bearer</em>: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/</li>
</ul>
<p>Also, you can find more on dependency injection in FastAPI on the official documentation page:</p>
<ul>
<li><em class="italic">Dependencies</em>: <a href="https://fastapi.tiangolo.com/tutorial/dependencies/">https://fastapi.tiangolo.com/tutorial/dependencies/</a></li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor118"/>Documenting your API with Swagger and Redoc</h1>
<p>FastAPI <a id="_idIndexMarker203"/>automatically<a id="_idIndexMarker204"/> generates<a id="_idIndexMarker205"/> documentation<a id="_idIndexMarker206"/> for your API using <strong class="bold">Swagger UI</strong> and <strong class="bold">Redoc</strong>, when spinning the server.</p>
<p>This documentation is derived from your route functions and Pydantic models, making it incredibly beneficial for both development and consumption by frontend teams or API consumers.</p>
<p>In this recipe, we will see how to customize the documentation’s specific needs.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor119"/>Getting ready…</h2>
<p>By default, FastAPI provides two documentation interfaces:</p>
<ul>
<li><code>/docs</code> endpoint (e.g., <code>http://127.0.0.1:8000/docs</code>)</li>
<li><code>/redoc</code> endpoint (e.g., <code>http://127.0.0.1:8000/redoc</code>)</li>
</ul>
<p>These interfaces offer dynamic documentation where users can see and test the API endpoints and their details. However, both pieces of documentation can be modified.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor120"/>How to do it...</h2>
<p>FastAPI allows the customization of Swagger UI. You can add metadata, customize the look, and add additional documentation through the <code>FastAPI</code> class parameters.</p>
<p>You can enhance your API documentation by providing additional metadata such as <code>title</code>, <code>description</code>, and <code>version</code> to the <code>app</code> object in the <code>main.py</code> module:</p>
<pre class="source-code">
app = FastAPI(
<strong class="bold">    title="Task Manager API",</strong>
<strong class="bold">    description="This is a task management API",</strong>
<strong class="bold">    version="0.1.0",</strong>
)</pre> <p>This<a id="_idIndexMarker207"/> metadata <a id="_idIndexMarker208"/>will<a id="_idIndexMarker209"/> appear in <a id="_idIndexMarker210"/>both Swagger UI and Redoc documentation.</p>
<p>You can push things further by completely customizing your Swagger UI in case you need to expose it to a third user under certain conditions.</p>
<p>Let’s try to hide the <code>/token</code> endpoint from the documentation.</p>
<p>In this case, you can use the <code>utils</code>, module provided by FastAPI to retrieve the OpenAPI schema of the Swagger UI in a <code>dict</code> object as follows:</p>
<pre class="source-code">
from fastapi.openapi.utils import get_openapi
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Customized Title",
        version="2.0.0",
        description="This is a custom OpenAPI schema",
        routes=app.routes,
    )
    del openapi_schema["paths"]["/token"]
    app.openapi_schema = openapi_schema
    return app.openapi_schema
app = FastAPI(
    title="Task Manager API",
    description="This is a task management API",
    version="0.1.0",
)
app.openapi = custom_openapi</pre> <p>That’s all you<a id="_idIndexMarker211"/> need<a id="_idIndexMarker212"/> to<a id="_idIndexMarker213"/> customize <a id="_idIndexMarker214"/>your API documentation.</p>
<p>If you spin up the server with the <code>uvicorn main:app</code> command and go to one of the two documentation pages, the <code>/token</code> endpoint won’t appear anymore.</p>
<p>You are now able to customize your API documentation to elevate the way you present it to your customers.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor121"/>See also</h2>
<p>You find out more about FastAPI generation for metadata, features, and OpenAPI integration on the official documentation pages:</p>
<ul>
<li><em class="italic">Metadata and Docs </em><em class="italic">URLs</em>: <a href="https://fastapi.tiangolo.com/tutorial/metadata/">https://fastapi.tiangolo.com/tutorial/metadata/</a></li>
<li><em class="italic">FastAPI </em><em class="italic">Features</em>: <a href="https://fastapi.tiangolo.com/features/">https://fastapi.tiangolo.com/features/</a></li>
<li><em class="italic">Extending </em><em class="italic">OpenAPI</em>: <a href="https://fastapi.tiangolo.com/how-to/extending-openapi/">https://fastapi.tiangolo.com/how-to/extending-openapi/</a></li>
</ul>
</div>
</div></body></html>