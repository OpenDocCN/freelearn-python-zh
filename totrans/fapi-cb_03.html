<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer007">
<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor091"/>3</h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>Building RESTful APIs with FastAPI</h1>
<p>In this chapter, we delve into the essentials of <a id="_idIndexMarker152"/>building <strong class="bold">RESTful APIs</strong>. RESTful APIs are the backbone of web services, enabling applications to communicate and exchange <span class="No-Break">data efficiently.</span></p>
<p>You will build a RESTful API for a Task Manager application. The application will interact with a CSV file, although the typical approach for such applications would be to use a database such as SQL or NoSQL. This approach is unconventional and not recommended for most scenarios due to scalability and performance limitations. However, in certain contexts, particularly in legacy systems or when dealing with large volumes of structured data files, managing data through CSV can be a <span class="No-Break">practical solution.</span></p>
<p>Our Task Manager API will allow users to <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) tasks, each represented as a record in a CSV file. This example will provide insights into handling data in non-standard formats <span class="No-Break">within FastAPI.</span></p>
<p>We will see how to test the API’s endpoint. As your API grows, managing complex queries and filtering becomes essential. We’ll explore techniques to implement advanced query capabilities, enhancing the usability and flexibility of <span class="No-Break">your API.</span></p>
<p>Furthermore, we’ll tackle the important aspect of versioning your API. Versioning is key to evolving your API over time without breaking existing clients. You’ll learn strategies to manage API versions, ensuring backward compatibility and smooth transitions <span class="No-Break">for users.</span></p>
<p>Lastly, we’ll cover securing API with OAuth2, an industry-standard protocol for authorization. Security is paramount in API development, and you’ll gain practical experience in implementing authentication and protecting <span class="No-Break">your endpoints.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Creating <span class="No-Break">CRUD</span><span class="No-Break"> operations</span></li>
<li>Creating <span class="No-Break">RESTful endpoints</span></li>
<li>Testing your <span class="No-Break">RESTful API</span></li>
<li>Handling complex queries <span class="No-Break">and filtering</span></li>
<li>Versioning <span class="No-Break">your API</span></li>
<li>Securing your API <span class="No-Break">with OAuth2</span></li>
<li>Documenting your API with Swagger <span class="No-Break">and Redoc</span></li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>To fully engage with this chapter in our <em class="italic">FastAPI Cookbook</em> and effectively build RESTful APIs, you’ll need to have the following technologies and tools installed <span class="No-Break">and configured:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Make sure you have a Python version higher than 3.9 in <span class="No-Break">your environment.</span></li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all required dependencies. If you haven’t done it from the previous chapters, you can do so simply from your terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> <li><strong class="bold">Pytest</strong>: You can install this framework by running <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">$ pip install pytest</strong></pre></li> </ul>
<p>Note that it can be very useful to already have some knowledge of the Pytest framework to better follow the <em class="italic">Testing your RESTful </em><span class="No-Break"><em class="italic">API</em></span><span class="No-Break"> recipe.</span></p>
<p>The code used in the chapter is available on GitHub at the <span class="No-Break">address:</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>
<p>Feel free to follow along or consult it in case you <span class="No-Break">get stuck.</span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Creating CRUD operations</h1>
<p>This recipe will<a id="_idIndexMarker153"/> show you how to make the basic CRUD operations work with the CSV file that acts as <span class="No-Break">a database.</span></p>
<p>We will begin by making a draft for a simple list of tasks in CSV format and we will put the operations in a separate Python module. By the end of the recipe, you will have all the operations ready to be used by the <span class="No-Break">API’s endpoints.</span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>How to do it…</h2>
<p>Let’s start by creating a project root directory called <strong class="source-inline">task_manager_app</strong> to host our code base for <span class="No-Break">our application:</span></p>
<ol>
<li>Move into the root project folder and create a <strong class="source-inline">tasks.csv</strong> file, which we will use as a database and put a few <span class="No-Break">tasks inside<a id="_idTextAnchor096"/>:</span><pre class="source-code">
id,title,description,status
1,Task One,Description One,Incomplete
2,Task Two,Description Two,Ongoing</pre></li> <li>Then, create a file called <strong class="source-inline">models.py</strong>, containing the Pydantic models that we will use<a id="_idIndexMarker154"/> internally for the code. It will look like <span class="No-Break">the following:</span><pre class="source-code">
from pydantic import BaseModel
class Task(BaseModel):
    title: str
    description: str
    status: str
class TaskWithID(Task):
    id: int</pre><p class="list-inset">We created two separate classes for task objects because <strong class="source-inline">id</strong> won’t be used all along <span class="No-Break">the code.</span></p></li> <li>In a new file called <strong class="source-inline">operations.py</strong>, we will define the function that interacts with <span class="No-Break">our database.</span><p class="list-inset">We can start creating the <span class="No-Break">CRUD operation</span></p><p class="list-inset">Create a<a id="_idIndexMarker155"/> function to retrieve all the tasks from a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csv</strong></span><span class="No-Break"> file:</span></p><pre class="source-code">
import csv
from typing import Optional
from models import Task, TaskWithID
DATABASE_FILENAME = "tasks.csv"
column_fields = [
    "id", "title", "description", "status"
]
def read_all_tasks() -&gt; list[TaskWithID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskWithID(**row) for row in reader]</pre></li> <li>Now, we need to create a function to read a specific task based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break">:</span><pre class="source-code">
def read_task(task_id) -&gt; Optional[TaskWithID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        for row in reader:
            if int(row["id"]) == task_id:
                return TaskWithID(**row)</pre></li> <li>To write a task, we need a strategy to assign a new <strong class="source-inline">id</strong> to the task that will written into <span class="No-Break">the database.</span><p class="list-inset">A good strategy can be to implement a logic based on the IDs already present in the database, then write the task into our CSV file, and group both operations into a new function. We can split the create task operation into <span class="No-Break">three functions.</span></p><p class="list-inset">First, let’s<a id="_idIndexMarker156"/> create the function that retrieves the new ID based on the existing ones in <span class="No-Break">the database:</span></p><pre class="source-code">
def get_next_id():
    try:
        with open(DATABASE_FILENAME, "r") as csvfile:
            reader = csv.DictReader(csvfile)
            max_id = max(
                int(row["id"]) for row in reader
            )
            return max_id + 1
    except (FileNotFoundError, ValueError):
        return 1</pre><p class="list-inset">Then, we define the function to write the task with the ID in the <span class="No-Break">CSV file:</span></p><pre class="source-code">def write_task_into_csv(
    task: TaskWithID
):
    with open(
        DATABASE_FILENAME, mode="a", newline=""
    ) as file:
        writer = csv.DictWriter(
            file,
            fieldnames=column_fields,
        )
        writer.writerow(task.model_dump())</pre><p class="list-inset">After that, we can<a id="_idIndexMarker157"/> leverage these last two functions to define the function that creates <span class="No-Break">the task:</span></p><pre class="source-code">def create_task(
    task: Task
) -&gt; TaskWithID:
    id = get_next_id()
    task_with_id = TaskWithID(
        id=id, **task.model_dump()
    )
    write_task_into_csv(task_with_id)
    return task_with_id</pre></li> <li>Then, let’s create the function to modify <span class="No-Break">the task:</span><pre class="source-code">
def modify_task(
    id: int, task: dict
) -&gt; Optional[TaskWithID]:
    updated_task: Optional[TaskWithID] = None
    tasks = read_all_tasks()
    for number, task_ in enumerate(tasks):
        if task_.id == id:
            tasks[number] = (
                updated_task
            ) = task_.model_copy(update=task)
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfile,
            fieldnames=column_fields,
        )
        writer.writeheader()
        for task in tasks:
            writer.writerow(task.model_dump())
    if updated_task:
        return updated_task</pre></li> <li>Finally, let’s create<a id="_idIndexMarker158"/> the function to remove the task with a <span class="No-Break">specific </span><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break">:</span><pre class="source-code">
def remove_task(id: int) -&gt; bool:
    deleted_task: Optional[Task] = None
    tasks = read_all_tasks()
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfile,
            fieldnames=column_fields,
        )
        writer.writeheader()
        for task in tasks:
            if task.id == id:
                deleted_task = task
                continue
            writer.writerow(task.model_dump())
    if deleted_task:
        dict_task_without_id = (
            deleted_task.model_dump()
        )
        del dict_task_without_id["id"]
        return Task(**dict_task_wihtout_id)</pre></li> </ol>
<p>You’ve just created the<a id="_idIndexMarker159"/> basic CRUD operations. We are now ready to expose those operations through the <span class="No-Break">API endpoints.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>How it works...</h2>
<p>The structure of your API is fundamental in RESTful design. It involves defining endpoints (URIs) and associating them with HTTP methods to perform the <span class="No-Break">desired operations.</span></p>
<p>In our Task Management system, we’ll create endpoints to handle tasks, mirroring common CRUD operations. Here’s <span class="No-Break">an overview:</span></p>
<ul>
<li><strong class="source-inline">List Tasks</strong> (<strong class="source-inline">GET /tasks</strong>) retrieves a list of <span class="No-Break">all tasks</span></li>
<li><strong class="source-inline">Retrieve Task</strong> (<strong class="source-inline">GET /tasks/{task_id}</strong>) gets details of a <span class="No-Break">specific task</span></li>
<li><strong class="source-inline">Create Task</strong> (<strong class="source-inline">POST /task</strong>) adds a <span class="No-Break">new task</span></li>
<li><strong class="source-inline">Update Task</strong> (<strong class="source-inline">PUT /tasks/{task_id}</strong>) modifies an <span class="No-Break">existing task</span></li>
<li><strong class="source-inline">Delete Task</strong> (<strong class="source-inline">DELETE /tasks/{task_id}</strong>) removes <span class="No-Break">a task</span></li>
</ul>
<p>Each endpoint represents a specific function in the API, clearly defined and purpose driven. FastAPI’s routing <a id="_idIndexMarker160"/>system allows us to map these operations to Python <span class="No-Break">functions easily.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">Try to write your unit tests for each one of the CRUD operations. If you follow along with the GitHub repository, you can find the tests in the <span class="No-Break"><strong class="source-inline">Chapter03/task_manager_rest_api/test_operations.py</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor098"/>Creating RESTful Endpoints</h1>
<p>Now, we will create <a id="_idIndexMarker161"/>the routes to expose each of the CRUD operations with a specific endpoint. In this recipe, we will see how FastAPI leverages Python type annotations to define expected request and response data types, streamlining the process of validation and <span class="No-Break">serializing data.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Getting ready…</h2>
<p>Before starting the recipe, make sure you know how to set up your local environment and create a basic FastAPI server. You can review it in the <em class="italic">Creating a new FastAPI project</em> and <em class="italic">Understanding FastAPI basics</em> recipes in <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps </em><span class="No-Break"><em class="italic">with FastAPI</em></span><span class="No-Break">.</span></p>
<p>Also, we will use the CRUD operations created in the <span class="No-Break">previous recipe.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor100"/>How to do it…</h2>
<p>Let’s create a <strong class="source-inline">main.py</strong> file in the project root folder to code the server with the endpoints. FastAPI simplifies the implementation of different HTTP methods, aligning them with the corresponding <span class="No-Break">CRUD operations.</span></p>
<p>Let’s now write the endpoints for <span class="No-Break">each operation:</span></p>
<ol>
<li>Create the server with the endpoint to list all the tasks by using the <span class="No-Break"><strong class="source-inline">read_all_tasks</strong></span><span class="No-Break"> operation:</span><pre class="source-code">
from fastapi import FastAPI, HTTPException
from models import (
    Task,
    TaskWithID,
)
from operations import read_all_tasks
app = FastAPI()
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks():
    tasks = read_all_tasks()
    return tasks</pre></li> <li>Now, let’s write<a id="_idIndexMarker162"/> the endpoint to read a specific task based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break">:</span><pre class="source-code">
@app.get("/task/{task_id}")
def get_task(task_id: int):
    task = read_task(task_id)
    if not task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return task</pre></li> <li>The endpoint to add a task will be <span class="No-Break">as follows:</span><pre class="source-code">
from operations import create_task
@app.post("/task", response_model=TaskWithID)
def add_task(task: Task):
    return create_task(task)</pre></li> <li>To update the task, we can modify each field (<strong class="source-inline">description</strong>, <strong class="source-inline">status</strong>, or <strong class="source-inline">title</strong>). To do this, we <a id="_idIndexMarker163"/>create a specific model to be used in the body called <strong class="source-inline">UpdateTask</strong>. The endpoint will look <span class="No-Break">like this:</span><pre class="source-code">
from operations import modify_task
class UpdateTask(BaseModel):
    title: str | None = None
    description: str | None = None
    status: str | None = None
@app.put("/task/{task_id}", response_model=TaskWithID)
def update_task(
    task_id: int, task_update: UpdateTask
):
    modified = modify_task(
        task_id,
        task_update.model_dump(exclude_unset=True),
    )
    if not modified:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return modified</pre></li> <li>Finally, here<a id="_idIndexMarker164"/> is the endpoint to delete <span class="No-Break">a task:</span><pre class="source-code">
from operations import remove_task
@app.delete("/task/{task_id}", response_model=Task)
def delete_task(task_id: int):
    removed_task = remove_task(task_id)
    if not removed_task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return removed_task</pre></li> </ol>
<p>You have just implemented the operations to interact with the CSV file used as <span class="No-Break">a database.</span></p>
<p>From a command terminal at the project root folder level, spin up the server with the <span class="No-Break"><strong class="source-inline">uvicorn</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>In the browser, go to <strong class="source-inline">http://localhost:8000/docs</strong> and you will see the endpoints of your RESTful API that you <span class="No-Break">just made.</span></p>
<p>You can experiment <a id="_idIndexMarker165"/>by creating some tasks, then listing them, updating them, and deleting some of them directly with the <span class="No-Break">interactive documentation.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Testing your RESTful API</h1>
<p>Testing is a critical <a id="_idIndexMarker166"/>part of API development. In FastAPI, you can use various testing frameworks such as <strong class="source-inline">pytest</strong> to write tests for your <span class="No-Break">API endpoints.</span></p>
<p>In this recipe, we are going to write unit tests for each of the endpoints we <span class="No-Break">created earlier.</span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Getting ready…</h2>
<p>If not done yet, ensure you have <strong class="source-inline">pytest</strong> installed in your environment <span class="No-Break">by running</span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install pytest</pre> <p>It’s a good practice in testing to use a dedicated database to avoid interaction with the production one. To accomplish this, we will create a test fixture that generates the database before <span class="No-Break">each test.</span></p>
<p>We will define this in a <strong class="source-inline">conftest.py</strong> module so that the fixture is applied to all tests under the project’s root folder. Let’s create the module in the project root folder and start by defining a list of test tasks and the name of the CSV file used for <span class="No-Break">the tests:</span></p>
<pre class="source-code">
TEST_DATABASE_FILE = "test_tasks.csv"
TEST_TASKS_CSV = [
    {
        "id": "1",
        "title": "Test Task One",
        "description": "Test Description One",
        "status": "Incomplete",
    },
    {
        "id": "2",
        "title": "Test Task Two",
        "description": "Test Description Two",
        "status": "Ongoing",
    },
]
TEST_TASKS = [
    {**task_json, "id": int(task_json["id"])}
    for task_json in TEST_TASKS_CSV
]</pre> <p>We can now create a fixture that will be used for all the tests. This fixture will set up the test database before <a id="_idIndexMarker167"/>each test <span class="No-Break">function execution.</span></p>
<p>We can achieve this by passing the <strong class="source-inline">autouse=True</strong> argument to the <strong class="source-inline">pytest.fixture</strong> decorator, which indicates that the feature will run before every <span class="No-Break">single test:</span></p>
<pre class="source-code">
import csv
import os
from pathlib import Path
from unittest.mock import patch
import pytest
@pytest.fixture(autouse=True)
def create_test_database():
    database_file_location = str(
        Path(__file__).parent / TEST_DATABASE_FILE
    )
    with patch(
        "operations.DATABASE_FILENAME",
        database_file_location,
    ) as csv_test:
        with open(
            database_file_location, mode="w", newline=""
        ) as csvfile:
            writer = csv.DictWriter(
                csvfile,
                fieldnames=[
                    "id",
                    "title",
                    "description",
                    "status",
                ],
            )
            writer.writeheader()
            writer.writerows(TEST_TASKS_CSV)
            print("")
        yield csv_test
        os.remove(database_file_location)</pre> <p>Since the fixture is defined in a <strong class="source-inline">conftest.py</strong> module, each test module will automatically <span class="No-Break">import it.</span></p>
<p>Now, we can proceed with creating the actual unit test functions for the endpoints created in the <span class="No-Break">previous recipe.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>How to do it...</h2>
<p>To test the endpoints, FastAPI provides a specific <strong class="source-inline">TestClient</strong> class that allows the testing of the <a id="_idIndexMarker168"/>endpoints without running <span class="No-Break">the server.</span></p>
<p>In a new module called <strong class="source-inline">test_main.py</strong>, let’s define our <span class="No-Break">test client:</span></p>
<pre class="source-code">
from main import app
from fastapi.testclient import TestClient
client = TestClient(app)</pre> <p>We can create the tests for each endpoint <span class="No-Break">as follows.</span></p>
<ol>
<li>Let’s start with the <strong class="source-inline">GET /tasks</strong> endpoint, which lists all the tasks in <span class="No-Break">the database:</span><pre class="source-code">
from conftest import TEST_TASKS
def test_endpoint_read_all_tasks():
    response = client.get("/tasks")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS</pre><p class="list-inset">We are asserting the response’s status code and the <span class="No-Break"><strong class="source-inline">json</strong></span><span class="No-Break"> body.</span></p></li> <li>As easy as that, we can go on by creating the test for <strong class="source-inline">GET /tasks/{task_id}</strong> to read a task with a <span class="No-Break">specific </span><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break">:</span><pre class="source-code">
def test_endpoint_get_task():
    response = client.get("/task/1")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS[0]
    response = client.get("/task/5")
    assert response.status_code == 404</pre><p class="list-inset">Besides the <strong class="source-inline">200</strong> status<a id="_idIndexMarker169"/> code for an existing task, we also asserted the status code is equal to <strong class="source-inline">404</strong> when the task does not exist in <span class="No-Break">the database.</span></p></li> <li>In a similar way, we can test the <strong class="source-inline">POST /task</strong> endpoint to add a new task into the database by asserting the new assigned <strong class="source-inline">id</strong> for <span class="No-Break">the task:</span><pre class="source-code">
from operations import read_all_tasks
def test_endpoint_create_task():
    task = {
        "title": "To Define",
        "description": "will be done",
        "status": "Ready",
    }
    response = client.post("/task", json=task)
    assert response.status_code == 200
    assert response.json() == {**task, "id": 3}
    assert len(read_all_tasks()) == 3</pre></li> <li>The test for the <strong class="source-inline">PUT /tasks/{task_id}</strong> endpoint to modify a task will then be <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker170"/></span><span class="No-Break"> following:</span><pre class="source-code">
from operations import read_task
def test_endpoint_modify_task():
    updated_fields = {"status": "Finished"}
    response = client.put(
        "/task/2", json=updated_fields
    )
    assert response.status_code == 200
    assert response.json() == {
         *TEST_TASKS[1],
         *updated_fields,
    }
    response = client.put(
        "/task/3", json=updated_fields
    )
    assert response.status_code == 404</pre></li> <li>Finally, we test the <strong class="source-inline">DELETE /tasks/{task_id}</strong> endpoint to delete <span class="No-Break">a task:</span><pre class="source-code">
def test_endpoint_delete_task():
    response = client.delete("/task/2")
    assert response.status_code == 200
    expected_response = TEST_TASKS[1]
    del expected_response["id"]
    assert response.json() == expected_response
    assert read_task(2) is None</pre></li> </ol>
<p>You’ve just <a id="_idIndexMarker171"/>written all the unit tests for each of the <span class="No-Break">API endpoints.</span></p>
<p>You can now run the tests from the project root folder by running in the terminal, or with the GUI support of your <span class="No-Break">favorite editor:</span></p>
<pre class="console">
$ pytest .</pre> <p>Pytest will collect all the tests and run them. If everything is correctly done, you will see a message that says you got a 100% score in the output of the console if you have written the <span class="No-Break">tests correctly.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor104"/>See also</h2>
<p>You can check test fixtures<a id="_idIndexMarker172"/> in the <span class="No-Break">Pytest documentation:</span></p>
<ul>
<li><em class="italic">Pytest Fixtures </em><span class="No-Break"><em class="italic">Reference</em></span><span class="No-Break">: </span><a href="https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml"><span class="No-Break">https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml</span></a></li>
</ul>
<p>You can dig into FastAPI testing<a id="_idIndexMarker173"/> tools and the <strong class="source-inline">TestClient</strong> API in the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">Testing</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/testing/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/testing/</span></a></li>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">TestClient</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/reference/testclient/"><span class="No-Break">https://fastapi.tiangolo.com/reference/testclient/</span></a></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor105"/>Handling complex queries and filtering</h1>
<p>In any RESTful API, providing <a id="_idIndexMarker174"/>the functionality to filter data based on certain criteria is essential. In this recipe, we’ll enhance our Task Manager API to allow users to filter tasks based on different parameters and create a <span class="No-Break">search endpoint.</span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Getting ready…</h2>
<p>The filtering functionality will be implemented in the existing <strong class="source-inline">GET /tasks</strong> endpoint to show how to overcharge an endpoint, while the search functionality will be shown on a brand-new endpoint. Make sure you have at least the CRUD operations already in place <span class="No-Break">before continuing.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>How to do it...</h2>
<p>We will start by overcharging <strong class="source-inline">GET /tasks</strong> endpoint with filters. We modify the endpoint to accept two query parameters: <strong class="source-inline">status</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">title</strong></span><span class="No-Break">.</span></p>
<p>The endpoint will then look like <span class="No-Break">the following:</span></p>
<pre class="source-code">
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks(
<strong class="bold">    status: Optional[str] = None,</strong>
<strong class="bold">    title: Optional[str] = None,</strong>
):
    tasks = read_all_tasks()
<strong class="bold">    if status:</strong>
<strong class="bold">        tasks = [</strong>
<strong class="bold">            task</strong>
<strong class="bold">            for task in tasks</strong>
<strong class="bold">            if task.status == status</strong>
<strong class="bold">        ]</strong>
<strong class="bold">    if title:</strong>
<strong class="bold">        tasks = [</strong>
<strong class="bold">            task for task in tasks if task.title == title</strong>
<strong class="bold">        ]</strong>
    return tasks</pre> <p>The two parameters can be optionally specified to filter the tasks that match <span class="No-Break">their value.</span></p>
<p>Next, we implement a search functionality. Beyond basic filtering, implementing a search functionality<a id="_idIndexMarker175"/> can significantly improve the usability of an API. We’ll add a search feature that allows users to find tasks based on a keyword present in the title or description in a <span class="No-Break">new endpoint:</span></p>
<pre class="source-code">
@app.get("/tasks/search", response_model=list[TaskWithID])
def search_tasks(keyword: str):
    tasks = read_all_tasks()
    filtered_tasks = [
        task
        for task in tasks
        if keyword.lower()
        in (task.title + task.description).lower()
    ]
    return filtered_tasks</pre> <p>In the <strong class="source-inline">search_tasks</strong> endpoint, the function filters tasks to include only those where the keyword appears in either the title or <span class="No-Break">the description.</span></p>
<p>To start the server as usual, run this command from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, go to the interactive documentation address at <strong class="source-inline">http://localhost:8000/docs</strong>, and you will see the new endpoint we’ve <span class="No-Break">just made.</span></p>
<p>Play around by<a id="_idIndexMarker176"/> specifying some keywords that could be in the title or the description of one of <span class="No-Break">your tasks.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor108"/>Versioning your API</h1>
<p><strong class="bold">API versioning</strong> is <a id="_idIndexMarker177"/>essential in maintaining<a id="_idIndexMarker178"/> and evolving web services without disrupting the existing users. It allows developers to introduce changes, improvements, or even breaking changes while providing backward compatibility. In this recipe, we will implement versioning in our Task <span class="No-Break">Manager API.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Getting ready…</h2>
<p>To follow the recipe, you will need to have endpoints already defined. If you don’t have them, you can first check the <em class="italic">Creating RESTful </em><span class="No-Break"><em class="italic">endpoints</em></span><span class="No-Break"> recipe.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor110"/>How to do it...</h2>
<p>There are several strategies for API versioning. We will use the most common approach, URL path versioning, for <span class="No-Break">our API.</span></p>
<p>Let’s consider that we want to improve the task information by adding a new <strong class="source-inline">str</strong> field called <strong class="source-inline">priority</strong> that is set to <strong class="source-inline">"lower"</strong> by default. Let's do it through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s create a <strong class="source-inline">TaskV2</strong> object class in the <span class="No-Break"><strong class="source-inline">models.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from typing import Optional
class TaskV2(BaseModel):
    title: str
    description: str
    status: str
    priority: str | None = "lower"
class TaskV2WithID(TaskV2):
    id: int</pre></li> <li>In the <strong class="source-inline">operations.py</strong> module, let’s create a new function called <strong class="source-inline">read_all_tasks_v2</strong>, which<a id="_idIndexMarker179"/> reads <a id="_idIndexMarker180"/>all the tasks, and add the <span class="No-Break"><strong class="source-inline">priority</strong></span><span class="No-Break"> field:</span><pre class="source-code">
from models import TaskV2WIthID
def read_all_tasks_v2() -&gt; list[TaskV2WIthID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskV2WIthID(**row) for row in reader]</pre></li> <li>We have now all we need to create version two of <strong class="source-inline">read_all_tasks</strong> function. We will do this in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from models import TaskV2WithID
@app.get(
    "/v2/tasks",
    response_model=list[TaskV2WithID]
)
def get_tasks_v2():
    tasks = read_all_tasks_v2()
    return tasks</pre></li> </ol>
<p>You’ve just created version two of the endpoint. In this way, you can develop and improve your<a id="_idIndexMarker181"/> API with several versions of <a id="_idIndexMarker182"/><span class="No-Break">your endpoint.</span></p>
<p>To test it, let's modify our <strong class="source-inline">tasks.csv</strong> file by manually adding the new field to test the <span class="No-Break">new endpoint:</span></p>
<pre class="source-code">
id,title,description,status,<strong class="bold">priority</strong>
1,Task One,Description One,Incomplete
2,Task Two,Description Two,Ongoing,<strong class="bold">higher</strong></pre> <p>Start the server once more from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Now, the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong> will show the new <strong class="source-inline">GET /v2/tasks</strong> endpoint to list all the tasks in version <span class="No-Break">2 mode.</span></p>
<p>Check that the endpoint lists the tasks with the new <strong class="source-inline">priority</strong> field and that the old <strong class="source-inline">GET /tasks</strong> is still working <span class="No-Break">as expected.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">You might have noticed that using a CSV file as a database might not be the most reliable solution. If the process crashes during an update or removal, you can lose all of the data. So, improve the API with a newer version of the endpoints that use operational functions that interact with an <span class="No-Break">SQLite database.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>There’s more…</h2>
<p>When you version<a id="_idIndexMarker183"/> an API, you are essentially providing a way to differentiate between different releases or versions of your API, allowing clients to choose which version they want to <span class="No-Break">interact with.</span></p>
<p>Besides the URL-based approach<a id="_idIndexMarker184"/> that we used in the recipe, there are other common approaches to API versioning, such as <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Query parameter versioning</strong>: Version information is passed as a query parameter in the API request. For example, see <span class="No-Break">the following:</span><pre class="source-code">
https://api.example.com/resource?version=1</pre><p class="list-inset">This method keeps the base URL uniform <span class="No-Break">across versions.</span></p></li> <li><strong class="bold">Header versioning</strong>: The version is specified in a custom header of the <span class="No-Break">HTTP request:</span><pre class="source-code">
GET /resource HTTP/1.1
Host: api.example.com
X-API-Version: 1</pre><p class="list-inset">This keeps the URL clean but requires clients to explicitly set the version in <span class="No-Break">their requests.</span></p></li> <li><strong class="bold">Consumer-based versioning</strong>: This strategy allows customers to choose the version they need. The version available at their first interaction is saved with their details and used in all future interactions unless they <span class="No-Break">make changes.</span></li>
</ul>
<p>Furthermore, it can be relevant<a id="_idIndexMarker185"/> to use <strong class="bold">semantic versioning</strong> where version numbers follow the semantic versioning format (<strong class="source-inline">MAJOR.MINOR.PATCH</strong>). Changes in the <strong class="source-inline">MAJOR</strong> version indicate incompatible API changes, while <strong class="source-inline">MINOR</strong> and <strong class="source-inline">PATCH</strong> versions indicate <span class="No-Break">backward-compatible changes.</span></p>
<p>Versioning allows API providers to introduce changes (such as adding new features, modifying existing behavior, or deprecating endpoints and sunset policies) without breaking existing <span class="No-Break">client integrations.</span></p>
<p>It also gives consumers control over when and how they adopt new versions, minimizing disruptions and maintaining stability in the <span class="No-Break">API ecosystem.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>See also</h2>
<p>You can have a look at an interesting <a id="_idIndexMarker186"/>article from the Postman blog on API <span class="No-Break">versioning strategies:</span></p>
<ul>
<li><em class="italic">Postman Blog API </em><span class="No-Break"><em class="italic">Versioning</em></span><span class="No-Break">: </span><a href="https://www.postman.com/api-platform/api-versioning/"><span class="No-Break">https://www.postman.com/api-platform/api-versioning/</span></a></li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor113"/>Securing your API with OAuth2</h1>
<p>In web applications, securing <a id="_idIndexMarker187"/>endpoints from<a id="_idIndexMarker188"/> unauthorized users is crucial. <strong class="bold">OAuth2</strong> is a common authorization framework that enables applications to be accessed by user accounts with restricted permissions. It works by issuing tokens instead of credentials. This recipe will show how to use OAuth2 in our Task Manager API to <span class="No-Break">protect endpoints.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor114"/>Getting ready…</h2>
<p>FastAPI provides support for OAuth2 with a password, including the use of external tokens. Data compliance regulations require that passwords are not stored in plain text. Instead, a usual method is to store the outcome of the hashing operation, which changes the plain text into a string that is not readable by humans and cannot <span class="No-Break">be reversed.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">With the only purpose of showing the functionality, we will fake the hashing mechanism as well the token creation with trivial ones. For obvious security reasons, do not use it in a <span class="No-Break">production environment.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor115"/>How to do it…</h2>
<p>Let’s start by creating a <strong class="source-inline">security.py</strong> module in the project root folder where we are going to implement all tools used to secure our service. Then let's create a secured endpoint <span class="No-Break">as follows.</span></p>
<ol>
<li>First, let’s create a dictionary containing a list of users with their usernames <span class="No-Break">and passwords:</span><pre class="source-code">
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "hashed_password": "hashedsecret",
    },
    "janedoe": {
        "username": "janedoe",
        "hashed_password": "hashedsecret2",
    },
}</pre></li> <li>Passwords <a id="_idIndexMarker189"/>should<a id="_idIndexMarker190"/> not be stored in plain text, but encrypted or hashed. To demonstrate the feature, we fake the hashing mechanism by inserting <strong class="source-inline">"hashed"</strong> before the <span class="No-Break">password string:</span><pre class="source-code">
def fakely_hash_password(password: str):
    return f"hashed{password}"</pre></li> <li>Let’s create the classes to handle the users and a function to retrieve the user from the <strong class="source-inline">dict</strong> database <span class="No-Break">we created:</span><pre class="source-code">
class User(BaseModel):
    username: str
class UserInDB(User):
    hashed_password: str
def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)</pre></li> <li>Using a similar<a id="_idIndexMarker191"/> logic<a id="_idIndexMarker192"/> to what we’ve just used for hashing, let’s make a fake token generator and a fake <span class="No-Break">token resolver:</span><pre class="source-code">
def fake_token_generator(user: UserInDB) -&gt; str:
    # This doesn't provide any security at all
    return f"tokenized{user.username}"
def fake_token_resolver(
    token: str
) -&gt; UserInDB | None:
    if token.startswith("tokenized"):
        user_id = token.removeprefix("tokenized")
        user = get_user(fake_users_db, user_id)
        return user</pre></li> <li>Now, let’s create a function to retrieve the user from the token. To this, we will make use of the <strong class="source-inline">Depends</strong> class to use dependency injection provided by FastAPI (see <a href="https://fastapi.tiangolo.com/tutorial/dependencies/">https://fastapi.tiangolo.com/tutorial/dependencies/</a>), with the <strong class="source-inline">OAuthPasswordBearer</strong> class to handle <span class="No-Break">the token:</span><pre class="source-code">
from fastapi import Depends, HTTPException, status
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
def get_user_from_token(
    token: str = Depends(oauth2_scheme),
) -&gt; UserInDB:
    user = fake_token_resolver(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=(
                "Invalid authentication credentials"
            ),
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user</pre><p class="list-inset"><strong class="source-inline">oauth2scheme</strong> contains<a id="_idIndexMarker193"/> the <strong class="source-inline">/token</strong> URL<a id="_idIndexMarker194"/> endpoint that will be used by the interactive documentation to authenticate <span class="No-Break">the browser.</span></p></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">We have used a dependency injection to retrieve the token from the <strong class="source-inline">get_user_token</strong> function with the <strong class="source-inline">fastapi.Depends</strong> object. A dependency injection pattern is not native to the Python language and it is strictly related to the FastAPI framework. In <a href="B21025_08.xhtml#_idTextAnchor262"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Advanced Features and Best Practices</em>, you will find a dedicated recipe about that called <em class="italic">Implementing </em><span class="No-Break"><em class="italic">dependency injection</em></span><span class="No-Break">.</span></p>
<ol>
<li value="6">Let’s create<a id="_idIndexMarker195"/> the<a id="_idIndexMarker196"/> endpoint in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordRequestForm
from security import (
    UserInDB,
    fake_token_generator,
    fakely_hash_password,
    fake_users_db
)
@app.post("/token")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    user = UserInDB(**user_dict)
    hashed_password = fakely_hash_password(
        form_data.password
    )
    if not hashed_password == user.hashed_password:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    token = fake_token_generator(user)
    return {
        "access_token": token,
        "token_type": "bearer"
    }</pre><p class="list-inset">We now have all we <a id="_idIndexMarker197"/>need <a id="_idIndexMarker198"/>to create a secured endpoint with <span class="No-Break">OAuth2 authentication.</span></p></li> <li>The endpoint we are going to create will return information about the current user from the token provided. If the token does not have authorization, it will return a <span class="No-Break"><strong class="source-inline">400</strong></span><span class="No-Break"> exception:</span><pre class="source-code">
from security import get_user_from_token
@app.get("/users/me", response_model=User)
def read_users_me(
    current_user: User = Depends(get_user_from_token),
):
    return current_user</pre><p class="list-inset">The endpoint we just created will be reachable only by <span class="No-Break">allowed users.</span></p></li> </ol>
<p>Let's now test our secured endpoint. From the command line terminal at the project root folder level, spin up the server <span class="No-Break">by running:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, open the browser, go to <strong class="source-inline">http://localhost:8000/docs</strong>, and you will notice the new <strong class="source-inline">token</strong> and <strong class="source-inline">users/me</strong> endpoints in the <span class="No-Break">interactive documentation.</span></p>
<p>You might notice a little padlock icon on the <strong class="source-inline">users/me</strong> endpoint. If you click on it, you will see a form <a id="_idIndexMarker199"/>window <a id="_idIndexMarker200"/>that allows you to get the token and store it directly in your browser, so you don’t have to provide it each time you call the <span class="No-Break">secured endpoint.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">You’ve just learned how to create a secured endpoint for your RESTful API. Now, try to secure some of the endpoints you created in the <span class="No-Break">previous recipes.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>There’s more…</h2>
<p>With OAuth2, we can define a <strong class="bold">scope</strong> parameter, which is used to specify the level of access that an access <a id="_idIndexMarker201"/>token grants to a client application when it is used to access a protected resource. Scopes can be used to define what actions or resources the client application is allowed to perform or access on behalf of <span class="No-Break">the user.</span></p>
<p>When a client requests authorization from the resource owner (user), it includes one or more scopes in the authorization request. In FastAPI, these scopes are represented as <strong class="source-inline">dict</strong>, where keys represent the scope’s name and the value is <span class="No-Break">a description.</span></p>
<p>The authorization server then uses these scopes to determine the appropriate access controls and permissions to grant to the client application when issuing an <span class="No-Break">access token.</span></p>
<p>It is not the purpose of this recipe to go into the details of implementing OAuth2 scopes in FastAPI. However, you<a id="_idIndexMarker202"/> can find practical examples on the official documentation page at the <span class="No-Break">link: </span><a href="https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>See also</h2>
<p>You can check on how FastAPI integrates OAuth2 at the <span class="No-Break">following link:</span></p>
<ul>
<li><em class="italic">Simple OAuth2 with Password and </em><span class="No-Break"><em class="italic">Bearer</em></span><span class="No-Break">: </span><span class="No-Break">https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/</span></li>
</ul>
<p>Also, you can find more on dependency injection in FastAPI on the official <span class="No-Break">documentation page:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">Dependencies</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/dependencies/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/dependencies/</span></a></li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor118"/>Documenting your API with Swagger and Redoc</h1>
<p>FastAPI <a id="_idIndexMarker203"/>automatically<a id="_idIndexMarker204"/> generates<a id="_idIndexMarker205"/> documentation<a id="_idIndexMarker206"/> for your API using <strong class="bold">Swagger UI</strong> and <strong class="bold">Redoc</strong>, when spinning <span class="No-Break">the server.</span></p>
<p>This documentation is derived from your route functions and Pydantic models, making it incredibly beneficial for both development and consumption by frontend teams or <span class="No-Break">API consumers.</span></p>
<p>In this recipe, we will see how to customize the documentation’s <span class="No-Break">specific needs.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor119"/>Getting ready…</h2>
<p>By default, FastAPI provides two <span class="No-Break">documentation interfaces:</span></p>
<ul>
<li><strong class="bold">Swagger UI</strong>: Accessible at <strong class="source-inline">/docs</strong> endpoint (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">http://127.0.0.1:8000/docs</strong></span><span class="No-Break">)</span></li>
<li><strong class="bold">Redoc</strong>: Accessible at <strong class="source-inline">/redoc</strong> endpoint (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">http://127.0.0.1:8000/redoc</strong></span><span class="No-Break">)</span></li>
</ul>
<p>These interfaces offer dynamic documentation where users can see and test the API endpoints and their details. However, both pieces of documentation can <span class="No-Break">be modified.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor120"/>How to do it...</h2>
<p>FastAPI allows the customization of Swagger UI. You can add metadata, customize the look, and add additional documentation through the <strong class="source-inline">FastAPI</strong> <span class="No-Break">class parameters.</span></p>
<p>You can enhance your API documentation by providing additional metadata such as <strong class="source-inline">title</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">version</strong> to the <strong class="source-inline">app</strong> object in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
app = FastAPI(
<strong class="bold">    title="Task Manager API",</strong>
<strong class="bold">    description="This is a task management API",</strong>
<strong class="bold">    version="0.1.0",</strong>
)</pre> <p>This<a id="_idIndexMarker207"/> metadata <a id="_idIndexMarker208"/>will<a id="_idIndexMarker209"/> appear in <a id="_idIndexMarker210"/>both Swagger UI and <span class="No-Break">Redoc documentation.</span></p>
<p>You can push things further by completely customizing your Swagger UI in case you need to expose it to a third user under <span class="No-Break">certain conditions.</span></p>
<p>Let’s try to hide the <strong class="source-inline">/token</strong> endpoint from <span class="No-Break">the documentation.</span></p>
<p>In this case, you can use the <strong class="source-inline">utils</strong>, module provided by FastAPI to retrieve the OpenAPI schema of the Swagger UI in a <strong class="source-inline">dict</strong> object <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi.openapi.utils import get_openapi
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Customized Title",
        version="2.0.0",
        description="This is a custom OpenAPI schema",
        routes=app.routes,
    )
    del openapi_schema["paths"]["/token"]
    app.openapi_schema = openapi_schema
    return app.openapi_schema
app = FastAPI(
    title="Task Manager API",
    description="This is a task management API",
    version="0.1.0",
)
app.openapi = custom_openapi</pre> <p>That’s all you<a id="_idIndexMarker211"/> need<a id="_idIndexMarker212"/> to<a id="_idIndexMarker213"/> customize <a id="_idIndexMarker214"/>your <span class="No-Break">API documentation.</span></p>
<p>If you spin up the server with the <strong class="source-inline">uvicorn main:app</strong> command and go to one of the two documentation pages, the <strong class="source-inline">/token</strong> endpoint won’t <span class="No-Break">appear anymore.</span></p>
<p>You are now able to customize your API documentation to elevate the way you present it to your <span class="No-Break">customers.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor121"/>See also</h2>
<p>You find out more about FastAPI generation for metadata, features, and OpenAPI integration on the official <span class="No-Break">documentation pages:</span></p>
<ul>
<li><em class="italic">Metadata and Docs </em><span class="No-Break"><em class="italic">URLs</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/metadata/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/metadata/</span></a></li>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">Features</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/features/"><span class="No-Break">https://fastapi.tiangolo.com/features/</span></a></li>
<li><em class="italic">Extending </em><span class="No-Break"><em class="italic">OpenAPI</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/how-to/extending-openapi/"><span class="No-Break">https://fastapi.tiangolo.com/how-to/extending-openapi/</span></a></li>
</ul>
</div>
</div></body></html>