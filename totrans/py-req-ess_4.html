<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Mocking HTTP Requests Using HTTPretty</h1></div></div></div><p>With the <code class="literal">Requests</code> module, we gained the means to open URLs, post data, and get data from web services. Let us take an instance of building an application, which uses a RESTful API and unfortunately, the API on which the server is running is down. Even though we achieved interaction with the web using Requests, we failed this time because we got no response from the server's side. This condition may leave us irked and blocked from our progress, as we found no way of testing our code any further.</p><p>So, there came this idea of creating an HTTP request mock tool, which can serve us by mocking the web server on the client side. Even though HTTPretty is no way directly connected with Requests, we would like to introduce a mock tool which would help us in the previously mentioned case.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>HTTP mock tool helps to mock web services by faking requests.</p></div></div><p>We'll look at the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding HTTPretty</li><li class="listitem" style="list-style-type: disc">Installing HTTPretty</li><li class="listitem" style="list-style-type: disc">Usage in detail</li><li class="listitem" style="list-style-type: disc">Setting headers</li><li class="listitem" style="list-style-type: disc">Working with responses</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Understanding HTTPretty</h1></div></div></div><p>HTTPretty is an <a class="indexterm" id="id130"/>HTTP client mock library for Python. The basic idea of HTTPretty is inspired by Ruby's FakeWeb, which is well known to the people from the Ruby community. HTTPretty re-implements the HTTP protocol by mimicking requests and responses.</p><p>Essentially, HTTPretty works on socket level, which gives it the inward virtue of working with most of the HTTP client libraries and it is more specifically battle tested against HTTP client libraries like <code class="literal">Requests</code>, <code class="literal">httplib2</code> and <code class="literal">urlib2</code>. So, we can mock the interactions from our Request library without any difficulty.</p><p>Here are the two cases in which HTTPretty comes to the rescue:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The condition <a class="indexterm" id="id131"/>in which the API server is down</li><li class="listitem" style="list-style-type: disc">The condition in which the API content has changed</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Installing HTTPretty</h1></div></div></div><p>We can install HTTPretty <a class="indexterm" id="id132"/>effortlessly from <strong>Python Package Index</strong> (<strong>PyPi</strong>).</p><div><pre class="programlisting"><strong>pip install HTTPretty</strong>
</pre></div><p>We will be learning <a class="indexterm" id="id133"/>many more things with examples in this process of getting used to HTTPretty; And in this course of journey we will be using libraries like mock, sure and obviously Requests. Here we go, with those installations:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; pip install requests sure mock</strong>
</pre></div><p>Let us take a peek at what exactly those packages deal with:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mock</code>: It is a testing library which allows us to replace parts of the system under test with mock objects</li><li class="listitem" style="list-style-type: disc"><code class="literal">sure</code>: It is a Python library which is used to make assertions</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Working with HTTPretty</h1></div></div></div><p>There are three <a class="indexterm" id="id134"/>main steps to be followed while dealing with HTTPretty:</p><div><ol class="orderedlist arabic"><li class="listitem">Enable HTTPretty</li><li class="listitem">Register the uniform resource locator to HTTPretty</li><li class="listitem">Disable HTTPretty</li></ol></div><p>We should enable HTTPretty initially, so that it will apply monkey patching; that is, a dynamic replacement of the attributes of the socket module. We will be using the function <code class="literal">register_uri</code> for registering the uniform resource locator. The <code class="literal">register_uri</code> function takes <code class="literal">class</code>, <code class="literal">uri</code> and <code class="literal">body</code> as arguments:</p><div><pre class="programlisting"><strong>   method: register_uri(class, uri, body)</strong>
</pre></div><p>And at the end of our testing process, we should disable HTTPretty so that it doesn't alter the behavior of the other. Let us take a look at using HTTPretty with an example:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>
<strong>from sure import expect</strong>
<strong> </strong>
<strong>def example():</strong>
<strong>    httpretty.enable()</strong>
<strong>    httpretty.register_uri(httpretty.GET, "http://google.com/",</strong>
<strong>                           body="This is the mocked body",</strong>
<strong>                           status=201)</strong>
<strong>    response = requests.get("http://google.com/")</strong>
<strong>    expect(response.status_code).to.equal(201)</strong>
<strong>    httpretty.disable()</strong>
</pre></div><p>In this example, we used the <code class="literal">httpretty.GET</code> class in <code class="literal">register_uri</code> function to register the <code class="literal">uri</code> value that is <code class="literal">"http://google.com/"</code>. In the next line, we used Request to get the information from the URI and then we used the expect function to assert the expected status code. In a nutshell, the preceding code tries to mock the URI and tests whether we are getting the same status code as expected.</p><p>We can simplify the <a class="indexterm" id="id135"/>preceding code using a decorator. As in the first and third step, that is, enabling and disabling HTTPretty are same all the time, we can use a decorator so that those functions get wrapped up whenever we want them to come into the picture. The decorator looks like this: <code class="literal">@httpretty.activate</code>. The previous code example can be rewritten using a decorator in the following way:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>

<strong>from sure import expect</strong>

<strong>@httpretty.activate</strong>
<strong>def example():</strong>
<strong>    httpretty.register_uri(httpretty.GET, "http://google.com/",</strong>
<strong>                           body="This is the mocked body",</strong>
<strong>                           status=201)</strong>
<strong>    response = requests.get("http://google.com/")</strong>
<strong>    expect(response.status_code).to.equal(201)</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Setting headers</h1></div></div></div><p>HTTP header fields <a class="indexterm" id="id136"/>supply the necessary information about the request or response. We can mock any HTTP response header by using HTTPretty. To achieve that, we will be adding them as keyword arguments. We should keep in mind that the keys of the keyword arguments are always lower case and have underscores (_) instead of dashes.</p><p>For example, if we want to mock the server, which returns Content-Type, we can use the argument <code class="literal">content_type</code>. Do notice that, in the following part we are using an inexistent URL to showcase the syntax:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>

<strong>from sure import expect</strong>

<strong>@httpretty.activate</strong>
<strong>def setting_header_example():</strong>
<strong>    httpretty.register_uri(httpretty.GET,</strong>
<strong>                           "http://api.example.com/some/path",</strong>
<strong>                           body='{"success": true}',</strong>
<strong>                           status=200,</strong>
<strong>                           content_type='text/json')</strong>

<strong>    response = requests.get("http://api.example.com/some/path")</strong>

<strong>    expect(response.json()).to.equal({'success': True})</strong>
<strong>    expect(response.status_code).to.equal(200)</strong>
</pre></div><p>Similarly, all the keyword arguments are taken by HTTPretty and changed into the RFC2616 equivalent name.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Working with responses</h1></div></div></div><p>When we mock HTTP requests using HTTPretty, it returns an <code class="literal">httpretty.Response</code> object. We can generate <a class="indexterm" id="id137"/>the following responses through callbacks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rotating <a class="indexterm" id="id138"/>Responses</li><li class="listitem" style="list-style-type: disc">Streaming Responses</li><li class="listitem" style="list-style-type: disc">Dynamic Responses</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Rotating responses</h2></div></div></div><p>Rotating responses are <a class="indexterm" id="id139"/>the responses we receive in a given order when we send a request to a server with the same URL and same request method. We can define as many responses as we wish with the responses argument.</p><p>The following snippet explains the mocking of Rotating Responses:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>

<strong>from sure import expect</strong>

<strong>@httpretty.activate</strong>
<strong>def rotating_responses_example():</strong>
<strong>    URL = "http://example.com/some/path"</strong>
<strong>    RESPONSE_1 = "This is Response 1."</strong>
<strong>    RESPONSE_2 = "This is Response 2."</strong>
<strong>    RESPONSE_3 = "This is Last Response."</strong>

<strong>    httpretty.register_uri(httpretty.GET,</strong>
<strong>                           URL,</strong>
<strong>                           responses=[</strong>
<strong>                               httpretty.Response(body=RESPONSE_1,</strong>
<strong>                                                  status=201),</strong>
<strong>                               httpretty.Response(body=RESPONSE_2,</strong>
<strong>                                                  status=202),</strong>
<strong>                               httpretty.Response(body=RESPONSE_3,</strong>
<strong>                                                  status=201)])</strong>

<strong>    response_1 = requests.get(URL)</strong>
<strong>    expect(response_1.status_code).to.equal(201)</strong>
<strong>    expect(response_1.text).to.equal(RESPONSE_1)</strong>

<strong>    response_2 = requests.get(URL)</strong>
<strong>    expect(response_2.status_code).to.equal(202)</strong>
<strong>    expect(response_2.text).to.equal(RESPONSE_2)</strong>

<strong>    response_3 = requests.get(URL)</strong>
<strong>    expect(response_3.status_code).to.equal(201)</strong>
<strong>    expect(response_3.text).to.equal(RESPONSE_3)</strong>

<strong>    response_4 = requests.get(URL)</strong>
<strong>    expect(response_4.status_code).to.equal(201)</strong>
<strong>    expect(response_4.text).to.equal(RESPONSE_3)</strong>
</pre></div><p>In this example, we have registered three different responses using the responses argument with the <code class="literal">httpretty.register_uri</code> method. And then, we sent four different requests to the server with the <a class="indexterm" id="id140"/>same URI and the same method. As a result, we received the first three responses in the sequence of registration. From the fourth request, we'll get the last response defined in the responses object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Streaming responses</h2></div></div></div><p>Streaming responses will <a class="indexterm" id="id141"/>not have <code class="literal">Content-Length</code> header. Rather, they have a <code class="literal">Transfer-Encoding</code> header with a value of <code class="literal">chunked</code>, and a body consisting of a series of chunks you write to the socket preceded by their individual sizes. These kinds of <a class="indexterm" id="id142"/>responses are also called <strong>Chunked Responses</strong>.</p><p>We can mock a Streaming response by registering a generator response body:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>
<strong>from time import sleep</strong>
<strong>from sure import expect</strong>

<strong>def mock_streaming_repos(repos):</strong>
<strong>    for repo in repos:</strong>
<strong>        sleep(.5)</strong>
<strong>        yield repo</strong>

<strong>@httpretty.activate</strong>
<strong>def streaming_responses_example():</strong>
<strong>    URL = "https://api.github.com/orgs/python/repos"</strong>
<strong>    REPOS = ['{"name": "repo-1", "id": 1}\r\n',</strong>
<strong>             '\r\n',</strong>
<strong>             '{"name": "repo-2", "id": 2}\r\n']</strong>

<strong>    httpretty.register_uri(httpretty.GET,</strong>
<strong>                           URL,</strong>
<strong>                           body=mock_streaming_repos(REPOS),</strong>
<strong>                           streaming=True)</strong>

<strong>    response = requests.get(URL,</strong>
<strong>                            data={"track": "requests"})</strong>

<strong>    line_iter = response.iter_lines()</strong>
<strong>    for i in xrange(len(REPOS)):</strong>
<strong>        expect(line_iter.next().strip()).to.equal(REPOS[i].strip())</strong>
</pre></div><p>To mock a streaming response, we need to set the streaming argument to <code class="literal">True</code> while registering <code class="literal">uri</code>. In the <a class="indexterm" id="id143"/>previous example, we mocked the streaming response using the generator <code class="literal">mock_streaming_repos,</code> which will take the list as an argument, and will yield the list item every half second.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Dynamic responses through callbacks</h2></div></div></div><p>If the response <a class="indexterm" id="id144"/>from the API server is generated, depending on the values from the request, then we call it a Dynamic response. To mock dynamic responses based on the request, we will use a callback method as defined in the following example:</p><div><pre class="programlisting"><strong>import httpretty</strong>
<strong>import requests</strong>

<strong>from sure import expect</strong>

<strong>@httpretty.activate</strong>
<strong>def dynamic_responses_example():</strong>
<strong>    def request_callback(method, uri, headers):</strong>
<strong>        return (200, headers, "The {} response from {}".format(method, uri)</strong>
<strong>    httpretty.register_uri(</strong>
<strong>        httpretty.GET, "http://example.com/sample/path",</strong>
<strong>        body=request_callback)</strong>


<strong>        response = requests.get("http://example.com/sample/path")</strong>

<strong>        expect(response.text).to.equal(' http://example.com/sample/path')</strong>
</pre></div><p>In this example, <code class="literal">request_callback</code> method is registered while mocking the response, in order to generate dynamic response content.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we learnt the basic concepts related to HTTPretty. We looked at what HTTPretty is, and why we need HTTPretty. We also walked through detailed usage of the mocking library, setting headers, and mocking different types of Responses. These topics are enough for us to get started and keep the progress moving on.</p><p>In the next chapter, we will learn how to interact with the social networks like Facebook, Twitter, and reddit with the requests library.</p></div></body></html>