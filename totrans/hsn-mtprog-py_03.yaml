- en: '*Chapter 2*: Refresher of OOP Concepts in Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：Python中OOP概念的复习'
- en: In the previous chapter, we looked at an overview of and discussed the need
    for metaprogramming and its practical applications, such as using the add function.
    But before we deep dive into the concepts of metaprogramming, it is important
    for you to have knowledge of the basic Object-Oriented Programming (OOP) concepts
    available in Python. This chapter gives an overview of the existing OOP concepts
    along with examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们概述了元编程及其实际应用，例如使用添加函数的需求。但在深入探讨元编程的概念之前，了解Python中可用的基本面向对象编程（OOP）概念对你来说很重要。本章概述了现有的OOP概念，并附有示例。
- en: 'The main topics we will be covering in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的主要主题如下：
- en: Introducing our core example
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的核心示例
- en: Creating classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类
- en: Understanding objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象
- en: Applying methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用方法
- en: Implementing inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现继承
- en: Extending to multiple inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展到多重继承
- en: Understanding polymorphism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多态性
- en: Hiding details with abstraction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象隐藏细节
- en: Protecting information with encapsulation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封装保护信息
- en: By the end of this chapter, you will be able to understand the concepts of OOP
    in Python along with some practical examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够理解Python中OOP的概念，并附带一些实际示例。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is completely optional, so if you are already familiar with the
    concepts of OOP, you can proceed directly learning metaprogramming concepts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完全可选，所以如果你已经熟悉OOP的概念，你可以直接学习元编程的概念。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02)。
- en: Introducing our core example
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的核心示例
- en: Throughout this chapter, we will be making use of a simulated schema named *ABC
    Megamart* to explain the concepts of OOP. The availability of an object-oriented
    approach in a programming language helps with effective reusability and abstraction
    of the language. Our example, *ABC Megamart*, is a simulated large retail store
    that sells multiple products across different cities and consists of multiple
    branches.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个名为 *ABC Megamart* 的模拟模式来解释面向对象编程（OOP）的概念。编程语言中面向对象方法的可用性有助于提高语言的有效重用性和抽象性。我们的示例，*ABC
    Megamart*，是一个模拟的大型零售店，在不同城市销售多种产品，并包含多个分店。
- en: 'Let us give a structure to different entities of this store and look at how
    they can fit into an organized OOP paradigm. Our store consists of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个商店的不同实体提供一个结构，并看看它们如何适应一个有组织的面向对象范式。我们的商店包括以下内容：
- en: Products
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Branches
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支
- en: Invoices
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票
- en: Holidays
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假期
- en: Shelves
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货架
- en: Inventory
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存
- en: Sales
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促销
- en: Promotions/offers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优惠/提供
- en: Exchange counter
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兑换柜台
- en: Finance
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财务
- en: Each of these entities can have multiple attributes of data or information that
    are required to perform multiple functions in the smooth and efficient management
    of the stores.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体中的每一个都可以有多个数据或信息属性，这些属性对于在商店的顺畅和高效管理中执行多个功能是必需的。
- en: 'Let us explore how these entities and their attributes can be structured into
    a software model developed by applying the concepts of OOP:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何将这些实体及其属性结构化到通过应用OOP概念开发的软件模型中：
- en: Each of the preceding 10 entities can be connected either directly or indirectly
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的10个实体可以直接或间接地相互连接
- en: Each branch will have sales and each sale will have invoices
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分支都会有促销活动，每个促销活动都会有发票
- en: Each branch city will have holidays and sales can happen during holiday seasons
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分支城市都会有假期，促销活动可以在假期季节进行
- en: Each branch (store) can have shelves and products will be placed on shelves
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个分支（商店）可以有货架，产品将被放置在货架上
- en: Each product can have promotions or offers and promotions influence sales
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个产品都可以有促销或优惠，促销会影响销售
- en: 'Thus, multiple entities can be linked together to develop software, maintain
    a database schema, or both, depending on the application being modeled. Here is
    a representation of how these entities can be linked:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多个实体可以链接在一起以开发软件、维护数据库模式或两者兼而有之，具体取决于所建模的应用。以下是这些实体如何相互连接的表示：
- en: '![Figure 2.1 – Example of how a simple linkage can be modeled to connect various
    entities ](img/B13426_02_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 简单链接如何建模以连接各种实体的示例](img/B13426_02_01.jpg)'
- en: Figure 2.1 – Example of how a simple linkage can be modeled to connect various
    entities
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 简单链接如何建模以连接各种实体的示例
- en: There is more than one way in which we can structure the previous entity model
    but we are not covering all of them. This is more of a simple representation of
    the entity relationship at a higher level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式来构建之前的实体模型，但我们不会涵盖所有这些。这更多的是在更高层次上对实体关系的简单表示。
- en: Using this example as the base, let us now dive into the topic of creating classes
    in Python.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个例子为基础，现在让我们深入探讨在Python中创建类的话题。
- en: Creating classes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类
- en: A **class** is a collection of common attributes and methods that can be reused
    by creating instances of the class. By creating a class, we define it once and
    reuse it multiple times, thus avoiding redundancy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是一组可以由创建类的实例重用的公共属性和方法。通过创建一个类，我们只定义一次并多次重用它，从而避免冗余。'
- en: Let us look at what a class can look like. We can consider the `Branch` entity
    of *ABC Megamart.* A `Branch` can have an `ID` and an `Address`. `Address` can
    further be detailed into `Street`, `City`, `State`, and `Zip code`. If we consider
    `Branch` as a class, `ID`, `Street`, `City`, `State`, and `Zip code` would become
    its attributes. All operations that can be performed by a branch will become its
    methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类可以是什么样的。我们可以考虑*ABC Megamart*的`Branch`实体。一个`Branch`可以有`ID`和`Address`。`Address`可以进一步细分为`Street`、`City`、`State`和`Zip
    code`。如果我们把`Branch`看作一个类，`ID`、`Street`、`City`、`State`和`Zip code`将成为其属性。所有可以由分支机构执行的操作将成为其方法。
- en: 'A branch can sell products, maintain invoices, maintain inventory, and so on.
    The generic format of a class is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分支可以销售产品、维护发票、维护库存等等。类的通用格式如下：
- en: '![Figure 2.2 – Class ](img/B13426_02_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 类](img/B13426_02_02.jpg)'
- en: Figure 2.2 – Class
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 类
- en: 'A class can be defined as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以这样定义：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The format of the `Branch` class is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Branch`类的格式如下：'
- en: '![Figure 2.3 – Branch class ](img/B13426_02_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – Branch类](img/B13426_02_03.jpg)'
- en: Figure 2.3 – Branch class
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Branch类
- en: 'Similarly, a `Branch` class can be defined as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以定义一个`Branch`类如下：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A `Branch` class can have multiple attributes and methods to perform various
    operations. These attributes and methods will be initialized as NULLs and added
    to the class in this example, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Branch`类可以有多个属性和方法来执行各种操作。在这个例子中，这些属性和方法将被初始化为NULL，并添加到类中，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The attributes of the class can be initialized either with a specific value
    or as NULL and modified later while defining an object for the class and calling
    it to perform various functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类的属性可以用特定的值初始化，也可以初始化为NULL，然后在定义类对象并调用它执行各种功能时进行修改。
- en: Let us look further into utilizing and modifying these class attributes by creating
    class objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨通过创建类对象来利用和修改这些类属性。
- en: Understanding objects
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: An `ClassName`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassName`。'
- en: 'A class without an object is practically unusable. All the attributes and methods
    created for the class can be effectively utilized once we create an object instance,
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对象的类实际上是不可用的。一旦我们创建了一个对象实例，就可以有效地利用为该类创建的所有属性和方法，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Considering the earlier example of a `Branch` class, we can create and utilize
    its objects as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的`Branch`类示例，我们可以创建并使用其对象如下：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, `branch_albany` is an instance of the`Branch` class and all its attributes
    can be modified for this instance without impacting the attributes within the
    class definition of `Branch`. An instance is more like a copy of the class that
    can be utilized without affecting the class itself. Let’s take the following code
    as an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`branch_albany`是`Branch`类的一个实例，并且可以修改这个实例的所有属性，而不会影响`Branch`类定义中的属性。一个实例更像是一个类的副本，可以在不影响类本身的情况下使用。以下代码作为例子：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calling the preceding defined attributes returns the following values defined
    for those attributes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调用先前定义的属性会返回为这些属性定义的以下值：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can create another object for the `Branch` class and the class would still
    remain unaffected. We can then assign a value to `branch_id` that belongs to the
    newly created `branch` object, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`Branch`类创建另一个对象，而类本身不会受到影响。然后我们可以为新创建的`branch`对象分配一个`branch_id`的值，如下所示：
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, `branchNevada.branch_id` is a variable of the the`branchNevada` object
    and it returns no value as it can be defined for this instance:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`branchNevada.branch_id` 是 `branchNevada` 对象的变量，它不返回任何值，因为它可以为此实例定义：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is not the only way to define values for class variables using an object.
    Alternatively, all attributes can be added as parameters to the `init` method
    in the class definition and all values for those attributes can be initiated while
    creating an object instance. To make this work, we will have to redefine the `Branch`
    class, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是使用对象定义类变量值的唯一方法。作为替代，可以将所有属性作为参数添加到类定义中的 `init` 方法中，并在创建对象实例时初始化这些属性的值。为了使这生效，我们必须重新定义
    `Branch` 类，如下所示：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Creating an object instance for the preceding redefined class in the same method
    as before would lead to an error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在与之前相同的方法中创建先前重新定义的类的对象实例会导致错误：
- en: '[PRE49]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the error message we receive:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们收到的错误信息：
- en: '![Figure 2.4 – Missing required arguments error ](img/B13426_02_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 缺少必需的参数错误](img/B13426_02_04.jpg)'
- en: Figure 2.4 – Missing required arguments error
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 缺少必需的参数错误
- en: 'Yes, all the parameters we declared in the `init` class are missing in the
    earlier object instantiation. The new object for this class needs to be created
    with all the values initiated, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们在 `init` 类中声明的所有参数在早期对象实例化中缺失。这个类的新对象需要创建并带有所有初始化的值，如下所示：
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With this understanding, let us look at the concept of defining methods inside
    a class and calling them using objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们来看看在类内部定义方法并使用对象调用它们的概念。
- en: Applying methods
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用方法
- en: '**Methods** are similar to the user-defined functions we create to perform
    various operations in a program, the difference being methods are defined inside
    a class and are governed by the rules of the class. Methods can be utilized only
    by calling them using an object instance created for that class. User-defined
    functions, on the other hand, are global and can be called freely anywhere within
    the program. A method can be as simple as printing a statement or can be a highly
    complex mathematical calculation that involves a large number of parameters.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**类似于我们创建以在程序中执行各种操作的用户定义函数，区别在于方法是在类内部定义的，并受类规则的约束。方法只能通过调用为该类创建的对象实例来使用。另一方面，用户定义函数是全局的，可以在程序中的任何地方自由调用。一个方法可以像打印一个语句那样简单，也可以是一个高度复杂的数学计算，涉及大量参数。'
- en: 'Defining methods with simple print statements inside the `Branch` class looks
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Branch` 类内部使用简单的打印语句定义方法如下：
- en: '[PRE57]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'By calling the preceding methods from `object_albany`, we will get the following
    output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `object_albany` 调用上述方法，我们将得到以下输出：
- en: '[PRE72]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As a variation, we can look at creating methods with parameters and calculations.
    For this example, let us consider a scenario where we need to calculate the selling
    price for a product in a particular branch given the tax rate for the state, the
    purchase price for the product, and the profit margin. After calculating the selling
    price of the product, the method should return branch details, product details,
    selling price, and sales tax.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种变体，我们可以看看创建带有参数和计算的方法的例子。对于这个例子，让我们考虑一个场景，其中我们需要根据州的销售税率、产品的购买价格和利润率来计算特定分支的产品销售价格。在计算产品的销售价格后，该方法应返回分支详情、产品详情、销售价格和销售税。
- en: 'To write this method, we will create three dictionary variables using Python
    keyword arguments and name them `**branch`, `**sales`, and `**product`. We will
    be creating three methods to set values for branch, sales, and product information,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写这个方法，我们将使用 Python 关键字参数创建三个字典变量，并分别命名为 `**branch`、`**sales` 和 `**product`。我们将创建三个方法来设置分支、销售和产品信息，如下所示：
- en: '[PRE78]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding code takes in all the values that can be included for the branch,
    sales, and product. We will be creating an object for the `Branch` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码接收了可以为分支、销售和产品包含的所有值。我们将为 `Branch` 类创建一个对象：
- en: '[PRE85]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In the following code, we will make use of the `set_branch` method to store
    the values in the `branch` dictionary variable within the object of `Branch`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将使用 `set_branch` 方法来存储 `Branch` 对象内部的 `branch` 字典变量中的值：
- en: '[PRE86]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will now call the `branch` attribute on the `branch_nyc` object, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式在 `branch_nyc` 对象上调用 `branch` 属性：
- en: '[PRE91]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of `branch_id` along with its address:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出，这是一个包含`branch_id`及其地址的字典：
- en: '[PRE92]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Similarly, in the following code, we will make use of the `set_product` method
    to store the values in the `product` dictionary variable within the object of
    `Branch`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下面的代码中，我们将使用`set_product`方法在`Branch`对象的`product`字典变量中存储值：
- en: '[PRE97]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We will now call the `product` attribute on the `branch_nyc` object, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式在`branch_nyc`对象上调用`product`属性：
- en: '[PRE101]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of all product IDs along with their details:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出，这是一个包含所有产品ID及其详细信息的字典：
- en: '[PRE102]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Similarly, in the following code, we will make use of the `set_sales` method
    to store the values in the `sales` dictionary variable within the object of `Branch`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在以下代码中，我们将使用`set_sales`方法在`Branch`对象的`sales`字典变量中存储值：
- en: '[PRE103]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We will now call the `sales` attribute on the `branch_nyc` object, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式在`branch_nyc`对象上调用`sales`属性：
- en: '[PRE108]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of all sales information:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出，这是一个包含所有销售信息的字典：
- en: '[PRE109]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Calculating the selling price will be done in the following two steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 计算销售价格将通过以下两个步骤来完成：
- en: Calculate the price before tax by adding the purchase price with the product
    between the purchase price and profit margin percentage.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将购买价格加上购买价格和利润率百分比之间的产品，来计算税前价格。
- en: Calculate the selling price by adding the price before tax, with the product
    between price before tax and sales tax rate.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将税前价格加上产品之间的价格，来计算销售价格。
- en: 'In the following code, we will include the `calc_tax` method to perform the
    preceding calculation steps and to return the branch details along with product
    information and sales data:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将包含`calc_tax`方法来执行前面的计算步骤，并返回分支详情以及产品信息和销售数据：
- en: '[PRE110]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Calling the preceding function provides the following results:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调用前面的函数会提供以下结果：
- en: '[PRE127]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now that we know how to apply methods, we can look further into the concept
    of inheritance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何应用方法，我们可以进一步了解继承的概念。
- en: Implementing inheritance
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现继承
- en: '**Inheritance** in a literal sense means acquiring the properties of a parent
    by the child, and it means the same in the case of OOP too. A new class can inherit
    the attributes and methods of a parent class and it can also have its own properties
    and methods. The new class that inherits the parent class will be called a child
    class or a subclass while the parent class can also be called a base class. The
    following is a simple representation of it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**在字面上的意思是通过子类获得父类的属性，在面向对象编程中也意味着相同。一个新类可以继承父类的属性和方法，它也可以有自己的属性和方法。继承父类的新类将被称为子类或子类，而父类也可以被称为基类。以下是对其的简单表示：'
- en: '![Figure 2.5 – Inheritance ](img/B13426_02_05.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 继承](img/B13426_02_05.jpg)'
- en: Figure 2.5 – Inheritance
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 继承
- en: Extending our latest class definition of `Branch` to have an individual class
    for `NYC`—since it has multiple intra-city branches and it also has other properties
    of its own in addition to the `Branch` class—we will be applying Inheritance to
    create a new subclass or child class named `NYC`. It has propertiessuch as having
    multiple hierarchies of management. NYC has a regional manager and each branch
    has its own branch manager. For NYC, we will also add an additional local tax
    component to the calculation of the selling price, which varies from branch to
    branch.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们最新的`Branch`类定义扩展为具有单独的`NYC`类——因为它有多个城市内部分支，并且它还具有除了`Branch`类之外的其他属性——我们将应用继承来创建一个新的子类或子类，名为`NYC`。它具有如具有多个管理层级等属性。NYC有一个区域经理，每个分支都有自己的分支经理。对于NYC，我们还将向销售价格的计算中添加一个额外的本地税率组件，该税率因分支而异。
- en: '![Figure 2.6 – NYC class inherits from Branch class ](img/B13426_02_06.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – NYC类继承自Branch类](img/B13426_02_06.jpg)'
- en: Figure 2.6 – NYC class inherits from Branch class
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – NYC类继承自Branch类
- en: 'The general structure of inheritance while defining a child class inheriting
    from a parent class looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个从父类继承的子类时的继承一般结构如下所示：
- en: '[PRE140]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Inheriting the `NYC` child class from the `Branch` parent class can be defined
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Branch`父类继承`NYC`子类可以定义如下：
- en: '[PRE146]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Let us examine the proceeding code before going any further with object creation.
    The`NYC` subclass has its own additional attribute, `intercitybranch`, introduced
    as a parameter in its own method, `set_management`. NYC also has its own method
    to calculate tax, `calc_tax_nyc`. The `calc_tax_nyc` method in NYC includes an
    additional component, `local_rate`, to calculate the selling price.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步创建对象之前，让我们检查前面的代码。`NYC`子类有自己的附加属性`intercitybranch`，它作为其自己的方法`set_management`的参数引入。纽约市还有一个自己的计算税的方法，即`calc_tax_nyc`。纽约市的`calc_tax_nyc`方法包括一个额外的组件`local_rate`来计算售价。
- en: 'Now, let us examinewhether NYC can make use of the methods of the `Branch`
    class to set the new values for branch, product, and sales:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查纽约市是否可以使用`Branch`类的这些方法来设置分支、产品和销售的新值：
- en: '[PRE161]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'By examining the methods that are available in the `branch_manhattan` object,
    as shown in the following screenshot, we can see that NYC can make use of the
    set methods defined in the `Branch` class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`branch_manhattan`对象中可用的方法，如下面的截图所示，我们可以看到纽约市可以利用`Branch`类中定义的集合方法：
- en: '![Figure 2.7 – Set methods inherited from Branch ](img/B13426_02_07.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 从Branch继承的设置方法](img/B13426_02_07.jpg)'
- en: Figure 2.7 – Set methods inherited from Branch
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 从Branch继承的设置方法
- en: 'We can proceed further by setting attributes using all of these methods and
    calculating the selling price after sales tax and local tax rate for the Manhattan
    branch, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用所有这些方法设置属性，并在计算曼哈顿分支的销售税和地方税率后计算售价，如下所示：
- en: '[PRE162]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We will call the `branch` attribute on the `branch_manhattan` object, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`branch_manhattan`对象上的`branch`属性，如下所示：
- en: '[PRE168]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'In the following code, we will make use of the `set_management` method to store
    the values in the `intercitybranch` dictionary variable within the object of NYC:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将使用`set_management`方法将值存储在纽约市对象内的`intercitybranch`字典变量中：
- en: '[PRE175]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Let’s call the `intercitybranch` attribute on the `branch_manhattan` object,
    as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称`branch_manhattan`对象上的`intercitybranch`属性，如下所示：
- en: '[PRE180]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Similarly, in the following code, we will make use of the `set_product` method
    to store the values in the `product` dictionary variable within the object of
    NYC:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下面的代码中，我们将使用`set_product`方法将值存储在纽约市对象内的`product`字典变量中：
- en: '[PRE184]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'We will now call the `product` attribute on the `branch_manhattan` object:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用`branch_manhattan`对象上的`product`属性：
- en: '[PRE189]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Similarly, in the following code, we will make use of the `set_sales` method
    to store the values in the `sales` dictionary variable within the object of NYC:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下面的代码中，我们将使用`set_sales`方法将值存储在纽约市对象内的`sales`字典变量中：
- en: '[PRE193]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'We will further call the `sales` attribute on the `branch_manhattan` object,
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步调用`branch_manhattan`对象上的`sales`属性，如下所示：
- en: '[PRE199]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'With all the preceding attributes and their value assignments, we can calculate
    tax for the Manhattan branch using the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的属性及其值分配之后，我们可以使用以下代码计算曼哈顿分支的税：
- en: '[PRE200]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'We can still make use of the `calc_tax` method available in the `Branch` class
    if we don’t want to calculate the selling price based on the local tax rate:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想根据地方税率计算售价，我们仍然可以使用`Branch`类中可用的`calc_tax`方法：
- en: '[PRE218]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The preceding code and its output demonstrate the reusable nature of inheritance
    in OOP. Now let’s look at an extended concept called multiple inheritance.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码及其输出展示了面向对象编程中继承的可重用性。现在让我们看看一个扩展的概念，即多重继承。
- en: Extending to multiple inheritance
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展到多重继承
- en: 'Python also supports `Product` and `Branch`, and let the `Sales` class inherit
    both these base classes. Here is a quick representation of the logic we’d be using:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Python也支持`Product`和`Branch`，并让`Sales`类继承这两个基类。以下是我们将使用的逻辑的快速表示：
- en: '![Figure 2.8 – Multiple inheritance example ](img/B13426_02_08.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 多重继承示例](img/B13426_02_08.jpg)'
- en: Figure 2.8 – Multiple inheritance example
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 多重继承示例
- en: 'In the following code, we will be creating a `Product` class where we will
    define the attributes for a product and a `get_product` method to return the product
    details:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将创建一个`Product`类，在其中我们将定义产品的属性和一个`get_product`方法来返回产品详情：
- en: '[PRE233]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'We will also be creating another class, `Branch`, where we will define the
    attributes for a branch and a `get_branch` method to return the branch details:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建另一个类`Branch`，在其中我们将定义分支的属性和一个`get_branch`方法来返回分支详情：
- en: '[PRE241]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'We will be implementing the concept of multiple inheritance by inheriting two
    parent classes, `Product` and `Branch`, into the child class, `Sales`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将两个父类 `Product` 和 `Branch` 继承到子类 `Sales` 中来实现多重继承的概念：
- en: '[PRE252]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: In the preceding code, the `Sales` class inherited two methods, `get_product`,
    and `get_branch`, from the `Product` class and the `Branch` class, respectively.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Sales` 类分别从 `Product` 类和 `Branch` 类继承了两个方法，分别是 `get_product` 和 `get_branch`。
- en: 'In the following code, we will be creating an object for the `Sales` class:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将为 `Sales` 类创建一个对象：
- en: '[PRE257]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Calling the `get_sales` method from the `Sales` class results in returning
    the `date` attribute from the `Sales` class along with the `product` and `branch`
    attributes from its parent classes:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Sales` 类调用 `get_sales` 方法会返回 `Sales` 类的 `date` 属性以及其父类中的 `product` 和 `branch`
    属性：
- en: '[PRE258]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: With these examples, we can proceed further to understand the concept of polymorphism,
    which extends on our earlier examples of inheritance.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们可以进一步了解多态的概念，它扩展了我们之前关于继承的例子。
- en: Understanding polymorphism
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态
- en: '**Polymorphism** is the concept of the OOP paradigm where we can reuse the
    name of a function from a parent class either by redefining or overriding an existing
    function or by creating two different functions for two different classes with
    the same name and using them separately. In this section, we will look at examples
    for both variations of polymorphism:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态** 是面向对象范式中的一个概念，我们可以通过重新定义或覆盖现有函数，或者为两个具有相同名称的不同类创建两个不同的函数来重用父类中函数的名称。在本节中，我们将探讨多态的两种变体示例：'
- en: Polymorphism within inheritance
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态在继承中
- en: Polymorphism in independent classes
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立类中的多态
- en: Polymorphism within inheritance
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态在继承中
- en: 'Let us look at the earlier example of the child class, `NYC`, which inherits
    from `Branch`. To calculate the selling price along with the local tax rate for
    the specific branch, we created a new method within the `NYC` class named `calc_tax_nyc`.
    Instead of creating a new method, we can also override the `Parent` method, `calc_tax`,
    with the new calculation in the child class. This concept is polymorphism within
    inheritance. Here is a representation of it:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前提到的子类 `NYC` 的例子，它从 `Branch` 类继承。为了计算特定分支的销售价格以及本地税率，我们在 `NYC` 类中创建了一个名为
    `calc_tax_nyc` 的新方法。我们也可以在子类中通过覆盖父类 `calc_tax` 方法并使用新的计算来实现这一点。这个概念是继承中的多态。以下是它的表示：
- en: '![Figure 2.9 – calc_tax method overridden in child class, NYC ](img/B13426_02_09.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – NYC 子类中覆盖的 calc_tax 方法](img/B13426_02_09.jpg)'
- en: Figure 2.9 – calc_tax method overridden in child class, NYC
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – NYC 子类中覆盖的 calc_tax 方法
- en: 'To begin with, polymorphism, let us first recall the `calc_tax` method from
    the `Branch` class, and then we can override it in the child class, `NYC`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下 `Branch` 类中的 `calc_tax` 方法，然后我们可以在子类 `NYC` 中覆盖它：
- en: '[PRE267]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'We will now define the `NYC` class by inheriting the `Branch` class. This class
    has two methods, `set_management` and `calc_tax`. The `set_management` method
    returns `intercitybranch` as a dictionary attribute. The `calc_tax` method is
    now overridden in the child class, `NYC`, and it returns branch details, intercity
    branch details, product details, and sales details:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过继承 `Branch` 类来定义 `NYC` 类。这个类有两个方法，`set_management` 和 `calc_tax`。`set_management`
    方法返回 `intercitybranch` 作为字典属性。`calc_tax` 方法现在在子类 `NYC` 中被覆盖，并返回分支详情、城际分支详情、产品详情和销售详情：
- en: '[PRE278]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'The following is a representation of all the methods supported by the `branch_manhattan`
    object of the child class, `NYC`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对子类 `NYC` 的 `branch_manhattan` 对象支持的所有方法的表示：
- en: '![Figure 2.10 – calc_tax after polymorphism ](img/B13426_02_10.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 多态后的 calc_tax](img/B13426_02_10.jpg)'
- en: Figure 2.10 – calc_tax after polymorphism
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 多态后的 calc_tax
- en: 'The following code displays the results of calling the `calc_tax` method from
    `branch_manhattan`, which is the method overridden from its parent class to calculate
    the selling price after applying the local tax rate:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了调用 `branch_manhattan` 中的 `calc_tax` 方法的输出，这是从其父类中覆盖的方法，用于在应用本地税率后计算销售价格：
- en: '[PRE294]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: As we can see, the `calc_tax` method returns the output as defined in NYC.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`calc_tax` 方法返回了在 NYC 中定义的输出。
- en: Polymorphism in independent classes
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立类中的多态
- en: Polymorphism need not always happen in a *parent-childpc* class relationship.
    We can always have two completely different classes that can have two different
    function definitions with the same name and the functions can both be utilized
    by calling them using their class object instances.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 多态不一定要发生在父-子类关系中。我们总是可以有两个完全不同的类，它们可以有两个具有相同名称的不同函数定义，并且可以通过调用它们的类对象实例来利用这两个函数。
- en: For this example, we will be creating two independent classes, `Queens` and
    `Brooklyn`,, which are two different branches of *ABC Megamart*. We will not associate
    these branches with the `Branch` parent class in order to explain the concept
    of polymorphism in independent classes. The Brooklyn branch stocks only `maintenance_cost`,
    and defining them according to the requirements of storage for each branch.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建两个独立的类，`Queens`和`Brooklyn`，它们是*ABC Megamart*的两个不同分支。我们将不会将这些分支与`Branch`父类关联，以解释独立类中多态的概念。Brooklyn分支只存储`maintenance_cost`，并按照每个分支的存储要求来定义它们。
- en: '![Figure 2.11 – Polymorphism of one method in independent classes ](img/B13426_02_11.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 独立类中一个方法的多态](img/B13426_02_11.jpg)'
- en: Figure 2.11 – Polymorphism of one method in independent classes
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 独立类中一个方法的多态
- en: 'In the following code, for the `Brooklyn` class, we will calculate the maintenance
    cost only if the product type is `FMCG`. We will calculate the product of quantity
    costing 0.25 and add 100 USD for cold storage. If the product type is anything
    other than FMCG, we will notify you that the product will not be stocked. Let’s
    take a look at the code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，对于`Brooklyn`类，我们只有在产品类型是`FMCG`时才计算维护成本。我们将计算数量成本为0.25的乘积，并额外加100美元用于冷藏。如果产品类型不是FMCG，我们将通知您该产品将不会入库。让我们看看代码：
- en: '[PRE312]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'In the following code, for the `Queens` class, we will calculate maintenance
    cost only if the product type is `Electronics`. We will calculate the product
    of quantity costing 0.05 since the maintenance cost for electronics is lower and
    there is also no cold storage cost required here. If the product type is anything
    other than `Electronics`, we will notify that the product will not be stocked:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，对于`Queens`类，我们只有在产品类型是`Electronics`时才计算维护成本。由于电子产品的维护成本较低，并且这里也不需要冷藏成本，我们将计算数量成本为0.05。如果产品类型不是`Electronics`，我们将通知您该产品将不会入库：
- en: '[PRE323]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Please note that we have used the same function names in both the preceding
    examples. The next step is to call these functions. Each of these functions can
    be called by creating an object for each class and the functions can be accessed
    separately to perform different calculations even when they are used within the
    same program:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在前几个例子中都使用了相同的函数名。下一步是调用这些函数。每个函数都可以通过为每个类创建一个对象来调用，即使它们在同一个程序中使用，这些函数也可以分别访问以执行不同的计算：
- en: '[PRE332]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: We now have an understanding of the concept of polymorphism within classes.
    We will next look at abstraction, which behaves along the same lines as polymorphism
    but with a difference that will be explained further in the coming section.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经理解了类中多态的概念。接下来，我们将探讨抽象，它的工作方式与多态类似，但有一个将在下一节中进一步解释的差异。
- en: Hiding details with abstraction
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过抽象隐藏细节
- en: '`ABC` that can be imported to define abstract base classes. Abstraction is
    more like giving a black box to external users by not revealing all the details
    of various methods defined inside a class but instead giving a reference class
    that can help the external users to implement the methods according to their own
    requirements.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 可以导入`ABC`来定义抽象基类。抽象更像是向外部用户提供一个黑盒，不透露类内部定义的各种方法的全部细节，而是提供一个参考类，帮助外部用户根据他们的需求实现方法。
- en: For instance, the users of the Brooklyn branch don’t have to know the calculations
    that are handled by the Queens branch to calculate their maintenance cost. The
    information that the users of the Brooklyn branch need to know is that they can
    inherit the `Branch` class and implement the calculations for maintenance costs
    according to their own books and they need not worry about how the Queens branch
    is calculating their maintenance costs. At the same time, the `Branch` class,
    which is their parent class, will not be able to provide one common implementation
    for calculating maintenance costs since the calculations are going to vary depending
    on the branch. In this kind of scenario, the `Branch` class can create an abstract
    method, `maintenance_cost`, and let its subclasses or child classes implement
    it according to their requirements. The implementation of the `maintenance_cost`
    method by Brooklyn will not impact the implementation of the same method by Queens;
    the purpose of the implementation ends within the child class and the parent abstract
    class is always available for other child classes to define their own implementation.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，布鲁克林分部的用户不需要知道由皇后分部处理的计算来计算他们的维护成本。布鲁克林分部用户需要知道的信息是他们可以继承`Branch`类，并根据他们自己的账簿实现维护成本的计算，他们无需担心皇后分部是如何计算他们的维护成本的。同时，作为他们父类的`Branch`类，将无法提供一个通用的计算维护成本的实施方案，因为计算将根据分部而有所不同。在这种场景下，`Branch`类可以创建一个抽象方法`maintenance_cost`，并让它的子类或子类根据它们的要求实现它。布鲁克林对`maintenance_cost`方法的实现不会影响皇后对同一方法的实现；实现的目的是在子类内部结束，父抽象类始终可供其他子类定义它们自己的实现。
- en: 'If this kind of implementation can be done by simply applying polymorphism
    to a parent class method, then why do we need an abstract class to do the same?
    Let us first look at this by implementing a parent class and its child classes
    without actually implementing it as an abstract class:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种实现可以通过简单地应用多态到父类方法来完成，那么我们为什么还需要一个抽象类来做同样的事情？让我们首先通过实现一个父类及其子类，而不实际将其实现为抽象类来看一下：
- en: '[PRE338]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: In the preceding implementation, we have two child classes for the `Branch`
    class and we have applied polymorphism to override the parent method, but it is
    still not an abstraction since we will be able to create an object instance for
    the parent class and the methods of the parent class can be exposed when an object
    is created.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们为`Branch`类创建了两个子类，并且已经应用了多态来重写父类方法，但这仍然不是一个抽象，因为我们仍然能够为父类创建一个对象实例，并且当创建对象时，父类的方法可以被暴露出来。
- en: 'Instead of the preceding implementation, if we make a slight modification and
    create `Branch` as an abstract base class, let us look at what happens then. Here
    is the representation of what we are going for:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的实现不同，如果我们稍作修改，将`Branch`创建为一个抽象基类，让我们看看会发生什么。以下是我们要达到的表示：
- en: '![Figure 2.12 -– Abstract class is inherited by two classes and the methods
    implemented ](img/B13426_02_12.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 -– 抽象类被两个类继承并实现了方法](img/B13426_02_12.jpg)'
- en: Figure 2.12 -– Abstract class is inherited by two classes and the methods implemented
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 -– 抽象类被两个类继承并实现了方法
- en: 'Here, we will be importing `ABC` and `abstractmethod` from the `abc` library
    and we will create an abstract class called `Branch` followed by two child classes,
    `Brooklyn` and `Queens`, which inherit the parent class, `Branch`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将从`abc`库中导入`ABC`和`abstractmethod`，并创建一个名为`Branch`的抽象类，后面跟着两个子类`Brooklyn`和`Queens`，它们继承自父类`Branch`：
- en: '[PRE361]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: We imported the `ABC` library, created `Branch` as an abstract class, and defined
    `maintenance_cost` as an abstract method using the `@abstractmethod` keyword.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`ABC`库，将`Branch`创建为一个抽象类，并使用`@abstractmethod`关键字定义了`maintenance_cost`为抽象方法。
- en: 'Let us now try to create an object of the `Branch` class:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试创建一个`Branch`类的对象：
- en: '[PRE386]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'It throws the following error:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 它抛出了以下错误：
- en: '![Figure 2.13 – Abstract method instantiation error ](img/B13426_02_13.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 抽象方法实例化错误](img/B13426_02_13.jpg)'
- en: Figure 2.13 – Abstract method instantiation error
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 抽象方法实例化错误
- en: If an object is instantiated for a class, all the attributes and methods of
    the class can be accessed through the object. It is possible in regular classes;
    whereas, in the case of an abstract class, an object cannot be instantiated. This
    is why it is helpful to hide information that need not be shared with external
    users.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为类实例化一个对象，则可以通过该对象访问类的所有属性和方法。这在常规类中是可能的；而在抽象类的情况下，不能实例化对象。这就是为什么隐藏不需要与外部用户共享的信息是有帮助的。
- en: Abstraction is a method of information protection in Python or any other OOP
    language. We will now look at encapsulation and more details on how information
    can be protected in a class.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是Python或其他任何面向对象语言中信息保护的一种方法。现在我们将看看封装以及如何在类中保护信息的更多细节。
- en: Protecting information with encapsulation
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用封装保护信息
- en: '`__` (double underscore) and protected members or variables are prefixed by
    `_` (single underscore). We will look at some examples of private and protected
    class members.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`__`（双下划线）和受保护的成员或变量以前缀`_`（单下划线）开头。我们将查看一些私有和受保护的类成员的示例。'
- en: Private members
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有成员
- en: In Python, the concept of a private variable does not exist as in other OOP
    languages. However, we can add two underscore symbols before the name of a variable
    or method to signify that a specific variable will be used as a private member
    within the class. It is done so that the developer can understand the naming convention
    that the program treats the variable as private. Adding two underscores before
    the name of a variable or method prevents name mangling by the Python interpreter
    to avoid collisions with the variable during inheritance, and it is not an actual
    private member as in other languages.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，不存在像其他面向对象语言那样的私有变量概念。然而，我们可以在变量或方法名前添加两个下划线符号，以表示特定的变量将在类内部用作私有成员。这样做是为了让开发者理解程序如何将变量视为私有。在变量或方法名前添加两个下划线可以防止Python解释器在继承期间进行名称混淆，以避免与变量发生冲突，并且它并不是像其他语言那样的实际私有成员。
- en: In this example, we will define our familiar `Branch` class with private variables
    for product ID, product name, brand, purchase price, and profit margin and create
    a private method to display the product details. We will also create branch ID,
    regional manager, and branch manager as class variables that are not private and
    look at the difference between accessing those using objects outside the class.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义我们熟悉的`Branch`类，其中包含产品ID、产品名称、品牌、购买价格和利润率的私有变量，并创建一个用于显示产品详情的私有方法。我们还将创建分支ID、区域经理和分支经理作为非私有类变量，并查看使用对象从类外部访问这些变量的区别。
- en: '![Figure 2.14 – Private members of theBranch class and its accessibility by
    the Branch object  ](img/B13426_02_14.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – `Branch`类的私有成员及其通过`Branch`对象的可访问性](img/B13426_02_14.jpg)'
- en: Figure 2.14 – Private members of theBranch class and its accessibility by the
    Branch object
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – `Branch`类的私有成员及其通过`Branch`对象的可访问性
- en: 'Let us look at the following code to implement this example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码来实现这个示例：
- en: '[PRE387]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'On creating an object instance for the `Branch` class, we will be able to look
    at the results of the `__display_product_details` method since it is called within
    the class using the default `__init__` method:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`Branch`类创建对象实例时，我们将能够查看`__display_product_details`方法的输出结果，因为它是在类内部使用默认的`__init__`方法调用的：
- en: '[PRE409]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'The output is as follows:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE410]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'Let us try to access the `branch_id` variable, which is not declared as private:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试访问`branch_id`变量，它没有被声明为私有：
- en: '[PRE411]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: 'The output is as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE412]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'We are able to access this variable. Let us now try to access `profit_margin`,
    which is declared with a prefix of double underscore:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够访问这个变量。现在让我们尝试访问`profit_margin`，它使用双下划线前缀声明：
- en: '[PRE413]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'It gives us the following error:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了以下错误：
- en: '![Figure 2.15 – Error accessing private variable of a class  ](img/B13426_02_15.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 访问类私有变量的错误](img/B13426_02_15.jpg)'
- en: Figure 2.15 – Error accessing private variable of a class
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 访问类私有变量的错误
- en: 'We are getting an error since this variable can only be accessed within the
    class and not by the object of the class due to name mangling. The same applies
    to the private method created to display product details as well:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误，因为这个变量只能在类内部访问，不能通过类的对象访问，这是由于名称混淆造成的。同样的情况也适用于创建用于显示产品详情的私有方法：
- en: '[PRE414]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'We see the following:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到以下内容：
- en: '![](img/B13426_02_16.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13426_02_16.jpg)'
- en: Figure 2.16 – Error accessing private method of a class
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 访问类私有方法的错误
- en: 'The following screenshot shows the list of class members for the `Branch` class
    that can be accessed by its object:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `Branch` 类可以由其对象访问的类成员列表：
- en: '![Figure 2.17 – Members accessible by the branch object after including private
    members ](img/B13426_02_17.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 包含私有成员后分支对象可访问的成员](img/B13426_02_17.jpg)'
- en: Figure 2.17 – Members accessible by the branch object after including private
    members
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 包含私有成员后分支对象可访问的成员
- en: However, these private members can be accessed outside the class by creating
    an API to do it.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些私有成员可以通过创建一个 API 来在类外访问。
- en: Protected members
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受保护成员
- en: In this example, we will recreate the `Branch` class with protected variables
    for product ID, product name, brand, purchase price, and profit margin and create
    a protected method to display the product details. We will create a branch manager
    as a private variable. We will also create branch ID and regional manager as class
    variables that are not protected or private and look at the difference in accessing
    those using objects outside the class. We will also inherit the `Branch` class
    further to check which members are accessible.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将重新创建一个 `Branch` 类，其中包含用于产品 ID、产品名称、品牌、购买价格和利润率的受保护变量，并创建一个用于显示产品详情的受保护方法。我们将创建一个分支经理作为私有变量。我们还将创建分支
    ID 和区域经理作为非受保护或私有的类变量，并查看使用类外对象访问这些变量的差异。我们还将进一步继承 `Branch` 类以检查哪些成员是可访问的。
- en: '![Figure 2.18 – Protected members of the Branch class and its accessibility
    by inherited subclasses  ](img/B13426_02_18.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 分支类的受保护成员及其被继承子类访问的权限](img/B13426_02_18.jpg)'
- en: Figure 2.18 – Protected members of the Branch class and its accessibility by
    inherited subclasses
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 分支类的受保护成员及其被继承子类访问的权限
- en: 'Let us look at the following code to implement this example:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下代码以实现此示例：
- en: '[PRE415]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'The output is as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE438]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'An object created by `Branch` cannot access its protected members too similar
    to the private members, as we see here:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `Branch` 创建的对象也无法访问其受保护的成员，这与私有成员类似，如下所示：
- en: '![Figure 2.19 – Members accessible by branch object after including protected
    members ](img/B13426_02_19.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 包含受保护成员后分支对象可访问的成员](img/B13426_02_19.jpg)'
- en: Figure 2.19 – Members accessible by branch object after including protected
    members
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 包含受保护成员后分支对象可访问的成员
- en: 'Let us create a child class called `Brooklyn` that inherits the parent class,
    `Branch`. The child class will inherit all the protected variables and methods
    from the parent class, whereas it will still not inherit the private members:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Brooklyn` 的子类，它继承自父类 `Branch`。子类将继承父类的所有受保护变量和方法，而它仍然不会继承私有成员：
- en: '[PRE439]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'The output is as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE444]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: The `product_id` variable is a protected member of the parent class and `display_product_details`
    is also a protected member of the parent class, which is accessible by the `init`
    method of the child class, `Brooklyn`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`product_id` 变量是父类的受保护成员，`display_product_details` 也是父类的受保护成员，它可以通过子类 `Brooklyn`
    的 `init` 方法访问。'
- en: 'Let us now include a private member of the parent class and check whether it
    can be accessed from the child class:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们包括父类的一个私有成员并检查它是否可以从子类访问：
- en: '[PRE446]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'The output is as follows:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE452]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'The following error clarifies that private members will still not be accessible
    by the child class:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 以下错误说明私有成员仍然不会被子类访问：
- en: '![Figure 2.20  – Error accessing private attribute of a parent class from its
    child class ](img/B13426_02_20.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 从子类访问父类私有属性的错误](img/B13426_02_20.jpg)'
- en: Figure 2.20  – Error accessing private attribute of a parent class from its
    child class
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 从子类访问父类私有属性的错误
- en: These examples give us an understanding of how encapsulation can be implemented
    in Python.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例让我们了解了如何在 Python 中实现封装。
- en: Summary
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the concept of classes and objects and looked at
    examples of how to create classes and object instances. We also learned the concept
    of methods and how to create methods inside classes. Along with this, we saw how
    to apply inheritance and multiple inheritances to classes and apply polymorphism
    to methods. We then learned how to create abstract classes and methods. Finally,
    we learned the concept of encapsulation and how to restrict access to methods
    and variables of a class.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们回顾了类和对象的概念，并探讨了如何创建类和对象实例的示例。我们还学习了方法的概念以及如何在类内部创建方法。此外，我们还看到了如何将继承和多继承应用于类，以及如何将多态应用于方法。然后我们学习了如何创建抽象类和方法。最后，我们学习了封装的概念以及如何限制对类的方法和变量的访问。
- en: This chapter has provided a review of all the concepts of OOP in Python, which
    is going to act as the foundation for the main topic of this book, which is metaprogramming.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了Python中所有面向对象编程（OOP）的概念，这些概念将作为本书主要主题——元编程的基础。
- en: In the next chapter, we will see in detail the concept of decorators and their
    implementation with examples.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨装饰器的概念及其通过示例的实现。
