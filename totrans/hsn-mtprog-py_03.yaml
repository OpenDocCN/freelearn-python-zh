- en: '*Chapter 2*: Refresher of OOP Concepts in Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at an overview of and discussed the need
    for metaprogramming and its practical applications, such as using the add function.
    But before we deep dive into the concepts of metaprogramming, it is important
    for you to have knowledge of the basic Object-Oriented Programming (OOP) concepts
    available in Python. This chapter gives an overview of the existing OOP concepts
    along with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics we will be covering in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our core example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending to multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding details with abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting information with encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand the concepts of OOP
    in Python along with some practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is completely optional, so if you are already familiar with the
    concepts of OOP, you can proceed directly learning metaprogramming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our core example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be making use of a simulated schema named *ABC
    Megamart* to explain the concepts of OOP. The availability of an object-oriented
    approach in a programming language helps with effective reusability and abstraction
    of the language. Our example, *ABC Megamart*, is a simulated large retail store
    that sells multiple products across different cities and consists of multiple
    branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us give a structure to different entities of this store and look at how
    they can fit into an organized OOP paradigm. Our store consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Holidays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shelves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promotions/offers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these entities can have multiple attributes of data or information that
    are required to perform multiple functions in the smooth and efficient management
    of the stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us explore how these entities and their attributes can be structured into
    a software model developed by applying the concepts of OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the preceding 10 entities can be connected either directly or indirectly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each branch will have sales and each sale will have invoices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each branch city will have holidays and sales can happen during holiday seasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each branch (store) can have shelves and products will be placed on shelves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product can have promotions or offers and promotions influence sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, multiple entities can be linked together to develop software, maintain
    a database schema, or both, depending on the application being modeled. Here is
    a representation of how these entities can be linked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Example of how a simple linkage can be modeled to connect various
    entities ](img/B13426_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Example of how a simple linkage can be modeled to connect various
    entities
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one way in which we can structure the previous entity model
    but we are not covering all of them. This is more of a simple representation of
    the entity relationship at a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Using this example as the base, let us now dive into the topic of creating classes
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **class** is a collection of common attributes and methods that can be reused
    by creating instances of the class. By creating a class, we define it once and
    reuse it multiple times, thus avoiding redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at what a class can look like. We can consider the `Branch` entity
    of *ABC Megamart.* A `Branch` can have an `ID` and an `Address`. `Address` can
    further be detailed into `Street`, `City`, `State`, and `Zip code`. If we consider
    `Branch` as a class, `ID`, `Street`, `City`, `State`, and `Zip code` would become
    its attributes. All operations that can be performed by a branch will become its
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A branch can sell products, maintain invoices, maintain inventory, and so on.
    The generic format of a class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Class ](img/B13426_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Class
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the `Branch` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Branch class ](img/B13426_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Branch class
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a `Branch` class can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Branch` class can have multiple attributes and methods to perform various
    operations. These attributes and methods will be initialized as NULLs and added
    to the class in this example, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The attributes of the class can be initialized either with a specific value
    or as NULL and modified later while defining an object for the class and calling
    it to perform various functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look further into utilizing and modifying these class attributes by creating
    class objects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `ClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class without an object is practically unusable. All the attributes and methods
    created for the class can be effectively utilized once we create an object instance,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the earlier example of a `Branch` class, we can create and utilize
    its objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `branch_albany` is an instance of the`Branch` class and all its attributes
    can be modified for this instance without impacting the attributes within the
    class definition of `Branch`. An instance is more like a copy of the class that
    can be utilized without affecting the class itself. Let’s take the following code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the preceding defined attributes returns the following values defined
    for those attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create another object for the `Branch` class and the class would still
    remain unaffected. We can then assign a value to `branch_id` that belongs to the
    newly created `branch` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `branchNevada.branch_id` is a variable of the the`branchNevada` object
    and it returns no value as it can be defined for this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the only way to define values for class variables using an object.
    Alternatively, all attributes can be added as parameters to the `init` method
    in the class definition and all values for those attributes can be initiated while
    creating an object instance. To make this work, we will have to redefine the `Branch`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an object instance for the preceding redefined class in the same method
    as before would lead to an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the error message we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Missing required arguments error ](img/B13426_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Missing required arguments error
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, all the parameters we declared in the `init` class are missing in the
    earlier object instantiation. The new object for this class needs to be created
    with all the values initiated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With this understanding, let us look at the concept of defining methods inside
    a class and calling them using objects.
  prefs: []
  type: TYPE_NORMAL
- en: Applying methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are similar to the user-defined functions we create to perform
    various operations in a program, the difference being methods are defined inside
    a class and are governed by the rules of the class. Methods can be utilized only
    by calling them using an object instance created for that class. User-defined
    functions, on the other hand, are global and can be called freely anywhere within
    the program. A method can be as simple as printing a statement or can be a highly
    complex mathematical calculation that involves a large number of parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining methods with simple print statements inside the `Branch` class looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling the preceding methods from `object_albany`, we will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As a variation, we can look at creating methods with parameters and calculations.
    For this example, let us consider a scenario where we need to calculate the selling
    price for a product in a particular branch given the tax rate for the state, the
    purchase price for the product, and the profit margin. After calculating the selling
    price of the product, the method should return branch details, product details,
    selling price, and sales tax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write this method, we will create three dictionary variables using Python
    keyword arguments and name them `**branch`, `**sales`, and `**product`. We will
    be creating three methods to set values for branch, sales, and product information,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code takes in all the values that can be included for the branch,
    sales, and product. We will be creating an object for the `Branch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will make use of the `set_branch` method to store
    the values in the `branch` dictionary variable within the object of `Branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now call the `branch` attribute on the `branch_nyc` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of `branch_id` along with its address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the following code, we will make use of the `set_product` method
    to store the values in the `product` dictionary variable within the object of
    `Branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now call the `product` attribute on the `branch_nyc` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of all product IDs along with their details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the following code, we will make use of the `set_sales` method
    to store the values in the `sales` dictionary variable within the object of `Branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now call the `sales` attribute on the `branch_nyc` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output, which is a dictionary
    of all sales information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the selling price will be done in the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the price before tax by adding the purchase price with the product
    between the purchase price and profit margin percentage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the selling price by adding the price before tax, with the product
    between price before tax and sales tax rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we will include the `calc_tax` method to perform the
    preceding calculation steps and to return the branch details along with product
    information and sales data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the preceding function provides the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to apply methods, we can look further into the concept
    of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance** in a literal sense means acquiring the properties of a parent
    by the child, and it means the same in the case of OOP too. A new class can inherit
    the attributes and methods of a parent class and it can also have its own properties
    and methods. The new class that inherits the parent class will be called a child
    class or a subclass while the parent class can also be called a base class. The
    following is a simple representation of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Inheritance ](img/B13426_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Extending our latest class definition of `Branch` to have an individual class
    for `NYC`—since it has multiple intra-city branches and it also has other properties
    of its own in addition to the `Branch` class—we will be applying Inheritance to
    create a new subclass or child class named `NYC`. It has propertiessuch as having
    multiple hierarchies of management. NYC has a regional manager and each branch
    has its own branch manager. For NYC, we will also add an additional local tax
    component to the calculation of the selling price, which varies from branch to
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – NYC class inherits from Branch class ](img/B13426_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – NYC class inherits from Branch class
  prefs: []
  type: TYPE_NORMAL
- en: 'The general structure of inheritance while defining a child class inheriting
    from a parent class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Inheriting the `NYC` child class from the `Branch` parent class can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine the proceeding code before going any further with object creation.
    The`NYC` subclass has its own additional attribute, `intercitybranch`, introduced
    as a parameter in its own method, `set_management`. NYC also has its own method
    to calculate tax, `calc_tax_nyc`. The `calc_tax_nyc` method in NYC includes an
    additional component, `local_rate`, to calculate the selling price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us examinewhether NYC can make use of the methods of the `Branch`
    class to set the new values for branch, product, and sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'By examining the methods that are available in the `branch_manhattan` object,
    as shown in the following screenshot, we can see that NYC can make use of the
    set methods defined in the `Branch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Set methods inherited from Branch ](img/B13426_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Set methods inherited from Branch
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed further by setting attributes using all of these methods and
    calculating the selling price after sales tax and local tax rate for the Manhattan
    branch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the `branch` attribute on the `branch_manhattan` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will make use of the `set_management` method to store
    the values in the `intercitybranch` dictionary variable within the object of NYC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s call the `intercitybranch` attribute on the `branch_manhattan` object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the following code, we will make use of the `set_product` method
    to store the values in the `product` dictionary variable within the object of
    NYC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now call the `product` attribute on the `branch_manhattan` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the following code, we will make use of the `set_sales` method
    to store the values in the `sales` dictionary variable within the object of NYC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'We will further call the `sales` attribute on the `branch_manhattan` object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the preceding attributes and their value assignments, we can calculate
    tax for the Manhattan branch using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'We can still make use of the `calc_tax` method available in the `Branch` class
    if we don’t want to calculate the selling price based on the local tax rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code and its output demonstrate the reusable nature of inheritance
    in OOP. Now let’s look at an extended concept called multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Extending to multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python also supports `Product` and `Branch`, and let the `Sales` class inherit
    both these base classes. Here is a quick representation of the logic we’d be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Multiple inheritance example ](img/B13426_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Multiple inheritance example
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will be creating a `Product` class where we will
    define the attributes for a product and a `get_product` method to return the product
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also be creating another class, `Branch`, where we will define the
    attributes for a branch and a `get_branch` method to return the branch details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be implementing the concept of multiple inheritance by inheriting two
    parent classes, `Product` and `Branch`, into the child class, `Sales`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Sales` class inherited two methods, `get_product`,
    and `get_branch`, from the `Product` class and the `Branch` class, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will be creating an object for the `Sales` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `get_sales` method from the `Sales` class results in returning
    the `date` attribute from the `Sales` class along with the `product` and `branch`
    attributes from its parent classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: With these examples, we can proceed further to understand the concept of polymorphism,
    which extends on our earlier examples of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** is the concept of the OOP paradigm where we can reuse the
    name of a function from a parent class either by redefining or overriding an existing
    function or by creating two different functions for two different classes with
    the same name and using them separately. In this section, we will look at examples
    for both variations of polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism within inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in independent classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism within inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at the earlier example of the child class, `NYC`, which inherits
    from `Branch`. To calculate the selling price along with the local tax rate for
    the specific branch, we created a new method within the `NYC` class named `calc_tax_nyc`.
    Instead of creating a new method, we can also override the `Parent` method, `calc_tax`,
    with the new calculation in the child class. This concept is polymorphism within
    inheritance. Here is a representation of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – calc_tax method overridden in child class, NYC ](img/B13426_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – calc_tax method overridden in child class, NYC
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, polymorphism, let us first recall the `calc_tax` method from
    the `Branch` class, and then we can override it in the child class, `NYC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now define the `NYC` class by inheriting the `Branch` class. This class
    has two methods, `set_management` and `calc_tax`. The `set_management` method
    returns `intercitybranch` as a dictionary attribute. The `calc_tax` method is
    now overridden in the child class, `NYC`, and it returns branch details, intercity
    branch details, product details, and sales details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a representation of all the methods supported by the `branch_manhattan`
    object of the child class, `NYC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – calc_tax after polymorphism ](img/B13426_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – calc_tax after polymorphism
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code displays the results of calling the `calc_tax` method from
    `branch_manhattan`, which is the method overridden from its parent class to calculate
    the selling price after applying the local tax rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `calc_tax` method returns the output as defined in NYC.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in independent classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism need not always happen in a *parent-childpc* class relationship.
    We can always have two completely different classes that can have two different
    function definitions with the same name and the functions can both be utilized
    by calling them using their class object instances.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will be creating two independent classes, `Queens` and
    `Brooklyn`,, which are two different branches of *ABC Megamart*. We will not associate
    these branches with the `Branch` parent class in order to explain the concept
    of polymorphism in independent classes. The Brooklyn branch stocks only `maintenance_cost`,
    and defining them according to the requirements of storage for each branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Polymorphism of one method in independent classes ](img/B13426_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Polymorphism of one method in independent classes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, for the `Brooklyn` class, we will calculate the maintenance
    cost only if the product type is `FMCG`. We will calculate the product of quantity
    costing 0.25 and add 100 USD for cold storage. If the product type is anything
    other than FMCG, we will notify you that the product will not be stocked. Let’s
    take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, for the `Queens` class, we will calculate maintenance
    cost only if the product type is `Electronics`. We will calculate the product
    of quantity costing 0.05 since the maintenance cost for electronics is lower and
    there is also no cold storage cost required here. If the product type is anything
    other than `Electronics`, we will notify that the product will not be stocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we have used the same function names in both the preceding
    examples. The next step is to call these functions. Each of these functions can
    be called by creating an object for each class and the functions can be accessed
    separately to perform different calculations even when they are used within the
    same program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: We now have an understanding of the concept of polymorphism within classes.
    We will next look at abstraction, which behaves along the same lines as polymorphism
    but with a difference that will be explained further in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding details with abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ABC` that can be imported to define abstract base classes. Abstraction is
    more like giving a black box to external users by not revealing all the details
    of various methods defined inside a class but instead giving a reference class
    that can help the external users to implement the methods according to their own
    requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the users of the Brooklyn branch don’t have to know the calculations
    that are handled by the Queens branch to calculate their maintenance cost. The
    information that the users of the Brooklyn branch need to know is that they can
    inherit the `Branch` class and implement the calculations for maintenance costs
    according to their own books and they need not worry about how the Queens branch
    is calculating their maintenance costs. At the same time, the `Branch` class,
    which is their parent class, will not be able to provide one common implementation
    for calculating maintenance costs since the calculations are going to vary depending
    on the branch. In this kind of scenario, the `Branch` class can create an abstract
    method, `maintenance_cost`, and let its subclasses or child classes implement
    it according to their requirements. The implementation of the `maintenance_cost`
    method by Brooklyn will not impact the implementation of the same method by Queens;
    the purpose of the implementation ends within the child class and the parent abstract
    class is always available for other child classes to define their own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this kind of implementation can be done by simply applying polymorphism
    to a parent class method, then why do we need an abstract class to do the same?
    Let us first look at this by implementing a parent class and its child classes
    without actually implementing it as an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, we have two child classes for the `Branch`
    class and we have applied polymorphism to override the parent method, but it is
    still not an abstraction since we will be able to create an object instance for
    the parent class and the methods of the parent class can be exposed when an object
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the preceding implementation, if we make a slight modification and
    create `Branch` as an abstract base class, let us look at what happens then. Here
    is the representation of what we are going for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 -– Abstract class is inherited by two classes and the methods
    implemented ](img/B13426_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 -– Abstract class is inherited by two classes and the methods implemented
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will be importing `ABC` and `abstractmethod` from the `abc` library
    and we will create an abstract class called `Branch` followed by two child classes,
    `Brooklyn` and `Queens`, which inherit the parent class, `Branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: We imported the `ABC` library, created `Branch` as an abstract class, and defined
    `maintenance_cost` as an abstract method using the `@abstractmethod` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now try to create an object of the `Branch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'It throws the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Abstract method instantiation error ](img/B13426_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Abstract method instantiation error
  prefs: []
  type: TYPE_NORMAL
- en: If an object is instantiated for a class, all the attributes and methods of
    the class can be accessed through the object. It is possible in regular classes;
    whereas, in the case of an abstract class, an object cannot be instantiated. This
    is why it is helpful to hide information that need not be shared with external
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is a method of information protection in Python or any other OOP
    language. We will now look at encapsulation and more details on how information
    can be protected in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting information with encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`__` (double underscore) and protected members or variables are prefixed by
    `_` (single underscore). We will look at some examples of private and protected
    class members.'
  prefs: []
  type: TYPE_NORMAL
- en: Private members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, the concept of a private variable does not exist as in other OOP
    languages. However, we can add two underscore symbols before the name of a variable
    or method to signify that a specific variable will be used as a private member
    within the class. It is done so that the developer can understand the naming convention
    that the program treats the variable as private. Adding two underscores before
    the name of a variable or method prevents name mangling by the Python interpreter
    to avoid collisions with the variable during inheritance, and it is not an actual
    private member as in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will define our familiar `Branch` class with private variables
    for product ID, product name, brand, purchase price, and profit margin and create
    a private method to display the product details. We will also create branch ID,
    regional manager, and branch manager as class variables that are not private and
    look at the difference between accessing those using objects outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Private members of theBranch class and its accessibility by
    the Branch object  ](img/B13426_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Private members of theBranch class and its accessibility by the
    Branch object
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the following code to implement this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'On creating an object instance for the `Branch` class, we will be able to look
    at the results of the `__display_product_details` method since it is called within
    the class using the default `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us try to access the `branch_id` variable, which is not declared as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to access this variable. Let us now try to access `profit_margin`,
    which is declared with a prefix of double underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Error accessing private variable of a class  ](img/B13426_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Error accessing private variable of a class
  prefs: []
  type: TYPE_NORMAL
- en: 'We are getting an error since this variable can only be accessed within the
    class and not by the object of the class due to name mangling. The same applies
    to the private method created to display product details as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13426_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Error accessing private method of a class
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the list of class members for the `Branch` class
    that can be accessed by its object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Members accessible by the branch object after including private
    members ](img/B13426_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Members accessible by the branch object after including private
    members
  prefs: []
  type: TYPE_NORMAL
- en: However, these private members can be accessed outside the class by creating
    an API to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Protected members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will recreate the `Branch` class with protected variables
    for product ID, product name, brand, purchase price, and profit margin and create
    a protected method to display the product details. We will create a branch manager
    as a private variable. We will also create branch ID and regional manager as class
    variables that are not protected or private and look at the difference in accessing
    those using objects outside the class. We will also inherit the `Branch` class
    further to check which members are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Protected members of the Branch class and its accessibility
    by inherited subclasses  ](img/B13426_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Protected members of the Branch class and its accessibility by
    inherited subclasses
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the following code to implement this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'An object created by `Branch` cannot access its protected members too similar
    to the private members, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Members accessible by branch object after including protected
    members ](img/B13426_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Members accessible by branch object after including protected
    members
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a child class called `Brooklyn` that inherits the parent class,
    `Branch`. The child class will inherit all the protected variables and methods
    from the parent class, whereas it will still not inherit the private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: The `product_id` variable is a protected member of the parent class and `display_product_details`
    is also a protected member of the parent class, which is accessible by the `init`
    method of the child class, `Brooklyn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now include a private member of the parent class and check whether it
    can be accessed from the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'The following error clarifies that private members will still not be accessible
    by the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20  – Error accessing private attribute of a parent class from its
    child class ](img/B13426_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20  – Error accessing private attribute of a parent class from its
    child class
  prefs: []
  type: TYPE_NORMAL
- en: These examples give us an understanding of how encapsulation can be implemented
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the concept of classes and objects and looked at
    examples of how to create classes and object instances. We also learned the concept
    of methods and how to create methods inside classes. Along with this, we saw how
    to apply inheritance and multiple inheritances to classes and apply polymorphism
    to methods. We then learned how to create abstract classes and methods. Finally,
    we learned the concept of encapsulation and how to restrict access to methods
    and variables of a class.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has provided a review of all the concepts of OOP in Python, which
    is going to act as the foundation for the main topic of this book, which is metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see in detail the concept of decorators and their
    implementation with examples.
  prefs: []
  type: TYPE_NORMAL
