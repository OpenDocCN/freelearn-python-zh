- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: SQL and Data Modeling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 和数据建模
- en: So far, we’ve explored React, a key library in frontend technology stacks. Now,
    we will explore the world of backend development, starting with **Structured Query
    Language** (**SQL**) and data modeling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 React，它是前端技术堆栈中的一个关键库。现在，我们将探索后端开发的世界，从**结构化查询语言**（**SQL**）和数据建模开始。
- en: SQL and data modeling are critical skills for any backend developer, and starting
    with these skills in the backend development journey will give you a strong foundation
    to build robust and scalable web applications. SQL is a standard language used
    to manage data in relational databases, which are essentially used to store structured
    data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 和数据建模是任何后端开发人员的关键技能，在后端开发之旅中从这些技能开始将为你打下构建稳健和可扩展的Web应用的基础。SQL 是一种标准语言，用于管理关系数据库中的数据，这些数据库本质上用于存储结构化数据。
- en: Knowledge of SQL will help you to write optimized SQL queries that can improve
    the performance of your application and reduce server load. Data modeling will
    help you to design a database schema that reflects the data your application will
    work with. Data modeling can help you avoid performance issues, maintainability
    problems, and other common issues that may arise when working with databases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握 SQL 将帮助你编写优化的 SQL 查询，从而提高应用程序的性能并减少服务器负载。数据建模将帮助你设计一个反映应用程序将处理的数据的数据库模式。数据建模可以帮助你避免性能问题、可维护性问题以及其他在数据库工作中可能出现的常见问题。
- en: We will dive deeply into relational databases and how database tables can relate
    to one another. We will examine SQL as a standard language used by many database
    management systems, including **PostgreSQL**, a popular open source **relational
    database management** **system** (**RDBMS**).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨关系数据库以及数据库表如何相互关联。我们将检查 SQL，这是许多数据库管理系统使用的标准语言，包括流行的开源**关系数据库管理系统**（**RDBMS**）**PostgreSQL**。
- en: Having a robust understanding of relational databases and knowledge of how database
    relationships work will help you design scalable and maintainable data structures.
    We will leave no stone unturned, cruising through the setup of PostgreSQL and
    exploring how Flask applications can communicate with PostgreSQL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对关系数据库有深入的理解，并了解数据库关系如何工作，将帮助你设计可扩展和可维护的数据结构。我们将不遗余力，从设置 PostgreSQL 开始，探索 Flask
    应用程序如何与 PostgreSQL 通信。
- en: We will also discuss in depth the ability of SQLAlchemy to handle various relational
    database dialects by providing an interface that allows SQL interaction with a
    database using Python objects. **SQLAlchemy** is an industrial-strength object-relational
    mapper that provides a powerful interface for interaction with various relational
    database dialects, including PostgreSQL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入讨论 SQLAlchemy 通过提供一个允许使用 Python 对象与数据库进行 SQL 交互的接口，来处理各种关系数据库方言的能力。**SQLAlchemy**
    是一个工业级对象关系映射器，它为与各种关系数据库方言（包括 PostgreSQL）的交互提供了一个强大的接口。
- en: SQLAlchemy makes it easier to write complex database queries and manage database
    transactions. We will examine how you can come up with a data model and send data
    from a Flask application to a database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 使得编写复杂的数据库查询和管理数据库事务变得更容易。我们将检查您如何提出数据模型，并将数据从 Flask 应用程序发送到数据库。
- en: In addition to data modeling and SQL, migration is also a crucial aspect of
    backend development. We will examine migration as a way of tracking and updating
    database structures with Alembic. **Alembic** is a migration tool that provides
    a reliable way of tracking and updating database structures, making it an essential
    tool for Python developers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据建模和 SQL，迁移也是后端开发的一个关键方面。我们将通过 Alembic 来检查迁移，作为跟踪和更新数据库结构的一种方式。**Alembic**
    是一个迁移工具，它提供了一种可靠的方式来跟踪和更新数据库结构，对于 Python 开发人员来说是一个必不可少的工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is the relational data model?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是关系数据模型？
- en: Exploring the different database relationships
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同的数据库关系
- en: Setting up PostgreSQL
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 PostgreSQL
- en: Understanding database concepts for Flask applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Flask 应用程序的数据库概念
- en: Understanding SQLAlchemy ORM basics
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SQLAlchemy ORM 基础
- en: Modeling data for the speakers conference web application
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为演讲者会议 Web 应用程序建模数据
- en: Sending data to the PostgreSQL database from a Flask application
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Flask 应用程序向 PostgreSQL 数据库发送数据
- en: Migration with Alembic
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Alembic 进行迁移
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08)。
- en: What is the relational data model?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是关系数据模型？
- en: The **relational data model** is a conceptual approach used to represent a database
    as a group of relations. Most web applications are highly data-driven. Developers
    have to deal with either code-level data storage, in the case of a data structure,
    or find a way to persistently store data in an RDBMS, such as PostgreSQL or MySQL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据模型**是一种概念方法，用于将数据库表示为一组关系。大多数Web应用程序都是高度数据驱动的。开发者必须处理代码级别的数据存储，在数据结构的情况下，或者找到一种方法在关系型数据库管理系统（如PostgreSQL或MySQL）中持久化存储数据。'
- en: In an RDBMS, you can refer to a table as a relation. Therefore, a relational
    model represents data as a collection of relations or tables. Breaking down the
    database structure further, you then have rows and columns making up a table.
    Then, you have a record, which consists of a combination of rows and columns.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库管理系统中，你可以将表格称为关系。因此，关系模型将数据表示为关系或表格的集合。进一步分解数据库结构，你将得到构成表格的行和列。然后，你有一个记录，它由行和列的组合组成。
- en: 'Let’s take a look at a hypothetical table named `customers` that depicts the
    structure of a typical table for clarity:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个名为`customers`的假设表格，它以清晰的方式描述了典型表格的结构：
- en: '| `Id` | `firstname` | `lastname` | `email` | `phone` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Id` | `firstname` | `lastname` | `email` | `phone` |'
- en: '| 1 | Joel | Doe | Joel@admin.com | 404-228-5487 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Joel | Doe | Joel@admin.com | 404-228-5487 |'
- en: '| 2 | Edward | Spinster | Edward@admin.com | 403-268-6486 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Edward | Spinster | Edward@admin.com | 403-268-6486 |'
- en: '| 3 | Mabel | Emmanuel | Mabel@admin.com | 402-248-4484 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Mabel | Emmanuel | Mabel@admin.com | 402-248-4484 |'
- en: Table 8.1 – A table showing customer information
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 展示客户信息的表格
- en: In the preceding `customers` table, we have five columns and three rows. Each
    row in a table is called a tuple. The column headers such as `Id`, `firstname`,
    `lastname`, `email`, and `phone` are called attributes or fields. In a database,
    tables are created to store data efficiently. Each table usually represents a
    business entity or object such as a speaker, venue, subject, customer, product,
    order, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`customers`表格中，我们有五列和三行。表格中的每一行称为一个元组。列标题如`Id`、`firstname`、`lastname`、`email`和`phone`被称为属性或字段。在数据库中，表格被创建来高效地存储数据。每个表格通常代表一个业务实体或对象，例如演讲者、场地、主题、客户、产品、订单等。
- en: For clarity, a business entity represents things we intend to encapsulate in
    the application business data model with all the rules, relationships, and ability
    to be persistent in the database. In the preceding table, we have a customer business
    entity with the following attributes – `Id`, `firstname`, `lastname`, `email`,
    and `phone`. More often than not, you would have more than one table in your web
    application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，业务实体代表我们打算在应用程序业务数据模型中封装的事物，包括所有规则、关系和能够在数据库中持久化的能力。在前面的表格中，我们有一个客户业务实体，具有以下属性
    – `Id`、`firstname`、`lastname`、`email`和`phone`。通常情况下，你会在你的Web应用程序中拥有不止一个表格。
- en: Expectedly, you need to be able to relate these different tables or relations
    in your database using primary keys. The primary key is the unique identifier
    for the entire row of a table, referring to one or more columns. And if there
    are multiple columns for the primary key, then the set of primary key columns
    is known as a composite key. In our case, `Id` in the customer table could be
    set as the primary key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 预计你需要能够使用主键在你的数据库中的不同表格或关系之间建立联系。主键是表格中整行唯一的标识符，指代一个或多个列。如果有多个列用于主键，那么主键列的集合被称为复合键。在我们的例子中，客户表中的`Id`可以设置为主键。
- en: Additionally, another concept in data relation is a foreign key. A foreign key
    refers to a primary key in another (foreign) table. Foreign keys are used to map
    relationships between tables or relations. The table relationship helps you to
    store data efficiently where it needs to be stored, and accessing related data
    becomes easier when needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据关系中的另一个概念是外键。外键指的是另一个（外部）表格中的主键。外键用于映射表格或关系之间的关系。表格关系帮助你高效地存储需要存储的数据，并在需要时更容易访问相关数据。
- en: There are many relationships in database design – *one-to-one*, *one-to-many*,
    and *many-to-many*. For instance, related tables in a database can help you find
    out orders made by your customers, how many conference attendees are currently
    enrolled in each subject, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计中存在许多关系——*一对一*、*一对多*和*多对多*。例如，数据库中的相关表可以帮助你找出客户下的订单，了解有多少会议参与者注册了每个主题，等等。
- en: In the next section, we will extensively discuss the relationships in a database
    and how they are used in web application architectural design.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将广泛讨论数据库中的关系以及它们在Web应用程序架构设计中的应用。
- en: Exploring the different database relationships
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索不同的数据库关系
- en: In the client-server model, the database resides at the server end of the infrastructure.
    The database is core to any production-grade web application in collecting and
    storing application data. Understanding relationships that exist in a database
    is vital for organizing, managing, and retrieving useful data from a database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器模型中，数据库位于基础设施的服务器端。数据库是任何生产级Web应用程序收集和存储应用程序数据的核心。理解数据库中存在的关系对于组织、管理和从数据库中检索有用数据至关重要。
- en: As previously mentioned, there are three types of relationships that exist in
    a database – *one-to-one*, *one-to-many*, and *many-to-many*. We will begin by
    delving into the concept of a one-to-one relationship.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据库中存在三种类型的关系——*一对一*、*一对多*和*多对多*。我们将从深入研究一对一关系的概念开始。
- en: One-to-one (1:1) relationship
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一（1:1）关系
- en: A `speakers` and `speakerExtras`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`speakers`和`speakerExtras`。'
- en: '![Figure 8.1 – An entity relationship diagram showing the one-to-one relationship](img/Figure_8.1_B18554.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 显示一对一关系的实体关系图](img/Figure_8.1_B18554.jpg)'
- en: Figure 8.1 – An entity relationship diagram showing the one-to-one relationship
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 显示一对一关系的实体关系图
- en: The preceding diagram depicts the `speakers` table and the `speakerExtras` table.
    The `speakers` table details the basic required information of a speaker object,
    while the `speakerExtras` table showcases the optional information that can be
    added to speaker information. `speaker_id` in the `speakers` table is the primary
    key that can be used to uniquely identify a speaker record.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了`speakers`表和`speakerExtras`表。`speakers`表详细说明了演讲者对象的基本必要信息，而`speakerExtras`表则展示了可以添加到演讲者信息中的可选信息。`speakers`表中的`speaker_id`是主键，可以用来唯一标识一个演讲者记录。
- en: In the `speakerExtras` table, a column is added as `speaker_id`. This `speaker_id`
    column in the `speakerExtras` table is a foreign key with a unique attribute.
    This `speaker_id` column is used as a reference key for `speaker_id` in the `speakers`
    table to form a one-to-one relationship between the `speakerExtras` table and
    the `speakers` table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`speakerExtras`表中，增加了一个名为`speaker_id`的列。`speakerExtras`表中的这个`speaker_id`列是一个具有唯一属性的外键。这个`speaker_id`列被用作对`speakers`表中的`speaker_id`的引用键，以在`speakerExtras`表和`speakers`表之间形成一个一对一关系。
- en: Most of the time, the one-to-one relationship data model can actually be merged.
    Merging a one-to-one relationship data model typically means combining the tables
    into a single table. This is usually done when the two tables have a strong connection
    and the data in the tables is not complex enough to warrant having separate tables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，一对一关系的数据模型实际上可以合并。合并一对多关系的数据模型通常意味着将表合并为一个单一的表。这通常是在两个表有强烈的联系，且表中的数据并不复杂到需要单独的表时进行的。
- en: However, there are cases where the database design requirement may be a separate
    table for information that may be optional, so rather than having an empty column
    in a table, you can create a different table to handle this optional information
    for better database performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，数据库设计的要求可能需要一个单独的表来处理可能的可选信息，因此，而不是在表中留有空列，你可以创建一个不同的表来处理这些可选信息，以获得更好的数据库性能。
- en: Let’s take a look at another database relationship, one-to-many.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一种数据库关系，一对多。
- en: One-to-many (1:M) relationship
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多（1:M）关系
- en: A **one-to-many relationship** in a data model explains a relationship between
    two tables, in which a row in one table can reference one or many rows in another
    table. The one-to-many relationship is a kind of parent-child relationship where
    a child record can only have one parent record.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型中的一对多关系解释了两个表之间的关系，其中一个表中的一行可以引用另一个表中的一行或多行。一对多关系是一种父子关系，其中子记录只能有一个父记录。
- en: Most of the time, the parent record has more than one child in another table’s
    rows. However, in a real-life scenario, we could have a situation in which a parent
    record has no child record at all. What does a parent with no child record mean?
    It means that the foreign key column in the child table will be empty for that
    parent record.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，父记录在另一个表的行中有多于一个子记录。然而，在现实场景中，我们可能会遇到一个父记录没有任何子记录的情况。没有子记录的父记录意味着子表中的外键列将为该父记录为空。
- en: For instance, consider a database design for a store where each customer can
    have multiple orders. If a new customer record is created but no orders have been
    placed yet, there will be a customer record with no corresponding order records.
    In this case, the customer record is the parent record, and the order records
    are the child records.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个商店的数据库设计，每个客户可以有多个订单。如果一个新客户记录被创建，但还没有下订单，那么将有一个没有对应订单记录的客户记录。在这种情况下，客户记录是父记录，订单记录是子记录。
- en: Furthermore, a one-to-many relationship in some cases also allows a single record
    in another table. There are cases where a one-to-many relationship can be constrained
    to functionally act as a one-to-one relationship. For instance, you could add
    a unique constraint to the foreign key column in the child table, ensuring that
    each record in the parent table is associated with, at most, one record in the
    child table.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，一对多关系也允许另一个表中的单个记录。存在一些情况，一对多关系可以被限制为功能上作为一对一关系。例如，你可以在子表的外键列上添加唯一约束，确保父表中的每个记录最多与子表中的一个记录相关联。
- en: This would effectively constrain the relationship to function as a one-to-one
    relationship, even though the underlying data model is a one-to-many relationship.
    This one-to-many relationship is almost similar to a one-to-one relationship but
    with a subtle difference of a unique constraint. Why is this one-to-many relationship
    important in data modeling?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地将关系约束为作为一对一关系，尽管底层的数据模型是一对多关系。这种一对多关系几乎类似于一对一关系，但有一个唯一约束的细微差别。为什么这种一对多关系在数据建模中很重要？
- en: Like other database relationships, the one-to-many relationship is a fundamental
    building block of relational database design and is essential for organizing,
    managing, and analyzing complex data structures. The one-to-many relationship
    enforces referential integrity of data by ensuring that each record in the child
    table is associated with a valid record in the parent table. This approach helps
    prevent data inconsistencies and errors that can arise from orphan records or
    references to non-existent records.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他数据库关系一样，一对多关系是关系数据库设计的基本构建块，对于组织、管理和分析复杂数据结构至关重要。一对多关系通过确保子表中的每个记录都与父表中的一个有效记录相关联，强制执行数据的引用完整性。这种方法有助于防止由孤立记录或对不存在记录的引用引起的数据不一致性和错误。
- en: Let’s take a look at an example of a one-to-many relationship. Imagine we have
    `customers` and `orders` tables in our database. It is possible for a customer
    to have many 1:M orders with a business over a period of time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个一对多关系的例子。想象一下，在我们的数据库中有`customers`（客户）和`orders`（订单）表。一个客户在一段时间内可能有很多1:M的订单。
- en: A business might want to keep this record. For example, customers tend to have
    different orders; a particular `orderID` can’t belong to many customers. Every
    customer’s order is unique. The following diagram depicts a one-to-many relationship
    between customers and orders.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个企业可能希望保留这个记录。例如，客户往往有不同的订单；特定的`orderID`不能属于多个客户。每个客户的订单都是唯一的。以下图展示了客户和订单之间的一对多关系。
- en: '![Figure 8.2 – An entity relationship diagram showing the one-to-many relationship](img/Figure_8.2_B18554.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 显示一对多关系的实体关系图](img/Figure_8.2_B18554.jpg)'
- en: Figure 8.2 – An entity relationship diagram showing the one-to-many relationship
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 显示一对多关系的实体关系图
- en: In the preceding diagram, `customer_id` in the `orders` table represents the
    foreign key and the main linking factor between the two entities – `customers`
    and `orders`. If you want to know the number of orders a particular customer has,
    all you need to do is write a `JOIN` query that tends to look up `customers` and
    `orders` tables, and check for the occurrence of `customer_id` in the `orders`
    table as a reference key.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`orders` 表中的 `customer_id` 代表外键，是两个实体——`customers` 和 `orders` 之间的主要链接因素。如果你想了解某个特定客户有多少订单，你只需要编写一个
    `JOIN` 查询，查找 `customers` 和 `orders` 表，并检查 `orders` 表中作为参考键的 `customer_id` 的出现情况。
- en: In the database design for your web application development, you will encounter
    more of this data relationship, as it is the most commonly used one. Next, we
    take a look at another database relationship, many-to-many.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络应用程序开发数据库设计中，你将遇到更多这种数据关系，因为它是最常用的。接下来，我们将看看另一种数据库关系，多对多。
- en: Many-to-many (M:M) relationship
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多（M:M）关系
- en: 'A **many-to-many relationship** in data modeling simply refers to a data relationship
    in which multiple records in one table are related to multiple records in another
    table. Take, for instance, a conference database design, where you could have
    the following scenarios:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模中的 **多对多关系** 简单来说是指一个表中的多条记录与另一个表中的多条记录相关联的数据关系。以会议数据库设计为例，你可能会有以下场景：
- en: An attendee can be enrolled in multiple conference sessions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参与者可以注册多个会议
- en: A session can have many attendees enrolled in it
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个会议可以有许多注册的参与者
- en: This implies that an attendee has many conference sessions, and a conference
    session has many attendees. Thus, there is a many-to-many relationship between
    the conference attendees and sessions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个参与者可以参加多个会议，一个会议也有许多参与者。因此，会议参与者和会议之间存在多对多关系。
- en: Interestingly, unlike a one-to-one relationship and one-to-many relationship,
    you can’t model a many-to-many relationship with just two tables. In many-to-many
    relationship modeling, a third join table is required, whereby you have the values
    of the primary keys of the two tables added to the join table.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与一对一关系和一对多关系不同，你不能只用两个表来建模多对多关系。在多对多关系建模中，需要一个第三张连接表，其中包含两个表的主键值添加到连接表中。
- en: 'Let’s examine the **entity relationship** (**ER**) diagram of a many-to-many
    relationship for conference attendees and the sessions they enroll in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查会议参与者和他们注册的会议的多对多关系的 **实体关系图**（**ER**）：
- en: '![Figure 8.3 – An entity relationship diagram showing the many-to-many relationship](img/Figure_8.3_B18554.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 显示多对多关系的实体关系图](img/Figure_8.3_B18554.jpg)'
- en: Figure 8.3 – An entity relationship diagram showing the many-to-many relationship
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 显示多对多关系的实体关系图
- en: Let’s break down the preceding ER diagram to have a better understanding of
    the many-to-many relationship. We have three tables, as clearly shown – `attendees`,
    `enrollemnt_tbl`, and `conf_sessions`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的 ER 图，以便更好地理解多对多关系。我们有三张表，如上图所示——`attendees`、`enrollemnt_tbl` 和 `conf_sessions`。
- en: The `attendees` table contains records for conference attendees. Likewise, the
    `conf_sessions` table contains records for conference sessions. You then have
    a join table, `enrollment_tbl`, which technically forms a one-to-many relationship
    with each of the two tables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`attendees` 表包含会议参与者的记录。同样，`conf_sessions` 表包含会议的记录。然后你有一个连接表 `enrollment_tbl`，它在技术上与两个表各自形成一个一对一关系。'
- en: '`enrollment_tbl` contains the primary keys of both the attendees and the `conf_sessions`
    tables as foreign keys. With `enrollment_tbl`, we can query related records from
    the attendees and `conf_sessions` tables. In this case, we can access all the
    sessions a particular attendee attends at the conference.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`enrollment_tbl` 包含参与者和 `conf_sessions` 表的主键作为外键。通过 `enrollment_tbl`，我们可以查询参与者和
    `conf_sessions` 表的相关记录。在这种情况下，我们可以访问特定参与者参加的所有会议。'
- en: Next, we will delve deeper into database setup, using SQLAlchemy and Alembic,
    for the database part of a web application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨数据库设置，使用 SQLAlchemy 和 Alembic 来处理网络应用程序的数据库部分。
- en: Setting up PostgreSQL, SQLAlchemy, and Alembic
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 PostgreSQL、SQLAlchemy 和 Alembic
- en: We are going to start by setting up the database tools needed for the backend
    database. PostgreSQL is a popular free and open source RDBMS. It is similar to
    other dialects of the **SQL** databases that exist – for example, MySQL, MariaDB,
    and Oracle. This database can be used to store data for any web application. PostgreSQL
    has enterprise-grade features that make it robust, scalable, and reliable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置后端数据库所需的数据库工具。PostgreSQL 是一个流行的免费开源关系型数据库管理系统。它与存在的其他 SQL 数据库方言类似 – 例如，MySQL、MariaDB
    和 Oracle。此数据库可以用于存储任何 Web 应用的数据。PostgreSQL 具有企业级功能，使其强大、可扩展和可靠。
- en: We will also set up SQLAlchemy, an `read`, `insert`, `update`, and `delete`,
    rather than writing SQL queries directly. Finally, in this section, we will set
    up Alembic to handle database migrations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置 SQLAlchemy，一个用于`读取`、`插入`、`更新`和`删除`的工具，而不是直接编写 SQL 查询。最后，在本节中，我们将设置 Alembic
    以处理数据库迁移。
- en: Setting up PostgreSQL
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 PostgreSQL
- en: To get started with PostgreSQL locally on your machine, download it from [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    and select your operating system package.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地机器上开始使用 PostgreSQL，请从 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    下载它并选择您的操作系统包。
- en: '![Figure 8.4 – A diagram showing the download page of PostgreSQL](img/Figure_8.4_B18554.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 一张显示 PostgreSQL 下载页面的图表](img/Figure_8.4_B18554.jpg)'
- en: Figure 8.4 – A diagram showing the download page of PostgreSQL
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 一张显示 PostgreSQL 下载页面的图表
- en: Run through the installation wizard by following the instructions to set up
    the database. During the PostgreSQL installation, you will be prompted to enter
    a super user password. It is very important you keep the password you entered
    as super user, as this will be required to log in to the default PostgreSQL database.
    Once the installation is complete, log in to the database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明运行安装向导以设置数据库。在 PostgreSQL 安装过程中，您将被提示输入超级用户密码。非常重要，您需要保留您输入的超级用户密码，因为这将用于登录默认的
    PostgreSQL 数据库。一旦安装完成，请登录到数据库。
- en: 'Open the command terminal on your machine and type the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您机器上的命令终端并输入以下命令：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`psql` invokes a connection to PostgreSQL from the terminal. Then, you can
    use the `-d` option to select the database you want to access and `-U` to select
    the user with access permission to the database.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`psql` 从终端调用与 PostgreSQL 的连接。然后，您可以使用 `-d` 选项选择您想要访问的数据库，并使用 `-U` 选择具有数据库访问权限的用户。'
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the command terminal replies with `psql not recognized as an internal or
    external command`, you might need to add the Postgres `bin/ (C:\Program Files\PostgreSQL\14\bin`)
    to the system path of the environment variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令终端回复“`psql`不是内部或外部命令”，您可能需要将 Postgres `bin/ (C:\Program Files\PostgreSQL\14\bin)`
    添加到环境变量的系统路径中。
- en: Then, enter the password you created for the superuser during the installation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入安装期间为超级用户创建的密码。
- en: The following screenshot shows the terminal while trying to log in to PostgreSQL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了尝试登录 PostgreSQL 时的终端。
- en: '![Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal](img/Figure_8.5_B18554.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 一张显示如何从终端访问 PostgreSQL 的屏幕截图](img/Figure_8.5_B18554.jpg)'
- en: Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 一张显示如何从终端访问 PostgreSQL 的屏幕截图
- en: 'It is always a best practice to create a new user on Postgres, different from
    the superuser created during the installation. Now that you are logged in with
    the default Postgres user, let’s create another user role called `admin` and assign
    it the password `admin123`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总是创建一个与安装期间创建的超级用户不同的新用户在 Postgres 上是一个最佳实践。现在您已使用默认的 Postgres 用户登录，让我们创建另一个名为
    `admin` 的用户角色，并为其分配密码 `admin123`：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now give a new user `admin` permission to create a database:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将给新用户 `admin` 授予权限以创建数据库：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With all this set, log out from the Postgres user and log in as `admin`. To
    log out, type the `\``q` command.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好所有这些之后，从 Postgres 用户注销并作为 `admin` 登录。要注销，请输入 `\q` 命令。
- en: 'Now, log in as an `admin` user:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以 `admin` 用户身份登录：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Enter the admin password and log in. Once logged in, create a new database
    called `bizza`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输入管理员密码并登录。登录后，创建一个名为 `bizza` 的新数据库：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To connect to the newly created database, run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到新创建的数据库，请运行以下命令：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows how to connect to create a database in PostgreSQL:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何在 PostgreSQL 中连接以创建数据库：
- en: '![Figure 8.6 – A screenshot showing a connection to the bizza database](img/Figure_8.6_B18554.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 显示连接到 bizza 数据库的屏幕截图](img/Figure_8.6_B18554.jpg)'
- en: Figure 8.6 – A screenshot showing a connection to the bizza database
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 显示连接到 bizza 数据库的屏幕截图
- en: Hurray! We have set up PostgreSQL successfully. Now, let’s dive into setting
    up SQLAlchemy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！我们已经成功设置了 PostgreSQL。现在，让我们深入了解设置 SQLAlchemy。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The role name, `admin`, and password, `admin123`, could be anything you want;
    they don’t have to be named as suggested.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 角色名称，`admin`，和密码，`admin123`，可以是您想要的任何名称；它们不必按照建议命名。
- en: Setting up SQLAlchemy
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 SQLAlchemy
- en: 'Setting up SQLAlchemy for a Flask application is simple and straightforward.
    To set up SQLAlchemy in your project, let’s install SQLAlchemy with the following
    command in the Terminal right inside your project `root` directory. Make sure
    your virtual environment is activated before running the installation command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Flask 应用程序设置 SQLAlchemy 简单直接。要在您的项目中设置 SQLAlchemy，请在终端中运行以下命令，直接在您的项目 `root`
    目录内。在运行安装命令之前，请确保您的虚拟环境已激活：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SQLAlchemy is a Python SQL toolkit and ORM library that provides a set of high-level
    APIs to interact with relational databases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是一个 Python SQL 工具包和 ORM 库，它提供了一套高级 API，用于与关系数据库交互。
- en: 'In addition, we will use a Flask extension called **Flask-SQLAlchemy**. Let’s
    install it by running the following command in the terminal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用一个名为 **Flask-SQLAlchemy** 的 Flask 扩展。让我们在终端中运行以下命令来安装它：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Flask-SQLAlchemy extension provides a wrapper for SQLAlchemy, making it
    easier to use SQLAlchemy in a Flask application. Flask-SQLAlchemy provides additional
    features, such as automatic session handling, integration with Flask’s application
    context, and support for Flask-specific configuration options.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy 扩展为 SQLAlchemy 提供了一个包装器，使得在 Flask 应用程序中使用 SQLAlchemy 更加容易。Flask-SQLAlchemy
    提供了额外的功能，例如自动会话处理、与 Flask 的应用程序上下文集成以及支持 Flask 特定的配置选项。
- en: SQLAlchemy will be discussed deeply in the subsequent section of this chapter,
    *Understanding SQLAlchemy* *ORM basics*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将深入讨论 SQLAlchemy，*理解 SQLAlchemy ORM 基础*。
- en: 'Briefly, let’s demonstrate how you can seamlessly integrate SQLAlchemy into
    your Flask application. The process of integrating SQLAlchemy is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，让我们演示如何无缝地将 SQLAlchemy 集成到您的 Flask 应用程序中。集成 SQLAlchemy 的过程如下：
- en: Create a new directory and name it `sqlalchemy`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录，并将其命名为 `sqlalchemy`。
- en: Then, follow the Flask project setup in the *Setting up the development environment
    with Flask* section of [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照 *第 1 章* 的 *使用 Flask 设置开发环境* 部分的 Flask 项目设置进行操作。[第 1 章](B18554_01.xhtml#_idTextAnchor014)。
- en: Make sure your development virtual environment is activated.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的开发虚拟环境已激活。
- en: 'In the terminal, run the following commands:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a file named `app.py` within the `sqlalchemy` directory, and add the
    following code snippet:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sqlalchemy` 目录中创建一个名为 `app.py` 的文件，并添加以下代码片段：
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code sets up a basic Flask application that uses SQLAlchemy for
    database operations. Let’s explain what happens in the preceding code:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码设置了一个基本的 Flask 应用程序，该应用程序使用 SQLAlchemy 进行数据库操作。让我们解释一下上述代码中发生了什么：
- en: '`from flask import Flask`: This imports the `Flask` class from the Flask package.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from flask import Flask`: 这从 Flask 包中导入 `Flask` 类。'
- en: '`from flask_sqlalchemy import SQLAlchemy`: This imports the `SQLAlchemy` class
    from the Flask-SQLAlchemy package.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from flask_sqlalchemy import SQLAlchemy`: 这从 Flask-SQLAlchemy 包中导入 `SQLAlchemy`
    类。'
- en: '`app = Flask(__name__, template_folder="templates")`: This creates a new `Flask`
    application instance. `template_folder` is added to ensure that Flask finds the
    `templates` directory. `App.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///bizza.db"`:
    This sets the database URI for the SQLite database. In this case, the database
    file is called `bizza.db` and is located in the `instance` directory of the Flask
    application file, `app.py`. We use `SQLite` in this example. You can use any database
    dialect – MySQL, Oracle, PostgreSQL, and so on.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app = Flask(__name__, template_folder="templates")`: 这将创建一个新的 `Flask` 应用程序实例。`template_folder`
    被添加以确保 Flask 能够找到 `templates` 目录。`App.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///bizza.db"`:
    这设置了 SQLite 数据库的数据库 URI。在这种情况下，数据库文件名为 `bizza.db`，位于 Flask 应用程序文件 `app.py` 的 `instance`
    目录中。我们在这个例子中使用 `SQLite`。您可以使用任何数据库方言 – MySQL、Oracle、PostgreSQL 等。'
- en: '`db = SQLAlchemy(app)`: This creates a new `SQLAlchemy` instance that is bound
    to the Flask application.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db = SQLAlchemy(app)`: 这将创建一个新的 `SQLAlchemy` 实例，并将其绑定到 Flask 应用程序。'
- en: Then, we have a Flask route handler that responds to the `/users` URL endpoint.
    When a user visits the `/users` URL, Flask will execute the `get_users` function,
    retrieve all the users from the database, and render the `users.html` template,
    passing the user’s variable to the template for display.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个 Flask 路由处理器，它响应`/users` URL 端点。当用户访问`/users` URL 时，Flask 将执行`get_users`函数，从数据库中检索所有用户，并渲染`users.html`模板，将用户变量传递给模板以进行显示。
- en: Lastly, we have the `User` model with four columns – `id`, `username`, `name`,
    and `email`. Each column represents a field in the corresponding database table
    and specifies its data type and optional constraints, such as uniqueness. This
    represents how we use SQLAlchemy in Flask to define our models as Python classes,
    specify their attributes and relationships, and perform database operations.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有包含四个列的`User`模型——`id`、`username`、`name`和`email`。每一列代表相应数据库表中的一个字段，并指定其数据类型和可选约束，如唯一性。这代表了我们在
    Flask 中使用 SQLAlchemy 定义我们的模型作为 Python 类，指定它们的属性和关系，并执行数据库操作的方式。
- en: Now, let’s create the `users` table in the terminal of the `sqlalchemy` directory.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们在`sqlalchemy`目录的终端中创建`users`表。
- en: 'Enter the following commands in the terminal:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入以下命令：
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, enter the `flask run` command and go to `http://127.0.0.1:5000/users`
    to view the users list from the database.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入`flask run`命令，并访问`http://127.0.0.1:5000/users`来查看数据库中的用户列表。
- en: The following is a screenshot that shows how you can use SQLAlchemy to define
    and retrieve users’ data.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个屏幕截图，展示了你如何使用 SQLAlchemy 定义和检索用户数据。
- en: '![Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations](img/Figure_8.7_B18554.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 展示如何使用 SQLAlchemy 进行数据库操作的屏幕截图](img/Figure_8.7_B18554.jpg)'
- en: Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 展示如何使用 SQLAlchemy 进行数据库操作的屏幕截图
- en: With this setup, we have demonstrated how you can define the SQLAlchemy model
    and use Python objects to interact with the database in a Flask application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种设置，我们展示了你如何定义 SQLAlchemy 模型，并使用 Python 对象在 Flask 应用程序中与数据库交互。
- en: Next, we will dive into how you can set up Alembic, a database migration tool.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解如何设置 Alembic，这是一个数据库迁移工具。
- en: Setting up Alembic
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Alembic
- en: '`pip install alembic` or install it from another migration package, `Flask-Migrate`,
    using `pip install flask-migrate`. `Flask-Migrate` relies on Alembic for database
    migration, and we will use it here as a tool of choice for database migration.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install alembic`或从另一个迁移包`Flask-Migrate`安装它，使用`pip install flask-migrate`。`Flask-Migrate`依赖于
    Alembic 进行数据库迁移，我们将在这里将其作为数据库迁移的首选工具。'
- en: The `Flask-Migrate` migration tool allows you to track changes to your database.
    Migration tools come with the ability to manage database structure and operations
    using a migration script. The essence of Alembic, a migration tool, is to facilitate
    the automatic generation of migration SQL scripts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Migrate`迁移工具允许你跟踪数据库的变化。迁移工具带有使用迁移脚本管理数据库结构和操作的能力。迁移工具 Alembic 的本质是简化迁移
    SQL 脚本的自动生成。'
- en: In the last section of this chapter, we will discuss migration in depth with
    some implementation details. Next, we will discuss how you can interact with a
    database from a Flask web application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将深入讨论迁移，并提供一些实现细节。接下来，我们将讨论如何从 Flask 网络应用程序与数据库交互。
- en: Understanding database concepts for Flask applications
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Flask 应用程序的数据库概念
- en: Now that we have set up our database and connected with it using the Terminal,
    it is crucial to have a solid understanding of some database concepts to be able
    to set up backend services that can collect, store, and retrieve users’ data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了数据库并使用终端连接到它，对一些数据库概念有一个扎实的理解对于能够设置能够收集、存储和检索用户数据的后端服务至关重要。
- en: Most modern web applications have a database to store users’ data. As a full
    stack web developer, part of your responsibility is to be able to set up backend
    services that can collect, store, and retrieve users’ data. We will dive into
    interacting with databases from a Flask application shortly, but before that there
    are few database concepts you need to understand.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代网络应用都有一个数据库来存储用户数据。作为一名全栈网络开发者，你的部分责任是能够设置后端服务来收集、存储和检索用户数据。我们将在不久的将来深入探讨从
    Flask 应用程序与数据库的交互，但在那之前，有一些数据库概念你需要理解。
- en: Let’s take a quick overview of the following database concepts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速概述以下数据库概念。
- en: RDBMS
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）
- en: When working with a database in a production environment, you need an RDBMS.
    An RDBMS is a software package that allows you to interact with a database. The
    RDBMS software allows you to define, manipulate, retrieve, and manage data in
    a database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中与数据库工作时，您需要一个关系型数据库管理系统（RDBMS）。RDBMS是一种软件包，允许您与数据库交互。RDBMS软件允许您定义、操作、检索和管理数据库中的数据。
- en: You have database features that allow you to manage data in a database and the
    structure of the database itself. There are many different RDBMS flavors on the
    market – MySQL, PostgreSQL, Oracle, MsSQL, and MariaDB – but the one we’ll work
    with is called PostgreSQL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您拥有数据库功能，可以用来管理数据库中的数据和数据库本身的架构。市场上有很多不同的关系型数据库管理系统（RDBMS）版本——MySQL、PostgreSQL、Oracle、MsSQL和MariaDB——但我们将要使用的是称为PostgreSQL的。
- en: Let’s take a look at another relevant tool needed to interact with a database,
    called a **database application programming** **interface** (**DB-API**).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一个与数据库交互所需的相关工具，称为**数据库应用程序编程接口**（**DB-API**）。
- en: DB-APIs
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DB-APIs
- en: A DB-API is an **application programming interface** (**API**) that allows communication
    between a programming language or web server framework and a database server,
    using protocols such as TCP/IP. Python, a language we use with the Flask framework,
    uses a library called psycopg2 that allows Python modules to interact with a PostgreSQL
    database server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DB-API是一个**应用程序编程接口**（**API**），它允许编程语言或Web服务器框架与数据库服务器之间进行通信，使用TCP/IP等协议。Python是一种我们与Flask框架一起使用的语言，它使用一个名为psycopg2的库，允许Python模块与PostgreSQL数据库服务器交互。
- en: The DB-API acts as a database adapter, a web interface that allows a web server
    programming language – Python, in our case – to run SQL queries on a database,
    using psycopg2 as a library for the DB-API.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: DB-API充当数据库适配器，一个Web接口，允许Web服务器编程语言（在我们的例子中是Python）在数据库上运行SQL查询，使用psycopg2作为DB-API的库。
- en: Different types of DB-APIs exist for every programming language or server framework
    and for the various dialects of the SQL database that we have. For instance, we
    have psycopg2 for PostgreSQL, `mysql-python` or `PyMySQL` for MySQL, `adodbapi`
    or `pymssql` for MS SQL Server, and `mxODBC` or `pyodb` for Oracle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种编程语言或服务器框架以及我们拥有的SQL数据库的各种方言，都存在不同类型的DB-API。例如，我们有psycopg2用于PostgreSQL，`mysql-python`或`PyMySQL`用于MySQL，`adodbapi`或`pymssql`用于MS
    SQL Server，以及`mxODBC`或`pyodb`用于Oracle。
- en: 'The documentation for PEP 248 DB-API version 1.0 specifies a goal for the DB-API:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 248 DB-API版本1.0的文档指定了DB-API的目标：
- en: “This API has been defined to encourage similarity between the Python modules
    that are used to access databases. By doing this, we hope to achieve a consistency
    leading to more easily understood modules, code that is generally more portable
    across databases, and a broader reach of database connectivity from Python.” ([http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “这个API被定义为鼓励用于访问数据库的Python模块之间的相似性。通过这样做，我们希望实现一致性，从而使得模块更容易理解，代码在数据库之间更通用，并且从Python扩展数据库连接的范围。”
    ([http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/))
- en: In essence, the DB-API gives you a low-level way of writing SQL query statements,
    making interactions with different databases consistently simple and easy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，DB-API提供了一种低级方式来编写SQL查询语句，使得与不同数据库的交互始终简单且容易。
- en: Client–server model interaction
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器模型交互
- en: Client-server model interaction is a communication paradigm in which a client
    requests resources or services from a server over a network. In this model, the
    client initiates a request to the server, and the server provides the requested
    service or data in response, creating a client-server interaction that forms the
    foundation of various applications and network communications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器模型交互是一种通信范式，其中客户端通过网络从服务器请求资源或服务。在这个模型中，客户端向服务器发起请求，服务器响应请求提供所需的服务或数据，从而形成一个客户端-服务器交互，这是各种应用程序和网络通信的基础。
- en: In the client-server model interaction, the browser acts as a client and the
    web server as a server. When an end user requests a resource or web page from
    the server, the request is made through a browser (the client side) through HTTP
    protocols on a web server (the server side). This same client-server architecture
    can also be modeled on an end user requesting a resource or web page that contains
    data from a database.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器模型交互中，浏览器充当客户端，Web服务器充当服务器。当最终用户从服务器请求资源或网页时，请求通过浏览器（客户端端）在Web服务器（服务器端）上通过HTTP协议进行。这种相同的客户端-服务器架构也可以用于最终用户请求包含数据库数据的资源或网页。
- en: When a browser makes a request that requires data from the database, the web
    server receives the request and initiates a connection with the database server.
    The web server becomes the client, and the database server becomes the server,
    completing a client-server model from the backend infrastructure ([http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器发起一个需要从数据库获取数据的请求时，Web服务器接收请求并与数据库服务器建立连接。Web服务器成为客户端，数据库服务器成为服务器，从而完成从后端基础设施的客户端-服务器模型（[http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/)）。
- en: Later in this chapter, we will create tables to thoroughly understand how to
    interact with a database. The following diagram shows the client–server interaction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将创建表格以全面了解如何与数据库交互。以下图示展示了客户端-服务器交互。
- en: '![Figure 8.8 – A diagram showing the client–server interaction](img/Figure_8.8_B18554.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 展示客户端-服务器交互](img/Figure_8.8_B18554.jpg)'
- en: Figure 8.8 – A diagram showing the client–server interaction
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 展示客户端-服务器交互的图示
- en: In the preceding diagram, the client initiates the interaction by sending a
    request to the server. The request can be an HTTP request in the case of web-based
    applications. The server receives the request, interprets it, and performs the
    necessary operations to generate a response.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，客户端通过向服务器发送请求来启动交互。在基于Web的应用程序中，请求可以是HTTP请求。服务器接收请求，对其进行解释，并执行必要的操作以生成响应。
- en: Once the response is ready, the server sends it back to the client. The client
    receives the response and processes it, utilizing the information provided to
    complete the client-server interaction. Next, we will dive into ORM basics to
    understand how you can use Python classes to interact with an RDBMS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦响应准备就绪，服务器将其发送回客户端。客户端接收响应并对其进行处理，利用提供的信息来完成客户端-服务器交互。接下来，我们将深入了解ORM基础知识，了解您如何使用Python类与关系型数据库管理系统（RDBMS）交互。
- en: Understanding SQLAlchemy ORM basics
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SQLAlchemy ORM基础知识
- en: SQLAlchemy offers developers the ability to work entirely in Python code to
    create, read, update, and delete tables. SQLAlchemy is the Python SQL toolkit
    and ORM that allows application developers to interact with databases without
    writing direct SQL statements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy为开发者提供了完全使用Python代码来创建、读取、更新和删除表的能力。SQLAlchemy是Python SQL工具包和ORM，允许应用程序开发者与数据库交互，而无需编写直接的SQL语句。
- en: As SQLAlchemy is an ORM library, Python classes are mapped to tables, and the
    instances of those classes are mapped to table rows in a relational database.
    You then have a situation where you can use Python object-oriented programming
    code to perform database SQL **create**, **read**, **update**, and **delete**
    (**CRUD**) operations and other necessary operations in your applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLAlchemy是一个ORM库，Python类被映射到表上，而这些类的实例被映射到关系数据库中的表行。然后，您就可以使用Python面向对象编程代码在应用程序中执行数据库SQL
    **创建**、**读取**、**更新**和**删除**（**CRUD**）操作以及其他必要的操作。
- en: The ORM feature of SQLAlchemy gives Python developers the power to harness function
    calls to generate SQL statements out of the box. With this new way of thinking
    about databases, developers are able to decouple object models and database schema,
    leading to a more flexible database structure, elegant SQL statements, and Python
    code that can interact with different types of database dialects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的ORM功能为Python开发者提供了利用函数调用直接生成SQL语句的能力。以这种方式思考数据库，开发者能够解耦对象模型和数据库模式，从而实现更灵活的数据库结构、优雅的SQL语句以及可以与不同类型的数据库方言交互的Python代码。
- en: SQLAlchemy doesn’t mind the kind of database systems you work with. SQLAlchemy
    makes it easier to switch from one database to another without altering your code.
    SQLAlchemy is undoubtedly a powerful tool that simplifies the process of web development,
    making it faster and more efficient.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy不介意你使用哪种数据库系统。SQLAlchemy使你更容易在不更改代码的情况下从一个数据库切换到另一个数据库。SQLAlchemy无疑是一个强大的工具，它简化了Web开发的过程，使其更快、更高效。
- en: With SQLAlchemy’s user-friendly interface, developers can easily create database
    models and interact with them from their Flask application. Additionally, SQLAlchemy
    is designed to reduce the chances of introducing bugs into the code base, which
    is especially important for large-scale applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLAlchemy的用户友好界面，开发者可以轻松创建数据库模型，并从他们的Flask应用程序中与之交互。此外，SQLAlchemy旨在减少将错误引入代码库的机会，这对于大规模应用程序尤为重要。
- en: With the provision of a robust framework to handle database interactions, SQLAlchemy
    allows developers to focus on building the logic of their applications without
    worrying about the underlying database operations. This results in a more streamlined
    development process and better overall code quality.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个强大的框架来处理数据库交互，SQLAlchemy允许开发者专注于构建应用程序的逻辑，而无需担心底层的数据库操作。这导致了一个更流畅的开发过程和更好的整体代码质量。
- en: Lastly, the SQLAlchemy ORM library comes with automatic caching. SQLAlchemy
    caches collections and references between objects once initially loaded. This
    invariably improves performance and prevents you from sending SQL queries to the
    database upon every call.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SQLAlchemy ORM库自带自动缓存功能。SQLAlchemy在对象首次加载后缓存集合和对象之间的引用。这无疑提高了性能，并防止你在每次调用时都向数据库发送SQL查询。
- en: In SQLAlchemy, there are three main vital layers of abstraction. These layers
    are the engine, the dialect, and the connection pool. This trio describes how
    you choose to interact with a database.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，有三个主要的抽象层。这些层是引擎、方言和连接池。这个三重奏描述了你是如何选择与数据库交互的。
- en: '![Figure 8.9 – The SQLAlchemy layers of abstraction](img/Figure_8.9_B18554.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – SQLAlchemy的抽象层](img/Figure_8.9_B18554.jpg)'
- en: Figure 8.9 – The SQLAlchemy layers of abstraction
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – SQLAlchemy的抽象层
- en: Let’s dig deeper into the SQLAlchemy layers of abstraction to better understand
    how they are used in SQLAlchemy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入挖掘SQLAlchemy的抽象层，以更好地理解它们在SQLAlchemy中的使用。
- en: The SQLAlchemy engine
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy引擎
- en: An SQLAlchemy application starts with the creation of an engine. You need to
    create an engine before SQLAlchemy can connect and interact with a database. The
    engine is at the lowest layer of abstraction in SQLAlchemy, and it works in pretty
    much the same way in which we use Psycopg2 to interact with a database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SQLAlchemy应用程序从创建一个引擎开始。在SQLAlchemy能够连接和与数据库交互之前，你需要创建一个引擎。引擎是SQLAlchemy中抽象层的最低层，它的工作方式与我们在使用Psycopg2与数据库交互时几乎相同。
- en: Let’s create an engine to kickstart database connectivity and interaction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个引擎来启动数据库连接和交互。
- en: 'The following snippet demonstrates PostgreSQL database connectivity using `create_engine`
    from SQLAlchemy. The SQLAlchemy engine connects to a PostgreSQL database and executes
    a SQL query in Python:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用SQLAlchemy的`create_engine`进行PostgreSQL数据库连接。SQLAlchemy引擎连接到PostgreSQL数据库，并在Python中执行SQL查询：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is what happens in the preceding code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码中发生的事情：
- en: 'The `create_engine` function is imported from the `sqlalchemy` library:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`sqlalchemy`库中导入`create_engine`函数：
- en: '[PRE12]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, the `create_engine()` method is invoked in SQLAlchemy and assigned to
    the engine instance. You then pass in a connection URL string that specifies backend
    server details, such as the database’s `name`, `username`, `password`, `host`,
    and `port` used for connectivity:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在SQLAlchemy中调用`create_engine()`方法并将其分配给引擎实例。接着，你传入一个连接URL字符串，该字符串指定了后端服务器细节，例如用于连接的数据库的`name`、`username`、`password`、`host`和`port`：
- en: '[PRE13]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A connection pool is created for the current database, and this is created
    once in the lifetime application:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前数据库创建一个连接池，并且这个连接池在整个应用程序生命周期中只创建一次：
- en: '[PRE14]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We execute the SQL statements using the established connection object:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用建立的连接对象执行SQL语句：
- en: '[PRE15]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we loop through the result set returned by the query and print the
    values.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们遍历查询返回的结果集并打印值。
- en: It’s important to close the result set and the connection using the `result.close()`
    and `conn.close()` methods to free up resources and prevent memory leaks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`result.close()`和`conn.close()`方法关闭结果集和连接，以释放资源并防止内存泄漏是很重要的。
- en: SQLAlchemy connection pools
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy连接池
- en: Connection pooling is an implementation of the object pool design paradigm in
    software engineering, where connections are reused instead of being created every
    time a connection to a database is required. In SQLAlchemy, the use of the `create_engine()`
    method usually generates a connection pool object that is created once and reused
    in subsequent connections when carrying out database transactions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池是软件工程中对象池设计范式的实现，其中连接在需要时被重用而不是每次都需要创建。在SQLAlchemy中，`create_engine()`方法的通常使用会生成一个连接池对象，该对象在创建后会被重用，在执行数据库事务时后续连接会使用它。
- en: This connection pooling design pattern helps improve performance and better
    manage application concurrent connections. The default setting of the connection
    pool can be adjusted to better serve end users of business web applications efficiently.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接池设计模式有助于提高性能并更好地管理应用程序的并发连接。连接池的默认设置可以根据需要调整，以更有效地服务于商业Web应用程序的最终用户。
- en: 'To update the connection pool, add pooling parameters to `create_engine()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新连接池，将连接池参数添加到`create_engine()`中：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following bullet list shows you how to tweak the connection pool parameters
    to optimize performance while working with the SQLAlchemy connection pool.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目符号列表显示了如何调整连接池参数以优化与SQLAlchemy连接池一起工作的性能。
- en: With `pool_size`, you can set the number of connections the pool can handle
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pool_size`，你可以设置连接池可以处理的连接数。
- en: With `max_overflow`, you can specify how many overflow connections the pool
    supports
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`max_overflow`，你可以指定连接池支持的溢出连接数。
- en: With `pool_recycle`, you can configure the maximum age in seconds of connections
    in the pool
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pool_recycle`，你可以配置连接池中连接的最大年龄（以秒为单位）。
- en: With `pool_timeout`, you can specify how many seconds the application needs
    to wait before giving up getting a connection from the pool
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pool_timeout`，你可以指定应用程序在放弃从连接池获取连接之前需要等待多少秒。
- en: SQLAlchemy dialect
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy方言
- en: One of the main benefits of using SQLAlchemy is that you can use different types
    of DB-API implementations (Psycopg2) and relational databases without altering
    your Python code to suit their internal workings.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy的主要好处之一是，你可以使用不同类型的DB-API实现（如Psycopg2）和关系数据库，而无需更改你的Python代码以适应它们的内部工作方式。
- en: So, the dialect is a system in SQLAlchemy that makes interaction with different
    databases possible. You can use SQLite in your development environment and decide
    to use MySQL or PostgreSQL in production with your existing code base.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方言是SQLAlchemy中的一种系统，它使得与不同数据库的交互成为可能。你可以在开发环境中使用SQLite，并决定在生产环境中使用MySQL或PostgreSQL，而无需更改现有的代码库。
- en: 'Some examples of relational database dialects are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关系数据库方言的示例：
- en: PostgreSQL
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: MySQL and MariaDB
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL和MariaDB
- en: SQLite
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: Oracle
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle
- en: Microsoft SQL Server
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server
- en: In order to use these database dialects, you must install appropriate DB-API
    drivers in your application. When connecting with PostgreSQL, SQLAlchemy uses
    Psycopg2 as an implementation of the DB-API specification. Psycopg2 is a PostgreSQL
    adapter for Python. Psycopg2 provides a simple and efficient way to communicate
    with a PostgreSQL database using Python code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些数据库方言，你必须在你的应用程序中安装适当的DB-API驱动程序。当与PostgreSQL连接时，SQLAlchemy使用Psycopg2作为DB-API规范的实现。Psycopg2是Python的PostgreSQL适配器。Psycopg2提供了一个简单高效的方法，使用Python代码与PostgreSQL数据库进行通信。
- en: We’ve talked about how SQLAlchemy dialects work, but what about the data types
    that are used within those dialects? SQLAlchemy offers a wide variety of data
    types, and we’ll explore some of them now. After that, we’ll discuss how to map
    them to Python classes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了SQLAlchemy方言的工作原理，但那些方言中使用的数据类型是什么呢？SQLAlchemy提供了多种数据类型，现在我们将探讨其中的一些。之后，我们将讨论如何将它们映射到Python类中。
- en: SQLAlchemy data types – mapping between tables and classes
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy数据类型 – 表与类之间的映射
- en: SQLAlchemy provides high-level abstractions to any underlying relational databases
    we may choose to use in our applications. SQLAlchemy has data type support for
    the most common traditional databases we are familiar with. For instance, dates,
    times, strings, integers, and Booleans are well supported by SQLAlchemy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 为我们可能选择在应用程序中使用的任何底层关系数据库提供了高级抽象。SQLAlchemy 对我们熟悉的常见传统数据库提供了数据类型支持。例如，日期、时间、字符串、整数和布尔值都得到了
    SQLAlchemy 的良好支持。
- en: SQLAlchemy data types allow for precise data storage and retrieval. Each column
    in a database table has a specific data type that defines the type of data that
    can be stored in that column, such as integers, strings, or dates. SQLAlchemy
    provides a range of data types that can be used to define the columns in a database
    table, including `Numeric`, `String`, `DateTime`, and `Boolean`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 数据类型允许精确的数据存储和检索。数据库表中的每一列都有一个特定的数据类型，它定义了可以存储在该列中的数据类型，例如整数、字符串或日期。SQLAlchemy
    提供了一系列数据类型，可用于定义数据库表中的列，包括 `Numeric`、`String`、`DateTime` 和 `Boolean`。
- en: By using these data types, we can ensure that our data is stored accurately
    and efficiently, allowing for faster and more reliable data retrieval. Also, the
    mapping between tables and classes is important because it allows us to work with
    database tables in an object-oriented manner.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些数据类型，我们可以确保我们的数据被准确且高效地存储，从而实现更快的检索和更可靠的性能。此外，表和类之间的映射很重要，因为它允许我们以面向对象的方式处理数据库表。
- en: SQLAlchemy provides an ORM system that allows us to map database tables to Python
    classes. This means that we can work with database data using Python objects and
    methods, which makes it easier to build and maintain our web applications. Let’s
    see an example of how SQLAlchemy data types are mapped with Python classes and
    instance attributes for table and column creations, respectively.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供了一个 ORM 系统，允许我们将数据库表映射到 Python 类。这意味着我们可以使用 Python 对象和方法来处理数据库数据，这使得构建和维护我们的
    Web 应用程序更加容易。让我们看看 SQLAlchemy 数据类型是如何与 Python 类和实例属性映射的，分别用于表和列的创建。
- en: 'This approach will be used to define tables from Python classes for the Flask
    applications in this book:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的 Flask 应用程序将使用这种方法从 Python 类定义表：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code snippet, we defined a class called `Speaker` that has
    some attributes. Let’s dive deeper into the code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为 `Speaker` 的类，它具有一些属性。让我们更深入地了解这段代码：
- en: The `__tablename__` attribute is set to `speakers`, indicating that instances
    of the `Speaker` class should be stored in the `speakers` table in the database.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__tablename__` 属性被设置为 `speakers`，表示 `Speaker` 类的实例应该存储在数据库中的 `speakers` 表中。'
- en: The `speaker_id` attribute specifies that this is the `primary_key` in the table
    and has an `Integer` type.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speaker_id` 属性指定这是表中的 `primary_key`，并且具有 `Integer` 类型。'
- en: The `first_name` attribute specifies that a column in the table has the name
    `first_name` with a `String` type.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name` 属性指定表中的一个列具有名称 `first_name`，类型为 `String`。'
- en: The `last_name` attribute specifies that a column in the table has a name `last_name`
    with a `String` type.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_name` 属性指定表中的一个列具有名称 `last_name`，类型为 `String`。'
- en: The `email` attribute specifies that a column in the table has the name `email`
    with a `String` type.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email` 属性指定表中的一个列具有名称 `email`，类型为 `String`。'
- en: '`created_at` and `updated_at` specify columns in the table with the mentioned
    names that are of type `date`. Methods are, however, passed to get the current
    `timezone`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at` 和 `updated_at` 指定了表中具有所述名称的列，其类型为 `date`。然而，方法被传递以获取当前的 `timezone`。'
- en: With the classes and instances defined, we can utilize the internal APIs of
    SQLAlchemy and the configured dialect to map the class attributes to the corresponding
    native structure of the database. For example, if we have a string data type in
    our class, SQLAlchemy will map it to a `varchar` column in PostgreSQL.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了类和实例后，我们可以利用 SQLAlchemy 的内部 API 和配置的方言，将类属性映射到数据库的相应原生结构。例如，如果我们类中有字符串数据类型，SQLAlchemy
    将将其映射到 PostgreSQL 中的 `varchar` 列。
- en: This ensures that the data types used in the class are properly translated into
    the appropriate database column types, allowing for seamless communication between
    the Python code and the database.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了在类中使用的数据类型被正确地转换为适当的数据库列类型，从而使得 Python 代码和数据库之间的通信无缝。
- en: To build a robust web application for a speakers’ conference web application,
    we need to model the data correctly. SQLAlchemy provides us with a powerful ORM
    that makes it easy to map our database tables to classes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个健壮的演讲者会议Web应用程序，我们需要正确地建模数据。SQLAlchemy为我们提供了一个强大的ORM，这使得将我们的数据库表映射到类变得容易。
- en: We can then define the attributes and relationships between these classes, which
    makes it easy to work with complex data structures. In the next section, we will
    explore how to model data for our speakers’ conference web application using SQLAlchemy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义这些类之间的属性和关系，这使得处理复杂的数据结构变得容易。在下一节中，我们将探讨如何使用SQLAlchemy为我们的演讲者会议Web应用程序建模数据。
- en: Modeling data for a speakers’ conference web application
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为演讲者会议Web应用程序建模数据
- en: '**Data modeling** is the process of creating a conceptual, logical, and visual
    representation of data structures and relationships between data elements, in
    order to understand, analyze, and manage complex information systems. Data modeling
    involves identifying entities (objects, concepts, or things) that will be represented
    in a system and defining their attributes and relationships with other entities.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据建模**是创建数据结构的概念性、逻辑性和视觉表示的过程，以便理解、分析和管理复杂的信息系统。数据建模涉及识别将在系统中表示的实体（对象、概念或事物），并定义它们的属性以及与其他实体之间的关系。'
- en: The main purpose of data modeling is to create a clear and precise representation
    of the data that will be stored, processed, and managed by an information system.
    A well-designed data model in a web application can ensure that the web application
    is scalable, efficient, and meets the needs of its users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模的主要目的是创建一个清晰且精确的数据表示，这些数据将由信息系统存储、处理和管理。在Web应用程序中，一个设计良好的数据模型可以确保Web应用程序具有可扩展性、效率，并满足其用户的需求。
- en: 'Let’s quickly examine some of the best practices to be considered when designing
    a data model for the conference speakers’ web application:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查在设计会议演讲者Web应用程序的数据模型时需要考虑的一些最佳实践：
- en: '**Identifying the entities**: Start by identifying the entities or objects
    that will be represented in the web application based on the system requirements,
    such as users, speakers, presentation, schedule, attendees, sessions, venue, and
    sponsors.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别实体**：首先根据系统需求识别将在Web应用程序中表示的实体或对象，例如用户、演讲者、演讲、日程、与会者、会议、场地和赞助商。'
- en: '**Defining the relationships**: Determine the relationships between these entities,
    such as one-to-one, one-to-many, or many-to-many relationships. For instance,
    a speaker can give multiple presentations at the conference, but a presentation
    can only be given by one speaker.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义关系**：确定这些实体之间的关系，例如一对一、一对多或多对多关系。例如，一个演讲者可以在会议上进行多次演讲，但一次演讲只能由一个演讲者进行。'
- en: '**Determining the attributes**: Define the attributes or properties of each
    entity – for instance, a speaker could have attributes such as name, contact address,
    biography, or presentation topics.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定属性**：定义每个实体的属性或特性——例如，一个演讲者可能具有姓名、联系地址、传记或演讲主题等属性。'
- en: '**Considering performance and scalability**: Design the data model to optimize
    performance and scalability, such as using indexes, caching, or denormalization
    to reduce query times and improve system response.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑性能和可扩展性**：设计数据模型以优化性能和可扩展性，例如使用索引、缓存或反规范化以减少查询时间和提高系统响应。'
- en: '**Planning for data storage**: Consider the data storage options available,
    such as relational databases, NoSQL databases, or flat files, and choose the appropriate
    option based on the needs of the web application. In this case, PostgreSQL was
    chosen.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划数据存储**：考虑可用的数据存储选项，例如关系数据库、NoSQL数据库或平面文件，并根据Web应用程序的需求选择合适的选项。在这种情况下，选择了PostgreSQL。'
- en: '**Data security**: Design the data model to ensure data security, such as using
    encryption or access controls to protect sensitive data. For instance, when a
    user logs in, their entered password can be hashed and compared to the stored
    hash to verify their identity.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全**：设计数据模型以确保数据安全，例如使用加密或访问控制来保护敏感数据。例如，当用户登录时，他们输入的密码可以被散列并与存储的散列进行比较以验证其身份。'
- en: '**Considering future changes**: Plan for future changes and updates to the
    web application, such as adding new entities or attributes, or modifying existing
    relationships.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑未来变化**：为Web应用程序的未来变化和更新做出规划，例如添加新的实体或属性，或修改现有关系。'
- en: Are you prepared to begin developing the backend of the *Bizza* project by establishing
    and organizing the data model? The *Bizza* project aims to create a full stack
    web application that is database-driven and focuses on conference speakers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否准备好通过建立和组织数据模型来开始开发 *Bizza* 项目的后端？*Bizza* 项目旨在创建一个以数据库驱动为主的完整栈网络应用，专注于会议演讲者。
- en: In this data model, we will take a closer look at the database, tables, and
    relationship between the tables.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据模型中，我们将更详细地查看数据库、表以及表之间的关系。
- en: 'The `bizza` database has the following tables and relationships:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`bizza` 数据库有以下表和关系：'
- en: '`users` and `userExtras`, a many-to-many relationship between users and roles,
    a one-to-one relationship between `users` and `speakers`, and a one-to-many relationship
    between `users` and `attendees`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users` 和 `userExtras`，用户和角色之间的多对多关系，`users` 和 `speakers` 之间的一对一关系，以及 `users`
    和 `attendees` 之间的一对多关系。'
- en: '`users` table – a one-to-one relationship between `users` and `userExtras`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users` 表 —— `users` 和 `userExtras` 之间的一对一关系。'
- en: '`users` table – a many-to-many relationship between `users` and `roles`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users` 表 —— `users` 和 `roles` 之间的多对多关系。'
- en: '`Speaker` model will be linked to the `users` model to associate each speaker
    with their user account. The following relationships exist with other tables –
    a one-to-many relationship between `speakers` and `sessions`, a one-to-one relationship
    between `users` and `speakers`, a one-to-many relationship between `speakers`
    and `schedules`, and a one-to-many relationship between `speakers` and `presentations`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Speaker` 模型将与 `users` 模型相关联，以便将每个演讲者与他们的用户账户关联起来。与其他表存在以下关系——`speakers` 和
    `sessions` 之间的一对多关系，`users` 和 `speakers` 之间的一对一关系，`speakers` 和 `schedules` 之间的一对多关系，以及
    `speakers` 和 `presentations` 之间的一对多关系。'
- en: '`Presentation` model will be linked to the `Speaker` model to associate each
    presentation with its speaker. The following relationships exist with other tables
    – many-to-one relationships between `presentations` and `speakers`, and one-to-many
    relationships between `presentations` and `schedules`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Presentation` 模型将与 `Speaker` 模型相关联，以便将每个演示与其演讲者关联起来。与其他表存在以下关系——`presentations`
    和 `speakers` 之间的多对一关系，以及 `presentations` 和 `schedules` 之间的一对多关系。'
- en: '`Schedule` model will be linked to the `Presentation` model to associate each
    presentation with its date and time. The following relationships exist with other
    tables – many-to-one relationships between `schedules` and `presentations`, one-to-many
    relationships between `schedules` and `sessions`, many-to-one relationships between
    `schedules` and `venues`, and many-to-many relationships between `schedules` and
    `attendees`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedule` 模型将与 `Presentation` 模型相关联，以便将每个演示与其日期和时间关联起来。与其他表存在以下关系——`schedules`
    和 `presentations` 之间的多对一关系，`schedules` 和 `sessions` 之间的一对多关系，`schedules` 和 `venues`
    之间的多对一关系，以及 `schedules` 和 `attendees` 之间的多对多关系。'
- en: '`attendees` and `schedules`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attendees` 和 `schedules`。'
- en: '`Session` model will be linked to the `Presentation` model to associate each
    session with its presentations. The following relationships exist with other tables
    – a many-to-one relationship between `sessions` and `schedules`, and a one-to-one
    relationship between `sessions` and `presentations`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session` 模型将与 `Presentation` 模型相关联，以便将每个会议与它的演示关联起来。与其他表存在以下关系——`sessions`
    和 `schedules` 之间的多对一关系，以及 `sessions` 和 `presentations` 之间的一对一关系。'
- en: '`venues` and `schedules`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venues` 和 `schedules`。'
- en: '**Sponsor model**: This model will include data about each sponsor of the conference,
    such as their name, logo, website, and any other relevant details.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赞助商模型**：此模型将包括有关每个会议赞助商的数据，例如他们的名称、标志、网站以及任何其他相关细节。'
- en: Now that we have defined our data model, we will explore in the next section
    how to seamlessly send data to a PostgreSQL database with just a few simple steps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的数据模型，在下一节中，我们将探讨如何通过几个简单的步骤无缝地将数据发送到 PostgreSQL 数据库。
- en: Sending data to the PostgreSQL database from a Flask app
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Flask 应用程序向 PostgreSQL 数据库发送数据
- en: Interacting with a database is a common aspect of most web applications. Sending
    data to the PostgreSQL database from a Flask app is simple and straightforward.
    A web application would not be complete without the ability to store and retrieve
    data from a database.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库交互是大多数网络应用的一个常见方面。从 Flask 应用程序向 PostgreSQL 数据库发送数据简单直接。一个网络应用如果没有存储和从数据库检索数据的能力，将是不完整的。
- en: The first step in sending data to a database is to ensure there is a connection
    between the Flask app and the database. This involves installing the required
    libraries and ensuring that you work in a virtual environment to contain your
    installation and prevent unexpected occurrences, due to the interference of other
    libraries.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发送到数据库的第一步是确保 Flask 应用和数据库之间存在连接。这涉及到安装所需的库，并确保您在一个虚拟环境中工作，以包含您的安装并防止其他库的干扰导致意外发生。
- en: Let’s make use of the `bizza/backend` directory created in the *Setting up the
    development environment with Flask* section of [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
    You can create one if you haven’t already. Install and activate the virtual environment.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用在 [*第 1 章*](B18554_01.xhtml#_idTextAnchor014) 的 *使用 Flask 设置开发环境* 部分中创建的
    `bizza/backend` 目录。如果您还没有创建，可以创建一个。安装并激活虚拟环境。
- en: 'To create a virtual environment, open your project root directory in a terminal
    and add the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个虚拟环境，请在终端中打开您的项目根目录，并添加以下命令：
- en: '[PRE18]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s activate the virtual environment:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们激活虚拟环境：
- en: '**For** **Windows users**:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Windows 用户**：'
- en: '[PRE19]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**For** **Linux/Mac users**:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Linux/Mac 用户**：'
- en: '[PRE20]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To create a database table from a Python class, you need `flask-sqlalchemy`
    installed. We have this installed already. If not, enter the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Python 类创建数据库表，您需要安装 `flask-sqlalchemy`。我们已经安装了它。如果没有安装，请输入以下命令：
- en: '[PRE21]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the Flask application module – that is, `app.py` – update the content of
    the `app.py` with the following code that creates the `users` table in the *bizza*
    database. In this section, we will only create the `users` table to demonstrate
    how to send data from a Flask app to PostgreSQL.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 应用模块中——即 `app.py` ——更新 `app.py` 的内容，使用以下代码在 *bizza* 数据库中创建 `users` 表。在本节中，我们只创建
    `users` 表以演示如何从 Flask 应用向 PostgreSQL 发送数据。
- en: 'The other models will be shown on GitHub and later in the book until we have
    a full implementation of the speakers’ conference web app, *Bizza*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模型将在 GitHub 上展示，并在书中稍后介绍，直到我们完成演讲者会议网络应用 *Bizza* 的完整实现：
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s delve into the preceding Flask app snippet used to create the `users`
    table in the database:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨前面用于在数据库中创建 `users` 表的 Flask 应用代码片段：
- en: '`from flask import Flask` imports the `Flask` class from the Flask module.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from flask import Flask` 从 Flask 模块导入 `Flask` 类。'
- en: '`from flask_sqlalchemy import SQLAlchemy` imports the `SQLAlchemy` class from
    the `flask_sqlalchemy` module.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from flask_sqlalchemy import SQLAlchemy` 从 `flask_sqlalchemy` 模块导入 `SQLAlchemy`
    类。'
- en: '`app = Flask(__name__)` creates a `Flask` instance named `app`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app = Flask(__name__)` 创建了一个名为 `app` 的 `Flask` 实例。'
- en: '`app.config[''SQLALCHEMY_DATABASE_URI''] = ''postgresql://<db_username>:<db_password>@localhost:5432/<database_name>''`
    is where the `app.config[]` dictionary defines the path to the database with the
    `db username` and `password` set.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.config[''SQLALCHEMY_DATABASE_URI''] = ''postgresql://<db_username>:<db_password>@localhost:5432/<database_name>''`
    是 `app.config[]` 字典定义了数据库的路径，其中设置了 `db username` 和 `password`。'
- en: '`db = SQLAlchemy(app)` initializes an instance of the `SQLAlchemy` class with
    the Flask app as the argument.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db = SQLAlchemy(app)` 使用 Flask 应用作为参数初始化 `SQLAlchemy` 类的一个实例。'
- en: Then, we start to define the `model` class for `User` with `class User(db.Model):`.
    The `User(db.Model)` class defines a `User` model that inherits from the `db.Model`
    class.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们开始定义 `User` 的 `model` 类，使用 `class User(db.Model):`。`User(db.Model)` 类定义了一个继承自
    `db.Model` 类的 `User` 模型。
- en: '`__tablename__ = ''users''` allows us to have a custom name for the table –
    a *Class User* model with a corresponding table name, `users`. If this is not
    specified, the lowercase class name (`user`) will be used.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__tablename__ = ''users''` 允许我们为表指定一个自定义名称——一个与 `Class User` 模型对应的表名 `users`。如果没有指定，将使用小写类名（`user`）。'
- en: 'Then, we add the columns for the table. Each column is an object of the `Column`
    subclass of SQLAlchemy:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们为表添加列。每个列都是 SQLAlchemy 的 `Column` 子类的对象：
- en: '`User_id = db.Column(db.Integer, primary_key=True,nullable=False)` defines
    a primary key column named `user_id` with an `Integer` data type'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User_id = db.Column(db.Integer, primary_key=True, nullable=False)` 定义了一个名为
    `user_id` 的主键列，其数据类型为 `Integer`。'
- en: '`username = db.Column(db.String(50), unique=True, nullable=False)` defines
    a column named `username` with a `String` data type and enforces that it must
    be unique and not nullable'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username = db.Column(db.String(50), unique=True, nullable=False)` 定义了一个名为
    `username` 的列，其数据类型为 `String`，并强制要求它必须是唯一的且不可为空。'
- en: '`email = db.Column(db.String(120), unique=True, nullable=False)` defines a
    column named `email` with a `String` data type and enforces that it must be unique
    and not nullable'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password = db.Column(db.String(256), nullable=False)` defines a column named
    `password` with a `String` data type and enforces that it must not be nullable'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name = db.Column(db.String(50), nullable=False)` defines a column named
    `first_name` with a `String` data type and enforces that it must not be nullable'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name = db.Column(db.String(50), nullable=False)` defines a column named
    `last_name` with a `String` data type and enforces that it must not be nullable'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_active = db.Column(db.Boolean, default=True)` defines a column named `is_active`
    with a b`oolean` data type and sets a default value of `True`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_superuser = db.Column(db.Boolean, default=False)` defines a column named
    `is_superuser` with a `Boolean` data type and sets a default value of `False`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def __repr__(self)` defines a method that returns a string representation
    of the `User` object.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return ''<User %r>'' % self.username` returns a string that includes the username
    of the `User` object.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined the `User` class model, it’s time to create the `users`
    table in the database and pass in some data:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal in the project root directory and enter the `flask` `shell`
    command.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – A screenshot showing flask shell](img/Figure_8.10_B18554.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – A screenshot showing flask shell
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Enter `from app import db` to connect with the database object.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `db.create_all()` to create the `users` table.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A screenshot showing db.create_all()](img/Figure_8.11_B18554.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – A screenshot showing db.create_all()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Enter `from app import User` to gain access to the `User` model.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add user data to the table using the `flask` `shell` terminal:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add `db.session.add(user1)` and `db.session.commit()` to add a user to the database
    session and a commit for data persistence in the database.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `User.query.all()` to see the `users` table with the added information.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – A screenshot showing flask shell with inserted data](img/Figure_8.12_B18554.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – A screenshot showing flask shell with inserted data
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how you can add and track changes to your database structure
    with migrations.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Migration with Alembic
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, Alembic is a migration tool that makes the tracking of
    changes in a database a less problematic operation for Flask developers. Since
    we expect data models to change, we need a tool that can keep track of these changes
    and ensure they are updated in the database.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how we do version control of source code using `Git`. The
    same applies to database schema change management, where we keep incremental and
    reversible changes in the database structure. Working with a database table, you
    will want to add or remove columns, thus altering the schema in a Python model
    class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, you need an automatic process to ensure your database table
    and the state of the data model schema are in sync. Alembic graciously handles
    the schema migration and ensures that the data model in a Python file is the same
    as the database structure.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine how you can implement migration in a Flask application. We will
    add another model and use migration to track changes made to the database. Here,
    we add the `Speaker` model class.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `Flask-Migrate` with `pip`, as stated in the *Setting up* *Alembic*
    section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside `app.py`, add the following snippet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A few changes were made to the `app.py` file, including the installation of
    the `flask-migrate` package, the creation of an instance of the `Migrate` class
    with the `app` and `db` instances as arguments, and the addition of a `speaker`
    model class that will be tracked upon its inclusion in the database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the changes made to `app.py` with the addition of the `speaker` model
    class, let’s implement migrations with Alembic:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, inside the project directory, enter the `pip install flask-migrate`
    command. The `flask-migrate` extension provides database migration support for
    Flask applications.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate the initial migration in Flask, enter the following in the command
    terminal of the project root directory:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, once you have initialized the migration repository, you can use the `flask
    db migrate` command to generate the first migration, based on changes you have
    made to your models. We have added the new speaker model to the `app.py` file.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, use the `flask db migrate -m ''first migration message, speaker model
    added''` command to generate a new migration script, based on the changes made
    to the database models. The `-m` flag is used to specify a message describing
    the changes made in the migration. The following command will create a new migration
    file with the changes specified in the models:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the effects of the commands:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A screenshot showing the migration commands](img/Figure_8.13_B18554.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – A screenshot showing the migration commands
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'To commit the schema data model change to a database based on the state of
    the migration script, run the following command:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will then get the following output:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A screenshot showing the flask db upgrade command](img/Figure_8.14_B18554.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – A screenshot showing the flask db upgrade command
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This will apply all the pending migrations to your database schema. From this
    point on, you can continue to generate new migrations as needed using the `flask
    db` `migrate` command.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the commands needed for Alembic migrations, follow these steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**pip** **install flask-migrate**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**flask** **db init**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**flask db migrate -m “first migration message** **speakers model”**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**flask** **db upgrade**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Alembic is a database migration tool for SQLAlchemy that helps keep the database
    schema in sync with the application’s data model. When using Alembic, you define
    changes to the data model in a series of migrations, which are Python scripts
    that modify the database schema.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic 是一个用于 SQLAlchemy 的数据库迁移工具，它帮助保持数据库模式与应用程序的数据模型同步。当使用 Alembic 时，你通过一系列迁移来定义数据模型的变化，这些迁移是修改数据库模式的
    Python 脚本。
- en: These migrations are stored in a migration directory, and each migration is
    associated with a specific version of the schema. When you run a migration, Alembic
    compares the current state of the database schema to the target state defined
    in the migration. It then generates a set of SQL statements to modify the database
    schema to match the target state.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迁移存储在迁移目录中，每个迁移都与数据库模式的一个特定版本相关联。当你运行一个迁移时，Alembic 会将数据库模式的当前状态与迁移中定义的目标状态进行比较。然后，它生成一系列
    SQL 语句来修改数据库模式以匹配目标状态。
- en: These SQL statements are executed in a transaction, which ensures that the database
    schema is modified in a consistent manner. With the use of Alembic to manage database
    migrations, you can ensure that the database schema remains in sync with the application’s
    data model as it evolves over time. This can help prevent data inconsistencies
    and other issues that can arise when the database schema and data model become
    out of sync.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SQL 语句在事务中执行，这确保了数据库模式以一致的方式被修改。使用 Alembic 管理数据库迁移，你可以确保数据库模式随着时间的推移与应用程序的数据模型保持同步。这有助于防止数据不一致和其他问题，这些问题可能在数据库模式和数据模型不同步时出现。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we extensively discussed SQL and relational data modeling for
    the web. A relational database helps us with the design of a database as a group
    of relations. We also discussed relationships that can exist in a database, such
    as one-to-one, one-to-many, and many-to-many relationships, allowing us to logically
    group relations in the database and enforce data referential integrity.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛讨论了用于网络的 SQL 和关系数据建模。关系数据库帮助我们以关系组的形式设计数据库。我们还讨论了数据库中可能存在的关系，例如一对一、一对多和多对多关系，这使得我们能够在数据库中逻辑地分组关系并强制执行数据引用完整性。
- en: Additionally, we examined how to set up PostgreSQL. We shed light on the basics
    of SQLAlchemy and its associated database adapters and how they are used in Flask
    application development. We discussed data model design, with the *Bizza* project
    as a use case. Finally, we discussed how a Flask app can communicate with the
    database and migration in Flask to keep track of changes in a database.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了如何设置 PostgreSQL。我们介绍了 SQLAlchemy 的基础知识及其相关的数据库适配器，以及它们在 Flask 应用程序开发中的使用。我们讨论了数据模型设计，以
    *Bizza* 项目为例。最后，我们讨论了 Flask 应用如何与数据库和迁移进行通信，以及在 Flask 中如何跟踪数据库的变化。
- en: In the next chapter, we will extensively discuss the API in backend development
    and how you can use the Flask framework to implement API design.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将广泛讨论后端开发中的 API 以及如何使用 Flask 框架来实现 API 设计。
