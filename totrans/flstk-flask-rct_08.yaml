- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL and Data Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve explored React, a key library in frontend technology stacks. Now,
    we will explore the world of backend development, starting with **Structured Query
    Language** (**SQL**) and data modeling.
  prefs: []
  type: TYPE_NORMAL
- en: SQL and data modeling are critical skills for any backend developer, and starting
    with these skills in the backend development journey will give you a strong foundation
    to build robust and scalable web applications. SQL is a standard language used
    to manage data in relational databases, which are essentially used to store structured
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of SQL will help you to write optimized SQL queries that can improve
    the performance of your application and reduce server load. Data modeling will
    help you to design a database schema that reflects the data your application will
    work with. Data modeling can help you avoid performance issues, maintainability
    problems, and other common issues that may arise when working with databases.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive deeply into relational databases and how database tables can relate
    to one another. We will examine SQL as a standard language used by many database
    management systems, including **PostgreSQL**, a popular open source **relational
    database management** **system** (**RDBMS**).
  prefs: []
  type: TYPE_NORMAL
- en: Having a robust understanding of relational databases and knowledge of how database
    relationships work will help you design scalable and maintainable data structures.
    We will leave no stone unturned, cruising through the setup of PostgreSQL and
    exploring how Flask applications can communicate with PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss in depth the ability of SQLAlchemy to handle various relational
    database dialects by providing an interface that allows SQL interaction with a
    database using Python objects. **SQLAlchemy** is an industrial-strength object-relational
    mapper that provides a powerful interface for interaction with various relational
    database dialects, including PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy makes it easier to write complex database queries and manage database
    transactions. We will examine how you can come up with a data model and send data
    from a Flask application to a database.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to data modeling and SQL, migration is also a crucial aspect of
    backend development. We will examine migration as a way of tracking and updating
    database structures with Alembic. **Alembic** is a migration tool that provides
    a reliable way of tracking and updating database structures, making it an essential
    tool for Python developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the relational data model?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the different database relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding database concepts for Flask applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SQLAlchemy ORM basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling data for the speakers conference web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to the PostgreSQL database from a Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration with Alembic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: What is the relational data model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **relational data model** is a conceptual approach used to represent a database
    as a group of relations. Most web applications are highly data-driven. Developers
    have to deal with either code-level data storage, in the case of a data structure,
    or find a way to persistently store data in an RDBMS, such as PostgreSQL or MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: In an RDBMS, you can refer to a table as a relation. Therefore, a relational
    model represents data as a collection of relations or tables. Breaking down the
    database structure further, you then have rows and columns making up a table.
    Then, you have a record, which consists of a combination of rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a hypothetical table named `customers` that depicts the
    structure of a typical table for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Id` | `firstname` | `lastname` | `email` | `phone` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Joel | Doe | Joel@admin.com | 404-228-5487 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Edward | Spinster | Edward@admin.com | 403-268-6486 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Mabel | Emmanuel | Mabel@admin.com | 402-248-4484 |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – A table showing customer information
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding `customers` table, we have five columns and three rows. Each
    row in a table is called a tuple. The column headers such as `Id`, `firstname`,
    `lastname`, `email`, and `phone` are called attributes or fields. In a database,
    tables are created to store data efficiently. Each table usually represents a
    business entity or object such as a speaker, venue, subject, customer, product,
    order, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, a business entity represents things we intend to encapsulate in
    the application business data model with all the rules, relationships, and ability
    to be persistent in the database. In the preceding table, we have a customer business
    entity with the following attributes – `Id`, `firstname`, `lastname`, `email`,
    and `phone`. More often than not, you would have more than one table in your web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Expectedly, you need to be able to relate these different tables or relations
    in your database using primary keys. The primary key is the unique identifier
    for the entire row of a table, referring to one or more columns. And if there
    are multiple columns for the primary key, then the set of primary key columns
    is known as a composite key. In our case, `Id` in the customer table could be
    set as the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, another concept in data relation is a foreign key. A foreign key
    refers to a primary key in another (foreign) table. Foreign keys are used to map
    relationships between tables or relations. The table relationship helps you to
    store data efficiently where it needs to be stored, and accessing related data
    becomes easier when needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many relationships in database design – *one-to-one*, *one-to-many*,
    and *many-to-many*. For instance, related tables in a database can help you find
    out orders made by your customers, how many conference attendees are currently
    enrolled in each subject, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will extensively discuss the relationships in a database
    and how they are used in web application architectural design.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the different database relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the client-server model, the database resides at the server end of the infrastructure.
    The database is core to any production-grade web application in collecting and
    storing application data. Understanding relationships that exist in a database
    is vital for organizing, managing, and retrieving useful data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, there are three types of relationships that exist in
    a database – *one-to-one*, *one-to-many*, and *many-to-many*. We will begin by
    delving into the concept of a one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one (1:1) relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `speakers` and `speakerExtras`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – An entity relationship diagram showing the one-to-one relationship](img/Figure_8.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – An entity relationship diagram showing the one-to-one relationship
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram depicts the `speakers` table and the `speakerExtras` table.
    The `speakers` table details the basic required information of a speaker object,
    while the `speakerExtras` table showcases the optional information that can be
    added to speaker information. `speaker_id` in the `speakers` table is the primary
    key that can be used to uniquely identify a speaker record.
  prefs: []
  type: TYPE_NORMAL
- en: In the `speakerExtras` table, a column is added as `speaker_id`. This `speaker_id`
    column in the `speakerExtras` table is a foreign key with a unique attribute.
    This `speaker_id` column is used as a reference key for `speaker_id` in the `speakers`
    table to form a one-to-one relationship between the `speakerExtras` table and
    the `speakers` table.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the one-to-one relationship data model can actually be merged.
    Merging a one-to-one relationship data model typically means combining the tables
    into a single table. This is usually done when the two tables have a strong connection
    and the data in the tables is not complex enough to warrant having separate tables.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are cases where the database design requirement may be a separate
    table for information that may be optional, so rather than having an empty column
    in a table, you can create a different table to handle this optional information
    for better database performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at another database relationship, one-to-many.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many (1:M) relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **one-to-many relationship** in a data model explains a relationship between
    two tables, in which a row in one table can reference one or many rows in another
    table. The one-to-many relationship is a kind of parent-child relationship where
    a child record can only have one parent record.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the parent record has more than one child in another table’s
    rows. However, in a real-life scenario, we could have a situation in which a parent
    record has no child record at all. What does a parent with no child record mean?
    It means that the foreign key column in the child table will be empty for that
    parent record.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, consider a database design for a store where each customer can
    have multiple orders. If a new customer record is created but no orders have been
    placed yet, there will be a customer record with no corresponding order records.
    In this case, the customer record is the parent record, and the order records
    are the child records.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a one-to-many relationship in some cases also allows a single record
    in another table. There are cases where a one-to-many relationship can be constrained
    to functionally act as a one-to-one relationship. For instance, you could add
    a unique constraint to the foreign key column in the child table, ensuring that
    each record in the parent table is associated with, at most, one record in the
    child table.
  prefs: []
  type: TYPE_NORMAL
- en: This would effectively constrain the relationship to function as a one-to-one
    relationship, even though the underlying data model is a one-to-many relationship.
    This one-to-many relationship is almost similar to a one-to-one relationship but
    with a subtle difference of a unique constraint. Why is this one-to-many relationship
    important in data modeling?
  prefs: []
  type: TYPE_NORMAL
- en: Like other database relationships, the one-to-many relationship is a fundamental
    building block of relational database design and is essential for organizing,
    managing, and analyzing complex data structures. The one-to-many relationship
    enforces referential integrity of data by ensuring that each record in the child
    table is associated with a valid record in the parent table. This approach helps
    prevent data inconsistencies and errors that can arise from orphan records or
    references to non-existent records.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an example of a one-to-many relationship. Imagine we have
    `customers` and `orders` tables in our database. It is possible for a customer
    to have many 1:M orders with a business over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: A business might want to keep this record. For example, customers tend to have
    different orders; a particular `orderID` can’t belong to many customers. Every
    customer’s order is unique. The following diagram depicts a one-to-many relationship
    between customers and orders.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – An entity relationship diagram showing the one-to-many relationship](img/Figure_8.2_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – An entity relationship diagram showing the one-to-many relationship
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, `customer_id` in the `orders` table represents the
    foreign key and the main linking factor between the two entities – `customers`
    and `orders`. If you want to know the number of orders a particular customer has,
    all you need to do is write a `JOIN` query that tends to look up `customers` and
    `orders` tables, and check for the occurrence of `customer_id` in the `orders`
    table as a reference key.
  prefs: []
  type: TYPE_NORMAL
- en: In the database design for your web application development, you will encounter
    more of this data relationship, as it is the most commonly used one. Next, we
    take a look at another database relationship, many-to-many.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many (M:M) relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **many-to-many relationship** in data modeling simply refers to a data relationship
    in which multiple records in one table are related to multiple records in another
    table. Take, for instance, a conference database design, where you could have
    the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: An attendee can be enrolled in multiple conference sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A session can have many attendees enrolled in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This implies that an attendee has many conference sessions, and a conference
    session has many attendees. Thus, there is a many-to-many relationship between
    the conference attendees and sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, unlike a one-to-one relationship and one-to-many relationship,
    you can’t model a many-to-many relationship with just two tables. In many-to-many
    relationship modeling, a third join table is required, whereby you have the values
    of the primary keys of the two tables added to the join table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the **entity relationship** (**ER**) diagram of a many-to-many
    relationship for conference attendees and the sessions they enroll in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – An entity relationship diagram showing the many-to-many relationship](img/Figure_8.3_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – An entity relationship diagram showing the many-to-many relationship
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the preceding ER diagram to have a better understanding of
    the many-to-many relationship. We have three tables, as clearly shown – `attendees`,
    `enrollemnt_tbl`, and `conf_sessions`.
  prefs: []
  type: TYPE_NORMAL
- en: The `attendees` table contains records for conference attendees. Likewise, the
    `conf_sessions` table contains records for conference sessions. You then have
    a join table, `enrollment_tbl`, which technically forms a one-to-many relationship
    with each of the two tables.
  prefs: []
  type: TYPE_NORMAL
- en: '`enrollment_tbl` contains the primary keys of both the attendees and the `conf_sessions`
    tables as foreign keys. With `enrollment_tbl`, we can query related records from
    the attendees and `conf_sessions` tables. In this case, we can access all the
    sessions a particular attendee attends at the conference.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve deeper into database setup, using SQLAlchemy and Alembic,
    for the database part of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL, SQLAlchemy, and Alembic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by setting up the database tools needed for the backend
    database. PostgreSQL is a popular free and open source RDBMS. It is similar to
    other dialects of the **SQL** databases that exist – for example, MySQL, MariaDB,
    and Oracle. This database can be used to store data for any web application. PostgreSQL
    has enterprise-grade features that make it robust, scalable, and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: We will also set up SQLAlchemy, an `read`, `insert`, `update`, and `delete`,
    rather than writing SQL queries directly. Finally, in this section, we will set
    up Alembic to handle database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with PostgreSQL locally on your machine, download it from [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    and select your operating system package.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A diagram showing the download page of PostgreSQL](img/Figure_8.4_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – A diagram showing the download page of PostgreSQL
  prefs: []
  type: TYPE_NORMAL
- en: Run through the installation wizard by following the instructions to set up
    the database. During the PostgreSQL installation, you will be prompted to enter
    a super user password. It is very important you keep the password you entered
    as super user, as this will be required to log in to the default PostgreSQL database.
    Once the installation is complete, log in to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command terminal on your machine and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`psql` invokes a connection to PostgreSQL from the terminal. Then, you can
    use the `-d` option to select the database you want to access and `-U` to select
    the user with access permission to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the command terminal replies with `psql not recognized as an internal or
    external command`, you might need to add the Postgres `bin/ (C:\Program Files\PostgreSQL\14\bin`)
    to the system path of the environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, enter the password you created for the superuser during the installation.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the terminal while trying to log in to PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal](img/Figure_8.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A screenshot showing how to access PostgreSQL from the terminal
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a best practice to create a new user on Postgres, different from
    the superuser created during the installation. Now that you are logged in with
    the default Postgres user, let’s create another user role called `admin` and assign
    it the password `admin123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now give a new user `admin` permission to create a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With all this set, log out from the Postgres user and log in as `admin`. To
    log out, type the `\``q` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, log in as an `admin` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the admin password and log in. Once logged in, create a new database
    called `bizza`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the newly created database, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how to connect to create a database in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A screenshot showing a connection to the bizza database](img/Figure_8.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – A screenshot showing a connection to the bizza database
  prefs: []
  type: TYPE_NORMAL
- en: Hurray! We have set up PostgreSQL successfully. Now, let’s dive into setting
    up SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The role name, `admin`, and password, `admin123`, could be anything you want;
    they don’t have to be named as suggested.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up SQLAlchemy for a Flask application is simple and straightforward.
    To set up SQLAlchemy in your project, let’s install SQLAlchemy with the following
    command in the Terminal right inside your project `root` directory. Make sure
    your virtual environment is activated before running the installation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy is a Python SQL toolkit and ORM library that provides a set of high-level
    APIs to interact with relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we will use a Flask extension called **Flask-SQLAlchemy**. Let’s
    install it by running the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Flask-SQLAlchemy extension provides a wrapper for SQLAlchemy, making it
    easier to use SQLAlchemy in a Flask application. Flask-SQLAlchemy provides additional
    features, such as automatic session handling, integration with Flask’s application
    context, and support for Flask-specific configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will be discussed deeply in the subsequent section of this chapter,
    *Understanding SQLAlchemy* *ORM basics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, let’s demonstrate how you can seamlessly integrate SQLAlchemy into
    your Flask application. The process of integrating SQLAlchemy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory and name it `sqlalchemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, follow the Flask project setup in the *Setting up the development environment
    with Flask* section of [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your development virtual environment is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `app.py` within the `sqlalchemy` directory, and add the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code sets up a basic Flask application that uses SQLAlchemy for
    database operations. Let’s explain what happens in the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`from flask import Flask`: This imports the `Flask` class from the Flask package.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from flask_sqlalchemy import SQLAlchemy`: This imports the `SQLAlchemy` class
    from the Flask-SQLAlchemy package.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app = Flask(__name__, template_folder="templates")`: This creates a new `Flask`
    application instance. `template_folder` is added to ensure that Flask finds the
    `templates` directory. `App.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///bizza.db"`:
    This sets the database URI for the SQLite database. In this case, the database
    file is called `bizza.db` and is located in the `instance` directory of the Flask
    application file, `app.py`. We use `SQLite` in this example. You can use any database
    dialect – MySQL, Oracle, PostgreSQL, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db = SQLAlchemy(app)`: This creates a new `SQLAlchemy` instance that is bound
    to the Flask application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a Flask route handler that responds to the `/users` URL endpoint.
    When a user visits the `/users` URL, Flask will execute the `get_users` function,
    retrieve all the users from the database, and render the `users.html` template,
    passing the user’s variable to the template for display.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have the `User` model with four columns – `id`, `username`, `name`,
    and `email`. Each column represents a field in the corresponding database table
    and specifies its data type and optional constraints, such as uniqueness. This
    represents how we use SQLAlchemy in Flask to define our models as Python classes,
    specify their attributes and relationships, and perform database operations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s create the `users` table in the terminal of the `sqlalchemy` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following commands in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, enter the `flask run` command and go to `http://127.0.0.1:5000/users`
    to view the users list from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following is a screenshot that shows how you can use SQLAlchemy to define
    and retrieve users’ data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations](img/Figure_8.7_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – A screenshot showing how to use SQLAlchemy for database operations
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, we have demonstrated how you can define the SQLAlchemy model
    and use Python objects to interact with the database in a Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will dive into how you can set up Alembic, a database migration tool.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Alembic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pip install alembic` or install it from another migration package, `Flask-Migrate`,
    using `pip install flask-migrate`. `Flask-Migrate` relies on Alembic for database
    migration, and we will use it here as a tool of choice for database migration.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Flask-Migrate` migration tool allows you to track changes to your database.
    Migration tools come with the ability to manage database structure and operations
    using a migration script. The essence of Alembic, a migration tool, is to facilitate
    the automatic generation of migration SQL scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will discuss migration in depth with
    some implementation details. Next, we will discuss how you can interact with a
    database from a Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding database concepts for Flask applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have set up our database and connected with it using the Terminal,
    it is crucial to have a solid understanding of some database concepts to be able
    to set up backend services that can collect, store, and retrieve users’ data.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern web applications have a database to store users’ data. As a full
    stack web developer, part of your responsibility is to be able to set up backend
    services that can collect, store, and retrieve users’ data. We will dive into
    interacting with databases from a Flask application shortly, but before that there
    are few database concepts you need to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick overview of the following database concepts.
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with a database in a production environment, you need an RDBMS.
    An RDBMS is a software package that allows you to interact with a database. The
    RDBMS software allows you to define, manipulate, retrieve, and manage data in
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: You have database features that allow you to manage data in a database and the
    structure of the database itself. There are many different RDBMS flavors on the
    market – MySQL, PostgreSQL, Oracle, MsSQL, and MariaDB – but the one we’ll work
    with is called PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at another relevant tool needed to interact with a database,
    called a **database application programming** **interface** (**DB-API**).
  prefs: []
  type: TYPE_NORMAL
- en: DB-APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DB-API is an **application programming interface** (**API**) that allows communication
    between a programming language or web server framework and a database server,
    using protocols such as TCP/IP. Python, a language we use with the Flask framework,
    uses a library called psycopg2 that allows Python modules to interact with a PostgreSQL
    database server.
  prefs: []
  type: TYPE_NORMAL
- en: The DB-API acts as a database adapter, a web interface that allows a web server
    programming language – Python, in our case – to run SQL queries on a database,
    using psycopg2 as a library for the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of DB-APIs exist for every programming language or server framework
    and for the various dialects of the SQL database that we have. For instance, we
    have psycopg2 for PostgreSQL, `mysql-python` or `PyMySQL` for MySQL, `adodbapi`
    or `pymssql` for MS SQL Server, and `mxODBC` or `pyodb` for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation for PEP 248 DB-API version 1.0 specifies a goal for the DB-API:'
  prefs: []
  type: TYPE_NORMAL
- en: “This API has been defined to encourage similarity between the Python modules
    that are used to access databases. By doing this, we hope to achieve a consistency
    leading to more easily understood modules, code that is generally more portable
    across databases, and a broader reach of database connectivity from Python.” ([http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/))
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the DB-API gives you a low-level way of writing SQL query statements,
    making interactions with different databases consistently simple and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Client–server model interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client-server model interaction is a communication paradigm in which a client
    requests resources or services from a server over a network. In this model, the
    client initiates a request to the server, and the server provides the requested
    service or data in response, creating a client-server interaction that forms the
    foundation of various applications and network communications.
  prefs: []
  type: TYPE_NORMAL
- en: In the client-server model interaction, the browser acts as a client and the
    web server as a server. When an end user requests a resource or web page from
    the server, the request is made through a browser (the client side) through HTTP
    protocols on a web server (the server side). This same client-server architecture
    can also be modeled on an end user requesting a resource or web page that contains
    data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: When a browser makes a request that requires data from the database, the web
    server receives the request and initiates a connection with the database server.
    The web server becomes the client, and the database server becomes the server,
    completing a client-server model from the backend infrastructure ([http://www.python.org/dev/peps/pep-0248/](http://www.python.org/dev/peps/pep-0248/)).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will create tables to thoroughly understand how to
    interact with a database. The following diagram shows the client–server interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – A diagram showing the client–server interaction](img/Figure_8.8_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – A diagram showing the client–server interaction
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the client initiates the interaction by sending a
    request to the server. The request can be an HTTP request in the case of web-based
    applications. The server receives the request, interprets it, and performs the
    necessary operations to generate a response.
  prefs: []
  type: TYPE_NORMAL
- en: Once the response is ready, the server sends it back to the client. The client
    receives the response and processes it, utilizing the information provided to
    complete the client-server interaction. Next, we will dive into ORM basics to
    understand how you can use Python classes to interact with an RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SQLAlchemy ORM basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy offers developers the ability to work entirely in Python code to
    create, read, update, and delete tables. SQLAlchemy is the Python SQL toolkit
    and ORM that allows application developers to interact with databases without
    writing direct SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: As SQLAlchemy is an ORM library, Python classes are mapped to tables, and the
    instances of those classes are mapped to table rows in a relational database.
    You then have a situation where you can use Python object-oriented programming
    code to perform database SQL **create**, **read**, **update**, and **delete**
    (**CRUD**) operations and other necessary operations in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM feature of SQLAlchemy gives Python developers the power to harness function
    calls to generate SQL statements out of the box. With this new way of thinking
    about databases, developers are able to decouple object models and database schema,
    leading to a more flexible database structure, elegant SQL statements, and Python
    code that can interact with different types of database dialects.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy doesn’t mind the kind of database systems you work with. SQLAlchemy
    makes it easier to switch from one database to another without altering your code.
    SQLAlchemy is undoubtedly a powerful tool that simplifies the process of web development,
    making it faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: With SQLAlchemy’s user-friendly interface, developers can easily create database
    models and interact with them from their Flask application. Additionally, SQLAlchemy
    is designed to reduce the chances of introducing bugs into the code base, which
    is especially important for large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: With the provision of a robust framework to handle database interactions, SQLAlchemy
    allows developers to focus on building the logic of their applications without
    worrying about the underlying database operations. This results in a more streamlined
    development process and better overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the SQLAlchemy ORM library comes with automatic caching. SQLAlchemy
    caches collections and references between objects once initially loaded. This
    invariably improves performance and prevents you from sending SQL queries to the
    database upon every call.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, there are three main vital layers of abstraction. These layers
    are the engine, the dialect, and the connection pool. This trio describes how
    you choose to interact with a database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The SQLAlchemy layers of abstraction](img/Figure_8.9_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The SQLAlchemy layers of abstraction
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig deeper into the SQLAlchemy layers of abstraction to better understand
    how they are used in SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An SQLAlchemy application starts with the creation of an engine. You need to
    create an engine before SQLAlchemy can connect and interact with a database. The
    engine is at the lowest layer of abstraction in SQLAlchemy, and it works in pretty
    much the same way in which we use Psycopg2 to interact with a database.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an engine to kickstart database connectivity and interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates PostgreSQL database connectivity using `create_engine`
    from SQLAlchemy. The SQLAlchemy engine connects to a PostgreSQL database and executes
    a SQL query in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what happens in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_engine` function is imported from the `sqlalchemy` library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the `create_engine()` method is invoked in SQLAlchemy and assigned to
    the engine instance. You then pass in a connection URL string that specifies backend
    server details, such as the database’s `name`, `username`, `password`, `host`,
    and `port` used for connectivity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A connection pool is created for the current database, and this is created
    once in the lifetime application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We execute the SQL statements using the established connection object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we loop through the result set returned by the query and print the
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to close the result set and the connection using the `result.close()`
    and `conn.close()` methods to free up resources and prevent memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy connection pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connection pooling is an implementation of the object pool design paradigm in
    software engineering, where connections are reused instead of being created every
    time a connection to a database is required. In SQLAlchemy, the use of the `create_engine()`
    method usually generates a connection pool object that is created once and reused
    in subsequent connections when carrying out database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This connection pooling design pattern helps improve performance and better
    manage application concurrent connections. The default setting of the connection
    pool can be adjusted to better serve end users of business web applications efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the connection pool, add pooling parameters to `create_engine()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The following bullet list shows you how to tweak the connection pool parameters
    to optimize performance while working with the SQLAlchemy connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: With `pool_size`, you can set the number of connections the pool can handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `max_overflow`, you can specify how many overflow connections the pool
    supports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `pool_recycle`, you can configure the maximum age in seconds of connections
    in the pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `pool_timeout`, you can specify how many seconds the application needs
    to wait before giving up getting a connection from the pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy dialect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main benefits of using SQLAlchemy is that you can use different types
    of DB-API implementations (Psycopg2) and relational databases without altering
    your Python code to suit their internal workings.
  prefs: []
  type: TYPE_NORMAL
- en: So, the dialect is a system in SQLAlchemy that makes interaction with different
    databases possible. You can use SQLite in your development environment and decide
    to use MySQL or PostgreSQL in production with your existing code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of relational database dialects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL and MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to use these database dialects, you must install appropriate DB-API
    drivers in your application. When connecting with PostgreSQL, SQLAlchemy uses
    Psycopg2 as an implementation of the DB-API specification. Psycopg2 is a PostgreSQL
    adapter for Python. Psycopg2 provides a simple and efficient way to communicate
    with a PostgreSQL database using Python code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve talked about how SQLAlchemy dialects work, but what about the data types
    that are used within those dialects? SQLAlchemy offers a wide variety of data
    types, and we’ll explore some of them now. After that, we’ll discuss how to map
    them to Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy data types – mapping between tables and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy provides high-level abstractions to any underlying relational databases
    we may choose to use in our applications. SQLAlchemy has data type support for
    the most common traditional databases we are familiar with. For instance, dates,
    times, strings, integers, and Booleans are well supported by SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy data types allow for precise data storage and retrieval. Each column
    in a database table has a specific data type that defines the type of data that
    can be stored in that column, such as integers, strings, or dates. SQLAlchemy
    provides a range of data types that can be used to define the columns in a database
    table, including `Numeric`, `String`, `DateTime`, and `Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: By using these data types, we can ensure that our data is stored accurately
    and efficiently, allowing for faster and more reliable data retrieval. Also, the
    mapping between tables and classes is important because it allows us to work with
    database tables in an object-oriented manner.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy provides an ORM system that allows us to map database tables to Python
    classes. This means that we can work with database data using Python objects and
    methods, which makes it easier to build and maintain our web applications. Let’s
    see an example of how SQLAlchemy data types are mapped with Python classes and
    instance attributes for table and column creations, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach will be used to define tables from Python classes for the Flask
    applications in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we defined a class called `Speaker` that has
    some attributes. Let’s dive deeper into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__tablename__` attribute is set to `speakers`, indicating that instances
    of the `Speaker` class should be stored in the `speakers` table in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `speaker_id` attribute specifies that this is the `primary_key` in the table
    and has an `Integer` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `first_name` attribute specifies that a column in the table has the name
    `first_name` with a `String` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `last_name` attribute specifies that a column in the table has a name `last_name`
    with a `String` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `email` attribute specifies that a column in the table has the name `email`
    with a `String` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at` and `updated_at` specify columns in the table with the mentioned
    names that are of type `date`. Methods are, however, passed to get the current
    `timezone`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the classes and instances defined, we can utilize the internal APIs of
    SQLAlchemy and the configured dialect to map the class attributes to the corresponding
    native structure of the database. For example, if we have a string data type in
    our class, SQLAlchemy will map it to a `varchar` column in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the data types used in the class are properly translated into
    the appropriate database column types, allowing for seamless communication between
    the Python code and the database.
  prefs: []
  type: TYPE_NORMAL
- en: To build a robust web application for a speakers’ conference web application,
    we need to model the data correctly. SQLAlchemy provides us with a powerful ORM
    that makes it easy to map our database tables to classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can then define the attributes and relationships between these classes, which
    makes it easy to work with complex data structures. In the next section, we will
    explore how to model data for our speakers’ conference web application using SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling data for a speakers’ conference web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data modeling** is the process of creating a conceptual, logical, and visual
    representation of data structures and relationships between data elements, in
    order to understand, analyze, and manage complex information systems. Data modeling
    involves identifying entities (objects, concepts, or things) that will be represented
    in a system and defining their attributes and relationships with other entities.'
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of data modeling is to create a clear and precise representation
    of the data that will be stored, processed, and managed by an information system.
    A well-designed data model in a web application can ensure that the web application
    is scalable, efficient, and meets the needs of its users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly examine some of the best practices to be considered when designing
    a data model for the conference speakers’ web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the entities**: Start by identifying the entities or objects
    that will be represented in the web application based on the system requirements,
    such as users, speakers, presentation, schedule, attendees, sessions, venue, and
    sponsors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the relationships**: Determine the relationships between these entities,
    such as one-to-one, one-to-many, or many-to-many relationships. For instance,
    a speaker can give multiple presentations at the conference, but a presentation
    can only be given by one speaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determining the attributes**: Define the attributes or properties of each
    entity – for instance, a speaker could have attributes such as name, contact address,
    biography, or presentation topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Considering performance and scalability**: Design the data model to optimize
    performance and scalability, such as using indexes, caching, or denormalization
    to reduce query times and improve system response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Planning for data storage**: Consider the data storage options available,
    such as relational databases, NoSQL databases, or flat files, and choose the appropriate
    option based on the needs of the web application. In this case, PostgreSQL was
    chosen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data security**: Design the data model to ensure data security, such as using
    encryption or access controls to protect sensitive data. For instance, when a
    user logs in, their entered password can be hashed and compared to the stored
    hash to verify their identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Considering future changes**: Plan for future changes and updates to the
    web application, such as adding new entities or attributes, or modifying existing
    relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you prepared to begin developing the backend of the *Bizza* project by establishing
    and organizing the data model? The *Bizza* project aims to create a full stack
    web application that is database-driven and focuses on conference speakers.
  prefs: []
  type: TYPE_NORMAL
- en: In this data model, we will take a closer look at the database, tables, and
    relationship between the tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bizza` database has the following tables and relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users` and `userExtras`, a many-to-many relationship between users and roles,
    a one-to-one relationship between `users` and `speakers`, and a one-to-many relationship
    between `users` and `attendees`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` table – a one-to-one relationship between `users` and `userExtras`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` table – a many-to-many relationship between `users` and `roles`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Speaker` model will be linked to the `users` model to associate each speaker
    with their user account. The following relationships exist with other tables –
    a one-to-many relationship between `speakers` and `sessions`, a one-to-one relationship
    between `users` and `speakers`, a one-to-many relationship between `speakers`
    and `schedules`, and a one-to-many relationship between `speakers` and `presentations`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Presentation` model will be linked to the `Speaker` model to associate each
    presentation with its speaker. The following relationships exist with other tables
    – many-to-one relationships between `presentations` and `speakers`, and one-to-many
    relationships between `presentations` and `schedules`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedule` model will be linked to the `Presentation` model to associate each
    presentation with its date and time. The following relationships exist with other
    tables – many-to-one relationships between `schedules` and `presentations`, one-to-many
    relationships between `schedules` and `sessions`, many-to-one relationships between
    `schedules` and `venues`, and many-to-many relationships between `schedules` and
    `attendees`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attendees` and `schedules`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Session` model will be linked to the `Presentation` model to associate each
    session with its presentations. The following relationships exist with other tables
    – a many-to-one relationship between `sessions` and `schedules`, and a one-to-one
    relationship between `sessions` and `presentations`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`venues` and `schedules`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sponsor model**: This model will include data about each sponsor of the conference,
    such as their name, logo, website, and any other relevant details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined our data model, we will explore in the next section
    how to seamlessly send data to a PostgreSQL database with just a few simple steps.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to the PostgreSQL database from a Flask app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with a database is a common aspect of most web applications. Sending
    data to the PostgreSQL database from a Flask app is simple and straightforward.
    A web application would not be complete without the ability to store and retrieve
    data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in sending data to a database is to ensure there is a connection
    between the Flask app and the database. This involves installing the required
    libraries and ensuring that you work in a virtual environment to contain your
    installation and prevent unexpected occurrences, due to the interference of other
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make use of the `bizza/backend` directory created in the *Setting up the
    development environment with Flask* section of [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
    You can create one if you haven’t already. Install and activate the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a virtual environment, open your project root directory in a terminal
    and add the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For** **Windows users**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**For** **Linux/Mac users**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a database table from a Python class, you need `flask-sqlalchemy`
    installed. We have this installed already. If not, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the Flask application module – that is, `app.py` – update the content of
    the `app.py` with the following code that creates the `users` table in the *bizza*
    database. In this section, we will only create the `users` table to demonstrate
    how to send data from a Flask app to PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other models will be shown on GitHub and later in the book until we have
    a full implementation of the speakers’ conference web app, *Bizza*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s delve into the preceding Flask app snippet used to create the `users`
    table in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from flask import Flask` imports the `Flask` class from the Flask module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from flask_sqlalchemy import SQLAlchemy` imports the `SQLAlchemy` class from
    the `flask_sqlalchemy` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app = Flask(__name__)` creates a `Flask` instance named `app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.config[''SQLALCHEMY_DATABASE_URI''] = ''postgresql://<db_username>:<db_password>@localhost:5432/<database_name>''`
    is where the `app.config[]` dictionary defines the path to the database with the
    `db username` and `password` set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db = SQLAlchemy(app)` initializes an instance of the `SQLAlchemy` class with
    the Flask app as the argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we start to define the `model` class for `User` with `class User(db.Model):`.
    The `User(db.Model)` class defines a `User` model that inherits from the `db.Model`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__tablename__ = ''users''` allows us to have a custom name for the table –
    a *Class User* model with a corresponding table name, `users`. If this is not
    specified, the lowercase class name (`user`) will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we add the columns for the table. Each column is an object of the `Column`
    subclass of SQLAlchemy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User_id = db.Column(db.Integer, primary_key=True,nullable=False)` defines
    a primary key column named `user_id` with an `Integer` data type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username = db.Column(db.String(50), unique=True, nullable=False)` defines
    a column named `username` with a `String` data type and enforces that it must
    be unique and not nullable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email = db.Column(db.String(120), unique=True, nullable=False)` defines a
    column named `email` with a `String` data type and enforces that it must be unique
    and not nullable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password = db.Column(db.String(256), nullable=False)` defines a column named
    `password` with a `String` data type and enforces that it must not be nullable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name = db.Column(db.String(50), nullable=False)` defines a column named
    `first_name` with a `String` data type and enforces that it must not be nullable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name = db.Column(db.String(50), nullable=False)` defines a column named
    `last_name` with a `String` data type and enforces that it must not be nullable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_active = db.Column(db.Boolean, default=True)` defines a column named `is_active`
    with a b`oolean` data type and sets a default value of `True`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_superuser = db.Column(db.Boolean, default=False)` defines a column named
    `is_superuser` with a `Boolean` data type and sets a default value of `False`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def __repr__(self)` defines a method that returns a string representation
    of the `User` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return ''<User %r>'' % self.username` returns a string that includes the username
    of the `User` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined the `User` class model, it’s time to create the `users`
    table in the database and pass in some data:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal in the project root directory and enter the `flask` `shell`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – A screenshot showing flask shell](img/Figure_8.10_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – A screenshot showing flask shell
  prefs: []
  type: TYPE_NORMAL
- en: Enter `from app import db` to connect with the database object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `db.create_all()` to create the `users` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A screenshot showing db.create_all()](img/Figure_8.11_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – A screenshot showing db.create_all()
  prefs: []
  type: TYPE_NORMAL
- en: Enter `from app import User` to gain access to the `User` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add user data to the table using the `flask` `shell` terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add `db.session.add(user1)` and `db.session.commit()` to add a user to the database
    session and a commit for data persistence in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `User.query.all()` to see the `users` table with the added information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – A screenshot showing flask shell with inserted data](img/Figure_8.12_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – A screenshot showing flask shell with inserted data
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how you can add and track changes to your database structure
    with migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Migration with Alembic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, Alembic is a migration tool that makes the tracking of
    changes in a database a less problematic operation for Flask developers. Since
    we expect data models to change, we need a tool that can keep track of these changes
    and ensure they are updated in the database.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how we do version control of source code using `Git`. The
    same applies to database schema change management, where we keep incremental and
    reversible changes in the database structure. Working with a database table, you
    will want to add or remove columns, thus altering the schema in a Python model
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, you need an automatic process to ensure your database table
    and the state of the data model schema are in sync. Alembic graciously handles
    the schema migration and ensures that the data model in a Python file is the same
    as the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine how you can implement migration in a Flask application. We will
    add another model and use migration to track changes made to the database. Here,
    we add the `Speaker` model class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `Flask-Migrate` with `pip`, as stated in the *Setting up* *Alembic*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `app.py`, add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A few changes were made to the `app.py` file, including the installation of
    the `flask-migrate` package, the creation of an instance of the `Migrate` class
    with the `app` and `db` instances as arguments, and the addition of a `speaker`
    model class that will be tracked upon its inclusion in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the changes made to `app.py` with the addition of the `speaker` model
    class, let’s implement migrations with Alembic:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, inside the project directory, enter the `pip install flask-migrate`
    command. The `flask-migrate` extension provides database migration support for
    Flask applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate the initial migration in Flask, enter the following in the command
    terminal of the project root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, once you have initialized the migration repository, you can use the `flask
    db migrate` command to generate the first migration, based on changes you have
    made to your models. We have added the new speaker model to the `app.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, use the `flask db migrate -m ''first migration message, speaker model
    added''` command to generate a new migration script, based on the changes made
    to the database models. The `-m` flag is used to specify a message describing
    the changes made in the migration. The following command will create a new migration
    file with the changes specified in the models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the effects of the commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A screenshot showing the migration commands](img/Figure_8.13_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – A screenshot showing the migration commands
  prefs: []
  type: TYPE_NORMAL
- en: 'To commit the schema data model change to a database based on the state of
    the migration script, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will then get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A screenshot showing the flask db upgrade command](img/Figure_8.14_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – A screenshot showing the flask db upgrade command
  prefs: []
  type: TYPE_NORMAL
- en: This will apply all the pending migrations to your database schema. From this
    point on, you can continue to generate new migrations as needed using the `flask
    db` `migrate` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the commands needed for Alembic migrations, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pip** **install flask-migrate**'
  prefs: []
  type: TYPE_NORMAL
- en: '**flask** **db init**'
  prefs: []
  type: TYPE_NORMAL
- en: '**flask db migrate -m “first migration message** **speakers model”**'
  prefs: []
  type: TYPE_NORMAL
- en: '**flask** **db upgrade**'
  prefs: []
  type: TYPE_NORMAL
- en: Alembic is a database migration tool for SQLAlchemy that helps keep the database
    schema in sync with the application’s data model. When using Alembic, you define
    changes to the data model in a series of migrations, which are Python scripts
    that modify the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: These migrations are stored in a migration directory, and each migration is
    associated with a specific version of the schema. When you run a migration, Alembic
    compares the current state of the database schema to the target state defined
    in the migration. It then generates a set of SQL statements to modify the database
    schema to match the target state.
  prefs: []
  type: TYPE_NORMAL
- en: These SQL statements are executed in a transaction, which ensures that the database
    schema is modified in a consistent manner. With the use of Alembic to manage database
    migrations, you can ensure that the database schema remains in sync with the application’s
    data model as it evolves over time. This can help prevent data inconsistencies
    and other issues that can arise when the database schema and data model become
    out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extensively discussed SQL and relational data modeling for
    the web. A relational database helps us with the design of a database as a group
    of relations. We also discussed relationships that can exist in a database, such
    as one-to-one, one-to-many, and many-to-many relationships, allowing us to logically
    group relations in the database and enforce data referential integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we examined how to set up PostgreSQL. We shed light on the basics
    of SQLAlchemy and its associated database adapters and how they are used in Flask
    application development. We discussed data model design, with the *Bizza* project
    as a use case. Finally, we discussed how a Flask app can communicate with the
    database and migration in Flask to keep track of changes in a database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extensively discuss the API in backend development
    and how you can use the Flask framework to implement API design.
  prefs: []
  type: TYPE_NORMAL
