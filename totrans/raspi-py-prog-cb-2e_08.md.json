["```py\nraspistill -o image.jpg -t 0\n\n```", "```py\nraspivid -o video.h264 -t 10000\n\n```", "```py\nraspistill > less\nraspivid > less\n\n```", "```py\nsudo apt-get install python3-picamera\n\n```", "```py\n    #!/usr/bin/python3\n    #cameraGUI.py\n    import tkinter as TK\n    from PIL import Image\n    import subprocess\n    import time\n    import datetime\n    import picamera as picam\n\n    class SET():\n      PV_SIZE=(320,240)\n      NORM_SIZE=(2592,1944)\n      NO_RESIZE=(0,0)\n      PREVIEW_FILE=\"PREVIEW.gif\"\n      TEMP_FILE=\"PREVIEW.ppm\"\n\n    class cameraGUI(TK.Frame):\n      def run(cmd):\n        print(\"Run:\"+cmd)\n        subprocess.call([cmd], shell=True)\n      def camCapture(filename,size=SET.NORM_SIZE):\n        with picam.PiCamera() as camera:\n          camera.resolution = size\n          print(\"Image: %s\"%filename)\n          camera.capture(filename)\n      def getTKImage(filename,previewsize=SET.NO_RESIZE):\n        encoding=str.split(filename,\".\")[1].lower()\n        print(\"Image Encoding: %s\"%encoding)\n        try:\n          if encoding==\"gif\" and previewsize==SET.NO_RESIZE:\n            theTKImage=TK.PhotoImage(file=filename)\n          else:\n            imageview=Image.open(filename)\n            if previewsize!=SET.NO_RESIZE:\n              imageview.thumbnail(previewsize,Image.ANTIALIAS)\n            imageview.save(SET.TEMP_FILE,format=\"ppm\")\n            theTKImage=TK.PhotoImage(file=SET.TEMP_FILE)\n        except IOError:\n          print(\"Unable to get: %s\"%filename)\n        return theTKImage\n      def timestamp():\n        ts=time.time() \n        tstring=datetime.datetime.fromtimestamp(ts)\n        return tstring.strftime(\"%Y%m%d_%H%M%S\")\n\n      def __init__(self,parent):\n        self.parent=parent\n        TK.Frame.__init__(self,self.parent)\n        self.parent.title(\"Camera GUI\")\n        self.previewUpdate = TK.IntVar()\n        self.filename=TK.StringVar()\n        self.canvas = TK.Canvas(self.parent,\n                                width=SET.PV_SIZE[0],\n                                height=SET.PV_SIZE[1])\n        self.canvas.grid(row=0,columnspan=4)\n        self.shutterBtn=TK.Button(self.parent,text=\"Shutter\",\n                                        command=self.shutter)\n        self.shutterBtn.grid(row=1,column=0)\n        exitBtn=TK.Button(self.parent,text=\"Exit\",\n                                 command=self.exit)\n        exitBtn.grid(row=1,column=3)\n        previewChk=TK.Checkbutton(self.parent,text=\"Preview\",\n                                  variable=self.previewUpdate)\n        previewChk.grid(row=1,column=1)\n        labelFilename=TK.Label(self.parent,\n                               textvariable=self.filename)\n        labelFilename.grid(row=2,column=0,columnspan=3)\n        self.preview()\n      def msg(self,text):\n        self.filename.set(text)\n        self.update()\n      def btnState(self,state):\n        self.shutterBtn[\"state\"] = state\n      def shutter(self):\n        self.btnState(\"disabled\")\n        self.msg(\"Taking photo...\")\n        self.update()\n        if self.previewUpdate.get() == 1:\n          self.preview()\n        else:\n          self.normal()\n        self.btnState(\"active\")\n      def normal(self):\n        name=cameraGUI.timestamp()+\".jpg\"\n        cameraGUI.camCapture(name,SET.NORM_SIZE)\n        self.updateDisp(name,previewsize=SET.PV_SIZE)\n        self.msg(name)\n      def preview(self):\n        cameraGUI.camCapture(SET.PREVIEW_FILE,SET.PV_SIZE)\n        self.updateDisp(SET.PREVIEW_FILE)\n        self.msg(SET.PREVIEW_FILE)\n      def updateDisp(self,filename,previewsize=SET.NO_RESIZE):\n        self.msg(\"Loading Preview...\")\n        self.myImage=cameraGUI.getTKImage(filename,previewsize)\n        self.theImage=self.canvas.create_image(0,0,\n                                      anchor=TK.NW,\n                                      image=self.myImage)\n        self.update()\n      def exit(self):\n        exit()\n    #End\n    ```", "```py\n    #!/usr/bin/python3\n    #cameraGUI1normal.py\n    import tkinter as TK\n    import cameraGUI as GUI\n\n    root=TK.Tk()\n    root.title(\"Camera GUI\")\n    cam=GUI.cameraGUI(root)\n    TK.mainloop()\n    #End\n    ```", "```py\n    python3 cameraGUI1normal.py\n\n    ```", "```py\nls /dev/video*\n\n```", "```py\nsudo apt-get install fswebcam\n\n```", "```py\nfswebcam -d /dev/video0 -r 320x240 testing.jpg\n\n```", "```py\ndd if=/dev/video0 of=testing.jpeg bs=11M count=1\n\n```", "```py\n        cameraGUI.run(SET.CAM_PREVIEW+SET.CAM_OUTPUT+\n                      SET.PREVIEW_FILE)\n    ```", "```py\n        cameraGUI.run(SET.CAM_NORMAL+SET.CAM_OUTPUT+name)\n    ```", "```py\n    CAM_OUTPUT=\" \"\n    CAM_PREVIEW=\"fswebcam -d /dev/video0 -r 320x240\"\n    CAM_NORMAL=\"fswebcam -d /dev/video0 -r 640x480\"\n    ```", "```py\n    wget http://www.linux-projects.org/listing/uv4l_repo/lrkey.asc\n    sudo apt-key add ./lrkey.asc\n    sudo nano /etc/apt/souces.list \n\n    ```", "```py\n    deb http://www.linux-projects.org/listing/uv4l_repo/raspbian/ wheezy main\n\n    ```", "```py\n    sudo apt-get update\n    sudo apt-get install uv4l uv4l-raspicam\n\n    ```", "```py\n    uv4l --driver raspicam --auto-video_nr --width 640 â€“height480 --encoding jpeg\n    ```", "```py\nsudo apt-get install mencoder\n\n```", "```py\n    #!/usr/bin/python3\n    #timelapseGUI.py\n    import tkinter as TK\n    from tkinter import messagebox\n    import cameraGUI as camGUI\n    import time\n    ```", "```py\n    class SET(camGUI.SET):\n      TL_SIZE=(1920,1080)\n      ENC_PROG=\"mencoder -nosound -ovc lavc -lavcopts\"\n      ENC_PROG+=\" vcodec=mpeg4:aspect=16/9:vbitrate=8000000\"\n      ENC_PROG+=\" -vf scale=%d:%d\"%(TL_SIZE[0],TL_SIZE[1])\n      ENC_PROG+=\" -o %s -mf type=jpeg:fps=24 mf://@%s\"\n      LIST_FILE=\"image_list.txt\"\n    ```", "```py\n    class cameraGUI(camGUI.cameraGUI):\n      def camTimelapse(filename,size=SET.TL_SIZE,\n                        timedelay=10,numImages=10):\n        with camGUI.picam.PiCamera() as camera:\n          camera.resolution = size\n          for count, name in \\\n                enumerate(camera.capture_continuous(filename)):\n            print(\"Timelapse: %s\"%name)\n            if count == numImages:\n              break\n            time.sleep(timedelay)\n    ```", "```py\n      def __init__(self,parent):\n        super(cameraGUI,self).__init__(parent)\n        self.parent=parent\n        TK.Frame.__init__(self,self.parent,background=\"white\")\n        self.numImageTL=TK.StringVar()\n        self.peroidTL=TK.StringVar()\n        self.totalTimeTL=TK.StringVar()\n        self.genVideoTL=TK.IntVar()\n        labelnumImgTK=TK.Label(self.parent,text=\"TL:#Images\")\n        labelperoidTK=TK.Label(self.parent,text=\"TL:Delay\")\n        labeltotalTimeTK=TK.Label(self.parent,\n                                  text=\"TL:TotalTime\")\n        self.numImgSpn=TK.Spinbox(self.parent,\n                           textvariable=self.numImageTL,\n                           from_=1,to=99999,\n                           width=5,state=\"readonly\",\n                           command=self.calcTLTotalTime)\n        self.peroidSpn=TK.Spinbox(self.parent,\n                           textvariable=self.peroidTL,\n                           from_=1,to=99999,width=5,\n                           command=self.calcTLTotalTime)\n        self.totalTime=TK.Label(self.parent,\n                           textvariable=self.totalTimeTL)\n        self.TLBtn=TK.Button(self.parent,text=\"TL GO!\",\n                                 command=self.timelapse)\n        genChk=TK.Checkbutton(self.parent,text=\"GenVideo\",\n                                 command=self.genVideoChk,\n                                 variable=self.genVideoTL)\n        labelnumImgTK.grid(row=3,column=0)\n        self.numImgSpn.grid(row=4,column=0)\n        labelperoidTK.grid(row=3,column=1)\n        self.peroidSpn.grid(row=4,column=1)\n        labeltotalTimeTK.grid(row=3,column=2)\n        self.totalTime.grid(row=4,column=2)\n        self.TLBtn.grid(row=3,column=3)\n        genChk.grid(row=4,column=3)\n        self.numImageTL.set(10)\n        self.peroidTL.set(5)\n        self.genVideoTL.set(1)\n        self.calcTLTotalTime()\n    ```", "```py\n      def btnState(self,state):\n        self.TLBtn[\"state\"] = state\n        super(cameraGUI,self).btnState(state)\n      def calcTLTotalTime(self):\n        numImg=float(self.numImageTL.get())-1\n        peroid=float(self.peroidTL.get())\n        if numImg<0:\n          numImg=1\n        self.totalTimeTL.set(numImg*peroid)\n      def timelapse(self):\n        self.msg(\"Running Timelapse\")\n        self.btnState(\"disabled\")\n        self.update()\n        self.tstamp=\"TL\"+cameraGUI.timestamp()\n        cameraGUI.camTimelapse(self.tstamp+'{counter:03d}.jpg',\n                               SET.TL_SIZE,\n                               float(self.peroidTL.get()),\n                               int(self.numImageTL.get()))\n        if self.genVideoTL.get() == 1:\n          self.genTLVideo()\n        self.btnState(\"active\")\n        TK.messagebox.showinfo(\"Timelapse Complete\",\n                               \"Processing complete\")\n        self.update()\n    ```", "```py\n      def genTLVideo(self):\n        self.msg(\"Generate video...\")\n        cameraGUI.run(\"ls \"+self.tstamp+\"*.jpg > \"\n                                    +SET.LIST_FILE)\n        cameraGUI.run(SET.ENC_PROG%(self.tstamp+\".avi\",\n                                          SET.LIST_FILE))\n        self.msg(self.tstamp+\".avi\")\n    #End\n    ```", "```py\n    #!/usr/bin/python3\n    #cameraGUI2timelapse.py\n    import tkinter as TK\n    import timelapseGUI as GUI\n\n    root=TK.Tk()\n    root.title(\"Camera GUI\")\n    cam=GUI.cameraGUI(root)\n    TK.mainloop()\n    #End\n    ```", "```py\npython3 cameraGUI2timelapse.py\n\n```", "```py\ndef camTimelapse(filename,size=SET.TL_SIZE,\n                    timedelay=10,numImages=10):\n    with camGUI.picam.PiCamera() as camera:\n      camera.resolution = size\n      for count, name in \\\n            enumerate(camera.capture_continuous(filename)):\n        print(\"Timelapse: %s\"%name)\n        if count == numImages:\n          break\n        time.sleep(timedelay)\n```", "```py\nls <self.tstamp>*.jpg > image_list.txt\n\n```", "```py\nmencoder -nosound -ovc lavc \\\n -lavcopts vcodec=mpeg4:aspect=16/9:vbitrate=8000000 \\\n -vf scale=1920:1080 -o <self.tstamp>.avi \\\n -mf type=jpeg:fps=24 mf://@image_list.txt\n\n```", "```py\nimport RPi.GPIO as GPIO\n\nGPIO.cleanup()\nGPIO.setmode(GPIO.BCM)\nCAMERALED=5 #GPIO using BCM numbering\nGPIO.setup(CAMERALED, GPIO.OUT)\nGPIO.output(CAMERALED,False)\n```", "```py\n    #!/usr/bin/python3\n    #animateGUI.py\n    import tkinter as TK\n    from tkinter import messagebox\n    import time\n    import os\n    import cameraGUI as camGUI\n    ```", "```py\n    class SET(camGUI.SET):\n      TL_SIZE=(1920,1080)\n      ENC_PROG=\"mencoder -nosound -ovc lavc -lavcopts\"\n      ENC_PROG+=\" vcodec=mpeg4:aspect=16/9:vbitrate=8000000\"\n      ENC_PROG+=\" -vf scale=%d:%d\"%(TL_SIZE[0],TL_SIZE[1])\n      ENC_PROG+=\" -o %s -mf type=jpeg:fps=24 mf://@%s\"\n      LIST_FILE=\"image_list.txt\"\n    ```", "```py\n    class cameraGUI(camGUI.cameraGUI):\n      def diff(a, b):\n        b = set(b)\n        return [aa for aa in a if aa not in b]\n      def __init__(self,parent):\n        super(cameraGUI,self).__init__(parent)\n        self.parent=parent\n        TK.Frame.__init__(self,self.parent,\n                          background=\"white\")\n        self.theList = TK.Variable()\n        self.imageListbox=TK.Listbox(self.parent,\n                       listvariable=self.theList,\n                           selectmode=TK.EXTENDED)\n        self.imageListbox.grid(row=0, column=4,columnspan=2,\n                                  sticky=TK.N+TK.S+TK.E+TK.W)\n        yscroll = TK.Scrollbar(command=self.imageListbox.yview,\n                                            orient=TK.VERTICAL)\n        yscroll.grid(row=0, column=6, sticky=TK.N+TK.S)\n        self.imageListbox.configure(yscrollcommand=yscroll.set)\n        self.trimBtn=TK.Button(self.parent,text=\"Trim\",\n                                      command=self.trim)\n        self.trimBtn.grid(row=1,column=4)\n        self.speed = TK.IntVar()\n        self.speed.set(20)\n        self.speedScale=TK.Scale(self.parent,from_=1,to=30,\n                                      orient=TK.HORIZONTAL,\n                                       variable=self.speed,\n                                       label=\"Speed (fps)\")\n        self.speedScale.grid(row=2,column=4)\n        self.genBtn=TK.Button(self.parent,text=\"Generate\",\n                                     command=self.generate)\n        self.genBtn.grid(row=2,column=5)\n        self.btnAniTxt=TK.StringVar()\n        self.btnAniTxt.set(\"Animate\")\n        self.animateBtn=TK.Button(self.parent,\n                  textvariable=self.btnAniTxt,\n                          command=self.animate)\n        self.animateBtn.grid(row=1,column=5)\n        self.animating=False\n        self.updateList()\n    ```", "```py\n      def shutter(self):\n        super(cameraGUI,self).shutter()\n        self.updateList()\n\n      def updateList(self):\n        filelist=[]\n        for files in os.listdir(\".\"):\n          if files.endswith(\".jpg\"):\n            filelist.append(files)\n        filelist.sort()\n        self.theList.set(tuple(filelist))\n        self.canvas.update()\n\n      def generate(self):\n        self.msg(\"Generate video...\")\n        cameraGUI.run(\"ls *.jpg > \"+SET.LIST_FILE)\n        filename=cameraGUI.timestamp()+\".avi\"\n        cameraGUI.run(SET.ENC_PROG%(filename,SET.LIST_FILE))\n        self.msg(filename)\n        TK.messagebox.showinfo(\"Encode Complete\",\n                               \"Video: \"+filename)\n      def trim(self):\n        print(\"Trim List\")\n        selected = map(int,self.imageListbox.curselection())\n        trim=cameraGUI.diff(range(self.imageListbox.size()),\n                                                    selected)\n        for item in trim:\n          filename=self.theList.get()[item]\n          self.msg(\"Rename file %s\"%filename)\n          #We could delete os.remove() but os.rename() allows\n          #us to change our minds (files are just renamed).\n          os.rename(filename,\n                    filename.replace(\".jpg\",\".jpg.bak\"))\n          self.imageListbox.selection_clear(0,\n                          last=self.imageListbox.size())\n        self.updateList()\n    ```", "```py\n      def animate(self):\n        print(\"Animate Toggle\")\n        if (self.animating==True):\n          self.btnAniTxt.set(\"Animate\")\n          self.animating=False\n        else:\n          self.btnAniTxt.set(\"STOP\")\n          self.animating=True\n          self.doAnimate()\n\n      def doAnimate(self):\n        imageList=[]\n        selected = self.imageListbox.curselection()\n        if len(selected)==0:\n          selected=range(self.imageListbox.size())\n        print(selected)\n        if len(selected)==0:\n          TK.messagebox.showinfo(\"Error\",\n                          \"There are no images to display!\")\n          self.animate()\n        elif len(selected)==1:\n          filename=self.theList.get()[int(selected[0])]\n          self.updateDisp(filename,SET.PV_SIZE)\n          self.animate()\n        else:\n          for idx,item in enumerate(selected):\n            self.msg(\"Generate Image: %d/%d\"%(idx+1,\n                                            len(selected)))\n            filename=self.theList.get()[int(item)]\n            aImage=cameraGUI.getTKImage(filename,SET.PV_SIZE)\n            imageList.append(aImage)\n          print(\"Apply Images\")\n          canvasList=[]\n          for idx,aImage in enumerate(imageList):\n            self.msg(\"Apply Image: %d/%d\"%(idx+1,\n                                           len(imageList)))\n            canvasList.append(self.canvas.create_image(0, 0,\n                                      anchor=TK.NW,\n                                      image=imageList[idx],\n                                      state=TK.HIDDEN))\n          self.cycleImages(canvasList)\n\n      def cycleImages(self,canvasList):\n        while (self.animating==True):\n          print(\"Cycle Images\")\n          for idx,aImage in enumerate(canvasList):\n            self.msg(\"Cycle Image: %d/%d\"%(idx+1,\n                                      len(canvasList)))\n            self.canvas.itemconfigure(canvasList[idx],\n                                      state=TK.NORMAL)\n            if idx>=1:\n              self.canvas.itemconfigure(canvasList[idx-1],\n                                          state=TK.HIDDEN)\n            elif len(canvasList)>1:\n              self.canvas.itemconfigure(\n                            canvasList[len(canvasList)-1],\n                                          state=TK.HIDDEN)\n            self.canvas.update()\n            time.sleep(1/self.speed.get())\n    #End\n    ```", "```py\n    #!/usr/bin/python3\n    #cameraGUI3animate.py\n    import tkinter as TK\n    import animateGUI as GUI\n\n    #Define Tkinter App\n    root=TK.Tk()\n    root.title(\"Camera GUI\")\n    cam=GUI.cameraGUI(root)\n    TK.mainloop()\n    #End\n    ```", "```py\n    python3 cameraGUI3animate.py\n\n    ```", "```py\n#!/usr/bin/python3\n#shutterCam.py\nimport RPi.GPIO as GPIO\nimport cameraGUI as camGUI\nimport time\n\nGPIO.setmode(GPIO.BOARD)\nCAMERA_BTN=12 #GPIO Pin 12\nGPIO.setup(CAMERA_BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP)\ncount=1\ntry:\n  while True:\n    btn_val = GPIO.input(CAMERA_BTN)\n    #Take photo when Pin 12 at 0V\n    if btn_val==False:\n      camGUI.cameraGUI.camCapture(\"Snap%03d.jpg\"%count,\n                                   camGUI.SET.NORM_SIZE)\n      count+=1\n    time.sleep(0.1)\nfinally:\n  GPIO.cleanup()\n#End\n```", "```py\nsudo apt-get install zbar-tools flite\n\n```", "```py\n#!/usr/bin/python3\n#qrcodeGUI.py\nimport tkinter as TK\nfrom tkinter import messagebox\nimport subprocess\nimport cameraGUI as camGUI\n\nclass SET(camGUI.SET):\n  QR_SIZE=(640,480)\n  READ_QR=\"zbarimg \"\n\nclass cameraGUI(camGUI.cameraGUI):\n  def run_p(cmd):\n    print(\"RunP:\"+cmd)\n    proc=subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE)\n    result=\"\"\n    for line in proc.stdout:\n      result=str(line,\"utf-8\")\n    return result\n  def __init__(self,parent):\n    super(cameraGUI,self).__init__(parent)\n    self.parent=parent\n    TK.Frame.__init__(self,self.parent,background=\"white\")\n    self.qrScan=TK.IntVar()\n    self.qrRead=TK.IntVar()\n    self.qrStream=TK.IntVar()\n    self.resultQR=TK.StringVar()\n    self.btnQrTxt=TK.StringVar()\n    self.btnQrTxt.set(\"QR GO!\")\n    self.QRBtn=TK.Button(self.parent,textvariable=self.btnQrTxt,\n                                              command=self.qrGet)\n    readChk=TK.Checkbutton(self.parent,text=\"Read\",\n                               variable=self.qrRead)\n    streamChk=TK.Checkbutton(self.parent,text=\"Stream\",\n                                 variable=self.qrStream)\n    labelQR=TK.Label(self.parent,textvariable=self.resultQR)\n    readChk.grid(row=3,column=0)\n    streamChk.grid(row=3,column=1)\n    self.QRBtn.grid(row=3,column=3)\n    labelQR.grid(row=4,columnspan=4)\n    self.scan=False\n  def qrGet(self):\n    if (self.scan==True):\n      self.btnQrTxt.set(\"QR GO!\")\n      self.btnState(\"active\")\n      self.scan=False\n    else:\n      self.msg(\"Get QR Code\")\n      self.btnQrTxt.set(\"STOP\")\n      self.btnState(\"disabled\")\n      self.scan=True\n      self.qrScanner()\n  def qrScanner(self):\n    found=False\n    while self.scan==True:\n      self.resultQR.set(\"Taking image...\")\n      self.update()\n      cameraGUI.camCapture(SET.PREVIEW_FILE,SET.QR_SIZE)\n      self.resultQR.set(\"Scanning for QRCode...\")\n      self.update()\n      #check for QR code in image\n      qrcode=cameraGUI.run_p(SET.READ_QR+SET.PREVIEW_FILE)\n      if len(qrcode)>0:\n        self.msg(\"Got barcode: %s\"%qrcode)\n        qrcode=qrcode.strip(\"QR-Code:\").strip('\\n')\n        self.resultQR.set(qrcode)\n        self.scan=False\n        found=True\n      else:\n        self.resultQR.set(\"No QRCode Found\")\n    if found:\n      self.qrAction(qrcode)\n      self.btnState(\"active\")\n      self.btnQrTxt.set(\"QR GO!\")\n    self.update()\n  def qrAction(self,qrcode):\n    if self.qrRead.get() == 1:\n      self.msg(\"Read:\"+qrcode)\n      cameraGUI.run(\"sudo flite -t '\"+qrcode+\"'\")\n    if self.qrStream.get() == 1:\n      self.msg(\"Stream:\"+qrcode)\n      cameraGUI.run(\"omxplayer '\"+qrcode+\"'\")\n    if self.qrRead.get() == 0 and self.qrStream.get() == 0:\n      TK.messagebox.showinfo(\"QR Code\",self.resultQR.get())\n#End\n```", "```py\nimport qrcodeGUI as GUI\n```", "```py\nproc=subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE)\n```", "```py\nsudo pip-3.2 install pyqrcode\n\n```", "```py\nsudo pip-3.2 install pypng\n\n```", "```py\n#!/usr/bin/python3\n#generateQRCodes.py\nimport pyqrcode\nvalid=False\nprint(\"QR-Code generator\")\nwhile(valid==False):\n    inputpages=input(\"How many pages?\")\n    try:\n      PAGES=int(inputpages)\n      valid=True\n    except ValueError:\n      print(\"Enter valid number.\")\n      pass\nprint(\"Creating QR-Codes for \"+str(PAGES)+\" pages:\")\nfor i in range(PAGES):\n  file=\"page%03d\"%(i+1)\n  qr_code = pyqrcode.create(file+\".mp3\")\n  qr_code.png(file+\".png\")\n  print(\"Generated QR-Code for \"+file)\nprint(\"Completed\")\n#End\n```", "```py\npython3 generateQRCodes.py\n\n```", "```py\n    sudo apt-get update\n    sudo apt-get upgrade\n    sudo rpi-update\n    ```", "```py\n    sudo reboot\n\n    ```", "```py\n    sudo apt-get install build-essential cmake pkg-config\n    sudo apt-get install python2.7-dev python3-dev\n    ```", "```py\n    sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev\n    sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev\n    sudo apt-get install libxvidcore-dev libx264-dev\n    sudo apt-get install libgtk2.0-dev\n\n    ```", "```py\n    sudo apt-get install python3-numpy\n    sudo apt-get install libatlas-base-dev gfortran\n\n    ```", "```py\n    cd ~\n    wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.0.0.zip\n    unzip opencv.zip\n    wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.0.0.zip\n    unzip opencv_contrib.zip\n    cd opencv-3.0.0\n    mkdir build\n    cd build\n\n    ```", "```py\n    cmake -D CMAKE_BUILD_TYPE=RELEASE \\\n     -D CMAKE_INSTALL_PREFIX=/usr/local \\\n     -D INSTALL_C_EXAMPLES=ON \\\n     -D INSTALL_PYTHON_EXAMPLES=ON \\\n     -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.0.0/modules \\\n     -D BUILD_EXAMPLES=ON ..\n\n    ```", "```py\nmake\n\n```", "```py\nmake -j4\n\n```", "```py\nsudo make install\n\n```", "```py\npython3\n\n```", "```py\nimport cv2\ncv2.__version__\n\n```", "```py\n#!/usr/bin/python3\n#openimage.py\nimport cv2\n\n# Load a color image in grayscale\nimg = cv2.imread('testimage.jpg',0)\ncv2.imshow('Frame',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\nraspistill -o testimage.jpg -w 640 -h 480\n\n```", "```py\npython3 openimage.py\n\n```", "```py\n#!/usr/bin/python3\n#opencv_display.py\nfrom picamera.array import PiRGBArray\nfrom picamera import PiCamera\nimport time\nimport cv2\n\nimport opencv_color_detect as PROCESS  \n\ndef show_images(images,text,MODE):          \n  # show the frame\n  cv2.putText(images[MODE], \"%s:%s\" %(MODE,text[MODE]), (10,20),\n              cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255), 2)\n  cv2.imshow(\"Frame\", images[MODE])\n\ndef begin_capture():\n  # initialize the camera and grab a reference to the raw camera capture\n  camera = PiCamera()\n  camera.resolution = (640, 480)\n  camera.framerate = 50\n  camera.hflip = True\n\n  rawCapture = PiRGBArray(camera, size=(640, 480))\n\n  # allow the camera to warmup\n  time.sleep(0.1)\n  print(\"Starting camera...\")\n  MODE=0\n\n  # capture frames from the camera\n  for frame in camera.capture_continuous(rawCapture, format=\"bgr\", use_video_port=True):\n    # capture any key presses\n    key = cv2.waitKey(1) & 0xFF\n\n\t# grab the raw NumPy array representing the image\n    images, text = PROCESS.process_image(frame.array,key)\n\n    #Change display mode or quit\n    if key == ord(\"m\"):\n      MODE=MODE%len(images)\n    elif key == ord(\"q\"):\n      print(\"Quit\")\n      break\n\n  #Display the output images\n    show_images(images,text,MODE)\n\n  # clear the stream in preparation for the next frame\n    rawCapture.truncate(0)\n\nbegin_capture()\n#End\n```", "```py\n#!/usr/bin/python3\n#opencv_color_detect.py\nimport cv2\nimport numpy as np\n\nBLUR=(5,5)\nthreshold=0\n#Set the BGR color thresholds\nTHRESH_TXT=[\"Blue\",\"Green\",\"Red\",\"Magenta\",\"Yellow\"]\nTHRESH_LOW=[[80,40,0],[40,80,0],[40,00,80],[80,0,80],[0,80,80]]\nTHRESH_HI=[[220,100,80],[100,220,80],[100,80,220],[220,80,220],[80,220,220]]\n\ndef process_image(raw_image,control):\n  global threshold\n  text=[]\n  images=[]\n\n  #Switch color threshold\n  if control == ord(\"c\"):\n    threshold=(threshold+1)%len(THRESH_LOW)\n  #Display contour and hierarchy details\n  elif control == ord(\"i\"):\n    print(\"Contour: %s\"%contours)\n    print(\"Hierarchy: %s\"%hierarchy)\n\n  #Keep a copy of the raw image\n  text.append(\"Raw Image %s\"%THRESH_TXT[threshold])\n  images.append(raw_image)\n\n  #Blur the raw image\n  text.append(\"with Blur...%s\"%THRESH_TXT[threshold])\n  images.append(cv2.blur(raw_image, BLUR))\n\n  #Set the color thresholds\n  lower = np.array(THRESH_LOW[threshold],dtype=\"uint8\")\n  upper = np.array(THRESH_HI[threshold], dtype=\"uint8\")\n\n  text.append(\"with Threshold...%s\"%THRESH_TXT[threshold])\n  images.append(cv2.inRange(images[-1], lower, upper))\n\n  #Find contours in the threshold image\n  text.append(\"with Contours...%s\"%THRESH_TXT[threshold])\n  images.append(images[-1].copy())\n  image, contours, hierarchy = cv2.findContours(images[-1],\n                                                cv2.RETR_LIST,\n                                                cv2.CHAIN_APPROX_SIMPLE)\n\n  #Display contour and hierarchy details\n  if control == ord(\"i\"):\n    print(\"Contour: %s\"%contours)\n    print(\"Hierarchy: %s\"%hierarchy)\n\n  #Find the contour with maximum area and store it as best_cnt\n  max_area = 0\n  best_cnt = 1\n  for cnt in contours:\n    area = cv2.contourArea(cnt)\n    if area > max_area:\n      max_area = area\n      best_cnt = cnt\n\n  #Find the centroid of the best_cnt and draw a circle there\n  M = cv2.moments(best_cnt)\n  cx,cy = int(M['m10']/M['m00']), int(M['m01']/M['m00'])\n\n  if max_area>0:\n    cv2.circle(raw_image,(cx,cy),8,(THRESH_HI[threshold]),-1)\n    cv2.circle(raw_image,(cx,cy),4,(THRESH_LOW[threshold]),-1)\n\n  return(images,text)\n#End\n```", "```py\npython3 opencv_display.py\n\n```", "```py\n#!/usr/bin/python3\n#opencv_motion_detect.py\nimport cv2\nimport numpy as np\n\nGAUSSIAN=(21,21)\n\nimageBG=None\ngray=True\n\nmovement=[]\nAVG=2\navgX=0\navgY=0\ncount=0\n\ndef process_image(raw_image,control):\n  global imageBG\n  global count,avgX,avgY,movement,gray\n\n  text=[]\n  images=[]\n  reset=False\n\n  #Toggle Gray and reset background\n  if control == ord(\"g\"):\n    if gray:\n      gray=not gray\n    reset=True\n    print(\"Toggle Gray\")\n  #Reset the background image\n  elif control == ord(\"r\"):\n    reset=True\n\n  #Clear movement record and reset background\n  if reset:\n    print(\"Reset Background\")\n    imageBG=None\n    movement=[]\n\n  #Keep a copy of the raw image\n  text.append(\"Raw Image\")\n  images.append(raw_image)\n\n  if gray:\n    raw_image=cv2.cvtColor(raw_image,cv2.COLOR_BGR2GRAY)\n\n  #Blur the raw image\n  text.append(\"with Gaussian Blur...\")\n  images.append(cv2.GaussianBlur(raw_image, GAUSSIAN))\n\n  #Initialise background\n  if imageBG is None:\n    imageBG=images[-1]\n\n  text.append(\"with image delta...\")  \n  images.append(cv2.absdiff(imageBG,images[-1]))\n\n  text.append(\"with threshold mask...\")                \n  images.append(cv2.threshold(images[-1], 25, 255,\n                             cv2.THRESH_BINARY)[1])\n\n  text.append(\"with dilation...\")                \n  images.append(cv2.dilate(images[-1],None, iterations=3))\n\n  #Find contours\n  if not gray:\n    #Require gray image to find contours\n    text.append(\"with dilation gray...\")\n    images.append(cv2.cvtColor(images[-1],cv2.COLOR_BGR2GRAY))\n  text.append(\"with contours...\")\n  images.append(images[-1].copy())\n  aimage, contours, hierarchy = cv2.findContours(images[-1],\n                                                 cv2.RETR_LIST,\n                                                 cv2.CHAIN_APPROX_SIMPLE)\n\n  #Display contour and hierarchy details\n  if control == ord(\"i\"):\n    print(\"Contour: %s\"%contours)\n    print(\"Hierarchy: %s\"%hierarchy)\n\n  #Determine the area of each of the contours\n  largest_area=0\n  found_contour=None\n  for cnt in contours:\n    area = cv2.contourArea(cnt)\n    #Find which one is largest\n    if area > largest_area:\n      largest_area=area\n      found_contour=cnt\n\n  if found_contour != None:\n    #Find the centre of the contour\n    M=cv2.moments(found_contour)\n    cx,cy=int(M['m10']/M['m00']),int(M['m01']/M['m00'])\n    #Calculate the average\n    if count<AVG:\n      avgX=(avgX+cx)/2\n      avgY=(avgY+cy)/2\n      count=count+1\n    else:\n      movement.append((int(avgX),int(avgY)))\n      avgX=cx\n      avgY=cy\n      count=0\n\n  #Display\n  if found_contour != None:\n    cv2.circle(images[0],(cx,cy),10,(255,255,255),-1)\n  if len(movement) > 1:\n    for i,j in enumerate(movement):\n      if i>1:\n        cv2.line(images[0],movement[i-1],movement[i],(255,255,255))\n\n  return(images,text)  \n#End\n```", "```py\nimport opencv_color_detect as PROCESS \n\n```", "```py\nimport opencv_motion_detect as PROCESS\n\n```", "```py\npython3 opencv_display.py\n\n```", "```py\n  text.append(\"with Low Blur...\")\n  images.append(cv2.blur(raw_image, (5,5))\n  text.append(\"with High Blur...\")\n  images.append(cv2.blur(raw_image, (30,30))\n```"]