- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Performance Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化
- en: With the help of the Odoo framework, you can develop large and complex applications.
    Good performance is key to the success of any project. In this chapter, we will
    explore the patterns and tools you need to optimize performance. You will also
    learn about the debugging techniques used to find the root cause of a performance
    issue.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo框架的帮助下，你可以开发大型且复杂的应用程序。良好的性能是任何项目成功的关键。在本章中，我们将探讨你需要用于优化性能的模式和工具。你还将了解用于找到性能问题根本原因的调试技术。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: The prefetching pattern for recordsets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录集的预取模式
- en: The in-memory cache – `ormcache`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存缓存 – `ormcache`
- en: Generating differently sized images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成不同大小的图像
- en: Accessing grouped data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问分组数据
- en: Creating or writing multiple records
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或写入多个记录
- en: Accessing records through database queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数据库查询访问记录
- en: Profiling Python code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Python代码
- en: The prefetching pattern for recordsets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录集的预取模式
- en: When you access data from a recordset, it makes a query in the database. If
    you have a recordset with multiple records, fetching records on it can make a
    system slow because of the multiple SQL queries. In this recipe, we will explore
    how you can use the prefetching pattern to solve this issue. By following the
    prefetching pattern, you can reduce the number of queries needed, which will improve
    performance and make your system faster.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从记录集中访问数据时，它会在数据库中执行一个查询。如果你有一个包含多个记录的记录集，对其上的记录进行检索可能会因为多个SQL查询而使系统变慢。在本食谱中，我们将探讨如何使用预取模式来解决这个问题。通过遵循预取模式，你可以减少所需的查询数量，这将提高性能并使你的系统更快。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Take a look at the following code; it is a normal `compute` method. In this
    method, `self` is a recordset of multiple records. When you iterate directly on
    the recordset, prefetching works perfectly:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码；这是一个正常的`compute`方法。在这个方法中，`self`是一个包含多个记录的记录集。当你直接在记录集上迭代时，预取将完美地工作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, in some cases, prefetching becomes more complex, such as when fetching
    data with the `browse` method. In the following example, we browse records one
    by one in the `for` loop. This will not use prefetching efficiently, and it will
    execute more queries than usual:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，预取变得更为复杂，例如使用`browse`方法获取数据。在下面的示例中，我们在`for`循环中逐个浏览记录。这将无法有效地使用预取，并且将执行比通常更多的查询：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By passing a list of IDs to the `browse` method, you can create a recordset
    of multiple records. If you perform operations on this recordset, prefetching
    works perfectly fine:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`browse`方法传递一个ID列表，你可以创建一个包含多个记录的记录集。如果你对这个记录集执行操作，预取将完美地工作：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This way, you will not lose the prefetching feature, and data will be fetched
    in a single SQL query.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将不会失去预取功能，并且数据将通过单个SQL查询进行获取。
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you work with multiple recordsets, prefetching helps reduce the number
    of SQL queries. It does this by fetching all of the data at once. Usually, prefetching
    works automatically in Odoo, but you lose this feature in certain circumstances,
    such as when you split records, as depicted in the following example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与多个记录集一起工作时，预取可以帮助减少SQL查询的数量。它是通过一次性获取所有数据来实现的。通常，在Odoo中预取是自动工作的，但在某些情况下，例如当你分割记录时，你会失去这个功能，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code given will split the recordset into parts, so you cannot
    take advantage of prefetching.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会将记录集分割成部分，因此你无法利用预取。
- en: Using prefetching correctly can significantly improve the performance of **Object-Relational
    Mapping** (**ORM**). Let’s explore how prefetching works under the hood.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用预取可以显著提高**对象关系映射**（**ORM**）的性能。让我们探索预取在底层是如何工作的。
- en: When you iterate on a recordset through a `for` loop and access the value of
    a field in the first iteration, the prefetching process starts its magic. Instead
    of fetching data for the current record in the iteration, prefetching will fetch
    the data for all of the records. The logic behind this is that if you access a
    field in a `for` loop, you are likely to fetch that data for the next record in
    the iteration as well. In the first iteration of the `for` loop, prefetching will
    fetch the data for all of the recordsets and keep it in the cache. In the next
    iteration of the `for` loop, data will be served from this cache, instead of making
    a new SQL query. This will reduce the query count from `O(n)` to `O(1)`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过`for`循环迭代记录集并访问第一次迭代的字段值时，预取过程开始发挥作用。预取不会为迭代中的当前记录获取数据，而是会获取所有记录的数据。背后的逻辑是，如果你在`for`循环中访问一个字段，你很可能还会在迭代中的下一个记录中获取该数据。在`for`循环的第一次迭代中，预取将获取所有记录集的数据并将其保存在缓存中。在`for`循环的下一个迭代中，数据将从这个缓存中提供，而不是执行新的SQL查询。这将把查询次数从`O(n)`减少到`O(1)`。
- en: 'Let’s suppose the recordset has 10 records. When you are in the first loop
    and access the `name` field of the record, it will fetch the data for all 10 records.
    This is not only the case for the `name` field; it will also fetch all the fields
    for those 10 records. In the subsequent `for` loop iterations, the data will be
    served from the cache. This will reduce the number of queries from 10 to 1:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设记录集有10条记录。当你处于第一个循环并访问记录的`name`字段时，它将获取所有10条记录的数据。这不仅适用于`name`字段；它还将获取这10条记录的所有字段。在随后的`for`循环迭代中，数据将从缓存中提供。这将把查询次数从10次减少到1次：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the prefetching will fetch the value of all of the fields (except
    the `*2many` fields), even if those fields are not used in the body of the `for`
    loop. This is because the extra columns only have a minor impact on performance
    compared to the extra queries for each column.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预取将获取所有字段的价值（除了`*2many`字段），即使这些字段在`for`循环的主体中没有被使用。这是因为额外的列与每个列的额外查询相比，对性能的影响较小。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sometimes, prefetched fields could reduce performance. In these cases, you
    can disable prefetching by passing `False` into the `prefetch_fields` context,
    as follows: `recordset.with_context(prefetch_fields=False)`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，预取字段可能会降低性能。在这些情况下，你可以通过将`False`传递给`prefetch_fields`上下文来禁用预取，如下所示：`recordset.with_context(prefetch_fields=False)`。
- en: The prefetch mechanism uses the environment cache to store and retrieve record
    values. This means that once the records are fetched from the database, all subsequent
    calls for fields will be served from the environment cache. You can access the
    environment cache using the `env.cache` attribute. To invalidate the cache, you
    can use the `invalidate_cache()` method of the environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 预取机制使用环境缓存来存储和检索记录值。这意味着一旦记录从数据库中获取，后续对字段的调用都将从环境缓存中提供。你可以使用`env.cache`属性来访问环境缓存。要使缓存失效，你可以使用环境的`invalidate_cache()`方法。
- en: There’s more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you split recordsets, the ORM will generate a new recordset with a new prefetch
    context. Performing operations on such recordsets will only prefetch the data
    for the respective records. If you want to prefetch all the records after `prefetch`,
    you can do this by passing the prefetch record IDs to the `with_prefetch()` method.
    In the following example, we split the recordset into two parts. Here, we passed
    a common prefetch context in both recordsets, so when you fetch the data from
    one of them, ORM will fetch the data for the other and put the data in the cache
    for future use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拆分记录集，ORM将生成一个新的记录集，并带有新的预取上下文。对这样的记录集执行操作将只预取相应记录的数据。如果你想在预取后预取所有记录，可以通过将预取记录ID传递给`with_prefetch()`方法来实现。在下面的示例中，我们将记录集拆分为两部分。在这里，我们在两个记录集中传递了共同的预取上下文，所以当你从其中一个中获取数据时，ORM将获取另一个的数据并将其保存在缓存中以供将来使用：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The prefetch context is not limited to splitting recordsets. You can also use
    the `with_prefetch()` method to have a common prefetch context between multiple
    recordsets. This means that when you fetch data from one record, it will fetch
    data for all other recordsets, too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 预取上下文不仅限于拆分记录集。你还可以使用`with_prefetch()`方法在多个记录集之间有一个共同的预取上下文。这意味着当你从一个记录中获取数据时，它也会获取其他所有记录集的数据。
- en: The in-memory cache – ormcache
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存缓存 – ormcache
- en: The Odoo framework provides the `ormcache` decorator to manage the in-memory
    cache. In this recipe, we will explore how you can manage the cache for your functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo框架提供了`ormcache`装饰器来管理内存缓存。在这个菜谱中，我们将探讨如何管理你函数的缓存。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The classes of this ORM cache are available at `/odoo/tools/cache.py`. In order
    to use these in any file, you will need to import them as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ORM缓存的类可以在`/odoo/tools/cache.py`中找到。为了在任何文件中使用这些类，你需要按照以下方式导入它们：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After importing the classes, you can use the ORM cache decorators. Odoo provides
    different types of in-memory cache decorators. We’ll take a look at each of these
    in the following subsections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 导入类后，你可以使用ORM缓存装饰器。Odoo提供了不同类型的内存缓存装饰器。在接下来的小节中，我们将逐一查看这些装饰器。
- en: ormcache
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ormcache
- en: 'This one is the simplest and most used cache decorator. You need to pass the
    parameter name upon which the method’s output depends. The following is an example
    method with the `ormcache` decorator:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单也是最常用的缓存装饰器。你需要传递一个参数名称，该参数名称决定了方法的输出。以下是一个带有`ormcache`装饰器的方法示例：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you call this method for the first time, it will be executed, and the result
    will be returned. `ormcache` will store this result based on the value of the
    `mode` parameter. When you call the method again with the same `mode` value, the
    result will be served from the cache without executing the actual method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次调用这个方法时，它将被执行，并返回结果。`ormcache`将根据`mode`参数的值存储这个结果。当你再次以相同的`mode`值调用该方法时，结果将从缓存中提供，而无需实际执行该方法。
- en: 'Sometimes, your method’s result depends on the environment attributes. In these
    cases, you can declare the method as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的方法的结果依赖于环境属性。在这些情况下，你可以这样声明方法：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method given in this example will store the cache based on the environment
    user and the value of the `mode` parameter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中给出的方法将根据环境用户和`mode`参数的值来存储缓存。
- en: ormcache_context
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ormcache_context
- en: 'This cache works similarly to `ormcache`, except that it depends on the parameters
    plus the value in the context. In this cache’s decorator, you need to pass the
    parameter name and a list of context keys. For example, if your method’s output
    depends on the `lang` and `website_id` keys in the context, you can use `ormcache_context`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓存的工作方式与`ormcache`类似，但它在参数的基础上还依赖于上下文中的值。在这个缓存的装饰器中，你需要传递参数名称和上下文键的列表。例如，如果你的方法输出依赖于上下文中的`lang`和`website_id`键，你可以使用`ormcache_context`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The cache in the preceding example will depend on the `mode` argument and the
    values of `context`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，这个缓存将依赖于`mode`参数和`context`的值。
- en: ormcache_multi
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ormcache_multi
- en: 'Some methods carry out an operation on multiple records or IDs. If you want
    to add a cache to these kinds of methods, you can use the `ormcache_multi` decorator.
    You need to pass the `multi` parameter, and during the method call, ORM will generate
    the cache keys by iterating on this parameter. In this method, you will need to
    return the result in the dictionary format with an element of the `multi` parameter
    as a key. Take a look at the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法对多个记录或ID执行操作。如果你想给这类方法添加缓存，你可以使用`ormcache_multi`装饰器。你需要传递`multi`参数，在方法调用期间，ORM将通过迭代这个参数来生成缓存键。在这个方法中，你需要以字典格式返回结果，其中`multi`参数的一个元素作为键。看看以下示例：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Suppose we called the preceding method with `[1,2,3]` as the IDs. The method
    will return a result in the `{1:... , 2:..., 3:... }` format. ORM will cache the
    result based on these keys. If you make another call with `[1,2,3,4,5]` as the
    IDs, your method will receive `[4, 5]` as the `ID` parameter, so the method will
    carry out the operations for the `4` and `5` IDs, and the rest of the result will
    be served from the cache.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用`[1,2,3]`作为ID调用前面的方法。该方法将以`{1:... , 2:..., 3:... }`的格式返回一个结果。ORM将根据这些键缓存结果。如果你再次调用该方法，并使用`[1,2,3,4,5]`作为ID，你的方法将接收到`[4,
    5]`作为`ID`参数，因此该方法将执行`4`和`5` ID的操作，其余的结果将从缓存中提供。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The ORM cache keeps the cache in the dictionary format (the cache lookup).
    The keys of this cache will be generated based on the signature of the decorated
    method, and the values will be the result. Put simply, when you call the method
    with the `x, y` parameters and the result of the method is `x+y`, the cache lookup
    will be `{(x, y): x+y}`. This means that the next time you call this method with
    the same parameters, the result will be served directly from this cache. This
    saves computation time and makes the response faster.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'ORM缓存以字典格式（缓存查找）保持缓存。此缓存的关键字将基于装饰方法的签名生成，值将是结果。简单来说，当你用`x, y`参数调用方法，且方法的结果是`x+y`时，缓存查找将是`{(x,
    y): x+y}`。这意味着下次你用相同的参数调用此方法时，结果将直接从缓存中提供。这节省了计算时间并使响应更快。'
- en: The ORM cache is an in-memory cache, so it is stored in RAM and occupies memory.
    Do not use `ormcache` to serve large data, such as images or files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ORM缓存是内存缓存，因此它存储在RAM中并占用内存。不要使用`ormcache`来服务大型数据，如图片或文件。
- en: Warning
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Methods using this decorator should never return a recordset. If they do, they
    will generate `psycopg2.OperationalError` because the underlying cursor of the
    recordset is closed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此装饰器的方法永远不应该返回一个记录集。如果它们这样做，将生成`psycopg2.OperationalError`，因为记录集的底层游标已关闭。
- en: 'You should use the ORM cache on pure functions. A pure function is a method
    that always returns the same result for the same arguments. The output of these
    methods only depends on the arguments, so they return the same result. If this
    is not the case, you need to manually clear the cache when you perform operations
    that make the cache’s state invalid. To clear the cache, call the `clear_caches()`
    method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在纯函数上使用ORM缓存。纯函数是一个总是对相同的参数返回相同结果的方法。这些方法的输出只依赖于参数，因此它们返回相同的结果。如果情况不是这样，当你执行使缓存状态无效的操作时，你需要手动清除缓存。要清除缓存，请调用`clear_caches()`方法：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you have cleared the cache, the next call to the method will execute the
    method and store the result in the cache, and all subsequent method calls with
    the same parameter will be served from the cache.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存后，下一次调用该方法将执行该方法并将结果存储在缓存中，所有后续具有相同参数的方法调用都将从缓存中提供服务。
- en: There’s more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The ORM cache is the `SIGUSR1` signal to the Odoo process:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ORM缓存是发送给Odoo进程的`SIGUSR1`信号：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `496` is the process ID. After executing the command, you will see the
    status of the ORM cache in the logs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`496`是进程ID。执行命令后，你将在日志中看到ORM缓存的状况：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The percentage in the cache is the hit-to-miss ratio. It’s the success ratio
    of the result being found in the cache. If the cache’s hit-to-miss ratio is too
    low, you should remove the ORM cache from the method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存中的百分比是命中-未命中比率。它是结果在缓存中找到的成功比率。如果缓存的命中-未命中比率太低，你应该从方法中移除ORM缓存。
- en: Generating images in different size
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成不同尺寸的图片
- en: Large images can be troublesome for any website. They increase the size of web
    pages and consequently make them slower as a result. This leads to bad SEO rankings
    and visitor loss. In this recipe, we will explore how you can create images of
    different sizes; by using the right images, you can reduce the web page size and
    improve the page loading time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大图片对任何网站都可能造成麻烦。它们增加了网页的大小，从而使得网页加载速度变慢。这会导致SEO排名下降和访客流失。在这个菜谱中，我们将探讨如何创建不同尺寸的图片；通过使用正确的图片，你可以减小网页大小并提高页面加载时间。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You will need to inherit `image.mixin` in your model. Here is how you can add
    `image.mixin` to your model:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的模型中继承`image.mixin`。以下是向你的模型添加`image.mixin`的方法：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The mixin will automatically add five new fields to the hostel student model
    to store images of different sizes. See the *How it works…* section to learn about
    all five fields.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模型将自动为宿舍学生模型添加五个新字段以存储不同尺寸的图片。请参阅*如何工作…*部分了解所有五个字段。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The `image.mixin` instance will automatically add five new binary fields to
    the model. Each field stores images with a different resolution. Here is a list
    of the fields and their resolutions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`image.mixin`实例将自动为模型添加五个新的二进制字段。每个字段存储具有不同分辨率的图片。以下是字段及其分辨率的列表：'
- en: '`image_1920`: 1,920x1,920'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_1920`: 1,920x1,920'
- en: '`image_1024`: 1,024x1,024'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_1024`: 1,024x1,024'
- en: '`image_512`: 512x1,512'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_512`: 512x1,512'
- en: '`image_256`: 256x256'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_256`: 256x256'
- en: '`image_128`: 128x128'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_128`: 128x128'
- en: 'Of all the fields given here, only `image_1920` is editable. The other image
    fields are read-only and update automatically when you change the `image_1920`
    field. So, in the backend form view of your model, you need to use the `image_1920`
    field to allow the user to upload images. However, by doing so, we load large
    `image_1920` images in the form view. However, there is a way to improve performance
    by using `image_1920` images in the form view but displaying smaller images. For
    instance, we can utilize the `image_1920` field but display an `image_128` field.
    To do this, you can use the following syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里给出的所有字段中，只有 `image_1920` 是可编辑的。其他图像字段是只读的，并在您更改 `image_1920` 字段时自动更新。因此，在您模型的表单视图后端，您需要使用
    `image_1920` 字段以允许用户上传图像。然而，这样做会在表单视图中加载大型的 `image_1920` 图像。但是，有一种方法可以通过在表单视图中使用
    `image_1920` 图像来提高性能，同时显示较小的图像。例如，我们可以利用 `image_1920` 字段，但显示 `image_128` 字段。为此，您可以使用以下语法：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once you have saved the image to the field, Odoo will automatically resize the
    image and store it in the respective field. The form view will display the converted
    `image_128`, as we use it as `preview_image`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将图像保存到字段中，Odoo 将自动调整图像大小并将其存储在相应的字段中。表单视图将显示转换后的 `image_128`，因为我们将其用作 `preview_image`。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `image.mixin` model is `AbstractModel`, so its table is not present in the
    database. You need to inherit it in your model in order to use it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`image.mixin` 模型是 `AbstractModel`，因此它的表不在数据库中。您需要在您的模型中继承它才能使用它。'
- en: With this `image.mixin`, you can store an image with a maximum resolution of
    1,920x1,920\. If you save an image with a resolution higher than 1,920x1,920,
    Odoo will reduce it to 1,920x1,920\. While doing so, Odoo will also preserve the
    resolution of the image, avoiding any distortion. As an example, if you upload
    an image with a 2,400x1,600 resolution, the `image_1920` field will have a resolution
    of 1,920x1,280.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 `image.mixin`，您可以存储最大分辨率为 1,920x1,920 的图像。如果您保存的图像分辨率高于 1,920x1,920，Odoo
    将将其减少到 1,920x1,920。在此过程中，Odoo 还将保留图像的分辨率，避免任何扭曲。例如，如果您上传分辨率为 2,400x1,600 的图像，`image_1920`
    字段将具有 1,920x1,280 的分辨率。
- en: There’s more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With `image.mixin`, you can get images with certain resolutions, but what if
    you want to use an image with another resolution? To do so, you can use a binary
    wrapper field image, as shown in the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `image.mixin`，您可以获取具有特定分辨率的图像，但您想使用具有其他分辨率的图像怎么办？为此，您可以使用二进制包装器字段图像，如下例所示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will create a new `image_1500` field, and storing the image will resize
    it to 1,500x1,500 resolution. Note that this is not part of `image.mixin`. It
    just reduces the image to 1,500x1,500, so you need to add this field in the form
    view; editing it will not make changes to the other image fields in `image.mixin`.
    If you want to link it with an existing `image.mixin` field, add the `related="image_1920"`
    attribute to the field definition.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 `image_1500` 字段，存储图像时将调整其分辨率为 1,500x1,500。请注意，这并不是 `image.mixin` 的一部分。它只是将图像减少到
    1,500x1,500，因此您需要在表单视图中添加此字段；编辑它不会更改 `image.mixin` 中的其他图像字段。如果您想将其与现有的 `image.mixin`
    字段链接，请将 `related="image_1920"` 属性添加到字段定义中。
- en: Accessing grouped data
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问分组数据
- en: When you want data for statistics, you often need it in a grouped form, such
    as a monthly sales report, or a report that shows sales per customer. It is time-consuming
    to search records and group them manually. In this recipe, we will explore how
    you can use the `read_group()` method to access grouped data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要统计数据时，您通常需要以分组的形式获取数据，例如月度销售报告，或按客户显示销售情况的报告。手动搜索记录并分组是耗时的工作。在这个菜谱中，我们将探讨您如何使用
    `read_group()` 方法来访问分组数据。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Perform the following steps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `read_group()` method is widely used for statistics and smart stat buttons.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_group()` 方法在统计和智能统计按钮中广泛使用。'
- en: 'Let’s assume that you want to show the number of sales orders on the partner
    form. This can be done by searching sales orders for a customer and then counting
    the length:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您想在合作伙伴表单上显示销售订单的数量。这可以通过搜索客户的销售订单然后计数长度来完成：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous example will work, but not optimally. When you display the `so_count`
    field on the tree view, it will fetch and filter sales orders for all the partners
    in a list. With this small amount of data, the `read_group()` method won›t make
    much difference, but as the amount of data grows, it could be a problem. To fix
    this issue, you can use the `read_group` method.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的示例将工作，但不是最优的。当您在树视图中显示 `so_count` 字段时，它将获取并过滤列表中所有合作伙伴的销售订单。对于这么少量的数据，`read_group()`
    方法不会带来太大的差异，但随着数据量的增长，可能会成为问题。为了解决这个问题，您可以使用 `read_group` 方法。
- en: 'The following example will do the same as the preceding one, but it only consumes
    one SQL query, even for large datasets:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例将执行与上一个示例相同的功能，但对于大量数据集，它只消耗一个 SQL 查询：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code snippet is optimized, as it obtains the sales order count
    directly via SQL’s `GROUP` `BY` feature.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段已经优化，因为它直接通过 SQL 的 `GROUP BY` 功能获取销售订单的数量。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `read_group()` method internally uses the `GROUP BY` feature of SQL. This
    makes the `read_group` method faster, even if you have large datasets. Internally,
    the Odoo web client uses this method in the charts and the grouped tree view.
    You can tweak the behavior of the `read_group` method by using different arguments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_group()` 方法在内部使用 SQL 的 `GROUP BY` 功能。这使得 `read_group` 方法即使在拥有大量数据集的情况下也能更快地执行。内部，Odoo
    网页客户端在图表和分组树视图中使用此方法。您可以通过使用不同的参数来调整 `read_group` 方法的行为。'
- en: 'Let’s explore the signature of the `read_group` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `read_group` 方法的签名：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The different parameters available for the `read_group` method are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 `read_group` 方法的不同参数如下：
- en: '`domain`: This is used to filter records. This will be the search criteria
    for the `read_group` method.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`：此参数用于过滤记录。这将作为 `read_group` 方法的搜索条件。'
- en: '`fields`: This is a list of the fields to fetch with the grouping. Note that
    the fields mentioned here should be in the `groupby` parameter, unless you use
    some aggregate functions. The `read_group` method supports the SQL aggregate functions.
    Let›s say you want to get the average order amount per customer. If so, you can
    use `read_group` as follows:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`：这是一个要分组获取的字段列表。请注意，这里提到的字段应包含在 `groupby` 参数中，除非您使用某些聚合函数。`read_group`
    方法支持 SQL 聚合函数。假设您想获取每个客户的平均订单金额。如果是这样，您可以使用以下 `read_group`：'
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to access the same field twice but with a different aggregate function,
    the syntax is a little different. You need to pass the field name as `alias:agg(field_name)`.
    This example will give you the total and average number of orders per customer:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想访问同一字段两次但使用不同的聚合函数，语法略有不同。您需要将字段名作为 `alias:agg(field_name)` 传递。此示例将为您提供每个客户的订单总数和平均数：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`groupby`: This parameter will be a list of fields by which the records are
    grouped. It lets you group records based on multiple fields. To do this, you will
    need to pass a list of fields. For example, if you want to group the sales orders
    by customer and order state, you can pass `[''partner_id '', ''state'']` in this
    parameter.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby`：此参数将是一个字段列表，记录将根据这些字段进行分组。它允许您根据多个字段对记录进行分组。为此，您需要传递一个字段列表。例如，如果您想按客户和订单状态对销售订单进行分组，您可以在该参数中传递
    `[''partner_id'', ''state'']`。'
- en: '`offset`: This parameter is used for pagination. If you want to skip a few
    records, you can use this parameter.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`：此参数用于分页。如果您想跳过一些记录，可以使用此参数。'
- en: '`limit`: This parameter is used for pagination; it indicates the maximum number
    of records to fetch.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`：此参数用于分页；它表示要获取的最大记录数。'
- en: '`lazy`: This parameter accepts Boolean values. By default, its value is `True`.
    If this parameter is `True`, the results are grouped only by the first field in
    the `groupby` parameter. You will get the remaining `groupby` parameters and the
    domain in the `__context` and `__domain` keys in the result. If the value of this
    parameter is set to `False`, it will group the data by all fields in the `groupby`
    parameter.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy`：此参数接受布尔值。默认情况下，其值为 `True`。如果此参数为 `True`，则结果仅按 `groupby` 参数中的第一个字段进行分组。您将在结果的
    `__context` 和 `__domain` 键中获取剩余的 `groupby` 参数和域。如果此参数的值设置为 `False`，则将按 `groupby`
    参数中的所有字段对数据进行分组。'
- en: There’s more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Grouping by date fields can be complicated because it is possible to group
    records based on days, weeks, quarters, months, or years. You can change the grouping
    behavior of the date field by passing `groupby_function` after `:` in the `groupby`
    parameter. If you want to group the monthly total of the sales orders, you can
    use the `read_group` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按日期字段分组可能很复杂，因为可以根据天、周、季度、月或年对记录进行分组。你可以通过在 `groupby` 参数中的 `:` 后传递 `groupby_function`
    来更改日期字段的分组行为。如果你想按月分组销售订单的总数，你可以使用 `read_group` 方法：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The possible options for date grouping are `day`, `week`, `month`, `quarter`,
    and `year`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 日期分组的可能选项有 `day`、`week`、`month`、`quarter` 和 `year`。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Refer to the documentation if you want to learn more about PostgreSQL aggregate
    functions: [https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 PostgreSQL 聚合函数的信息，请参阅文档：[https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html)。
- en: Creating or writing multiple records
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建或写入多个记录
- en: If you are new to Odoo development, you might execute multiple queries to write
    or create multiple records. In this recipe, we will look at how to create and
    write records in batches.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触 Odoo 开发，你可能会执行多个查询来写入或创建多个记录。在本配方中，我们将探讨如何批量创建和写入记录。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Creating multiple records and writing on multiple records work differently under
    the hood. Let’s see each of these records one by one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，创建多个记录和在多个记录上写入操作的工作方式不同。让我们逐一查看这些记录。
- en: Creating multiple records
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建多个记录
- en: 'Odoo supports creating records in batches. If you are creating a single record,
    simply pass a dictionary with the field values. To create records in a batch,
    you just need to pass a list of these dictionaries instead of a single dictionary.
    The following example creates three room records in a single `create` call:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 支持批量创建记录。如果你正在创建单个记录，只需传递一个包含字段值的字典。要批量创建记录，你只需传递这些字典的列表而不是单个字典。以下示例在单个
    `create` 调用中创建三个房间记录：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code snippet will create the records for three new books.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将创建三本新书的记录。
- en: Writing on multiple records
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个记录上写入
- en: When working with multiple versions of Odoo, it’s important to understand how
    the write method behaves. In this case, it adopts a delayed approach for updates,
    meaning it doesn’t immediately write data to the database. Instead, Odoo only
    writes the data to the database when necessary or when the `flush()` method is
    called.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当与多个版本的 Odoo 一起工作时，了解写入方法的行为方式很重要。在这种情况下，它采用延迟更新的方法，这意味着它不会立即将数据写入数据库。相反，Odoo
    只在必要时或当调用 `flush()` 方法时将数据写入数据库。
- en: 'Here are two examples of the `write` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `write` 方法的两个示例：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are using Odoo v13 or above, then there will not be any issues regarding
    performance. However, if you are using an older version, the second example will
    be much faster than the first one because the first example will execute a SQL
    query in each iteration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Odoo v13 或更高版本，那么将不会有任何关于性能的问题。然而，如果你使用较旧版本，第二个示例将比第一个示例快得多，因为第一个示例将在每个迭代中执行一个
    SQL 查询。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to create multiple records in a batch, you need to pass value dictionaries
    in the form of a list to create new records. This will automatically manage batch-creating
    the records. When you create records in a batch, doing so internally will insert
    a query for each record. This means that creating records in a batch is not done
    in a single query. However, this doesn’t mean that creating records in batches
    does not improve performance. The performance gain is achieved through batch-calculating
    computing fields.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了批量创建多个记录，你需要以列表的形式传递包含值的字典来创建新记录。这将自动管理批量创建记录。当你批量创建记录时，内部操作将为每个记录插入一个查询。这意味着批量创建记录不是在一个查询中完成的。然而，这并不意味着批量创建记录不会提高性能。性能的提升是通过批量计算计算字段实现的。
- en: 'Things work differently for the `write` method. Most things are handled automatically
    by the framework. For instance, if you write the same data on all records, the
    database will be updated with only one `UPDATE` query. The framework will even
    handle it if you update the same record again and again in the same transaction,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `write` 方法，操作方式不同。大多数事情都由框架自动处理。例如，如果你在所有记录上写入相同的数据，数据库将只通过一个 `UPDATE` 查询进行更新。如果框架在同一个事务中反复更新相同的记录，它也会处理这种情况，如下所示：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous code snippet, only one query will be executed for `write`, with
    the final values of `name=Administrator` and `email=admin-2@example.com`. This
    does not have a bad impact on performance, as the assigned values are in the cache
    and written later in a single query.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，对于`write`操作，只会执行一个查询，最终`name=Administrator`和`email=admin-2@example.com`的值。这不会对性能产生负面影响，因为分配的值在缓存中，并且稍后在一个查询中写入。
- en: 'Things are different if you use the `flush()` method in between, as shown in
    the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这之间使用`flush()`方法，情况会有所不同，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `flush()` method updates the values from the cache to the database. So,
    in the previous example, two `UPDATE` queries will be executed – one with data
    before the flush and another with data after the flush.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`flush()`方法将缓存中的值更新到数据库。因此，在前面的例子中，将执行两个`UPDATE`查询——一个是在刷新之前的数据，另一个是在刷新之后的数据。'
- en: There’s more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you are using an older version, then writing a single value will execute
    the `UPDATE` query immediately. Check the following examples to explore the correct
    usage of the `write` operation for an older version of Odoo:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧版本，那么写入单个值将立即执行`UPDATE`查询。请查看以下示例以探索旧版Odoo中`write`操作的正确用法：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, in the first example, we have two `UPDATE` queries, while the second example
    will only take one `UPDATE` query.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在第一个例子中，我们有两次`UPDATE`查询，而第二个例子将只执行一次`UPDATE`查询。
- en: Accessing records through database queries
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过数据库查询访问记录
- en: Odoo ORM has limited methods, and sometimes, it is difficult to fetch certain
    data from ORM. In these cases, you can fetch data in the desired format, and you
    need to perform an operation on the data to get a certain result. Due to this,
    it becomes slower. To handle these special cases, you can execute SQL queries
    in the database. In this recipe, we will explore how you can run SQL queries from
    Odoo.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo ORM方法有限，有时从ORM中获取某些数据可能很困难。在这些情况下，你可以以所需格式获取数据，并需要对数据进行操作以获得特定结果。因此，这会变慢。为了处理这些特殊情况，你可以在数据库中执行SQL查询。在本食谱中，我们将探讨如何从Odoo运行SQL查询。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can perform database queries using the `self._cr.execute` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`self._cr.execute`方法执行数据库查询：
- en: 'Add the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is the output:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: self.flush()
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.flush()
- en: self._cr.execute("SELECT id, name, room_no, floor_no  FROM hostel_room WHERE
    name ilike %s", ('%Room A-%',))
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self._cr.execute("SELECT id, name, room_no, floor_no FROM hostel_room WHERE
    name ilike %s", ('%Room A-%',))
- en: data = self._cr.dictfetchall()
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = self._cr.dictfetchall()
- en: print(data)
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(data)
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[{''id'': 4, ''name'': ''Room A-101'', ''room_no'': 101, ''floor_no'': 1},
    {''id'': 5, ''name'': ''Room A-103'', ''room_no'': 103, ''floor_no'': 1}, {''id'':
    6, ''name'': ''Room A-201'', ''room_no'': 201, ''floor_no'': 2}]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[{''id'': 4, ''name'': ''Room A-101'', ''room_no'': 101, ''floor_no'': 1},
    {''id'': 5, ''name'': ''Room A-103'', ''room_no'': 103, ''floor_no'': 1}, {''id'':
    6, ''name'': ''Room A-201'', ''room_no'': 201, ''floor_no'': 2}]'
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you want to fetch only a single record, you can use the `fetchone()` and
    `dictfetchone()` methods. These methods work like `fetchall()` and `dictfetchall()`,
    but they only return a single record, and you need to call the `fetchone()` and
    `dictfetchone()` methods multiple times if you want to fetch multiple records.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取单个记录，可以使用`fetchone()`和`dictfetchone()`方法。这些方法与`fetchall()`和`dictfetchall()`类似，但它们只返回单个记录，如果你想获取多个记录，需要多次调用`fetchone()`和`dictfetchone()`方法。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two ways to access the database cursor from the recordset – one is
    from the recordset itself, such as `self._cr`, and the other is from the environment
    (in particular, `self.env.cr`). This cursor is used to execute database queries.
    In the preceding example, we saw how you can fetch data through raw queries. The
    table name is the name of the model after replacing `.` with `_`, so the `hostel.room`
    model becomes `hostel_room`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式从记录集访问数据库游标——一种是从记录集本身，例如`self._cr`，另一种是从环境（特别是`self.env.cr`）。这个游标用于执行数据库查询。在前面的例子中，我们看到了如何通过原始查询获取数据。表名是模型名称，将`.`替换为`_`后的名称，因此`hostel.room`模型变为`hostel_room`。
- en: 'Note that we used `self.flush()` before executing a query. The reason behind
    this is that Odoo uses the cache excessively, and the database might not have
    the correct values. `self.flush()` will push all the delayed updates to the database
    and conduct all the dependent computations as well, and you will then get correct
    values from the database. The `flush()` method also supports a few parameters
    that help you control what is flushed in the database. The parameters are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The `fname` parameter needs a list of fields that you want to flush to the database
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `records` parameter needs a recordset, and it is used if you want to flush
    certain records only
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are executing `INSERT` or `UPDATE` queries, you will also need to execute
    `flush()` after executing the query because the ORM might not be aware of the
    change you made, and it might have cached records.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to consider a few things before you execute raw queries. Only use
    raw queries when you have no other choice. By executing raw queries, you bypass
    the ORM layers. Therefore, you also bypass security rules and the ORM’s performance
    advantages. Sometimes, wrongly built queries can introduce SQL injection vulnerabilities.
    Consider the following example, in which the queries could allow an attacker to
    perform SQL injection:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Don’t use the string format function either; it will also allow an attacker
    to perform SQL injection. Using SQL queries makes your code harder to read and
    understand for other developers, so avoid using them wherever possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: A lot of Odoo developers believe that executing SQL queries makes operations
    faster, as it bypasses the ORM layer. This is not completely true, however; it
    depends on the use case. In most operations, ORM performs better and faster than
    `RAW` queries because data is served from the recordset cache.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations made in one transaction are only committed at the end of it. If an
    error occurs in the ORM, the transaction is rolled back. If you have made an `INSERT`
    or `UPDATE` query and you want to make it permanent, you can use `self._cr.commit()`
    to commit the changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that using `commit()` can be dangerous because it can put records in an
    inconsistent state. An error in the ORM can cause incomplete rollbacks, so only
    use `commit()` if you are completely sure of what you›re doing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `commit()` method, then there›s no need to use `flush()` afterward.
    The `commit()` method flushes the environment internally.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you will be unable to pinpoint the cause of an issue. This is especially
    true of performance issues. Odoo provides some built-in profiling tools that help
    you find the real cause of an issue.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Profiling is about analyzing the execution of a program and measuring aggregated
    data. These data can be the elapsed time for each function, the executed SQL queries,
    and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: While profiling does not improve the performance of a program by itself, it
    can prove very helpful in finding performance issues and identifying which part
    of the program is responsible for them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Code profiling in Odoo can help you identify performance and optimize your code.
    It is a technique used to analyze the code execution time, complexity of the program,
    and memory usage of an application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: By using profiling techniques in Odoo, you can improve the overall performance
    and user experience of your application, making it faster and more efficient.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the profiler
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The profiler can either be enabled from the user interface, which is the easiest
    way to do so but only allows you to profile web requests, or from Python code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Enable developer mode.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The profiler must be enabled globally on the database. This can be done in
    two ways:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer mode tools, and then toggle the **Enable profiling** button.
    A wizard suggests a set of expiry times for the profiling. Click on **Enable profiling**
    to enable the profiler globally.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 21.1 – Enabling Profiling](img/B20997_21_01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 21.1 – Enabling Profiling
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.2 – Disabling profiling](img/B20997_21_02.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Figure 21.2 – Disabling profiling
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Settings** | **General Settings** | **Performance** and set the desired
    time for the field Enable profiling field.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the results
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To browse the profiling results, make sure that the profiler is enabled globally
    on the database, then open the developer mode tools, and click on the button in
    the top-right corner of the profiling section. A list view of the `ir.profile`
    records grouped by profiling session will open.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_03.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Each record has a clickable link that opens the speedscope results in a new
    tab.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_04.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Speedscope falls out of the scope of this documentation, but there are a lot
    of tools to try out – search, highlight of similar frames, zoom on frame, timeline,
    left heavy, sandwich view, and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the profiling options that were activated, Odoo generates different
    view modes that you can access from the top menu.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_05.jpg)![](img/B20997_21_06.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '**Combined**: The **Combined** view displays all of the SQL queries and traces
    that have been integrated together.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combined no context**: The **Combined no context** view produces the same
    results but disregards the stored execution context, performance/profiling/enable>.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sql (no gap)**: The **sql (no gap)** view displays all SQL queries as if
    they were done sequentially, without any Python logic. This is solely beneficial
    for SQL optimization.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sql (density)**: Only the SQL queries are displayed in the **sql (no density)**
    view, with space between them. This can help you discover areas where numerous
    tiny queries could be batch-processed and determine whether the issue is with
    the Python or SQL code.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frames**: Only the periodic collector’s results are displayed in the **frames**
    view.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Despite the profiler’s lightweight design, it can still affect performance,
    particularly when utilizing the `Sync` collector. Remember that when you examine
    the speedscope data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Collectors
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every collector has a unique format and method to gather profiling data. Through
    their specific toggle button in the developer mode tools, or from Python code
    using their key or class, each can be independently enabled from the user interface.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently four collectors available in Odoo:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLCollector`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PeriodicCollector`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QwebCollector`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyncCollector`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLCollector
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All SQL queries made to the database in the current thread (for all cursors)
    are saved by the `SQL` collector, together with the stack trace. Using the collector
    on a large number of tiny queries could affect execution time and other profilers,
    since the overhead of the collector is added to the thread that is examined for
    each query.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging query counts and adding data to the `Periodic` collector in the combined
    speedscope view are two particularly helpful uses for it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Periodic collector
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This collector runs in a separate thread and saves the stack trace of the analyzed
    thread at every interval. The interval (by default, 10 ms) can be defined through
    the **Interval** option in the user interface or the interval parameter in Python
    code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Memory problems will arise when profiling lengthy queries if the interval is
    set extremely low. The interval will lose information on brief function executions
    if it is set extremely high.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its distinct thread, it should have relatively little effect on
    execution time, making it one of the finest ways to assess performance:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Qweb collector
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Python execution time and queries for each directive are reduced by this
    collector. With the SQL collector, the overhead may be significant when a large
    number of tiny instructions are executed. In terms of data collected, the results
    differ from those of other collectors, and a custom widget can be used to examine
    them from the `ir.profile` form view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'It is most helpful when trying to maximize views:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Sync collector
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Performance is significantly impacted by this collector, since it operates on
    a single thread and saves the stack for each function call and return.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging and comprehending intricate flows, as well as tracking their execution
    within the code, can be helpful. However, due to the significant overhead, performance
    analysis is not advised to use it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Performance pitfalls
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful with randomness. Multiple executions may lead to different results
    – for example , a garbage collector being triggered during execution.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful with blocking calls. In some cases, an external `c_call` may take
    some time before releasing the GIL, thus leading to unexpected long frames with
    the Periodic collector. This should be detected by the profiler and given a warning.
    It is possible to trigger the profiler manually before such calls if needed.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay attention to the cache. Profiling before the view/assets/… are in a cache
    can lead to different results.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意缓存。在视图/资源/...进入缓存之前进行分析可能会导致不同的结果。
- en: Be aware of the profiler’s overhead. The SQL collector’s overhead can be important
    when many small queries are executed. Profiling is practical to spot a problem,
    but you may want to disable the profiler to measure a code change’s real impact.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意分析器的开销。当执行许多小查询时，SQL收集器的开销可能很重要。分析是发现问题的实用方法，但你可能希望禁用分析器来测量代码更改的实际影响。
- en: Profiling results can be memory-intensive. In some cases (e.g., profiling an
    install or a long request), you can reach the memory limit, especially when rendering
    the speedscope results, which can lead to an HTTP 500 error. In this case, you
    may need to start the server with a higher memory limit – `--``limit-memory-hard
    $((8*1024**3)).`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析结果可能占用大量内存。在某些情况下（例如，分析安装或长时间请求），你可能会达到内存限制，尤其是在渲染speedscope结果时，这可能导致HTTP
    500错误。在这种情况下，你可能需要以更高的内存限制启动服务器 - `--limit-memory-hard $((8*1024**3)).`
