- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of the Odoo framework, you can develop large and complex applications.
    Good performance is key to the success of any project. In this chapter, we will
    explore the patterns and tools you need to optimize performance. You will also
    learn about the debugging techniques used to find the root cause of a performance
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The prefetching pattern for recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The in-memory cache – `ormcache`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating differently sized images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing grouped data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating or writing multiple records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing records through database queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefetching pattern for recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you access data from a recordset, it makes a query in the database. If
    you have a recordset with multiple records, fetching records on it can make a
    system slow because of the multiple SQL queries. In this recipe, we will explore
    how you can use the prefetching pattern to solve this issue. By following the
    prefetching pattern, you can reduce the number of queries needed, which will improve
    performance and make your system faster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following code; it is a normal `compute` method. In this
    method, `self` is a recordset of multiple records. When you iterate directly on
    the recordset, prefetching works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in some cases, prefetching becomes more complex, such as when fetching
    data with the `browse` method. In the following example, we browse records one
    by one in the `for` loop. This will not use prefetching efficiently, and it will
    execute more queries than usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing a list of IDs to the `browse` method, you can create a recordset
    of multiple records. If you perform operations on this recordset, prefetching
    works perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This way, you will not lose the prefetching feature, and data will be fetched
    in a single SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you work with multiple recordsets, prefetching helps reduce the number
    of SQL queries. It does this by fetching all of the data at once. Usually, prefetching
    works automatically in Odoo, but you lose this feature in certain circumstances,
    such as when you split records, as depicted in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code given will split the recordset into parts, so you cannot
    take advantage of prefetching.
  prefs: []
  type: TYPE_NORMAL
- en: Using prefetching correctly can significantly improve the performance of **Object-Relational
    Mapping** (**ORM**). Let’s explore how prefetching works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: When you iterate on a recordset through a `for` loop and access the value of
    a field in the first iteration, the prefetching process starts its magic. Instead
    of fetching data for the current record in the iteration, prefetching will fetch
    the data for all of the records. The logic behind this is that if you access a
    field in a `for` loop, you are likely to fetch that data for the next record in
    the iteration as well. In the first iteration of the `for` loop, prefetching will
    fetch the data for all of the recordsets and keep it in the cache. In the next
    iteration of the `for` loop, data will be served from this cache, instead of making
    a new SQL query. This will reduce the query count from `O(n)` to `O(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose the recordset has 10 records. When you are in the first loop
    and access the `name` field of the record, it will fetch the data for all 10 records.
    This is not only the case for the `name` field; it will also fetch all the fields
    for those 10 records. In the subsequent `for` loop iterations, the data will be
    served from the cache. This will reduce the number of queries from 10 to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the prefetching will fetch the value of all of the fields (except
    the `*2many` fields), even if those fields are not used in the body of the `for`
    loop. This is because the extra columns only have a minor impact on performance
    compared to the extra queries for each column.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, prefetched fields could reduce performance. In these cases, you
    can disable prefetching by passing `False` into the `prefetch_fields` context,
    as follows: `recordset.with_context(prefetch_fields=False)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The prefetch mechanism uses the environment cache to store and retrieve record
    values. This means that once the records are fetched from the database, all subsequent
    calls for fields will be served from the environment cache. You can access the
    environment cache using the `env.cache` attribute. To invalidate the cache, you
    can use the `invalidate_cache()` method of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you split recordsets, the ORM will generate a new recordset with a new prefetch
    context. Performing operations on such recordsets will only prefetch the data
    for the respective records. If you want to prefetch all the records after `prefetch`,
    you can do this by passing the prefetch record IDs to the `with_prefetch()` method.
    In the following example, we split the recordset into two parts. Here, we passed
    a common prefetch context in both recordsets, so when you fetch the data from
    one of them, ORM will fetch the data for the other and put the data in the cache
    for future use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The prefetch context is not limited to splitting recordsets. You can also use
    the `with_prefetch()` method to have a common prefetch context between multiple
    recordsets. This means that when you fetch data from one record, it will fetch
    data for all other recordsets, too.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory cache – ormcache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Odoo framework provides the `ormcache` decorator to manage the in-memory
    cache. In this recipe, we will explore how you can manage the cache for your functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classes of this ORM cache are available at `/odoo/tools/cache.py`. In order
    to use these in any file, you will need to import them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After importing the classes, you can use the ORM cache decorators. Odoo provides
    different types of in-memory cache decorators. We’ll take a look at each of these
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: ormcache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one is the simplest and most used cache decorator. You need to pass the
    parameter name upon which the method’s output depends. The following is an example
    method with the `ormcache` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you call this method for the first time, it will be executed, and the result
    will be returned. `ormcache` will store this result based on the value of the
    `mode` parameter. When you call the method again with the same `mode` value, the
    result will be served from the cache without executing the actual method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, your method’s result depends on the environment attributes. In these
    cases, you can declare the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The method given in this example will store the cache based on the environment
    user and the value of the `mode` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: ormcache_context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This cache works similarly to `ormcache`, except that it depends on the parameters
    plus the value in the context. In this cache’s decorator, you need to pass the
    parameter name and a list of context keys. For example, if your method’s output
    depends on the `lang` and `website_id` keys in the context, you can use `ormcache_context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The cache in the preceding example will depend on the `mode` argument and the
    values of `context`.
  prefs: []
  type: TYPE_NORMAL
- en: ormcache_multi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some methods carry out an operation on multiple records or IDs. If you want
    to add a cache to these kinds of methods, you can use the `ormcache_multi` decorator.
    You need to pass the `multi` parameter, and during the method call, ORM will generate
    the cache keys by iterating on this parameter. In this method, you will need to
    return the result in the dictionary format with an element of the `multi` parameter
    as a key. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we called the preceding method with `[1,2,3]` as the IDs. The method
    will return a result in the `{1:... , 2:..., 3:... }` format. ORM will cache the
    result based on these keys. If you make another call with `[1,2,3,4,5]` as the
    IDs, your method will receive `[4, 5]` as the `ID` parameter, so the method will
    carry out the operations for the `4` and `5` IDs, and the rest of the result will
    be served from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM cache keeps the cache in the dictionary format (the cache lookup).
    The keys of this cache will be generated based on the signature of the decorated
    method, and the values will be the result. Put simply, when you call the method
    with the `x, y` parameters and the result of the method is `x+y`, the cache lookup
    will be `{(x, y): x+y}`. This means that the next time you call this method with
    the same parameters, the result will be served directly from this cache. This
    saves computation time and makes the response faster.'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM cache is an in-memory cache, so it is stored in RAM and occupies memory.
    Do not use `ormcache` to serve large data, such as images or files.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Methods using this decorator should never return a recordset. If they do, they
    will generate `psycopg2.OperationalError` because the underlying cursor of the
    recordset is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use the ORM cache on pure functions. A pure function is a method
    that always returns the same result for the same arguments. The output of these
    methods only depends on the arguments, so they return the same result. If this
    is not the case, you need to manually clear the cache when you perform operations
    that make the cache’s state invalid. To clear the cache, call the `clear_caches()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once you have cleared the cache, the next call to the method will execute the
    method and store the result in the cache, and all subsequent method calls with
    the same parameter will be served from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM cache is the `SIGUSR1` signal to the Odoo process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `496` is the process ID. After executing the command, you will see the
    status of the ORM cache in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The percentage in the cache is the hit-to-miss ratio. It’s the success ratio
    of the result being found in the cache. If the cache’s hit-to-miss ratio is too
    low, you should remove the ORM cache from the method.
  prefs: []
  type: TYPE_NORMAL
- en: Generating images in different size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large images can be troublesome for any website. They increase the size of web
    pages and consequently make them slower as a result. This leads to bad SEO rankings
    and visitor loss. In this recipe, we will explore how you can create images of
    different sizes; by using the right images, you can reduce the web page size and
    improve the page loading time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to inherit `image.mixin` in your model. Here is how you can add
    `image.mixin` to your model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The mixin will automatically add five new fields to the hostel student model
    to store images of different sizes. See the *How it works…* section to learn about
    all five fields.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `image.mixin` instance will automatically add five new binary fields to
    the model. Each field stores images with a different resolution. Here is a list
    of the fields and their resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image_1920`: 1,920x1,920'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_1024`: 1,024x1,024'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_512`: 512x1,512'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_256`: 256x256'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_128`: 128x128'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of all the fields given here, only `image_1920` is editable. The other image
    fields are read-only and update automatically when you change the `image_1920`
    field. So, in the backend form view of your model, you need to use the `image_1920`
    field to allow the user to upload images. However, by doing so, we load large
    `image_1920` images in the form view. However, there is a way to improve performance
    by using `image_1920` images in the form view but displaying smaller images. For
    instance, we can utilize the `image_1920` field but display an `image_128` field.
    To do this, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once you have saved the image to the field, Odoo will automatically resize the
    image and store it in the respective field. The form view will display the converted
    `image_128`, as we use it as `preview_image`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `image.mixin` model is `AbstractModel`, so its table is not present in the
    database. You need to inherit it in your model in order to use it.
  prefs: []
  type: TYPE_NORMAL
- en: With this `image.mixin`, you can store an image with a maximum resolution of
    1,920x1,920\. If you save an image with a resolution higher than 1,920x1,920,
    Odoo will reduce it to 1,920x1,920\. While doing so, Odoo will also preserve the
    resolution of the image, avoiding any distortion. As an example, if you upload
    an image with a 2,400x1,600 resolution, the `image_1920` field will have a resolution
    of 1,920x1,280.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `image.mixin`, you can get images with certain resolutions, but what if
    you want to use an image with another resolution? To do so, you can use a binary
    wrapper field image, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new `image_1500` field, and storing the image will resize
    it to 1,500x1,500 resolution. Note that this is not part of `image.mixin`. It
    just reduces the image to 1,500x1,500, so you need to add this field in the form
    view; editing it will not make changes to the other image fields in `image.mixin`.
    If you want to link it with an existing `image.mixin` field, add the `related="image_1920"`
    attribute to the field definition.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing grouped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want data for statistics, you often need it in a grouped form, such
    as a monthly sales report, or a report that shows sales per customer. It is time-consuming
    to search records and group them manually. In this recipe, we will explore how
    you can use the `read_group()` method to access grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perform the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `read_group()` method is widely used for statistics and smart stat buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that you want to show the number of sales orders on the partner
    form. This can be done by searching sales orders for a customer and then counting
    the length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous example will work, but not optimally. When you display the `so_count`
    field on the tree view, it will fetch and filter sales orders for all the partners
    in a list. With this small amount of data, the `read_group()` method won›t make
    much difference, but as the amount of data grows, it could be a problem. To fix
    this issue, you can use the `read_group` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following example will do the same as the preceding one, but it only consumes
    one SQL query, even for large datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous code snippet is optimized, as it obtains the sales order count
    directly via SQL’s `GROUP` `BY` feature.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `read_group()` method internally uses the `GROUP BY` feature of SQL. This
    makes the `read_group` method faster, even if you have large datasets. Internally,
    the Odoo web client uses this method in the charts and the grouped tree view.
    You can tweak the behavior of the `read_group` method by using different arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the signature of the `read_group` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The different parameters available for the `read_group` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`domain`: This is used to filter records. This will be the search criteria
    for the `read_group` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This is a list of the fields to fetch with the grouping. Note that
    the fields mentioned here should be in the `groupby` parameter, unless you use
    some aggregate functions. The `read_group` method supports the SQL aggregate functions.
    Let›s say you want to get the average order amount per customer. If so, you can
    use `read_group` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to access the same field twice but with a different aggregate function,
    the syntax is a little different. You need to pass the field name as `alias:agg(field_name)`.
    This example will give you the total and average number of orders per customer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`groupby`: This parameter will be a list of fields by which the records are
    grouped. It lets you group records based on multiple fields. To do this, you will
    need to pass a list of fields. For example, if you want to group the sales orders
    by customer and order state, you can pass `[''partner_id '', ''state'']` in this
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: This parameter is used for pagination. If you want to skip a few
    records, you can use this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This parameter is used for pagination; it indicates the maximum number
    of records to fetch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazy`: This parameter accepts Boolean values. By default, its value is `True`.
    If this parameter is `True`, the results are grouped only by the first field in
    the `groupby` parameter. You will get the remaining `groupby` parameters and the
    domain in the `__context` and `__domain` keys in the result. If the value of this
    parameter is set to `False`, it will group the data by all fields in the `groupby`
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grouping by date fields can be complicated because it is possible to group
    records based on days, weeks, quarters, months, or years. You can change the grouping
    behavior of the date field by passing `groupby_function` after `:` in the `groupby`
    parameter. If you want to group the monthly total of the sales orders, you can
    use the `read_group` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The possible options for date grouping are `day`, `week`, `month`, `quarter`,
    and `year`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the documentation if you want to learn more about PostgreSQL aggregate
    functions: [https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating or writing multiple records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Odoo development, you might execute multiple queries to write
    or create multiple records. In this recipe, we will look at how to create and
    write records in batches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating multiple records and writing on multiple records work differently under
    the hood. Let’s see each of these records one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Odoo supports creating records in batches. If you are creating a single record,
    simply pass a dictionary with the field values. To create records in a batch,
    you just need to pass a list of these dictionaries instead of a single dictionary.
    The following example creates three room records in a single `create` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet will create the records for three new books.
  prefs: []
  type: TYPE_NORMAL
- en: Writing on multiple records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with multiple versions of Odoo, it’s important to understand how
    the write method behaves. In this case, it adopts a delayed approach for updates,
    meaning it doesn’t immediately write data to the database. Instead, Odoo only
    writes the data to the database when necessary or when the `flush()` method is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of the `write` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Odoo v13 or above, then there will not be any issues regarding
    performance. However, if you are using an older version, the second example will
    be much faster than the first one because the first example will execute a SQL
    query in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create multiple records in a batch, you need to pass value dictionaries
    in the form of a list to create new records. This will automatically manage batch-creating
    the records. When you create records in a batch, doing so internally will insert
    a query for each record. This means that creating records in a batch is not done
    in a single query. However, this doesn’t mean that creating records in batches
    does not improve performance. The performance gain is achieved through batch-calculating
    computing fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things work differently for the `write` method. Most things are handled automatically
    by the framework. For instance, if you write the same data on all records, the
    database will be updated with only one `UPDATE` query. The framework will even
    handle it if you update the same record again and again in the same transaction,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, only one query will be executed for `write`, with
    the final values of `name=Administrator` and `email=admin-2@example.com`. This
    does not have a bad impact on performance, as the assigned values are in the cache
    and written later in a single query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are different if you use the `flush()` method in between, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `flush()` method updates the values from the cache to the database. So,
    in the previous example, two `UPDATE` queries will be executed – one with data
    before the flush and another with data after the flush.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using an older version, then writing a single value will execute
    the `UPDATE` query immediately. Check the following examples to explore the correct
    usage of the `write` operation for an older version of Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the first example, we have two `UPDATE` queries, while the second example
    will only take one `UPDATE` query.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing records through database queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo ORM has limited methods, and sometimes, it is difficult to fetch certain
    data from ORM. In these cases, you can fetch data in the desired format, and you
    need to perform an operation on the data to get a certain result. Due to this,
    it becomes slower. To handle these special cases, you can execute SQL queries
    in the database. In this recipe, we will explore how you can run SQL queries from
    Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform database queries using the `self._cr.execute` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: self.flush()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self._cr.execute("SELECT id, name, room_no, floor_no  FROM hostel_room WHERE
    name ilike %s", ('%Room A-%',))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data = self._cr.dictfetchall()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(data)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[{''id'': 4, ''name'': ''Room A-101'', ''room_no'': 101, ''floor_no'': 1},
    {''id'': 5, ''name'': ''Room A-103'', ''room_no'': 103, ''floor_no'': 1}, {''id'':
    6, ''name'': ''Room A-201'', ''room_no'': 201, ''floor_no'': 2}]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to fetch only a single record, you can use the `fetchone()` and
    `dictfetchone()` methods. These methods work like `fetchall()` and `dictfetchall()`,
    but they only return a single record, and you need to call the `fetchone()` and
    `dictfetchone()` methods multiple times if you want to fetch multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to access the database cursor from the recordset – one is
    from the recordset itself, such as `self._cr`, and the other is from the environment
    (in particular, `self.env.cr`). This cursor is used to execute database queries.
    In the preceding example, we saw how you can fetch data through raw queries. The
    table name is the name of the model after replacing `.` with `_`, so the `hostel.room`
    model becomes `hostel_room`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we used `self.flush()` before executing a query. The reason behind
    this is that Odoo uses the cache excessively, and the database might not have
    the correct values. `self.flush()` will push all the delayed updates to the database
    and conduct all the dependent computations as well, and you will then get correct
    values from the database. The `flush()` method also supports a few parameters
    that help you control what is flushed in the database. The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fname` parameter needs a list of fields that you want to flush to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `records` parameter needs a recordset, and it is used if you want to flush
    certain records only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are executing `INSERT` or `UPDATE` queries, you will also need to execute
    `flush()` after executing the query because the ORM might not be aware of the
    change you made, and it might have cached records.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to consider a few things before you execute raw queries. Only use
    raw queries when you have no other choice. By executing raw queries, you bypass
    the ORM layers. Therefore, you also bypass security rules and the ORM’s performance
    advantages. Sometimes, wrongly built queries can introduce SQL injection vulnerabilities.
    Consider the following example, in which the queries could allow an attacker to
    perform SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Don’t use the string format function either; it will also allow an attacker
    to perform SQL injection. Using SQL queries makes your code harder to read and
    understand for other developers, so avoid using them wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: A lot of Odoo developers believe that executing SQL queries makes operations
    faster, as it bypasses the ORM layer. This is not completely true, however; it
    depends on the use case. In most operations, ORM performs better and faster than
    `RAW` queries because data is served from the recordset cache.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations made in one transaction are only committed at the end of it. If an
    error occurs in the ORM, the transaction is rolled back. If you have made an `INSERT`
    or `UPDATE` query and you want to make it permanent, you can use `self._cr.commit()`
    to commit the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that using `commit()` can be dangerous because it can put records in an
    inconsistent state. An error in the ORM can cause incomplete rollbacks, so only
    use `commit()` if you are completely sure of what you›re doing.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `commit()` method, then there›s no need to use `flush()` afterward.
    The `commit()` method flushes the environment internally.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you will be unable to pinpoint the cause of an issue. This is especially
    true of performance issues. Odoo provides some built-in profiling tools that help
    you find the real cause of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling is about analyzing the execution of a program and measuring aggregated
    data. These data can be the elapsed time for each function, the executed SQL queries,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While profiling does not improve the performance of a program by itself, it
    can prove very helpful in finding performance issues and identifying which part
    of the program is responsible for them.
  prefs: []
  type: TYPE_NORMAL
- en: Code profiling in Odoo can help you identify performance and optimize your code.
    It is a technique used to analyze the code execution time, complexity of the program,
    and memory usage of an application.
  prefs: []
  type: TYPE_NORMAL
- en: By using profiling techniques in Odoo, you can improve the overall performance
    and user experience of your application, making it faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The profiler can either be enabled from the user interface, which is the easiest
    way to do so but only allows you to profile web requests, or from Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable developer mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The profiler must be enabled globally on the database. This can be done in
    two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer mode tools, and then toggle the **Enable profiling** button.
    A wizard suggests a set of expiry times for the profiling. Click on **Enable profiling**
    to enable the profiler globally.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 21.1 – Enabling Profiling](img/B20997_21_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21.1 – Enabling Profiling
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.2 – Disabling profiling](img/B20997_21_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21.2 – Disabling profiling
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Settings** | **General Settings** | **Performance** and set the desired
    time for the field Enable profiling field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To browse the profiling results, make sure that the profiler is enabled globally
    on the database, then open the developer mode tools, and click on the button in
    the top-right corner of the profiling section. A list view of the `ir.profile`
    records grouped by profiling session will open.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each record has a clickable link that opens the speedscope results in a new
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Speedscope falls out of the scope of this documentation, but there are a lot
    of tools to try out – search, highlight of similar frames, zoom on frame, timeline,
    left heavy, sandwich view, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the profiling options that were activated, Odoo generates different
    view modes that you can access from the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20997_21_05.jpg)![](img/B20997_21_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Combined**: The **Combined** view displays all of the SQL queries and traces
    that have been integrated together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combined no context**: The **Combined no context** view produces the same
    results but disregards the stored execution context, performance/profiling/enable>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sql (no gap)**: The **sql (no gap)** view displays all SQL queries as if
    they were done sequentially, without any Python logic. This is solely beneficial
    for SQL optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sql (density)**: Only the SQL queries are displayed in the **sql (no density)**
    view, with space between them. This can help you discover areas where numerous
    tiny queries could be batch-processed and determine whether the issue is with
    the Python or SQL code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frames**: Only the periodic collector’s results are displayed in the **frames**
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Despite the profiler’s lightweight design, it can still affect performance,
    particularly when utilizing the `Sync` collector. Remember that when you examine
    the speedscope data.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every collector has a unique format and method to gather profiling data. Through
    their specific toggle button in the developer mode tools, or from Python code
    using their key or class, each can be independently enabled from the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently four collectors available in Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLCollector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PeriodicCollector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QwebCollector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyncCollector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLCollector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All SQL queries made to the database in the current thread (for all cursors)
    are saved by the `SQL` collector, together with the stack trace. Using the collector
    on a large number of tiny queries could affect execution time and other profilers,
    since the overhead of the collector is added to the thread that is examined for
    each query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging query counts and adding data to the `Periodic` collector in the combined
    speedscope view are two particularly helpful uses for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Periodic collector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This collector runs in a separate thread and saves the stack trace of the analyzed
    thread at every interval. The interval (by default, 10 ms) can be defined through
    the **Interval** option in the user interface or the interval parameter in Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Memory problems will arise when profiling lengthy queries if the interval is
    set extremely low. The interval will lose information on brief function executions
    if it is set extremely high.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its distinct thread, it should have relatively little effect on
    execution time, making it one of the finest ways to assess performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The Qweb collector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Python execution time and queries for each directive are reduced by this
    collector. With the SQL collector, the overhead may be significant when a large
    number of tiny instructions are executed. In terms of data collected, the results
    differ from those of other collectors, and a custom widget can be used to examine
    them from the `ir.profile` form view.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is most helpful when trying to maximize views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Sync collector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Performance is significantly impacted by this collector, since it operates on
    a single thread and saves the stack for each function call and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging and comprehending intricate flows, as well as tracking their execution
    within the code, can be helpful. However, due to the significant overhead, performance
    analysis is not advised to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Performance pitfalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful with randomness. Multiple executions may lead to different results
    – for example , a garbage collector being triggered during execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful with blocking calls. In some cases, an external `c_call` may take
    some time before releasing the GIL, thus leading to unexpected long frames with
    the Periodic collector. This should be detected by the profiler and given a warning.
    It is possible to trigger the profiler manually before such calls if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay attention to the cache. Profiling before the view/assets/… are in a cache
    can lead to different results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of the profiler’s overhead. The SQL collector’s overhead can be important
    when many small queries are executed. Profiling is practical to spot a problem,
    but you may want to disable the profiler to measure a code change’s real impact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling results can be memory-intensive. In some cases (e.g., profiling an
    install or a long request), you can reach the memory limit, especially when rendering
    the speedscope results, which can lead to an HTTP 500 error. In this case, you
    may need to start the server with a higher memory limit – `--``limit-memory-hard
    $((8*1024**3)).`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
