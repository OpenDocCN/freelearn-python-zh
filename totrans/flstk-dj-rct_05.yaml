- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Testing the REST API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 REST API
- en: In software engineering, testing is a process to check whether the actual software
    product performs as expected and is bug free.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，测试是一个检查实际软件产品是否按预期运行且无错误的过程。
- en: There are a lot of ways to test software through both manual and automated tests.
    But in this project, we’ll focus more on **automated testing**. However, we’ll
    first dive into the different ways of testing software, including their pros and
    their cons, and also talk about the concept of the **testing pyramid**. We’ll
    also check the tools needed to add tests to a Django application and add tests
    to the models and the viewsets. This chapter will help you understand testing
    for developers and also how to write tests for a Django API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以通过手动和自动测试来测试软件。但在本项目，我们将更多地关注**自动化测试**。然而，我们首先会深入了解软件测试的不同方式，包括它们的优缺点，以及讨论**测试金字塔**的概念。我们还将检查添加测试到
    Django 应用程序所需的工具，以及如何为模型和视图集添加测试。本章将帮助您了解开发者的测试以及如何为 Django API 编写测试。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is testing?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: Testing in Django
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 中的测试
- en: Configuring the testing environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: Writing tests for Django models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Django 模型编写测试
- en: Writing tests for Django viewsets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Django 视图集编写测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code of the current chapter at this link: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到当前章节的代码：[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5).
- en: What is testing?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: To make it simple, testing is finding out how well something works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，测试就是找出某物工作得有多好。
- en: However, the process comprises a group of techniques to determine the correctness
    of the application under a script or manual test directly on the user interface.
    The aim is to detect failures, including bugs and performance issues, in the application,
    so that they can be corrected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程包括一系列技术，用于确定在脚本或直接在用户界面上的手动测试下应用程序的正确性。目的是检测应用程序中的失败，包括错误和性能问题，以便它们可以被纠正。
- en: Most of the time, testing is done by comparing the software requirements to
    the actual software product. If one of the requirements is to make sure that input
    only accepts numbers and not characters or files, a test will be conducted to
    check whether the input has a validation system to reject non-number values in
    the input.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，测试是通过将软件需求与实际软件产品进行比较来完成的。如果其中一个需求是确保输入只接受数字而不是字符或文件，那么将进行一项测试来检查输入是否有验证系统以拒绝输入中的非数值。
- en: However, testing also involves an examination of code and the execution of code
    in various environments and conditions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试还涉及对代码的检查以及在各种环境和条件下执行代码。
- en: What is software testing?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: Software testing is the process of examining the behavior of the software under
    test for validation or verification. It considers the attributes of reliability,
    scalability, reusability, and usability to evaluate the execution of the software
    components (servers, database, application, and so on) and find software bugs,
    errors, or defects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是检查软件在测试下的行为以进行验证或验证的过程。它考虑了可靠性、可伸缩性、可重用性和可用性等属性，以评估软件组件（服务器、数据库、应用程序等）的执行，并找出软件错误、错误或缺陷。
- en: 'Software testing has a lot of benefits, some of which are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试有很多好处，以下是一些：
- en: '**Cost effectiveness**: Testing any software project helps the business save
    money in the long run. As the process helps detect bugs and check whether newly
    added features are working in the system without breaking things, it’s a great
    technical debt reducer.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：测试任何软件项目都有助于企业在长期内节省资金。因为这个过程有助于检测错误，并检查新添加的功能是否在系统中运行良好而不会破坏其他东西，所以它是一个很好的技术债务减少者。'
- en: '**Security**: If testing is done well, it can be a quick way to detect security
    risks and problems at an early stage before deploying a product to the whole world.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：如果测试做得好，它可以是一个快速检测在产品部署到整个世界之前早期阶段的安全风险和问题的方法。'
- en: '**Product quality**: Testing helps with performance measurement, making sure
    that the requirements are respected.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品质量**：测试有助于性能测量，确保需求得到尊重。'
- en: Why is software testing important?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么软件测试很重要？
- en: 'Testing your software is important because it helps reduce the impact of bugs
    through bug identification and resolution. Some bugs can be quite dangerous and
    can lead to financial losses or endanger human life. Here are some historical
    examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的软件很重要，因为它有助于通过漏洞识别和解决来减少错误的影响。一些错误可能非常危险，可能导致经济损失或危及人类生命。以下是一些历史例子：
- en: 'Source: [https://lexingtontechnologies.ng/software-testing/](https://lexingtontechnologies.ng/software-testing/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://lexingtontechnologies.ng/software-testing/](https://lexingtontechnologies.ng/software-testing/).
- en: In April 1999, $1.2 billion were lost due to the failure of a military satellite
    launch. To date, this is the costliest accident in the history of the world.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1999年4月，由于一次军事卫星发射失败，损失了12亿美元。到目前为止，这是世界上成本最高的事故。
- en: In 2014, the giant Nissan recalled over 1 million cars from the market because
    of a software failure in the airbag sensory detectors.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年，由于安全气囊传感器中的软件故障，日产汽车召回了一百多万辆汽车。
- en: In 2014, some of Amazon's third-party retailers lost a lot of money because
    of a software glitch. The bug affected the price of the products, reducing them
    to 1p.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年，由于软件故障，亚马逊的一些第三方零售商损失了大量资金。该漏洞影响了产品的价格，将它们降至1便士。
- en: In 2015, a software failure in the **Point of sales** (**POS**) system of Starbucks
    stores caused the temporary closure of more than 60% of their stores in the US
    and Canada.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2015年，星巴克商店的销售点（POS）系统出现软件故障，导致其在美加的超过60%的门店临时关闭。
- en: In 2015, an F-35 fighter plane fell victim to a software bug, which prevented
    it from detecting or identifying targets correctly. The sensor on the plane was
    unable to identify threats even from their own planes.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2015年，F-35战斗机因软件漏洞而成为受害者，该漏洞阻止了它正确检测或识别目标。飞机上的传感器甚至无法识别来自它们自己的飞机的威胁。
- en: In 2016, Google reported a bug affecting Windows 10 machines. The vulnerability
    allowed users to escape security sandboxes through a flow in the win32k system.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2016年，谷歌报告了一个影响Windows 10机器的漏洞。该漏洞允许用户通过win32k系统中的流程绕过安全沙箱。
- en: What are the various types of testing?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些不同的测试类型？
- en: 'Testing is typically classified into three categories:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常分为三类：
- en: '**Functional testing**: This type of testing comprises unit, integration, user
    acceptance, globalization, internationalization testing, and so on'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性测试**：这种测试包括单元测试、集成测试、用户接受测试、全球化测试、国际化测试等'
- en: '**Non-functional testing**: This type of testing checks for factors such as
    performance, volume, scalability, usability, and load'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性测试**：这种测试检查性能、容量、可扩展性、可用性和负载等因素'
- en: '**Maintenance testing**: This type of testing considers regression and maintenance'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护测试**：这种测试考虑了回归和维护'
- en: 'However, these tests can also be classified into two different types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些测试也可以分为两种不同的类型：
- en: Automated tests
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Manual tests
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试
- en: First, let’s see what manual testing is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看什么是手动测试。
- en: Understanding manual testing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解手动测试
- en: '**Manual testing** is the process of testing software manually to find defects
    or bugs. It’s the process of testing the functionalities of an application without
    the help of automation tools.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动测试**是指手动测试软件以发现缺陷或错误的过程。这是在没有自动化工具帮助的情况下测试应用程序功能的过程。'
- en: An example of manual testing is when test users are called to test an application
    or a special feature. They can be asked to test a specific form, push the application
    to its limits when it comes to performance, and much more.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试的一个例子是当测试用户被召集来测试一个应用程序或一个特殊功能。他们可能被要求测试一个特定的表单，在性能方面将应用程序推到极限，等等。
- en: 'Manual testing has a lot of advantages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试有很多优点：
- en: It’s very useful to test user interface designs and interactions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常有助于测试用户界面设计和交互
- en: It’s easier to learn for new testers
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新测试员来说更容易学习
- en: It takes user experience and usability into consideration
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它考虑了用户体验和可用性
- en: It’s cost-effective
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有成本效益
- en: 'However, manual testing also has some cons:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动测试也有一些缺点：
- en: It requires human resources.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要人力资源。
- en: It’s time-consuming.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这很耗时。
- en: Testers consider test cases based on their skills and experience. This means
    that a beginner tester may not cover all the functions.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试员根据他们的技能和经验考虑测试用例。这意味着一个初级测试员可能无法覆盖所有功能。
- en: Even if manual testing sounds very appealing, it can be quite a time- and resource-consuming
    exercise, and developers definitely do not make really good manual testers. Let’s
    see how automated testing can erase the cons of manual testing and place better
    development at the center of testing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使手动测试听起来非常吸引人，它也可能是一项耗时且资源消耗很大的活动，而开发者绝对不是真正优秀的手动测试员。让我们看看自动化测试如何消除手动测试的缺点，并将更好的开发置于测试的中心。
- en: Understanding automated testing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解自动化测试
- en: '**Automated testing** is simply the process of testing software using automation
    tools to find defects. These automation tools can be scripts written in the language
    used to build the application or some software or drivers (such as **Selenium**,
    **WinRunner**, and **LoadRunner**) to make automated testing easier and faster.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化测试**简单来说就是使用自动化工具测试软件以查找缺陷的过程。这些自动化工具可以是用于构建应用程序的语言编写的脚本，或者是一些软件或驱动程序（例如**Selenium**、**WinRunner**和**LoadRunner**），以使自动化测试更加容易和快速。'
- en: 'Automated testing fixes the cons of manual testing, and it also has more advantages,
    as shown in the following list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试解决了手动测试的缺点，并且它还具有更多优点，如下所示：
- en: Faster in execution
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行速度更快
- en: Cheaper than manual testing in the long run
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从长远来看，比手动测试便宜
- en: More reliable, powerful, and versatile
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更可靠、强大和多功能
- en: Very useful in regression testing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回归测试中非常有用
- en: Able to provide better test coverage
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够提供更好的测试覆盖率
- en: Possible to run without human intervention
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能在没有人为干预的情况下运行
- en: Much cheaper
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更便宜
- en: 'However, automated testing is also inconvenient in some ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动化测试在某些方面也存在不便：
- en: It is expensive at the beginning
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始成本较高
- en: It has a huge cost of maintenance when requirements change
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需求发生变化时，维护成本非常高
- en: Automated testing tools are expensive
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试工具成本较高
- en: The real value of automated testing and manual testing comes when each is used
    in the right environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试和手动测试的真实价值在于它们在正确环境中被使用时。
- en: For example, manual testing is much more useful on frontend projects where you
    want to test the usability and user experience. Automated testing can be useful
    to test methods or functions in the code and is very useful for finding bugs or
    security issues.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，手动测试在前端项目中非常有用，您想测试可用性和用户体验。自动化测试可以用来测试代码中的方法或函数，并且对于查找错误或安全问题非常有用。
- en: In this chapter, we’ll focus on writing automated tests in Python. As we are
    developing an API, we want to make sure that the system is reliable and behaves
    as we want it to, but it should also be secure against the possible issues of
    the next added feature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于用Python编写自动化测试。由于我们正在开发一个API，我们想确保系统是可靠的，并且按照我们的期望运行，但它也应该能够抵御下一个添加的功能可能带来的问题。
- en: This said, let’s talk about testing in Django and introduce the notion of **test-driven**
    **development** (**TDD**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们来谈谈Django中的测试，并介绍**测试驱动开发**（**TDD**）的概念。
- en: Testing in Django
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django中的测试
- en: Testing in Python, particularly in Django, is very simple and easy. The framework
    actually provides many tools and utilities you can use to write tests for the
    models, serializers, or views in the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行测试，尤其是在Django中，非常简单和容易。实际上，该框架提供了许多工具和实用程序，您可以使用它们来编写应用程序中模型、序列化器或视图的测试。
- en: However, the Python ecosystem for testing relies a lot on one tool to write
    tests, and this tool has deep integration with Django. The tool is named **Pytest**
    ([https://docs.pytest.org](https://docs.pytest.org)) and is a framework for writing
    small and readable tests. Used with Django, Pytest is mainly used for API testing
    by writing code to test API endpoints, databases, and user interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python的测试生态系统在很大程度上依赖于一个工具来编写测试，这个工具与Django有深度集成。这个工具叫做**Pytest**([https://docs.pytest.org](https://docs.pytest.org))，是一个用于编写小型和可读性测试的框架。与Django一起使用时，Pytest主要用于通过编写代码来测试API端点、数据库和用户界面进行API测试。
- en: 'But why use Pytest? Well, it has the following advantages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么使用Pytest？嗯，它有以下优点：
- en: It is free and open source
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费和开源的
- en: It has a simple syntax and is very easy to start with
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法简单，易于上手
- en: It automatically detects test files, functions, and classes
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动检测测试文件、函数和类
- en: It can run multiple tests in parallel, increasing the performance and the speed
    of running tests
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以并行运行多个测试，提高性能和测试运行速度
- en: 'We’ll use Pytest in this project to write two kinds of tests: **integration
    tests** and **unit tests**.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本项目中使用Pytest编写两种类型的测试：**集成测试**和**单元测试**。
- en: Before starting to code, let’s learn about integration testing and unit testing
    by considering the concepts of TDD and the testing pyramid.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，让我们通过考虑TDD和测试金字塔的概念来学习集成测试和单元测试。
- en: The testing pyramid
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: The testing pyramid is a framework that can help developers start with testing
    to create high-quality software. Basically, the testing pyramid specifies the
    types of tests that should be included in an automated test suite.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔是一个可以帮助开发者从测试开始创建高质量软件的框架。基本上，测试金字塔指定了应该包含在自动化测试套件中的测试类型。
- en: 'First of all, remember that the testing pyramid operates at three levels:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记住测试金字塔在三个层面上运作：
- en: Unit tests
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End-to-end tests
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: 'The following figure shows the positions of each of these levels in the pyramid
    and how they are prioritized in terms of the speed performance and level of integration
    or isolation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了金字塔中每个层面的位置以及它们在速度性能和集成或隔离程度方面的优先级：
- en: '![Figure 5.1 – The testing pyramid](img/Figure_5.1_B18221.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 测试金字塔](img/Figure_5.1_B18221.jpg)'
- en: Figure 5.1 – The testing pyramid
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 测试金字塔
- en: In the preceding figure, the base level is occupied by unit testing. Unit tests
    target individual components or functionality to check whether they work as expected
    in isolated conditions. In our backend project, an example would be to test whether
    the `like_post` method on the `User` class model actually performs as intended.
    We are not testing the whole `User` model; we are testing one method of the `User`
    model class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，底层被单元测试占据。单元测试针对单个组件或功能，以检查它们在隔离条件下是否按预期工作。在我们的后端项目中，一个例子是测试`User`类模型上的`like_post`方法是否真正按预期执行。我们不是在测试整个`User`模型；我们是在测试`User`模型类的一个方法。
- en: It’s definitely a good habit to write a lot of unit tests. They should comprise
    at least 60% of all the tests in your code base because they are fast, short,
    and test a lot of components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 写很多单元测试绝对是一个好习惯。它们应该至少占你代码库中所有测试的60%，因为它们速度快、短小，并且测试了很多组件。
- en: On the second level, you have integration tests. If unit tests verify small
    pieces of a code base, integration tests test how this code interacts with other
    code or other parts of the software. A useful, albeit controversial, example of
    integration testing is writing a test for a viewset. When testing a viewset, you
    are also testing the permissions, the authentication classes, the serializers,
    the models, and the database if possible. It’s a test of how the different parts
    of the Django API work together.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二层，你有集成测试。如果单元测试验证代码库的小部分，集成测试则测试这段代码如何与其他代码或其他软件部分交互。集成测试的一个有用但具有争议的例子是编写一个针对视图集的测试。当测试视图集时，你也在测试权限、认证类、序列化器、模型，如果可能的话，还有数据库。这是一个测试Django
    API的不同部分如何协同工作的测试。
- en: An integration test can also be a test between your application and an external
    service, a payment API, for example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试也可以是应用程序与外部服务之间的测试，例如支付API。
- en: On the third level at the top of the pyramid, you have end-to-end tests. These
    kinds of tests ensure that the software is working as required. They test how
    the application works from beginning to end.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔顶部的第三层，你有端到端测试。这类测试确保软件按预期工作。它们测试应用程序从开始到结束的工作方式。
- en: In this book, we’ll focus on unit and integration testing. Note that integration
    tests are the subject of some misunderstandings that will be cleared up once we
    define them. According to my personal experience, unit tests in Django are written
    more on the model and serializer side of each application. They can be used for
    testing the creation of an object in the database as well as for retrieving, updating,
    or deletion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注单元测试和集成测试。请注意，集成测试是某些误解的主题，一旦我们定义了它们，这些误解就会消除。根据我的个人经验，Django中的单元测试更多地写在每个应用程序的模型和序列化器方面。它们可以用来测试在数据库中创建对象，以及检索、更新或删除。
- en: Regarding viewset tests, I believe that they can act as integration tests because
    running them calls on permissions, authentication, serializers, validation, and
    also models, depending on the action you are performing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视图集测试，我相信它们可以作为集成测试，因为运行它们会调用权限、认证、序列化器、验证，以及根据你执行的操作，还有模型。
- en: 'Returning to unit tests, they are more effective when using TDD, which comprises
    software development practices that focus on writing unit test cases before developing
    the feature. Even if it sounds counter-intuitive, TDD has a lot of advantages:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到单元测试，当使用 TDD（测试驱动开发）时，它们更有效，TDD 是一种软件开发实践，它侧重于在开发功能之前编写单元测试用例。尽管听起来有些反直觉，但
    TDD 有很多优点：
- en: It ensures optimized code
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保代码优化
- en: It ensures the application of design patterns and better architecture
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保了设计模式和更好架构的应用
- en: It helps the developer understand the business requirements
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助开发者理解业务需求
- en: It makes the code flexible and easier to maintain
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使代码更灵活且易于维护
- en: However, we didn’t particularly respect the TDD rule in the book. We relied
    on the Django shell and a client to test the feature of the REST API we are building.
    For the next features that will be added to the project, tests will be written
    before coding the feature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并没有特别遵守书中的 TDD 规则。我们依赖于 Django shell 和客户端来测试我们正在构建的 REST API 的功能。对于项目将要添加的下一个功能，测试将在编码功能之前编写。
- en: With concepts such as TDD, unit and integration testing, and testing pyramid
    understood, we can now configure the testing environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 TDD、单元和集成测试以及测试金字塔等概念之后，我们现在可以配置测试环境。
- en: Configuring the testing environment
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: Pytest, taken alone, is simply a Python framework to write unit tests in Python
    programs. Thankfully, there is a plugin for Pytest to write tests in Django projects
    and applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，Pytest 只是一个用于在 Python 程序中编写单元测试的 Python 框架。幸运的是，有一个 Pytest 插件可以用于 Django
    项目和应用程序的测试。
- en: 'Let’s install and configure the environment for testing by using the following
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装和配置测试环境：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the package is installed, create a new file called `pytest.ini` at the
    root of the Django project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，在 Django 项目的根目录下创建一个名为 `pytest.ini` 的新文件：
- en: pytest.ini
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pytest.ini
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once it’s done, run the `pytest` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，运行 `pytest` 命令：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You’ll see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great! Pytest is installed in the project, and we can write the first test in
    the project to test the configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！Pytest 已安装到项目中，我们可以编写项目中的第一个测试来测试配置。
- en: Writing your first test
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个测试
- en: The Pytest environment is configured, so let’s see how we can write a simple
    test using Pytest.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 环境已配置，让我们看看如何使用 Pytest 编写一个简单的测试。
- en: At the root of the project, create a file called `tests.py`. We’ll simply write
    a test to test the sum of a function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为 `tests.py` 的文件。我们将简单地编写一个测试来测试函数的求和。
- en: 'Following the TDD concept, we’ll write the test first and make it fail:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 TDD 概念，我们将首先编写测试并使其失败：
- en: tests.py
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: tests.py
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is written to check for a condition, justifying the usage of the
    `assert` Python keyword. If the condition after the `assert` is true, the script
    will continue or stop the execution. If that’s not the case, an assertion error
    will be raised.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是为了检查一个条件，从而证明使用 `assert` Python 关键字是合理的。如果 `assert` 后的条件为真，脚本将继续或停止执行。如果不是这种情况，将引发断言错误。
- en: 'If you run the `pytest` command, you’ll receive the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `pytest` 命令，你会收到以下输出：
- en: '![Figure 5.2 – Failing tests](img/Figure_5.2_B18221.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 失败的测试](img/Figure_5.2_B18221.jpg)'
- en: Figure 5.2 – Failing tests
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 失败的测试
- en: From the preceding output, we are sure that the test has failed. Let’s now write
    the feature to pass the test.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以确定测试失败了。现在让我们编写通过测试的功能。
- en: 'In the same file, `tests.py`, add the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件 `tests.py` 中，添加以下函数：
- en: tests.py
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: tests.py
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, run the `pytest` command again in the terminal. Everything should now
    be green:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中再次运行 `pytest` 命令。现在一切应该都是绿色的：
- en: "![Figure 5.3 – \uFEFFTest passes successfully](img/Figure_5.3_B18221.jpg)"
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 测试成功通过](img/Figure_5.3_B18221.jpg)'
- en: Figure 5.3 – Test passes successfully
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 测试成功通过
- en: Great! You have written the first test in the project using Pytest. In the next
    section, we’ll be writing tests for the models of the project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经使用 Pytest 在项目中编写了第一个测试。在下一节中，我们将编写项目的模型测试。
- en: Writing tests for Django models
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Django 模型编写测试
- en: When applying testing to a Django project, it’s always a good idea to start
    with writing tests for the models. But why test the models?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当将测试应用于 Django 项目时，始终从编写模型测试开始是一个好主意。但为什么要测试模型呢？
- en: Well, it gives you better confidence in your code and the connections to the
    database. It’ll make sure that methods or attributes on the model are well represented
    in the database, but it can also help you with better code structure, resolving
    bugs, and building documentation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这让你对自己的代码和数据库连接更有信心。它将确保模型上的方法或属性在数据库中得到良好表示，但也可以帮助你更好地构建代码结构、解决bug和编写文档。
- en: Without further ado, let’s start by writing tests for the `User` model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们先为`User`模型编写测试。
- en: Writing tests for the User model
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为User模型编写测试
- en: 'Inside the `core/user` directory, create a new file called `tests.py`. We’ll
    write tests to create a user and a simple user:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/user`目录中，创建一个名为`tests.py`的新文件。我们将编写创建用户和简单用户的测试。
- en: core/user/tests.py
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/tests.py
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the imports and the data to create the user have been added, we can write
    the test function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了导入和创建用户所需的数据，我们就可以编写测试函数：
- en: core/user/tests.py
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/tests.py
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above the `test_create_user` function, you’ll probably notice some syntax. It’s
    called a decorator, and it’s basically a function that takes another function
    as its argument and returns another function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_create_user`函数上方，你可能注意到了一些语法。这被称为装饰器，它基本上是一个接受另一个函数作为参数并返回另一个函数的函数。
- en: '`@pytest.mark.django_db` gives us access to the Django database. Try to remove
    this decorator and run the tests.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pytest.mark.django_db`为我们提供了访问Django数据库的权限。尝试移除此装饰器并运行测试。'
- en: 'You’ll get an error output with a similar message at the end:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在最后得到一个包含类似消息的错误输出：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well, re-add the decorator and run the `pytest` command and all tests should
    pass normally.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，重新添加装饰器并运行`pytest`命令，所有测试应该都能正常通过。
- en: Let’s do another test to make sure that the creation of `superuser` works perfectly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进行一个测试，以确保`superuser`的创建工作完美无误。
- en: 'Add a new dictionary containing the data needed to create `superuser`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的字典，包含创建`superuser`所需的数据：
- en: core/user/tests.py
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/tests.py
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here’s the function that tests the creation of `superuser`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试`superuser`创建功能的函数：
- en: core/user/tests.py
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/tests.py
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the tests again, and everything should be green.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，一切应该都是绿色的。
- en: Great! Now that we have a better understanding of how `pytest` works for tests,
    let’s write tests for the `Post` model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们更好地理解了`pytest`在测试中的作用，让我们为`Post`模型编写测试。
- en: Writing tests for the Post model
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Post模型编写测试
- en: To create a model, we need to have a user object ready. This will also be the
    same for the `Comment` model. To avoid repetition, we’ll simply write **fixtures**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模型，我们需要一个用户对象。对于`Comment`模型也是如此。为了避免重复，我们将简单地编写** fixtures**。
- en: A fixture is a function that will run before each test function to which it’s
    applied. In this case, the fixture will be used to feed some data to the tests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: fixture是一个函数，它将在应用到的每个测试函数之前运行。在这种情况下，fixture将用于向测试提供一些数据。
- en: To add fixtures in the project, create a new Python package called `fixtures`
    in the `core` directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中添加fixture，请在`core`目录中创建一个新的Python包，名为`fixtures`。
- en: 'In the `core/fixtures` directory, create a file called `user.py`. This file
    will contain a user fixture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/fixtures`目录中，创建一个名为`user.py`的文件。该文件将包含一个用户fixture：
- en: core/fixtures/user.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: core/fixtures/user.py
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the `@pytest.fixture` decorator labels the function as
    a fixture. We can now import the `user` function in any test and pass it as an
    argument to the `test` function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@pytest.fixture`装饰器将函数标记为fixture。现在我们可以在任何测试中导入`user`函数，并将其作为参数传递给`test`函数。
- en: Inside the `core/post` directory, create a new file called `tests.py`. This
    file will then test for the creation of a post.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/post`目录中，创建一个名为`tests.py`的新文件。然后该文件将测试创建帖子。
- en: 'Here’s the code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: core/post/tests.py
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests.py
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we are importing the `user` function from `user.py` in the fixtures
    directory and passing it as an argument to the `test_create_post` test function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在`fixtures`目录中从`user.py`导入`user`函数，并将其作为参数传递给`test_create_post`测试函数。
- en: Run the `pytest` command, and everything should be green.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pytest`命令，一切应该都是绿色的。
- en: Now that we have a working test for the `Post` model, let’s write tests for
    the `Comment` model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`Post`模型编写了工作测试，让我们为`Comment`模型编写测试。
- en: Writing tests for the Comment model
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Comment模型编写测试
- en: Writing tests for the `Comment` model requires the same steps as the tests for
    the `Post` model. First of all, create a new file called `post.py` in the `core/fixtures`
    directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Comment`模型编写测试需要与`Post`模型的测试相同的步骤。首先，在`core/fixtures`目录中创建一个名为`post.py`的新文件。
- en: This file will contain the fixture of a post, as it’s needed to create a comment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将包含一个帖子固定设置，因为它需要创建一个评论。
- en: But the `post` fixture will also need a `user` fixture. Thankfully, it’s possible
    with Pytest to inject fixtures into other fixtures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`post`固定设置也需要一个`user`固定设置。幸运的是，使用Pytest可以将固定设置注入到其他固定设置中。
- en: 'Here’s the code for the `post` fixture:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`post`固定设置的代码：
- en: core/fixtures/post.py
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: core/fixtures/post.py
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great! With the fixtures added, we can now write the test for comment creation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！添加了固定设置后，我们现在可以编写评论创建的测试。
- en: 'Inside the `core/comment/` directory, create a new file called `tests.py`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/comment/`目录内，创建一个名为`tests.py`的新文件：
- en: core/comment/tests.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests.py
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the tests with the `pytest` command, and everything should be green.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest`命令运行测试，一切应该都是绿色的。
- en: Great! We’ve just written tests for all the models in the project. Let’s move
    on to writing tests for the viewsets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们刚刚为项目中的所有模型编写了测试。让我们继续编写视图集的测试。
- en: Writing tests for your Django viewsets
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Django视图集编写测试
- en: Viewsets or endpoints are the interfaces of the business logic that the external
    clients will use to fetch data and create, modify, or delete data. It’s always
    a great habit to have tests to make sure that the whole system, starting from
    a request to the database, is working as intended.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 视图集或端点是外部客户端将用来获取数据以及创建、修改或删除数据的业务逻辑接口。始终有一个测试来确保整个系统从数据库请求开始按预期工作是一个很好的习惯。
- en: Before starting to write the tests, let’s configure the Pytest environment to
    use the API client from DRF.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试之前，让我们配置Pytest环境以使用DRF的API客户端。
- en: The API client is a class that handles different HTTP methods, as well as features
    such as authentication in testing, which can be very helpful for directly authenticating
    without a username and password to test some endpoints. Pytest provides a way
    to add configurations in a testing environment.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端是一个类，它处理不同的HTTP方法，以及测试中的认证等特性，这可以直接认证而不需要用户名和密码来测试一些端点，非常有帮助。Pytest提供了一种在测试环境中添加配置的方法。
- en: 'Create a file named `conftest.py` at the root of the project. Inside the file,
    we’ll create a fixture function for our custom client:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为`conftest.py`的文件。在文件内部，我们将为我们的自定义客户端创建一个固定设置函数：
- en: conftest.py
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: conftest.py
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Great! We can now directly call this client in the next tests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在可以直接在下一个测试中调用这个客户端。
- en: Let’s start by testing the authentication endpoints.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试认证端点开始。
- en: Writing tests for authentication
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写认证测试
- en: 'Inside the `core/auth` directory, create a file named `tests.py`. Instead of
    writing test functions directly, we write a class that will contain the testing
    methods as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/auth`目录内，创建一个名为`tests.py`的文件。我们不是直接编写测试函数，而是编写一个包含测试方法的类，如下所示：
- en: core/auth/tests.py
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/tests.py
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s add the `test_login` method to the `TestAuthenticationViewSet` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`TestAuthenticationViewSet`类中添加`test_login`方法：
- en: Core/auth/tests.py
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Core/auth/tests.py
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method basically tests the login endpoint. We are using the client fixture
    initialized in the `conftest.py` file to make a `post` request. Then, we test
    for the value of `status_code` of the response and the response returned.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基本上测试登录端点。我们使用在`conftest.py`文件中初始化的客户端固定设置来发出`post`请求。然后，我们测试响应的`status_code`值和返回的响应。
- en: Run the `pytest` command, and everything should be green.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pytest`命令，一切应该都是绿色的。
- en: 'Let’s add tests for the `register` and `refresh` endpoints:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`register`和`refresh`端点添加测试：
- en: core/auth/tests.py
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/tests.py
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, within the `test_refresh` method, we log in to get a
    refresh token to make a request to get a new access token.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`test_refresh`方法内部，我们登录以获取刷新令牌，以便发出请求以获取新的访问令牌。
- en: Run the `pytest` command again to run the tests, and everything should be green.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`pytest`命令来运行测试，一切应该都是绿色的。
- en: Let’s move on to writing tests for `PostViewSet`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写`PostViewSet`的测试。
- en: Writing tests for PostViewSet
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写PostViewSet的测试
- en: Before starting to write the viewsets tests, let’s quickly refactor the code
    to simply write the tests and follow the DRY rule. Inside the `core/post` directory,
    create a Python package called `tests`. Once it’s done, rename the `tests.py`
    file in the `core/post` directory to `test_models.py` and move it to the `core/post/tests/`
    directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写视图集测试之前，让我们快速重构代码以简化测试并遵循DRY规则。在`core/post`目录中，创建一个名为`tests`的Python包。完成后，将`core/post`目录中的`tests.py`文件重命名为`test_models.py`并将其移动到`core/post/tests/`目录。
- en: 'Inside the same directory, create a new file called `test_viewsets.py`. This
    file will contain tests for `PostViewSet`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，创建一个名为`test_viewsets.py`的新文件。此文件将包含对`PostViewSet`的测试：
- en: core/post/tests/test_viewsets.py
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests/test_viewsets.py
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`PostViewSet` handles requests for two types of users:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostViewSet`处理两种类型用户的请求：'
- en: Authenticated users
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户
- en: Anonymous users
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名用户
- en: 'Each type of user has different permissions on the `post` resource. So, let’s
    make sure that these cases are handled:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的用户对`post`资源有不同的权限。因此，让我们确保这些情况得到处理：
- en: core/post/tests/test_viewsets.py
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests/test_viewsets.py
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For these tests, we are forcing authentication. We want to make sure that authenticated
    users have access to the post’s resources. Let’s now write a test method for post
    creation, updating, and deletion:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些测试，我们正在强制进行认证。我们想确保认证用户可以访问帖子的资源。现在让我们为帖子创建、更新和删除编写一个测试方法：
- en: core/post/tests/test_viewsets.py
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests/test_viewsets.py
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the tests, and the outcomes should be green. Now, for the anonymous users,
    we want them to access the resource in reading mode, so they can’t create, modify,
    or delete a resource. Let’s test and validate these features:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，结果应该是绿色的。现在，对于匿名用户，我们希望他们以只读模式访问资源，因此他们不能创建、修改或删除资源。让我们测试并验证这些功能：
- en: core/post/tests/test_viewsets.py
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests/test_viewsets.py
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the tests to make sure everything is green. After that, let’s test the
    forbidden methods:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确保一切正常。之后，让我们测试禁止的方法：
- en: core/post/tests/test_viewsets.py
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/tests/test_viewsets.py
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the tests again. Great! We’ve just written tests for the post viewset. You
    should now have a better understanding of testing with viewsets.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。太好了！我们刚刚为帖子视图集编写了测试。你现在应该对使用视图集进行测试有了更好的理解。
- en: Let’s quickly write tests for `CommentViewSet`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速编写对`CommentViewSet`的测试。
- en: Writing tests for CommentViewSet
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为CommentViewSet编写测试
- en: Before starting to write the viewset tests, let’s also quickly refactor the
    code for writing the tests. Inside the `core/comment` directory, create a Python
    package called `tests`. Once it’s done, rename the `tests.py` file in the `core/post`
    directory to `test_models.py` and move it to the `core/comment/tests/` directory.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写视图集测试之前，让我们也快速重构编写测试的代码。在`core/comment`目录中，创建一个名为`tests`的Python包。完成后，将`core/post`目录中的`tests.py`文件重命名为`test_models.py`并将其移动到`core/comment/tests/`目录。
- en: Inside the same directory, create a new file called `test_viewsets.py`. This
    file will contain tests for `CommentViewSet`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，创建一个名为`test_viewsets.py`的新文件。此文件将包含对`CommentViewSet`的测试。
- en: Just like in `PostViewSet`, we have two types of users, and we want to write
    test cases for each of their permissions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`PostViewSet`中一样，我们有两种类型的用户，我们想要为他们的每种权限编写测试用例。
- en: 'However, before creating comments, we need to add comment fixtures. Inside
    the `core/fixtures` directory, create a new file called `comment.py` and add the
    following content:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建评论之前，我们需要添加评论固定数据。在`core/fixtures`目录中，创建一个名为`comment.py`的新文件并添加以下内容：
- en: core/fixtures/comment.py
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: core/fixtures/comment.py
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, inside `core/comment/tests/test_viewsets.py`, add the following
    content first:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`core/comment/tests/test_viewsets.py`内部，首先添加以下内容：
- en: core/comment/tests/test_viewsets.py
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests/test_viewsets.py
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, let’s add tests to the list and retrieve comments as authenticated users:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向列表中添加测试并作为认证用户检索评论：
- en: core/comment/tests/test_viewsets.py
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests/test_viewsets.py
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make sure that these tests pass by running the `pytest` command. The next step
    is to add tests for comment creation, updating, and deletion:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`pytest`命令确保这些测试通过。下一步是添加对评论创建、更新和删除的测试：
- en: core/comment/tests/test_viewsets.py
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests/test_viewsets.py
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the tests again to make sure everything is green. Let’s write tests for
    the anonymous users now.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以确保一切正常。现在，让我们为匿名用户编写测试。
- en: 'First of all, we need to make sure that they can access the resources with
    the `GET` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保他们可以使用`GET`方法访问资源：
- en: core/comment/tests/test_viewsets.py
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests/test_viewsets.py
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we need to make sure that an anonymous user can’t create, update, or
    delete a comment:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保匿名用户不能创建、更新或删除评论：
- en: core/comment/tests/test_viewsets.py
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/tests/test_viewsets.py
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding cases, the data `dict` is empty because we are expecting error
    statuses.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数据 `dict` 是空的，因为我们期望错误状态。
- en: Run the tests again to make sure that everything is green!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试以确保一切正常！
- en: And voilà. We’ve just written tests for `CommentViewSet`. We also need to write
    tests for the `UserViewSet` class, but this will be a small project for you.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦。我们刚刚为 `CommentViewSet` 编写了测试。我们还需要为 `UserViewSet` 类编写测试，但这将是一个小项目给你。
- en: Writing tests for the UserViewSet class
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 UserViewSet 类编写测试
- en: 'In this section, let’s do a quick hands-on exercise. You’ll write the code
    for the `UserViewSet` class. It’s quite similar to the other tests we’ve written
    for `PostViewSet` and `CommentViewSet`. I have provided you with the structure
    of the class, and all you have to do is to write the testing logic in the methods.
    The following is the structure you need to build on:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们进行一个快速的实际操作练习。你需要为 `UserViewSet` 类编写代码。它与我们已经为 `PostViewSet` 和 `CommentViewSet`
    编写的其他测试非常相似。我已经为你提供了类的结构，你所要做的就是编写方法中的测试逻辑。以下是你需要构建的结构：
- en: core/user/tests/test_viewsets.py
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/tests/test_viewsets.py
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here are the requirements concerning the tests:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于测试的要求：
- en: '`test_list`: An authenticated user should enable a list of all users'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_list`：认证用户应该能够列出所有用户'
- en: '`test_retrieve`: An authenticated user can retrieve resources concerning a
    user'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_retrieve`：认证用户可以检索与用户相关的资源'
- en: '`test_create`: Users cannot create users directly with a `POST` request'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create`：用户不能通过 `POST` 请求直接创建用户'
- en: '`test_update`: An authenticated user can update a `user` object with a `PATCH`
    request'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_update`：认证用户可以使用 `PATCH` 请求更新 `user` 对象'
- en: 'You can find the solution to this exercise here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到这个练习的解决方案：[https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py)。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about testing, the different types of testing, and
    their advantages. We also introduced testing in Django using Pytest and wrote
    tests for the models and viewsets. These skills acquired in writing tests using
    the TDD method help you better design your code, prevent bugs tied to code architecture,
    and improve the quality of the software. Not to forget, they also give you a competitive
    advantage in the job market.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了测试，不同类型的测试及其优势。我们还介绍了在 Django 中使用 Pytest 进行测试，并为模型和视图集编写了测试。使用 TDD
    方法编写测试所获得的能力有助于你更好地设计代码，防止与代码架构相关的错误，并提高软件的质量。别忘了，它们还能在就业市场上给你带来竞争优势。
- en: This is the last chapter of *Part 1*, *Technical Background*. The next part
    will be dedicated to React and connecting the frontend to the REST API we’ve just
    built. In the next chapter, we’ll learn more about frontend development and React,
    and we’ll also create a React project and run it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一部分 *技术背景* 的最后一章。下一部分将专注于 React 以及将前端连接到我们刚刚构建的 REST API。在下一章中，我们将学习更多关于前端开发和
    React 的知识，并创建一个 React 项目并运行它。
- en: Questions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is testing?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: What is a unit test?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是什么？
- en: What is the testing pyramid?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是什么？
- en: What is Pytest?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Pytest？
- en: What is a Pytest fixture?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Pytest 固定装置？
- en: 'Part 2: Building a Reactive UI with React'
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用 React 构建响应式 UI
- en: In *Part 1* of our book, we built the backend of the Postagram application using
    Django, with authentication features and post and comment management. In this
    part of the book, you will build a React application representing the UI interface
    of Postagram, where users will see posts and comments and be able to like posts
    or comments, upload profile pictures, and visit other users’ profiles. At the
    end of this part, you will have the required knowledge to use React to handle
    authentication from the frontend side, build UI components from scratch, work
    with React Hooks such as `useState`, `useContext`, and `useMemo`, and send requests
    to a REST API and handle the responses.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这本书的*第一部分*中，我们使用Django构建了Postagram应用程序的后端，包括身份验证功能和帖子及评论管理。在这一部分书中，你将构建一个代表Postagram
    UI界面的React应用程序，用户将看到帖子及评论，并能够点赞帖子或评论，上传个人头像，并访问其他用户的个人资料。在这一部分的最后，你将具备使用React从前端处理身份验证、从头开始构建UI组件、使用React
    Hooks如`useState`、`useContext`和`useMemo`以及向REST API发送请求并处理响应所需的知识。
- en: 'This section comprises the following chapters:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 6*](B18221_06.xhtml#_idTextAnchor116), *Creating a Project with React*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18221_06.xhtml#_idTextAnchor116)，*使用React创建项目*'
- en: '[*Chapter 7*](B18221_07.xhtml#_idTextAnchor144), *Building Login and Registration
    Forms*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18221_07.xhtml#_idTextAnchor144)，*构建登录和注册表单*'
- en: '[*Chapter 8*](B18221_08.xhtml#_idTextAnchor164), *Social Media Posts*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18221_08.xhtml#_idTextAnchor164)，*社交媒体帖子*'
- en: '[*Chapter 9*](B18221_09.xhtml#_idTextAnchor182), *Post Comments*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18221_09.xhtml#_idTextAnchor182)，*帖子评论*'
- en: '[*Chapter 10*](B18221_10.xhtml#_idTextAnchor205), *User Profiles*'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18221_10.xhtml#_idTextAnchor205)，*用户个人资料*'
- en: '[*Chapter 11*](B18221_11.xhtml#_idTextAnchor218), *Effective UI Testing for
    React Components*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18221_11.xhtml#_idTextAnchor218)，*针对React组件的有效UI测试*'
