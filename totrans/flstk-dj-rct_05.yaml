- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software engineering, testing is a process to check whether the actual software
    product performs as expected and is bug free.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to test software through both manual and automated tests.
    But in this project, we’ll focus more on **automated testing**. However, we’ll
    first dive into the different ways of testing software, including their pros and
    their cons, and also talk about the concept of the **testing pyramid**. We’ll
    also check the tools needed to add tests to a Django application and add tests
    to the models and the viewsets. This chapter will help you understand testing
    for developers and also how to write tests for a Django API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the testing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for Django models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for Django viewsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code of the current chapter at this link: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5).'
  prefs: []
  type: TYPE_NORMAL
- en: What is testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make it simple, testing is finding out how well something works.
  prefs: []
  type: TYPE_NORMAL
- en: However, the process comprises a group of techniques to determine the correctness
    of the application under a script or manual test directly on the user interface.
    The aim is to detect failures, including bugs and performance issues, in the application,
    so that they can be corrected.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, testing is done by comparing the software requirements to
    the actual software product. If one of the requirements is to make sure that input
    only accepts numbers and not characters or files, a test will be conducted to
    check whether the input has a validation system to reject non-number values in
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: However, testing also involves an examination of code and the execution of code
    in various environments and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing is the process of examining the behavior of the software under
    test for validation or verification. It considers the attributes of reliability,
    scalability, reusability, and usability to evaluate the execution of the software
    components (servers, database, application, and so on) and find software bugs,
    errors, or defects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software testing has a lot of benefits, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost effectiveness**: Testing any software project helps the business save
    money in the long run. As the process helps detect bugs and check whether newly
    added features are working in the system without breaking things, it’s a great
    technical debt reducer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: If testing is done well, it can be a quick way to detect security
    risks and problems at an early stage before deploying a product to the whole world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product quality**: Testing helps with performance measurement, making sure
    that the requirements are respected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is software testing important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing your software is important because it helps reduce the impact of bugs
    through bug identification and resolution. Some bugs can be quite dangerous and
    can lead to financial losses or endanger human life. Here are some historical
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://lexingtontechnologies.ng/software-testing/](https://lexingtontechnologies.ng/software-testing/).'
  prefs: []
  type: TYPE_NORMAL
- en: In April 1999, $1.2 billion were lost due to the failure of a military satellite
    launch. To date, this is the costliest accident in the history of the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2014, the giant Nissan recalled over 1 million cars from the market because
    of a software failure in the airbag sensory detectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2014, some of Amazon's third-party retailers lost a lot of money because
    of a software glitch. The bug affected the price of the products, reducing them
    to 1p.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2015, a software failure in the **Point of sales** (**POS**) system of Starbucks
    stores caused the temporary closure of more than 60% of their stores in the US
    and Canada.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2015, an F-35 fighter plane fell victim to a software bug, which prevented
    it from detecting or identifying targets correctly. The sensor on the plane was
    unable to identify threats even from their own planes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2016, Google reported a bug affecting Windows 10 machines. The vulnerability
    allowed users to escape security sandboxes through a flow in the win32k system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the various types of testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing is typically classified into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: This type of testing comprises unit, integration, user
    acceptance, globalization, internationalization testing, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional testing**: This type of testing checks for factors such as
    performance, volume, scalability, usability, and load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance testing**: This type of testing considers regression and maintenance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, these tests can also be classified into two different types:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let’s see what manual testing is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding manual testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Manual testing** is the process of testing software manually to find defects
    or bugs. It’s the process of testing the functionalities of an application without
    the help of automation tools.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of manual testing is when test users are called to test an application
    or a special feature. They can be asked to test a specific form, push the application
    to its limits when it comes to performance, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manual testing has a lot of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s very useful to test user interface designs and interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to learn for new testers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes user experience and usability into consideration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s cost-effective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, manual testing also has some cons:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires human resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s time-consuming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testers consider test cases based on their skills and experience. This means
    that a beginner tester may not cover all the functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if manual testing sounds very appealing, it can be quite a time- and resource-consuming
    exercise, and developers definitely do not make really good manual testers. Let’s
    see how automated testing can erase the cons of manual testing and place better
    development at the center of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding automated testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Automated testing** is simply the process of testing software using automation
    tools to find defects. These automation tools can be scripts written in the language
    used to build the application or some software or drivers (such as **Selenium**,
    **WinRunner**, and **LoadRunner**) to make automated testing easier and faster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Automated testing fixes the cons of manual testing, and it also has more advantages,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster in execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cheaper than manual testing in the long run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More reliable, powerful, and versatile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very useful in regression testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to provide better test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible to run without human intervention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much cheaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, automated testing is also inconvenient in some ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It is expensive at the beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a huge cost of maintenance when requirements change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated testing tools are expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real value of automated testing and manual testing comes when each is used
    in the right environment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, manual testing is much more useful on frontend projects where you
    want to test the usability and user experience. Automated testing can be useful
    to test methods or functions in the code and is very useful for finding bugs or
    security issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on writing automated tests in Python. As we are
    developing an API, we want to make sure that the system is reliable and behaves
    as we want it to, but it should also be secure against the possible issues of
    the next added feature.
  prefs: []
  type: TYPE_NORMAL
- en: This said, let’s talk about testing in Django and introduce the notion of **test-driven**
    **development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing in Python, particularly in Django, is very simple and easy. The framework
    actually provides many tools and utilities you can use to write tests for the
    models, serializers, or views in the application.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Python ecosystem for testing relies a lot on one tool to write
    tests, and this tool has deep integration with Django. The tool is named **Pytest**
    ([https://docs.pytest.org](https://docs.pytest.org)) and is a framework for writing
    small and readable tests. Used with Django, Pytest is mainly used for API testing
    by writing code to test API endpoints, databases, and user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why use Pytest? Well, it has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It is free and open source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a simple syntax and is very easy to start with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically detects test files, functions, and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run multiple tests in parallel, increasing the performance and the speed
    of running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use Pytest in this project to write two kinds of tests: **integration
    tests** and **unit tests**.'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to code, let’s learn about integration testing and unit testing
    by considering the concepts of TDD and the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The testing pyramid is a framework that can help developers start with testing
    to create high-quality software. Basically, the testing pyramid specifies the
    types of tests that should be included in an automated test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, remember that the testing pyramid operates at three levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the positions of each of these levels in the pyramid
    and how they are prioritized in terms of the speed performance and level of integration
    or isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The testing pyramid](img/Figure_5.1_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the base level is occupied by unit testing. Unit tests
    target individual components or functionality to check whether they work as expected
    in isolated conditions. In our backend project, an example would be to test whether
    the `like_post` method on the `User` class model actually performs as intended.
    We are not testing the whole `User` model; we are testing one method of the `User`
    model class.
  prefs: []
  type: TYPE_NORMAL
- en: It’s definitely a good habit to write a lot of unit tests. They should comprise
    at least 60% of all the tests in your code base because they are fast, short,
    and test a lot of components.
  prefs: []
  type: TYPE_NORMAL
- en: On the second level, you have integration tests. If unit tests verify small
    pieces of a code base, integration tests test how this code interacts with other
    code or other parts of the software. A useful, albeit controversial, example of
    integration testing is writing a test for a viewset. When testing a viewset, you
    are also testing the permissions, the authentication classes, the serializers,
    the models, and the database if possible. It’s a test of how the different parts
    of the Django API work together.
  prefs: []
  type: TYPE_NORMAL
- en: An integration test can also be a test between your application and an external
    service, a payment API, for example.
  prefs: []
  type: TYPE_NORMAL
- en: On the third level at the top of the pyramid, you have end-to-end tests. These
    kinds of tests ensure that the software is working as required. They test how
    the application works from beginning to end.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll focus on unit and integration testing. Note that integration
    tests are the subject of some misunderstandings that will be cleared up once we
    define them. According to my personal experience, unit tests in Django are written
    more on the model and serializer side of each application. They can be used for
    testing the creation of an object in the database as well as for retrieving, updating,
    or deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding viewset tests, I believe that they can act as integration tests because
    running them calls on permissions, authentication, serializers, validation, and
    also models, depending on the action you are performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to unit tests, they are more effective when using TDD, which comprises
    software development practices that focus on writing unit test cases before developing
    the feature. Even if it sounds counter-intuitive, TDD has a lot of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures optimized code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ensures the application of design patterns and better architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps the developer understand the business requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the code flexible and easier to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we didn’t particularly respect the TDD rule in the book. We relied
    on the Django shell and a client to test the feature of the REST API we are building.
    For the next features that will be added to the project, tests will be written
    before coding the feature.
  prefs: []
  type: TYPE_NORMAL
- en: With concepts such as TDD, unit and integration testing, and testing pyramid
    understood, we can now configure the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pytest, taken alone, is simply a Python framework to write unit tests in Python
    programs. Thankfully, there is a plugin for Pytest to write tests in Django projects
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install and configure the environment for testing by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is installed, create a new file called `pytest.ini` at the
    root of the Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: pytest.ini
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, run the `pytest` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Great! Pytest is installed in the project, and we can write the first test in
    the project to test the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pytest environment is configured, so let’s see how we can write a simple
    test using Pytest.
  prefs: []
  type: TYPE_NORMAL
- en: At the root of the project, create a file called `tests.py`. We’ll simply write
    a test to test the sum of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the TDD concept, we’ll write the test first and make it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function is written to check for a condition, justifying the usage of the
    `assert` Python keyword. If the condition after the `assert` is true, the script
    will continue or stop the execution. If that’s not the case, an assertion error
    will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `pytest` command, you’ll receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Failing tests](img/Figure_5.2_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Failing tests
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, we are sure that the test has failed. Let’s now write
    the feature to pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, `tests.py`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `pytest` command again in the terminal. Everything should now
    be green:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3 – \uFEFFTest passes successfully](img/Figure_5.3_B18221.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Test passes successfully
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have written the first test in the project using Pytest. In the next
    section, we’ll be writing tests for the models of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for Django models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When applying testing to a Django project, it’s always a good idea to start
    with writing tests for the models. But why test the models?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it gives you better confidence in your code and the connections to the
    database. It’ll make sure that methods or attributes on the model are well represented
    in the database, but it can also help you with better code structure, resolving
    bugs, and building documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s start by writing tests for the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for the User model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `core/user` directory, create a new file called `tests.py`. We’ll
    write tests to create a user and a simple user:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the imports and the data to create the user have been added, we can write
    the test function:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Above the `test_create_user` function, you’ll probably notice some syntax. It’s
    called a decorator, and it’s basically a function that takes another function
    as its argument and returns another function.
  prefs: []
  type: TYPE_NORMAL
- en: '`@pytest.mark.django_db` gives us access to the Django database. Try to remove
    this decorator and run the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll get an error output with a similar message at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Well, re-add the decorator and run the `pytest` command and all tests should
    pass normally.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do another test to make sure that the creation of `superuser` works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new dictionary containing the data needed to create `superuser`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the function that tests the creation of `superuser`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests again, and everything should be green.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that we have a better understanding of how `pytest` works for tests,
    let’s write tests for the `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for the Post model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a model, we need to have a user object ready. This will also be the
    same for the `Comment` model. To avoid repetition, we’ll simply write **fixtures**.
  prefs: []
  type: TYPE_NORMAL
- en: A fixture is a function that will run before each test function to which it’s
    applied. In this case, the fixture will be used to feed some data to the tests.
  prefs: []
  type: TYPE_NORMAL
- en: To add fixtures in the project, create a new Python package called `fixtures`
    in the `core` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `core/fixtures` directory, create a file called `user.py`. This file
    will contain a user fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: core/fixtures/user.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `@pytest.fixture` decorator labels the function as
    a fixture. We can now import the `user` function in any test and pass it as an
    argument to the `test` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `core/post` directory, create a new file called `tests.py`. This
    file will then test for the creation of a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are importing the `user` function from `user.py` in the fixtures
    directory and passing it as an argument to the `test_create_post` test function.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `pytest` command, and everything should be green.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working test for the `Post` model, let’s write tests for
    the `Comment` model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for the Comment model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests for the `Comment` model requires the same steps as the tests for
    the `Post` model. First of all, create a new file called `post.py` in the `core/fixtures`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: This file will contain the fixture of a post, as it’s needed to create a comment.
  prefs: []
  type: TYPE_NORMAL
- en: But the `post` fixture will also need a `user` fixture. Thankfully, it’s possible
    with Pytest to inject fixtures into other fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the `post` fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: core/fixtures/post.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great! With the fixtures added, we can now write the test for comment creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core/comment/` directory, create a new file called `tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests with the `pytest` command, and everything should be green.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We’ve just written tests for all the models in the project. Let’s move
    on to writing tests for the viewsets.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for your Django viewsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Viewsets or endpoints are the interfaces of the business logic that the external
    clients will use to fetch data and create, modify, or delete data. It’s always
    a great habit to have tests to make sure that the whole system, starting from
    a request to the database, is working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to write the tests, let’s configure the Pytest environment to
    use the API client from DRF.
  prefs: []
  type: TYPE_NORMAL
- en: The API client is a class that handles different HTTP methods, as well as features
    such as authentication in testing, which can be very helpful for directly authenticating
    without a username and password to test some endpoints. Pytest provides a way
    to add configurations in a testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `conftest.py` at the root of the project. Inside the file,
    we’ll create a fixture function for our custom client:'
  prefs: []
  type: TYPE_NORMAL
- en: conftest.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Great! We can now directly call this client in the next tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by testing the authentication endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `core/auth` directory, create a file named `tests.py`. Instead of
    writing test functions directly, we write a class that will contain the testing
    methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the `test_login` method to the `TestAuthenticationViewSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Core/auth/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method basically tests the login endpoint. We are using the client fixture
    initialized in the `conftest.py` file to make a `post` request. Then, we test
    for the value of `status_code` of the response and the response returned.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `pytest` command, and everything should be green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add tests for the `register` and `refresh` endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, within the `test_refresh` method, we log in to get a
    refresh token to make a request to get a new access token.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `pytest` command again to run the tests, and everything should be green.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to writing tests for `PostViewSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for PostViewSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting to write the viewsets tests, let’s quickly refactor the code
    to simply write the tests and follow the DRY rule. Inside the `core/post` directory,
    create a Python package called `tests`. Once it’s done, rename the `tests.py`
    file in the `core/post` directory to `test_models.py` and move it to the `core/post/tests/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the same directory, create a new file called `test_viewsets.py`. This
    file will contain tests for `PostViewSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`PostViewSet` handles requests for two types of users:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each type of user has different permissions on the `post` resource. So, let’s
    make sure that these cases are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For these tests, we are forcing authentication. We want to make sure that authenticated
    users have access to the post’s resources. Let’s now write a test method for post
    creation, updating, and deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests, and the outcomes should be green. Now, for the anonymous users,
    we want them to access the resource in reading mode, so they can’t create, modify,
    or delete a resource. Let’s test and validate these features:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests to make sure everything is green. After that, let’s test the
    forbidden methods:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests again. Great! We’ve just written tests for the post viewset. You
    should now have a better understanding of testing with viewsets.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly write tests for `CommentViewSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for CommentViewSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting to write the viewset tests, let’s also quickly refactor the
    code for writing the tests. Inside the `core/comment` directory, create a Python
    package called `tests`. Once it’s done, rename the `tests.py` file in the `core/post`
    directory to `test_models.py` and move it to the `core/comment/tests/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the same directory, create a new file called `test_viewsets.py`. This
    file will contain tests for `CommentViewSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in `PostViewSet`, we have two types of users, and we want to write
    test cases for each of their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before creating comments, we need to add comment fixtures. Inside
    the `core/fixtures` directory, create a new file called `comment.py` and add the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/fixtures/comment.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, inside `core/comment/tests/test_viewsets.py`, add the following
    content first:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add tests to the list and retrieve comments as authenticated users:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that these tests pass by running the `pytest` command. The next step
    is to add tests for comment creation, updating, and deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests again to make sure everything is green. Let’s write tests for
    the anonymous users now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to make sure that they can access the resources with
    the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make sure that an anonymous user can’t create, update, or
    delete a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding cases, the data `dict` is empty because we are expecting error
    statuses.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests again to make sure that everything is green!
  prefs: []
  type: TYPE_NORMAL
- en: And voilà. We’ve just written tests for `CommentViewSet`. We also need to write
    tests for the `UserViewSet` class, but this will be a small project for you.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for the UserViewSet class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let’s do a quick hands-on exercise. You’ll write the code
    for the `UserViewSet` class. It’s quite similar to the other tests we’ve written
    for `PostViewSet` and `CommentViewSet`. I have provided you with the structure
    of the class, and all you have to do is to write the testing logic in the methods.
    The following is the structure you need to build on:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/tests/test_viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the requirements concerning the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_list`: An authenticated user should enable a list of all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_retrieve`: An authenticated user can retrieve resources concerning a
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_create`: Users cannot create users directly with a `POST` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_update`: An authenticated user can update a `user` object with a `PATCH`
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the solution to this exercise here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about testing, the different types of testing, and
    their advantages. We also introduced testing in Django using Pytest and wrote
    tests for the models and viewsets. These skills acquired in writing tests using
    the TDD method help you better design your code, prevent bugs tied to code architecture,
    and improve the quality of the software. Not to forget, they also give you a competitive
    advantage in the job market.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter of *Part 1*, *Technical Background*. The next part
    will be dedicated to React and connecting the frontend to the REST API we’ve just
    built. In the next chapter, we’ll learn more about frontend development and React,
    and we’ll also create a React project and run it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a unit test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the testing pyramid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Pytest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Pytest fixture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: Building a Reactive UI with React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 1* of our book, we built the backend of the Postagram application using
    Django, with authentication features and post and comment management. In this
    part of the book, you will build a React application representing the UI interface
    of Postagram, where users will see posts and comments and be able to like posts
    or comments, upload profile pictures, and visit other users’ profiles. At the
    end of this part, you will have the required knowledge to use React to handle
    authentication from the frontend side, build UI components from scratch, work
    with React Hooks such as `useState`, `useContext`, and `useMemo`, and send requests
    to a REST API and handle the responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18221_06.xhtml#_idTextAnchor116), *Creating a Project with React*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18221_07.xhtml#_idTextAnchor144), *Building Login and Registration
    Forms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18221_08.xhtml#_idTextAnchor164), *Social Media Posts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18221_09.xhtml#_idTextAnchor182), *Post Comments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18221_10.xhtml#_idTextAnchor205), *User Profiles*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18221_11.xhtml#_idTextAnchor218), *Effective UI Testing for
    React Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
