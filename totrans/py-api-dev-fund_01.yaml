- en: 1\. Your First Step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Replicate the concepts of RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the meaning of different HTTP methods and statuses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get hands-on experience on PyCharm IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a RESTful API and execute CRUD using Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSON messages to communicate with the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test API endpoints using Postman and httpie/curl command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter introduces API and explains the concepts of web services, API and
    REST.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are in the internet era, a world where everything is connected. Data flows
    seamlessly from one place to another. We can get all the information in the world
    with a few clicks on a website. Take Skyscanner as an example, we just need to
    put in the date and location of our trips, and it can find us the cheapest flight
    in a split second; the hero behind the scenes that provides this data is API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn what a web service, an API, and REST are. We
    will start by teaching the fundamental concepts of APIs. Then we will look at
    real-life examples of how different web services (Google, Facebook, and so on)
    use the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will develop our first simple Python RESTful API using Python. Python
    is a popular and powerful programming language. Apart from its extensive use in
    the realm of artificial intelligence, it is also widely used in web application
    development, big data analysis, web scraping, and process automation. What makes
    Python excel in so many areas is the extensive number of frameworks available.
    The frameworks do all the heavy lifting jobs and that allows the developers to
    focus on the actual application design and development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will see how data is encoded and communicated between the
    frontend and the backend. You will learn technical details about the JSON format,
    the HTTP protocol, HTTP status codes, and so on. All the development work will
    be verified and tested using Postman and httpie/curl. We will take you through
    the whole process of web application development. Not only will you learn the
    essential aspects of developing a RESTful API, but you will also learn about the
    thinking process, design, development, testing, and even deployment. This is a
    journey of learning the complete software development life cycle. Let's embark
    on our exciting journey now!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API stands for application programming interface; it is an interface for the
    website (or mobile application) to communicate with the backend logic. Simply
    put, it is like a messenger that takes a request from the users and sends the
    request to the backend system. Once the backend system responds, it will then
    pass that response to the users. A metaphor for this is a waiter/waitress, who
    can understand different customers' orders. They will then act as a middleman
    between the customers and the chefs in the kitchen.
  prefs: []
  type: TYPE_NORMAL
- en: If you were the boss of the restaurant, the key benefit of having a waiter/waitress
    here between your customer and the kitchen is that the customers will be shielded
    from seeing your business secrets. They don't need to know how the meal is prepared.
    They just need to send an order through the waiter/waitress, and they will get
    the meal they ordered. In this scenario, the waiter acts like the API. The following
    figure helps illustrate the analogy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The waiter acting as the API for the customer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: The waiter acting as the API for the customer'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly, in computer science, one of the key benefits of having API is encapsulation.
    We encapsulate the logic so that people outside won't be able to see it. With
    this arrangement, big companies with sensitive information are willing to provide
    services to the world through APIs, confident that their internal information
    won't be revealed. Take Skyscanner again as an example. The company is comfortable
    with using an API to allow customers to book their flights, but at the same time,
    personal data from other customers that are stored in their internal database
    won't leak.
  prefs: []
  type: TYPE_NORMAL
- en: An API is also a standard interface that can communicate with different types
    of frontend Terminals, they can be mobile applications or websites. As long as
    the frontend is sending the same request to the API, it will get the same result
    back. If we go back to our metaphor, the waiter/waitress will serve all kinds
    of customers, regardless of their gender, age, language, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine you are a software engineer at Skyscanner who is responsible for
    developing an API. What will your job be? Let me tell you. Your job will be to
    write a program that can take booking requests (date and location) from customers
    through the website, and then look up matching flights in the Skyscanner database
    and return the flight details to the customers. Throughout this book, you will
    be our API engineering intern. We will guide you, step by step, through the process
    of developing a RESTful API project that can serve the users of your system.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST stands for Representational State Transfer. It was first defined in Dr.
    Roy Fielding's dissertation (Architectural Styles and the Design of Network-Based
    Software Architectures) back in 2000\. This dissertation is considered to be the
    bible in the web domain. REST is not a standard or protocol; it is more like a
    software architectural style. Many engineers follow this architectural style to
    build their applications, such as eBay, Facebook, and Google Maps. These web applications
    serve huge amounts of traffic every second, so you can see that REST really is
    a scalable architecture style. And when we say RESTful API, we are referring to
    an API that conforms to the REST constraints/principles.
  prefs: []
  type: TYPE_NORMAL
- en: REST Constraints/Principles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are five important constraints/principles for the REST architecture style:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client-server: There is an interface between the client and the server. The
    client and server communicate through this interface and are independent of each
    other. Either side can be replaced as long as the interface stays the same. Requests
    always come from the client-side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stateless: There is no concept of state for a request. Every request is considered
    to be independent and complete. There is no dependence on the previous request
    nor dependence on a session to maintain the connection status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cacheable: Things are cacheable on the server or client-side to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Layered system: There can be multiple layers in the system, and the goal here
    is to hide the actual logic/resources. These layers can perform different functions,
    such as caching and encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uniform interface: The interface stays the same. This helps to decouple the
    client and server logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand what REST is and make sure we are implementing the REST
    style, we can simply talk about the HTTP protocol. HTTP is an implementation of
    the REST architecture style. It is short for HyperText Transfer Protocol and is
    the standard protocol used on the worldwide web. We use it every day to browse
    different websites. That's why all the websites we visit are prefixed with http.
  prefs: []
  type: TYPE_NORMAL
- en: In the HTTP protocol, there are different types of service request methods.
    Each service request method has a special definition that is specific to it. When
    the frontend interface interacts with the backend API through a URL, they need
    to, at the same time, define the HTTP method for this request. Different HTTP
    methods are like different service counters. For example, reading and creating
    data are completely different services, so they should be handled by different
    service counters, meaning different HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: For reading data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: For creating data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: For updating data by completely replacing data with new content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: For updating data, but by partially modifying a few attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: For deleting data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply put, different HTTP methods are like the verbs for REST API. They are
    used for performing different actions on the same set of data.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Methods and CRUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily build a RESTful API by leveraging what has already been provided
    by the HTTP protocol. Let's take a look at the HTTP methods that we can use to
    communicate with the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will build a recipe sharing platform with a RESTful API as
    the backend. This platform will allow users to create and share their own recipes.
    At the same time, users will also be able to read recipes shared by other users.
    Using this recipe sharing platform as an example, to achieve these functionalities,
    we will need our API to be able to perform different actions on the recipes. We
    can leverage different HTTP methods here. For example, we can use the `GET` method
    to request `http://localhost:5000/recipes` for all the recipes. We can use the
    `POST` method to request `http://localhost:5000/recipes` to create a new recipe.
    We can also use the `DELETE` method to request `http://localhost:5000/recipes/20`
    to delete a recipe with `ID = 20`. Please refer to the following table for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: HTTP methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: HTTP methods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that asking the backend API to work for us is simple. We can simply
    use the HTTP protocol to communicate our request.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with this recipe sharing platform, you can see the majority of the
    actions we require will revolve around CREATE, READ, UPDATE, and DELETE. This
    is generally true for all other web applications as well. In the developer community,
    we call this CRUD in short. In a nutshell, CRUD models the life cycle of database
    record management.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling our web applications this way can help us easily construct a functioning
    web system, as these actions are related to the HTTP methods. Constructing our
    application with this architecture is simple, powerful, and highly readable.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably imagine, we will need to send information to the backend
    server. For example, you may want to store a recipe in the backend database. You
    send the recipe over HTTP with a pre-agreed format with the backend. A pre-agreed
    format can be understood as a language used to communicate with the waiter/waitress
    in our previous metaphor. In real life, we have different languages, such as English,
    German, Chinese, and so on. We need to speak the right language for the other
    side to understand. In the web API domain, there are two prevalent standards,
    JSON and XML. We will mainly talk about JSON here because it is more readable
    and widely adopted.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a simple plaintext format that
    is capable of representing complex data structures. We can use this format to
    represent strings, numbers, arrays, and even objects. Once we have the information
    "JSONified," we can use this widely adopted format to communicate with the API.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to show you what a JSON format file looks like. In the following
    example, you will see that we are representing two recipes in JSON format. A JSON
    document is a plaintext document; there is no encryption here. It is so readable
    that I am sure you can already tell (without further explanation) that there are
    two recipes here, each with an ID, name, and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few notes on JSON syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are enclosed by `[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects can be represented by `{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names/values always exist in pairs, and are delimited by "`:`"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are enclosed by ""
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is a sample code file with JSON syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Status Codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP status code is a code that is returned in the HTTP protocol. It is usually
    hidden from users, so you probably didn't realize it exists. In fact, every HTTP
    response from the server contains a status code. And as we construct our RESTful
    API, we need to comply with the HTTP protocol. The status code helps the frontend
    client understand the status of their request, that is, whether it is a success
    or failure. For example, there could be a client request about creating a record
    in the backend database. In that case, once the database record has been successfully
    created, the server should return an HTTP status code 201 (Created). If there
    is an error (such as a syntax error in the JSON document), the server should return
    an HTTP status code 400 (Bad Request) instead.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used HTTP Status Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s discuss some commonly used status codes. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 200 OK means the request has been successful. The request could be a GET, PUT,
    or PATCH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 201 Created means the POST request has been successful and a record has been
    created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 204 No Content means the DELETE request has been successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 400 Bad Request means there is something wrong with the client request. For
    example, there is a syntax error in the JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 401 Unauthorized means the client request is missing authentication details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 403 Forbidden means the requested resource is forbidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 Not Found means the requested resource doesn't exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open API is a third-party API that is open to use. There are plenty of them
    available out there. Companies are eager to open their APIs to expand their user
    base but at the same time keep their source code proprietary. These APIs can be
    accessible by us as well. Let's take a look at some of the APIs from Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use the HTTP GET method to access `https://graph.facebook.com/{page_id}/feed`,
    which will give us the feeds on the Facebook page with `ID = {page_id}`. We can
    send an HTTP request using the `POST` method to `https://graph.facebook.com/{page_id}/feed`,
    and then we can create a post on the Facebook page with `ID = {page_id}`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Facebook fans page API details can be found at [https://developers.facebook.com/docs/pages/publishing](https://developers.facebook.com/docs/pages/publishing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at another internet giant, Google. Google also provides some
    Gmail APIs that we can use to manage the email labels in our mailbox. Here is
    a screenshot from the Gmail API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Gmail API documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Gmail API documentation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Gmail Label API is available at [https://developers.google.com/gmail/api/v1/reference/](https://developers.google.com/gmail/api/v1/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: The Flask Web Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask is a web framework that we can use to easily build a web application.
    Web applications usually need some core functionalities, such as interacting with
    client requests, routing URLs to resources, rendering web pages, and interacting
    with backend databases. A web application framework such as Flask provides the
    necessary packages, modules that do the heavy lifting. So, as a developer, we
    only need to focus on the actual application logic.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, other available web frameworks available on the market.
    One strong competitor of Flask is Django. It is also a Python web framework. The
    reason why we choose Flask in this book is that Flask is minimalistic. It is regarded
    as a micro-web-framework that only provides the absolutely essential packages
    for developers to start with. Because of that, it is easy to learn and is great
    for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: And later, if we want to build further functions, there is a vast number of
    Flask extensions. You will see the power of Flask as we progress in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Simple Recipe Management Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s do some simple exercises to test your knowledge. We are going to build
    a recipe-sharing platform throughout this book, and the API is the interface we
    expose to the public. We will first define what functions we want to provide and
    the corresponding URLs. These are the basic functions that we will probably need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: HTTP methods and functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: HTTP methods and functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A typical recipe should have the following attributes
  prefs: []
  type: TYPE_NORMAL
- en: '`ID`: The unique identifier for the recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: The name of the recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: The description of the recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to build an API that lists all the recipes stored in our system.
    The API will be designed to return different results with different URLs. For
    example, `http://localhost:5000/recipes` is going to give us all the recipes stored
    in our system, while `http://localhost:5000/recipes/20` will give us the recipe
    with `ID = 20`. Upon successful recipe retrieval, we will also see the HTTP status
    is set to 200 (OK). This indicates that our request has been successful.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new recipe, we use the HTTP POST method to query `http://localhost:5000/recipes`
    with all the necessary parameters to describe our recipe in JSON format. The JSON
    format is simply a key/value pair. If our request is successful, the recipe will
    be created in the backend and will return HTTP status 201 (Created). Together
    with the HTTP status, it will also send the recipe that has just been created
    in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: When we update a recipe, we use the HTTP PUT method to send the data to `http://localhost:5000/recipes/20`
    with all the necessary parameters for the updated recipe in JSON format. If our
    request is successful, the recipe will be updated in the backend and it will return
    HTTP status 200 (OK). Together with the HTTP status, it will also send the updated
    recipe in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: When we delete a recipe, we can use the HTTP Delete method to send the data
    to `http://localhost:5000/recipes/20`. This will remove the recipe with `ID =
    20`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know where we are heading to, let's roll up our sleeves and get our
    hands dirty!
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always recommended for developers to develop their application inside
    a virtual environment instead of directly on their local environment.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that virtual environments are independent application development
    environments. We can create multiple virtual environments on a local machine,
    and these virtual environments can have their own version of Python, their own
    packages, their own environment variables, and so on. These virtual environments
    won't interfere with each other even though they are built on the same local machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will create a development project in the PyCharm
    IDE. We will show you how to set up a virtual environment for this project in
    PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Building Our First Flask Application'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to build our first Flask application in this exercise. You will
    realize how simple it is to build an application along the way. PyCharm is a great
    **integrated development environment** (**IDE**) with a nice GUI that will make
    our development process easier. We will learn about the workflow of application
    development, including the creation of the application project and installing
    the necessary Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in PyCharm with `basic-api`. PyCharm will automatically
    help us to create a virtual environment for this new project.![Figure 1.5: Creating
    a new project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.5: Creating a new project'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: It's a good practice for projects to run on their own assigned independent virtual
    environments, so these projects can run on different packages and they won't affect
    each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install the necessary packages in our virtual environment. To do that, we can
    create a file named `requirements.txt` in our project and type in the following
    text. We want to install `Flask` (version `1.0.3`) and `httpie` (version `1.0.2):`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following screenshot shows the installation of Flask and httpie in `requirements.txt`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.6: Installing Flask and httpie in requirements.txt'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_01_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.6: Installing Flask and httpie in requirements.txt'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: PyCharm is going to prompt us on the missing package, as shown in the screenshot.
    Clicking on `app.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: To install the Python packages, we can also run the `pip install -r requirements.txt`
    command in Terminal. It will yield the same result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Flask package that we are installing is a web micro-framework. It is extremely
    lightweight and allows us to build a web service with just a few lines of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s type in the following code in `app.py`, then *right-click* on the filename
    of `app.py` in the left panel, and select `app` to execute our first web service
    in Flask:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What this does is it first imports the Flask package in `app.py`, then it instantiates
    a `Flask` object, and finally, it assigns it to the `app` variable. We have created
    the main function as the entry point for our startup script. This subsequently
    brings up the Flask web server. After that, we have defined our first API function,
    `hello`, which returns a "`Hello World`" response. Using the Flask decorator,
    we can route the GET request URL to this function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now open the browser and type `http://localhost:5000`, You will see the string
    **Hello World!**. No special format, just plaintext. This means your first web
    service passed the test, it works!![Figure 1.7: Browser showing Hello World in
    plaintext'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.7: Browser showing Hello World in plaintext'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a very good start! Though this web service merely returns the plain
    text string, we can build a lot of stuff on top of that.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see how simple it is to build a web service using Flask; it is
    literally just a few lines of code. In fact, there are more Flask extensions out
    there that can help us build fancy functions. And be patient, we will talk about
    that in the subsequent chapters. For now, let's stay simple and get ourselves
    familiar with Flask first.
  prefs: []
  type: TYPE_NORMAL
- en: For production-grade applications, data is usually stored in a database. We
    haven't looked at how to interact with the database yet, so for now, we are going
    to simply store them in memory. Since we are building a recipe sharing platform,
    we will be creating two recipes in our next exercise, and we'll let them live
    in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Managing Recipes with Flask'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to work on our recipe management application
    with Flask. We will implement functionality to get recipes, to create recipes,
    and to update recipes. Without further ado, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the complete code, please refer to [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clean up `app.py` and start everything all over again, import the packages
    that we need for this web service from the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The jsonify package here is to convert our Python objects (such as a list) to
    JSON format. It will also change the content type in our HTTP response to application/json.
    Simply put, it takes care of the heavy lifting of converting to JSON format for
    us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we import the `HTTPStatus` enum, which includes different HTTP statuses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For instance, we will have `HTTPStatus.CREATED (201)` and `HTTPStatus.NOT_FOUND
    (404)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an instance of the `Flask` class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the recipes list. We store two recipes in the list. They are stored in
    the memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the route decorator to tell Flask that the `/recipes` route will route
    to the `get_recipes` function, and the `methods = [''GET'']` argument to specify
    that the route decorator will only respond to GET requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Please note that if we don't specify methods argument, the default will still
    be only responding to GET requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After that, use the `jsonify` function to convert the list of recipes to JSON
    format and respond to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After getting a specific recipe, if you only want to retrieve one specific recipe,
    then use the `/recipes/<int:recipe_id>` route to trigger the `get_recipe(recipe_id)`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The syntax `<int:recipe_id>` syntax means the value in the route will be assigned
    to the integer variable id integer variable and can be used in the function. Our
    function `get_recipe(recipe_id)` function will then loop through the whole "`recipes`"
    list and locate the recipe that has the id that we are looking for. If that recipe
    exists, then we will return it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take a closer look at our `get_recipe` function. Get the next recipe in the
    loop by using `recipe = next((recipe for recipe in recipes if recipe[''id''] ==
    recipe_id), None)`. Here, the line `for recipe in recipes` iterates through all
    the recipes in our recipe collection and finds out the recipe with `id = recipe_id`.
    Once we have found it, we store it in the iterator and retrieve it using the next
    function. If there is no such recipe with that ID, `None` will be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will work on the `create_recipe` function, which creates a recipe
    in memory. Use the `/recipes` route to the `create_recipe` function and the "`methods
    = [POST]`" argument to specify that the route decorator will only respond to POST
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, use the `request.get_json` method to get the name and description
    from the client POST request. These two values together with a self-incremented
    id that we generate will be stored in the recipe (dictionary object) and then
    appended to our recipes list. At this point in time, the recipe is created and
    stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, return the recipe that has just been created in JSON format, together
    with an **HTTP 201 (CREATED)** status. The following code highlights this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next part of code is about updating recipes. Again, use the same line of
    code here, `recipe = next((recipe for recipe in recipes if recipe[''id''] == recipe_id),
    None)` to get the recipe with a specific ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next few lines of code say that if we can''t find the recipe, we will return
    a `recipe not found` message in JSON format, together with a `HTTP NOT_FOUND`
    status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we found the recipe, then perform the `recipe.update` function, and put
    in the new name and description you get from the client request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we convert the updated recipe to JSON format using the `jsonify` function
    and return together with a default HTTP status **200 (OK)**. The following code
    highlights this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last few lines of code in our program is for starting up the Flask server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the code is done, *right-click* on the `app.py` file and click **run**
    to start the application. The Flask server will be started up and our application
    is ready to be tested. The full code looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: The final Flask server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: The final Flask server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following sections, we will show you how to test your web service using
    curl/httpie or Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Using curl or httpie to Test All the Endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will go through ways to test the API service endpoints in
    our recipe management application using Command Prompt. Testing is a very important
    step in application development. This is to ensure the functions we developed
    are working as expected. We can use curl or httpie, depending on your personal
    preference. In the subsequent exercise, we will show you both tools.
  prefs: []
  type: TYPE_NORMAL
- en: Curl (or cURL) is a command-line tool that can transfer data using URLs. We
    can use this tool to send requests to our API endpoints and examine the response.
    If you are running on macOS, you don't need to install curl. It is pre-installed
    in the system and you can find it in Terminal. You can also run it in the Terminal
    in PyCharm. However, if you are running on Windows, you need to download and install
    it for free from [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Httpie (aych-tee-tee-pie) is another command-line client that does a similar
    thing. It was built with the goal to improve the communication between the CLI
    (command-line interface) and the web. It is pretty user-friendly. For more details
    about httpie, please refer to [https://httpie.org/](https://httpie.org/).
  prefs: []
  type: TYPE_NORMAL
- en: We added `httpie==1.0.2` in our requirements.txt previously, so PyCharm should
    have already installed it for us. The main benefit of having httpie is it will
    beautifully format the JSON document, making it more readable. And believe me,
    that will save us a lot of time when we move on to verifying the HTTP response
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Testing Our API Endpoints with httpie and curl'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to use httpie and curl to test our API endpoints.
    We will test the functions of getting all the recipes back from the server, and
    also creating/updating the recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first open the Terminal in PyCharm. It is located at the bottom of
    the application. It will look as shown in the following screenshot:![Figure 1.9:
    PyCharm Terminal'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.9: PyCharm Terminal'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type in the following httpie command to get the recipes from our API endpoint,
    [`http://localhost:5000/recipes`](http://localhost:5000/recipes); we will be using
    the HTTP GET method here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you prefer to do it the curl way, use the following command instead. Note
    that we have different parameters here: `-i` is for showing the header in the
    response and `-X` is for specifying the HTTP method. We will be using `GET` here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, let''s create a recipe. This time, use the HTTP `POST` method,
    as we have lots of information that cannot be encoded in the URL. Please take
    a look at the following httpie command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then following is the curl command. The -H here is to specify the header
    in the request. Put in `Content-Type: application/json`, as we are going to send
    over the details of the new recipe in JSON format. The `-d` here is to specify
    the HTTP `POST` data, which is our new recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `@app.route(''/recipes'', methods=[''POST''])` in the backend to catch
    this client request and invoke the `create_recipe` function. It will get the recipe
    details from the client request and save it to a list in the application memory.
    Once the recipe is successfully stored in the memory, it will return an HTTP status
    of `201 CREATED`, and the new recipe will also be returned in the HTTP response
    for us to verify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, get all the recipes again to verify if our previous recipe was really
    created successfully. We expect to receive three recipes in the response now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use either one of the preceding commands. They do the same thing, which is to
    trigger the `get_recipes` function and get us all the recipes currently stored
    in the application memory in JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following response, we can see that the HTTP header is saying OK, and
    the Content-Length is now slightly longer than our previous response, that is,
    `252` bytes. This makes sense because we are expecting to see one more recipe
    in the response. The Content-Type is again `application/json`, with the body storing
    the recipes in JSON format. Now we can see our new recipe with ID `3`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Cool! So far, we are in pretty good shape. Now, test our application by trying
    to modify the recipe with ID 3\. Use the HTTP `PUT` method and send over the modified
    name and description of the recipe to `localhost:5000/recipes/3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the curl command. Again, `-H` is to specify the header in
    the HTTP request, and we are setting that to `"Content-Type: application/json"`;
    `-d` is to specify that our data should be in JSON format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If things are working properly, then the client request will be caught by the
    `@app.route(''/recipes/<int:recipe_id>'', methods=[''PUT''])` route. It will then
    invoke the `update_recipe(recipe_id)` function to look for the recipe with the
    passed-in `recipe_id`, update it, and return it. Together with the updated recipe
    in JSON format, we will also receive the HTTP status of `OK` (`200`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alright, all good so far. Now, go on and see if we can get a particular recipe.
    To do this, send a request to `localhost:5000/recipes/3` to get the recipe with
    ID `3`, and confirm whether our previous update was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use a `curl` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application will look for the recipe with the `recipe_id` and return it
    in JSON format, together with an HTTP status of `200 OK`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, what if we try a recipe ID that we know doesn''t exist? How will the application
    behave? Test it out with the httpie command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the following `curl` command, which will do the same thing
    as in the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, `@app.route(''/recipes/<int:recipe_id>'', methods=[''GET''])` in
    the application will catch this client request and try to look for the recipe
    with ID = 101\. The application will return with an HTTP status of `message: "recipe
    not found"` in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your application passed the test, congratulations! It is a pretty solid implementation.
    You can choose to perform more tests by yourself if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Postman is a handy tool for API testing. It has a user-friendly GUI that we
    can send HTTP requests through. It allows us to send requests with different HTTP
    methods (that is, GET, POST, PUT, and DELETE) and we can check the response from
    the server. With this tool, we can easily test our API by sending a client request
    and checking the HTTP response. We can also save our test cases and group them
    into different collections.
  prefs: []
  type: TYPE_NORMAL
- en: The Postman GUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume you should have already installed Postman by following the steps in
    the preface. When you open Postman, you should see the screen shown in the following
    screenshot. The left-hand side is a navigation panel for you to navigate through
    your historical or saved requests. In Postman, your requests are going to be organized
    into collections, which is like a folder in the filesystem. You can put relevant
    saved requests in the same collection.
  prefs: []
  type: TYPE_NORMAL
- en: The top panel is for you to compose your request. As you have learned from the
    command-line testing tool, we can have different HTTP verbs (such as GET and PUT).
    We also need to put in an API endpoint to send the request to. For some requests,
    you may also need to pass in additional parameters. These can all be done in Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom panel shows the server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: Postman interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: Postman interface'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sending a GET Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sending a GET request is simple; we just need to fill in the target URL:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `GET` as our HTTP method in the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the request URL (such as `http://localhost:5000/API1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending a POST Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sending a POST request, however, will take a bit more work, because very often,
    we will put extra data in the request. For example, if you want to send some JSON
    data to an API endpoint, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **POST** as our HTTP method in the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the request URL (such as `http://localhost:5000/API2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Body** Tab. Also, select the "**raw**" radio button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose "**JSON (application/json)**" from the right drop-down menu. Put in
    the JSON data to the Body content area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving a Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Very often, you will want to save your request for later use. This saving feature
    in Postman is particularly useful during regression testing. To save your request,
    you just need to click the save button, follow the on-screen instructions, and
    save it in a collection. Then you will see your saved request in the left navigation
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may need to open an account in Postman before you can save the request.
    Please follow the on-screen instructions accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about Postman, click on the "Bootcamp" button at the
    bottom of Postman. You will see interactive tutorials showing you how to use Postman
    step-by-step on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Sending Requests to Our APIs Using Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have learned how to use Postman, we are going to test our application
    using Postman instead of the curl/httpie command-line testing tools. In this activity,
    we will be using this tool to test the CRUD functions in our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a request in Postman and get all the recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `POST` request to create a recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a request to get all the recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send an update request to modify the recipe that we have just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a request to get a specific recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a request to search for a recipe that doesn't exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 286.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your application passed the test, congratulations! It is a pretty solid implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Automated Testing Using Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we would like to show you how we can use Postman as a powerful
    automatic testing tool. An automatic testing tool allows us to repeatedly send
    requests to the APIs, thus achieve testing automation. Postman allows us to do
    this. We can save historical requests in a collection so that you can reuse the
    same test cases next time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover the cursor over the request; the **Save Request** button will appear:![Figure
    1.11: Saving the request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.11: Saving the request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the Save Request button, and you will see a dialog box popping up,
    asking for more information. Type in **Get all recipes** for the request name
    and click on **Create Collection** at the bottom. Then, type in **Basic API**
    as the collection name and tick to confirm. Click **Save to Basic API**:![Figure
    1.12: Putting in information for saving the request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.12: Putting in information for saving the request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The collection will then be created. Now, save our request to this collection
    for future use. We can also click on the **Collections** tab to see all the requests
    in that collection:![Figure 1.13: Creating the new collection'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_01_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.13: Creating the new collection'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we have a bunch of saved requests in our collection. Next time, if we make
    any changes in our application, we can rerun these tests to make sure the previously
    developed APIs are still working fine. This is called regression testing in the
    developer community. And Postman is a simple yet powerful tool for us to perform
    such testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Implement and Test the delete_recipe Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have a basic understanding of how to implement the API. We have coded
    the create and update recipe functions. In this activity, you will implement the
    `delete_recipe` function yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have learned about both the command-line and GUI testing tools. You will
    test the application using these tools after the implementation. This is what
    you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a `delete_recipe` function in `app.py` that can delete a specific
    recipe. Create the API endpoint accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application, make it ready for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use httpie or curl to delete the recipe with `ID = 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Postman to delete the recipe with `ID = 2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 291.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have built a basic RESTful API using Flask. We did CRUD
    (Create, Read, Update, Delete) operations on our recipes, and through this, you
    should have grasped the concepts and fundamentals of APIs. We have also talked
    about relevant concepts, such as HTTP methods, HTTP status codes, JSON, and routing.
    We wrapped up the chapter by showing you different ways (command prompt, GUI)
    to test the web services that we have built.
  prefs: []
  type: TYPE_NORMAL
- en: After laying a good foundation, in the next chapter, we will continue to develop
    our recipe sharing platform step by step. You will learn the whole process of
    RESTful API development. Just stay with us, the best is yet to come!
  prefs: []
  type: TYPE_NORMAL
