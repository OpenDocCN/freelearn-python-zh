<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will expand the capabilities of the RESTful API that we started in the previous chapter. We will use SQLAlchemy as our ORM to work with a PostgreSQL database, and we will take advantage of advanced features included in Flask and Flask-RESTful that will allow us to easily organize code for complex APIs, such as models and blueprints.</p>
<p>We will go through the following topics in this chapter:</p>
<ul>
<li>Design a RESTful API to interact with a PostgreSQL 10.5 database</li>
<li>Understand the tasks performed by each HTTP method</li>
<li>Install packages with the <kbd>requirements.txt</kbd> file to simplify our common tasks</li>
<li>Create the database</li>
<li>Configure the database</li>
<li>Write code for the models with their ...</li></ul></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing a RESTful API to interact with a PostgreSQL 10.5 database</h1>
                </header>
            
            <article>
                
<p>So far, our RESTful API has performed CRUD operations on a simple in-memory dictionary that acted as a data repository. The dictionary is never persisted and, therefore, the data is lost whenever we restart our Flask development server.</p>
<p>Now, we want to create a more complex RESTful API with Flask RESTful to interact with a database model that allows us to work with notifications that are grouped into notification categories. In our previous RESTful API, we used a string attribute to specify the notification category for a notification. In this case, we want to be able to easily retrieve all the notifications that belong to a specific notification category and, therefore, we will have a relationship between a notification and a notification category.</p>
<p>We must be able to perform CRUD operations on different related resources and resource collections. The following table enumerates the resources and the class name that we will create to represent the model:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Resources</p>
</td>
<td>
<p>Class name that represents the model</p>
</td>
</tr>
<tr>
<td>
<p>Notification categories</p>
</td>
<td>
<p><kbd>NotificationCategory</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Notifications</p>
</td>
<td>
<p><kbd>Notification</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The notification category (<kbd>NotificationCategory</kbd>) just requires the following data:</p>
<ul>
<li>An integer identifier</li>
<li>A string name</li>
</ul>
<p>We need the following data for a notification (<kbd>Notification</kbd>):</p>
<ul>
<li>An integer identifier</li>
<li>A foreign key to a notification category (<kbd>NotificationCategory</kbd>)</li>
<li>A string message</li>
<li>A <strong>TTL</strong> (short for <strong>Time to Live</strong>), that is, a duration in seconds that will indicate the amount of time the notification message has to be displayed on the OLED display</li>
<li>A creation date and time. The timestamp will be added automatically when adding a new notification to the collection</li>
<li>An integer counter that indicates the times when the notification message has been displayed on the OLED display</li>
<li>A bool value indicating whether the notification message was displayed at least once on the OLED display</li>
</ul>
<div class="packt_tip">We will take advantage of many packages related to Flask RESTful and SQLAlchemy that make it easier to serialize and deserialize data, perform validations, and integrate SQLAlchemy with Flask and Flask RESTful. This way, we will reduce the boilerplate code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the tasks performed by each HTTP method</h1>
                </header>
            
            <article>
                
<p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our new API must support. Each method is composed by an HTTP verb and a scope, and all the methods have well-defined meanings for all the resources and collections:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Semantics</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of notification categories</p>
</td>
<td>
<p>Retrieve all the stored notification categories in the collection, sorted by their name in ascending order. Each notification category must include the full URL for the resource. In addition, each notification category must include a list containing all the details of the notifications that belong to the category. The notifications don't have to include ...</p></td></tr></tbody></table></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing packages with the requirements.txt file to simplify our common tasks</h1>
                </header>
            
            <article>
                
<p>Make sure you quit Flask's development server. You just need to press <span class="KeyPACKT"><em>Ctrl</em> + <em>C</em></span> in the Terminal or Command Prompt window in which it is running.</p>
<p>Now, we will install a number of additional packages. Make sure you have activated the virtual environment we created in the previous chapter and named <kbd>Flask01</kbd>. After you activate the virtual environment, it is time to run numerous commands, which will be the same for either macOS, Linux, or Windows.</p>
<p>Now, we will edit the existing <kbd>requirements.txt</kbd> file to specify the additional set of packages that our application requires to be installed in any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p>Use your favorite editor to edit the existing text file named <kbd>requirements.txt</kbd> within the root folder for the virtual environment. Add the following lines after the last line to declare the additional packages and the versions that our new version of the API requires. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/requirements.txt</kbd> file:</p>
<pre>Flask-SQLAlchemy==2.3.2 
Flask-Migrate==2.2.1 
marshmallow==2.16.0 
marshmallow-sqlalchemy==0.14.1 
flask-marshmallow==0.9.0 
psycopg2==2.7.5</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Each additional line added to the <kbd>requirements.txt</kbd> file indicates the package and the version that needs to be installed. The following table summarizes the packages and the version numbers that we specified as additional requirements to the previously included packages:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Package name</p>
</td>
<td>
<p>Version to be installed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Flask-SQLAlchemy</kbd></p>
</td>
<td>
<p>2.3.2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Flask-Migrate</kbd></p>
</td>
<td>
<p>2.2.1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>marshmallow</kbd></p>
</td>
<td>
<p>2.16.0</p>
</td>
</tr>
<tr>
<td>
<p><kbd>marshmallow-sqlalchemy</kbd></p>
</td>
<td>
<p>0.14.1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>flask-marshmallow</kbd></p>
</td>
<td>
<p>0.9.0</p>
</td>
</tr>
<tr>
<td>
<p><kbd>psycopg2</kbd></p>
</td>
<td>
<p>2.7.5</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><kbd>Flask-SQLAlchemy</kbd> adds support for the SQLAlchemy ORM to Flask applications. This extension simplifies executing common SQLAlchemy tasks within a Flask application. SQLAlchemy is a dependency for <kbd>Flask-SQLAlchemy</kbd>.</p>
<p><kbd>Flask-Migrate</kbd> uses the Alembic package to handle SQLAlchemy database migrations for Flask applications. We will use <kbd>Flask-Migrate</kbd> to set up our PostgreSQL database.</p>
<div class="packt_tip">If you've worked with previous versions of <kbd>Flask-Migrate</kbd>, it is very important to notice that Flask-Script is no longer a dependency for <kbd>Flask-Migrate</kbd> . Flask-Script was a popular package that added support for writing external scripts in Flask, including scripts to set up a database. The newest Flask versions install the <kbd>flask</kbd> script and a command-line interface based on the Click package in the virtual environment. Hence, it is no longer necessary to combine <kbd>Flask-Migrate</kbd> with Flask-Script.</div>
<p>Marshmallow is a lightweight library for converting complex datatypes to and from native Python datatypes. Marshmallow provides schemas that we can use to validate input data, deserialize input data to app-level objects, and serialize app-level objects to Python primitive types.</p>
<p><kbd>marshmallow-sqlalchemy</kbd> provides SQLAlchemy integration with the previously installed <kbd>marshmallow</kbd> validation, serialization, and deserialization lightweight library.</p>
<p>Flask-Marshmallow integrates the previously installed <kbd>marshmallow</kbd> library with Flask applications and makes it easy to generate URL and hyperlink fields.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Psycopg 2 (<kbd>psycopg2</kbd>) is a Python-PostgreSQL database adapter and SQLAlchemy will use it to interact with our recently created PostgreSQL database. Again, it is very important to make sure that the PostgreSQL <kbd>bin</kbd> folder is included in the <kbd>PATH</kbd> environmental variable before we run the installation for this package.</p>
<p>Now, we must run the following command on macOS, Linux, or Windows to install the additional packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently edited <kbd>requirements</kbd> file. Make sure you are located in the folder that has the <kbd>requirements.txt</kbd> file before running the command:</p>
<pre>    <strong>pip install -r requirements.txt</strong></pre>
<p>The last lines for the output will indicate that all the new packages and their dependencies have been successfully installed. If you downloaded the source code for the example and you didn't work with the previous version of the API, <kbd>pip</kbd> will also install the other packages included in the <kbd>requirements.txt</kbd> file:</p>
<pre><strong>Installing collected packages: SQLAlchemy, Flask-SQLAlchemy, Mako, python-editor, python-dateutil, alembic, Flask-Migrate, marshmallow, marshmallow-sqlalchemy, flask-marshmallow, psycopg2</strong>
    <strong>  Running setup.py install for SQLAlchemy ... done</strong>
    <strong>  Running setup.py install for Mako ... done</strong>
    <strong>  Running setup.py install for python-editor ... done</strong>
<strong>Successfully installed Flask-Migrate-2.2.1 Flask-SQLAlchemy-2.3.2<br/>Mako-1.0.7 SQLAlchemy-1.2.12 alembic-1.0.0 flask-marshmallow-0.9.0 marshmallow-2.16.0 marshmallow-sqlalchemy-0.14.1 psycopg2-2.7.5 <br/>python-dateutil-2.7.3 python-editor-1.0.3</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the database</h1>
                </header>
            
            <article>
                
<p>Now, we will create the PostgreSQL 10.5 database that we will use as a repository for our API. You will have to download and install a PostgreSQL database server if you aren't already running it in your computer or on a development server. You can download and install this database management system from its web page (<a href="http://www.postgresql.org"><span class="URLPACKT">http://www.postgresql.org)</span></a>. If you are working with macOS, <kbd>Postgres.app</kbd> provides a really easy way to install and use PostgreSQL on this operating system. You can refer to it from <span class="URLPACKT"><a href="http://postgresapp.com">http://postgresapp.com</a></span>. If you are working with Windows, EnterpriseDB and BigSQL provide graphics installers that simplify the configuration process on modern Windows server or desktop versions (visit <a href="https://www.postgresql.org/download/windows"><span class="URLPACKT">https://www.postgresql.org/download/windows ...</span></a></p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring the database</h1>
                </header>
            
            <article>
                
<p>If you are using the same virtual environment we have created for the previous example, or you downloaded the code sample, the <kbd>service</kbd> folder already exists. If you created a new virtual environment, create a folder named <kbd>service</kbd> within the root folder for the  virtual environment created.</p>
<p>Create a new <kbd>config.py</kbd> file within the <kbd>service</kbd> folder. The following lines show the code that declares variables that determine the configuration for Flask and SQLAlchemy. The <kbd>SQL_ALCHEMY_DATABASE_URI</kbd> variable generates an SQLAlchemy URI for the PostgreSQL database. Make sure you specify the desired database name in the value for <kbd>DB_NAME</kbd> and that you configure the user, password, host, and port based on your PostgreSQL configuration. If you followed the previous steps, use the settings specified in these steps. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/config.py</kbd> file:</p>
<pre>import os 
 
basedir = os.path.abspath(os.path.dirname(__file__)) 
SQLALCHEMY_ECHO = False 
SQLALCHEMY_TRACK_MODIFICATIONS = True 
# Replace your_user_name with the user name you configured for the database 
# Replace your_password with the password you specified for the database user 
SQLALCHEMY_DATABASE_URI = "postgresql://{DB_USER}:{DB_PASS}@{DB_ADDR}/{DB_NAME}".format(DB_USER="your_user_name", DB_PASS="your_password", DB_ADDR="127.0.0.1", DB_NAME="flask_notifications") 
SQLALCHEMY_MIGRATE_REPO = os.path.join(basedir, 'db_repository')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We will specify the previously created module (<kbd>config</kbd>) as an argument to a function that will create a Flask app. This way, we have one module that specifies all the values for the different configuration variables related to SQLAlchemy, and another module that creates a Flask app. We will create the Flask app factory as our final step toward our new API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating models with their relationships</h1>
                </header>
            
            <article>
                
<p>Now, we will create the models that we will use to represent and persist the notification categories, notifications, and their relationships in the PostgreSQL database.</p>
<p>Open the <kbd>service/models.py</kbd> file and replace its contents with the following code. The lines that declare fields related to other models are highlighted in the code listing. If you created a new virtual environment, create a new <kbd>models.py</kbd> file within the <kbd>service</kbd> folder. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/models.py</kbd> file:</p>
<pre>from marshmallow import Schema, fields, pre_load from marshmallow import validate from flask_sqlalchemy import SQLAlchemy from flask_marshmallow import ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating schemas to validate, serialize, and deserialize models</h1>
                </header>
            
            <article>
                
<p>Now, we will create the Flask-Marshmallow schemas that we will use to validate, serialize, and deserialize the previously declared <kbd>NotificationCategory</kbd> and <kbd>Notification</kbd> models, and their relationships.</p>
<p>Open the <kbd>models.py</kbd> file within the <kbd>service</kbd> folder and add the following code after the last line. The lines that declare fields related to other schemas are highlighted in the code listing. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/models.py</kbd> file:</p>
<pre>class NotificationCategorySchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    # Minimum length = 3 characters 
    name = fields.String(required=True,  
        validate=validate.Length(3)) 
    url = ma.URLFor('service.notificationcategoryresource',  
        id='&lt;id&gt;',  
        _external=True) 
<strong><span class="MsoCommentReference">    notifications = fields.Nested('NotificationSchema', </span><span class="MsoCommentReference">            <br/>      many=True, </span><span class="MsoCommentReference">        <br/>      exclude=('notification_category',))</span></strong> 
  
 
class NotificationSchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    # Minimum length = 5 characters 
    message = fields.String(required=True,  
        validate=validate.Length(5)) 
    ttl = fields.Integer() 
    creation_date = fields.DateTime() 
<strong><span class="MsoCommentReference">    notification_category =<br/>fields.Nested(NotificationCategorySchema,<br/> </span><span class="MsoCommentReference">        only=['id', 'url', 'name'],<br/> </span><span class="MsoCommentReference">        required=True)</span> </strong>
    displayed_times = fields.Integer() 
    displayed_once = fields.Boolean() 
    url = ma.URLFor('service.notificationresource',  
        id='&lt;id&gt;',  
        _external=True) 
 
    @pre_load 
    def process_notification_category(self, data): 
        notification_category = data.get('notification_category') 
        if notification_category: 
            if isinstance(notification_category, dict): 
                notification_category_name = notification_category.get('name') 
            else: 
                notification_category_name = notification_category 
            notification_category_dict = dict(name=notification_category_name) 
        else: 
            notification_category_dict = {} 
        data['notification_category'] = notification_category_dict 
        return data </pre>
<p>The code declares the following two schemas, that is, two subclasses of the <kbd>ma.Schema</kbd> class:</p>
<ul>
<li><kbd>NotificationCategorySchema</kbd></li>
<li><kbd>NotificationSchema</kbd></li>
</ul>
<div class="packt_tip">We don't use the Flask-Marshmallow features that allow us to automatically determine the appropriate type for each attribute based on the fields declared in a model because we want to use specific options for each field.</div>
<p>We declare the attributes that represent fields as instances of the appropriate classes declared in the <kbd>marshmallow.fields</kbd> module. Whenever we specify the <kbd>True</kbd> value for the <kbd>dump_only</kbd> argument, it means that we want the field to be read-only. For example, we won't be able to provide a value for the <kbd>id</kbd> field in any of the schemas. The value for this field will be automatically generated by the auto-increment primary key in the PostgreSQL database.</p>
<p>The <kbd>NotificationCategorySchema</kbd> class declares the <kbd>name</kbd> attribute as an instance of <kbd>fields.String</kbd>. The <kbd>required</kbd> argument is set to <kbd>True</kbd> to specify that the field cannot be an empty string. The <kbd>validate</kbd> argument is set to <kbd>validate.Length(3)</kbd> to specify that the field must have a minimum length of three characters.</p>
<p class="mce-root"/>
<p>The class declares the <kbd>url</kbd> field with the following lines:</p>
<pre>url = ma.URLFor('service.notificacion_categoryresource', 
    id='&lt;id&gt;', 
    _external=True)</pre>
<p>The <kbd>url</kbd> attribute is an instance of the <kbd>ma.URLFor</kbd> class and this field will output the full URL of the resource, that is, the URL for the notification category. The first argument is the Flask endpoint's name: <kbd>'service.notificationcategoryresource'</kbd>. We will create a <kbd>NotificationCategoryResource</kbd> class later and the <kbd>URLFor</kbd> class will use it to generate the URL. The <kbd>id</kbd> argument specifies <kbd>'&lt;id&gt;'</kbd> because we want the <kbd>id</kbd> to be pulled from the object to be serialized. The <kbd>id</kbd> string enclosed within less than (<kbd>&lt;</kbd>) and greater than (<kbd>&gt;</kbd>) symbols specifies that we want the field to be pulled from the object that has to be serialized. The <kbd>_external</kbd> attribute is set to <kbd>True</kbd> because we want to generate the full URL for the resource. This way, every time we serialize a <kbd>NotificationCategory</kbd>, it will include the full URL for the resource in the <kbd>url</kbd> key or property.</p>
<div class="packt_tip">In this case, we are using our insecure API behind HTTP. If our API is configured with HTTPS, we should set the <kbd>_scheme</kbd> argument to <kbd>'https'</kbd> when we create the <kbd>ma.URLFor</kbd> instance.</div>
<p>The class declares the <kbd>notifications</kbd> field with the following lines:</p>
<pre>notifications = fields.Nested('NotificationSchema', 
    many=True, 
    exclude=('notification_category',)) </pre>
<p>The <kbd>notifications</kbd> attribute is an instance of the <kbd>marshmallow.fields.Nested</kbd> class, and this field will nest a collection of <kbd>Schema</kbd>, so, therefore, we specify <kbd>True</kbd> for the <kbd>many</kbd> argument. The first argument specifies the name for the nested <kbd>Schema</kbd> class as a string. We declare the <kbd>NotificationSchema</kbd> class after we defined the <kbd>NotificationCategorySchema</kbd> class. Thus, we specify the <kbd>Schema</kbd> class name as a string instead of using the type that we haven't defined yet.</p>
<div class="packt_tip">In fact, we will end up with two objects that nest to each other; that is, we will create a two-way nesting between notification categories and notifications. We use the <kbd>exclude</kbd> parameter with a tuple of string to indicate that we want the <kbd>notification_category</kbd> field to be excluded from the fields that are serialized for each notification. This way, we avoid infinite recursion because the inclusion of the <kbd>notification_category</kbd> field would serialize all the notifications related to the category.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When we declared the <kbd>Notification</kbd> model, we used the <kbd>orm.relationship</kbd> function to provide a many-to-one relationship to the <kbd>NotificationCategory</kbd> model. The <kbd>backref</kbd> argument specified a call to the <kbd>orm.backref</kbd> function with <kbd>'notifications'</kbd> as the first value that indicates the name to use for the relation from the related <kbd>NotificationCategory</kbd> object back to a <kbd>Notification</kbd> object. With the previously explained line, we created the <kbd>notifications</kbd> fields that use the same name we indicated for the <kbd>db.backref</kbd> function.</p>
<p>The <kbd>NotificationSchema</kbd> class declares the <kbd>notification</kbd> attribute as an instance of <kbd>fields.String</kbd>. The <kbd>required</kbd> argument is set to <kbd>True</kbd> to specify that the field cannot be an empty string. The <kbd>validate</kbd> argument is set to <kbd>validate.Length(5)</kbd> to specify that the field must have a minimum length of five characters. The class declares the <kbd>ttl</kbd>, <kbd>creation_date</kbd>, <kbd>displayed_times</kbd>, and <kbd>displayed_once</kbd> fields with the corresponding classes based on the types we used in the <kbd>Message</kbd> model.</p>
<p>The class declares the <kbd>notification_category</kbd> field with the following lines:</p>
<pre>notification_category = fields.Nested(CategorySchema,  
    only=['id', 'url', 'name'],  
    required=True) </pre>
<p>The <kbd>notification_category</kbd> attribute is an instance of the <kbd>marshmallow.fields.Nested</kbd> class, and this field will nest a single <kbd>NotificationCategorySchema</kbd>. We specify <kbd>True</kbd> for the <kbd>required</kbd> argument because a notification must belong to a category. The first argument specifies the name for the nested <kbd>Schema</kbd> class. We already declared the <kbd>NotificationCategorySchema</kbd> class and, therefore, we specify <kbd>NotificationCategorySchema</kbd> as the value for the first argument. We use the <kbd>only</kbd> parameter with a list of strings to indicate the field names that we want to be included when the nested <kbd>NotificationCategorySchema</kbd> is serialized. We want the <kbd>id</kbd>, <kbd>url</kbd>, and <kbd>name</kbd> fields to be included. We don't specify the <kbd>notifications</kbd> field because we don't want the notification category to serialize the list of notifications that belong to it.</p>
<p>The class declares the <kbd>url</kbd> field with the following lines:</p>
<pre>url = ma.URLFor('service.notificationresource',  
    id='&lt;id&gt;',  
    _external=True)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The <kbd>url</kbd> attribute is an instance of the <kbd>ma.URLFor</kbd> class and this field will output the full URL of the resource, that is, of the notification resource. The first argument is the Flask endpoint name: <kbd>'service.notificationresource'</kbd>. We will create a <kbd>NotificationResource</kbd> class later and the <kbd>URLFor</kbd> class will use it to generate the URL. The <kbd>id</kbd> argument specifies <kbd>'&lt;id&gt;'</kbd> because we want <kbd>id</kbd> to be pulled from the object to be serialized. The <kbd>_external</kbd> attribute is set to <kbd>True</kbd> because we want to generate the full URL for the resource. This way, each time we serialize a <kbd>Notification</kbd>, it will include the full URL for the resource in the <kbd>url</kbd> key.</p>
<p>The <kbd>NotificationSchema</kbd> class declares a <kbd>process_notification_category</kbd> method that uses the <kbd>@pre_load</kbd> decorator, specifically, <kbd>marshmallow.pre_load</kbd>. This decorator registers a method to invoke before deserializing an object. This way, before Marshmallow deserializes a notification, the <kbd>process_category</kbd> method will be executed.</p>
<p>The method receives the data to be deserialized in the <kbd>data</kbd> argument and it returns the processed data. When we receive a request to <kbd>POST</kbd> a new notification, the notification category name can be specified in a key named <kbd>'notification_category'</kbd>. If a category with the specified name exists, we will use the existing category as the one that is related to the new notification. If a category with the specified name doesn't exist, we will create a new notification category and then we will use this new category as the one that is related to the new notification. This way, we make it easy and straightforward for the user to create new notifications related to categories.</p>
<p>The <kbd>data</kbd> argument might have a notification category name specified as a string for the <kbd>'notification_category'</kbd> key. However, in other cases, the <kbd>'notification_category'</kbd> key will include the key-value pairs with the field name and field values for an existing notification category.</p>
<p>The code in the <kbd>process_notification_category</kbd> method checks the value of the <kbd>'notification_category'</kbd> key and returns a dictionary with the appropriate data to make sure that we are able to deserialize a notification category with the appropriate key-value pairs, irrespective of the differences between the incoming data. Finally, the method returns the processed dictionary. We will dive deep on the work done by the <kbd>process_notification_category</kbd> method later when we start composing and sending HTTP requests to the new API.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Combining blueprints with resourceful routing</h1>
                </header>
            
            <article>
                
<p>Now, we will create the resources that compose our main building blocks for the RESTful API. First, we will create a few instances that we will use in the different resources. Create a new <kbd>views.py</kbd> file within the <kbd>services</kbd> folder and add the following lines. Notice that the code imports the <kbd>HttpStatus</kbd> enum declared in the <kbd>http_status.py</kbd> module that we created in the previous chapter. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>from flask import Blueprint, request, jsonify, make_response from flask_restful import Api, Resource from http_status import HttpStatus from models import orm, NotificationCategory, NotificationCategorySchema, ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding and configuring resourceful routing</h1>
                </header>
            
            <article>
                
<p>The following table shows the method of our previously created classes that we want to be executed for each combination of HTTP verb and scope:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Class and method</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of notifications</p>
</td>
<td>
<p><kbd>NotificationListResource.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p><kbd>NotificationResource.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of notifications</p>
</td>
<td>
<p><kbd>NotificationListResource.post</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p><kbd>NotificationResource.patch</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p><kbd>NotificationResource.delete</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of notification categories</p>
</td>
<td>
<p><kbd>NotificationCategoryListResource.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Notification category</p>
</td>
<td>
<p><kbd>NotificationCategoryResource.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of notification categories</p>
</td>
<td>
<p><kbd>NotificationCategoryListResource.post</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Notification category</p>
</td>
<td>
<p><kbd>NotificationCategoryResource.patch</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Notification category</p>
</td>
<td>
<p><kbd>NotificationCategoryResource.delete</kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip">If the request results in the invocation of a resource with an unsupported HTTP method, Flask-RESTful will return a response with the HTTP <kbd>405 Method Not Allowed</kbd> status code.</div>
<p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines configure the resource routing for the service. Open the previously created <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and add the following code after the last line. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>service.add_resource(NotificationCategoryListResource,  
    '/notification_categories/') 
service.add_resource(NotificationCategoryResource,  
    '/notification_categories/&lt;int:id&gt;') 
service.add_resource(NotificationListResource,  
    '/notifications/') 
service.add_resource(NotificationResource,  
    '/notifications/&lt;int:id&gt;')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Each call to the <kbd>service.add_resource</kbd> method routes a URL to a resource; specifically, to one of the previously declared subclasses of the <kbd>flask_restful.Resource</kbd> superclass. Whenever there is a request to the API, and the URL matches one of the URLs specified in the <kbd>service.add_resource</kbd> method, Flask will call the method that matches the HTTP verb in the request for the specified class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Registering the blueprint and running migrations</h1>
                </header>
            
            <article>
                
<p>Create a new <kbd>app.py</kbd> file within the <kbd>service</kbd> folder. The following lines show the code that creates a Flask application. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/service/app.py</kbd> file:</p>
<pre>from flask import Flask 
from flask_sqlalchemy import SQLAlchemy 
from flask_migrate import Migrate 
from models import orm 
from views import service_blueprint 
 
 
def create_app(config_filename): 
    app = Flask(__name__) 
    app.config.from_object(config_filename) 
    orm.init_app(app) 
    app.register_blueprint(service_blueprint, url_prefix='/service') 
    migrate = Migrate(app, orm) 
    return app 
 
 
app = create_app('config') </pre>
<p>The code in the <kbd>service/app.py</kbd> file declares a <kbd>create_app</kbd> function ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Verifying the contents of the PostgreSQL database</h1>
                </header>
            
            <article>
                
<p>After we run the previous scripts, we can use the PostgreSQL command line or any other application that allows us to easily verify the contents of the PostgreSQL 10.5 database to check the tables that the migration generated.</p>
<p class="mce-root"/>
<p>Run the following command to list the generated tables. If the database name you are using is not named <kbd>flask_notifications</kbd>, make sure you use the appropriate database name. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/list_database_tables.sql</kbd> file:</p>
<pre><strong>psql --username=your_user_name --dbname=flask_notifications --command="\dt"</strong></pre>
<p>The following lines show the output with all the generated table names:</p>
<pre>    <strong>
      <strong>                    List of relations</strong></strong>
<strong>
      <strong> Schema |         Name          | Type  |     Owner      </strong></strong><strong>
      <strong>--------+-----------------------+-------+----------------</strong></strong><strong>
      <strong> public | alembic_version       | table | your_user_name</strong></strong><strong>
      <strong> public | notification          | table | your_user_name</strong></strong><strong>
      <strong> public | notification_category | table | your_user_name</strong></strong><strong>
      <strong>(3 rows)</strong></strong></pre>
<p>SQLAlchemy generated the following two tables with the unique constraints and the foreign keys based on the information included in our models:</p>
<ul>
<li><kbd>notification_category</kbd>: This table persists the <kbd>NotificationCategory</kbd> model.</li>
<li><kbd>notification</kbd>: This table persists the <kbd>Notification</kbd> model.</li>
</ul>
<p>The following command will allow you to check the contents of the two tables after we compose and send HTTP requests to the RESTful API and execute CRUD operations on the two tables. The commands assume that you are running PostgreSQL 10.5 on the same computer in which you are running the command. The code file for the sample is included in the <kbd>restful_python_2_02_01</kbd> folder, in the <kbd>Flask01/check_tables_contents.sql</kbd> file:</p>
<pre><strong>psql --username=your_user_name --dbname=flask_notifications --command="SELECT * FROM notification_category;"</strong>
<strong>psql --username=your_user_name --dbname=flask_notifications --command="SELECT * FROM notification;"</strong>
  </pre>
<div class="packt_tip">Instead of working with the PostgreSQL command-line utility, you can use your favorite GUI tool to check the contents of the PostgreSQL database.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Alembic generated an additional table named <kbd>alembic_version</kbd> that saves the version number for the database in the <kbd>version_num</kbd> column. This table makes it possible for the migration commands to retrieve the current version for the database and upgrade or downgrade it based on our needs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and retrieving related resources</h1>
                </header>
            
            <article>
                
<p>Now, we will use the flask script to launch Flask's development server and our RESTful API. We want to enable the debug mode and, therefore, we will set the value for the <kbd>FLASK_ENV</kbd> environment variable to <kbd>development</kbd>.</p>
<p>Run the following command in the Terminal in Linux or macOS with a bash shell:</p>
<pre>    <strong>export FLASK_ENV=development</strong></pre>
<p>In Windows, if you are using the Command Prompt, run the following command:</p>
<pre>    <strong>set FLASK_ENV=development</strong></pre>
<p>In Windows, if you are using Windows PowerShell, run the following command:</p>
<pre>    <strong>$env:FLASK_ENV = "development"</strong></pre>
<p>Now, run the <kbd>flask</kbd> script that launches Flask's development server and the application.</p>
<p>Now that the <kbd>FLASK_ENV</kbd> environment variable is configured to work in development ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following commands start the Flask development server and the Flask application, and makes it listen on every interface on port <kbd>5000</kbd>?:
<ol>
<li><kbd>flask run -h 0.0.0.0</kbd></li>
<li><kbd>flask run -p 0.0.0.0 -h 5000</kbd></li>
<li><kbd>flask run -p 0.0.0.0</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li><kbd>Flask-Migrate</kbd> is:
<ol>
<li>A lightweight library for converting complex datatypes to and from native Python datatypes.</li>
<li>A library that uses the Alembic package to handle SQLAlchemy database migrations for Flask applications.</li>
<li>A library that replaces SQLAlchemy to run queries on PostgreSQL.</li>
</ol>
</li>
</ol>
<ol start="3">
<li>Marshmallow is:
<ol>
<li>A lightweight library for converting complex datatypes to and from native Python datatypes.</li>
<li>An ORM.</li>
<li>A lightweight web framework that replaces Flask.</li>
</ol>
</li>
</ol>
<ol start="4">
<li>SQLAlchemy is:
<ol>
<li>A lightweight library for converting complex datatypes to and from native Python datatypes.</li>
<li>An ORM.</li>
<li>A lightweight web framework that replaces Flask.</li>
</ol>
</li>
</ol>
<ol start="5">
<li>The <kbd>marshmallow.pre_load</kbd> decorator:
<ol>
<li>Registers a method to run after any instance of the <kbd>Resource</kbd> <span>class is created.</span></li>
<li>Registers a method to invoke after serializing an object.</li>
<li>Registers a method to invoke before deserializing an object.</li>
</ol>
</li>
</ol>
<ol start="6">
<li>The <kbd>dump</kbd> method for any instance of a <kbd>Schema</kbd> subclass:
<ol>
<li>Routes URLs to Python primitives.</li>
<li>Persists the instance or collection of instances passed as an argument to the database.</li>
<li>Takes the instance or collection of instances passed as an argument and applies the field filtering and output formatting specified in the <kbd>Schema</kbd> <span>subclass to the instance or collection of instances.</span></li>
</ol>
</li>
</ol>
<ol start="7">
<li>When we declare an attribute as an instance of the <kbd>marshmallow.fields.Nested</kbd> class:
<ol>
<li>The field will nest a single <kbd>Schema</kbd> <span>or a collection of</span> <kbd>Schema</kbd> <span>based on the value for the</span> <kbd>many</kbd> argument.</li>
<li>The field will nest a single <kbd>Schema</kbd><span>. If we want to nest a collection of</span> <kbd>Schema</kbd><span>, we have to use an instance of the</span> <kbd>marshmallow.fields.NestedCollection</kbd> <span>class.</span></li>
<li>The field will nest a collection of <kbd>Schema</kbd><span>. If we want to nest a single</span> <kbd>Schema</kbd><span>, we have to use an instance of the</span> <kbd>marshmallow.fields.NestedSingle</kbd> <span>class.</span></li>
</ol>
</li>
</ol>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we expanded the capabilities of the previous version of the RESTful API we created in the preceding chapter. We used SQLAlchemy as our ORM to work with a PostgreSQL 10.5 database. We added many packages to simplify many common tasks, we wrote code for the models and their relationships, and we worked with schemas to validate, serialize, and deserialize these models.</p>
<p>We combined blueprints with resourceful routing, and we were able to generate the database from the models. We composed and sent many HTTP requests to our RESTful API and analyzed how each HTTP request was processed in our code and how the models persisted in the database tables.</p>
<p>Now that we have built a complex API with Flask, Flask-RESTful, and SQLAlchemy, ...</p></article></section></div>



  </body></html>