- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We described how Python and Go run and how they access the network in the previous
    chapter; however, we missed two important points when building our network automation
    solution: how we report program execution events and how we handle errors.'
  prefs: []
  type: TYPE_NORMAL
- en: These two topics are not as easy as they seem, and they are, most of the time,
    implemented in the system poorly. Some network developers might not do it properly
    because of lack of knowledge, but there are also some developers that don’t do
    it properly because of time constraints and extra time needed for coding.
  prefs: []
  type: TYPE_NORMAL
- en: But are these activities really important? Let’s examine these in this chapter.
    First, let’s investigate how and why we handle errors and then why and how we
    do event logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding logging to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to add effectively code to handle
    errors and log events in your network development.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see how important handling errors is, we have to think of our system as a
    whole, including inputs and output. Our code by itself might never experience
    an error; however, when integrated with other systems, it might cause unpredictable
    outputs, or might just crash and stop working.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, handling errors is important to cope with the unpredictability of
    inputs and protect your code to avoid wrong outputs or crashes. But how do we
    do that?
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to identify our inputs, and then we create a series of different
    combinations of values that are sent to our inputs. The behavior of these input
    combinations are then evaluated by running our code. For a function, we do that
    by adding unit tests, as we discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127).
    For the system, we add integration tests and end-to-end testing. Additional techniques
    were also discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127).
  prefs: []
  type: TYPE_NORMAL
- en: But what is the correct way to write code for handling errors? It will depend
    on the language.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to handle errors is quite different in Go compared to Python. Let’s
    see how we do this effectively in Go then in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Adding error handling in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The design of the Go language requires explicitly checking errors when they
    occur, which is different from throwing exceptions and then catching them like
    in Python. In Go, errors are just values returned by functions, which makes Go
    coding a bit more verbose and perhaps more repetitive. With Python, you would
    not need to check errors, as an exception would be raised, but in Go, you have
    to check the errors. But on the other hand, Go error handling is much simpler
    compared to Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors in Go are created by using an `error` type interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the error implementation in Go is quite
    simple by using a method called `Error()` that returns an error message as a string.
  prefs: []
  type: TYPE_NORMAL
- en: The correct way to construct an error in your code is by using either the `errors`
    or `fmt` standard libraries
  prefs: []
  type: TYPE_NORMAL
- en: The following are two examples of using each of them for a division-by-zero
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `errors` library looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `fmt` library looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two examples produce the same results. For instance, if you call
    any of the two functions with `fmt.Println(divide(10, 0))`, it will print the
    following output: `0 divided by zero` `not valid`.'
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between `fmt.Errorf` and `errors.New` is the possibility
    of formatting the string and adding values. Another point is that `errors.New`
    is faster because it does not invoke the formatter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking to create custom errors, stack traces, and more advanced
    error features, consider using the `errors` library or third-party libraries such
    as the popular `pkg/errors` ([https://pkg.go.dev/github.com/pkg/errors](https://pkg.go.dev/github.com/pkg/errors))
    or `golang.org/x/xerrors` ([https://pkg.go.dev/golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus now on the best practices when writing code for error handling in
    Go. The following are the top best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Return errors last and values to 0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating a function that returns several values, the error should be placed
    as the last argument returned. When returning values with errors, use 0 when it
    is a number and `empty string` for strings, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the value of the string returned is empty and the
    value of `int` returned is 0\. These values are just suggestions, because when
    an error is returned, the calling statement will first check whether there is
    an error before assigning the returned variables. Therefore, the values returned
    with an error are irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: Add only information that the caller does not have
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating the error message, do not add information that is already known
    by the caller of your function. The following example illustrates this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the value of `q` was returned in the
    error message. But that is not necessary, because the caller of the `divide` function
    has this value.
  prefs: []
  type: TYPE_NORMAL
- en: When creating errors to return in your function, do not include any arguments
    passed in the function, as this is known by the caller. This can lead to information
    duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Use lowercase and do not end with punctuation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always use lowercase as your error message will be concatenated with other messages
    when returning. Most of the time, you should also not use any punctuation, because
    the error messages will probably be linked together, and punctuation will end
    up looking odd in the middle of the error message.
  prefs: []
  type: TYPE_NORMAL
- en: The exception of the lowercase rule is when you are referring to the names of
    functions or methods that already have capital letters.
  prefs: []
  type: TYPE_NORMAL
- en: Add a colon to the error message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A colon (`:`) is used whenever you want to add information from another error
    message of a call made inside your code. Let’s use the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `connect` function encapsulates a call to `ssh.Dial`.
    We can add the context of the error to the error message by indicating which call
    generated the error by adding the name of the call or some information about `ssh.Dial`,
    using a colon to separate it if necessary. Note that the `config` and `host` arguments
    are known by the caller of the `connect` function and therefore should not be
    added to the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Use defer, panic, and recover
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go has important mechanisms to control how the program flows during errors.
    That is mostly useful when using goroutines, because one might cause the program
    to crash, and you might need to be extra careful to avoid unclosed software pipes
    and software caches; and avoid unfreed memory and unclosed file descriptors
  prefs: []
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go `defer` is used to push the execution to a list that is only executed after
    the surrounding function has returned or when it crashes. The main intention of
    `defer` is to perform a cleanup. Consider the following example of a function
    that copies data from one file to another and then removes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if an error occurs in `os.Create`, the function would
    return before calling `src.Close()`, which means the file has not been closed
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to avoid having to add the `close` statement repetitively throughout
    the code is to use `defer`, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, `defer` is used just after a successful
    `os.Open` and after a successful `os.Create`. Therefore, if there is an error,
    or if the function ends, it will invoke `dst.Close()` first and then `src.Close()`
    in a reverse order, like in a **Last In, First Out** (**LIFO**) queue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to use `panic` now.
  prefs: []
  type: TYPE_NORMAL
- en: panic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When writing code, if you don’t want to handle an error, you can use `panic`
    to indicate that you want to stop immediately. In Go, `panic` can be called in
    your program by explicitly writing it, but it is also called automatically during
    runtime if an error occurs. The following is a list of the major runtime errors
    that can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds memory access, including arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertion of a wrong type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to call a function using a variable with a `nil` pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a closed channel or file descriptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Division by zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, `panic` is only used in your code when you are not planning to handle
    the error or are dealing with errors that are not yet understood.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that before exiting the function and passing the `panic`
    message, the program will still run all `defer` statements that were stacked earlier
    in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `panic` to exit the program after receiving a negative
    value as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run this program and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output does not print `done`, because `panic` is called inside
    the `squareRoot` function, before the instruction to print.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we add `defer` to the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ending the function` print statement was placed before sending
    the `panic` message. That is because, as we explained, the `defer` stack is executed
    before returning the function by `panic`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can use `recover`.
  prefs: []
  type: TYPE_NORMAL
- en: recover
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Go, `recover` is the last piece of error flow control necessary to handle
    errors. It is used to handle a `panic` situation and regain control. It should
    only be used inside a `defer` function call. In a normal call, `recover` will
    return a `nil` value, but in the `panic` situation, it will return the value given
    to `panic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding program, you will get the following `panic` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this output, you have no control of the `panic` situation.
    It will basically crash the program without the possibility to handle the error
    properly. This is undesirable in most production software, especially using multiple
    goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to properly handle the `panic` situation, you should add a `defer`
    function to test whether it is a `panic` situation by using `recover`, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the `defer` function as in the preceding example, the output will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, adding a `recover` test inside the `defer` function will allow
    you to handle unexpected `panic` situations, avoiding your program crashing unexpectedly
    without doing a proper cleanup or fixing the error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have investigated how to handle Go errors, let’s have a look at
    Python error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Adding error handling in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python handles errors differently than Go. Python does not require your function
    to return error values. In Python, errors are thrown during runtime and they are
    called exceptions. To handle exceptions, your code has to catch them properly
    and avoid raising them.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, there are built-in exceptions that are raised by many runtime errors.
    The list of built-in exceptions is quite long and can be found here: [https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).
    As an example, the division-by-zero error is called a `ZeroDivisionError` exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the error, you need to catch the exception and then handle it by
    using the `try`, `except`, `else`, and `finally` Python statements. To create
    an example of how to handle the exception for division by zero, let’s first run
    the following program without catching an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding program, it will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program crashes and shows the error message as `Traceback`
    on the screen, with details of where the error occurs and the name of the exception,
    in this case, `ZeroDivisionError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s update the Python code to catch this exception and handle the error
    more gracefully, like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the program, it will print the error gracefully without crashing
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, whenever you think there is a possibility for the function to raise an exception
    by an error, use the `try` and `except` statements, as shown in the preceding
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `try` and `except` statements, Python also allows using `else`
    and `finally` statements to add more flow control of the error handling. They
    are not mandatory as the flow can be controlled outside the `try`/`except` statement,
    but they are sometimes useful. The following is the same example of adding the
    `else` and `finally` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program, it will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `else` statement is only executed if no exception was raised in
    the `try` clause. The `finally` statement is always executed, regardless of whether
    an exception was raised or not in the `try` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to catch an exception in Python, let’s discuss how
    to choose the exception we want to catch.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing more specific exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, exceptions are hierarchical and always start with the exception
    called `BaseException`. As an example, division by zero exhibits the following
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The exceptions hierarchy is quite useful, because your code can catch either
    a higher-level exception or a more specific one. With division by zero, you could
    catch the `ArithmeticError` exception instead of `ZeroDivisionError`. However,
    it’s a good practice sometimes to catch the more specific exception instead of
    a higher-level one.
  prefs: []
  type: TYPE_NORMAL
- en: More specific exceptions are more desirable to be caught inside functions and
    libraries, because if you catch generic exceptions inside the function, you might
    mask the problem when another part of the code calls your function. So, it will
    depend on where you are catching and how you are handling it.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good idea how to handle errors in Go and Python. Let’s discuss
    how to add logging to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Logging events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer software, logging is a well-known technique used to help troubleshoot
    a problem, record milestones, understand behavior, retrieve information, and check
    historical events, among other useful actions. Despite these advantages, not many
    developers add proper logging to their code. In fact, some developers do nothing
    and add logging only when the program has problems and needs debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In network automation, logging is even more important, because network elements
    are normally distributed and rely heavily on logging to be able to be audited
    in case of a problem or if an improvement is needed. Adding logging to your code
    is a good practice that will be appreciated by several levels of engineering,
    such as network operators, network planners, network security, and network designers,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: But one important point here that must be observed is that time synchronization
    between network elements is mandatory to allow logging to be useful. Protocols
    such as the **Network Time Protocol** (**NTP**) or **Precision Time Protocol**
    (**PTP**) must be used throughout the network.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice to use logging is to use the Unix logging reference called `syslog`,
    firstly published as an informational RFC in RFC3164 and then as a standard document
    in RFC5424 ([https://www.rfc-editor.org/rfc/rfc3164](https://www.rfc-editor.org/rfc/rfc3164)).
  prefs: []
  type: TYPE_NORMAL
- en: For our network automation code, we do not need to follow all the details in
    the `syslog` protocol standard, but we are going to use it as a guide for logging
    useful information based on severity level.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now talk about some levels of information we want when logging events.
  prefs: []
  type: TYPE_NORMAL
- en: Severity levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RFC5424 `syslog` protocol has defined eight levels of severity, which are
    described in *Section 6.2.1* of RFC5424 ([https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1](https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1)).
    They are mentioned in the following list with a brief explanation of what kind
    of information message is intended to be added to each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Emergency`: The system is not operational and there is no possible recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alert`: Immediate attention is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Critical`: Something bad is happening and quick attention is required to fix
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Error`: Failure is occurring but does not need urgent attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Warning or Warn`: Indicates that something is wrong and might cause an error
    in the future, such as software not updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notice`: An important milestone that has been reached and might indicate a
    future warning, such as configuration not saved or resource utilization limit
    not set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Informational or Info`: Normal operational milestone messages. Used later
    for audit and investigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Debug`: Used by developers to troubleshoot a problem or to investigate possible
    improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although these eight levels are defined in the `syslog` protocol, they are quite
    ambiguous and open to different interpretations. For instance, `Alert` and `Emergency`
    might be different for different developers when writing code, as is the case
    with other levels, such as `Notice` and `Informational`. Therefore, some network
    developers prefer to use less levels with easier interpretation. The number will
    depend on how the network operates, but varies between three and five levels.
    For Go and Python, the number of levels will depend on the library you are using
    to create the log messages. Some might have more levels than others.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s investigate how to add log events to your code using Go and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding event logging in your code will be different in Go and in Python and
    will vary depending on the library used in your code. But the idea for both languages
    is to divide the information into severity levels, as done in `syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: The severity log levels will also vary depending on the library used. Python
    and Go have standard log libraries, but you are also able to use third-party libraries
    to log events in both languages.
  prefs: []
  type: TYPE_NORMAL
- en: One important point here is that when writing the code, you will decide whether
    there is a need to add a logging event line. The line of logging added must carry
    some information that will signal to the program which level of severity the message
    is. Therefore, important messages such as failures will have priority over less-important
    messages, such as debugging. Ideally, the decision about which level of logging
    should be exposed is normally made by adding input arguments to your program that
    allow setting the log level. So, if you are running the program for debugging,
    it will generate much more information compared to a normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can add logging events to our code in Go and then we check
    how to do it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event logging in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go language has a standard library for logging that comes with the Go installation,
    but it is quite limited. For more advanced logging capabilities in Go, you might
    want to use third-party libraries for logging.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can use the standard library and then check other popular third-party
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard Go logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard logging library in Go can be imported using `log` in the `import`
    statement. By default, Go standard logging does not provide any severity levels,
    but it has some helper functions that can help create logs. The helper functions
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Print`, `Printf`, and `Println`: These functions print the message passed
    to them in the terminal using `stderr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panic`, `Panicf`, and `Panicln`: These are like `Print`, but they call `Panic`
    after printing the log message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fatal`, `Fatalf`, and `Fatalln`: These also work like `Print`, but they call
    `os.Exit(1)` after printing the log message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a simple example of using the standard Go logging library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program will print the following output without errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If for any reason it is not possible to retrieve the current user, it will call
    `Fatalf`, which will call `os.Exit(1)` after printing the failed message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s show a more complex example of how to create severity levels using
    the standard logging library and saving it to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created five levels of severity that can be used
    to write to a file as required. Note that in Go, the `init()` function is executed
    before the `main()` function. If you want to use these log definitions within
    other packages, remember to use capitalization of the variables; otherwise, the
    variables will be local to this package; for example, `errorLog` should be `ErrorLog`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you want to set a log level to avoid `Debug` or `Info` messages, you
    will have to pass an argument to your program and suppress lower levels of severity
    depending on the level set. Using the Go standard logging library, you will have
    to do that on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s investigate a third-party logging library that is very popular with
    Go developers.
  prefs: []
  type: TYPE_NORMAL
- en: Using logrus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps one of the most popular libraries for logging in Go, `logrus` is a structured
    logging library with several logging capabilities. `logrus` has seven log levels
    and is compatible with the standard logging library. By default, the library allows
    you to set the log level, so it won’t create noise if you don’t want to see debugging
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of using `logrus` and setting the log level to `Error`,
    which means lower-level logs will not show, such as `Warning`, `Info,` or `Debug`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding example will only show the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because the level of severity is set to `ErrorLevel`, none of the less-significant
    log messages will be displayed – in the example, the calls for `log.Info` and
    `log.Debug`.
  prefs: []
  type: TYPE_NORMAL
- en: '`logrus` is very flexible and powerful with plenty of examples of usage on
    the internet. More details on `logrus` can be found at [https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use more logging libraries in Go, here is a compiled list of
    third-party log libraries: [https://awesome-go.com/logging/](https://awesome-go.com/logging/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check how we add logging to our code using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Add event logging in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In comparison to Go, Python has added many more features to the standard logging
    library. Despite the better support, the Python community has also developed many
    third-party logging libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the standard library and then a popular third-party library
    for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard logging for Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard logging library comes with five severity levels and an extra level
    that is used to indicate the level was not set by the logger. Each level has a
    number associated with it that can be used to interpret the priority level, where
    lower numbers have lower priority. The levels are `CRITICAL` (50), `ERROR` (40),
    `WARNING` (30), `INFO` (20), `DEBUG` (10), and `NOTSET` (0).
  prefs: []
  type: TYPE_NORMAL
- en: The `NOTSET` level is useful when using log hierarchies, allowing a non-root
    logger to delegate the level to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of using Python standard logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding program will produce the following line in the output
    file called `file-log.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in the preceding code, setting the level to `logging.ERROR` will
    not allow the lower-level log messages to be written in the file. The program
    just ignores the `logging.debug()`, `logging.info()`, and `logging.warning()`
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is to show how easier it is to use standard logging
    in Python. The preceding example shows that you just need one call to `logging.basicConfig`
    to set almost everything you need, from the formatter to the level of severity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being easy to use, the Python community has created great tutorials
    and documentation for the standard logging library. Here are the three main references
    for the documentation and advanced utilization info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/logging](https://docs.python.org/3/library/logging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/howto/logging-cookbook.html](https://docs.python.org/3/howto/logging-cookbook.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, the Python standard logging library is quite complete, and you won’t
    need to use a third-party library for most of your work. However, there are some
    nice and interesting features in one popular third-party library for Python called
    `loguru`. Let’s see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python loguru
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python `loguru` provides a few more features than the standard Python logging
    library and has the aim of being easier to use and configure. For instance, using
    `loguru`, you will be able to set file rotation on the log file, use a more advanced
    string formatter, and use decorators to catch exceptions on functions, and it
    is thread and multiprocessing safe.
  prefs: []
  type: TYPE_NORMAL
- en: It also has interesting features that can allow you to add extra information
    to the logging by using a `patch` method (more on the `patch` method at [https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch](https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example using `loguru`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding example will create a file with the date and time with
    log messages that will rotate if it reaches 1 MB in size. The output written in
    the file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: More detailed documentation can be found at [https://loguru.readthedocs.io](https://loguru.readthedocs.io)
    and the source code at [https://github.com/Delgan/loguru](https://github.com/Delgan/loguru).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you are probably more aware of why we need to handle
    errors and why we need to create proper event logging. You also should be more
    familiar with the differences between how Go and Python handle errors. Furthermore,
    you saw the differences in how to use standard libraries and third-party libraries
    for event logging. From now on, your network automation code design will have
    a special section on logging and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about how we can scale our code and
    how our network automation solution can interact with large networks.
  prefs: []
  type: TYPE_NORMAL
