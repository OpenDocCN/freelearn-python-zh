<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Building a Serverless Application in AWS</h1>
                
            
            
                
<p class="calibre2">This chapter will introduce the concept of serverless applications using AWS Lambda as the tool of choice. This will help you understand the concept, intuition, and working components involved in a serverless tool. It will also explain the nuances involved in security, user-controls, and versioning code inside Lambda. You will be guided via hands-on tutorials and lessons for understanding and learning to use AWS Lambda. So, it is recommended that you follow along this chapter with a laptop and an AWS account setup to easily execute the given instructions.</p>
<p class="calibre2">This chapter will cover the following topics:</p>
<ul class="calibre9">
<li class="calibre10">Triggers in AWS Lambda</li>
<li class="calibre10">Lambda functions</li>
<li class="calibre10">Functions as containers</li>
<li class="calibre10">Configuring functions</li>
<li class="calibre10">Testing Lambda functions</li>
<li class="calibre10">Versioning Lambda functions</li>
<li class="calibre10">Creating deployment packages</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Triggers in AWS Lambda</h1>
                
            
            
                
<p class="calibre2">Serverless functions are on-demand computational concepts. So, there has to be an event that needs to trigger a Lambda function so that the entire computational process is started. AWS Lambda has several events which can act as a trigger. Almost all services of AWS can act as AWS Lambda's triggers. Here is the list of services that you can use for generating events for Lambda to respond to:</p>
<ul class="calibre9">
<li class="calibre10">API Gateway</li>
<li class="calibre10">AWS IoT</li>
<li class="calibre10">CloudWatch Events</li>
<li class="calibre10">CloudWatch Logs</li>
<li class="calibre10">CodeCommit</li>
<li class="calibre10">Cognito Sync Trigger</li>
<li class="calibre10">DynamoDB</li>
<li class="calibre10">Kinesis</li>
<li class="calibre10">S3</li>
<li class="calibre10">SNS</li>
</ul>
<p class="calibre2">The triggers page of AWS Lambda looks like this:</p>
<div><img src="img/00007.jpeg" class="calibre21"/></div>
<p class="calibre2">Let's take a look at some of the following important and widely-used triggers that are available, and understand how they can be leveraged as FaaS in the serverless paradigm. They are as follows:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">API Gateway</strong>: This trigger can be used to create efficient, scalable, and serverless APIs. One scenario where a serverless API makes sense would be while building a querying interface for S3. Let us assume that we have a bunch of text files in an S3 bucket. Whenever a user hits the API with a query parameter, which can be some word that we want to search in the text files in the bucket, the API Gateway's trigger will launch a Lambda function that executes the computational logic and workload for executing the query. The Lambda function that we want our API to trigger can be specified at the API creation time. The trigger will be created accordingly in the corresponding Lambda function's console. This is what it looks like:</li>
</ul>
<div><img src="img/00008.jpeg" class="calibre22"/></div>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">CloudWatch</strong>: It events mostly help the user in setting the cron scheduling for Lambda. The CloudWatch Logs trigger is useful whenever a user wants to execute a computational workload depending on some keyword in the Cloudwatch Logs. However, the CloudWatch Alarms cannot trigger Lambda directly via the CloudWatch trigger. They have to be sent via a notification system, such as the <strong class="calibre1">AWS Simple Notification Service</strong> (<strong class="calibre1">AWS SNS</strong>). This is how you can create a cron execution in AWS Lambda. In the following screenshot, the Lambda function is set to execute every minute:</li>
</ul>
<div><img src="img/00009.jpeg" class="calibre23"/></div>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">S3</strong>: This is a document store of AWS. So, whenever a file is added, removed, or changed, an event will be sent to AWS Lambda when added as a trigger. So, if you want to do some computational workload on a file as soon as the file gets uploaded, then this trigger helps to do that. This is what an S3's event structure looks like:</li>
</ul>
<div><img src="img/00010.jpeg" class="calibre24"/></div>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">AWS SNS</strong>: The SNS service of AWS helps users to send notifications to other systems. This service can also be used for catching CloudWatch Alarms and sending the notifications to a Lambda function for computational execution. This is what a sample SNS event looks like:</li>
</ul>
<div><img src="img/00011.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lambda functions</h1>
                
            
            
                
<p class="calibre2"><strong class="calibre4">Lambda functions</strong> are the core operating parts of a serverless architecture. They contain the code which is supposed to be executed. These functions are executed whenever the trigger attached to it has been set off. We have already learned about some of the most popular Lambda triggers in the previous section. </p>
<p class="calibre2">Whenever a Lambda function is triggered, it creates a container with the respective settings set by the user. We'll learn more about the container in our next section.</p>
<p class="calibre2">The spinning up of containers takes a bit of time, which may result in a latency whenever a fresh invocation of a Lambda function is done, as it takes time to set up the environment and bootstrap the settings mentioned by the user in the Advanced settings tab. So, to overcome this latency, AWS thaws a container for some time for reuse in case of another Lambda invocation within the thawing time. So, using a thawed or a ready-made Lambda function helps in overcoming the latency problem. However, the same global namespace of the thawed container would be reused for the new invocation too. </p>
<p class="calibre2">So, if the Lambda function has any global variables that get manipulated inside the function, it is a good idea to convert them into local namespaces, as the manipulated global namespace variables will be reused, leading to faulty execution results of the Lambda function.</p>
<p class="calibre2">The user needs to specify the technical details for the Lambda function in the Advanced Settings tab, which include the following:</p>
<ul class="calibre9">
<li class="calibre10">Memory (MB): This is the maximum memory that the Lambda function needs to be allocated for the purpose of your function. The CPU of the container would be assigned accordingly.</li>
<li class="calibre10">Timeout: The maximum amount of time the function needs to execute before the container gets automatically stopped.</li>
<li class="calibre10">DLQ Resource: This is a dead-letter setting to AWS Lambda. The user can add either an SQS queue or an SNS topic for configuring this. Lambda functions get asynchronously retried for at least five times on failure.</li>
<li class="calibre10">VPC: This enables the Lambda function to access components or services in some particular VPCs. The Lambda function executes in a default VPC of its own.</li>
<li class="calibre10">KMS key: If there are any environment variables entered along with the Lambda function, this helps us encrypt them using an <strong class="calibre1">AWS Key Management Service</strong> (<strong class="calibre1">KMS</strong>) by default.</li>
</ul>
<p class="calibre2">The Lambda function's Advanced settings page looks like this:</p>
<div><img src="img/00012.jpeg" class="calibre26"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Functions as containers</h1>
                
            
            
                
<p class="calibre2">For understanding the concept of functions being executed as/inside containers, we need to properly understand the concept of containers. To cite the definition of a container from the Docker documentation (<a href="https://www.docker.com/what-docker" class="calibre8">https://www.docker.com/what-docker</a>)<a href="https://www.docker.com/what-docker" class="calibre8">:</a></p>
<p>A container image is a lightweight, stand-alone, executable package of a piece of software that includes everything needed to run it: code, runtime, system tools, system libraries, settings.</p>
<p class="calibre2">What is available for both Linux and Windows based applications; containerized software will always run the same, regardless of the environment.</p>
<p class="calibre2">Containers isolate software from its surroundings (for example, differences between development and staging environments) and help reduce conflicts between teams running different software on the same infrastructure.</p>
<p class="calibre2">So, the concept of containers is that they are self-sustainable isolated environments just like the containers in a container ship that can be hosted and be worked upon any host OS, the host OS being the host ship in our analogy. The figurative depiction of the analogy would look something like this:</p>
<div><img src="img/00013.jpeg" class="calibre27"/></div>
<p class="calibre2">Similar to the aforementioned analogy, AWS Lambda's functions are also launched inside a unique container for each function. So, let us understand this topic in more detail, point by point:</p>
<ol class="calibre13">
<li value="1" class="calibre10">The Lambda function can be in the form of a single code file or in the form of a <strong class="calibre1">deployment package</strong>. The deployment package is a zipped file that includes the core function file along with the libraries which would be used by the function. We shall be learning in detail about how to create the deployment package in the <em class="calibre28">Creating deployment packages</em> section of this chapter.</li>
<li value="2" class="calibre10">Whenever a function is triggered or started, AWS spins up an EC2 instance with the AWS Linux operating system for running the function. The configuration of the instance would be dependent on the ones provided by the user in the Advanced settings tab of the Lambda function.</li>
<li value="3" class="calibre10">There is a maximum time limit of 300 seconds, or 5 minutes, for a function to execute successfully, after which the container would be destroyed. So, this needs to be kept in mind while designing the Lambda functions and/or the deployment packages.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Configuring functions</h1>
                
            
            
                
<p class="calibre2">In this section, we will go through the ways of configuring Lambda functions and understand all the settings in great detail. Like in the previous section, we will learn about each configuration and its settings, as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre10">You can go to the page of AWS Lambda by selecting it from the drop-down menu that is present in the top-left corner of the AWS console. This can be done as follows:</li>
</ol>
<div><img src="img/00014.jpeg" class="calibre29"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Once the Lambda option is selected, it redirects the user to the AWS Lambda console, which looks something like this:</li>
</ol>
<div><img src="img/00015.jpeg" class="calibre30"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">For creating a function, you need to click on the orange Create a function button on the right. This will open a console for the function creation. This looks something like this:</li>
</ol>
<div><img src="img/00016.jpeg" class="calibre31"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Let's create a function from scratch in order to understand the configurations better. So, for doing that, click on the Author from scratch button on the top-right corner. After clicking it, the user will be directed to Lambda's first-run console, which looks something like this:</li>
</ol>
<div><img src="img/00017.jpeg" class="calibre32"/></div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">This page has three configurations which the user can select, which are Name, Role, and Existing role. The Name value is where the user can enter the name of the Lambda function. The Role value is how you can define permissions in the AWS environment. The Role value's drop-down list would contain the following options: Choose an existing role, Create new role from template(s), and Create a custom role. They can be seen as follows:</li>
</ol>
<p class="cdpaligncenter1"><img src="img/00018.jpeg" class="calibre33"/></p>
<p class="calibre34">The Choose an existing role option will enable us to select an already existing role with pre-configured permissions. The second option helps the user with creating a role from pre-baked templates. The Create a custom role option allows the user to create a role with permissions from scratch. The list of pre-baked roles looks like this:</p>
<div><img src="img/00019.jpeg" class="calibre35"/></div>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">Select one from the pre-baked templates for the sake of this tutorial. By pressing Create function in the lower-right part of the screen, we will land on the Lambda function's creation page, which looks similar to this:</li>
</ol>
<div><img src="img/00020.jpeg" class="calibre36"/></div>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">The preceding page indicates that we have successfully created an AWS Lambda function. We shall now explore the advanced settings of this function. They are present in the lower part of the same console. They will look something like this:</li>
</ol>
<div><img src="img/00021.jpeg" class="calibre37"/></div>
<p class="calibre34">We shall now try to understand each of those parts in detail. </p>
<ol start="8" class="calibre13">
<li value="8" class="calibre10">The unfurled Environment variables section contains text boxes to enter the key-value pair of environment variables that will be used by our function. One can also optionally mention details on the encryption setting that we want to have for the environment variables. The encryption needs to be done via <strong class="calibre1">AWS KMS</strong> (<strong class="calibre1">Key Management Service</strong>). The unfurled settings box of the environment variables looks something like this:</li>
</ol>
<div><img src="img/00022.jpeg" class="calibre38"/></div>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">The next settings section is Tags. This is similar to the tagging feature of all the available AWS services for easy service discovery purposes. So, similar to all AWS services's tags, this also needs just a key and a value. The unfurled Tags section looks something like this:</li>
</ol>
<div><img src="img/00023.jpeg" class="calibre39"/></div>
<ol start="10" class="calibre13">
<li value="10" class="calibre10">The next section that will be visible after the Tags section is the Execution role section, in which the user can set the <strong class="calibre1">Identity Access Management (IAM)</strong> role for the execution of the Lambda function. As we have already discussed what IAM roles are previously in the book, we will not be covering that again here. If the user has not set the role when creating the function itself, they can always set that here. The section will be visible in the Lambda console as follows:<br class="title-page-name"/>
<div><img src="img/00024.jpeg" class="calibre40"/></div>
</li>
</ol>
<ol start="11" class="calibre13">
<li value="11" class="calibre10">The next section is the Basic settings section, which includes settings such as the memory of the Lambda container, time-out for the container, and the description for the Lambda function. The memory of the container can range from 128 MB to 1,536 MB. The user can choose any value within that range and will be billed accordingly. The time-out can be set from 1 second to 300 seconds, which is 5 minutes. The time-out is the time which the Lambda function and its container would run before being stopped or terminated. The next setting is the Description value of the Lambda function, which acts as the metadata of a Lambda function. The section looks like this in the console:
<div><img src="img/00025.jpeg" class="calibre41"/></div>
</li>
</ol>
<ol start="12" class="calibre13">
<li value="12" class="calibre10">The next section is the Network section, which is also about the network settings of the Lambda function related to <strong class="calibre1">AWS's Virtual Private Cloud</strong> (<strong class="calibre1">VPC</strong>) and related subnets. Even if No VPC is selected as an option, AWS Lambda runs in its own secure VPC. However, if your Lambda function accesses or deals with any other service which is in a particular VPC or in a subnet, the corresponding information needs to be added in this section so that the network allows traffic from the Lambda function's container. This section looks like this in the console:
<div><img src="img/00026.jpeg" class="calibre42"/></div>
The sensitive information in the preceding screenshot, such as the IP address and the ID of the VPC, are masked for security purposes.</li>
<li value="13" class="calibre10">The next section is the Debugging and error handling section. This section enables the user to set up measures for ensuring fault tolerance and exception handling of the Lambda function. This includes the <strong class="calibre1">Dead Letter Queue</strong> (<strong class="calibre1">DLQ</strong>) settings.</li>
<li value="14" class="calibre10">Lambda automatically retries failed executions for asynchronous invocations. So, the payloads that were not processed would be automatically forwarded to the DLQ resource. The DLQ settings look like this in the Lambda console:</li>
</ol>
<div><img src="img/00027.jpeg" class="calibre43"/> </div>
<p class="calibre44">The user can also enable active tracing for the Lambda functions, which would help in detailed monitoring of the Lambda container. This setting in the Debugging and error handling section of the Lambda console looks like this: </p>
<div><img src="img/00028.jpeg" class="calibre45"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Testing Lambda functions</h1>
                
            
            
                
<p class="calibre2">Just like every other software system and programming paradigm, proper testing of Lambda functions and serverless architectures is very important before deploying into production. We will try to understand the testing of Lambda functions in the following points:</p>
<ol start="1" class="calibre13">
<li value="1" class="calibre10">In the top-most bar of the Lambda console, one can observe the Save and test option, which is represented by an orange button. This button saves the Lambda function and then runs the configured tests on that function. This looks something like this in the console:</li>
</ol>
<div><img src="img/00029.jpeg" class="calibre46"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Also, in the same bar, there exists a drop-down menu that reads Select a test event…. This contains a list of testing events available for testing Lambda functions. The drop-down looks like this:</li>
</ol>
<div><img src="img/00030.jpeg" class="calibre47"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Now, for further configuration of test events for the Lambda function, the user needs to select the Configure test events option in the drop-down. This will open a popup with the test events menu, which looks like this:</li>
</ol>
<div><img src="img/00031.jpeg" class="calibre48"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">That would open the basic Hello World template, which has three pre-configured JSON format test events, or edge cases. However, depending on what the Lambda function does, one can select some other test event. The available list of testing templates can be seen in the Event template drop-down menu. The list in the drop-down looks something like this:</li>
</ol>
<div><img src="img/00032.jpeg" class="calibre48"/></div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">For example, let's imagine we are building a pipeline that involves the Lambda function getting started whenever an image file is added to an S3 bucket, and the function does some image processing tasks and puts it back to some data store. The test event of the S3 Put notification looks something like this:</li>
</ol>
<div><img src="img/00033.jpeg" class="calibre49"/></div>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">After selecting or creating a test event, the user can select the Create option in the bottom-right corner of the event creation console, wherein you shall be asked to enter a name for the event. After entering the necessary details, the user will be re-directed back to the Lambda console. Now, when you check the TestEvent drop-down in the Lambda console, you can see the saved test event in the list. This can be verified as follows:</li>
</ol>
<div><img src="img/00034.jpeg" class="calibre50"/></div>
<p class="calibre34">As I have named the event as <strong class="calibre4">TestEvent</strong>, the test is visible by the same name in the events drop-down menu.</p>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">Additionally, when we take a closer look at the event structure of S3 in the test event, we can observe the meta-details that are being made available to the Lambda function. The event structure looks like this:</li>
</ol>
<div><img src="img/00035.jpeg" class="calibre51"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Versioning Lambda functions</h1>
                
            
            
                
<p class="calibre2">The concept of the <strong class="calibre4">Version Control System</strong> (<strong class="calibre4">VCS</strong>) is for controlling and managing versions of code. This functionality is available directly from the main Lambda console. Let's try and learn how to version our Lambda functions:</p>
<ol class="calibre13">
<li value="1" class="calibre10">The first option in the Actions drop-down in the Lambda console is the Publish new version option. This option can be seen here:</li>
</ol>
<div><img src="img/00036.jpeg" class="calibre52"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">When the Publish new version option is selected, the versioning popup of the Lambda console would be seen on the console. This would ask about the name for the new version of your Lambda function. The popup looks something like this:</li>
</ol>
<div><img src="img/00037.jpeg" class="calibre53"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">After clicking the Publish button, you will be re-directed to the main Lambda console. The successfully created Lambda version in the console looks something like this:</li>
</ol>
<div><img src="img/00038.jpeg" class="calibre54"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">In the bottom half of the page, the following message can be noticed: Code and handler editing is only available for the $LATEST version. This means that one can only edit the code in the version named $LATEST.  The versioned version of Lambda functions are read-only and cannot be edited and manipulated. When something goes wrong or when the user wants to revert back or refer to a previous version, that version will overlay the $LATEST version to make edits possible. The message looks like this:</li>
</ol>
<div><img src="img/00039.jpeg" class="calibre55"/></div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">When the Click here to go to $LATEST link is clicked, the user will be re-directed to the $LATEST version of the function, which can be edited and manipulated by the user. The console of the $LATEST version of the Lambda function looks like this:</li>
</ol>
<div><img src="img/00040.jpeg" class="calibre56"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating deployment packages</h1>
                
            
            
                
<p class="calibre2">Lambda functions that have external libraries as dependencies can be packaged as deployment packages and be uploaded into the AWS Lambda console. This is very similar to creating a virtual environment in Python. So in this section, we shall learn and understand the process of creating Python deployment for using in the Lambda functions. We shall try and understand the process of creating deployment packages in detail, as follows:</p>
<ol class="calibre13">
<li class="calibre10" value="1">Deployment packages are generally in the format of ZIP packages. The contents of the ZIP package is exactly the same as a normal library of any programming language. </li>
<li value="2" class="calibre10">The package structure should be such that the library folders and the function file are in the same destination or in the same hierarchy inside the folder structure of the deployment package. The layout looks something like this:</li>
</ol>
<div><img src="img/00041.jpeg" class="calibre48"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">The Python libraries can be installed by using the <kbd class="calibre12">pip install &lt;library_name&gt; -t &lt;path_of_the_target_folder&gt;</kbd> command. This will install the package inside the target folder. This can be done as in the following screenshot:</li>
</ol>
<div><img src="img/00042.jpeg" class="calibre48"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now, when we have the entire deployment package's folder along with the library folders ready, we need to zip all of the folders including the Lambda function file before uploading it into the console. The following screenshot shows how the zipping needs to be done as per the folder hierarchy:</li>
</ol>
<div><img src="img/00043.jpeg" class="calibre48"/></div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Now, as the zipped package is ready, we shall be trying to upload the package to the Lambda console for processing. For uploading a Lambda package, we need to select the drop-down list of the Code entry type option in the console. The selection looks like this in the Lambda console:</li>
</ol>
<div><img src="img/00044.jpeg" class="calibre48"/></div>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">Once the Upload a .ZIP file option is selected, the uploader will become visible, where the user can directly upload the deployment package or even upload it via an S3 bucket. The wizard would look like this in the Lambda console:</li>
</ol>
<div><img src="img/00045.jpeg" class="calibre57"/></div>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">As mentioned previously, the user can choose to upload the deployment package via an S3 file location too. This wizard looks like this in the Lambda console:</li>
</ol>
<div><img src="img/00046.jpeg" class="calibre58"/></div>
<ol start="8" class="calibre13">
<li value="8" class="calibre10">The deployment package's naming should be aligned with the values entered in the handler part of the settings. The deployment package's name and the Lambda function file's name are separated by a dot (<kbd class="calibre12">.</kbd>) and arranged in that order. This can be explicitly seen in the following screenshot:</li>
</ol>
<div><img src="img/00047.jpeg" class="calibre48"/></div>
<p class="calibre34"><kbd class="calibre12">index</kbd> should be the name of the Lambda function's file name deployment package. The <kbd class="calibre12">handler</kbd> function file is the name of the core function handler inside, which is the Lambda function. As AWS's documentation states:</p>
<p>The module-name export value in your function". For example, index.handler would call exports.handler in index.py.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we have learned the concepts of how triggers work for AWS Lambda and how to select triggers depending on the problem statement and time intervals, in case of cron job triggers. We understood what Lambda functions are, along with understanding their functionalities and settings related to memory, VPCs, security, and fault tolerance. We also learned about the way container reuse is done under the hood specifically for AWS Lambda. Then, we covered event-driven functions and how they are implemented under the hood, the concept of containers, and their uses and applications in the domain of software engineering in general. Most importantly, from the concepts we learned regarding containers, we can now appreciate the options for choosing containers for running the Lambda functions.</p>
<p class="calibre2">After that, we talked about all the configuration settings available in the AWS Lambda dashboard, which are necessary to build and run a Lambda function from start to finish without any settings-related problems. We also learned about and understood the security settings inside Lambda so that the necessary VPC details and security keys settings are taken care of when configuring our Lambda functions. This was followed by testing Lambda functions depending on the choice of trigger selected. We learned what the responses of various AWS services look like, as they are the inputs for the Lambda functions. We then learned how to write custom hand-made tests for custom testing purposes.</p>
<p class="calibre2">Following that, we saw how versioning happens for the AWS Lambda functions. We learned the differences between past and present versions. We also learned that the present version is immutable, unlike the past versions, and also how to revert to past versions without much effort. We also learned how to create deployment packages for functions that have dependencies on external packages, which are not included in Python's standard library. We came across the function code naming nuances, including the filename and the method handler names, followed by the two ways deployment packages can be uploaded to the Lambda console; one being a manual upload and the other being from an S3 file location.</p>
<p class="calibre2">In the next chapter, we will be gaining a detailed understanding of the different triggers available in the Lambda console and how to use them. We will also learn about implementing them in Python code. We will understand the event structures and the responses from different AWS services and use that to build our Lambda functions. We will understand how to integrate each trigger into a Lambda function and do a specific task in Python. Finally, we will also be learning about ideas and best practices on how to move your existing infrastructures to serverless using the serverless paradigm.</p>


            

            
        
    </body></html>