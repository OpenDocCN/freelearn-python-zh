- en: 'Chapter 13. Searching: Finding What You Need'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。搜索：找到你需要的东西
- en: Sorting your collections can be costly, but often this represents a one-time
    cost after the collection has been created. However, this time and energy spent
    up front can significantly improve performance once in the life of your application's
    run cycle. Even adding a new object is a much less costly process when the object
    is added to an already sorted collection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的集合进行排序可能会很昂贵，但通常这代表在创建集合后的单次成本。然而，在应用程序运行周期中，这种前期的时间和精力投入可以显著提高性能。即使添加新对象，当它被添加到已排序的集合中时，这个过程也要便宜得多。
- en: 'The real performance improvement comes when it is time to search your collections
    for specific elements or values. In this chapter, we will examine how sorted collections
    greatly improve search time, depending on the search algorithm you choose. We
    will not discuss all of the search algorithms you can choose from, but we will
    examine three of the most common ones:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要搜索你的集合以查找特定元素或值时，真正的性能提升才会到来。在本章中，我们将探讨排序集合如何根据你选择的搜索算法大大提高搜索时间。我们不会讨论你可以选择的所有搜索算法，但我们将检查三种最常见的算法：
- en: Linear search (sequential search)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索（顺序搜索）
- en: Binary search
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索
- en: Jump search
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转搜索
- en: Linear search
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: A search, also called a **sequential** search, is simply a loop through a collection
    with some kind of comparison function to locate a matching element or value. Most
    linear searches return a value representing the index of the matching object in
    the collection, or some impossible index value such as `-1` when an object is
    not found. Alternative versions of this search could return the object itself
    or `null` if the object is not found.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索，也称为**顺序**搜索，简单地说就是通过某种比较函数遍历一个集合，以定位匹配的元素或值。大多数线性搜索返回一个表示集合中匹配对象的索引的值，或者当对象未找到时，返回一些不可能的索引值，例如`-1`。这个搜索的替代版本可以返回对象本身，或者当对象未找到时返回`null`。
- en: This is the simplest form of search pattern and it carries an **O**(*n*) complexity
    cost. This complexity is consistent whether the collection is in random order
    or if it has already been sorted. In very small collections linear searches are
    perfectly acceptable and many developers make use of them daily. However, when
    working with very large collections it is often beneficial to find alternatives
    to this sequential search approach. This is particularly true when working with
    lists of very complex objects, such as spatial geometries, where search or analysis
    can be very processor-intensive operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的搜索模式，它具有**O**(*n*)的复杂度成本。这种复杂度在集合是无序的还是已经排序的情况下都是一致的。在非常小的集合中，线性搜索是完全可接受的，许多开发者每天都在使用它们。然而，当处理非常大的集合时，找到这种顺序搜索方法的替代方案通常是有益的。这尤其适用于处理非常复杂的对象列表，例如空间几何，其中搜索或分析可能是非常耗处理器的操作。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each of the code examples in this chapter will examine search algorithms in
    the form of the methods most essential to the operation, with these being detached
    from their parent classes. Additionally, in each case, the collection of objects
    being sorted will be defined at the class level, outside the example code shown
    here. Likewise, the subsequent object instantiation and population of those collections
    will be defined outside the example code. To see the full class examples, use
    the code examples accompanying this text.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个代码示例都将通过操作中最基本的方法形式来检查搜索算法，这些方法与它们的父类分离。此外，在每个情况下，将要排序的对象集合将在类级别上定义，在下面展示的示例代码之外。同样，后续的对象实例化和这些集合的填充也将定义在示例代码之外。要查看完整的类示例，请使用伴随此文本的代码示例。
- en: '**C#**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: The first example of the linear search algorithm is in the `LinearSearchIndex(int[]
    values, int key)` method. As you can see, this method is very simple and almost
    self-explanatory. There are two major characteristics of this implementation worth
    mentioning. First, the method accepts the array of `values` and the search `key`.
    Second, the method returns the index `i` of any matching element, or simply `-1`
    if the search key is not found.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索算法的第一个示例是在`LinearSearchIndex(int[] values, int key)`方法中。正如你所看到的，这个方法非常简单，几乎是自我解释的。这个实现有两个主要特点值得提及。首先，该方法接受`values`数组（值）和搜索`key`。其次，该方法返回任何匹配元素的索引`i`，或者如果搜索键未找到，则简单地返回`-1`。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second example of a linear search is nearly identical to the first. However,
    in the `LinearSearchCustomer(Customer[] customers, int custId)` method, we are
    not searching for a value but rather for a key that represents the customer that
    the caller wants to retrieve. Note that the comparison is now searching the `customerId`
    field on the `Customer` object; if a match is found, the `Customer` at `customers[i]`
    is returned. If no match is found, the method returns `null`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索的第二个例子几乎与第一个相同。然而，在`LinearSearchCustomer(Customer[] customers, int custId)`方法中，我们不是在搜索一个值，而是在搜索一个代表调用者想要检索的客户的键。请注意，现在的比较是在`Customer`对象的`customerId`字段上进行的；如果找到匹配项，则返回`customers[i]`处的`Customer`。如果没有找到匹配项，该方法返回`null`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Java**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: The Java implementation of each method is nearly identical in design to the
    C# implementation, except for the name of the array `length` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的Java实现的设计几乎与C#实现相同，只是数组的`length`函数的名称不同。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Objective-C**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine `intValue`. Otherwise,
    these implementations are fundamentally the same as the C# or Java implementations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`只能存储对象，我们需要将我们的值转换为`NSNumber`，在评估成员时，我们需要显式检查`intValue`。否则，这些实现与C#或Java实现基本相同：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Swift**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, Swift does not allow a method to return `nil` unless the
    return type is explicitly declared as optional, so the `linearSearchCustomer(
    customers: [Customer], custId: Int)` method has a return type of `Customer?`.
    Otherwise, the functionality is fundamentally the same as its predecessors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swift不允许C样式的`for`循环，因此我们的方法必须使用Swift 3.0的等效方法。此外，Swift不允许方法返回`nil`，除非返回类型明确声明为可选，因此`linearSearchCustomer(customers:
    [Customer], custId: Int)`方法的返回类型为`Customer?`。否则，其功能与其前辈基本相同：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Binary search
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: When dealing with an unsorted collection, a sequential search is probably the
    most reasonable approach. However, when working with a sorted collection there
    are better methods of finding matches to search keys. One alternative is a binary
    search. A binary search is typically implemented as a recursive function and works
    on the principle of repeatedly dividing the collection in half and searching smaller
    and smaller chunks of the collection until a match is found or until the search
    has exhausted the remaining options and turns up empty.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理未排序的集合时，顺序搜索可能是最合理的方法。然而，当与排序集合一起工作时，有更好的方法来找到与搜索键匹配的方法。一个替代方案是二分搜索。二分搜索通常实现为一个递归函数，其工作原理是反复将集合分成两半，并搜索越来越小的集合块，直到找到匹配项或搜索耗尽剩余选项并返回空。
- en: 'For example, given the following set of ordered values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定以下有序值集合：
- en: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
- en: Using a linear search to find the value `143` would have a complexity cost of
    **O**(8) since `143` is found at index 7 (position 8) in our collection. However,
    a binary search can take advantage of the sorted nature of the collection to improve
    upon this complexity cost.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性搜索查找值`143`将具有**O**(8)的复杂度成本，因为`143`在我们的集合中位于索引7（位置8）。然而，二分搜索可以利用集合的排序特性来提高这种复杂度成本。
- en: 'We know that the collection consists of nine elements, so the binary search
    would begin by examining the median element at index 5 and comparing that to the
    key value of `143`. Since *i[5] = 75*, and this is less than `143`, the set is
    split and the range of possible matches is reduced to only include the upper half,
    leaving us with:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道集合由九个元素组成，因此二分搜索将首先检查索引5的中值元素，并将其与键值`143`进行比较。由于*i[5] = 75*，这小于`143`，因此集合被分割，可能的匹配项的范围仅包括上半部分，留下：
- en: '*S = {103, 121, 143, 201}*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {103, 121, 143, 201}*'
- en: 'With four elements, the median element is the element at position two. Position
    *i[2] = 121*, and this is less than `143` so the set is split and the range of
    possible matches is reduced to only include the upper quarter, leaving us with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四个元素，中值元素是位置二的元素。位置*i[2] = 121*，这小于`143`，因此集合被分割，可能的匹配项的范围仅包括上半部分，留下：
- en: '*S = {143, 201}*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {143, 201}*'
- en: 'With two elements, the median element is the element at position one. Since
    *i[1] = 143*, we have found a match and the value can be returned. This search
    only cost **O**(3), improving on the linear search time by almost 67%. Although
    individual results may vary, the binary search pattern is consistently more efficient
    than the linear search when the collection is sorted. This is a strong justification
    for taking the time to sort your collections before your application begins to
    use data supplied by them:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个元素时，中值元素是位置一的元素。由于*i[1] = 143*，我们找到了匹配项，可以返回该值。这种搜索只花费了**O**(3)的时间，几乎提高了67%的线性搜索时间。尽管个别结果可能会有所不同，但当集合已排序时，二分搜索模式始终比线性搜索更有效。这是在应用程序开始使用它们提供的数据之前花时间对集合进行排序的强有力的理由：
- en: '**C#**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: The `BinarySort(int[] values, int left, int right, int key)` begins by checking
    if the `right` index is greater than or equal to the `left` index. If `false`,
    there are no elements within the prescribed range and the analysis has been exhausted
    so the method returns `-1`. We'll examine why in a moment. Otherwise, method execution
    continues because there is at least one object in the defined range.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySort(int[] values, int left, int right, int key)`首先检查`right`索引是否大于或等于`left`索引。如果不是，则指定范围内的没有元素，分析已经用尽，因此方法返回`-1`。我们稍后将检查原因。否则，方法执行继续，因为定义的范围内至少有一个对象。'
- en: 'Next, the method checks whether the value at the `middle` index matches our
    `key`. If `true`, the `middle` index is returned. Otherwise, the method checks
    whether the values at the `middle` index are greater than the `key` value. If
    `true`, `BinarySort(int[] values, int left, int right, int key)` is called recursively
    with bounds that select the lower half of the current range of elements. Otherwise,
    the value at the `middle` index is less than the `key`, so `BinarySort(int[] values,
    int left, int right, int key)` is called recursively with bounds that select the
    upper half of the current range of elements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，方法检查`middle`索引处的值是否与我们的`key`匹配。如果是`true`，则返回`middle`索引。否则，方法检查`middle`索引处的值是否大于`key`值。如果是`true`，则以选择当前元素范围下半部分的边界递归调用`BinarySort(int[]
    values, int left, int right, int key)`。否则，`middle`索引处的值小于`key`，因此以选择当前元素范围上半部分的边界递归调用`BinarySort(int[]
    values, int left, int right, int key)`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Java**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Apart from the name `binarySearch(int[] values, int left, int right, int key)`,
    the Java implementation is identical in design to the C# implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`binarySearch(int[] values, int left, int right, int key)`这个名称外，Java实现的设计与C#实现相同：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Objective-C**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`.
    Otherwise, these implementations are fundamentally the same as the C# or Java
    implementations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`只能存储对象，我们需要将我们的值转换为`NSNumber`，并且在评估成员时，我们需要显式检查`intValue`。否则，这些实现与C#或Java实现基本相同：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Swift**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Fundamentally, the Swift implementation is the same as its predecessors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Swift实现与其前辈相同：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Jump search
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃搜索
- en: Another search algorithm that can improve performance with sorted arrays is
    the **jump search**. A jump search bears some similarity to both the linear search
    and binary search algorithms in that it searches blocks of elements from left
    to right beginning with the first block in the collection, and also because at
    each jump the algorithm compares the search key value to the value of the element
    at the current step. If the algorithm determines that the key could exist in the
    current subset of elements, the next step (no pun intended) is to examine each
    element in the current subset to determine if it is less than the key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以改善排序数组性能的搜索算法是**跳跃搜索**。跳跃搜索在某种程度上与线性搜索和二分搜索算法相似，因为它从集合的第一个块开始，从左到右搜索元素块，并且在每次跳跃时，算法将搜索键值与当前步骤的元素值进行比较。如果算法确定键可能存在于当前元素子集中，下一步（无意中开玩笑）就是检查当前子集中的每个元素，以确定它是否小于键。
- en: Once an element is found that is not less than the key , that element is compared
    to the key. If the element is equal to the key, it is returned; otherwise, it
    is greater than the key, which means that the key does not exist in the collection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个不小于键的元素，该元素就会与键进行比较。如果元素等于键，则返回；否则，它大于键，这意味着键不存在于集合中。
- en: The jump length *m* is not an arbitrary value, but rather is calculated based
    on the length of the collection using the formula *m =* √*n*, where *n* is the
    total number of elements in the collection. The jump search begins by examining
    the value of the last object in the first block or subset.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃长度 *m* 不是一个任意值，而是基于集合长度通过公式 *m =* √*n* 计算得出的，其中 *n* 是集合中元素的总数。跳跃搜索首先检查第一个块或子集的最后一个对象的值。
- en: 'For example, let''s search for value *143* given the following set of ordered
    values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在以下有序值集合中搜索值 *143*：
- en: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
- en: 'Since our collection contains nine elements, *m = √* *n* gives us a value of
    3\. Since *i[2] = 23*, and this is less than *143*, the algorithm jumps to the
    next block. Next, *i[4] = 103* which is also less than *143* so this subset is
    excluded. Finally, *i[8] = 201*. Since *201* is greater than *143*, the key could
    possible exist in the third subset:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的集合包含九个元素，*m = √* *n* 给我们一个值为 3 的结果。由于 *i[2] = 23*，并且这个值小于 *143*，算法跳到下一个块。接下来，*i[4]
    = 103*，这也小于 *143*，所以这个子集被排除。最后，*i[8] = 201*。由于 *201* 大于 *143*，键可能存在于第三个子集中：
- en: '*S[3] = {121, 143, 201}*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*S[3] = {121, 143, 201}*'
- en: Next, the algorithm checks each element in this subset to determine if it is
    less than *143*. And *i[6] = 121*, so the algorithm continues its examination.
    Also, *i[7] = 143* which is not less than *143*, so the execution proceeds to
    the final step. Since *i[7] = 143*, we have found a match to our key and the value
    of *i* can be returned. This search cost **O**(5), which is only slightly better
    than the **O**(7) the linear search produced and slightly worse than the **O**(3)
    cost we found with a binary search. However, with much larger data sets the jump
    search is consistently more efficient than a linear and binary search when the
    collection is sorted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，算法检查这个子集中的每个元素，以确定它是否小于 *143*。并且 *i[6] = 121*，所以算法继续检查。另外，*i[7] = 143*，这并不小于
    *143*，所以执行继续到最后一步。由于 *i[7] = 143*，我们找到了与我们的键匹配的值，并且可以返回 *i* 的值。这次搜索的成本是 **O**(5)，这比线性搜索产生的
    **O**(7) 略好，但比我们找到的 **O**(3) 成本略差。然而，对于更大的数据集，当集合已排序时，跳跃搜索在大多数情况下比线性搜索和二分搜索更有效。
- en: Again, sorting the collection does represent some cost in time and performance
    up front, but the payoff over the life span of your application's run cycle is
    more than justifies the effort.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对集合进行排序确实在时间和性能上代表了一些前期成本，但你的应用程序运行周期中的回报远远超过了这些努力。
- en: '**C#**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: Each of our implementations of the `BubbleSort` method begins by declaring three
    `int` variables to track the size of the collection, the step size, and the previously
    evaluated index. Following this, a `while` loop uses the `prev` and `step` values
    to define and search subsets of the collection for a range where the `key` could
    exist. If no acceptable subset is found, the method returns `-1` indicating that
    the `key` cannot exist in this set. Otherwise, the value of `prev` and `step`
    identify the subset where the `key` might exist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `BubbleSort` 方法的每个实现都从声明三个 `int` 变量开始，以跟踪集合的大小、步长和先前评估的索引。随后，一个 `while`
    循环使用 `prev` 和 `step` 值来定义和搜索集合的子集，以确定 `key` 可能存在的范围。如果没有找到可接受的子集，该方法返回 `-1`，表示
    `key` 不能存在于这个集合中。否则，`prev` 和 `step` 的值标识了 `key` 可能存在的子集。
- en: The next `while` loop examines each element within the subset to determine if
    it is less than the `key`. If no acceptable element is found, the method returns
    `-1` indicating that the `key` cannot exist in this set. Otherwise, the value
    of `prev` identifies the best possible match for `key` in the subset.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `while` 循环检查子集中每个元素，以确定它是否小于 `key`。如果没有找到可接受的元素，该方法返回 `-1`，表示 `key` 不能存在于这个集合中。否则，`prev`
    的值标识了 `key` 在子集中可能的最佳匹配。
- en: 'Finally, the element at `prev` is compared to the `key`. If the two values
    match, then `prev` is returned. Otherwise, we reach the end of execution and `-1`
    is returned:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `prev` 位置的元素与 `key` 进行比较。如果两个值匹配，则返回 `prev`。否则，我们到达执行结束，返回 `-1`：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Java**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: The Java implementation of each method is nearly identical in design to the
    C# implementations, except for the name of the array `length` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的 Java 实现在设计上几乎与 C# 实现相同，只是数组 `length` 函数的名称不同。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Objective-C**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`.
    Otherwise, this implementation is fundamentally the same as the C# or Java implementations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `NSArray` 只能存储对象，我们需要将我们的值转换为 `NSNumber`，当我们评估成员时，需要显式检查 `intValue`。否则，这个实现本质上与
    C# 或 Java 实现相同。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Swift**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Aside from from the extra casting of values returned from `sqrt()` and `floor()`
    methods, the functionality is fundamentally the same as its predecessors:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 `sqrt()` 和 `floor()` 方法返回的值需要额外的类型转换外，其功能本质上与前辈相同：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined several search algorithms. First, we looked at
    linear searching, or sequential searching. Linear searching is barely even an
    algorithm as your code is simply looping through the elements in a collection
    from left to right until a match is found. This approach is useful when working
    with very small collections, or with collections that have not been sorted, if
    for no other reason than it is easy to implement from a development point of view.
    However, when working with large sorted datasets, there are much better alternatives.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个搜索算法。首先，我们研究了线性搜索，或顺序搜索。线性搜索几乎不能算是一个算法，因为你的代码只是简单地从左到右遍历集合中的元素，直到找到匹配项。当处理非常小的集合或未排序的集合时，这种方法是有用的，如果其他原因的话，那就是从开发角度来看易于实现。然而，当处理大型排序数据集时，有更好的替代方案。
- en: The next search algorithm we examined was the binary search. Binary search algorithms
    essentially divide-and-conquer the collection, halving the elements into smaller
    and smaller subsets of the original collection until a match is found or the list
    of possible matches has been exhausted. Whereas a linear search has an **O**(*n*)
    complexity cost, a binary search pattern has a much improved **O**(*log(n)*) complexity
    cost. However, it is absolutely vital that a collection be properly sorted prior
    to running the binary search or the results will be meaningless.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了二分搜索算法。二分搜索算法本质上是通过将集合划分为更小的子集来分而治之，直到找到匹配项或可能的匹配项列表耗尽。与线性搜索的 **O**(*n*)
    复杂度成本相比，二分搜索模式具有显著改进的 **O**(*log(n)*) 复杂度成本。然而，在运行二分搜索之前，确保集合被正确排序是绝对必要的，否则结果将毫无意义。
- en: Finally, we examined the jump search. Jump searches work by sequentially examining
    subsets of the collection that are each √*n* in length where *n* is the total
    number of elements in the collection. Although somewhat more complex to implement,
    and with a worst case complexity of **O**(*n*), the jump search has a vastly improved
    average cost complexity of **O**(√*n*) where *n* is the total number of elements
    in the collection.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了跳跃搜索。跳跃搜索通过顺序检查集合的子集来实现，每个子集的长度为 √*n*，其中 *n* 是集合中元素的总数。尽管实现起来稍微复杂一些，并且最坏情况下的复杂度为
    **O**(*n*)，但跳跃搜索的平均成本复杂度显著提高，为 **O**(√*n*)，其中 *n* 是集合中元素的总数。
