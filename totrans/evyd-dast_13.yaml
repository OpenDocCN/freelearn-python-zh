- en: 'Chapter 13. Searching: Finding What You Need'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting your collections can be costly, but often this represents a one-time
    cost after the collection has been created. However, this time and energy spent
    up front can significantly improve performance once in the life of your application's
    run cycle. Even adding a new object is a much less costly process when the object
    is added to an already sorted collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real performance improvement comes when it is time to search your collections
    for specific elements or values. In this chapter, we will examine how sorted collections
    greatly improve search time, depending on the search algorithm you choose. We
    will not discuss all of the search algorithms you can choose from, but we will
    examine three of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear search (sequential search)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A search, also called a **sequential** search, is simply a loop through a collection
    with some kind of comparison function to locate a matching element or value. Most
    linear searches return a value representing the index of the matching object in
    the collection, or some impossible index value such as `-1` when an object is
    not found. Alternative versions of this search could return the object itself
    or `null` if the object is not found.
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest form of search pattern and it carries an **O**(*n*) complexity
    cost. This complexity is consistent whether the collection is in random order
    or if it has already been sorted. In very small collections linear searches are
    perfectly acceptable and many developers make use of them daily. However, when
    working with very large collections it is often beneficial to find alternatives
    to this sequential search approach. This is particularly true when working with
    lists of very complex objects, such as spatial geometries, where search or analysis
    can be very processor-intensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each of the code examples in this chapter will examine search algorithms in
    the form of the methods most essential to the operation, with these being detached
    from their parent classes. Additionally, in each case, the collection of objects
    being sorted will be defined at the class level, outside the example code shown
    here. Likewise, the subsequent object instantiation and population of those collections
    will be defined outside the example code. To see the full class examples, use
    the code examples accompanying this text.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: The first example of the linear search algorithm is in the `LinearSearchIndex(int[]
    values, int key)` method. As you can see, this method is very simple and almost
    self-explanatory. There are two major characteristics of this implementation worth
    mentioning. First, the method accepts the array of `values` and the search `key`.
    Second, the method returns the index `i` of any matching element, or simply `-1`
    if the search key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example of a linear search is nearly identical to the first. However,
    in the `LinearSearchCustomer(Customer[] customers, int custId)` method, we are
    not searching for a value but rather for a key that represents the customer that
    the caller wants to retrieve. Note that the comparison is now searching the `customerId`
    field on the `Customer` object; if a match is found, the `Customer` at `customers[i]`
    is returned. If no match is found, the method returns `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: The Java implementation of each method is nearly identical in design to the
    C# implementation, except for the name of the array `length` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine `intValue`. Otherwise,
    these implementations are fundamentally the same as the C# or Java implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, Swift does not allow a method to return `nil` unless the
    return type is explicitly declared as optional, so the `linearSearchCustomer(
    customers: [Customer], custId: Int)` method has a return type of `Customer?`.
    Otherwise, the functionality is fundamentally the same as its predecessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with an unsorted collection, a sequential search is probably the
    most reasonable approach. However, when working with a sorted collection there
    are better methods of finding matches to search keys. One alternative is a binary
    search. A binary search is typically implemented as a recursive function and works
    on the principle of repeatedly dividing the collection in half and searching smaller
    and smaller chunks of the collection until a match is found or until the search
    has exhausted the remaining options and turns up empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the following set of ordered values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
  prefs: []
  type: TYPE_NORMAL
- en: Using a linear search to find the value `143` would have a complexity cost of
    **O**(8) since `143` is found at index 7 (position 8) in our collection. However,
    a binary search can take advantage of the sorted nature of the collection to improve
    upon this complexity cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the collection consists of nine elements, so the binary search
    would begin by examining the median element at index 5 and comparing that to the
    key value of `143`. Since *i[5] = 75*, and this is less than `143`, the set is
    split and the range of possible matches is reduced to only include the upper half,
    leaving us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {103, 121, 143, 201}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With four elements, the median element is the element at position two. Position
    *i[2] = 121*, and this is less than `143` so the set is split and the range of
    possible matches is reduced to only include the upper quarter, leaving us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {143, 201}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With two elements, the median element is the element at position one. Since
    *i[1] = 143*, we have found a match and the value can be returned. This search
    only cost **O**(3), improving on the linear search time by almost 67%. Although
    individual results may vary, the binary search pattern is consistently more efficient
    than the linear search when the collection is sorted. This is a strong justification
    for taking the time to sort your collections before your application begins to
    use data supplied by them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: The `BinarySort(int[] values, int left, int right, int key)` begins by checking
    if the `right` index is greater than or equal to the `left` index. If `false`,
    there are no elements within the prescribed range and the analysis has been exhausted
    so the method returns `-1`. We'll examine why in a moment. Otherwise, method execution
    continues because there is at least one object in the defined range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the method checks whether the value at the `middle` index matches our
    `key`. If `true`, the `middle` index is returned. Otherwise, the method checks
    whether the values at the `middle` index are greater than the `key` value. If
    `true`, `BinarySort(int[] values, int left, int right, int key)` is called recursively
    with bounds that select the lower half of the current range of elements. Otherwise,
    the value at the `middle` index is less than the `key`, so `BinarySort(int[] values,
    int left, int right, int key)` is called recursively with bounds that select the
    upper half of the current range of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the name `binarySearch(int[] values, int left, int right, int key)`,
    the Java implementation is identical in design to the C# implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`.
    Otherwise, these implementations are fundamentally the same as the C# or Java
    implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, the Swift implementation is the same as its predecessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Jump search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another search algorithm that can improve performance with sorted arrays is
    the **jump search**. A jump search bears some similarity to both the linear search
    and binary search algorithms in that it searches blocks of elements from left
    to right beginning with the first block in the collection, and also because at
    each jump the algorithm compares the search key value to the value of the element
    at the current step. If the algorithm determines that the key could exist in the
    current subset of elements, the next step (no pun intended) is to examine each
    element in the current subset to determine if it is less than the key.
  prefs: []
  type: TYPE_NORMAL
- en: Once an element is found that is not less than the key , that element is compared
    to the key. If the element is equal to the key, it is returned; otherwise, it
    is greater than the key, which means that the key does not exist in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The jump length *m* is not an arbitrary value, but rather is calculated based
    on the length of the collection using the formula *m =* √*n*, where *n* is the
    total number of elements in the collection. The jump search begins by examining
    the value of the last object in the first block or subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s search for value *143* given the following set of ordered
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {8, 19, 23, 50, 75, 103, 121, 143, 201}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our collection contains nine elements, *m = √* *n* gives us a value of
    3\. Since *i[2] = 23*, and this is less than *143*, the algorithm jumps to the
    next block. Next, *i[4] = 103* which is also less than *143* so this subset is
    excluded. Finally, *i[8] = 201*. Since *201* is greater than *143*, the key could
    possible exist in the third subset:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S[3] = {121, 143, 201}*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the algorithm checks each element in this subset to determine if it is
    less than *143*. And *i[6] = 121*, so the algorithm continues its examination.
    Also, *i[7] = 143* which is not less than *143*, so the execution proceeds to
    the final step. Since *i[7] = 143*, we have found a match to our key and the value
    of *i* can be returned. This search cost **O**(5), which is only slightly better
    than the **O**(7) the linear search produced and slightly worse than the **O**(3)
    cost we found with a binary search. However, with much larger data sets the jump
    search is consistently more efficient than a linear and binary search when the
    collection is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Again, sorting the collection does represent some cost in time and performance
    up front, but the payoff over the life span of your application's run cycle is
    more than justifies the effort.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: Each of our implementations of the `BubbleSort` method begins by declaring three
    `int` variables to track the size of the collection, the step size, and the previously
    evaluated index. Following this, a `while` loop uses the `prev` and `step` values
    to define and search subsets of the collection for a range where the `key` could
    exist. If no acceptable subset is found, the method returns `-1` indicating that
    the `key` cannot exist in this set. Otherwise, the value of `prev` and `step`
    identify the subset where the `key` might exist.
  prefs: []
  type: TYPE_NORMAL
- en: The next `while` loop examines each element within the subset to determine if
    it is less than the `key`. If no acceptable element is found, the method returns
    `-1` indicating that the `key` cannot exist in this set. Otherwise, the value
    of `prev` identifies the best possible match for `key` in the subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the element at `prev` is compared to the `key`. If the two values
    match, then `prev` is returned. Otherwise, we reach the end of execution and `-1`
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: The Java implementation of each method is nearly identical in design to the
    C# implementations, except for the name of the array `length` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`.
    Otherwise, this implementation is fundamentally the same as the C# or Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from from the extra casting of values returned from `sqrt()` and `floor()`
    methods, the functionality is fundamentally the same as its predecessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined several search algorithms. First, we looked at
    linear searching, or sequential searching. Linear searching is barely even an
    algorithm as your code is simply looping through the elements in a collection
    from left to right until a match is found. This approach is useful when working
    with very small collections, or with collections that have not been sorted, if
    for no other reason than it is easy to implement from a development point of view.
    However, when working with large sorted datasets, there are much better alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: The next search algorithm we examined was the binary search. Binary search algorithms
    essentially divide-and-conquer the collection, halving the elements into smaller
    and smaller subsets of the original collection until a match is found or the list
    of possible matches has been exhausted. Whereas a linear search has an **O**(*n*)
    complexity cost, a binary search pattern has a much improved **O**(*log(n)*) complexity
    cost. However, it is absolutely vital that a collection be properly sorted prior
    to running the binary search or the results will be meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined the jump search. Jump searches work by sequentially examining
    subsets of the collection that are each √*n* in length where *n* is the total
    number of elements in the collection. Although somewhat more complex to implement,
    and with a worst case complexity of **O**(*n*), the jump search has a vastly improved
    average cost complexity of **O**(√*n*) where *n* is the total number of elements
    in the collection.
  prefs: []
  type: TYPE_NORMAL
