<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer021">&#13;&#13;
    <h1 class="chapterNumber">1</h1>&#13;&#13;
    <h1 id="_idParaDest-13" class="chapterTitle">Introduction to Software Architecture</h1>&#13;&#13;
    <p class="normal">The objective of this chapter is to present an introduction to what software architecture is and where it's useful. We will look at some of the basic techniques used when defining the architecture of a system and a baseline example of the web services architecture.</p>&#13;&#13;
    <p class="normal">This chapter includes a discussion of the implications that software structure has for team structure and communication. As the successful building of any non-tiny piece of software depends heavily on successful communication and collaboration between one or more teams of multiple developers, this factor should be taken into consideration. Also, the structure of the software can have a profound effect on how different elements are accessed, so how software is structured has ramifications for security.</p>&#13;&#13;
    <p class="normal">Also, in this chapter, there will be a brief introduction to the architecture of an example system that we will be using to present the different patterns and discussions throughout the rest of the book.</p>&#13;&#13;
    <p class="normal">In this chapter, we'll cover the following topics:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Defining the structure of a system</li>&#13;&#13;
      <li class="bullet">Dividing into smaller units</li>&#13;&#13;
      <li class="bullet">Conway's Law in software architecture</li>&#13;&#13;
      <li class="bullet">General overview of the example</li>&#13;&#13;
      <li class="bullet">Security aspects of software architecture</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Let's dive in.</p>&#13;&#13;
    <h1 id="_idParaDest-14" class="title">Defining the structure of a system</h1>&#13;&#13;
    <p class="normal">At its core, software development is about creating and managing complex systems.</p>&#13;&#13;
    <p class="normal">In the early days of computing, programs were relatively simple. At most, they perhaps could calculate a <a id="_idIndexMarker000"/>parabolic trajectory or factorize numbers. The very first computer program, designed in 1843 by Ada Lovelace, calculated a sequence of Bernoulli numbers. A hundred years after that, during the Second World War, electronic computers were invented to break encryption codes. As the possibilities of the new invention started to be explored, more and more complex operations and systems were designed. Tools like compilers and high-level languages multiplied the number of possibilities and the rapid advancement of hardware allowed more and more operations to be performed. This quickly created a need to manage the growing complexity and apply consistent engineering principles to the creation of software.</p>&#13;&#13;
    <p class="normal">More than 50 years after the birth of the computing industry, the software tools at our disposal are incredibly varied and powerful. We stand on the shoulders of giants to build our own software. We can quickly add a lot of functionalities with relatively little effort, either leveraging high-level languages and APIs or using out-of-the-box modules and packages. With this great power comes the great responsibility of managing the explosion of complexity that it produces.</p>&#13;&#13;
    <p class="normal">In the most simple terms, software architecture defines the structure of a software system. This architecture <a id="_idIndexMarker001"/>can develop organically, usually in the early stages of a project, but after system growth and a few change requests, the need to think carefully about the architecture becomes more and more important. As the system becomes bigger, the structure becomes more difficult to change, which affects future efforts. It's easier to make changes following the structure rather than against the structure.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">Making it so that certain changes are difficult to do is not necessarily always a bad thing. Changes that <em class="italic">should</em> be made difficult could involve elements that need to be overseen by different teams or perhaps elements that can affect external customers. While the main focus is to create a system that's easy and efficient to change in the future, a smart architectural design will have a proper balance of ease and difficulty based on the requirements. Later in the chapter, we will study security as a clear example of when to keep certain operations difficult to implement.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">At the core of software architecture, then, is taking a look at the big picture: to focus on where the system is going to be in the future, to be able to materialize this view, but also to help the present situation. The usual choice between short-term wins and long-term operation is very important in development, and its most common outcome is the creation of <a id="_idIndexMarker002"/>technical debt. Software architecture deals mostly with long-term implications.</p>&#13;&#13;
    <p class="normal">The considerations for software architecture can be quite numerous and there needs to be a balance <a id="_idIndexMarker003"/>between them. Some examples may include:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Business vision</strong>, if the system is going to be commercially exploited. This may include requirements coming from stakeholders like marketing, sales, orÂ management. Business vision is typically driven by customers.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Technical requirements</strong>, like being sure that the system is scalable and can handle a certain number of users, or that the system is fast enough for its use case. A news website requires different update times than a real-time trading system.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Security and reliability concerns</strong>, the seriousness of which depends on how risky or critical the application and the data stored are.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Division of tasks</strong>, to allow multiple teams, perhaps specialized in different areas, to work in a flexible way at the same time on the same system. As systems grow, the need to divide them into semi-autonomous, smaller components becomes more pressing. Small projects may live longer with a "single-block" or monolithic approach.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Use specific technologies</strong>, for example, to allow integration with other systems or leverage the existing knowledge in the team.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">These considerations will influence the structure and design of a system. In a sense, the software architect is responsible for implementing the application vision and matching it with the specific technologies and teams that will develop it. That makes the software architect an important intermediary between the business teams and the technology teams, as well as between the different technology teams. Communication is a critical aspect of the job.</p>&#13;&#13;
    <p class="normal">To enable successful communication, a good architecture should define boundaries between the different aspects and assign clear responsibilities. The software architect should, in addition to defining clear boundaries, facilitate the creation of interface channels between the system components and follow up on the implementation details.</p>&#13;&#13;
    <p class="normal">Ideally, the architectural design should happen at the beginning of system design, with a well thought-out design based on the requirements for the project. This is the general approach in this book because it's the best way to explain the different options and techniques. But it's not the most common use case in real life.</p>&#13;&#13;
    <p class="normal">One of the main challenges for a software architect is working with existing systems that need to be adapted, making incremental approaches toward a better system, all while not interrupting the normal daily operation that keeps the business running.</p>&#13;&#13;
    <h1 id="_idParaDest-15" class="title">Division into smaller units</h1>&#13;&#13;
    <p class="normal">The main technique for software architecture is to divide the whole system into smaller elements and <a id="_idIndexMarker004"/>describe how they interact with each other. Each smaller element, or unit, should have a clear function and interface.</p>&#13;&#13;
    <p class="normal">For example, a common architecture for a typical system could be a web service architecture composed of:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">A database that stores all the data in MySQL</li>&#13;&#13;
      <li class="bullet">A web worker that serves dynamic HTML content written in PHP</li>&#13;&#13;
      <li class="bullet">An Apache web server that handles all the web requests, returns any static files, like CSS and images, and forwards the dynamic requests to the web worker</li>&#13;&#13;
    </ul>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_01_01.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="286"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 1.1: Typical web architecture</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This architecture and tech stack has been extremely popular since the early 2000s and was called LAMP, an acronym made from the different open source projects involved: (L)inux as an operating system, (A)pache, (M)ySQL, and (P)HP. Nowadays, the technologies can be swapped for equivalent ones, like using PostgreSQL instead of MySQL or Nginx instead of Apache, but still using the LAMP name. The LAMP architecture can be considered the default starting point when designing web-based client/server systems using HTTP, creating a solid and proven foundation to start building a more complex system.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">As you can see, every different element has a distinct function in the system. They interact with each <a id="_idIndexMarker005"/>other in clearly defined ways. This is known as the <strong class="keyword">Single-Responsibility principle</strong>. When presented with new features, most use cases will fall clearly within one of the elements of the system. Any style <a id="_idIndexMarker006"/>changes will be handled by the web server and dynamic changes by the web worker. There are dependencies between the elements, as the data stored in the database may need to be changed to support dynamic requests, but they can be detected early in the process.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">We will describe this architecture in greater detail in <em class="italic">Chapter 9</em>.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Each element has different requirements and characteristics:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The database needs to be reliable, as it stores all the data. Maintenance work like backup- and recovery-related work will be important. The database won't be updated very <a id="_idIndexMarker007"/>frequently, as databases are very stable. Changes to the table schemas will be made through restarts in the web worker.</li>&#13;&#13;
      <li class="bullet">The web worker needs to be scalable and not store any state. Instead, any data will be sent and <a id="_idIndexMarker008"/>received from the database. This element will be updated often. Multiple copies can be run, either in the same machine or in multiple ones to allow horizontal scalability.</li>&#13;&#13;
      <li class="bullet">The web server will require some changes for new styling, but that won't happen very often. Once the <a id="_idIndexMarker009"/>configuration is properly set up, this element will remain quite stable. Only one web server per machine is required, as it's capable of load-balancing between multiple web workers.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">As we can see, the work balance between elements is very different, as the web worker will be the focus for most new work, while the other two elements will be much more stable. The database will require specific work for us to be sure that it's in good shape, as it's arguably the most critical element of the three. The other two can recover quickly if there's a problem, but any corruption in the database will generate a lot of problems.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">The most critical and valuable element of a system is almost always the stored data.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The communication protocols are also unique. The web worker talks to the database using SQL <a id="_idIndexMarker010"/>statements. The web server talks to the web worker using a dedicated interface, normally FastCGI or a similar protocol. The web server communicates with the external clients via HTTP requests. The web server and the database don't talk to each other.</p>&#13;&#13;
    <p class="normal">These three protocols are different. This doesn't have to be the case for all systems; different components can share the same protocol. For example, there can be multiple RESTful interfaces, which is common in microservices.</p>&#13;&#13;
    <h2 id="_idParaDest-16" class="title">In-process communication</h2>&#13;&#13;
    <p class="normal">The typical way of looking at different units is as different processes running independently, but that's <a id="_idIndexMarker011"/>not the only option. Two different modules inside the sameÂ process can still follow the Single-Responsibility principle.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">The Single-Responsibility principle can be applied at different levels and is used to define the<a id="_idIndexMarker012"/> divisions between functions or other blocks. So, it can be applied in smaller and smaller scopes. It's turtles all the way down! But, from the point of view of architecture, the higher-level elements are the most important, as it's the higher level that defines the structure. Knowing how far to go in terms of detail is clearly important, but when taking an architectural approach, it is better to err on the "big picture" side rather than the "too much detail" one.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">A clear example of this would be a library that's maintained independently, but it could also be certain modules within a code base. For example, you could create a module that performs all the external HTTP calls and handles all the complexity of keeping connections, retries, handling errors, and so on, or you could create a module to produce reports in multiple formats, based on some parameters.</p>&#13;&#13;
    <p class="normal">The important characteristic is that in order to create an independent element, the API needs to be clearly defined and the responsibility needs to be well defined. It should be possible for the module to be extracted into a different repo and installed as a third-party element for it to be considered truly independent.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">Creating a big component with internal divisions only is a well-known pattern called a monolithic architecture. The LAMP architecture described above is an example of <a id="_idIndexMarker013"/>that, as most of the code is defined inside the web worker. Monoliths are the usual de facto starts of projects, as normally at the <a id="_idIndexMarker014"/>start there's no big plan and dividing things strictly into multiple components doesn't have a big advantage when the code base is small. As the code base and system grow more and more complex, the division of elements inside the monolith starts to make sense, and later it may start to make sense to split it into several components. We will discuss monoliths further in <em class="chapterRef">Chapter 9</em>, <em class="italic">Microservices vs Monolith</em>.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Inside the same <a id="_idIndexMarker015"/>component, communication is typically straightforward, as internal APIs will be used. In the vast majority of cases, the same programming language will be used.</p>&#13;&#13;
    <h1 id="_idParaDest-17" class="title">Conway's Law â Effects on software architecture</h1>&#13;&#13;
    <p class="normal">A critical concept to always <a id="_idIndexMarker016"/>keep in mind while dealing with architectural designs is Conway's Law. Conway's Law is a well-known adage that postulates <a id="_idIndexMarker017"/>that the systems introduced in organizations mirror the communication pattern of the organization structure (<a href="https://www.thoughtworks.com/insights/articles/demystifying-conways-law"><span class="url">https://www.thoughtworks.com/insights/articles/demystifying-conways-law</span></a>):</p>&#13;&#13;
    <blockquote class="packt_quote">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.&#13;&#13;
    <p class="normal" style="text-align: right;">â Melvin E. Conway</p></blockquote>&#13;&#13;
    <p class="normal">This means that the structure of the organization's people is replicated, either explicitly or otherwise, to form the software structure created by an organization. In a very simple example, a company that has two big departments â say, purchases and sales â will tend to create two big systems, one focused on buying and another on selling, that talk to each other, instead of other possible structures, like a system with divisions by product.</p>&#13;&#13;
    <p class="normal">This can feel natural; after all, communication between teams is more difficult than communication within teams. Communication between teams would need to be more structured and require more active work. Communication inside a single group would be more fluid and less rigid. These elements are key for the design of a good software architecture.</p>&#13;&#13;
    <p class="normal">The main thing for the successful application of any software architecture is that the team structure needs to follow the designed architecture quite closely. Trying to deviate too much will result in difficulties, as the tendency will be to structure, de facto, everything following group divisions. In the same way, changing the architecture of a system <a id="_idIndexMarker018"/>would likely necessitate restructuring the organization. This is a difficult and painful process, as anyone who has experienced a company reorganization will attest.</p>&#13;&#13;
    <p class="normal">Division of responsibilities is also a key aspect. A single software element should have a clear owner, and this shouldn't be distributed across multiple teams. Different teams have different goals and focuses, which will complicate the long-term vision and create tensions.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">The reverse, a single team taking ownership of multiple elements, is definitely possible but also requires careful consideration to ensure that this doesn't overstress the team.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">If there's a big imbalance in the mapping of work units to teams (for example, too many work units for one team and too few for another team), it is likely that there's aÂ problem with the architecture of the system.</p>&#13;&#13;
    <p class="normal">As remote work becomes more common and teams increasingly become located in different parts of the world, communication is also impacted. That's why it has become very common to set up different branches to take care of different elements of the system and to use detailed APIs to overcome the physical barriers of geographical distance. Communication improvements also have an effect on the capacity for collaboration, making remote work more effective and allowing fully remote teams to work closely together on the same code base.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">The recent COVID-19 crisis has greatly increased the trend of remote working, especially in software. This is resulting in more people working remotely and in better tools that are adapted to work in this way. While time zone differences are still a big barrier to communication, more and more companies and teams are learning to work effectively in full-remote mode. Remember that Conway's Law is very much dependent on the communication dependencies of organizations, but communication itself can change and improve.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Conway's Law should not be considered an impediment to overcome but a reflection of the fact that organizational structure has an impact on the structure of the software. Software architecture is tightly related to how different teams are coordinated and responsibilities are divided. It has an important human communication component.</p>&#13;&#13;
    <p class="normal">Keeping this in mind will help you design a successful software architecture so that the communication flow is fluid <a id="_idIndexMarker019"/>at all times and you can identify problems in advance. Software architecture is, of course, closely tied to the human factor, as the architecture will ultimately be implemented and maintained by engineers.</p>&#13;&#13;
    <h1 id="_idParaDest-18" class="title">Application example â Overview </h1>&#13;&#13;
    <p class="normal">In this book, we will be using an application as an example to demonstrate the different elements and patterns presented. This application will be simple but divided into different elements for <a id="_idIndexMarker020"/>demonstration purposes. The full code for the example is available on GitHub, and different parts of it will be presented in the different chapters. The example is written in Python, using well-known frameworks and modules.</p>&#13;&#13;
    <p class="normal">The example application is a web application for microblogging, very similar to Twitter. In essence, users will write short text messages that will be available for other users to read.</p>&#13;&#13;
    <p class="normal">The architecture of the example system is described in this diagram:</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_01_02.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="422"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 1.2: Example architecture</p>&#13;&#13;
    <p class="normal">It has the following <a id="_idIndexMarker021"/>high-level functional elements:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">A public website in HTML that can be accessed. This includes functionality for login, logout, writing new micro-posts, and reading other users' micro-posts (no need to be logged in for this).</li>&#13;&#13;
      <li class="bullet">A public RESTful API, to allow the usage of other clients (mobile, JavaScript, and so on) instead of the HTML site. This will authenticate the users using OAuth and perform actions similar to the website.</li>&#13;&#13;
    </ul>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">These two elements, while distinct, will be made into a single application, as shown in the diagram. The front-facing part of the application will include a web server, as we saw in the LAMP architecture description, which has not been displayed here for simplicity.</p>&#13;&#13;
    </div>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">A task manager that will execute event-driven tasks. We will add periodic tasks that will calculate <a id="_idIndexMarker022"/>daily statistics and send email notifications to users when they are named in a micro-post.</li>&#13;&#13;
      <li class="bullet">A database that stores all the information. Note that access to it is shared between the different elements.</li>&#13;&#13;
      <li class="bullet">Internally, a common package to ensure that the database is accessed correctly for all the services. This package works as a different element.</li>&#13;&#13;
    </ul>&#13;&#13;
    <h1 id="_idParaDest-19" class="title">Security aspects of software architecture</h1>&#13;&#13;
    <p class="normal">An important element to take into consideration when creating an architecture is the security requirements. Not every application is the same, so some can be more relaxed in this aspect than <a id="_idIndexMarker023"/>others. For example, a banking application needs to be 100 times more secure than, say, an internet forum for discussing cats. The most common example of this is the storage of passwords. The most naive approach to passwords is to store them, in plain text, associated with a username or email address â say, in a file or a database table. When the user tries to log in, we receive the input password, compare it with the one stored previously, and, if they are the same, we allow the user to log in. Right?</p>&#13;&#13;
    <p class="normal">Well, this is a very bad idea, because it can produce serious problems:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">If an attacker has access to the storage for the application, they'll be able to read the passwords of all the users. Users tend to reuse passwords (even if it's a bad idea), so, paired with their emails, they'll be exposed to attacks on multiple applications, not only the breached one.</li>&#13;&#13;
    </ul>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This may seem unlikely, but keep in mind that any copy of the data stored is susceptible to attack, including backups.</p>&#13;&#13;
    </div>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Another real issue is insider threats, workers who may have legitimate access to the system but copy data for nefarious purposes or by mistake. For very sensitive data, this can be a very important consideration.</li>&#13;&#13;
      <li class="bullet">Mistakes like displaying the password of a user in status logs.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">To make things secure, data needs to be structured in a way that's as protected as possible from <a id="_idIndexMarker024"/>access or even copying, without exposing the real passwords of users. The usual solution to this is to have the following schema:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered">The password itself is not stored. Instead, a <em class="italic">cryptographical hash</em> of the password <a id="_idIndexMarker025"/>is stored. This applies a mathematical function to the password and generates a replicable sequence of bits, but the reverse operation is computationally very difficult.</li>&#13;&#13;
      <li class="numbered">As the hash is deterministic based on the input, a malicious actor could detect duplicated passwords, as their hashes are the same. To avoid this problem, a random sequence of characters, called a <em class="italic">salt</em>, is added for each account. This will be added to each <a id="_idIndexMarker026"/>password before hashing, meaning two users with the same password but different salts will have different hashes.</li>&#13;&#13;
      <li class="numbered">Both the resulting hash and the salt are stored.</li>&#13;&#13;
      <li class="numbered">When a user tries to log in, their input password is added to the salt, and the result is compared with the stored hash. If it's correct, the user is logged in.</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">Note that in this design, the actual password is unknown to the system. It's not stored anywhere and is only accepted temporarily to compare it with the expected hash, after being processed.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This example is presented in a simplified way. There are multiple ways of using this schema and different ways of comparing a hash. For example, the <code class="Code-In-Text--PACKT-">bcrypt</code> function can be applied <a id="_idIndexMarker027"/>multiple times, increasing encryption each time, which can increase the time required to produce a valid hash, making it more resistant to brute-force attacks.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">This kind of system is more secure than one that stores the password directly, as the password is not known by the people operating the system, nor is it stored anywhere.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">The problem of mistakenly displaying the password of a user in status logs may still happen! Extra care should be taken to make sure that sensitive information is not being logged by mistake.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">In certain cases, the same approach as for passwords can be taken to encrypt other stored data, so that <a id="_idIndexMarker028"/>only customers can access their own data. For example, you can enable end-to-end encryption for a communication channel.</p>&#13;&#13;
    <p class="normal">Security has a very close relationship with the architecture of a system. As we saw before, the architecture defines which aspects are easy and difficult to change and can make some unsafe things impossible to do, like knowing the password of a user, as we described in the previous example. Other options include not storing data from the user to keep privacy or reducing the data exposed in internal APIs, for example. Software security is a very difficult problem and is often a double-edged sword, and trying to make a system more secure can have the side effect of making operations long-winded and inconvenient.</p>&#13;&#13;
    <h1 id="_idParaDest-20" class="title">Summary</h1>&#13;&#13;
    <p class="normal">In this chapter, we looked at what software architecture is and when it is required, as well as its focus on the long-term approach, which is characteristic of the discipline. We learned that the underlying structure of software is difficult to change and that that aspect should be taken into consideration when designing and changing a software system.</p>&#13;&#13;
    <p class="normal">We described how the most important thing is to divide a complex system into smaller parts and assign clear goals and objectives to each of them, keeping in mind that these smaller parts can use multiple programming languages and refer to different scopes. We also described the LAMP architecture and how it's a widely successful starting point when creating simple web service systems.</p>&#13;&#13;
    <p class="normal">We talked about how Conway's Law affects the architecture of a system, as underlying team structures have a direct impact on the implementation and structure of software. After all, software is operated and developed by humans, and human communication needs to be accounted for to implement it successfully.</p>&#13;&#13;
    <p class="normal">We described the example that we will use throughout the book to describe the different elements and patterns we will present. Finally, we commented on the security aspects of software architecture and how creating barriers to accessing data as part of the structural design of a system can mitigate security issues.</p>&#13;&#13;
    <p class="normal">In the next section of the book, we will talk about the different aspects of designing a system.</p>&#13;&#13;
  </div>&#13;&#13;
</div></body></html>