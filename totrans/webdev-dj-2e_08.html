<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-229"><a id="_idTextAnchor244"/>8. Media Serving and File Uploads</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter starts by introducing you to media files and then teaching you how to set up Django to serve them. Once you have understood this, you will learn how to build a form in HTML that can upload files to a view for storage to disk. To enhance this process and reduce the amount of code, you will use Django forms to generate and validate a form and learn how to process file uploads through it. You will then look at some enhancements that Django provides specifically for working with image files and use the <code>FileField</code> and <code>ImageField</code> to store a file and image respectively and upload to it using a Django form. After this, you will build a <code>ModelForm</code> instance automatically from the model and save the model and the files using just one line of code. At the end of this chapter, you will enhance the Bookr app by adding a cover image and book excerpt to the <code>Book</code> model.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor245"/>Introduction</h1>
			<p>Media files refer to extra files that can be added after deployment to enrich your Django application. Usually, they are extra images that you would use in your site, but any type of file (including video, audio, PDF, text, documents, or even HTML) can be served as media.</p>
			<p>You can think of them as somewhere between dynamic data and static assets. They are not dynamic data that Django generates on the fly, like when rendering a template. They also are not the static files that are included by the site developer when the site is deployed. Instead, they are extra files that can be uploaded by users or generated by your application for later retrieval.</p>
			<p>Some common examples of media files (that you will see in <em class="italic">Activity 8.01</em>, <em class="italic">Image and PDF Uploads of Books</em>, later in this chapter) are book covers and preview PDFs that can be attached to a <code>Book</code> object. You can also use media files to allow users to upload images for a blog post or avatars for a social media site. If you wanted to use Django to build your own video sharing platform, you would store the uploaded videos as media. Your website will not function well if all these files are static files, as users won't be able to upload their own book covers, videos, and so on, and will be stuck with the ones you deployed.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor246"/>Settings for Media Uploads and Serving</h1>
			<p>In <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, we looked at how Django can be used to serve static files. Serving media files is quite similar. Two settings must be configured in <code>settings.py</code>: <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code>. These are analogous to <code>STATIC_ROOT</code> and <code>STATIC_URL</code> for serving static files.</p>
			<ul>
				<li><code>MEDIA_ROOT</code><p>This is the path on the disk where the media (such as uploaded files) will be stored. As with static files, your web server should be configured to serve directly from this directory, to take the load off Django.</p></li>
				<li><code>MEDIA_URL</code><p>This is similar to <code>STATIC_URL</code>, but as you might guess, it's the URL that should be used to serve media. It must end in a <code>/</code>. Generally, you will use something like <code>/media/</code>.</p><p class="callout-heading">Note</p><p class="callout">For security reasons, the path for <code>MEDIA_ROOT</code> must not be the same as the path for <code>STATIC_ROOT</code>, and <code>MEDIA_URL</code> must not be the same as <code>STATIC_URL</code>. If they were the same, a user might replace your static files (such as JavaScript or CSS files) with malicious code and exploit your users.</p></li>
			</ul>
			<p><code>MEDIA_URL</code> is designed to be used in templates so that you are not hardcoding the URL and it can be changed easily. For example, you might want to set it to a specific host or <code>MEDIA_URL</code> in templates in an upcoming section.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor247"/>Serving Media Files in Development</h2>
			<p>As with static files, when serving media in production, your web server should be configured to serve directly from the <code>MEDIA_ROOT</code> directory to prevent Django from being tied up servicing the request. The Django dev server can serve media files in development. However, unlike static files, the URL mapping and view is not set up automatically for media files. </p>
			<p>Django provides the <code>static</code> URL mapping that can be added to your existing URL maps to serve media files. It is added to your <code>urls.py</code> file like this:</p>
			<pre>from django.conf import settings
from django.conf.urls.static import static
urlpatterns = [
    # your existing URL maps
] 
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,\
                          document_root=settings.MEDIA_ROOT)</pre>
			<p>This will serve the <code>MEDIA_ROOT</code> setting defined in <code>settings.py</code> to the <code>MEDIA_URL</code> setting that is also defined there. The reason we check for <code>settings.DEBUG</code> before appending the map is so we don't add this map in production.</p>
			<p>For example, if your <code>MEDIA_ROOT</code> was set to <code>/var/www/bookr/media</code>, and your <code>MEDIA_URL</code> was set to <code>/media/</code>, then the <code>/var/www/bookr/media/image.jpg</code> file would be available at <code>http://127.0.0.1:8000/media/image.jpg</code>.</p>
			<p>The <code>static</code> URL map does not work when the Django <code>DEBUG</code> setting is <code>False</code>, and so it can't be used in production. However, as mentioned earlier, in production your web server should be serving these requests, so Django will not need to handle them.</p>
			<p>In the first exercise, you will create and add a new <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> to your <code>settings.py</code> file. You will then add the <code>static</code> media serving URL map and add a test file to ensure media serving is configured correctly.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor248"/>Exercise 8.01: Configuring Media Storage and Serving Media Files</h2>
			<p>In this exercise, you will set up a new Django project as an example project to use throughout this chapter. Then you'll configure it to be able to serve media files. You'll do this by creating a <code>media</code> directory and adding the <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> settings. Then you'll set up the URL mapping for <code>MEDIA_URL</code>. </p>
			<p>To check that everything is configured and being served correctly, you will put a test file inside the <code>media</code> directory:</p>
			<ol>
				<li>As with the previous example Django projects you've set up, you can reuse the existing <code>bookr</code> virtual environment. In a terminal, activate the <code>bookr</code> virtual environment. Then, start a new project named <code>media_project</code>, using <code>django-admin.py</code>:<pre>django-admin.py startproject media_project</pre><p>Change (or <code>cd</code>) into the <code>media_project</code> directory that was created, then use the <code>startapp</code> management command to start an app called <code>media_example</code>:</p><pre>python3 manage.py startapp media_example</pre></li>
				<li>Open the <code>media_project</code> directory in PyCharm. Set up a run configuration for the <code>runserver</code> command in the same manner as for the other Django projects you've opened:<div><img src="img/B15509_08_01.jpg" alt="Figure 8.1: Runserver configuration&#13;&#10;"/></div><p class="figure-caption">Figure 8.1: Runserver configuration</p><p><em class="italic">Figure 8.1</em> shows the <code>runserver</code> configuration of the project in PyCharm.</p></li>
				<li>Create a new directory named <code>media</code> inside the <code>media_project</code> project directory. Then, create a new file in this directory named <code>test.txt</code>. The directory structure of this will look like <em class="italic">Figure 8.2</em>:<div><img src="img/B15509_08_02.jpg" alt="Figure 8.2: media directory and test.txt layout&#13;&#10;"/></div><p class="figure-caption">Figure 8.2: media directory and test.txt layout</p></li>
				<li><code>test.txt</code> will also open automatically. Enter the text <code>Hello, world!</code> into it, then you can save and close the file.</li>
				<li>Open <code>settings.py</code> inside the <code>media_project</code> package directory. At the end of the file, add a setting for <code>MEDIA_ROOT</code>, using the path to the media directory you just created. Make sure to import the <code>os</code> module at the top of the file:<pre>import os</pre><p>Then use it to join it to <code>BASE_DIR</code> using the <code>os.path.join</code> function:</p><pre>MEDIA_ROOT = os.path.join(BASE_DIR, 'media')</pre></li>
				<li>Directly below the line added in <em class="italic">step 5</em>, add another setting for <code>MEDIA_URL</code>. This should just be <code>'/media/'</code>:<pre>MEDIA_URL = '/media/'</pre><p>After this, save <code>settings.py</code>. Here's what it should look like:</p><pre>STATIC_URL = '/static/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
<code>settings.py</code> should look like this: <a href="http://packt.live/34RdhU1">http://packt.live/34RdhU1</a>.</p></li>
				<li>Open the <code>media_project</code> package's <code>urls.py</code> file. After the <code>urlpatterns</code> definition, add the following code to add the media serving URL if running in <code>DEBUG</code> mode. First, you will need to import the Django settings and static serving view by adding the highlighted import lines above the <code>urlpatterns</code> definition:<pre>from django.contrib import admin
from django.urls import path
<strong class="bold">from django.conf import settings</strong>
<strong class="bold">from django.conf.urls.static import static</strong>
urlpatterns = [path('admin/', admin.site.urls),]</pre></li>
				<li>Then, add the following code right after your <code>urlpatterns</code> definition (refer to the code block in the previous step) to conditionally add a mapping from <code>MEDIA_URL</code> to the <code>static</code> view, which will serve from <code>MEDIA_ROOT</code>:<pre>if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,\
                          document_root=settings.MEDIA_ROOT)</pre><p>You can now save this file. It should look like this: <a href="http://packt.live/3nVUiPn">http://packt.live/3nVUiPn</a>.</p></li>
				<li>Start the Django dev server if it is not already running, then visit <code>http://127.0.0.1:8000/media/test.txt</code>. If you did everything correctly, then you should see the text <code>Hello, world!</code> in your browser:<div><img src="img/B15509_08_03.jpg" alt="Figure 8.3: Serving a media file&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.3: Serving a media file</p>
			<p>If your browser looks like <em class="italic">Figure 8.3</em>, it means that the media files are being served from the <code>MEDIA_ROOT</code> directory. The <code>test.txt</code> file we created was just for testing, but we will use it in <em class="italic">Exercise 8.02</em>,<em class="italic"> Template Settings and Using MEDIA_URL in Templates</em>, so don't delete it yet.</p>
			<p>In this exercise, we configured Django to serve media files. We served a test file just to make sure everything works as expected, and it did. We'll now look at how we can automatically generate media URLs in templates.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor249"/>Context Processors and Using MEDIA_URL in Templates</h1>
			<p>To use <code>MEDIA_URL</code> in a template, we could pass it in through the rendering context dictionary, in our view. For example:</p>
			<pre>from django.conf import settings
def my_view(request):
    return render(request, "template.html",\
                  {"MEDIA_URL": settings.MEDIA_URL,\
                   "username": "admin"})</pre>
			<p>This will work, but the problem is that <code>MEDIA_URL</code> is a common variable that we might want to use in many places, and so we'd have to pass it through in practically every view.</p>
			<p>Instead, we can use a <code>render</code> call.</p>
			<p>A context processor is a function that accepts one argument, the current request. It returns a dictionary of context information that will be merged with the dictionary that was passed to the <code>render</code> call.</p>
			<p>We can look at the source code of the <code>media</code> context processor, which illustrates how they work:</p>
			<pre>def media(request):
    """
    Add media-related context variables to the context.
    """
    return {'MEDIA_URL': settings.MEDIA_URL}</pre>
			<p>With the media context processor activated, <code>MEDIA_URL</code> will be added to our context dictionaries. We could change our <code>render</code> call, seen previously, to this:</p>
			<pre>return render(request, "template.html", {"username": "admin"})</pre>
			<p>The same data would be sent to the template, as the context processor would add <code>MEDIA_URL</code>.</p>
			<p>The full module path to the <code>media</code> context processor is <code>django.template.context_processors.media</code>. Some examples of other context processors that Django provides are: </p>
			<ul>
				<li><code>django.template.context_processors.debug</code><p>This returns the dictionary <code>{"DEBUG": settings.DEBUG}</code>.</p></li>
				<li><code>django.template.context_processors.request</code> <p>This returns the dictionary <code>{"request": request}</code>, that is, it just adds the current HTTP request to the context.</p></li>
			</ul>
			<p>To enable a context processor, its module path must be added to the <code>context_processors</code> option of your <code>TEMPLATES</code> setting. For example, to enable the media context processor, add <code>django.template.context_processors.media</code>. We will cover how to do this in detail in <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>. </p>
			<p>Once the <code>media</code> context processor is enabled, the <code>MEDIA_URL</code> variable can be accessed inside a template just like a normal variable:</p>
			<pre>{{ MEDIA_URL }}</pre>
			<p>You could use it, for example, to source an image:</p>
			<pre>&lt;img src="img/image.jpg"&gt;</pre>
			<p>Note that, unlike with static files, there is no template tag for loading media files (that is, there is no equivalent to the <code>{% static %}</code> template tag).</p>
			<p>Custom context processors can also be written. For example, referring back to the Bookr application that we have been building, we might want to show a list of the five latest reviews in a sidebar that's on every page. A context processor like this would perform this:</p>
			<pre>from reviews.models import Review
def latest_reviews(request):
    return {"latest_reviews": \
             Review.objects.order_by('-date_created')[:5]}.</pre>
			<p>This would be saved in a file named <code>context_processors.py</code> in the Bookr project directory, then referred to in the <code>context_processors</code> setting by its module path, <code>context_processors.latest_reviews</code>. Or we could save it inside the <code>reviews</code> app and refer to it as <code>reviews.context_processors.latest_reviews</code>. It is up to you to decide whether a context processor should be considered project-wide or app-specific. However, bear in mind that regardless of where it is stored, once activated, it applies to all <code>render</code> calls for all apps.</p>
			<p>A context processor can return a dictionary with multiple items, or even zero items. It would do this if it had conditions to only add items if certain criteria were met, for example, showing the latest reviews only if the user is logged in. Let's explore this in detail in the next exercise.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor250"/>Exercise 8.02: Template Settings and Using MEDIA_URL in Templates</h2>
			<p>In this exercise, you will continue with <code>media_project</code> and configure Django to automatically add the <code>MEDIA_URL</code> setting to every template. You do this by adding <code>django.template.context_processors.media</code> to the <code>TEMPLATES</code> <code>context_processors</code> setting. You'll then add a template that uses this new variable, and an example view to render it. You will make changes to the view and template throughout the exercises in this chapter:</p>
			<ol>
				<li value="1">In PyCharm, open <code>settings.py</code>. First, you will need to add <code>media_example</code> to the <code>INSTALLED_APPS</code> setting, since it wasn't done when the project was set up:<pre>INSTALLED_APPS = [# other apps truncated for brevity\
    'media_example']</pre></li>
				<li>About halfway down the file, you will find the <code>TEMPLATES</code> setting, which is a dictionary. Inside it is the item <code>OPTIONS</code> (another dictionary). Inside <code>OPTIONS</code> is the <code>context_processors</code> setting.<p>To the end of this list, add this:</p><pre>'django.template.context_processors.media'</pre><p>The full list should look like this:</p><pre>TEMPLATES = \
[{'BACKEND': 'django.template.backends.django.DjangoTemplates',
  'DIRS': [],
  'APP_DIRS': True,
  'OPTIONS': {'context_processors': \
              ['django.template.context_processors.debug',\
               'django.template.context_processors.request',\
               'django.contrib.auth.context_processors.auth',\
               'django.contrib.messages.context_processors.messages',\
               <strong class="bold">'django.template.context_processors.media'\</strong>
            ],\
        },\
    },\
]</pre><p>The complete file should look like this: <a href="http://packt.live/3nVOpSx">http://packt.live/3nVOpSx</a>.</p></li>
				<li>Open the <code>media_example</code> app's <code>views.py</code> and create a new view called <code>media_example</code>. For now, it can just render a template named <code>media-example.html</code> (you will create this in <em class="italic">step 5</em>). The entire code of the view function is like this:<pre>def media_example(request):
    return render(request, "media-example.html")</pre><p>Save <code>views.py</code>. It should look like this: <a href="http://packt.live/3pvEGCB">http://packt.live/3pvEGCB</a>.</p></li>
				<li>You need a URL mapping to the <code>media_example</code> view. Open the <code>media_project</code> package's <code>urls.py</code> file. <p>First, <code>import</code> <code>media_example.views</code> with the other imports in the file:</p><pre>import media_example.views</pre><p>Then add a <code>path</code> into <code>urlpatterns</code> to map <code>media-example/</code> to the <code>media_example</code> view:</p><pre>path('media-example/', media_example.views.media_example)</pre><p>Your full <code>urlpatterns</code> should look like this code block:</p><pre>from django.conf.urls.static import static
<strong class="bold">import media_example.views</strong>
urlpatterns = [<strong class="bold">path('admin/', admin.site.urls),\</strong>
<strong class="bold">               path('media-example/', \</strong>
<strong class="bold">                    media_example.views.media_example)</strong>]
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,\
                          document_root=settings.MEDIA_ROOT)</pre><p>You can save and close the file.</p></li>
				<li>Create a <code>templates</code> directory inside the <code>media_example</code> app directory. Then, create a new HTML file inside the <code>media_project</code> project's <code>templates</code> directory. Select <code>HTML 5 file</code> and name the file <code>media-example.html</code>:<div><img src="img/B15509_08_04.jpg" alt="Figure 8.4: Create media-example.html&#13;&#10;"/></div><p class="figure-caption">Figure 8.4: Create media-example.html</p></li>
				<li>The <code>media-example.html</code> file should open automatically. You are just going to add a link inside the file to the <code>test.txt</code> file you created in <em class="italic">Exercise 8.01</em>, <em class="italic">Configuring Media Storage and Serving</em>. Inside the <code>&lt;body&gt;</code> element, add the highlighted code:<pre>&lt;body&gt;
    <code>/</code> between <code>MEDIA_URL</code> and the filename – this is because we already added a trailing slash when we defined it in <code>settings.py</code>. You can save the file. The complete file will look like this: <a href="http://packt.live/3nYTvgF">http://packt.live/3nYTvgF</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then visit <code>http://127.0.0.1:8000/media-example/</code>. You should see a simple page, like in <em class="italic">Figure 8.5</em>:<div><img src="img/B15509_08_05.jpg" alt="Figure 8.5: Basic media link page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.5: Basic media link page</p>
			<p>If you click the link, you will be taken to the <code>test.txt</code> display and see the <code>Hello, world!</code> text you created in <em class="italic">Exercise 8.01</em>, <em class="italic">Configuring Media Storage and Serving Media Files</em> (<em class="italic">Figure 8.3</em>). This means you have configured the Django <code>context_processors</code> settings correctly.</p>
			<p>We have finished with <code>test.txt</code>, so you can delete the file now. We will use the <code>media_example</code> view and template in the other exercises, so leave them around. In the next section, we will talk about how to upload files using a web browser, and how Django accesses them in a view.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor251"/>File Uploads Using HTML Forms</h1>
			<p>In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, we learned about HTML forms. We discussed how to use the <code>method</code> attribute of <code>&lt;form&gt;</code> for <code>GET</code> or <code>POST</code> requests. Though we have only submitted text data using a form so far, it is also possible to submit one or more files using a form.</p>
			<p>When submitting files, we must ensure that there are at least two attributes on the form: <code>method</code> and <code>enctype</code>. You may still also need other attributes, such as <code>action</code>. A form that supports file uploads might look like this:</p>
			<pre>&lt;form <strong class="bold">method</strong>="post" <strong class="bold">enctype</strong>="multipart/form-data"&gt;</pre>
			<p>File uploads are only available for <code>POST</code> requests. They are not possible with <code>GET</code> requests as it would be impossible to send all the data for a file through a URL. The <code>enctype</code> attribute must be set to let the browser know it should send the form data as multiple parts, one part for the text data of the form, and separate parts for each of the files that have been attached to the form. This encoding is seamless to the user; they do not know how the browser is encoding the form, nor do they need to do anything different.</p>
			<p>To attach files to a form, you need to create an input of type <code>file</code>. You can manually write the HTML code, like this:</p>
			<pre>&lt;input type="file" name="file-upload-name"&gt;</pre>
			<p>When the input is rendered in the browser it looks like this when empty:</p>
			<div><div><img src="img/B15509_08_06.jpg" alt="Figure 8.6: Empty file input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Empty file input</p>
			<p>The title of the button might be different depending on your browser.</p>
			<p>Clicking the <code>Browse…</code> button will display a <em class="italic">file open</em> dialog box:</p>
			<div><div><img src="img/B15509_08_07.jpg" alt="Figure 8.7: File browser on macOS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: File browser on macOS</p>
			<p>And after selecting a file, the name of the file is shown in the field:</p>
			<p> </p>
			<div><div><img src="img/B15509_08_08.jpg" alt="Figure 8.8: File input with cover.jpg selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: File input with cover.jpg selected</p>
			<p><em class="italic">Figure 8.8</em> shows a file input with a file named <code>cover.jpg</code> having been selected.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor252"/>Working with Uploaded Files in a View</h2>
			<p>In addition to text data, if a form also contains file uploads, Django will populate the <code>request.FILES</code> attribute with these files. <code>request.FILES</code> is a dictionary-like object that is keyed on the <code>name</code> attribute given to the <code>file</code> input.</p>
			<p>In the form example in the previous section, the file input had the name <code>file-upload-name</code>. So, the file would be accessible in the view using <code>request.FILES["file-upload-name"]</code>.</p>
			<p>The objects that <code>request.FILES</code> contains are file-like objects (specifically, a <code>django.core.files.uploadedfile.UploadedFile</code> instance), so to use them, you must read their data. For example, to get the content of an uploaded file in your view, you can write:</p>
			<pre>content = request.FILES["file-upload-name"].read()</pre>
			<p>A more common action is to write the file contents to disk. When files are uploaded, they are stored in a temporary location (in memory if they are under 2.5 MB, otherwise in a temporary file on disk). To store the file data in a known location, the contents must be read and then written to disk at the desired location. An <code>UploadedFile</code> instance has a <code>chunks</code> method that will read the file data one chunk at a time to prevent too much memory from being used by reading the entirety of the file at once.</p>
			<p>So, instead of simply using the <code>read</code> and <code>write</code> functions, use the <code>chunks</code> method to only read small chunks of the file into memory at a time:</p>
			<pre>with open("/path/to/output.jpg", "wb+") as output_file:
    uploaded_file = request.FILES["file-upload-name"]
    for chunk in uploaded_file.chunks():
        output_file.write(chunk)</pre>
			<p>Note that in some of the upcoming examples, we will refer to this code as the <code>save_file_upload</code> function. Assume the function is defined like this:</p>
			<pre>def save_file_upload(upload, save_path):
    with open(save_path, "wb+") as output_file:
        for chunk in upload.chunks():
            output_file.write(chunk)</pre>
			<p>The previous example code could then be refactored to call the function:</p>
			<pre>uploaded_file = request.FILES["file-upload-name"]
save_file_upload(uploaded_file, "/path/to/output.jpg")</pre>
			<p>Each <code>UploadedFile</code> object (the <code>uploaded_file</code> variable in the previous example code snippets) also contains extra metadata about the uploaded file, such as the file's name, size, and content type. The attributes you will find most useful are:</p>
			<ul>
				<li><code>size</code>: As the name suggests, this is the size of the uploaded file in bytes.</li>
				<li><code>name</code>: This refers to the name of the uploaded file, for example, <code>image.jpg</code>, <code>file.txt</code>, <code>document.pdf</code>, and so on. This value is sent by the browser.</li>
				<li><code>content_type</code>: The content type (MIME type) of the uploaded file. For example, <code>image/jpeg</code>, <code>text/plain</code>, <code>application/pdf</code>, and so on. Like <code>name</code>, this value is sent by the browser.</li>
				<li><code>charset</code>: This refers to the charset or text encoding of the uploaded file, for text files. This will be something like <code>utf8</code> or <code>ascii</code>. Once again, this value is also determined and sent by the browser.</li>
			</ul>
			<p>Here is a quick example of accessing these attributes (such as inside a view):</p>
			<pre>upload = request.FILES["file-upload-name"]
size = upload.size
name = upload.name
content_type = upload.content_type
charset = upload.charset</pre>
			<h3 id="_idParaDest-238"><a id="_idTextAnchor253"/>Security and Trust of Browsers' Sent Values</h3>
			<p>As we just described, the values of an <code>UploadedFile</code> for <code>name</code>, <code>content_type</code>, and <code>charset</code> are determined by the browser. This is important to consider because a malicious user could send fake values in place of real ones to disguise the actual files being uploaded. Django does not automatically try to determine the content type or charset of the uploaded file, and so it relies on the client to be accurate when it sends this information.</p>
			<p>If we manually handle the saving of tile uploads without suitable checks, then a scenario like this could happen:</p>
			<ol>
				<li value="1">A user of the site uploads a malicious executable <code>malware.exe</code> but sends the content type <code>image/jpeg</code>.</li>
				<li>Our code checks the content type and considers it to be safe, and so saves <code>malware.exe</code> to the <code>MEDIA_ROOT</code> file.</li>
				<li>Another user of the site downloads what they think is a book cover image but is the <code>malware.exe</code> executable. They open the file, and their computer is infected with malware.</li>
			</ol>
			<p>This scenario has been simplified – the malicious file would probably have a name that was not so obvious (maybe something like <code>cover.jpg.exe</code>), but the general process has been illustrated.</p>
			<p>How you choose to handle the security of your uploads will depend on the specific use case, but for most cases, these tips will help:</p>
			<ul>
				<li>When you save the file to disk, generate a name instead of using the one provided by the uploader. You should replace the file extension with what you expect. For example, if a file is named <code>cover.exe</code> but the content type is <code>image/jpeg</code>, save the file as <code>cover.jpg</code>. You could also generate a completely random filename for extra security.</li>
				<li>Check that the file name extension matches the content type. This method is not foolproof as there are so many mime types that if you are handling uncommon files you might not get a match. The built-in <code>mimetypes</code> Python module can help you here. Its <code>guess_type</code> function takes a filename and returns a tuple of <code>mimetype</code> (content type) and <code>encoding</code>. Here is a short snippet showing its use, in a Python console:<pre>&gt;&gt;&gt; import mimetypes
&gt;&gt;&gt; mimetypes.guess_type('file.jpg')
('image/jpeg', None)
&gt;&gt;&gt; mimetypes.guess_type('text.html')
('text/html', None)
&gt;&gt;&gt; mimetypes.guess_type('unknownfile.abc')
(None, None)
&gt;&gt;&gt; mimetypes.guess_type('archive.tar.gz')
('application/x-tar', 'gzip')</pre><p>Either element of the tuple might be <code>None</code> if the type or encoding cannot be guessed. Once it is imported into your file by doing <code>import mimetypes</code>, you would use it like this in your view function:</p><pre>upload = request.FILES["file-upload-name"]
mimetype, encoding = mimetypes.guess_type(upload.name)
if mimetype != upload.content_type:
    raise TypeError("Mimetype doesn't match file extension.")</pre><p>This method will work for common file types such as images, but as mentioned, many uncommon types may return <code>None</code> for <code>mimetype</code>.</p></li>
				<li>If you are expecting image uploads, use the <code>Pillow</code> library to try to open the uploaded file as an image. If it is not a valid image, then <code>Pillow</code> will be unable to open it. This is what Django does when using its <code>ImageField</code> to upload images. We will show how to use this technique to open and manipulate an image in <em class="italic">Exercise 8.05</em>, <em class="italic">Image Uploads using Django Forms</em>.</li>
				<li>You can also consider the <code>python-magic</code> Python package, which examines the actual content of files to try to determine their type. It is installable using <code>pip</code>, and its GitHub project is <a href="https://github.com/ahupp/python-magic">https://github.com/ahupp/python-magic</a>. Once installed, and imported into your file with <code>import magic</code>, you can use it like this in your view function:<pre>upload = request.FILES["field_name"]
mimetype = magic.from_buffer(upload.read(2048), mime=True)</pre></li>
			</ul>
			<p>You could then verify that <code>mimetype</code> was in a list of allowed types.</p>
			<p>This is not a definitive list of all the ways of protecting against malicious file uploads. The best approach will depend on what type of application you are building. You might build a site for hosting arbitrary files, in which case you would not need any kind of content checking at all.</p>
			<p>Let us now see how we can build an HTML form and view that will allow files to be uploaded. We will then store them inside the <code>media</code> directory and retrieve the downloaded files in our browser.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor254"/>Exercise 8.03: File Upload and Download</h2>
			<p>In this exercise, you will add a form with a file field to the <code>media-example.html</code> template. This will allow you to upload a file to the <code>media_example</code> view using your browser. You will also update the <code>media_example</code> view to save the file to the <code>MEDIA_ROOT</code> directory so that it's available for download. You will then test that this all works by downloading the file again:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>media-example.html</code> template located inside the <code>templates</code> folder. Inside the <code>&lt;body&gt;</code> element, remove the <code>&lt;a&gt;</code> link that was added in <em class="italic">step 6</em> of <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>. Replace it with a <code>&lt;form&gt;</code> element (highlighted here). Make sure the opening tag has <code>method="post"</code> and <code>enctype="multipart/form-data"</code>:<pre>&lt;/head&gt;
&lt;body&gt;
<strong class="bold">    &lt;form method="post" enctype="multipart/form-data"&gt;</strong>
<strong class="bold">    </strong><strong class="bold">&lt;/form&gt;</strong>
&lt;/body&gt;</pre></li>
				<li>Insert the <code>{% csrf_token %}</code> template tag inside the <code>&lt;form&gt;</code> body.</li>
				<li>After <code>{% csrf_token %}</code>, add an <code>&lt;input&gt;</code> element, with <code>type="file"</code> and <code>name="file_upload"</code>:<pre>&lt;input type="file" name="file_upload"&gt;</pre></li>
				<li>Finally, before the closing <code>&lt;/form&gt;</code> tag, add a <code>&lt;button&gt;</code> element with <code>type="submit"</code> and the text content <code>Submit</code>:<pre>&lt;button type="submit"&gt;Submit&lt;/button&gt;</pre><p>Your HTML body should now look like this:</p><pre>&lt;body&gt;
<strong class="bold">    &lt;form method="post" enctype="multipart/form-data"&gt;</strong>
<strong class="bold">        {% csrf_token %}</strong>
<strong class="bold">        &lt;input type="file" name="file_upload"&gt;</strong>
<strong class="bold">        &lt;button type="submit"&gt;Submit&lt;/button&gt;</strong>
<strong class="bold">    &lt;/form&gt;</strong>
&lt;/body&gt;</pre><p>Now, save and close the file. It should look like this: <a href="http://packt.live/37XJPh3">http://packt.live/37XJPh3</a>.</p></li>
				<li>Open the <code>media_example</code> app's <code>views.py</code>. Inside the <code>media_example</code> view, add code to save the uploaded file to the <code>MEDIA_ROOT</code> directory. For this, you need access to <code>MEDIA_ROOT</code> from settings, so import the Django settings at the top of the file:<pre>from django.conf import settings</pre><p>You will also need to use the <code>os</code> module to build the save path, so import that as well (also at the top of the file):</p><pre>import os</pre></li>
				<li>The uploaded file should only be saved if the request method is <code>POST</code>. Inside the <code>media_example</code> view, add an <code>if</code> statement to validate that <code>request.method</code> is <code>POST</code>:<pre>def media_example(request):
    if request.method == 'POST':
        …</pre></li>
				<li>Inside the <code>if</code> statement added in the previous step, generate the output path by joining the uploaded filename to <code>MEDIA_ROOT</code>. Then, open this path in <code>wb</code> mode and iterate over the uploaded file using the <code>chunks</code> method. Finally, write each chunk to the saved file:<pre>def media_example(request):
    if request.method == 'POST':
<code>request.FILES</code> dictionary, using the key that matches the name given to the file input (in our case, this is <code>file_upload</code>). You can save and close <code>views.py</code>. It should now look like this: </p><p><a href="http://packt.live/37TwxSr">http://packt.live/37TwxSr</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <code>http://127.0.0.1:8000/media-example/</code>. You should see the file upload field and <code>Submit</code> button, as can be seen here:<div><img src="img/B15509_08_09.jpg" alt="Figure 8.9: File upload form&#13;&#10;"/></div><p class="figure-caption">Figure 8.9: File upload form</p><p>Click <code>Browse…</code> (or the equivalent in your browser) and select a file to upload. The name of the file will appear in the file input. Then, click <code>Submit</code>. The page will reload, and the form will be empty again. This is normal – in the background, the file should have been saved.</p></li>
				<li>Try to download the file you uploaded using <code>MEDIA_URL</code>. In this example, a file named <code>cover.jpg</code> was uploaded. It will be downloadable at <code>http://127.0.0.1:8000/media/cover.jpg</code>. Your URL will depend on the name of the file you uploaded.<div><img src="img/B15509_08_10.jpg" alt="Figure 8.10: Uploaded file visible inside MEDIA_URL&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 8.10: Uploaded file visible inside MEDIA_URL</p>
			<p>If you uploaded an image file, HTML file, or another type of file your browser can display, you will be able to view it inside the browser. Otherwise, your browser will just download it to disk again. In both cases, it means the upload was successful.</p>
			<p>You can also confirm the upload was successful by looking inside the <code>media</code> directory in the <code>media_project</code> project directory:</p>
			<p> </p>
			<div><div><img src="img/B15509_08_11.jpg" alt="Figure 8.11: cover.jpg inside the media directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: cover.jpg inside the media directory</p>
			<p><em class="italic">Figure 8.11</em> shows <code>cover.jpg</code> inside the <code>media</code> directory in PyCharm.</p>
			<p>In this exercise, you added an HTML form with <code>enctype</code> set to <code>multipart/form-data</code> so that it would allow file uploads. It contained a <code>file</code> input to select a file to upload. You then added saving functionality to the <code>media_example</code> view to save the uploaded file to disk.</p>
			<p>In the next section, we will look at how to simplify form generation and add validation using Django forms.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor255"/>File Uploads with Django Forms</h2>
			<p>In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, we saw how Django makes it easy to define forms and automatically render them to HTML. In the previous example, we defined our form manually and wrote the HTML. We can replace this with a Django form, and implement the file input with a <code>FileField</code> constructor.</p>
			<p>Here is how a <code>FileField</code> is defined on a form:</p>
			<pre>from django import forms
class ExampleForm(forms.Form):
    file_upload = forms.FileField()</pre>
			<p>The <code>FileField</code> constructor can take the following keyword arguments:</p>
			<ul>
				<li><code>required</code>: This should be <code>True</code> for required fields and <code>False</code> if the field is optional.</li>
				<li><code>max_length</code>: This refers to the maximum length of the filename of the file being uploaded.</li>
				<li><code>allow_empty_file</code>: A field with this argument is valid even if the uploaded file is empty (has a size of <code>0</code>).</li>
			</ul>
			<p>Apart from these three keyword arguments, the constructor can also accept the standard <code>Field</code> arguments, such as <code>widget</code>. The default widget class for a <code>FileField</code> is <code>ClearableFileInput</code>. This is a file input that can display a checkbox that can be checked to send a null value and clear the saved file on a model field.</p>
			<p>Using a form with a <code>FileField</code> in a view is similar to other forms, but when the form has been submitted (that is, <code>request.METHOD</code> is <code>POST</code>), then <code>request.FILES</code> should be passed into the form constructor as well. This is because Django needs to access <code>request.FILES</code> to find information about uploaded files when validating the form.</p>
			<p>The basic flow in a <code>view</code> function is therefore like this:</p>
			<pre>def view(request):
    if request.method == "POST":
        # instantiate the form with POST data and files
        form = ExampleForm(request.POST, request.FILES)
        if form.is_valid():
            # process the form and save files
            return redirect("success-url")
    else:
        # instantiate an empty form as we've seen before
        form = ExampleForm()
    # render a template, the same as for other forms
    return render(request, "template.html", {"form": form})</pre>
			<p>When working with uploaded files and forms, you can interact with the uploaded files by accessing them through <code>request.FILES</code>, or through <code>form.cleaned_data</code>: the values will return to the same object. In our above example, we could process the uploaded file like this:</p>
			<pre>if form.is_valid():
    save_file_upload("/path/to/save.jpg", \
                     request.FILES["file_upload"])
    return redirect("/success-url/")</pre>
			<p>Or, since they contain the same object, you can use <code>form.cleaned_data</code>:</p>
			<pre>if form.is_valid():
    save_file_upload("/path/to/save.jpg", \
                     form.cleaned_data["file_upload"])
    return redirect("/success-url/")</pre>
			<p>The data that is saved will be the same.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, you experimented with forms and submitting them with invalid values. When the page refreshed to show the form errors, the data that you had previously entered was populated when the page reloaded. This does not occur with file fields; instead, the user will have to navigate and select the file again if the form is invalid.</p>
			<p>In the next exercise, we will put what we have seen with <code>FileFields</code> into practice by building an example form, then modifying our view to save the file only if the form is valid.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor256"/>Exercise 8.04: File Uploads with a Django Form</h2>
			<p>In the previous exercise, you created a form in HTML and used it to upload a file to a Django view. If you tried submitting the form without selecting a file, you would get a Django exception screen. You did not do any validation on the form, so this method is quite fragile.</p>
			<p>In this exercise, you will create a Django form with a <code>FileFIeld</code>, which will allow you to use form validation functions to make the view more robust as well to reduce the amount of code:</p>
			<ol>
				<li value="1">In PyCharm, inside the <code>media_example</code> app, create a new file named <code>forms.py</code>. It will open automatically. At the start of the file, import the Django <code>forms</code> library:<pre>from django import forms</pre><p>Then, create a <code>forms.Form</code> subclass, and name it <code>UploadForm</code>. Add one field to it, a <code>FileField</code> named <code>file_upload</code>. Your class should have this code:</p><pre>class UploadForm(forms.Form):
    file_upload = forms.FileField()</pre><p>You can save and close this file. The complete file should look like this: <a href="http://packt.live/34S5hBV">http://packt.live/34S5hBV</a>. </p></li>
				<li>Open the <code>form_example</code> app's <code>views.py</code> file. At the start of the file, right below the existing <code>import</code> statements, you will need to import your new class, like this: <pre>from .forms import UploadForm</pre></li>
				<li>If you are in the <code>POST</code> branch of the view, <code>UploadForm</code> needs to be instantiated with both <code>request.POST</code> and <code>request.FILES</code>. If you do not pass in <code>request.FILES</code>, then the <code>form</code> instance will not be able to access the uploaded files. Under the <code>if request.method == "POST"</code> check, instantiate the <code>UploadForm</code> with these two arguments:<pre>form = UploadForm(request.POST, request.FILES)</pre></li>
				<li>The existing lines that define the <code>save_path</code> and store the file contents can be retained, but they should be indented by one block and put inside a form validity check, so they are only executed if the form is valid. Add the <code>if form.is_valid():</code> line and then indent the other lines so the code looks like this:<pre>if form.is_valid():
    save_path = os.path.join\
                (settings.MEDIA_ROOT, \
                 request.FILES["file_upload"].name)
    with open(save_path, "wb") as output_file:
        for chunk in request.FILES["file_upload"].chunks():
            output_file.write(chunk)</pre></li>
				<li>Since you are using a form now, you can access the file upload through the form. Replace usages of <code>request.FILES["file_upload"]</code> with <code>form.cleaned_data["file_upload"]</code>:<pre>if form.is_valid():
    save_path = os.path.join\
                (settings.MEDIA_ROOT,\
                 form.cleaned_data["file_upload"].name)
    with open(save_path, "wb") as output_file:
        for chunk in <strong class="bold">form.cleaned_data["file_upload"].chunks():</strong>
            output_file.write(chunk)</pre></li>
				<li>Finally, add an <code>else</code> branch to handle non-<code>POST</code> requests, which simply instantiates a form without any arguments:<pre>if request.method == 'POST':
    …
else:
    form = UploadForm()</pre></li>
				<li>Add a context dictionary argument to the <code>render</code> call and set the <code>form</code> variable in the <code>form</code> key:<pre>return render(request, "media-example.html", \
              {"form": form})</pre><p>You can now save and close this file. It should look like this: <a href="http://packt.live/3psXxyc">http://packt.live/3psXxyc</a>. </p></li>
				<li>Finally, open the <code>media-example.html</code> template and remove your manually defined file <code>&lt;input&gt;</code>. Replace it with <code>form</code>, rendered using the <code>as_p</code> method (highlighted):<pre>&lt;body&gt;
    &lt;form method="post" enctype="multipart/form-data"&gt;
        {% csrf_token %}
        <strong class="bold">{{ form.as_p }}</strong>
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;</pre><p>You should not change any other parts of the file. You can save and close this file. It should look like this: <a href="http://packt.live/3qHHSMi">http://packt.live/3qHHSMi</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <code>http://127.0.0.1:8000/media-example/</code>. You should see the <code>File upload</code> field and the <code>Submit</code> button, as follows:<div><img src="img/B15509_08_12.jpg" alt="Figure 8.12: File upload Django form rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.12: File upload Django form rendered in the browser</p></li>
				<li>Since we are using a Django form, we get its built-in validation automatically. If you try to submit the form without selecting a file, your browser should prevent you and show an error, as can be seen here:<div><img src="img/B15509_08_13.jpg" alt="Figure 8.13: Form submission prevented by the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.13: Form submission prevented by the browser</p></li>
				<li>Finally, repeat the upload test that you performed in <em class="italic">Exercise 8.03</em>, <em class="italic">File Upload and Download</em>, by selecting a file and submitting the form. You should then be able to retrieve the file using <code>MEDIA_URL</code>. In this case, a file named <code>cover.jpg</code> is being uploaded again (see the following figure):<p> </p><div><img src="img/B15509_08_14.jpg" alt="Figure 8.14: Uploading a file named cover.jpg&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.14: Uploading a file named cover.jpg</p>
			<p>You can then retrieve the file at <code>http://127.0.0.1:8000/media/cover.jpg</code>, and you can see it in the browser as follows:</p>
			<p> </p>
			<div><div><img src="img/B15509_08_15.jpg" alt="Figure 8.15: The file uploaded using a Django form is also visible in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: The file uploaded using a Django form is also visible in the browser</p>
			<p>In this exercise, we replaced a manually built form with a Django form containing a <code>FileField</code>. We instantiated the form in the view by passing in both <code>request.POST</code> and <code>request.FILES</code>. We then used the standard <code>is_valid</code> method to check the validity of the form, and only saved the file upload if the form was valid. We tested the file uploading and saw we were able to retrieve uploaded files using <code>MEDIA_URL</code>.</p>
			<p>In the next section, we will look at <code>ImageField</code>, which is like a <code>FileField</code> but specifically for images.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor257"/>Image Uploads with Django Forms</h2>
			<p>If you want to work with images in Python, the most common library that you will use is called <code>Image</code> object is imported from PIL:</p>
			<pre>from PIL import Image</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The terms Python Imaging Library, PIL, and Pillow are often used interchangeably. You can assume that if someone refers to PIL, they mean the latest Pillow library.</p>
			<p>Pillow provides various methods of retrieving data about or manipulating images. You can find out the width and height of images, or scale, crop, and apply transformations to them. There are too many operations available to cover in this chapter, so we will just introduce a simple example (scaling an image), which you will use in the next exercise. </p>
			<p>Since images are one of the most common types of files that a user may want to upload, Django also includes an <code>ImageField</code> instance. This behaves similarly to <code>FileField</code> instance but also automatically validates that the data is an image file. This helps mitigate security issues where we expect an image, but the user uploads a malicious file.</p>
			<p>An <code>UploadedFile</code> from an <code>ImageField</code> has all the same attributes and methods as that of a <code>FileField</code> (<code>size</code>, <code>content_type</code>, <code>name</code>, <code>chunks()</code>, and so on) but adds an extra attribute: <code>image</code>. This is an instance of the PIL <code>Image</code> object that is used to verify that the file being uploaded is a valid image. </p>
			<p>After checking that the form is valid, the underlying PIL <code>Image</code> object is closed. This is to free up memory and prevent the Python process from holding too many files open, which could cause performance issues. What this means for the developer is that you can access some of the metadata about the image (such as its <code>width</code>, <code>height</code>, and <code>format</code>) but you can't access the actual image data without re-opening the image.</p>
			<p>To illustrate, we will have a form with an <code>ImageField</code>, named <code>picture</code>:</p>
			<pre>class ExampleForm(forms.Form):
    picture = ImageField()</pre>
			<p>Inside the view function, the <code>picture</code> field can be accessed in the form's <code>cleaned_data</code>:</p>
			<pre>if form.is_valid():
    picture_field = form.cleaned_data["picture"]</pre>
			<p>Then, the <code>picture</code> field's <code>Image</code> object can be retrieved:</p>
			<pre>image = picture_field.image</pre>
			<p>Now that we have a reference to the image in the view, we can get some metadata:</p>
			<pre>w = image.width  # an integer, e.g. 600
h = image.height  # also an integer, e.g. 420
# the format of the image as a string, e.g. "PNG"
f = image.format</pre>
			<p>Django will also automatically update the <code>content_type</code> attribute of <code>UploadedFile</code> to the correct type for the <code>picture</code> field. This overwrites the value that the browser sent when uploading the file.</p>
			<p>Attempting to use a method that accesses the actual image data (rather than just the metadata) will cause an exception to be raised. This is because Django has already closed the underlying image file.</p>
			<p>For example, the following code snippet will raise an <code>AttributeError</code>:</p>
			<pre>image.getdata()</pre>
			<p>Instead, we need to re-open the image. The image data can be opened with the <code>ImageField</code> reference, after importing the <code>Image</code> class:</p>
			<pre>from PIL import Image
image = Image.open(picture_field)</pre>
			<p>Now that the image has been opened, you can perform operations on it. In the next section, we will look at a simple example – resizing the uploaded image.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor258"/>Resizing an Image with Pillow</h2>
			<p>Pillow supports many operations that you might want to perform on an image before saving it. We cannot explain them all in this book, so we will just use a common operation: resizing an image to a specific size before saving it. This will help us save storage space and improve the download speed. For example, a user may upload large cover images in Bookr that are bigger than are needed for our purposes. When saving the file (writing it back to disk) we must specify the format to use. We could determine the type of image that was uploading with a number of methods (such as checking the <code>content_type</code> of the uploaded file or the <code>format</code> from the <code>Image</code> object), but in our example, we will always just save the image as a <code>JPEG</code> file.</p>
			<p>The PIL <code>Image</code> class has a <code>thumbnail</code> method that will resize an image to a maximum size while retaining the aspect ratio. For example, we could set a maximum size of 50px by 50px. A 200px by 100px image would be resized to 50px by 25px: the aspect ratio is retained by setting the maximum dimension to 50px. Each dimension is scaled by a factor of 0.25:</p>
			<pre>from PIL import Image
size = 50, 50  # a tuple of width, height to resize to
image = Image.open(image_field)  # open the image as before
image.thumbnail(size)  # perform the resize</pre>
			<p>At this point, the resize has been done in memory only. The change is not saved to disk until the <code>save</code> method is called, like so:</p>
			<pre>image.save("path/to/file.jpg")</pre>
			<p>The output format is automatically determined from the file extension used, in this case, JPEG. The <code>save</code> method can also take a format argument to override it. For example:</p>
			<pre>image.save("path/to/file.png", "JPEG")</pre>
			<p>Despite having the extension <code>png</code>, the format is specified as <code>JPEG</code> and so the output will be in JPEG format. As you might imagine, this can be very confusing, so you might decide to stick with specifying the extension only.</p>
			<p>In the next exercise, we will change the <code>UploadForm</code> we have been working with to use an <code>ImageField</code> instead of a <code>FileField</code>, then implement the resizing of an uploaded image before saving it to the media directory.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor259"/>Exercise 8.05: Image Uploads using Django Forms</h2>
			<p>In this exercise, you will update the <code>UploadForm</code> class you created in <em class="italic">Exercise 8.04</em>, <em class="italic">File Uploads with a Django Form</em>, to use an <code>ImageField</code> instead of a <code>FileField</code> (this will involve simply changing the field's class). You will then see that the form renders it in the browser. Next, you will try uploading some non-image files and see how Django validates the form to disallow them. Finally, you will update your view to use PIL to resize the image before saving it, and then test it in action:</p>
			<ol>
				<li value="1">Open the <code>media_example</code> app's <code>forms.py</code> file. In the <code>UploadForm</code> class, change <code>file_upload</code> so it's an instance of <code>ImageField</code> instead of <code>FileField</code>. After updating, your <code>UploadForm</code> should look like this:<pre>class UploadForm(forms.Form):
    file_upload = forms.<code>forms.py</code> file should look like this: <a href="http://packt.live/2KAootD">http://packt.live/2KAootD</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <code>http://127.0.0.1:8000/media-example/</code>. You should see the form rendered, and it will look identical as to when we used a <code>FileField</code> (see the following figure):<div><img src="img/B15509_08_16.jpg" alt="Figure 8.16: The ImageField looks the same as a FileField&#13;&#10;"/></div><p class="figure-caption">Figure 8.16: The ImageField looks the same as a FileField</p></li>
				<li>You will notice the difference when you try to upload a non-image file. Click the <code>Browse…</code> button and try to select a non-image file. Depending on your browser or operating system, you might not be able to select anything other than an image file, as in <em class="italic">Figure 8.17</em>:<p> </p><div><img src="img/B15509_08_17.jpg" alt="Figure 8.17: Only image files are selectable&#13;&#10;"/></div><p class="figure-caption">Figure 8.17: Only image files are selectable</p><p>Your browser may allow selecting an image but show an error in the form after selection. Or your browser may allow you to select a file and submit the form, and Django will raise a <code>ValidationError</code>. Regardless, you can be sure that in your view, the form's <code>is_valid</code> view will only return <code>True</code> if an image has been uploaded.</p><p class="callout-heading">Note</p><p class="callout">You do not need to test uploading a file at this point, as the result would be the same as in <em class="italic">Exercise 8.04</em>, <em class="italic">File Uploads with a Django Form</em>.</p></li>
				<li>The first thing you will need to do is to make sure the Pillow library is installed. In a terminal (making sure your virtual environment has been activated), run:<pre>pip3 install pillow</pre><p>(In Windows, this is <code>pip install pillow</code>.) You will get output like <em class="italic">Figure 8.18</em>:</p><div><img src="img/B15509_08_18.jpg" alt="Figure 8.18: pip3 installing Pillow&#13;&#10;"/></div><p class="figure-caption">Figure 8.18: pip3 installing Pillow</p><p>Or if Pillow was already installed, you will see the output message <code>Requirement already satisfied</code>.</p></li>
				<li>Now we can update the <code>media_example</code> view to resize the image before saving it. Switch back to PyCharm and open the <code>media_example</code> app's <code>views.py</code> file, then import PIL's <code>Image</code> class. So, add this import line below the <code>import os</code> statement near the top of the file:<pre>from PIL import Image</pre></li>
				<li>Go to the <code>media_example</code> view. Under the line that generates the <code>save_path</code>, take out the three lines that open the output file, iterate over the uploaded file, and write out its chunks. Replace this with the code that opens the uploaded file with PIL, resizes it, then saves it:<pre>image = Image.open(form.cleaned_data["file_upload"])
image.thumbnail((50, 50))
image.save(save_path)</pre><p>The first line creates an <code>Image</code> instance by opening the uploaded file, the next performs the thumbnail conversion (to a maximum size of 50px by 50px), and the third line saves the file to the same save path that we have been generating in previous exercises. You can save the file. It should look like this: <a href="http://packt.live/34PWvof">http://packt.live/34PWvof</a>. </p></li>
				<li>The Django dev server should still be running from <em class="italic">step 2</em>, but you should start it if it is not. Then, navigate to <code>http://127.0.0.1:8000/media-example/</code>. You will see the familiar <code>UploadForm</code>. Select an image and submit the form. If the upload and resize was successful, the form will refresh and be empty again.</li>
				<li>View the uploaded image using <code>MEDIA_URL</code>. For example, a file named <code>cover.jpg</code> will be downloadable from <code>http://127.0.0.1:8000/media/cover.jpg</code>. You should see the image has been resized to have a maximum dimension of just 50px:<p> </p><div><img src="img/B15509_08_19.jpg" alt="Figure 8.19: Resized logo&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.19: Resized logo</p>
			<p>While a thumbnail this size might not be that useful, it at least lets us be sure that the image resize has worked correctly.</p>
			<p>In this exercise, we changed the <code>FileField</code> on <code>UploadForm</code> to an <code>ImageField</code>. We saw that the browser wouldn't let us upload anything other than images. We then added code to the <code>media_example</code> view to resize the uploaded image using PIL.</p>
			<p>We have encouraged the use of a separate web server to serve static and media files, for performance reasons. However, in some cases, you might want to use Django to serve files, for example, to provide authentication before allowing access. In the next section, we will discuss how to use Django to serve media files.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor260"/>Serving Uploaded (and Other) Files Using Django</h2>
			<p>Throughout this chapter and <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, we have discouraged serving files using Django. This is because it would needlessly tie up a Python process just serving a file – something that the web server is capable of handling. Unfortunately, web servers do not usually provide dynamic access control, that is, allowing only authenticated users to download a file. Depending on your web server used in production, you might be able to have it authenticate against Django and then serve the file itself; however, the specific configuration of specific web servers is outside the scope of this book.</p>
			<p>One approach you can take is to specify a subdirectory of your <code>MEDIA_ROOT</code> directory and have your web server prevent access to just this specific folder. Any protected media should be stored inside it. If you do this, only Django will be able to read the files inside. For example, your web server could serve everything in the <code>MEDIA_ROOT</code> directory, except for a <code>MEDIA_ROOT/protected</code> directory.</p>
			<p>Another approach would be to configure a Django view to serve a specific file from disk. The view will determine the path of the file on disk to send, then send it using the <code>FileResponse</code> class. The <code>FileResponse</code> class takes an open filehandle as an argument and tries to determine the correct content type from the file's content. Django will close the filehandle after the request completes.</p>
			<p>The view function will accept the request and a relative path to the file to be downloaded, as parameters. This relative path is the path inside the <code>MEDIA_ROOT/protected</code> folder.</p>
			<p>In our case, we will just check whether the user is anonymous (not logged in). We will do this by checking the <code>request.user.is_anonymous</code> property. If they are not logged in then we will raise a <code>django.core.exceptions.PermissionDenied</code> exception, which returns an HTTP <code>403 Forbidden</code> response to the browser. This will stop the execution of the view and not return any file:</p>
			<pre>import os.path
from django.conf import settings
from django.http import FileResponse
from django.core.exceptions import PermissionDenied
def download_view(request, relative_path):
    if request.user.is_anonymous:
        raise PermissionDenied
    full_path = os.path.join(settings.MEDIA_ROOT, \
                             "protected", relative_path)
    file_handle = open(full_path, "rb")
    return FileResponse(file_handle)
# Django sends the file then closes the handle</pre>
			<p>The URL mapping to this view could be like this, using the <code>&lt;path&gt;</code> path converter. Inside your <code>urls.py</code> file:</p>
			<pre>urlpatterns = [
    …
    path("downloads/&lt;path:relative_path&gt;", views.download_view)]</pre>
			<p>There are many ways that you could choose to implement a view that sends files. The important thing is that you use the <code>FileResponse</code> class, which is designed to stream the file to the client in chunks instead of loading it all into memory. This will reduce the load on the server and lessen the impact on resource usage if you have to resort to sending files with Django.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor261"/>Storing Files on Model Instances</h1>
			<p>So far, we have manually managed the uploading and saving of files. You can also associate a file with a model instance by assigning the path to which it was saved to a <code>CharField</code>. However, as with much of Django, this capability (and more) is already provided with the <code>models.FileField</code> class. <code>FileField</code> instances do not actually store the file data; instead, they store the path where the file is stored (like a <code>CharField</code> would), but they also provide helper methods. These methods assist with loading files (so you do not have to manually open them) and generating disk paths for you based on the ID of the instance (or other attributes).</p>
			<p><code>FileField</code> can accept two specific optional arguments in its constructor (as well as the base <code>Field</code> arguments, such as <code>required</code>, <code>unique</code>, <code>help_text</code>, and so on):</p>
			<ul>
				<li><code>max_length</code>: Like <code>max_length</code> in the form's <code>ImageField</code>, this is the maximum length of the filename that is allowed.</li>
				<li><code>upload_to</code>: The <code>upload_to</code> argument has three different behaviors depending on what type of variable is passed to it. Its simplest use is with a string or <code>pathlib.Path</code> object. The path is simply appended to <code>MEDIA_ROOT</code>. </li>
			</ul>
			<p>In this example, <code>upload_to</code> is just defined as a string:</p>
			<pre>class ExampleModel(models.Model):
    file_field = models.FileField(upload_to="files/")</pre>
			<p>Files saved to this <code>FileField</code> would be stored in the <code>MEDIA_ROOT/files</code> directory.</p>
			<p>You could achieve the same result using a <code>pathlib.Path</code> instance too:</p>
			<pre>import pathlib
class ExampleModel(models.Model):
    file_field = models.FileField(upload_to=pathlib.Path("files/"))</pre>
			<p>The next way of using <code>upload_to</code> is with a string that contains <code>strftime</code> formatting directives (for example, <code>%Y</code> to substitute the current year, <code>%m</code> for the current month, and <code>%d</code> for the current day of the month). The full list of these directives is extensive and can be found at <a href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a>. Django will automatically interpolate these values when saving the file.</p>
			<p>For example, say you defined the model and <code>FileField</code> like this:</p>
			<pre>class ExampleModel(models.Model):
    file_field = models.FileField(upload_to="files/%Y/%m/%d/")</pre>
			<p>For the first file uploaded on a specific day, Django would create the directory structure for that day. For example, for the first file uploaded on January 1, 2020, Django would create the directory <code>MEDIA_ROOT/2020/01/01</code> and then store the uploaded file in there. The next file (and all subsequent ones) uploaded on the same day would also be stored in that directory. Similarly, on January 2, 2020, Django would create the <code>MEDIA_ROOT/2020/01/02</code> directory, and files would be stored there.</p>
			<p>If you have many thousands of files being uploaded every day, you could even have the files split up further by including the hour and minute in the <code>upload_to</code> argument (<code>upload_to="files/%Y/%m/%d/%H/%M/"</code>). This may not be necessary if you only have a small volume of uploads though.</p>
			<p>By utilizing this method of the <code>upload_to</code> argument, you can have Django automatically segregate uploads and prevent too many files from being stored within a single directory (which can be hard to manage). </p>
			<p>The final method of using <code>upload_to</code> is by passing a function that will be called to generate the storage path. Note that this is different than the other uses of <code>upload_to</code> as it should generate the full path, including filename, rather than just the directory. The function takes two arguments: <code>instance</code> and <code>filename</code>. <code>instance</code> is the model instance that the <code>FileField</code> is attached to, and <code>filename</code> is the name of the uploaded file.</p>
			<p>Here is an example function that takes the first two characters of a filename to generate the saved directory. This will mean that each uploaded file will be grouped into parent directories, which can help organize files and prevent there from being too many in one directory:</p>
			<pre>def user_grouped_file_path(instance, filename):
    return "{}/{}/{}/{}".format(instance.username, \
                                filename[0].lower(), \
                                filename[1].lower(), filename)</pre>
			<p>If this function is called with the filename <code>Test.jpg</code>, it will return <code>&lt;username&gt;/t/e/Test.jpg</code>. If called with <code>example.txt</code>, it will return <code>&lt;username&gt;e/x/example.txt</code>, and so on. <code>username</code> is retrieved from the instance that is being saved. To illustrate, here is a model with a <code>FileField</code> that uses this function. It also has a username, which is a <code>CharField</code>:</p>
			<pre>class ExampleModel(models.Model):
    file_field = models.FileField\
                 (upload_to=user_grouped_file_path)
    username = models.CharField(unique=True)</pre>
			<p>You can use any attribute of the instance in the <code>upload_to</code> function, but be aware that if this instance is in the process of being created, then the file save function will be called before it is saved to the database. Therefore, some of the automatically generated attributes on the instance (such as <code>id</code>/<code>pk</code>) will not yet be populated and should not be used to generate a path.</p>
			<p>Whatever path is returned from the <code>upload_to</code> function, it is appended to <code>MEDIA_ROOT</code> so the uploaded files would be saved at <code>MEDIA_ROOT/&lt;username&gt;/t/e/Test.jpg</code> and <code>MEDIA_ROOT/&lt;username&gt;/e/x/example.txt</code> respectively. </p>
			<p>Note that <code>user_grouped_file_path</code> is just an illustrative function that has intentionally been kept short, so it will not work correctly with single-character filenames or if the username has invalid characters. For example, if the username has a <code>/</code> in it, then this would act as a directory separator in the generated path.</p>
			<p>Now we have done a deep dive into setting up a <code>FileField</code> on a model, but how do we actually save an uploaded file to it? It is as easy as assigning the uploaded file to the attribute of the model, as you would with any type of value. Here is a quick example with a view, and the simple <code>ExampleModel</code> class we were using as an example earlier in this section:</p>
			<pre>class ExampleModel(models.Model):
    file_field = models.FileField(upload_to="files/")
def view(request):
    if request.method == "POST":
        m = ExampleModel()  # Create a new ExampleModel instance
        m.file_field = request.FILES["uploaded_file"]
        m.save()
    return render(request, "template.html")</pre>
			<p>In this example, we create a new <code>ExampleModel</code> class and assign the uploaded file (which had the name <code>uploaded_file</code> in the form) to its <code>file_field</code> attribute. When we save the model instance, Django automatically writes the file with its name to the <code>upload_to</code> directory path. If the uploaded file had the name <code>image.jpg</code>, the save path would be <code>MEDIA_ROOT/upload_to/image.jpg</code>.</p>
			<p>We could just have easily updated the file field on an existing model or used a form (validating it before saving). Here is another simple example demonstrating this:</p>
			<pre>class ExampleForm(forms.Form):
    uploaded_file = forms.FileField()
def view(request, model_pk):
    form = ExampleForm(request.POST, request.FILES)
    if form.is_valid():    
        # Get an existing model instance
        m = ExampleModel.object.get(pk=model_pk)
        # store the uploaded file on the instance
        m.file_field = form.cleaned_data["uploaded_file"]
        m.save()
    return render(request, "template.html")</pre>
			<p>You can see that updating a <code>FileField</code> on an existing model instance is the same process as setting it on a new instance; and if you choose to use a Django form, or just access <code>request.FILES</code> directly, the process is just as simple.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor262"/>Storing Images on Model Instances</h2>
			<p>While a <code>FileField</code> can store any type of file, including images, there is also an <code>ImageField</code>. As you would expect, this is only for storing images. The relationship between models' <code>forms.FileField</code> and <code>forms.ImageField</code> is similar to that between <code>models.FileField</code> and <code>models.ImageField</code>, that is, <code>ImageField</code> extends <code>FileField</code> and adds extra methods for working with images.</p>
			<p>The <code>ImageField</code> constructor takes the same arguments as <code>FileField</code>, and adds two extra optional arguments:</p>
			<ul>
				<li><code>height_field</code>: This is the name of the field of the model that will be updated with the height of the image every time the model instance is saved.</li>
				<li><code>width_field</code>: The width counterpart to <code>height_field</code>, the field that stores the width of the image that is updated every time the model instance is saved.</li>
			</ul>
			<p>Both of these arguments are optional, but the fields they name must exist if used. That is, it is valid to have <code>height_field</code> or <code>width_field</code> unset, but if they are set to the name of a field that does not exist, then an error will occur. The purpose of this is to assist with searching the database for files of a particular dimension. </p>
			<p>Here is an example model using an <code>ImageField</code>, which updates the image dimension fields:</p>
			<pre>class ExampleModel(models.Model):
    image = models.ImageField(upload_to="images/%Y/%m/%d/", \
                              height_field="image_height",\
                              width_field="image_width")
    image_height = models.IntegerField()
    image_width = models.IntegerField()</pre>
			<p>Notice that the <code>ImageField</code> is using the <code>upload_to</code> parameter with date formatting directives that are updated on save. The behavior of <code>upload_to</code> is identical to that of <code>FileField</code>.</p>
			<p>Upon saving an <code>ExampleModel</code> instance, its <code>image_height</code> field would be updated with the height of the image, and <code>image_width</code> with the width of the image.</p>
			<p>We will not show examples for setting <code>ImageField</code> values in a view, as the process is the same as for a plain <code>FileField</code>.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor263"/>Working with FieldFile</h2>
			<p>When you access a <code>FileField</code> or <code>ImageField</code> attribute of a model instance, you will not get a native Python <code>file</code> object. Instead, you will be working with a <code>FieldFile</code> object. The <code>FieldFile</code> class is a wrapper around a <code>file</code> that adds extra methods. Yes, it can be confusing to have classes called <code>FileField</code> and <code>FieldFile</code>.</p>
			<p>The reason that Django uses <code>FieldFile</code> instead of just a <code>file</code> object is twofold. First, it adds extra methods to open, read, delete, and generate the URL of the file. Second, it provides an abstraction to allow alternative storage engines to be used. </p>
			<h3 id="_idParaDest-249"><a id="_idTextAnchor264"/>Custom Storage Engines</h3>
			<p>We looked at custom storage engines in <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, regarding storing static files. We will not examine custom storage engines in detail about media files, since the code outlined in <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, for static files also applies to media files. The important thing to note is that the storage engine you are using can be changed without updating your other code. This means that you can have your media files stored on your local drive during development and then saved to a CDN when your application is deployed to production.</p>
			<p>The default storage engine class can be set with <code>DEFAULT_FILE_STORAGE</code> in <code>settings.py</code>. The storage engine can also be specified on a per-field basis (for <code>FileField</code> or <code>ImageField</code>) with the <code>storage</code> argument. For example:</p>
			<pre>storage_engine = CustomStorageEngine()
class ExampleModel(models.Model):
    image_field = ImageField(storage=storage_engine)</pre>
			<p>This demonstrates what actually happens when you upload or retrieve a file. Django delegates to the storage engine to write or read it, respectively. This happens even while saving to disk; however, it is fundamental and is invisible to the user.</p>
			<h3 id="_idParaDest-250"><a id="_idTextAnchor265"/>Reading a Stored FieldFile</h3>
			<p>Now that we have learned about custom storage engines, let us look at reading from a <code>FieldFile</code>. In the previous sections, we saw how to set the file on the model instance. Reading the data back again is just as easy – we have a couple of different methods that can help us, depending on our use case.</p>
			<p>In the following few code snippets, assume we are inside a view and have retrieved our model instance in some manner, and it is stored in a variable, <code>m</code>. For example:</p>
			<pre>m = ExampleModel.object.get(pk=model_pk)</pre>
			<p>We can read all the data from the file with the <code>read</code> method:</p>
			<pre>data = m.file_field.read()</pre>
			<p>Or we can manually open the file with the <code>open</code> method. This might be useful if we want to write our own generated data to the file:</p>
			<pre>with m.file_field.open("wb") as f:
    chunk = f.write(b"test")  # write bytes to the file</pre>
			<p>If we wanted to read the file in chunks, we can use the <code>chunks</code> method. This works the same as reading chunks from the uploaded file, as we saw earlier:</p>
			<pre>for chunk in m.file_field.chunks():
    # assume this method is defined somewhere
    write_chunk(open_file, chunk)</pre>
			<p>We can also manually open the file ourselves by using its <code>path</code> attribute:</p>
			<pre>open(m.file_field.path)</pre>
			<p>If we want to stream a <code>FileField</code> for download, the best way is by using the <code>FileResponse</code> class as we saw earlier. Combine this with the <code>open</code> method on the <code>FileField</code>. Note that if we are just trying to serve a media file, we should only implement a view to do this if we are trying to restrict access to the file. Otherwise, we should just serve the file using <code>MEDIA_URL</code> and allow the web server to handle the request. Here is how we'd write our <code>download_view</code> to use a <code>FileField</code> instead of the manually specified path:</p>
			<pre>def download_view(request, model_pk):
    if request.user.is_anonymous:
        raise PermissionDenied
    m = ExampleModel.objects.get(pk=model_pk)
    # Django sends the file then closes the handle
    return FileResponse(m.file_field.open())  </pre>
			<p>Django opens the correct path and closes it after the response. Django will also attempt to determine the correct mime type for the file. We assume that this <code>FileField</code> has its <code>upload_to</code> attribute set to a protected directory that the web server is preventing direct access to.</p>
			<h3 id="_idParaDest-251"><a id="_idTextAnchor266"/>Storing Existing Files or Content in FileField</h3>
			<p>We've seen how to store an uploaded file in an image field – simply assign it to the field like so:</p>
			<pre>m.file_field = request.FILES["file_upload"]</pre>
			<p>But how can we set the <code>field</code> value to that of an existing file that we might already have on disk? You might think you can use a standard Python <code>file</code> object, but this won't work:</p>
			<pre># Don't do this
m.file_field = open("/path/to/file.txt", "rb")  </pre>
			<p>You might also try setting the file using some content:</p>
			<pre>m.file_field = "new file content"  # Don't do this</pre>
			<p>This won't work either.</p>
			<p>You instead need to use the <code>save</code> method of <code>FileField</code>, which accepts an instance of a Django <code>File</code> or <code>ContentFile</code> object (these classes' full paths are <code>django.core.files.File</code> and <code>django.core.files.base.ContentFile</code>, respectively). We will briefly discuss the <code>save</code> method and its arguments then return to these classes.</p>
			<p>The <code>save</code> method of <code>FileField</code> takes three arguments:</p>
			<ul>
				<li><code>name</code>: The name of the file you are saving. This is the name the file will have when saved to the storage engine (in our case, to disk, inside <code>MEDIA_ROOT</code>).</li>
				<li><code>Content</code>: This is an instance of <code>File</code> or <code>ContentFile</code>, which we just saw; again, we will discuss these soon.</li>
				<li><code>Save</code>: This argument is optional and defaults to <code>True</code>. This indicates whether or not to save the model instance to the database after saving the file. If set to <code>False</code> (that is, the model is not saved), then the file will still be written to the storage engine (to disk), but the association is not stored on the model. The previous file path (or no file if one was not set) will still be stored in the database until the model instance's <code>save</code> method is called manually. You should only set this argument to <code>False</code> if you intend to make other changes to the model instance and then save it manually.</li>
			</ul>
			<p>Back to <code>File</code> and <code>ContentFile</code>: the one to use depends on what you want to store in a <code>FileField</code>. </p>
			<p><code>File</code> is used as a wrapper around a Python <code>file</code> object, and you should use it if you have an existing <code>file</code> or file-like object that you want to save. File-like objects include <code>io.BytesIO</code> or <code>io.StringIO</code> instances. To instantiate a <code>File</code> instance, just pass the native <code>file</code> object to the constructor, for example:</p>
			<pre>f = open("/path/to/file.txt", "rb")
file_wrapper = File(f)</pre>
			<p>Use <code>ContentFile</code> when you already have some data loaded, either a <code>str</code> or <code>bytes</code> object. Pass the data to the <code>ContentFile</code> constructor:</p>
			<pre>string_content = ContentFile("A string value")
bytes_content = ContentField(b"A bytes value")</pre>
			<p>Now that you have either a <code>File</code> or <code>ContentFile</code> instance, saving the data to the <code>FileField</code> is easy, using the <code>save</code> method:</p>
			<pre>m = ExampleModel.objects.first()
with open("/path/to/file.txt") as f:
    file_wrapper = File(f)
    m.file_field.save("file.txt", f)</pre>
			<p>Since we did not pass a value for <code>save</code> to the <code>save</code> method, it will default to <code>True</code>, so the model instance is automatically persisted to the database.</p>
			<p>Next, we will look at how to store an image that has been manipulated with a PIL back to an image field.</p>
			<h3 id="_idParaDest-252"><a id="_idTextAnchor267"/>Writing PIL Images to ImageField</h3>
			<p>In <em class="italic">Exercise 8.05</em>, <em class="italic">Image Uploads Using Django Forms</em>, you used PIL to resize an image and save it to disk. When working with a model, you might want to perform a similar operation, but have Django handle the file storage using the <code>ImageField</code> so that you do not have to do it manually. As in the exercise, you could save the image to disk and then use the <code>File</code> class to wrap the stored path – something like this:</p>
			<pre>image = Image.open(request.FILES["image_field"])
image.thumbnail((150, 150))
# save thumbnail to temp location
image.save("/tmp/thumbnail.jpg")
with open("/tmp/thumbnail.jpg", "rb") as f:
    image_wrapper = File(f)
    m.image_field.save("thumbnail.jpg", image_wrapper)
os.unlink("/tmp/thumbnail.jpg")  # clean up temp file</pre>
			<p>In this example, we're having PIL stored to a temporary location with the <code>Image.save()</code> method, and then re-opening the file.</p>
			<p>This method works but is not ideal as it involves writing the file to disk and then reading it out again, which can sometimes be slow. Instead, we can perform this whole process in memory. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>io.BytesIO</code> and <code>io.StringIO</code> are useful objects. They behave like files but exist in memory only. <code>BytesIO</code> is used for storing raw bytes, and <code>StringIO</code> accepts Python 3's native Unicode strings. You can <code>read</code>, <code>write</code>, and <code>seek</code> them, just like a normal file. Unlike a normal file though, they do not get written to disk and instead will disappear when your program terminates, or they go out of scope and are garbage-collected. They are very useful if a function wants to write to something like a file, but you want to access the data immediately. </p>
			<p>First, we will save the image data to an <code>io.BytesIO</code> object. Then, we will wrap the <code>BytesIO</code> object in a <code>django.core.files.images.ImageFile</code> instance (a subclass of <code>File</code> that is specifically for images and provides <code>width</code> and <code>height</code> attributes). Once we have this <code>ImageFile</code> instance, we can use it in the <code>save</code> method of <code>ImageField</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An <code>ImageFile</code> is a file or file-like wrapper just like <code>File</code>. It provides two extra attributes: <code>width</code>, and <code>height</code>. <code>ImageFile</code> does not generate any errors if you use it to wrap a non-image. For example, you could <code>open()</code> a text file and pass the filehandle to the <code>ImageFile</code> constructor without any issue. You can check whether the image file you passed in was valid by trying to access the <code>width</code> or <code>height</code> attributes: if these are <code>None</code>, then PIL was unable to decode the image data. You could check for the validity of these values yourself and throw an exception if they were <code>None</code>.</p>
			<p>Let us have a look at this in practice, in a view:</p>
			<pre>from io import BytesIO
from PIL import Image
from django.core.files.images import ImageFile
def index(request, pk):
    # trim out logic for checking if method is POST
    # get a model instance, or create a new one
    m = ExampleModel.objects.get(pk=pk)  
    
    # store the uploaded image in a variable for shorter code
    uploaded_image = request.FILES["image_field"]
    # load a PIL image instance from the uploaded file
    image = Image.open(uploaded)
    # perform the image resize
    image.thumbnail((150, 150))
    # Create a BytesIO file-like object to store
    image_data = BytesIO()
    # Write the Image data back out to the BytesIO object
    # Retain the existing format from the uploaded image
    image.save(fp=image_data, uploaded_image.format)
    # Wrap the BytesIO containing the image data
    image_file = ImageFile(image_data)
    # Save the wrapped image file data with the original name
    m.image_field.save(uploaded_image.name, image_file)
    # this also saves the model instance
    return redirect("/success-url/")</pre>
			<p>You can see this is a little bit more code, but it saves on writing the data to disk. You can choose to use either method (or another one that you come up with) depending on your needs. </p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor268"/>Referring to Media in Templates</h2>
			<p>Once we have uploaded a file, we want to be able to refer to it in a template. For an uploaded image, such as a book cover, we will want to be able to display the image on the page. We saw in <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>, how to build a URL using <code>MEDIA_URL</code> in a template. When working with <code>FileField</code> or <code>ImageField</code> on a model instance, it is not necessary to do this as Django provides this functionality for you.</p>
			<p>The <code>url</code> attribute of a <code>FileField</code> will automatically generate the full URL to the media file, based on the <code>MEDIA_URL</code> in your settings.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that references we make to a <code>FileField</code> in this section also apply to <code>ImageField</code>, as it is a subclass of <code>FileField</code>.</p>
			<p>This can be used anywhere that you have access to the instance and field, such as in a view or a template. For example, in a view:</p>
			<pre>instance = ExampleModel.objects.first()
url = instance.file_field.url  # Get the URL</pre>
			<p>Or in a template (assuming the <code>instance</code> has been passed to the template context):</p>
			<pre>&lt;img src="img/{{ instance.file_field.url }}"&gt;</pre>
			<p>In the next exercise, we will create a new model with a <code>FileField</code> and <code>ImageField</code>, then show how Django can automatically save these. We'll also demonstrate how to retrieve the URL for an uploaded file.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor269"/>Exercise 8.06: FileField and ImageField on Models</h2>
			<p>In this exercise, we will create a model with a <code>FileField</code> and <code>ImageField</code>. After doing this, we will have to generate a migration and apply it. We will then change the <code>UploadForm</code> we have been using so it has both a <code>FileField</code> and an <code>ImageField</code>. The <code>media_example</code> view will be updated to store the uploaded files in the model instance. Finally, we will add an <code>&lt;img&gt;</code> into the example template to show the previously uploaded image:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>media_example</code> app's <code>models.py</code> file. Create a new model called <code>ExampleModel</code>, with two fields: an <code>ImageField</code> named <code>image_field</code>, and a <code>FileField</code> called <code>file_field</code>. The <code>ImageField</code> should have its <code>upload_to</code> set to <code>images/</code>, and the <code>FileField</code> should have its <code>upload_to</code> set to <code>files/</code>. The finished model should look like this:<pre>class ExampleModel(models.Model):
    image_field = models.ImageField(upload_to="images/")
    file_field = models.FileField(upload_to="files/")</pre><p>Your <code>models.py</code> should now look like this: <a href="http://packt.live/3p4bfrr">http://packt.live/3p4bfrr</a>. </p></li>
				<li>Open a terminal and navigate to the <code>media_project</code> project directory. Make sure your <code>bookr</code> virtual environment is active. Run the <code>makemigrations</code> management command to generate the migrations for this new model (for Windows, you can use <code>python</code> instead of <code>python3</code> in the following code):<pre>python3 manage.py makemigrations
(bookr)$ python3 manage.py makemigrations
Migrations for 'media_example':
  media_example/migrations/0001_initial.py
    - Create model ExampleModel</pre></li>
				<li>Apply the migration by running the <code>migrate</code> management command:<pre>python3 manage.py migrate</pre><p>The output is like the following:</p><pre>(bookr)$ python3 manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, reviews, sessions
Running migrations:
  # output trimmed for brevity
   Applying media_example.0001_initial... OK</pre><p>Note that all the initial Django migrations will also be applied since we did not apply those after creating the project.</p></li>
				<li>Switch back to PyCharm and open the <code>reviews</code> app's <code>forms.py</code> file. Rename the existing <code>ImageField</code> from <code>file_upload</code> to <code>image_upload</code>. Then, add a new <code>FileField</code> named <code>file_upload</code>. After making these changes, your <code>UploadForm</code> code should look like this:<pre>class UploadForm(forms.Form):
    image_upload = forms.ImageField()
    file_upload = forms.FileField()</pre><p>You can save and close the file. It should look like this: <a href="http://packt.live/37RZcaG">http://packt.live/37RZcaG</a>. </p></li>
				<li>Open the <code>media_example</code> app's <code>views.py</code> file. First, import <code>ExampleModel</code> into the file. To do this, add this line at the top of the file after the existing <code>import</code> statements:<pre>from .models import ExampleModel</pre><p>Some imports will no longer be required, so you can remove these lines:</p><pre>import os
from PIL import Image
from django.conf import settings</pre></li>
				<li>In the <code>media_example</code> view, set a default for the instance that you will render, in case one is not created. After the function definition, define a variable called <code>instance</code>, and set it to <code>None</code>:<pre>def media_example(request):
    instance = None</pre></li>
				<li>You can completely remove the contents of the <code>form.is_valid()</code> branch as you no longer need to manually save the file. Instead, it will automatically be saved when the <code>ExampleModel</code> instance is saved. You will instantiate an <code>ExampleModel</code> instance and set the <code>file</code> and <code>image</code> fields from the uploaded form. <p>Add this code under the <code>if form.is_valid():</code> line:</p><pre>instance = ExampleModel()
instance.image_field = form.cleaned_data["image_upload"]
instance.file_field = form.cleaned_data["file_upload"]
instance.save()</pre></li>
				<li>Pass the instance through to the template in the context dictionary that is passed to <code>render</code>. Use the key <code>instance</code>:<pre>return render(request, "media-example.html", \
              {"form": form, "instance": instance})</pre><p>Now, your completed <code>media_example</code> view should look like this: <a href="http://packt.live/3hqyYz7">http://packt.live/3hqyYz7</a>.</p><p>You can now save and close this file.</p></li>
				<li>Open the <code>media-example.html</code> template. Add an <code>&lt;img&gt;</code> element that displays the last uploaded image. Under the closing <code>&lt;/form&gt;</code> tag, add an <code>if</code> template tag that checks if an <code>instance</code> has been provided. If so, display an <code>&lt;img&gt;</code> with a <code>src</code> attribute of <code>instance.image_field.url</code>:<pre>{% if instance %}
    &lt;img src="img/{{ instance.image_field.url }}"&gt;
{% endif %}</pre><p>You can save and close this file. It should now look like this: <a href="http://packt.live/2X5d5w9">http://packt.live/2X5d5w9</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <code>http://127.0.0.1:8000/media-example/</code>. You should see the form rendered with two fields:<div><img src="img/B15509_08_20.jpg" alt="Figure 8.20: UploadForm with two fields&#13;&#10;"/></div><p class="figure-caption">Figure 8.20: UploadForm with two fields</p></li>
				<li>Select a file for each field – for the <code>ImageField</code> you must select an image, but any type of file is allowed for the <code>FileField</code>. See <em class="italic">Figure 8.21</em>, which shows the fields with files selected:<div><img src="img/B15509_08_21.jpg" alt="Figure 8.21: ImageField and FileField with files selected&#13;&#10;"/></div><p class="figure-caption">Figure 8.21: ImageField and FileField with files selected</p><p>Then, submit the form. If the submission was successful, the page will reload and the last image you uploaded will be displayed (<em class="italic">Figure 8.22</em>):</p><div><img src="img/B15509_08_22.jpg" alt="Figure 8.22: The last image that was uploaded is displayed&#13;&#10;"/></div><p class="figure-caption">Figure 8.22: The last image that was uploaded is displayed</p></li>
				<li>You can see how Django stores the files by looking in the <code>MEDIA_ROOT</code> directory. <em class="italic">Figure 8.23</em> shows the directory layout in PyCharm:<div><img src="img/B15509_08_23.jpg" alt="Figure 8.23: Uploaded files that Django has created&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.23: Uploaded files that Django has created</p>
			<p>You can see that Django has created the <code>files</code> and <code>images</code> directories. These were what you set in the <code>upload_to</code> arguments on the <code>ImageField</code> and <code>FileField</code> of the model. You could also verify these uploads by attempting to download them, for example, at <code>http://127.0.0.1:8000/media/files/sample.txt</code> or <code>http://127.0.0.1:8000/media/images/cover.jpg</code>.</p>
			<p>In this exercise, we created <code>ExampleModel</code> with <code>FileField</code> and <code>ImageField</code> and saw how to store uploaded files in it. We saw how to generate a URL to an uploaded file for use in a template. We tried uploading some files and saw that Django automatically created the <code>upload_to</code> directories (<code>media/files</code> and <code>media/images</code>), then stored the files inside.</p>
			<p>In the next section, we will look at how we can simplify the process even further by using a <code>ModelForm</code> to generate the form and save the model without having to manually set the files in the view.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor270"/>ModelForms and File Uploads</h2>
			<p>We have seen how using a <code>form.ImageField</code> on a form can prevent non-images being uploaded. We have also seen how <code>models.ImageField</code> makes it easy to store an image for a model. But we need to be aware that Django does not stop you from setting a non-image file to an <code>ImageField</code>. For example, consider a form that has both a <code>FileField</code> and <code>ImageField</code>:</p>
			<pre>class ExampleForm(forms.Form):
    uploaded_file = forms.FileField()
    uploaded_image = forms.ImageField()</pre>
			<p>In the following view, the form would not validate if the <code>uploaded_image</code> field on the form was not an image, so some data validity is ensured for uploaded data. For example:</p>
			<pre>def view(request):
    form = ExampleForm(request.POST, request.FILES)
    if form.is_valid():
        m = ExampleModel()
        m.file_field = form.cleaned_data["uploaded_file"]
        m.image_field = forms.cleaned_data["uploaded_image"]
        m.save()
    return render(request, "template.html")  </pre>
			<p>Since we are sure the form is valid, we know that <code>forms.cleaned_data["uploaded_image"]</code> must contain an image. Therefore, we would never assign a non-image to the model instance's <code>image_field</code>.</p>
			<p>However, say we made a mistake in our code and wrote something like this:</p>
			<pre>m.image_field = forms.cleaned_data["uploaded_file"]</pre>
			<p>That is, if we accidentally reference the <code>FileField</code> by mistake, Django does not validate that a (potential) non-image is being assigned to an <code>ImageField</code>, and so it does not throw an exception or generate any kind of error. We can mitigate the potential for issues like this by using a <code>ModelForm</code>.</p>
			<p>We introduced <code>ModelForm</code> in <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em> – these are forms whose fields are automatically defined from a model. We saw that a <code>ModelForm</code> has a <code>save</code> method that automatically creates or updates the model data in the database. When used with a model that has a <code>FileFIeld</code> or <code>ImageField</code>, then the <code>ModelForm</code> <code>save</code> method will also save uploaded files.</p>
			<p>Here is an example of using a <code>ModelForm</code> to save a new model instance in a view. Here, we are just making sure to pass <code>request.FILES</code> to the <code>ModelForm</code> constructor:</p>
			<pre>class ExampleModelForm(forms.Model):
    class Meta:
        model = ExampleModel
        # The same ExampleModel class we've seen previously
        fields = "__all__"
def view(request):
    if request.method == "POST":
        form = ExampleModelForm(request.POST, request.FILES)
        form.save()
        return redirect("/success-page")
    else:
        form = ExampleModelForm()
    return (request, "template.html", {"form": form})</pre>
			<p>As with any <code>ModelForm</code>, the <code>save</code> method can be called with the <code>commit</code> argument set to <code>False</code>. Then the model instance will not be saved to the database, and the <code>FileField</code>/<code>ImageField</code> files will not be saved to disk. The <code>save</code> method should be called on the model instance itself – this will commit changes to the database and save the files. In this next short example, we set a value on the model instance before saving it:</p>
			<pre>def view(request):
    if request.method == "POST":
        form = ExampleModelForm(request.POST, request.FILES)
        m = form.save(False)
        # Set arbitrary value on the model instance before save
        m.attribute = "value"
        # save the model instance, also write the files to disk
        m.save()
        return redirect("/success-page/")
    else:
        form = ExampleModelForm()
    return (request, "template.html", {"form": form})</pre>
			<p>Calling the <code>save</code> method on the model instance both saves the model data to the database and the uploaded files to disk. In the next exercise, we will build a <code>ModelForm</code> from <code>ExampleModel</code>, which we created in <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, then test uploading files with it.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor271"/>Exercise 8.07: File and Image Uploads Using a ModelForm</h2>
			<p>In this exercise, you will update <code>UploadForm</code> to be a subclass of <code>ModelForm</code> and have it built automatically from <code>ExampleModel</code>. You will then change the <code>media_example</code> view to save the instance automatically from the form, so you can see how the amount of code can be reduced:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>media_example</code> apps' <code>forms.py</code> file. You need to use <code>ExampleModel</code> in this chapter, so <code>import</code> it at the top of the file after the <code>from django import forms</code> statement. Insert this line:<pre>from .models import ExampleModel</pre></li>
				<li>Change <code>UploadForm</code> to be a subclass of <code>forms.ModelForm</code>. Remove the <code>class</code> body and replace it with a <code>class Meta</code> definition; its <code>model</code> should be <code>ExampleModel</code>. Set the <code>fields</code> attribute to <code>__all__</code>. After completing this step, your <code>UploadForm</code> should look like this:<pre>class UploadForm(forms.ModelForm):
    class Meta:
        model = ExampleModel
        fields = "__all__"</pre><p>Save and close the file. It should now look like this: <a href="http://packt.live/37X49ig">http://packt.live/37X49ig</a>.</p></li>
				<li>Open the <code>media_example</code> app's <code>views.py</code> file. Since you no longer need to reference the <code>ExampleModel</code> directly, you can remove its <code>import</code> at the top of the file. Remove the following line:<pre>from .models import ExampleModel</pre></li>
				<li>In the <code>media_example</code> view, remove the entirety of the <code>form.is_valid()</code> branch and replace it with a single line:<pre>instance = form.save()</pre><p>The form's <code>save</code> method will handle persisting the instance to the database and saving the files. It will return an instance of <code>ExampleModel</code>, the same as the other instances of <code>ModelForm</code> we have worked with in <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em>.</p><p>After completing this step, your <code>media_example</code> function should look like this: <a href="http://packt.live/37V0ly2">http://packt.live/37V0ly2</a>. Save and close <code>views.py</code>.</p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <code>http://127.0.0.1:8000/media-example/</code>. You should see the form rendered with two fields, <code>Image field</code> and <code>File field</code> (<em class="italic">Figure 8.24</em>): <div><img src="img/B15509_08_24.jpg" alt="Figure 8.24: UploadForm as a ModelForm rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.24: UploadForm as a ModelForm rendered in the browser</p><p>Note that the names of these fields now match those of the model rather than the form, as the form just uses the model's fields.</p></li>
				<li>Browse and select an image and file (<em class="italic">Figure 8.25</em>), then submit the form:<p> </p><div><img src="img/B15509_08_25.jpg" alt="Figure 8.25: Image and file selected&#13;&#10;"/></div><p class="figure-caption">Figure 8.25: Image and file selected</p></li>
				<li>The page will reload, and as in <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, you will see the previously uploaded image (<em class="italic">Figure 8.26</em>):<p> </p><div><img src="img/B15509_08_26.jpg" alt="Figure 8.26: Image being displayed after upload&#13;&#10;"/></div><p class="figure-caption">Figure 8.26: Image being displayed after upload</p></li>
				<li>Finally, examine the contents of the <code>media</code> directory. You should see the directory layout matches that of <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, with images inside the <code>images</code> directory, and files inside the <code>files</code> directory:<div><img src="img/B15509_08_27.jpg" alt="Figure 8.27: The uploaded files directory matches Exercise 8.06&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.27: The uploaded files directory matches Exercise 8.06</p>
			<p>In this exercise, we changed <code>UploadForm</code> to be a <code>ModelForm</code> subclass, which allowed us to automatically generate the upload fields. We could replace the code that stored the uploaded files on the models with a call to the form's <code>save</code> method.</p>
			<p>We have now covered everything you need to start enhancing Bookr with file uploads. In the activity for this chapter, we will add support for uploading a cover image and sample document (PDF, text file, and more) for a book. The book cover will be resized using PIL before it is saved.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor272"/>Activity 8.01: Image and PDF Uploads of Books</h2>
			<p>In this activity, you will start by cleaning up (deleting) the example views, templates, forms, models, and URL maps that we have used throughout the exercises in this chapter. You will then need to generate and apply a migration to delete <code>ExampleModel</code> from the database.</p>
			<p>You can then start adding the Bookr enhancements, first by adding an <code>ImageField</code> and <code>FileField</code> to the <code>Book</code> model to store the book <code>cover</code> and <code>sample</code>. Then you will create a migration and apply it to add these fields to the database. You can then build a form that will display just these new fields. You will add a view that uses this form to save the model instance with the uploaded files, after first resizing the image to thumbnail size. You will be able to reuse the <code>instance-form.html</code> template from <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em>, with a minor change to allow file uploads.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Update the Django settings to add the settings <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code>.</li>
				<li>The <code>/media/</code> URL mapping should be added to <code>urls.py</code>. Use the <code>static</code> view and utilize <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> from Django settings. Remember, this mapping should only be added if <code>DEBUG</code> is true.</li>
				<li>Add an <code>ImageField</code> (named <code>cover</code>) and <code>FileField</code> (named <code>sample</code>) to the <code>Book</code> model. The fields should upload to <code>book_covers/</code> and <code>book_samples/</code>, respectively. They should both allow <code>null</code> and <code>blank</code> values.</li>
				<li>Run <code>makemigrations</code> and <code>migrate</code> again to apply the <code>Book</code> model changes to the database.</li>
				<li>Create a <code>BookMediaForm</code> as a subclass of <code>ModelForm</code>. Its model should be <code>Book</code>, and the fields should only be the fields you added in <em class="italic">step 3</em>.</li>
				<li>Add a <code>book_media</code> view. This will not allow you to create a <code>Book</code>, instead, it will only allow you to add media to an existing <code>Book</code> (so it must take <code>pk</code> as a required argument).</li>
				<li>The <code>book_media</code> view should validate the form, and <code>save</code> it, but not <code>commit</code> the instance. The uploaded cover should first be resized using the <code>thumbnail</code> method as demonstrated in the <em class="italic">Writing PIL Images to ImageField</em> section. The maximum size should be 300 by 300 pixels. It should then be stored on the instance and the instance saved. Remember that the <code>cover</code> field is not required so you should check this before trying to manipulate the image. On a successful <code>POST</code>, register a success message that the <code>Book</code> was updated, then redirect to the <code>book_detail</code> view.</li>
				<li>Render the <code>instance-form.html</code>, passing a context dictionary containing <code>form</code>, <code>model_type,</code> and <code>instance</code>, as you did in <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>. Also pass another item, <code>is_file_upload</code>, set to <code>True</code>. This variable will be used in the next step.</li>
				<li>In the <code>instance-form.html</code> template, use the <code>is_file_upload</code> variable to add the correct <code>enctype</code> attribute to the form. This will allow you to switch the modes for the form to enable file uploads when required.</li>
				<li>Finally, add a URL map that maps <code>/books/&lt;pk&gt;/media/</code> to the <code>book_media</code> view.</li>
			</ol>
			<p>When you are finished, you should be able to start the Django dev server and load the <code>book_media</code> view at <code>http://127.0.0.1:8000/books/&lt;pk&gt;/media/</code>, for example, <code>http://127.0.0.1:8000/books/2/media/</code>. You should see the <code>BookMediaForm</code> rendered in the browser, like in <em class="italic">Figure 8.28</em>:</p>
			<div><div><img src="img/B15509_08_28.jpg" alt="Figure 8.28: BookMediaForm in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.28: BookMediaForm in the browser</p>
			<p>Select a cover image and sample file for the book. You can use the image at <a href="http://packt.live/2KyIapl">http://packt.live/2KyIapl</a> and PDF at <a href="http://packt.live/37VycHn">http://packt.live/37VycHn</a> (or you can use any other image/PDF of your choosing).</p>
			<div><div><img src="img/B15509_08_29.jpg" alt="Figure 8.29: Book Cover image and Sample selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.29: Book Cover image and Sample selected</p>
			<p>After submitting the form, you will be redirected to the <code>Book Details</code> view and see the success message (<em class="italic">Figure 8.30</em>):</p>
			<p> </p>
			<div><div><img src="img/B15509_08_30.jpg" alt="Figure 8.30: Success message on the Book Details page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.30: Success message on the Book Details page</p>
			<p>If you go back to the same book's media page, you should see the fields are now filled in, with an option to clear the data from them:</p>
			<div><div><img src="img/B15509_08_31.jpg" alt="Figure 8.31: BookMediaForm with existing values&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 8.31: BookMediaForm with existing values</p>
			<p>In <em class="italic">Activity 8.02</em>, <em class="italic">Displaying Cover and Sample Links</em>, you will add these uploaded files to the <code>Book Details</code> view, but for now, if you want to check that uploads have worked, you can look inside the <code>media</code> directory in the Bookr project:</p>
			<div><div><img src="img/B15509_08_32.jpg" alt="Figure 8.32: Book media&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32: Book media</p>
			<p>You should see the directories that were created and the uploaded files, as per <em class="italic">Figure 8.32</em>. Open an uploaded image, and you should see its maximum dimension is 300 pixels.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-258">Activity 8.02: Displaying Cover <a id="_idTextAnchor273"/>and Sample Links</h2>
			<p>In this activity, you will update the <code>book_detail.html</code> template to show the cover for the <code>Book</code> (if one is set). You will also add a link to download the sample, again, only if one is set. You will use the <code>FileField</code> and <code>ImageField</code> <code>url</code> attributes to generate the URLs to the media files.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Inside the <code>Book Details</code> display in the <code>book_detail.html</code> view, add an <code>&lt;img&gt;</code> element if the book has a <code>cover</code> image. Then, display the cover of the book inside it. Use <code>&lt;br&gt;</code> after the <code>&lt;img&gt;</code> tag so the image is on its own line.</li>
				<li>After the <code>Publication Date</code> display, add a link to the sample file. It should only be displayed if a <code>sample</code> file has been uploaded. Make sure you add another <code>&lt;br&gt;</code> tag so it displays correctly.</li>
				<li>In the section that has a link to add a review, add another link that goes to the media page for the book. Follow the same styling as the <code>Add Review</code> link.</li>
			</ol>
			<p>When you have completed these steps, you should be able to load a book detail page. If the book has no <code>cover</code> or <code>sample</code>, then the page should look very similar to what it did before, except you should see the new link to the <code>Media</code> page at the bottom (<em class="italic">Figure 8.33</em>):</p>
			<div><div><img src="img/B15509_08_33.jpg" alt="Figure 8.33: New Media button visible on the book detail page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.33: New Media button visible on the book detail page</p>
			<p>Once you have uploaded a <code>cover</code> and/or a <code>sample</code> for a <code>Book</code>, the cover image and sample link should be displayed (<em class="italic">Figure 8.34</em>):</p>
			<div><div><img src="img/B15509_08_34.jpg" alt="Figure 8.34: Book cover and sample link displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.34: Book cover and sample link displayed</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor274"/>Summary</h1>
			<p>In this chapter, we added the <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> settings and a special URL map to serve media files. We then created a form and a view to upload files and save them to the <code>media</code> directory. We saw how to add the media context processor to automatically have access to the <code>MEDIA_URL</code> setting in all our templates. We then enhanced and simplified our form code by using a Django form with a <code>FileField</code> or <code>ImageField</code>, instead of manually defining one in HTML.</p>
			<p>We looked at some of the enhancements Django provides for images with the <code>ImageField</code>, and how to interact with an image using Pillow. We showed an example view that would be able to serve files that required authentication, using the <code>FileResponse</code> class. Then, we saw how to store files on models using the <code>FileField</code> and <code>ImageField</code> and refer to them in a template using the <code>FileField.url</code> attribute. We were able to reduce the amount of code we had to write by automatically building a <code>ModelForm</code> from a <code>model</code> instance. Finally, in the two activities at the end, we enhanced Bookr by adding a cover image and sample file to the <code>Book</code> model. In <em class="italic">Chapter 9</em>, <em class="italic">Sessions and Authentication</em>, we will learn how to add authentication to a Django application to protect it from unauthorized users.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>