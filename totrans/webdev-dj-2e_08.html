<html><head></head><body>
		<div>
			<div id="_idContainer289" class="Content">
			</div>
		</div>
		<div id="_idContainer290" class="Content">
			<h1 id="_idParaDest-229"><a id="_idTextAnchor244"/>8. Media Serving and File Uploads</h1>
		</div>
		<div id="_idContainer325" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter starts by introducing you to media files and then teaching you how to set up Django to serve them. Once you have understood this, you will learn how to build a form in HTML that can upload files to a view for storage to disk. To enhance this process and reduce the amount of code, you will use Django forms to generate and validate a form and learn how to process file uploads through it. You will then look at some enhancements that Django provides specifically for working with image files and use the <strong class="bold">Python Imaging Library</strong> to resize an image. You will then create a model that uses <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong> to store a file and image respectively and upload to it using a Django form. After this, you will build a <strong class="source-inline">ModelForm</strong> instance automatically from the model and save the model and the files using just one line of code. At the end of this chapter, you will enhance the Bookr app by adding a cover image and book excerpt to the <strong class="source-inline">Book</strong> model.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor245"/>Introduction</h1>
			<p>Media files refer to extra files that can be added after deployment to enrich your Django application. Usually, they are extra images that you would use in your site, but any type of file (including video, audio, PDF, text, documents, or even HTML) can be served as media.</p>
			<p>You can think of them as somewhere between dynamic data and static assets. They are not dynamic data that Django generates on the fly, like when rendering a template. They also are not the static files that are included by the site developer when the site is deployed. Instead, they are extra files that can be uploaded by users or generated by your application for later retrieval.</p>
			<p>Some common examples of media files (that you will see in <em class="italic">Activity 8.01</em>, <em class="italic">Image and PDF Uploads of Books</em>, later in this chapter) are book covers and preview PDFs that can be attached to a <strong class="source-inline">Book</strong> object. You can also use media files to allow users to upload images for a blog post or avatars for a social media site. If you wanted to use Django to build your own video sharing platform, you would store the uploaded videos as media. Your website will not function well if all these files are static files, as users won't be able to upload their own book covers, videos, and so on, and will be stuck with the ones you deployed.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor246"/>Settings for Media Uploads and Serving</h1>
			<p>In <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, we looked at how Django can be used to serve static files. Serving media files is quite similar. Two settings must be configured in <strong class="source-inline">settings.py</strong>: <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong>. These are analogous to <strong class="source-inline">STATIC_ROOT</strong> and <strong class="source-inline">STATIC_URL</strong> for serving static files.</p>
			<ul>
				<li><strong class="source-inline">MEDIA_ROOT</strong><p>This is the path on the disk where the media (such as uploaded files) will be stored. As with static files, your web server should be configured to serve directly from this directory, to take the load off Django.</p></li>
				<li><strong class="source-inline">MEDIA_URL</strong><p>This is similar to <strong class="source-inline">STATIC_URL</strong>, but as you might guess, it's the URL that should be used to serve media. It must end in a <strong class="source-inline">/</strong>. Generally, you will use something like <strong class="source-inline">/media/</strong>.</p><p class="callout-heading">Note</p><p class="callout">For security reasons, the path for <strong class="source-inline">MEDIA_ROOT</strong> must not be the same as the path for <strong class="source-inline">STATIC_ROOT</strong>, and <strong class="source-inline">MEDIA_URL</strong> must not be the same as <strong class="source-inline">STATIC_URL</strong>. If they were the same, a user might replace your static files (such as JavaScript or CSS files) with malicious code and exploit your users.</p></li>
			</ul>
			<p><strong class="source-inline">MEDIA_URL</strong> is designed to be used in templates so that you are not hardcoding the URL and it can be changed easily. For example, you might want to set it to a specific host or <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>) when you deploy to production. We will discuss the use of <strong class="source-inline">MEDIA_URL</strong> in templates in an upcoming section.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor247"/>Serving Media Files in Development</h2>
			<p>As with static files, when serving media in production, your web server should be configured to serve directly from the <strong class="source-inline">MEDIA_ROOT</strong> directory to prevent Django from being tied up servicing the request. The Django dev server can serve media files in development. However, unlike static files, the URL mapping and view is not set up automatically for media files. </p>
			<p>Django provides the <strong class="source-inline">static</strong> URL mapping that can be added to your existing URL maps to serve media files. It is added to your <strong class="source-inline">urls.py</strong> file like this:</p>
			<p class="source-code">from django.conf import settings</p>
			<p class="source-code">from django.conf.urls.static import static</p>
			<p class="source-code">urlpatterns = [</p>
			<p class="source-code">    # your existing URL maps</p>
			<p class="source-code">] </p>
			<p class="source-code">if settings.DEBUG:</p>
			<p class="source-code">    urlpatterns += static(settings.MEDIA_URL,\</p>
			<p class="source-code">                          document_root=settings.MEDIA_ROOT)</p>
			<p>This will serve the <strong class="source-inline">MEDIA_ROOT</strong> setting defined in <strong class="source-inline">settings.py</strong> to the <strong class="source-inline">MEDIA_URL</strong> setting that is also defined there. The reason we check for <strong class="source-inline">settings.DEBUG</strong> before appending the map is so we don't add this map in production.</p>
			<p>For example, if your <strong class="source-inline">MEDIA_ROOT</strong> was set to <strong class="source-inline">/var/www/bookr/media</strong>, and your <strong class="source-inline">MEDIA_URL</strong> was set to <strong class="source-inline">/media/</strong>, then the <strong class="source-inline">/var/www/bookr/media/image.jpg</strong> file would be available at <strong class="source-inline">http://127.0.0.1:8000/media/image.jpg</strong>.</p>
			<p>The <strong class="source-inline">static</strong> URL map does not work when the Django <strong class="source-inline">DEBUG</strong> setting is <strong class="source-inline">False</strong>, and so it can't be used in production. However, as mentioned earlier, in production your web server should be serving these requests, so Django will not need to handle them.</p>
			<p>In the first exercise, you will create and add a new <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong> to your <strong class="source-inline">settings.py</strong> file. You will then add the <strong class="source-inline">static</strong> media serving URL map and add a test file to ensure media serving is configured correctly.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor248"/>Exercise 8.01: Configuring Media Storage and Serving Media Files</h2>
			<p>In this exercise, you will set up a new Django project as an example project to use throughout this chapter. Then you'll configure it to be able to serve media files. You'll do this by creating a <strong class="source-inline">media</strong> directory and adding the <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong> settings. Then you'll set up the URL mapping for <strong class="source-inline">MEDIA_URL</strong>. </p>
			<p>To check that everything is configured and being served correctly, you will put a test file inside the <strong class="source-inline">media</strong> directory:</p>
			<ol>
				<li>As with the previous example Django projects you've set up, you can reuse the existing <strong class="source-inline">bookr</strong> virtual environment. In a terminal, activate the <strong class="source-inline">bookr</strong> virtual environment. Then, start a new project named <strong class="source-inline">media_project</strong>, using <strong class="source-inline">django-admin.py</strong>:<p class="callout-heading">Note</p><p class="callout">To learn how to create and activate a virtual environment, refer to the <em class="italic">Preface</em>. </p><p class="source-code">django-admin.py startproject media_project</p><p>Change (or <strong class="source-inline">cd</strong>) into the <strong class="source-inline">media_project</strong> directory that was created, then use the <strong class="source-inline">startapp</strong> management command to start an app called <strong class="source-inline">media_example</strong>:</p><p class="source-code">python3 manage.py startapp media_example</p></li>
				<li>Open the <strong class="source-inline">media_project</strong> directory in PyCharm. Set up a run configuration for the <strong class="source-inline">runserver</strong> command in the same manner as for the other Django projects you've opened:<div id="_idContainer291" class="IMG---Figure"><img src="image/B15509_08_01.jpg" alt="Figure 8.1: Runserver configuration&#13;&#10;"/></div><p class="figure-caption">Figure 8.1: Runserver configuration</p><p><em class="italic">Figure 8.1</em> shows the <strong class="source-inline">runserver</strong> configuration of the project in PyCharm.</p></li>
				<li>Create a new directory named <strong class="source-inline">media</strong> inside the <strong class="source-inline">media_project</strong> project directory. Then, create a new file in this directory named <strong class="source-inline">test.txt</strong>. The directory structure of this will look like <em class="italic">Figure 8.2</em>:<div id="_idContainer292" class="IMG---Figure"><img src="image/B15509_08_02.jpg" alt="Figure 8.2: media directory and test.txt layout&#13;&#10;"/></div><p class="figure-caption">Figure 8.2: media directory and test.txt layout</p></li>
				<li><strong class="source-inline">test.txt</strong> will also open automatically. Enter the text <strong class="source-inline">Hello, world!</strong> into it, then you can save and close the file.</li>
				<li>Open <strong class="source-inline">settings.py</strong> inside the <strong class="source-inline">media_project</strong> package directory. At the end of the file, add a setting for <strong class="source-inline">MEDIA_ROOT</strong>, using the path to the media directory you just created. Make sure to import the <strong class="source-inline">os</strong> module at the top of the file:<p class="source-code">import os</p><p>Then use it to join it to <strong class="source-inline">BASE_DIR</strong> using the <strong class="source-inline">os.path.join</strong> function:</p><p class="source-code">MEDIA_ROOT = os.path.join(BASE_DIR, 'media')</p></li>
				<li>Directly below the line added in <em class="italic">step 5</em>, add another setting for <strong class="source-inline">MEDIA_URL</strong>. This should just be <strong class="source-inline">'/media/'</strong>:<p class="source-code">MEDIA_URL = '/media/'</p><p>After this, save <strong class="source-inline">settings.py</strong>. Here's what it should look like:</p><p class="source-code">STATIC_URL = '/static/'</p><p class="source-code">MEDIA_ROOT = os.path.join(BASE_DIR, 'media')</p><p class="source-code"><strong class="bold">MEDIA_URL = '/media/'</strong></p><p>With these changes made, your <strong class="source-inline">settings.py</strong> should look like this: <a href="http://packt.live/34RdhU1">http://packt.live/34RdhU1</a>.</p></li>
				<li>Open the <strong class="source-inline">media_project</strong> package's <strong class="source-inline">urls.py</strong> file. After the <strong class="source-inline">urlpatterns</strong> definition, add the following code to add the media serving URL if running in <strong class="source-inline">DEBUG</strong> mode. First, you will need to import the Django settings and static serving view by adding the highlighted import lines above the <strong class="source-inline">urlpatterns</strong> definition:<p class="source-code">from django.contrib import admin</p><p class="source-code">from django.urls import path</p><p class="source-code"><strong class="bold">from django.conf import settings</strong></p><p class="source-code"><strong class="bold">from django.conf.urls.static import static</strong></p><p class="source-code">urlpatterns = [path('admin/', admin.site.urls),]</p></li>
				<li>Then, add the following code right after your <strong class="source-inline">urlpatterns</strong> definition (refer to the code block in the previous step) to conditionally add a mapping from <strong class="source-inline">MEDIA_URL</strong> to the <strong class="source-inline">static</strong> view, which will serve from <strong class="source-inline">MEDIA_ROOT</strong>:<p class="source-code">if settings.DEBUG:</p><p class="source-code">    urlpatterns += static(settings.MEDIA_URL,\</p><p class="source-code">                          document_root=settings.MEDIA_ROOT)</p><p>You can now save this file. It should look like this: <a href="http://packt.live/3nVUiPn">http://packt.live/3nVUiPn</a>.</p></li>
				<li>Start the Django dev server if it is not already running, then visit <strong class="source-inline">http://127.0.0.1:8000/media/test.txt</strong>. If you did everything correctly, then you should see the text <strong class="source-inline">Hello, world!</strong> in your browser:<div id="_idContainer293" class="IMG---Figure"><img src="image/B15509_08_03.jpg" alt="Figure 8.3: Serving a media file&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.3: Serving a media file</p>
			<p>If your browser looks like <em class="italic">Figure 8.3</em>, it means that the media files are being served from the <strong class="source-inline">MEDIA_ROOT</strong> directory. The <strong class="source-inline">test.txt</strong> file we created was just for testing, but we will use it in <em class="italic">Exercise 8.02</em>,<em class="italic"> Template Settings and Using MEDIA_URL in Templates</em>, so don't delete it yet.</p>
			<p>In this exercise, we configured Django to serve media files. We served a test file just to make sure everything works as expected, and it did. We'll now look at how we can automatically generate media URLs in templates.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor249"/>Context Processors and Using MEDIA_URL in Templates</h1>
			<p>To use <strong class="source-inline">MEDIA_URL</strong> in a template, we could pass it in through the rendering context dictionary, in our view. For example:</p>
			<p class="source-code">from django.conf import settings</p>
			<p class="source-code">def my_view(request):</p>
			<p class="source-code">    return render(request, "template.html",\</p>
			<p class="source-code">                  {"MEDIA_URL": settings.MEDIA_URL,\</p>
			<p class="source-code">                   "username": "admin"})</p>
			<p>This will work, but the problem is that <strong class="source-inline">MEDIA_URL</strong> is a common variable that we might want to use in many places, and so we'd have to pass it through in practically every view.</p>
			<p>Instead, we can use a <strong class="bold">context processor</strong>, which is a way of adding one or more variables automatically to the context dictionary on every <strong class="source-inline">render</strong> call.</p>
			<p>A context processor is a function that accepts one argument, the current request. It returns a dictionary of context information that will be merged with the dictionary that was passed to the <strong class="source-inline">render</strong> call.</p>
			<p>We can look at the source code of the <strong class="source-inline">media</strong> context processor, which illustrates how they work:</p>
			<p class="source-code">def media(request):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Add media-related context variables to the context.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return {'MEDIA_URL': settings.MEDIA_URL}</p>
			<p>With the media context processor activated, <strong class="source-inline">MEDIA_URL</strong> will be added to our context dictionaries. We could change our <strong class="source-inline">render</strong> call, seen previously, to this:</p>
			<p class="source-code">return render(request, "template.html", {"username": "admin"})</p>
			<p>The same data would be sent to the template, as the context processor would add <strong class="source-inline">MEDIA_URL</strong>.</p>
			<p>The full module path to the <strong class="source-inline">media</strong> context processor is <strong class="source-inline">django.template.context_processors.media</strong>. Some examples of other context processors that Django provides are: </p>
			<ul>
				<li><strong class="source-inline">django.template.context_processors.debug</strong><p>This returns the dictionary <strong class="source-inline">{"DEBUG": settings.DEBUG}</strong>.</p></li>
				<li><strong class="source-inline">django.template.context_processors.request</strong> <p>This returns the dictionary <strong class="source-inline">{"request": request}</strong>, that is, it just adds the current HTTP request to the context.</p></li>
			</ul>
			<p>To enable a context processor, its module path must be added to the <strong class="source-inline">context_processors</strong> option of your <strong class="source-inline">TEMPLATES</strong> setting. For example, to enable the media context processor, add <strong class="source-inline">django.template.context_processors.media</strong>. We will cover how to do this in detail in <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>. </p>
			<p>Once the <strong class="source-inline">media</strong> context processor is enabled, the <strong class="source-inline">MEDIA_URL</strong> variable can be accessed inside a template just like a normal variable:</p>
			<p class="source-code">{{ MEDIA_URL }}</p>
			<p>You could use it, for example, to source an image:</p>
			<p class="source-code">&lt;img src="{{ MEDIA_URL }}uploads/image.jpg"&gt;</p>
			<p>Note that, unlike with static files, there is no template tag for loading media files (that is, there is no equivalent to the <strong class="source-inline">{% static %}</strong> template tag).</p>
			<p>Custom context processors can also be written. For example, referring back to the Bookr application that we have been building, we might want to show a list of the five latest reviews in a sidebar that's on every page. A context processor like this would perform this:</p>
			<p class="source-code">from reviews.models import Review</p>
			<p class="source-code">def latest_reviews(request):</p>
			<p class="source-code">    return {"latest_reviews": \</p>
			<p class="source-code">             Review.objects.order_by('-date_created')[:5]}.</p>
			<p>This would be saved in a file named <strong class="source-inline">context_processors.py</strong> in the Bookr project directory, then referred to in the <strong class="source-inline">context_processors</strong> setting by its module path, <strong class="source-inline">context_processors.latest_reviews</strong>. Or we could save it inside the <strong class="source-inline">reviews</strong> app and refer to it as <strong class="source-inline">reviews.context_processors.latest_reviews</strong>. It is up to you to decide whether a context processor should be considered project-wide or app-specific. However, bear in mind that regardless of where it is stored, once activated, it applies to all <strong class="source-inline">render</strong> calls for all apps.</p>
			<p>A context processor can return a dictionary with multiple items, or even zero items. It would do this if it had conditions to only add items if certain criteria were met, for example, showing the latest reviews only if the user is logged in. Let's explore this in detail in the next exercise.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor250"/>Exercise 8.02: Template Settings and Using MEDIA_URL in Templates</h2>
			<p>In this exercise, you will continue with <strong class="source-inline">media_project</strong> and configure Django to automatically add the <strong class="source-inline">MEDIA_URL</strong> setting to every template. You do this by adding <strong class="source-inline">django.template.context_processors.media</strong> to the <strong class="source-inline">TEMPLATES</strong> <strong class="source-inline">context_processors</strong> setting. You'll then add a template that uses this new variable, and an example view to render it. You will make changes to the view and template throughout the exercises in this chapter:</p>
			<ol>
				<li value="1">In PyCharm, open <strong class="source-inline">settings.py</strong>. First, you will need to add <strong class="source-inline">media_example</strong> to the <strong class="source-inline">INSTALLED_APPS</strong> setting, since it wasn't done when the project was set up:<p class="source-code">INSTALLED_APPS = [# other apps truncated for brevity\</p><p class="source-code">    'media_example']</p></li>
				<li>About halfway down the file, you will find the <strong class="source-inline">TEMPLATES</strong> setting, which is a dictionary. Inside it is the item <strong class="source-inline">OPTIONS</strong> (another dictionary). Inside <strong class="source-inline">OPTIONS</strong> is the <strong class="source-inline">context_processors</strong> setting.<p>To the end of this list, add this:</p><p class="source-code">'django.template.context_processors.media'</p><p>The full list should look like this:</p><p class="source-code">TEMPLATES = \</p><p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',</p><p class="source-code">  'DIRS': [],</p><p class="source-code">  'APP_DIRS': True,</p><p class="source-code">  'OPTIONS': {'context_processors': \</p><p class="source-code">              ['django.template.context_processors.debug',\</p><p class="source-code">               'django.template.context_processors.request',\</p><p class="source-code">               'django.contrib.auth.context_processors.auth',\</p><p class="source-code">               'django.contrib.messages.context_processors.messages',\</p><p class="source-code">               <strong class="bold">'django.template.context_processors.media'\</strong></p><p class="source-code">            ],\</p><p class="source-code">        },\</p><p class="source-code">    },\</p><p class="source-code">]</p><p>The complete file should look like this: <a href="http://packt.live/3nVOpSx">http://packt.live/3nVOpSx</a>.</p></li>
				<li>Open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">views.py</strong> and create a new view called <strong class="source-inline">media_example</strong>. For now, it can just render a template named <strong class="source-inline">media-example.html</strong> (you will create this in <em class="italic">step 5</em>). The entire code of the view function is like this:<p class="source-code">def media_example(request):</p><p class="source-code">    return render(request, "media-example.html")</p><p>Save <strong class="source-inline">views.py</strong>. It should look like this: <a href="http://packt.live/3pvEGCB">http://packt.live/3pvEGCB</a>.</p></li>
				<li>You need a URL mapping to the <strong class="source-inline">media_example</strong> view. Open the <strong class="source-inline">media_project</strong> package's <strong class="source-inline">urls.py</strong> file. <p>First, <strong class="source-inline">import</strong> <strong class="source-inline">media_example.views</strong> with the other imports in the file:</p><p class="source-code">import media_example.views</p><p>Then add a <strong class="source-inline">path</strong> into <strong class="source-inline">urlpatterns</strong> to map <strong class="source-inline">media-example/</strong> to the <strong class="source-inline">media_example</strong> view:</p><p class="source-code">path('media-example/', media_example.views.media_example)</p><p>Your full <strong class="source-inline">urlpatterns</strong> should look like this code block:</p><p class="source-code">from django.conf.urls.static import static</p><p class="source-code"><strong class="bold">import media_example.views</strong></p><p class="source-code">urlpatterns = [<strong class="bold">path('admin/', admin.site.urls),\</strong></p><p class="source-code"><strong class="bold">               path('media-example/', \</strong></p><p class="source-code"><strong class="bold">                    media_example.views.media_example)</strong>]</p><p class="source-code">if settings.DEBUG:</p><p class="source-code">    urlpatterns += static(settings.MEDIA_URL,\</p><p class="source-code">                          document_root=settings.MEDIA_ROOT)</p><p>You can save and close the file.</p></li>
				<li>Create a <strong class="source-inline">templates</strong> directory inside the <strong class="source-inline">media_example</strong> app directory. Then, create a new HTML file inside the <strong class="source-inline">media_project</strong> project's <strong class="source-inline">templates</strong> directory. Select <strong class="source-inline">HTML 5 file</strong> and name the file <strong class="source-inline">media-example.html</strong>:<div id="_idContainer294" class="IMG---Figure"><img src="image/B15509_08_04.jpg" alt="Figure 8.4: Create media-example.html&#13;&#10;"/></div><p class="figure-caption">Figure 8.4: Create media-example.html</p></li>
				<li>The <strong class="source-inline">media-example.html</strong> file should open automatically. You are just going to add a link inside the file to the <strong class="source-inline">test.txt</strong> file you created in <em class="italic">Exercise 8.01</em>, <em class="italic">Configuring Media Storage and Serving</em>. Inside the <strong class="source-inline">&lt;body&gt;</strong> element, add the highlighted code:<p class="source-code">&lt;body&gt;</p><p class="source-code">    <strong class="bold">&lt;a href="{{ MEDIA_URL }}test.txt"&gt;Test Text File&lt;/a&gt;</strong></p><p class="source-code">&lt;/body&gt;</p><p>Note that there is no <strong class="source-inline">/</strong> between <strong class="source-inline">MEDIA_URL</strong> and the filename – this is because we already added a trailing slash when we defined it in <strong class="source-inline">settings.py</strong>. You can save the file. The complete file will look like this: <a href="http://packt.live/3nYTvgF">http://packt.live/3nYTvgF</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then visit <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see a simple page, like in <em class="italic">Figure 8.5</em>:<div id="_idContainer295" class="IMG---Figure"><img src="image/B15509_08_05.jpg" alt="Figure 8.5: Basic media link page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.5: Basic media link page</p>
			<p>If you click the link, you will be taken to the <strong class="source-inline">test.txt</strong> display and see the <strong class="source-inline">Hello, world!</strong> text you created in <em class="italic">Exercise 8.01</em>, <em class="italic">Configuring Media Storage and Serving Media Files</em> (<em class="italic">Figure 8.3</em>). This means you have configured the Django <strong class="source-inline">context_processors</strong> settings correctly.</p>
			<p>We have finished with <strong class="source-inline">test.txt</strong>, so you can delete the file now. We will use the <strong class="source-inline">media_example</strong> view and template in the other exercises, so leave them around. In the next section, we will talk about how to upload files using a web browser, and how Django accesses them in a view.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor251"/>File Uploads Using HTML Forms</h1>
			<p>In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, we learned about HTML forms. We discussed how to use the <strong class="source-inline">method</strong> attribute of <strong class="source-inline">&lt;form&gt;</strong> for <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> requests. Though we have only submitted text data using a form so far, it is also possible to submit one or more files using a form.</p>
			<p>When submitting files, we must ensure that there are at least two attributes on the form: <strong class="source-inline">method</strong> and <strong class="source-inline">enctype</strong>. You may still also need other attributes, such as <strong class="source-inline">action</strong>. A form that supports file uploads might look like this:</p>
			<p class="source-code">&lt;form <strong class="bold">method</strong>="post" <strong class="bold">enctype</strong>="multipart/form-data"&gt;</p>
			<p>File uploads are only available for <strong class="source-inline">POST</strong> requests. They are not possible with <strong class="source-inline">GET</strong> requests as it would be impossible to send all the data for a file through a URL. The <strong class="source-inline">enctype</strong> attribute must be set to let the browser know it should send the form data as multiple parts, one part for the text data of the form, and separate parts for each of the files that have been attached to the form. This encoding is seamless to the user; they do not know how the browser is encoding the form, nor do they need to do anything different.</p>
			<p>To attach files to a form, you need to create an input of type <strong class="source-inline">file</strong>. You can manually write the HTML code, like this:</p>
			<p class="source-code">&lt;input type="file" name="file-upload-name"&gt;</p>
			<p>When the input is rendered in the browser it looks like this when empty:</p>
			<div>
				<div id="_idContainer296" class="IMG---Figure">
					<img src="image/B15509_08_06.jpg" alt="Figure 8.6: Empty file input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Empty file input</p>
			<p>The title of the button might be different depending on your browser.</p>
			<p>Clicking the <strong class="source-inline">Browse…</strong> button will display a <em class="italic">file open</em> dialog box:</p>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="image/B15509_08_07.jpg" alt="Figure 8.7: File browser on macOS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: File browser on macOS</p>
			<p>And after selecting a file, the name of the file is shown in the field:</p>
			<p> </p>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="image/B15509_08_08.jpg" alt="Figure 8.8: File input with cover.jpg selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: File input with cover.jpg selected</p>
			<p><em class="italic">Figure 8.8</em> shows a file input with a file named <strong class="source-inline">cover.jpg</strong> having been selected.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor252"/>Working with Uploaded Files in a View</h2>
			<p>In addition to text data, if a form also contains file uploads, Django will populate the <strong class="source-inline">request.FILES</strong> attribute with these files. <strong class="source-inline">request.FILES</strong> is a dictionary-like object that is keyed on the <strong class="source-inline">name</strong> attribute given to the <strong class="source-inline">file</strong> input.</p>
			<p>In the form example in the previous section, the file input had the name <strong class="source-inline">file-upload-name</strong>. So, the file would be accessible in the view using <strong class="source-inline">request.FILES["file-upload-name"]</strong>.</p>
			<p>The objects that <strong class="source-inline">request.FILES</strong> contains are file-like objects (specifically, a <strong class="source-inline">django.core.files.uploadedfile.UploadedFile</strong> instance), so to use them, you must read their data. For example, to get the content of an uploaded file in your view, you can write:</p>
			<p class="source-code">content = request.FILES["file-upload-name"].read()</p>
			<p>A more common action is to write the file contents to disk. When files are uploaded, they are stored in a temporary location (in memory if they are under 2.5 MB, otherwise in a temporary file on disk). To store the file data in a known location, the contents must be read and then written to disk at the desired location. An <strong class="source-inline">UploadedFile</strong> instance has a <strong class="source-inline">chunks</strong> method that will read the file data one chunk at a time to prevent too much memory from being used by reading the entirety of the file at once.</p>
			<p>So, instead of simply using the <strong class="source-inline">read</strong> and <strong class="source-inline">write</strong> functions, use the <strong class="source-inline">chunks</strong> method to only read small chunks of the file into memory at a time:</p>
			<p class="source-code">with open("/path/to/output.jpg", "wb+") as output_file:</p>
			<p class="source-code">    uploaded_file = request.FILES["file-upload-name"]</p>
			<p class="source-code">    for chunk in uploaded_file.chunks():</p>
			<p class="source-code">        output_file.write(chunk)</p>
			<p>Note that in some of the upcoming examples, we will refer to this code as the <strong class="source-inline">save_file_upload</strong> function. Assume the function is defined like this:</p>
			<p class="source-code">def save_file_upload(upload, save_path):</p>
			<p class="source-code">    with open(save_path, "wb+") as output_file:</p>
			<p class="source-code">        for chunk in upload.chunks():</p>
			<p class="source-code">            output_file.write(chunk)</p>
			<p>The previous example code could then be refactored to call the function:</p>
			<p class="source-code">uploaded_file = request.FILES["file-upload-name"]</p>
			<p class="source-code">save_file_upload(uploaded_file, "/path/to/output.jpg")</p>
			<p>Each <strong class="source-inline">UploadedFile</strong> object (the <strong class="source-inline">uploaded_file</strong> variable in the previous example code snippets) also contains extra metadata about the uploaded file, such as the file's name, size, and content type. The attributes you will find most useful are:</p>
			<ul>
				<li><strong class="source-inline">size</strong>: As the name suggests, this is the size of the uploaded file in bytes.</li>
				<li><strong class="source-inline">name</strong>: This refers to the name of the uploaded file, for example, <strong class="source-inline">image.jpg</strong>, <strong class="source-inline">file.txt</strong>, <strong class="source-inline">document.pdf</strong>, and so on. This value is sent by the browser.</li>
				<li><strong class="source-inline">content_type</strong>: The content type (MIME type) of the uploaded file. For example, <strong class="source-inline">image/jpeg</strong>, <strong class="source-inline">text/plain</strong>, <strong class="source-inline">application/pdf</strong>, and so on. Like <strong class="source-inline">name</strong>, this value is sent by the browser.</li>
				<li><strong class="source-inline">charset</strong>: This refers to the charset or text encoding of the uploaded file, for text files. This will be something like <strong class="source-inline">utf8</strong> or <strong class="source-inline">ascii</strong>. Once again, this value is also determined and sent by the browser.</li>
			</ul>
			<p>Here is a quick example of accessing these attributes (such as inside a view):</p>
			<p class="source-code">upload = request.FILES["file-upload-name"]</p>
			<p class="source-code">size = upload.size</p>
			<p class="source-code">name = upload.name</p>
			<p class="source-code">content_type = upload.content_type</p>
			<p class="source-code">charset = upload.charset</p>
			<h3 id="_idParaDest-238"><a id="_idTextAnchor253"/>Security and Trust of Browsers' Sent Values</h3>
			<p>As we just described, the values of an <strong class="source-inline">UploadedFile</strong> for <strong class="source-inline">name</strong>, <strong class="source-inline">content_type</strong>, and <strong class="source-inline">charset</strong> are determined by the browser. This is important to consider because a malicious user could send fake values in place of real ones to disguise the actual files being uploaded. Django does not automatically try to determine the content type or charset of the uploaded file, and so it relies on the client to be accurate when it sends this information.</p>
			<p>If we manually handle the saving of tile uploads without suitable checks, then a scenario like this could happen:</p>
			<ol>
				<li value="1">A user of the site uploads a malicious executable <strong class="source-inline">malware.exe</strong> but sends the content type <strong class="source-inline">image/jpeg</strong>.</li>
				<li>Our code checks the content type and considers it to be safe, and so saves <strong class="source-inline">malware.exe</strong> to the <strong class="source-inline">MEDIA_ROOT</strong> file.</li>
				<li>Another user of the site downloads what they think is a book cover image but is the <strong class="source-inline">malware.exe</strong> executable. They open the file, and their computer is infected with malware.</li>
			</ol>
			<p>This scenario has been simplified – the malicious file would probably have a name that was not so obvious (maybe something like <strong class="source-inline">cover.jpg.exe</strong>), but the general process has been illustrated.</p>
			<p>How you choose to handle the security of your uploads will depend on the specific use case, but for most cases, these tips will help:</p>
			<ul>
				<li>When you save the file to disk, generate a name instead of using the one provided by the uploader. You should replace the file extension with what you expect. For example, if a file is named <strong class="source-inline">cover.exe</strong> but the content type is <strong class="source-inline">image/jpeg</strong>, save the file as <strong class="source-inline">cover.jpg</strong>. You could also generate a completely random filename for extra security.</li>
				<li>Check that the file name extension matches the content type. This method is not foolproof as there are so many mime types that if you are handling uncommon files you might not get a match. The built-in <strong class="source-inline">mimetypes</strong> Python module can help you here. Its <strong class="source-inline">guess_type</strong> function takes a filename and returns a tuple of <strong class="source-inline">mimetype</strong> (content type) and <strong class="source-inline">encoding</strong>. Here is a short snippet showing its use, in a Python console:<p class="source-code">&gt;&gt;&gt; import mimetypes</p><p class="source-code">&gt;&gt;&gt; mimetypes.guess_type('file.jpg')</p><p class="source-code">('image/jpeg', None)</p><p class="source-code">&gt;&gt;&gt; mimetypes.guess_type('text.html')</p><p class="source-code">('text/html', None)</p><p class="source-code">&gt;&gt;&gt; mimetypes.guess_type('unknownfile.abc')</p><p class="source-code">(None, None)</p><p class="source-code">&gt;&gt;&gt; mimetypes.guess_type('archive.tar.gz')</p><p class="source-code">('application/x-tar', 'gzip')</p><p>Either element of the tuple might be <strong class="source-inline">None</strong> if the type or encoding cannot be guessed. Once it is imported into your file by doing <strong class="source-inline">import mimetypes</strong>, you would use it like this in your view function:</p><p class="source-code">upload = request.FILES["file-upload-name"]</p><p class="source-code">mimetype, encoding = mimetypes.guess_type(upload.name)</p><p class="source-code">if mimetype != upload.content_type:</p><p class="source-code">    raise TypeError("Mimetype doesn't match file extension.")</p><p>This method will work for common file types such as images, but as mentioned, many uncommon types may return <strong class="source-inline">None</strong> for <strong class="source-inline">mimetype</strong>.</p></li>
				<li>If you are expecting image uploads, use the <strong class="source-inline">Pillow</strong> library to try to open the uploaded file as an image. If it is not a valid image, then <strong class="source-inline">Pillow</strong> will be unable to open it. This is what Django does when using its <strong class="source-inline">ImageField</strong> to upload images. We will show how to use this technique to open and manipulate an image in <em class="italic">Exercise 8.05</em>, <em class="italic">Image Uploads using Django Forms</em>.</li>
				<li>You can also consider the <strong class="source-inline">python-magic</strong> Python package, which examines the actual content of files to try to determine their type. It is installable using <strong class="source-inline">pip</strong>, and its GitHub project is <a href="https://github.com/ahupp/python-magic">https://github.com/ahupp/python-magic</a>. Once installed, and imported into your file with <strong class="source-inline">import magic</strong>, you can use it like this in your view function:<p class="source-code">upload = request.FILES["field_name"]</p><p class="source-code">mimetype = magic.from_buffer(upload.read(2048), mime=True)</p></li>
			</ul>
			<p>You could then verify that <strong class="source-inline">mimetype</strong> was in a list of allowed types.</p>
			<p>This is not a definitive list of all the ways of protecting against malicious file uploads. The best approach will depend on what type of application you are building. You might build a site for hosting arbitrary files, in which case you would not need any kind of content checking at all.</p>
			<p>Let us now see how we can build an HTML form and view that will allow files to be uploaded. We will then store them inside the <strong class="source-inline">media</strong> directory and retrieve the downloaded files in our browser.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor254"/>Exercise 8.03: File Upload and Download</h2>
			<p>In this exercise, you will add a form with a file field to the <strong class="source-inline">media-example.html</strong> template. This will allow you to upload a file to the <strong class="source-inline">media_example</strong> view using your browser. You will also update the <strong class="source-inline">media_example</strong> view to save the file to the <strong class="source-inline">MEDIA_ROOT</strong> directory so that it's available for download. You will then test that this all works by downloading the file again:</p>
			<ol>
				<li value="1">In PyCharm, open the <strong class="source-inline">media-example.html</strong> template located inside the <strong class="source-inline">templates</strong> folder. Inside the <strong class="source-inline">&lt;body&gt;</strong> element, remove the <strong class="source-inline">&lt;a&gt;</strong> link that was added in <em class="italic">step 6</em> of <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>. Replace it with a <strong class="source-inline">&lt;form&gt;</strong> element (highlighted here). Make sure the opening tag has <strong class="source-inline">method="post"</strong> and <strong class="source-inline">enctype="multipart/form-data"</strong>:<p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code"><strong class="bold">    &lt;form method="post" enctype="multipart/form-data"&gt;</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">&lt;/form&gt;</strong></p><p class="source-code">&lt;/body&gt;</p></li>
				<li>Insert the <strong class="source-inline">{% csrf_token %}</strong> template tag inside the <strong class="source-inline">&lt;form&gt;</strong> body.</li>
				<li>After <strong class="source-inline">{% csrf_token %}</strong>, add an <strong class="source-inline">&lt;input&gt;</strong> element, with <strong class="source-inline">type="file"</strong> and <strong class="source-inline">name="file_upload"</strong>:<p class="source-code">&lt;input type="file" name="file_upload"&gt;</p></li>
				<li>Finally, before the closing <strong class="source-inline">&lt;/form&gt;</strong> tag, add a <strong class="source-inline">&lt;button&gt;</strong> element with <strong class="source-inline">type="submit"</strong> and the text content <strong class="source-inline">Submit</strong>:<p class="source-code">&lt;button type="submit"&gt;Submit&lt;/button&gt;</p><p>Your HTML body should now look like this:</p><p class="source-code">&lt;body&gt;</p><p class="source-code"><strong class="bold">    &lt;form method="post" enctype="multipart/form-data"&gt;</strong></p><p class="source-code"><strong class="bold">        {% csrf_token %}</strong></p><p class="source-code"><strong class="bold">        &lt;input type="file" name="file_upload"&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;button type="submit"&gt;Submit&lt;/button&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/form&gt;</strong></p><p class="source-code">&lt;/body&gt;</p><p>Now, save and close the file. It should look like this: <a href="http://packt.live/37XJPh3">http://packt.live/37XJPh3</a>.</p></li>
				<li>Open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">views.py</strong>. Inside the <strong class="source-inline">media_example</strong> view, add code to save the uploaded file to the <strong class="source-inline">MEDIA_ROOT</strong> directory. For this, you need access to <strong class="source-inline">MEDIA_ROOT</strong> from settings, so import the Django settings at the top of the file:<p class="source-code">from django.conf import settings</p><p>You will also need to use the <strong class="source-inline">os</strong> module to build the save path, so import that as well (also at the top of the file):</p><p class="source-code">import os</p></li>
				<li>The uploaded file should only be saved if the request method is <strong class="source-inline">POST</strong>. Inside the <strong class="source-inline">media_example</strong> view, add an <strong class="source-inline">if</strong> statement to validate that <strong class="source-inline">request.method</strong> is <strong class="source-inline">POST</strong>:<p class="source-code">def media_example(request):</p><p class="source-code">    if request.method == 'POST':</p><p class="source-code">        …</p></li>
				<li>Inside the <strong class="source-inline">if</strong> statement added in the previous step, generate the output path by joining the uploaded filename to <strong class="source-inline">MEDIA_ROOT</strong>. Then, open this path in <strong class="source-inline">wb</strong> mode and iterate over the uploaded file using the <strong class="source-inline">chunks</strong> method. Finally, write each chunk to the saved file:<p class="source-code">def media_example(request):</p><p class="source-code">    if request.method == 'POST':</p><p class="source-code"><strong class="bold">        save_path = os.path.join\</strong></p><p class="source-code"><strong class="bold">                    (settings.MEDIA_ROOT, \</strong></p><p class="source-code"><strong class="bold">                     request.FILES["file_upload"].name)</strong></p><p class="source-code"><strong class="bold">        with open(save_path, "wb") as output_file:</strong></p><p class="source-code"><strong class="bold">            for chunk in request.FILES["file_upload"].chunks():</strong></p><p class="source-code"><strong class="bold">                output_file.write(chunk)</strong></p><p class="source-code"><strong class="bold">    return render(request, "media-example.html")</strong></p><p>Note that the uploaded file and its metadata are being accessed from the <strong class="source-inline">request.FILES</strong> dictionary, using the key that matches the name given to the file input (in our case, this is <strong class="source-inline">file_upload</strong>). You can save and close <strong class="source-inline">views.py</strong>. It should now look like this: </p><p><a href="http://packt.live/37TwxSr">http://packt.live/37TwxSr</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see the file upload field and <strong class="source-inline">Submit</strong> button, as can be seen here:<div id="_idContainer299" class="IMG---Figure"><img src="image/B15509_08_09.jpg" alt="Figure 8.9: File upload form&#13;&#10;"/></div><p class="figure-caption">Figure 8.9: File upload form</p><p>Click <strong class="source-inline">Browse…</strong> (or the equivalent in your browser) and select a file to upload. The name of the file will appear in the file input. Then, click <strong class="source-inline">Submit</strong>. The page will reload, and the form will be empty again. This is normal – in the background, the file should have been saved.</p></li>
				<li>Try to download the file you uploaded using <strong class="source-inline">MEDIA_URL</strong>. In this example, a file named <strong class="source-inline">cover.jpg</strong> was uploaded. It will be downloadable at <strong class="source-inline">http://127.0.0.1:8000/media/cover.jpg</strong>. Your URL will depend on the name of the file you uploaded.<div id="_idContainer300" class="IMG---Figure"><img src="image/B15509_08_10.jpg" alt="Figure 8.10: Uploaded file visible inside MEDIA_URL&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 8.10: Uploaded file visible inside MEDIA_URL</p>
			<p>If you uploaded an image file, HTML file, or another type of file your browser can display, you will be able to view it inside the browser. Otherwise, your browser will just download it to disk again. In both cases, it means the upload was successful.</p>
			<p>You can also confirm the upload was successful by looking inside the <strong class="source-inline">media</strong> directory in the <strong class="source-inline">media_project</strong> project directory:</p>
			<p> </p>
			<div>
				<div id="_idContainer301" class="IMG---Figure">
					<img src="image/B15509_08_11.jpg" alt="Figure 8.11: cover.jpg inside the media directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: cover.jpg inside the media directory</p>
			<p><em class="italic">Figure 8.11</em> shows <strong class="source-inline">cover.jpg</strong> inside the <strong class="source-inline">media</strong> directory in PyCharm.</p>
			<p>In this exercise, you added an HTML form with <strong class="source-inline">enctype</strong> set to <strong class="source-inline">multipart/form-data</strong> so that it would allow file uploads. It contained a <strong class="source-inline">file</strong> input to select a file to upload. You then added saving functionality to the <strong class="source-inline">media_example</strong> view to save the uploaded file to disk.</p>
			<p>In the next section, we will look at how to simplify form generation and add validation using Django forms.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor255"/>File Uploads with Django Forms</h2>
			<p>In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, we saw how Django makes it easy to define forms and automatically render them to HTML. In the previous example, we defined our form manually and wrote the HTML. We can replace this with a Django form, and implement the file input with a <strong class="source-inline">FileField</strong> constructor.</p>
			<p>Here is how a <strong class="source-inline">FileField</strong> is defined on a form:</p>
			<p class="source-code">from django import forms</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    file_upload = forms.FileField()</p>
			<p>The <strong class="source-inline">FileField</strong> constructor can take the following keyword arguments:</p>
			<ul>
				<li><strong class="source-inline">required</strong>: This should be <strong class="source-inline">True</strong> for required fields and <strong class="source-inline">False</strong> if the field is optional.</li>
				<li><strong class="source-inline">max_length</strong>: This refers to the maximum length of the filename of the file being uploaded.</li>
				<li><strong class="source-inline">allow_empty_file</strong>: A field with this argument is valid even if the uploaded file is empty (has a size of <strong class="source-inline">0</strong>).</li>
			</ul>
			<p>Apart from these three keyword arguments, the constructor can also accept the standard <strong class="source-inline">Field</strong> arguments, such as <strong class="source-inline">widget</strong>. The default widget class for a <strong class="source-inline">FileField</strong> is <strong class="source-inline">ClearableFileInput</strong>. This is a file input that can display a checkbox that can be checked to send a null value and clear the saved file on a model field.</p>
			<p>Using a form with a <strong class="source-inline">FileField</strong> in a view is similar to other forms, but when the form has been submitted (that is, <strong class="source-inline">request.METHOD</strong> is <strong class="source-inline">POST</strong>), then <strong class="source-inline">request.FILES</strong> should be passed into the form constructor as well. This is because Django needs to access <strong class="source-inline">request.FILES</strong> to find information about uploaded files when validating the form.</p>
			<p>The basic flow in a <strong class="source-inline">view</strong> function is therefore like this:</p>
			<p class="source-code">def view(request):</p>
			<p class="source-code">    if request.method == "POST":</p>
			<p class="source-code">        # instantiate the form with POST data and files</p>
			<p class="source-code">        form = ExampleForm(request.POST, request.FILES)</p>
			<p class="source-code">        if form.is_valid():</p>
			<p class="source-code">            # process the form and save files</p>
			<p class="source-code">            return redirect("success-url")</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        # instantiate an empty form as we've seen before</p>
			<p class="source-code">        form = ExampleForm()</p>
			<p class="source-code">    # render a template, the same as for other forms</p>
			<p class="source-code">    return render(request, "template.html", {"form": form})</p>
			<p>When working with uploaded files and forms, you can interact with the uploaded files by accessing them through <strong class="source-inline">request.FILES</strong>, or through <strong class="source-inline">form.cleaned_data</strong>: the values will return to the same object. In our above example, we could process the uploaded file like this:</p>
			<p class="source-code">if form.is_valid():</p>
			<p class="source-code">    save_file_upload("/path/to/save.jpg", \</p>
			<p class="source-code">                     request.FILES["file_upload"])</p>
			<p class="source-code">    return redirect("/success-url/")</p>
			<p>Or, since they contain the same object, you can use <strong class="source-inline">form.cleaned_data</strong>:</p>
			<p class="source-code">if form.is_valid():</p>
			<p class="source-code">    save_file_upload("/path/to/save.jpg", \</p>
			<p class="source-code">                     form.cleaned_data["file_upload"])</p>
			<p class="source-code">    return redirect("/success-url/")</p>
			<p>The data that is saved will be the same.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, you experimented with forms and submitting them with invalid values. When the page refreshed to show the form errors, the data that you had previously entered was populated when the page reloaded. This does not occur with file fields; instead, the user will have to navigate and select the file again if the form is invalid.</p>
			<p>In the next exercise, we will put what we have seen with <strong class="source-inline">FileFields</strong> into practice by building an example form, then modifying our view to save the file only if the form is valid.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor256"/>Exercise 8.04: File Uploads with a Django Form</h2>
			<p>In the previous exercise, you created a form in HTML and used it to upload a file to a Django view. If you tried submitting the form without selecting a file, you would get a Django exception screen. You did not do any validation on the form, so this method is quite fragile.</p>
			<p>In this exercise, you will create a Django form with a <strong class="source-inline">FileFIeld</strong>, which will allow you to use form validation functions to make the view more robust as well to reduce the amount of code:</p>
			<ol>
				<li value="1">In PyCharm, inside the <strong class="source-inline">media_example</strong> app, create a new file named <strong class="source-inline">forms.py</strong>. It will open automatically. At the start of the file, import the Django <strong class="source-inline">forms</strong> library:<p class="source-code">from django import forms</p><p>Then, create a <strong class="source-inline">forms.Form</strong> subclass, and name it <strong class="source-inline">UploadForm</strong>. Add one field to it, a <strong class="source-inline">FileField</strong> named <strong class="source-inline">file_upload</strong>. Your class should have this code:</p><p class="source-code">class UploadForm(forms.Form):</p><p class="source-code">    file_upload = forms.FileField()</p><p>You can save and close this file. The complete file should look like this: <a href="http://packt.live/34S5hBV">http://packt.live/34S5hBV</a>. </p></li>
				<li>Open the <strong class="source-inline">form_example</strong> app's <strong class="source-inline">views.py</strong> file. At the start of the file, right below the existing <strong class="source-inline">import</strong> statements, you will need to import your new class, like this: <p class="source-code">from .forms import UploadForm</p></li>
				<li>If you are in the <strong class="source-inline">POST</strong> branch of the view, <strong class="source-inline">UploadForm</strong> needs to be instantiated with both <strong class="source-inline">request.POST</strong> and <strong class="source-inline">request.FILES</strong>. If you do not pass in <strong class="source-inline">request.FILES</strong>, then the <strong class="source-inline">form</strong> instance will not be able to access the uploaded files. Under the <strong class="source-inline">if request.method == "POST"</strong> check, instantiate the <strong class="source-inline">UploadForm</strong> with these two arguments:<p class="source-code">form = UploadForm(request.POST, request.FILES)</p></li>
				<li>The existing lines that define the <strong class="source-inline">save_path</strong> and store the file contents can be retained, but they should be indented by one block and put inside a form validity check, so they are only executed if the form is valid. Add the <strong class="source-inline">if form.is_valid():</strong> line and then indent the other lines so the code looks like this:<p class="source-code">if form.is_valid():</p><p class="source-code">    save_path = os.path.join\</p><p class="source-code">                (settings.MEDIA_ROOT, \</p><p class="source-code">                 request.FILES["file_upload"].name)</p><p class="source-code">    with open(save_path, "wb") as output_file:</p><p class="source-code">        for chunk in request.FILES["file_upload"].chunks():</p><p class="source-code">            output_file.write(chunk)</p></li>
				<li>Since you are using a form now, you can access the file upload through the form. Replace usages of <strong class="source-inline">request.FILES["file_upload"]</strong> with <strong class="source-inline">form.cleaned_data["file_upload"]</strong>:<p class="source-code">if form.is_valid():</p><p class="source-code">    save_path = os.path.join\</p><p class="source-code">                (settings.MEDIA_ROOT,\</p><p class="source-code">                 form.cleaned_data["file_upload"].name)</p><p class="source-code">    with open(save_path, "wb") as output_file:</p><p class="source-code">        for chunk in <strong class="bold">form.cleaned_data["file_upload"].chunks():</strong></p><p class="source-code">            output_file.write(chunk)</p></li>
				<li>Finally, add an <strong class="source-inline">else</strong> branch to handle non-<strong class="source-inline">POST</strong> requests, which simply instantiates a form without any arguments:<p class="source-code">if request.method == 'POST':</p><p class="source-code">    …</p><p class="source-code">else:</p><p class="source-code">    form = UploadForm()</p></li>
				<li>Add a context dictionary argument to the <strong class="source-inline">render</strong> call and set the <strong class="source-inline">form</strong> variable in the <strong class="source-inline">form</strong> key:<p class="source-code">return render(request, "media-example.html", \</p><p class="source-code">              {"form": form})</p><p>You can now save and close this file. It should look like this: <a href="http://packt.live/3psXxyc">http://packt.live/3psXxyc</a>. </p></li>
				<li>Finally, open the <strong class="source-inline">media-example.html</strong> template and remove your manually defined file <strong class="source-inline">&lt;input&gt;</strong>. Replace it with <strong class="source-inline">form</strong>, rendered using the <strong class="source-inline">as_p</strong> method (highlighted):<p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;form method="post" enctype="multipart/form-data"&gt;</p><p class="source-code">        {% csrf_token %}</p><p class="source-code">        <strong class="bold">{{ form.as_p }}</strong></p><p class="source-code">        &lt;button type="submit"&gt;Submit&lt;/button&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">&lt;/body&gt;</p><p>You should not change any other parts of the file. You can save and close this file. It should look like this: <a href="http://packt.live/3qHHSMi">http://packt.live/3qHHSMi</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see the <strong class="source-inline">File upload</strong> field and the <strong class="source-inline">Submit</strong> button, as follows:<div id="_idContainer302" class="IMG---Figure"><img src="image/B15509_08_12.jpg" alt="Figure 8.12: File upload Django form rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.12: File upload Django form rendered in the browser</p></li>
				<li>Since we are using a Django form, we get its built-in validation automatically. If you try to submit the form without selecting a file, your browser should prevent you and show an error, as can be seen here:<div id="_idContainer303" class="IMG---Figure"><img src="image/B15509_08_13.jpg" alt="Figure 8.13: Form submission prevented by the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.13: Form submission prevented by the browser</p></li>
				<li>Finally, repeat the upload test that you performed in <em class="italic">Exercise 8.03</em>, <em class="italic">File Upload and Download</em>, by selecting a file and submitting the form. You should then be able to retrieve the file using <strong class="source-inline">MEDIA_URL</strong>. In this case, a file named <strong class="source-inline">cover.jpg</strong> is being uploaded again (see the following figure):<p> </p><div id="_idContainer304" class="IMG---Figure"><img src="image/B15509_08_14.jpg" alt="Figure 8.14: Uploading a file named cover.jpg&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.14: Uploading a file named cover.jpg</p>
			<p>You can then retrieve the file at <strong class="source-inline">http://127.0.0.1:8000/media/cover.jpg</strong>, and you can see it in the browser as follows:</p>
			<p> </p>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="image/B15509_08_15.jpg" alt="Figure 8.15: The file uploaded using a Django form is also visible in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: The file uploaded using a Django form is also visible in the browser</p>
			<p>In this exercise, we replaced a manually built form with a Django form containing a <strong class="source-inline">FileField</strong>. We instantiated the form in the view by passing in both <strong class="source-inline">request.POST</strong> and <strong class="source-inline">request.FILES</strong>. We then used the standard <strong class="source-inline">is_valid</strong> method to check the validity of the form, and only saved the file upload if the form was valid. We tested the file uploading and saw we were able to retrieve uploaded files using <strong class="source-inline">MEDIA_URL</strong>.</p>
			<p>In the next section, we will look at <strong class="source-inline">ImageField</strong>, which is like a <strong class="source-inline">FileField</strong> but specifically for images.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor257"/>Image Uploads with Django Forms</h2>
			<p>If you want to work with images in Python, the most common library that you will use is called <strong class="bold">Pillow</strong>. This is the library that Django uses to validate images. Originally, there was a library called <strong class="bold">Python Imaging Library</strong>, or <strong class="bold">PIL</strong>. It was not kept up to date and, eventually, a fork of the library was created and is still maintained – this is Pillow. To maintain backward compatibility, the package is still called PIL when installed. For example, the <strong class="source-inline">Image</strong> object is imported from PIL:</p>
			<p class="source-code">from PIL import Image</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The terms Python Imaging Library, PIL, and Pillow are often used interchangeably. You can assume that if someone refers to PIL, they mean the latest Pillow library.</p>
			<p>Pillow provides various methods of retrieving data about or manipulating images. You can find out the width and height of images, or scale, crop, and apply transformations to them. There are too many operations available to cover in this chapter, so we will just introduce a simple example (scaling an image), which you will use in the next exercise. </p>
			<p>Since images are one of the most common types of files that a user may want to upload, Django also includes an <strong class="source-inline">ImageField</strong> instance. This behaves similarly to <strong class="source-inline">FileField</strong> instance but also automatically validates that the data is an image file. This helps mitigate security issues where we expect an image, but the user uploads a malicious file.</p>
			<p>An <strong class="source-inline">UploadedFile</strong> from an <strong class="source-inline">ImageField</strong> has all the same attributes and methods as that of a <strong class="source-inline">FileField</strong> (<strong class="source-inline">size</strong>, <strong class="source-inline">content_type</strong>, <strong class="source-inline">name</strong>, <strong class="source-inline">chunks()</strong>, and so on) but adds an extra attribute: <strong class="source-inline">image</strong>. This is an instance of the PIL <strong class="source-inline">Image</strong> object that is used to verify that the file being uploaded is a valid image. </p>
			<p>After checking that the form is valid, the underlying PIL <strong class="source-inline">Image</strong> object is closed. This is to free up memory and prevent the Python process from holding too many files open, which could cause performance issues. What this means for the developer is that you can access some of the metadata about the image (such as its <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, and <strong class="source-inline">format</strong>) but you can't access the actual image data without re-opening the image.</p>
			<p>To illustrate, we will have a form with an <strong class="source-inline">ImageField</strong>, named <strong class="source-inline">picture</strong>:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    picture = ImageField()</p>
			<p>Inside the view function, the <strong class="source-inline">picture</strong> field can be accessed in the form's <strong class="source-inline">cleaned_data</strong>:</p>
			<p class="source-code">if form.is_valid():</p>
			<p class="source-code">    picture_field = form.cleaned_data["picture"]</p>
			<p>Then, the <strong class="source-inline">picture</strong> field's <strong class="source-inline">Image</strong> object can be retrieved:</p>
			<p class="source-code">image = picture_field.image</p>
			<p>Now that we have a reference to the image in the view, we can get some metadata:</p>
			<p class="source-code">w = image.width  # an integer, e.g. 600</p>
			<p class="source-code">h = image.height  # also an integer, e.g. 420</p>
			<p class="source-code"># the format of the image as a string, e.g. "PNG"</p>
			<p class="source-code">f = image.format</p>
			<p>Django will also automatically update the <strong class="source-inline">content_type</strong> attribute of <strong class="source-inline">UploadedFile</strong> to the correct type for the <strong class="source-inline">picture</strong> field. This overwrites the value that the browser sent when uploading the file.</p>
			<p>Attempting to use a method that accesses the actual image data (rather than just the metadata) will cause an exception to be raised. This is because Django has already closed the underlying image file.</p>
			<p>For example, the following code snippet will raise an <strong class="source-inline">AttributeError</strong>:</p>
			<p class="source-code">image.getdata()</p>
			<p>Instead, we need to re-open the image. The image data can be opened with the <strong class="source-inline">ImageField</strong> reference, after importing the <strong class="source-inline">Image</strong> class:</p>
			<p class="source-code">from PIL import Image</p>
			<p class="source-code">image = Image.open(picture_field)</p>
			<p>Now that the image has been opened, you can perform operations on it. In the next section, we will look at a simple example – resizing the uploaded image.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor258"/>Resizing an Image with Pillow</h2>
			<p>Pillow supports many operations that you might want to perform on an image before saving it. We cannot explain them all in this book, so we will just use a common operation: resizing an image to a specific size before saving it. This will help us save storage space and improve the download speed. For example, a user may upload large cover images in Bookr that are bigger than are needed for our purposes. When saving the file (writing it back to disk) we must specify the format to use. We could determine the type of image that was uploading with a number of methods (such as checking the <strong class="source-inline">content_type</strong> of the uploaded file or the <strong class="source-inline">format</strong> from the <strong class="source-inline">Image</strong> object), but in our example, we will always just save the image as a <strong class="source-inline">JPEG</strong> file.</p>
			<p>The PIL <strong class="source-inline">Image</strong> class has a <strong class="source-inline">thumbnail</strong> method that will resize an image to a maximum size while retaining the aspect ratio. For example, we could set a maximum size of 50px by 50px. A 200px by 100px image would be resized to 50px by 25px: the aspect ratio is retained by setting the maximum dimension to 50px. Each dimension is scaled by a factor of 0.25:</p>
			<p class="source-code">from PIL import Image</p>
			<p class="source-code">size = 50, 50  # a tuple of width, height to resize to</p>
			<p class="source-code">image = Image.open(image_field)  # open the image as before</p>
			<p class="source-code">image.thumbnail(size)  # perform the resize</p>
			<p>At this point, the resize has been done in memory only. The change is not saved to disk until the <strong class="source-inline">save</strong> method is called, like so:</p>
			<p class="source-code">image.save("path/to/file.jpg")</p>
			<p>The output format is automatically determined from the file extension used, in this case, JPEG. The <strong class="source-inline">save</strong> method can also take a format argument to override it. For example:</p>
			<p class="source-code">image.save("path/to/file.png", "JPEG")</p>
			<p>Despite having the extension <strong class="source-inline">png</strong>, the format is specified as <strong class="source-inline">JPEG</strong> and so the output will be in JPEG format. As you might imagine, this can be very confusing, so you might decide to stick with specifying the extension only.</p>
			<p>In the next exercise, we will change the <strong class="source-inline">UploadForm</strong> we have been working with to use an <strong class="source-inline">ImageField</strong> instead of a <strong class="source-inline">FileField</strong>, then implement the resizing of an uploaded image before saving it to the media directory.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor259"/>Exercise 8.05: Image Uploads using Django Forms</h2>
			<p>In this exercise, you will update the <strong class="source-inline">UploadForm</strong> class you created in <em class="italic">Exercise 8.04</em>, <em class="italic">File Uploads with a Django Form</em>, to use an <strong class="source-inline">ImageField</strong> instead of a <strong class="source-inline">FileField</strong> (this will involve simply changing the field's class). You will then see that the form renders it in the browser. Next, you will try uploading some non-image files and see how Django validates the form to disallow them. Finally, you will update your view to use PIL to resize the image before saving it, and then test it in action:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">forms.py</strong> file. In the <strong class="source-inline">UploadForm</strong> class, change <strong class="source-inline">file_upload</strong> so it's an instance of <strong class="source-inline">ImageField</strong> instead of <strong class="source-inline">FileField</strong>. After updating, your <strong class="source-inline">UploadForm</strong> should look like this:<p class="source-code">class UploadForm(forms.Form):</p><p class="source-code">    file_upload = forms.<strong class="bold">ImageField</strong>()</p><p>Save and close the file. Your <strong class="source-inline">forms.py</strong> file should look like this: <a href="http://packt.live/2KAootD">http://packt.live/2KAootD</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see the form rendered, and it will look identical as to when we used a <strong class="source-inline">FileField</strong> (see the following figure):<div id="_idContainer306" class="IMG---Figure"><img src="image/B15509_08_16.jpg" alt="Figure 8.16: The ImageField looks the same as a FileField&#13;&#10;"/></div><p class="figure-caption">Figure 8.16: The ImageField looks the same as a FileField</p></li>
				<li>You will notice the difference when you try to upload a non-image file. Click the <strong class="source-inline">Browse…</strong> button and try to select a non-image file. Depending on your browser or operating system, you might not be able to select anything other than an image file, as in <em class="italic">Figure 8.17</em>:<p> </p><div id="_idContainer307" class="IMG---Figure"><img src="image/B15509_08_17.jpg" alt="Figure 8.17: Only image files are selectable&#13;&#10;"/></div><p class="figure-caption">Figure 8.17: Only image files are selectable</p><p>Your browser may allow selecting an image but show an error in the form after selection. Or your browser may allow you to select a file and submit the form, and Django will raise a <strong class="source-inline">ValidationError</strong>. Regardless, you can be sure that in your view, the form's <strong class="source-inline">is_valid</strong> view will only return <strong class="source-inline">True</strong> if an image has been uploaded.</p><p class="callout-heading">Note</p><p class="callout">You do not need to test uploading a file at this point, as the result would be the same as in <em class="italic">Exercise 8.04</em>, <em class="italic">File Uploads with a Django Form</em>.</p></li>
				<li>The first thing you will need to do is to make sure the Pillow library is installed. In a terminal (making sure your virtual environment has been activated), run:<p class="source-code">pip3 install pillow</p><p>(In Windows, this is <strong class="source-inline">pip install pillow</strong>.) You will get output like <em class="italic">Figure 8.18</em>:</p><div id="_idContainer308" class="IMG---Figure"><img src="image/B15509_08_18.jpg" alt="Figure 8.18: pip3 installing Pillow&#13;&#10;"/></div><p class="figure-caption">Figure 8.18: pip3 installing Pillow</p><p>Or if Pillow was already installed, you will see the output message <strong class="source-inline">Requirement already satisfied</strong>.</p></li>
				<li>Now we can update the <strong class="source-inline">media_example</strong> view to resize the image before saving it. Switch back to PyCharm and open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">views.py</strong> file, then import PIL's <strong class="source-inline">Image</strong> class. So, add this import line below the <strong class="source-inline">import os</strong> statement near the top of the file:<p class="source-code">from PIL import Image</p></li>
				<li>Go to the <strong class="source-inline">media_example</strong> view. Under the line that generates the <strong class="source-inline">save_path</strong>, take out the three lines that open the output file, iterate over the uploaded file, and write out its chunks. Replace this with the code that opens the uploaded file with PIL, resizes it, then saves it:<p class="source-code">image = Image.open(form.cleaned_data["file_upload"])</p><p class="source-code">image.thumbnail((50, 50))</p><p class="source-code">image.save(save_path)</p><p>The first line creates an <strong class="source-inline">Image</strong> instance by opening the uploaded file, the next performs the thumbnail conversion (to a maximum size of 50px by 50px), and the third line saves the file to the same save path that we have been generating in previous exercises. You can save the file. It should look like this: <a href="http://packt.live/34PWvof">http://packt.live/34PWvof</a>. </p></li>
				<li>The Django dev server should still be running from <em class="italic">step 2</em>, but you should start it if it is not. Then, navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You will see the familiar <strong class="source-inline">UploadForm</strong>. Select an image and submit the form. If the upload and resize was successful, the form will refresh and be empty again.</li>
				<li>View the uploaded image using <strong class="source-inline">MEDIA_URL</strong>. For example, a file named <strong class="source-inline">cover.jpg</strong> will be downloadable from <strong class="source-inline">http://127.0.0.1:8000/media/cover.jpg</strong>. You should see the image has been resized to have a maximum dimension of just 50px:<p> </p><div id="_idContainer309" class="IMG---Figure"><img src="image/B15509_08_19.jpg" alt="Figure 8.19: Resized logo&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.19: Resized logo</p>
			<p>While a thumbnail this size might not be that useful, it at least lets us be sure that the image resize has worked correctly.</p>
			<p>In this exercise, we changed the <strong class="source-inline">FileField</strong> on <strong class="source-inline">UploadForm</strong> to an <strong class="source-inline">ImageField</strong>. We saw that the browser wouldn't let us upload anything other than images. We then added code to the <strong class="source-inline">media_example</strong> view to resize the uploaded image using PIL.</p>
			<p>We have encouraged the use of a separate web server to serve static and media files, for performance reasons. However, in some cases, you might want to use Django to serve files, for example, to provide authentication before allowing access. In the next section, we will discuss how to use Django to serve media files.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor260"/>Serving Uploaded (and Other) Files Using Django</h2>
			<p>Throughout this chapter and <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, we have discouraged serving files using Django. This is because it would needlessly tie up a Python process just serving a file – something that the web server is capable of handling. Unfortunately, web servers do not usually provide dynamic access control, that is, allowing only authenticated users to download a file. Depending on your web server used in production, you might be able to have it authenticate against Django and then serve the file itself; however, the specific configuration of specific web servers is outside the scope of this book.</p>
			<p>One approach you can take is to specify a subdirectory of your <strong class="source-inline">MEDIA_ROOT</strong> directory and have your web server prevent access to just this specific folder. Any protected media should be stored inside it. If you do this, only Django will be able to read the files inside. For example, your web server could serve everything in the <strong class="source-inline">MEDIA_ROOT</strong> directory, except for a <strong class="source-inline">MEDIA_ROOT/protected</strong> directory.</p>
			<p>Another approach would be to configure a Django view to serve a specific file from disk. The view will determine the path of the file on disk to send, then send it using the <strong class="source-inline">FileResponse</strong> class. The <strong class="source-inline">FileResponse</strong> class takes an open filehandle as an argument and tries to determine the correct content type from the file's content. Django will close the filehandle after the request completes.</p>
			<p>The view function will accept the request and a relative path to the file to be downloaded, as parameters. This relative path is the path inside the <strong class="source-inline">MEDIA_ROOT/protected</strong> folder.</p>
			<p>In our case, we will just check whether the user is anonymous (not logged in). We will do this by checking the <strong class="source-inline">request.user.is_anonymous</strong> property. If they are not logged in then we will raise a <strong class="source-inline">django.core.exceptions.PermissionDenied</strong> exception, which returns an HTTP <strong class="source-inline">403 Forbidden</strong> response to the browser. This will stop the execution of the view and not return any file:</p>
			<p class="source-code">import os.path</p>
			<p class="source-code">from django.conf import settings</p>
			<p class="source-code">from django.http import FileResponse</p>
			<p class="source-code">from django.core.exceptions import PermissionDenied</p>
			<p class="source-code">def download_view(request, relative_path):</p>
			<p class="source-code">    if request.user.is_anonymous:</p>
			<p class="source-code">        raise PermissionDenied</p>
			<p class="source-code">    full_path = os.path.join(settings.MEDIA_ROOT, \</p>
			<p class="source-code">                             "protected", relative_path)</p>
			<p class="source-code">    file_handle = open(full_path, "rb")</p>
			<p class="source-code">    return FileResponse(file_handle)</p>
			<p class="source-code"># Django sends the file then closes the handle</p>
			<p>The URL mapping to this view could be like this, using the <strong class="source-inline">&lt;path&gt;</strong> path converter. Inside your <strong class="source-inline">urls.py</strong> file:</p>
			<p class="source-code">urlpatterns = [</p>
			<p class="source-code">    …</p>
			<p class="source-code">    path("downloads/&lt;path:relative_path&gt;", views.download_view)]</p>
			<p>There are many ways that you could choose to implement a view that sends files. The important thing is that you use the <strong class="source-inline">FileResponse</strong> class, which is designed to stream the file to the client in chunks instead of loading it all into memory. This will reduce the load on the server and lessen the impact on resource usage if you have to resort to sending files with Django.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor261"/>Storing Files on Model Instances</h1>
			<p>So far, we have manually managed the uploading and saving of files. You can also associate a file with a model instance by assigning the path to which it was saved to a <strong class="source-inline">CharField</strong>. However, as with much of Django, this capability (and more) is already provided with the <strong class="source-inline">models.FileField</strong> class. <strong class="source-inline">FileField</strong> instances do not actually store the file data; instead, they store the path where the file is stored (like a <strong class="source-inline">CharField</strong> would), but they also provide helper methods. These methods assist with loading files (so you do not have to manually open them) and generating disk paths for you based on the ID of the instance (or other attributes).</p>
			<p><strong class="source-inline">FileField</strong> can accept two specific optional arguments in its constructor (as well as the base <strong class="source-inline">Field</strong> arguments, such as <strong class="source-inline">required</strong>, <strong class="source-inline">unique</strong>, <strong class="source-inline">help_text</strong>, and so on):</p>
			<ul>
				<li><strong class="source-inline">max_length</strong>: Like <strong class="source-inline">max_length</strong> in the form's <strong class="source-inline">ImageField</strong>, this is the maximum length of the filename that is allowed.</li>
				<li><strong class="source-inline">upload_to</strong>: The <strong class="source-inline">upload_to</strong> argument has three different behaviors depending on what type of variable is passed to it. Its simplest use is with a string or <strong class="source-inline">pathlib.Path</strong> object. The path is simply appended to <strong class="source-inline">MEDIA_ROOT</strong>. </li>
			</ul>
			<p>In this example, <strong class="source-inline">upload_to</strong> is just defined as a string:</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    file_field = models.FileField(upload_to="files/")</p>
			<p>Files saved to this <strong class="source-inline">FileField</strong> would be stored in the <strong class="source-inline">MEDIA_ROOT/files</strong> directory.</p>
			<p>You could achieve the same result using a <strong class="source-inline">pathlib.Path</strong> instance too:</p>
			<p class="source-code">import pathlib</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    file_field = models.FileField(upload_to=pathlib.Path("files/"))</p>
			<p>The next way of using <strong class="source-inline">upload_to</strong> is with a string that contains <strong class="source-inline">strftime</strong> formatting directives (for example, <strong class="source-inline">%Y</strong> to substitute the current year, <strong class="source-inline">%m</strong> for the current month, and <strong class="source-inline">%d</strong> for the current day of the month). The full list of these directives is extensive and can be found at <a href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a>. Django will automatically interpolate these values when saving the file.</p>
			<p>For example, say you defined the model and <strong class="source-inline">FileField</strong> like this:</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    file_field = models.FileField(upload_to="files/%Y/%m/%d/")</p>
			<p>For the first file uploaded on a specific day, Django would create the directory structure for that day. For example, for the first file uploaded on January 1, 2020, Django would create the directory <strong class="source-inline">MEDIA_ROOT/2020/01/01</strong> and then store the uploaded file in there. The next file (and all subsequent ones) uploaded on the same day would also be stored in that directory. Similarly, on January 2, 2020, Django would create the <strong class="source-inline">MEDIA_ROOT/2020/01/02</strong> directory, and files would be stored there.</p>
			<p>If you have many thousands of files being uploaded every day, you could even have the files split up further by including the hour and minute in the <strong class="source-inline">upload_to</strong> argument (<strong class="source-inline">upload_to="files/%Y/%m/%d/%H/%M/"</strong>). This may not be necessary if you only have a small volume of uploads though.</p>
			<p>By utilizing this method of the <strong class="source-inline">upload_to</strong> argument, you can have Django automatically segregate uploads and prevent too many files from being stored within a single directory (which can be hard to manage). </p>
			<p>The final method of using <strong class="source-inline">upload_to</strong> is by passing a function that will be called to generate the storage path. Note that this is different than the other uses of <strong class="source-inline">upload_to</strong> as it should generate the full path, including filename, rather than just the directory. The function takes two arguments: <strong class="source-inline">instance</strong> and <strong class="source-inline">filename</strong>. <strong class="source-inline">instance</strong> is the model instance that the <strong class="source-inline">FileField</strong> is attached to, and <strong class="source-inline">filename</strong> is the name of the uploaded file.</p>
			<p>Here is an example function that takes the first two characters of a filename to generate the saved directory. This will mean that each uploaded file will be grouped into parent directories, which can help organize files and prevent there from being too many in one directory:</p>
			<p class="source-code">def user_grouped_file_path(instance, filename):</p>
			<p class="source-code">    return "{}/{}/{}/{}".format(instance.username, \</p>
			<p class="source-code">                                filename[0].lower(), \</p>
			<p class="source-code">                                filename[1].lower(), filename)</p>
			<p>If this function is called with the filename <strong class="source-inline">Test.jpg</strong>, it will return <strong class="source-inline">&lt;username&gt;/t/e/Test.jpg</strong>. If called with <strong class="source-inline">example.txt</strong>, it will return <strong class="source-inline">&lt;username&gt;e/x/example.txt</strong>, and so on. <strong class="source-inline">username</strong> is retrieved from the instance that is being saved. To illustrate, here is a model with a <strong class="source-inline">FileField</strong> that uses this function. It also has a username, which is a <strong class="source-inline">CharField</strong>:</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    file_field = models.FileField\</p>
			<p class="source-code">                 (upload_to=user_grouped_file_path)</p>
			<p class="source-code">    username = models.CharField(unique=True)</p>
			<p>You can use any attribute of the instance in the <strong class="source-inline">upload_to</strong> function, but be aware that if this instance is in the process of being created, then the file save function will be called before it is saved to the database. Therefore, some of the automatically generated attributes on the instance (such as <strong class="source-inline">id</strong>/<strong class="source-inline">pk</strong>) will not yet be populated and should not be used to generate a path.</p>
			<p>Whatever path is returned from the <strong class="source-inline">upload_to</strong> function, it is appended to <strong class="source-inline">MEDIA_ROOT</strong> so the uploaded files would be saved at <strong class="source-inline">MEDIA_ROOT/&lt;username&gt;/t/e/Test.jpg</strong> and <strong class="source-inline">MEDIA_ROOT/&lt;username&gt;/e/x/example.txt</strong> respectively. </p>
			<p>Note that <strong class="source-inline">user_grouped_file_path</strong> is just an illustrative function that has intentionally been kept short, so it will not work correctly with single-character filenames or if the username has invalid characters. For example, if the username has a <strong class="source-inline">/</strong> in it, then this would act as a directory separator in the generated path.</p>
			<p>Now we have done a deep dive into setting up a <strong class="source-inline">FileField</strong> on a model, but how do we actually save an uploaded file to it? It is as easy as assigning the uploaded file to the attribute of the model, as you would with any type of value. Here is a quick example with a view, and the simple <strong class="source-inline">ExampleModel</strong> class we were using as an example earlier in this section:</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    file_field = models.FileField(upload_to="files/")</p>
			<p class="source-code">def view(request):</p>
			<p class="source-code">    if request.method == "POST":</p>
			<p class="source-code">        m = ExampleModel()  # Create a new ExampleModel instance</p>
			<p class="source-code">        m.file_field = request.FILES["uploaded_file"]</p>
			<p class="source-code">        m.save()</p>
			<p class="source-code">    return render(request, "template.html")</p>
			<p>In this example, we create a new <strong class="source-inline">ExampleModel</strong> class and assign the uploaded file (which had the name <strong class="source-inline">uploaded_file</strong> in the form) to its <strong class="source-inline">file_field</strong> attribute. When we save the model instance, Django automatically writes the file with its name to the <strong class="source-inline">upload_to</strong> directory path. If the uploaded file had the name <strong class="source-inline">image.jpg</strong>, the save path would be <strong class="source-inline">MEDIA_ROOT/upload_to/image.jpg</strong>.</p>
			<p>We could just have easily updated the file field on an existing model or used a form (validating it before saving). Here is another simple example demonstrating this:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    uploaded_file = forms.FileField()</p>
			<p class="source-code">def view(request, model_pk):</p>
			<p class="source-code">    form = ExampleForm(request.POST, request.FILES)</p>
			<p class="source-code">    if form.is_valid():    </p>
			<p class="source-code">        # Get an existing model instance</p>
			<p class="source-code">        m = ExampleModel.object.get(pk=model_pk)</p>
			<p class="source-code">        # store the uploaded file on the instance</p>
			<p class="source-code">        m.file_field = form.cleaned_data["uploaded_file"]</p>
			<p class="source-code">        m.save()</p>
			<p class="source-code">    return render(request, "template.html")</p>
			<p>You can see that updating a <strong class="source-inline">FileField</strong> on an existing model instance is the same process as setting it on a new instance; and if you choose to use a Django form, or just access <strong class="source-inline">request.FILES</strong> directly, the process is just as simple.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor262"/>Storing Images on Model Instances</h2>
			<p>While a <strong class="source-inline">FileField</strong> can store any type of file, including images, there is also an <strong class="source-inline">ImageField</strong>. As you would expect, this is only for storing images. The relationship between models' <strong class="source-inline">forms.FileField</strong> and <strong class="source-inline">forms.ImageField</strong> is similar to that between <strong class="source-inline">models.FileField</strong> and <strong class="source-inline">models.ImageField</strong>, that is, <strong class="source-inline">ImageField</strong> extends <strong class="source-inline">FileField</strong> and adds extra methods for working with images.</p>
			<p>The <strong class="source-inline">ImageField</strong> constructor takes the same arguments as <strong class="source-inline">FileField</strong>, and adds two extra optional arguments:</p>
			<ul>
				<li><strong class="source-inline">height_field</strong>: This is the name of the field of the model that will be updated with the height of the image every time the model instance is saved.</li>
				<li><strong class="source-inline">width_field</strong>: The width counterpart to <strong class="source-inline">height_field</strong>, the field that stores the width of the image that is updated every time the model instance is saved.</li>
			</ul>
			<p>Both of these arguments are optional, but the fields they name must exist if used. That is, it is valid to have <strong class="source-inline">height_field</strong> or <strong class="source-inline">width_field</strong> unset, but if they are set to the name of a field that does not exist, then an error will occur. The purpose of this is to assist with searching the database for files of a particular dimension. </p>
			<p>Here is an example model using an <strong class="source-inline">ImageField</strong>, which updates the image dimension fields:</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    image = models.ImageField(upload_to="images/%Y/%m/%d/", \</p>
			<p class="source-code">                              height_field="image_height",\</p>
			<p class="source-code">                              width_field="image_width")</p>
			<p class="source-code">    image_height = models.IntegerField()</p>
			<p class="source-code">    image_width = models.IntegerField()</p>
			<p>Notice that the <strong class="source-inline">ImageField</strong> is using the <strong class="source-inline">upload_to</strong> parameter with date formatting directives that are updated on save. The behavior of <strong class="source-inline">upload_to</strong> is identical to that of <strong class="source-inline">FileField</strong>.</p>
			<p>Upon saving an <strong class="source-inline">ExampleModel</strong> instance, its <strong class="source-inline">image_height</strong> field would be updated with the height of the image, and <strong class="source-inline">image_width</strong> with the width of the image.</p>
			<p>We will not show examples for setting <strong class="source-inline">ImageField</strong> values in a view, as the process is the same as for a plain <strong class="source-inline">FileField</strong>.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor263"/>Working with FieldFile</h2>
			<p>When you access a <strong class="source-inline">FileField</strong> or <strong class="source-inline">ImageField</strong> attribute of a model instance, you will not get a native Python <strong class="source-inline">file</strong> object. Instead, you will be working with a <strong class="source-inline">FieldFile</strong> object. The <strong class="source-inline">FieldFile</strong> class is a wrapper around a <strong class="source-inline">file</strong> that adds extra methods. Yes, it can be confusing to have classes called <strong class="source-inline">FileField</strong> and <strong class="source-inline">FieldFile</strong>.</p>
			<p>The reason that Django uses <strong class="source-inline">FieldFile</strong> instead of just a <strong class="source-inline">file</strong> object is twofold. First, it adds extra methods to open, read, delete, and generate the URL of the file. Second, it provides an abstraction to allow alternative storage engines to be used. </p>
			<h3 id="_idParaDest-249"><a id="_idTextAnchor264"/>Custom Storage Engines</h3>
			<p>We looked at custom storage engines in <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, regarding storing static files. We will not examine custom storage engines in detail about media files, since the code outlined in <em class="italic">Chapter 5</em>, <em class="italic">Serving Static Files</em>, for static files also applies to media files. The important thing to note is that the storage engine you are using can be changed without updating your other code. This means that you can have your media files stored on your local drive during development and then saved to a CDN when your application is deployed to production.</p>
			<p>The default storage engine class can be set with <strong class="source-inline">DEFAULT_FILE_STORAGE</strong> in <strong class="source-inline">settings.py</strong>. The storage engine can also be specified on a per-field basis (for <strong class="source-inline">FileField</strong> or <strong class="source-inline">ImageField</strong>) with the <strong class="source-inline">storage</strong> argument. For example:</p>
			<p class="source-code">storage_engine = CustomStorageEngine()</p>
			<p class="source-code">class ExampleModel(models.Model):</p>
			<p class="source-code">    image_field = ImageField(storage=storage_engine)</p>
			<p>This demonstrates what actually happens when you upload or retrieve a file. Django delegates to the storage engine to write or read it, respectively. This happens even while saving to disk; however, it is fundamental and is invisible to the user.</p>
			<h3 id="_idParaDest-250"><a id="_idTextAnchor265"/>Reading a Stored FieldFile</h3>
			<p>Now that we have learned about custom storage engines, let us look at reading from a <strong class="source-inline">FieldFile</strong>. In the previous sections, we saw how to set the file on the model instance. Reading the data back again is just as easy – we have a couple of different methods that can help us, depending on our use case.</p>
			<p>In the following few code snippets, assume we are inside a view and have retrieved our model instance in some manner, and it is stored in a variable, <strong class="source-inline">m</strong>. For example:</p>
			<p class="source-code">m = ExampleModel.object.get(pk=model_pk)</p>
			<p>We can read all the data from the file with the <strong class="source-inline">read</strong> method:</p>
			<p class="source-code">data = m.file_field.read()</p>
			<p>Or we can manually open the file with the <strong class="source-inline">open</strong> method. This might be useful if we want to write our own generated data to the file:</p>
			<p class="source-code">with m.file_field.open("wb") as f:</p>
			<p class="source-code">    chunk = f.write(b"test")  # write bytes to the file</p>
			<p>If we wanted to read the file in chunks, we can use the <strong class="source-inline">chunks</strong> method. This works the same as reading chunks from the uploaded file, as we saw earlier:</p>
			<p class="source-code">for chunk in m.file_field.chunks():</p>
			<p class="source-code">    # assume this method is defined somewhere</p>
			<p class="source-code">    write_chunk(open_file, chunk)</p>
			<p>We can also manually open the file ourselves by using its <strong class="source-inline">path</strong> attribute:</p>
			<p class="source-code">open(m.file_field.path)</p>
			<p>If we want to stream a <strong class="source-inline">FileField</strong> for download, the best way is by using the <strong class="source-inline">FileResponse</strong> class as we saw earlier. Combine this with the <strong class="source-inline">open</strong> method on the <strong class="source-inline">FileField</strong>. Note that if we are just trying to serve a media file, we should only implement a view to do this if we are trying to restrict access to the file. Otherwise, we should just serve the file using <strong class="source-inline">MEDIA_URL</strong> and allow the web server to handle the request. Here is how we'd write our <strong class="source-inline">download_view</strong> to use a <strong class="source-inline">FileField</strong> instead of the manually specified path:</p>
			<p class="source-code">def download_view(request, model_pk):</p>
			<p class="source-code">    if request.user.is_anonymous:</p>
			<p class="source-code">        raise PermissionDenied</p>
			<p class="source-code">    m = ExampleModel.objects.get(pk=model_pk)</p>
			<p class="source-code">    # Django sends the file then closes the handle</p>
			<p class="source-code">    return FileResponse(m.file_field.open())  </p>
			<p>Django opens the correct path and closes it after the response. Django will also attempt to determine the correct mime type for the file. We assume that this <strong class="source-inline">FileField</strong> has its <strong class="source-inline">upload_to</strong> attribute set to a protected directory that the web server is preventing direct access to.</p>
			<h3 id="_idParaDest-251"><a id="_idTextAnchor266"/>Storing Existing Files or Content in FileField</h3>
			<p>We've seen how to store an uploaded file in an image field – simply assign it to the field like so:</p>
			<p class="source-code">m.file_field = request.FILES["file_upload"]</p>
			<p>But how can we set the <strong class="source-inline">field</strong> value to that of an existing file that we might already have on disk? You might think you can use a standard Python <strong class="source-inline">file</strong> object, but this won't work:</p>
			<p class="source-code"># Don't do this</p>
			<p class="source-code">m.file_field = open("/path/to/file.txt", "rb")  </p>
			<p>You might also try setting the file using some content:</p>
			<p class="source-code">m.file_field = "new file content"  # Don't do this</p>
			<p>This won't work either.</p>
			<p>You instead need to use the <strong class="source-inline">save</strong> method of <strong class="source-inline">FileField</strong>, which accepts an instance of a Django <strong class="source-inline">File</strong> or <strong class="source-inline">ContentFile</strong> object (these classes' full paths are <strong class="source-inline">django.core.files.File</strong> and <strong class="source-inline">django.core.files.base.ContentFile</strong>, respectively). We will briefly discuss the <strong class="source-inline">save</strong> method and its arguments then return to these classes.</p>
			<p>The <strong class="source-inline">save</strong> method of <strong class="source-inline">FileField</strong> takes three arguments:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The name of the file you are saving. This is the name the file will have when saved to the storage engine (in our case, to disk, inside <strong class="source-inline">MEDIA_ROOT</strong>).</li>
				<li><strong class="source-inline">Content</strong>: This is an instance of <strong class="source-inline">File</strong> or <strong class="source-inline">ContentFile</strong>, which we just saw; again, we will discuss these soon.</li>
				<li><strong class="source-inline">Save</strong>: This argument is optional and defaults to <strong class="source-inline">True</strong>. This indicates whether or not to save the model instance to the database after saving the file. If set to <strong class="source-inline">False</strong> (that is, the model is not saved), then the file will still be written to the storage engine (to disk), but the association is not stored on the model. The previous file path (or no file if one was not set) will still be stored in the database until the model instance's <strong class="source-inline">save</strong> method is called manually. You should only set this argument to <strong class="source-inline">False</strong> if you intend to make other changes to the model instance and then save it manually.</li>
			</ul>
			<p>Back to <strong class="source-inline">File</strong> and <strong class="source-inline">ContentFile</strong>: the one to use depends on what you want to store in a <strong class="source-inline">FileField</strong>. </p>
			<p><strong class="source-inline">File</strong> is used as a wrapper around a Python <strong class="source-inline">file</strong> object, and you should use it if you have an existing <strong class="source-inline">file</strong> or file-like object that you want to save. File-like objects include <strong class="source-inline">io.BytesIO</strong> or <strong class="source-inline">io.StringIO</strong> instances. To instantiate a <strong class="source-inline">File</strong> instance, just pass the native <strong class="source-inline">file</strong> object to the constructor, for example:</p>
			<p class="source-code">f = open("/path/to/file.txt", "rb")</p>
			<p class="source-code">file_wrapper = File(f)</p>
			<p>Use <strong class="source-inline">ContentFile</strong> when you already have some data loaded, either a <strong class="source-inline">str</strong> or <strong class="source-inline">bytes</strong> object. Pass the data to the <strong class="source-inline">ContentFile</strong> constructor:</p>
			<p class="source-code">string_content = ContentFile("A string value")</p>
			<p class="source-code">bytes_content = ContentField(b"A bytes value")</p>
			<p>Now that you have either a <strong class="source-inline">File</strong> or <strong class="source-inline">ContentFile</strong> instance, saving the data to the <strong class="source-inline">FileField</strong> is easy, using the <strong class="source-inline">save</strong> method:</p>
			<p class="source-code">m = ExampleModel.objects.first()</p>
			<p class="source-code">with open("/path/to/file.txt") as f:</p>
			<p class="source-code">    file_wrapper = File(f)</p>
			<p class="source-code">    m.file_field.save("file.txt", f)</p>
			<p>Since we did not pass a value for <strong class="source-inline">save</strong> to the <strong class="source-inline">save</strong> method, it will default to <strong class="source-inline">True</strong>, so the model instance is automatically persisted to the database.</p>
			<p>Next, we will look at how to store an image that has been manipulated with a PIL back to an image field.</p>
			<h3 id="_idParaDest-252"><a id="_idTextAnchor267"/>Writing PIL Images to ImageField</h3>
			<p>In <em class="italic">Exercise 8.05</em>, <em class="italic">Image Uploads Using Django Forms</em>, you used PIL to resize an image and save it to disk. When working with a model, you might want to perform a similar operation, but have Django handle the file storage using the <strong class="source-inline">ImageField</strong> so that you do not have to do it manually. As in the exercise, you could save the image to disk and then use the <strong class="source-inline">File</strong> class to wrap the stored path – something like this:</p>
			<p class="source-code">image = Image.open(request.FILES["image_field"])</p>
			<p class="source-code">image.thumbnail((150, 150))</p>
			<p class="source-code"># save thumbnail to temp location</p>
			<p class="source-code">image.save("/tmp/thumbnail.jpg")</p>
			<p class="source-code">with open("/tmp/thumbnail.jpg", "rb") as f:</p>
			<p class="source-code">    image_wrapper = File(f)</p>
			<p class="source-code">    m.image_field.save("thumbnail.jpg", image_wrapper)</p>
			<p class="source-code">os.unlink("/tmp/thumbnail.jpg")  # clean up temp file</p>
			<p>In this example, we're having PIL stored to a temporary location with the <strong class="source-inline">Image.save()</strong> method, and then re-opening the file.</p>
			<p>This method works but is not ideal as it involves writing the file to disk and then reading it out again, which can sometimes be slow. Instead, we can perform this whole process in memory. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">io.BytesIO</strong> and <strong class="source-inline">io.StringIO</strong> are useful objects. They behave like files but exist in memory only. <strong class="source-inline">BytesIO</strong> is used for storing raw bytes, and <strong class="source-inline">StringIO</strong> accepts Python 3's native Unicode strings. You can <strong class="source-inline">read</strong>, <strong class="source-inline">write</strong>, and <strong class="source-inline">seek</strong> them, just like a normal file. Unlike a normal file though, they do not get written to disk and instead will disappear when your program terminates, or they go out of scope and are garbage-collected. They are very useful if a function wants to write to something like a file, but you want to access the data immediately. </p>
			<p>First, we will save the image data to an <strong class="source-inline">io.BytesIO</strong> object. Then, we will wrap the <strong class="source-inline">BytesIO</strong> object in a <strong class="source-inline">django.core.files.images.ImageFile</strong> instance (a subclass of <strong class="source-inline">File</strong> that is specifically for images and provides <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> attributes). Once we have this <strong class="source-inline">ImageFile</strong> instance, we can use it in the <strong class="source-inline">save</strong> method of <strong class="source-inline">ImageField</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An <strong class="source-inline">ImageFile</strong> is a file or file-like wrapper just like <strong class="source-inline">File</strong>. It provides two extra attributes: <strong class="source-inline">width</strong>, and <strong class="source-inline">height</strong>. <strong class="source-inline">ImageFile</strong> does not generate any errors if you use it to wrap a non-image. For example, you could <strong class="source-inline">open()</strong> a text file and pass the filehandle to the <strong class="source-inline">ImageFile</strong> constructor without any issue. You can check whether the image file you passed in was valid by trying to access the <strong class="source-inline">width</strong> or <strong class="source-inline">height</strong> attributes: if these are <strong class="source-inline">None</strong>, then PIL was unable to decode the image data. You could check for the validity of these values yourself and throw an exception if they were <strong class="source-inline">None</strong>.</p>
			<p>Let us have a look at this in practice, in a view:</p>
			<p class="source-code">from io import BytesIO</p>
			<p class="source-code">from PIL import Image</p>
			<p class="source-code">from django.core.files.images import ImageFile</p>
			<p class="source-code">def index(request, pk):</p>
			<p class="source-code">    # trim out logic for checking if method is POST</p>
			<p class="source-code">    # get a model instance, or create a new one</p>
			<p class="source-code">    m = ExampleModel.objects.get(pk=pk)  </p>
			<p class="source-code">    </p>
			<p class="source-code">    # store the uploaded image in a variable for shorter code</p>
			<p class="source-code">    uploaded_image = request.FILES["image_field"]</p>
			<p class="source-code">    # load a PIL image instance from the uploaded file</p>
			<p class="source-code">    image = Image.open(uploaded)</p>
			<p class="source-code">    # perform the image resize</p>
			<p class="source-code">    image.thumbnail((150, 150))</p>
			<p class="source-code">    # Create a BytesIO file-like object to store</p>
			<p class="source-code">    image_data = BytesIO()</p>
			<p class="source-code">    # Write the Image data back out to the BytesIO object</p>
			<p class="source-code">    # Retain the existing format from the uploaded image</p>
			<p class="source-code">    image.save(fp=image_data, uploaded_image.format)</p>
			<p class="source-code">    # Wrap the BytesIO containing the image data</p>
			<p class="source-code">    image_file = ImageFile(image_data)</p>
			<p class="source-code">    # Save the wrapped image file data with the original name</p>
			<p class="source-code">    m.image_field.save(uploaded_image.name, image_file)</p>
			<p class="source-code">    # this also saves the model instance</p>
			<p class="source-code">    return redirect("/success-url/")</p>
			<p>You can see this is a little bit more code, but it saves on writing the data to disk. You can choose to use either method (or another one that you come up with) depending on your needs. </p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor268"/>Referring to Media in Templates</h2>
			<p>Once we have uploaded a file, we want to be able to refer to it in a template. For an uploaded image, such as a book cover, we will want to be able to display the image on the page. We saw in <em class="italic">Exercise 8.02</em>, <em class="italic">Template Settings and Using MEDIA_URL in Templates</em>, how to build a URL using <strong class="source-inline">MEDIA_URL</strong> in a template. When working with <strong class="source-inline">FileField</strong> or <strong class="source-inline">ImageField</strong> on a model instance, it is not necessary to do this as Django provides this functionality for you.</p>
			<p>The <strong class="source-inline">url</strong> attribute of a <strong class="source-inline">FileField</strong> will automatically generate the full URL to the media file, based on the <strong class="source-inline">MEDIA_URL</strong> in your settings.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that references we make to a <strong class="source-inline">FileField</strong> in this section also apply to <strong class="source-inline">ImageField</strong>, as it is a subclass of <strong class="source-inline">FileField</strong>.</p>
			<p>This can be used anywhere that you have access to the instance and field, such as in a view or a template. For example, in a view:</p>
			<p class="source-code">instance = ExampleModel.objects.first()</p>
			<p class="source-code">url = instance.file_field.url  # Get the URL</p>
			<p>Or in a template (assuming the <strong class="source-inline">instance</strong> has been passed to the template context):</p>
			<p class="source-code">&lt;img src="{{ instance.file_field.url }}"&gt;</p>
			<p>In the next exercise, we will create a new model with a <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong>, then show how Django can automatically save these. We'll also demonstrate how to retrieve the URL for an uploaded file.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor269"/>Exercise 8.06: FileField and ImageField on Models</h2>
			<p>In this exercise, we will create a model with a <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong>. After doing this, we will have to generate a migration and apply it. We will then change the <strong class="source-inline">UploadForm</strong> we have been using so it has both a <strong class="source-inline">FileField</strong> and an <strong class="source-inline">ImageField</strong>. The <strong class="source-inline">media_example</strong> view will be updated to store the uploaded files in the model instance. Finally, we will add an <strong class="source-inline">&lt;img&gt;</strong> into the example template to show the previously uploaded image:</p>
			<ol>
				<li value="1">In PyCharm, open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">models.py</strong> file. Create a new model called <strong class="source-inline">ExampleModel</strong>, with two fields: an <strong class="source-inline">ImageField</strong> named <strong class="source-inline">image_field</strong>, and a <strong class="source-inline">FileField</strong> called <strong class="source-inline">file_field</strong>. The <strong class="source-inline">ImageField</strong> should have its <strong class="source-inline">upload_to</strong> set to <strong class="source-inline">images/</strong>, and the <strong class="source-inline">FileField</strong> should have its <strong class="source-inline">upload_to</strong> set to <strong class="source-inline">files/</strong>. The finished model should look like this:<p class="source-code">class ExampleModel(models.Model):</p><p class="source-code">    image_field = models.ImageField(upload_to="images/")</p><p class="source-code">    file_field = models.FileField(upload_to="files/")</p><p>Your <strong class="source-inline">models.py</strong> should now look like this: <a href="http://packt.live/3p4bfrr">http://packt.live/3p4bfrr</a>. </p></li>
				<li>Open a terminal and navigate to the <strong class="source-inline">media_project</strong> project directory. Make sure your <strong class="source-inline">bookr</strong> virtual environment is active. Run the <strong class="source-inline">makemigrations</strong> management command to generate the migrations for this new model (for Windows, you can use <strong class="source-inline">python</strong> instead of <strong class="source-inline">python3</strong> in the following code):<p class="source-code">python3 manage.py makemigrations</p><p class="callout-heading">Note</p><p class="callout">To learn how to create and activate a virtual environment, refer to the <em class="italic">Preface</em>.</p><p>You should get output like the following:</p><p class="source-code">(bookr)$ python3 manage.py makemigrations</p><p class="source-code">Migrations for 'media_example':</p><p class="source-code">  media_example/migrations/0001_initial.py</p><p class="source-code">    - Create model ExampleModel</p></li>
				<li>Apply the migration by running the <strong class="source-inline">migrate</strong> management command:<p class="source-code">python3 manage.py migrate</p><p>The output is like the following:</p><p class="source-code">(bookr)$ python3 manage.py migrate</p><p class="source-code">Operations to perform:</p><p class="source-code">  Apply all migrations: admin, auth, contenttypes, reviews, sessions</p><p class="source-code">Running migrations:</p><p class="source-code">  # output trimmed for brevity</p><p class="source-code">   Applying media_example.0001_initial... OK</p><p>Note that all the initial Django migrations will also be applied since we did not apply those after creating the project.</p></li>
				<li>Switch back to PyCharm and open the <strong class="source-inline">reviews</strong> app's <strong class="source-inline">forms.py</strong> file. Rename the existing <strong class="source-inline">ImageField</strong> from <strong class="source-inline">file_upload</strong> to <strong class="source-inline">image_upload</strong>. Then, add a new <strong class="source-inline">FileField</strong> named <strong class="source-inline">file_upload</strong>. After making these changes, your <strong class="source-inline">UploadForm</strong> code should look like this:<p class="source-code">class UploadForm(forms.Form):</p><p class="source-code">    image_upload = forms.ImageField()</p><p class="source-code">    file_upload = forms.FileField()</p><p>You can save and close the file. It should look like this: <a href="http://packt.live/37RZcaG">http://packt.live/37RZcaG</a>. </p></li>
				<li>Open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">views.py</strong> file. First, import <strong class="source-inline">ExampleModel</strong> into the file. To do this, add this line at the top of the file after the existing <strong class="source-inline">import</strong> statements:<p class="source-code">from .models import ExampleModel</p><p>Some imports will no longer be required, so you can remove these lines:</p><p class="source-code">import os</p><p class="source-code">from PIL import Image</p><p class="source-code">from django.conf import settings</p></li>
				<li>In the <strong class="source-inline">media_example</strong> view, set a default for the instance that you will render, in case one is not created. After the function definition, define a variable called <strong class="source-inline">instance</strong>, and set it to <strong class="source-inline">None</strong>:<p class="source-code">def media_example(request):</p><p class="source-code">    instance = None</p></li>
				<li>You can completely remove the contents of the <strong class="source-inline">form.is_valid()</strong> branch as you no longer need to manually save the file. Instead, it will automatically be saved when the <strong class="source-inline">ExampleModel</strong> instance is saved. You will instantiate an <strong class="source-inline">ExampleModel</strong> instance and set the <strong class="source-inline">file</strong> and <strong class="source-inline">image</strong> fields from the uploaded form. <p>Add this code under the <strong class="source-inline">if form.is_valid():</strong> line:</p><p class="source-code">instance = ExampleModel()</p><p class="source-code">instance.image_field = form.cleaned_data["image_upload"]</p><p class="source-code">instance.file_field = form.cleaned_data["file_upload"]</p><p class="source-code">instance.save()</p></li>
				<li>Pass the instance through to the template in the context dictionary that is passed to <strong class="source-inline">render</strong>. Use the key <strong class="source-inline">instance</strong>:<p class="source-code">return render(request, "media-example.html", \</p><p class="source-code">              {"form": form, "instance": instance})</p><p>Now, your completed <strong class="source-inline">media_example</strong> view should look like this: <a href="http://packt.live/3hqyYz7">http://packt.live/3hqyYz7</a>.</p><p>You can now save and close this file.</p></li>
				<li>Open the <strong class="source-inline">media-example.html</strong> template. Add an <strong class="source-inline">&lt;img&gt;</strong> element that displays the last uploaded image. Under the closing <strong class="source-inline">&lt;/form&gt;</strong> tag, add an <strong class="source-inline">if</strong> template tag that checks if an <strong class="source-inline">instance</strong> has been provided. If so, display an <strong class="source-inline">&lt;img&gt;</strong> with a <strong class="source-inline">src</strong> attribute of <strong class="source-inline">instance.image_field.url</strong>:<p class="source-code">{% if instance %}</p><p class="source-code">    &lt;img src="{{ instance.image_field.url }}"&gt;</p><p class="source-code">{% endif %}</p><p>You can save and close this file. It should now look like this: <a href="http://packt.live/2X5d5w9">http://packt.live/2X5d5w9</a>. </p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see the form rendered with two fields:<div id="_idContainer310" class="IMG---Figure"><img src="image/B15509_08_20.jpg" alt="Figure 8.20: UploadForm with two fields&#13;&#10;"/></div><p class="figure-caption">Figure 8.20: UploadForm with two fields</p></li>
				<li>Select a file for each field – for the <strong class="source-inline">ImageField</strong> you must select an image, but any type of file is allowed for the <strong class="source-inline">FileField</strong>. See <em class="italic">Figure 8.21</em>, which shows the fields with files selected:<div id="_idContainer311" class="IMG---Figure"><img src="image/B15509_08_21.jpg" alt="Figure 8.21: ImageField and FileField with files selected&#13;&#10;"/></div><p class="figure-caption">Figure 8.21: ImageField and FileField with files selected</p><p>Then, submit the form. If the submission was successful, the page will reload and the last image you uploaded will be displayed (<em class="italic">Figure 8.22</em>):</p><div id="_idContainer312" class="IMG---Figure"><img src="image/B15509_08_22.jpg" alt="Figure 8.22: The last image that was uploaded is displayed&#13;&#10;"/></div><p class="figure-caption">Figure 8.22: The last image that was uploaded is displayed</p></li>
				<li>You can see how Django stores the files by looking in the <strong class="source-inline">MEDIA_ROOT</strong> directory. <em class="italic">Figure 8.23</em> shows the directory layout in PyCharm:<div id="_idContainer313" class="IMG---Figure"><img src="image/B15509_08_23.jpg" alt="Figure 8.23: Uploaded files that Django has created&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.23: Uploaded files that Django has created</p>
			<p>You can see that Django has created the <strong class="source-inline">files</strong> and <strong class="source-inline">images</strong> directories. These were what you set in the <strong class="source-inline">upload_to</strong> arguments on the <strong class="source-inline">ImageField</strong> and <strong class="source-inline">FileField</strong> of the model. You could also verify these uploads by attempting to download them, for example, at <strong class="source-inline">http://127.0.0.1:8000/media/files/sample.txt</strong> or <strong class="source-inline">http://127.0.0.1:8000/media/images/cover.jpg</strong>.</p>
			<p>In this exercise, we created <strong class="source-inline">ExampleModel</strong> with <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong> and saw how to store uploaded files in it. We saw how to generate a URL to an uploaded file for use in a template. We tried uploading some files and saw that Django automatically created the <strong class="source-inline">upload_to</strong> directories (<strong class="source-inline">media/files</strong> and <strong class="source-inline">media/images</strong>), then stored the files inside.</p>
			<p>In the next section, we will look at how we can simplify the process even further by using a <strong class="source-inline">ModelForm</strong> to generate the form and save the model without having to manually set the files in the view.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor270"/>ModelForms and File Uploads</h2>
			<p>We have seen how using a <strong class="source-inline">form.ImageField</strong> on a form can prevent non-images being uploaded. We have also seen how <strong class="source-inline">models.ImageField</strong> makes it easy to store an image for a model. But we need to be aware that Django does not stop you from setting a non-image file to an <strong class="source-inline">ImageField</strong>. For example, consider a form that has both a <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong>:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    uploaded_file = forms.FileField()</p>
			<p class="source-code">    uploaded_image = forms.ImageField()</p>
			<p>In the following view, the form would not validate if the <strong class="source-inline">uploaded_image</strong> field on the form was not an image, so some data validity is ensured for uploaded data. For example:</p>
			<p class="source-code">def view(request):</p>
			<p class="source-code">    form = ExampleForm(request.POST, request.FILES)</p>
			<p class="source-code">    if form.is_valid():</p>
			<p class="source-code">        m = ExampleModel()</p>
			<p class="source-code">        m.file_field = form.cleaned_data["uploaded_file"]</p>
			<p class="source-code">        m.image_field = forms.cleaned_data["uploaded_image"]</p>
			<p class="source-code">        m.save()</p>
			<p class="source-code">    return render(request, "template.html")  </p>
			<p>Since we are sure the form is valid, we know that <strong class="source-inline">forms.cleaned_data["uploaded_image"]</strong> must contain an image. Therefore, we would never assign a non-image to the model instance's <strong class="source-inline">image_field</strong>.</p>
			<p>However, say we made a mistake in our code and wrote something like this:</p>
			<p class="source-code">m.image_field = forms.cleaned_data["uploaded_file"]</p>
			<p>That is, if we accidentally reference the <strong class="source-inline">FileField</strong> by mistake, Django does not validate that a (potential) non-image is being assigned to an <strong class="source-inline">ImageField</strong>, and so it does not throw an exception or generate any kind of error. We can mitigate the potential for issues like this by using a <strong class="source-inline">ModelForm</strong>.</p>
			<p>We introduced <strong class="source-inline">ModelForm</strong> in <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em> – these are forms whose fields are automatically defined from a model. We saw that a <strong class="source-inline">ModelForm</strong> has a <strong class="source-inline">save</strong> method that automatically creates or updates the model data in the database. When used with a model that has a <strong class="source-inline">FileFIeld</strong> or <strong class="source-inline">ImageField</strong>, then the <strong class="source-inline">ModelForm</strong> <strong class="source-inline">save</strong> method will also save uploaded files.</p>
			<p>Here is an example of using a <strong class="source-inline">ModelForm</strong> to save a new model instance in a view. Here, we are just making sure to pass <strong class="source-inline">request.FILES</strong> to the <strong class="source-inline">ModelForm</strong> constructor:</p>
			<p class="source-code">class ExampleModelForm(forms.Model):</p>
			<p class="source-code">    class Meta:</p>
			<p class="source-code">        model = ExampleModel</p>
			<p class="source-code">        # The same ExampleModel class we've seen previously</p>
			<p class="source-code">        fields = "__all__"</p>
			<p class="source-code">def view(request):</p>
			<p class="source-code">    if request.method == "POST":</p>
			<p class="source-code">        form = ExampleModelForm(request.POST, request.FILES)</p>
			<p class="source-code">        form.save()</p>
			<p class="source-code">        return redirect("/success-page")</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        form = ExampleModelForm()</p>
			<p class="source-code">    return (request, "template.html", {"form": form})</p>
			<p>As with any <strong class="source-inline">ModelForm</strong>, the <strong class="source-inline">save</strong> method can be called with the <strong class="source-inline">commit</strong> argument set to <strong class="source-inline">False</strong>. Then the model instance will not be saved to the database, and the <strong class="source-inline">FileField</strong>/<strong class="source-inline">ImageField</strong> files will not be saved to disk. The <strong class="source-inline">save</strong> method should be called on the model instance itself – this will commit changes to the database and save the files. In this next short example, we set a value on the model instance before saving it:</p>
			<p class="source-code">def view(request):</p>
			<p class="source-code">    if request.method == "POST":</p>
			<p class="source-code">        form = ExampleModelForm(request.POST, request.FILES)</p>
			<p class="source-code">        m = form.save(False)</p>
			<p class="source-code">        # Set arbitrary value on the model instance before save</p>
			<p class="source-code">        m.attribute = "value"</p>
			<p class="source-code">        # save the model instance, also write the files to disk</p>
			<p class="source-code">        m.save()</p>
			<p class="source-code">        return redirect("/success-page/")</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        form = ExampleModelForm()</p>
			<p class="source-code">    return (request, "template.html", {"form": form})</p>
			<p>Calling the <strong class="source-inline">save</strong> method on the model instance both saves the model data to the database and the uploaded files to disk. In the next exercise, we will build a <strong class="source-inline">ModelForm</strong> from <strong class="source-inline">ExampleModel</strong>, which we created in <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, then test uploading files with it.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor271"/>Exercise 8.07: File and Image Uploads Using a ModelForm</h2>
			<p>In this exercise, you will update <strong class="source-inline">UploadForm</strong> to be a subclass of <strong class="source-inline">ModelForm</strong> and have it built automatically from <strong class="source-inline">ExampleModel</strong>. You will then change the <strong class="source-inline">media_example</strong> view to save the instance automatically from the form, so you can see how the amount of code can be reduced:</p>
			<ol>
				<li value="1">In PyCharm, open the <strong class="source-inline">media_example</strong> apps' <strong class="source-inline">forms.py</strong> file. You need to use <strong class="source-inline">ExampleModel</strong> in this chapter, so <strong class="source-inline">import</strong> it at the top of the file after the <strong class="source-inline">from django import forms</strong> statement. Insert this line:<p class="source-code">from .models import ExampleModel</p></li>
				<li>Change <strong class="source-inline">UploadForm</strong> to be a subclass of <strong class="source-inline">forms.ModelForm</strong>. Remove the <strong class="source-inline">class</strong> body and replace it with a <strong class="source-inline">class Meta</strong> definition; its <strong class="source-inline">model</strong> should be <strong class="source-inline">ExampleModel</strong>. Set the <strong class="source-inline">fields</strong> attribute to <strong class="source-inline">__all__</strong>. After completing this step, your <strong class="source-inline">UploadForm</strong> should look like this:<p class="source-code">class UploadForm(forms.ModelForm):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = ExampleModel</p><p class="source-code">        fields = "__all__"</p><p>Save and close the file. It should now look like this: <a href="http://packt.live/37X49ig">http://packt.live/37X49ig</a>.</p></li>
				<li>Open the <strong class="source-inline">media_example</strong> app's <strong class="source-inline">views.py</strong> file. Since you no longer need to reference the <strong class="source-inline">ExampleModel</strong> directly, you can remove its <strong class="source-inline">import</strong> at the top of the file. Remove the following line:<p class="source-code">from .models import ExampleModel</p></li>
				<li>In the <strong class="source-inline">media_example</strong> view, remove the entirety of the <strong class="source-inline">form.is_valid()</strong> branch and replace it with a single line:<p class="source-code">instance = form.save()</p><p>The form's <strong class="source-inline">save</strong> method will handle persisting the instance to the database and saving the files. It will return an instance of <strong class="source-inline">ExampleModel</strong>, the same as the other instances of <strong class="source-inline">ModelForm</strong> we have worked with in <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em>.</p><p>After completing this step, your <strong class="source-inline">media_example</strong> function should look like this: <a href="http://packt.live/37V0ly2">http://packt.live/37V0ly2</a>. Save and close <strong class="source-inline">views.py</strong>.</p></li>
				<li>Start the Django dev server if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/media-example/</strong>. You should see the form rendered with two fields, <strong class="source-inline">Image field</strong> and <strong class="source-inline">File field</strong> (<em class="italic">Figure 8.24</em>): <div id="_idContainer314" class="IMG---Figure"><img src="image/B15509_08_24.jpg" alt="Figure 8.24: UploadForm as a ModelForm rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 8.24: UploadForm as a ModelForm rendered in the browser</p><p>Note that the names of these fields now match those of the model rather than the form, as the form just uses the model's fields.</p></li>
				<li>Browse and select an image and file (<em class="italic">Figure 8.25</em>), then submit the form:<p> </p><div id="_idContainer315" class="IMG---Figure"><img src="image/B15509_08_25.jpg" alt="Figure 8.25: Image and file selected&#13;&#10;"/></div><p class="figure-caption">Figure 8.25: Image and file selected</p></li>
				<li>The page will reload, and as in <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, you will see the previously uploaded image (<em class="italic">Figure 8.26</em>):<p> </p><div id="_idContainer316" class="IMG---Figure"><img src="image/B15509_08_26.jpg" alt="Figure 8.26: Image being displayed after upload&#13;&#10;"/></div><p class="figure-caption">Figure 8.26: Image being displayed after upload</p></li>
				<li>Finally, examine the contents of the <strong class="source-inline">media</strong> directory. You should see the directory layout matches that of <em class="italic">Exercise 8.06</em>, <em class="italic">FileField and ImageField on Models</em>, with images inside the <strong class="source-inline">images</strong> directory, and files inside the <strong class="source-inline">files</strong> directory:<div id="_idContainer317" class="IMG---Figure"><img src="image/B15509_08_27.jpg" alt="Figure 8.27: The uploaded files directory matches Exercise 8.06&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.27: The uploaded files directory matches Exercise 8.06</p>
			<p>In this exercise, we changed <strong class="source-inline">UploadForm</strong> to be a <strong class="source-inline">ModelForm</strong> subclass, which allowed us to automatically generate the upload fields. We could replace the code that stored the uploaded files on the models with a call to the form's <strong class="source-inline">save</strong> method.</p>
			<p>We have now covered everything you need to start enhancing Bookr with file uploads. In the activity for this chapter, we will add support for uploading a cover image and sample document (PDF, text file, and more) for a book. The book cover will be resized using PIL before it is saved.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor272"/>Activity 8.01: Image and PDF Uploads of Books</h2>
			<p>In this activity, you will start by cleaning up (deleting) the example views, templates, forms, models, and URL maps that we have used throughout the exercises in this chapter. You will then need to generate and apply a migration to delete <strong class="source-inline">ExampleModel</strong> from the database.</p>
			<p>You can then start adding the Bookr enhancements, first by adding an <strong class="source-inline">ImageField</strong> and <strong class="source-inline">FileField</strong> to the <strong class="source-inline">Book</strong> model to store the book <strong class="source-inline">cover</strong> and <strong class="source-inline">sample</strong>. Then you will create a migration and apply it to add these fields to the database. You can then build a form that will display just these new fields. You will add a view that uses this form to save the model instance with the uploaded files, after first resizing the image to thumbnail size. You will be able to reuse the <strong class="source-inline">instance-form.html</strong> template from <em class="italic">Chapter 7</em>, <em class="italic">Advanced Form Validation and Model Forms</em>, with a minor change to allow file uploads.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Update the Django settings to add the settings <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong>.</li>
				<li>The <strong class="source-inline">/media/</strong> URL mapping should be added to <strong class="source-inline">urls.py</strong>. Use the <strong class="source-inline">static</strong> view and utilize <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong> from Django settings. Remember, this mapping should only be added if <strong class="source-inline">DEBUG</strong> is true.</li>
				<li>Add an <strong class="source-inline">ImageField</strong> (named <strong class="source-inline">cover</strong>) and <strong class="source-inline">FileField</strong> (named <strong class="source-inline">sample</strong>) to the <strong class="source-inline">Book</strong> model. The fields should upload to <strong class="source-inline">book_covers/</strong> and <strong class="source-inline">book_samples/</strong>, respectively. They should both allow <strong class="source-inline">null</strong> and <strong class="source-inline">blank</strong> values.</li>
				<li>Run <strong class="source-inline">makemigrations</strong> and <strong class="source-inline">migrate</strong> again to apply the <strong class="source-inline">Book</strong> model changes to the database.</li>
				<li>Create a <strong class="source-inline">BookMediaForm</strong> as a subclass of <strong class="source-inline">ModelForm</strong>. Its model should be <strong class="source-inline">Book</strong>, and the fields should only be the fields you added in <em class="italic">step 3</em>.</li>
				<li>Add a <strong class="source-inline">book_media</strong> view. This will not allow you to create a <strong class="source-inline">Book</strong>, instead, it will only allow you to add media to an existing <strong class="source-inline">Book</strong> (so it must take <strong class="source-inline">pk</strong> as a required argument).</li>
				<li>The <strong class="source-inline">book_media</strong> view should validate the form, and <strong class="source-inline">save</strong> it, but not <strong class="source-inline">commit</strong> the instance. The uploaded cover should first be resized using the <strong class="source-inline">thumbnail</strong> method as demonstrated in the <em class="italic">Writing PIL Images to ImageField</em> section. The maximum size should be 300 by 300 pixels. It should then be stored on the instance and the instance saved. Remember that the <strong class="source-inline">cover</strong> field is not required so you should check this before trying to manipulate the image. On a successful <strong class="source-inline">POST</strong>, register a success message that the <strong class="source-inline">Book</strong> was updated, then redirect to the <strong class="source-inline">book_detail</strong> view.</li>
				<li>Render the <strong class="source-inline">instance-form.html</strong>, passing a context dictionary containing <strong class="source-inline">form</strong>, <strong class="source-inline">model_type,</strong> and <strong class="source-inline">instance</strong>, as you did in <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>. Also pass another item, <strong class="source-inline">is_file_upload</strong>, set to <strong class="source-inline">True</strong>. This variable will be used in the next step.</li>
				<li>In the <strong class="source-inline">instance-form.html</strong> template, use the <strong class="source-inline">is_file_upload</strong> variable to add the correct <strong class="source-inline">enctype</strong> attribute to the form. This will allow you to switch the modes for the form to enable file uploads when required.</li>
				<li>Finally, add a URL map that maps <strong class="source-inline">/books/&lt;pk&gt;/media/</strong> to the <strong class="source-inline">book_media</strong> view.</li>
			</ol>
			<p>When you are finished, you should be able to start the Django dev server and load the <strong class="source-inline">book_media</strong> view at <strong class="source-inline">http://127.0.0.1:8000/books/&lt;pk&gt;/media/</strong>, for example, <strong class="source-inline">http://127.0.0.1:8000/books/2/media/</strong>. You should see the <strong class="source-inline">BookMediaForm</strong> rendered in the browser, like in <em class="italic">Figure 8.28</em>:</p>
			<div>
				<div id="_idContainer318" class="IMG---Figure">
					<img src="image/B15509_08_28.jpg" alt="Figure 8.28: BookMediaForm in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.28: BookMediaForm in the browser</p>
			<p>Select a cover image and sample file for the book. You can use the image at <a href="http://packt.live/2KyIapl">http://packt.live/2KyIapl</a> and PDF at <a href="http://packt.live/37VycHn">http://packt.live/37VycHn</a> (or you can use any other image/PDF of your choosing).</p>
			<div>
				<div id="_idContainer319" class="IMG---Figure">
					<img src="image/B15509_08_29.jpg" alt="Figure 8.29: Book Cover image and Sample selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.29: Book Cover image and Sample selected</p>
			<p>After submitting the form, you will be redirected to the <strong class="source-inline">Book Details</strong> view and see the success message (<em class="italic">Figure 8.30</em>):</p>
			<p> </p>
			<div>
				<div id="_idContainer320" class="IMG---Figure">
					<img src="image/B15509_08_30.jpg" alt="Figure 8.30: Success message on the Book Details page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.30: Success message on the Book Details page</p>
			<p>If you go back to the same book's media page, you should see the fields are now filled in, with an option to clear the data from them:</p>
			<div>
				<div id="_idContainer321" class="IMG---Figure">
					<img src="image/B15509_08_31.jpg" alt="Figure 8.31: BookMediaForm with existing values&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 8.31: BookMediaForm with existing values</p>
			<p>In <em class="italic">Activity 8.02</em>, <em class="italic">Displaying Cover and Sample Links</em>, you will add these uploaded files to the <strong class="source-inline">Book Details</strong> view, but for now, if you want to check that uploads have worked, you can look inside the <strong class="source-inline">media</strong> directory in the Bookr project:</p>
			<div>
				<div id="_idContainer322" class="IMG---Figure">
					<img src="image/B15509_08_32.jpg" alt="Figure 8.32: Book media&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32: Book media</p>
			<p>You should see the directories that were created and the uploaded files, as per <em class="italic">Figure 8.32</em>. Open an uploaded image, and you should see its maximum dimension is 300 pixels.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-258">Activity 8.02: Displaying Cover <a id="_idTextAnchor273"/>and Sample Links</h2>
			<p>In this activity, you will update the <strong class="source-inline">book_detail.html</strong> template to show the cover for the <strong class="source-inline">Book</strong> (if one is set). You will also add a link to download the sample, again, only if one is set. You will use the <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong> <strong class="source-inline">url</strong> attributes to generate the URLs to the media files.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">Book Details</strong> display in the <strong class="source-inline">book_detail.html</strong> view, add an <strong class="source-inline">&lt;img&gt;</strong> element if the book has a <strong class="source-inline">cover</strong> image. Then, display the cover of the book inside it. Use <strong class="source-inline">&lt;br&gt;</strong> after the <strong class="source-inline">&lt;img&gt;</strong> tag so the image is on its own line.</li>
				<li>After the <strong class="source-inline">Publication Date</strong> display, add a link to the sample file. It should only be displayed if a <strong class="source-inline">sample</strong> file has been uploaded. Make sure you add another <strong class="source-inline">&lt;br&gt;</strong> tag so it displays correctly.</li>
				<li>In the section that has a link to add a review, add another link that goes to the media page for the book. Follow the same styling as the <strong class="source-inline">Add Review</strong> link.</li>
			</ol>
			<p>When you have completed these steps, you should be able to load a book detail page. If the book has no <strong class="source-inline">cover</strong> or <strong class="source-inline">sample</strong>, then the page should look very similar to what it did before, except you should see the new link to the <strong class="source-inline">Media</strong> page at the bottom (<em class="italic">Figure 8.33</em>):</p>
			<div>
				<div id="_idContainer323" class="IMG---Figure">
					<img src="image/B15509_08_33.jpg" alt="Figure 8.33: New Media button visible on the book detail page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.33: New Media button visible on the book detail page</p>
			<p>Once you have uploaded a <strong class="source-inline">cover</strong> and/or a <strong class="source-inline">sample</strong> for a <strong class="source-inline">Book</strong>, the cover image and sample link should be displayed (<em class="italic">Figure 8.34</em>):</p>
			<div>
				<div id="_idContainer324" class="IMG---Figure">
					<img src="image/B15509_08_34.jpg" alt="Figure 8.34: Book cover and sample link displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.34: Book cover and sample link displayed</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor274"/>Summary</h1>
			<p>In this chapter, we added the <strong class="source-inline">MEDIA_ROOT</strong> and <strong class="source-inline">MEDIA_URL</strong> settings and a special URL map to serve media files. We then created a form and a view to upload files and save them to the <strong class="source-inline">media</strong> directory. We saw how to add the media context processor to automatically have access to the <strong class="source-inline">MEDIA_URL</strong> setting in all our templates. We then enhanced and simplified our form code by using a Django form with a <strong class="source-inline">FileField</strong> or <strong class="source-inline">ImageField</strong>, instead of manually defining one in HTML.</p>
			<p>We looked at some of the enhancements Django provides for images with the <strong class="source-inline">ImageField</strong>, and how to interact with an image using Pillow. We showed an example view that would be able to serve files that required authentication, using the <strong class="source-inline">FileResponse</strong> class. Then, we saw how to store files on models using the <strong class="source-inline">FileField</strong> and <strong class="source-inline">ImageField</strong> and refer to them in a template using the <strong class="source-inline">FileField.url</strong> attribute. We were able to reduce the amount of code we had to write by automatically building a <strong class="source-inline">ModelForm</strong> from a <strong class="source-inline">model</strong> instance. Finally, in the two activities at the end, we enhanced Bookr by adding a cover image and sample file to the <strong class="source-inline">Book</strong> model. In <em class="italic">Chapter 9</em>, <em class="italic">Sessions and Authentication</em>, we will learn how to add authentication to a Django application to protect it from unauthorized users.</p>
		</div>
		<div>
			<div id="_idContainer326" class="Content">
			</div>
		</div>
	</body></html>