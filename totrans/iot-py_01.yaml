- en: Chapter 1. Understanding and Setting up the Base IoT Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start our journey towards **Internet of Things** (**IoT**)
    with Python and the Intel Galileo Gen 2 board. Python is one of the most popular
    and versatile programming languages. You can use Python to create multiplatform
    desktops and Web, mobile, and scientific applications. You can work with huge
    amounts of data and develop the complex algorithms that are popular in Big Data
    scenarios with Python. There are thousands of Python packages, which allow you
    to extend Python capabilities to any kind of domain you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage our existing knowledge of Python and all of its packages to
    code the different pieces of our IoT ecosystem. We can use the object-oriented
    features, which we love from Python. in code that interacts with the Intel Galileo
    Gen 2 board and the electronic components connected to it. We can use the different
    packages that make it possible for us to easily run a Web server and provide a
    RESTful API. We can use all the packages that we already know to interact with
    databases, Web services, and different APIs. Python makes it easy for us to jump
    into the IoT world. We don't need to learn another programming language, we can
    use the one we already know and love.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will learn about the features included in the Intel Galileo Gen 2
    board. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the Intel Galileo Gen 2 board and its components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the Input/Output and the Arduino 1.0 pinout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the additional expansion and connectivity capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the buttons and the LEDs found in the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check and upgrade the board's firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Intel Galileo Gen 2 board and its components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to bring our ideas to life, easily. We want to be able to display a
    happy birthday message on a screen when we clap our hands. We want to collect
    huge amounts of data from the real world. We want to create wearables that keep
    track of all our activities during an entire day. We want to use the data to perform
    actions and interact with real-world elements. We want to use our mobile devices
    to control robots. We want to be able to determine whether the weather is hot
    or cold based on the data retrieved from a temperature sensor. We want to make
    decisions based on the values collected from a humidity sensor.
  prefs: []
  type: TYPE_NORMAL
- en: We want to measure how much of our favorite beverage is there in the cup and
    display the information on an LCD dot matrix display. We want to analyze all the
    data collected by things that are connected to the Internet. We want to become
    makers in the Internet of Things era by leveraging our existing Python programming
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Python as the main programming language to control the different
    components connected to an Intel Galileo Gen 2 board, specifically Python 2.7.3\.
    However, before we can become makers, it is necessary to understand some of this
    board's features.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we unbox an Intel Galileo Gen 2, we will find the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The Intel Galileo Gen 2 board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 12 VDC (Volts direct current), 1.5 A (Amperes) power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the front view for an unboxed Intel Galileo Gen 2
    board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's have a look at the front view of the board for a few minutes. We will
    notice many familiar elements, such as an Ethernet jack, host USB port, and many
    labeled pins. In case we have previous experience with an Arduino UNO R3 board,
    we will easily realize that many elements are in the same locations as in that
    board. In case we have previous experience with embedded systems and electronics,
    we will easily realize that the board provides the necessary pins (SCL and SDA)
    to talk with the devices that support the I²C bus. In case we don't have any previous
    experience, we will learn what we can do with all these pins in the examples included
    in the forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The next image shows the graphical representation of the Intel Galileo Gen 2
    board in the Fritzing open source and free software. As you might notice, the
    graphical representation includes only the important pieces of the board and all
    the things we can wire and connect, with the necessary labels to help recognize
    them easily. We will use the Fritzing diagrams to illustrate all the wirings that
    we must do in order to complete each sample project through the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the latest version of Fritzing from [http://fritzing.org/download/](http://fritzing.org/download/).
    Fritzing runs on Windows, Mac OS X and Linux. You will find the Fritzing sketches
    for all the examples included throughout the book in files with an FZZ extension
    (`*.fzz`) as a part of the code files that you can download for this book. The
    files are saved with Fritzing 0.92\. Thus, you can open the sketches in Fritzing,
    check the breadboard view, and make any changes to it based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The next image shows the electronic schematic representation of the Intel Galileo
    Gen 2 board, that is, the symbolic representation of the board to make it easy
    to understand the interconnections of the electronic circuits related to the board.
    The electronic schematic is also known as circuit diagram or electrical diagram.
    The symbol includes all the pins provided by the board shown as connectors. We
    can easily recognize the many labels that appear on the board as labels for each
    connector in the symbol. Fritzing allows us to work with both the breadboard and
    the electronic schematic representation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you open the Fritzing file for each sample included in the book, you will
    be able to easily switch from the breadboard view to the schematic view by clicking
    on either the Breadboard or the Schematic buttons located at the top of the main
    Fritzing window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next image shows the system block diagram for the Intel Galileo Gen 2 board.
    The diagram is a part of the content included in the Intel Galileo Gen 2 design
    document: [http://www.intel.com/content/dam/www/public/us/en/documents/guides/galileo-g2-schematic.pdf](http://www.intel.com/content/dam/www/public/us/en/documents/guides/galileo-g2-schematic.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Intel Galileo Gen 2 board is an Arduino certified embedded computer that
    we will use to develop and prototype our IoT projects. The board is based on Intel
    architecture and uses an Intel Quark SoC X1000 system on a chip, known as SoC
    or application processor. The SoC is a single-core and single-threaded application
    processor that is compatible with the Intel Pentium 32-bit **instruction set architecture**
    (**ISA**). Its operating speed is up to 400 MHz. The following image shows the
    SoC, located approximately at the center of the board. The following page provides
    detailed information about the Intel Quark SoC X1000: [http://ark.intel.com/products/79084/Intel-Quark-SoC-X1000-16K-Cache-400-MHz](http://ark.intel.com/products/79084/Intel-Quark-SoC-X1000-16K-Cache-400-MHz)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the right-hand side of the CPU, the board has two integrated circuits that
    provide 256 MB of DDR3 **RAM** (short for **Random Access Memory**) memory. The
    operating system and Python will be able to work with this RAM memory. As it happens
    in any computer, RAM memory loses its information after we turn off the board.
    Thus, we say that RAM is volatile, as the data stored in it is lost when the memory
    isn't powered. The following image shows the DDR3 memory chips.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel Galileo Gen 2 board and its components](img/B05042_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, the board provides access to the following onboard memories:'
  prefs: []
  type: TYPE_NORMAL
- en: 512 KB embedded **SRAM** (short for **Static Random Access Memory**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 MB Legacy SPI NOR Flash, non-volatile memory. Its goal is to store the board's
    firmware and sketches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11 KB **EEPROM** (short for **Electrically Erasable Programmable Read-Only Memory**).
    It is non-volatile and we can store data in it for our own purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing the Input/Output and the Arduino 1.0 pinout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The board provides the following I/O pins:'
  prefs: []
  type: TYPE_NORMAL
- en: 14 digital I/O pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six **PWM** (short for **Pulse Width Modulation**) output pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six analog input pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The board is hardware and software pin-compatible with Arduino shields designed
    for the Arduino Uno R3\. The 14 digital I/O pins numbered from 0 to 13 are located
    in the upper-right corner of the board and they also include the adjacent **AREF**
    and **GND** pins, as in the Arduino Uno R3\. The pins configuration is also known
    as Arduino 1.0 pinout.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shields are boards that we can plug on top of the Intel Galileo Gen 2 board
    to extend its capabilities. For example, you can plug a shield that provides two
    high current motor controllers or a shield that adds an LED matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens in the Arduino Uno R3, we can use six of these digital I/O pins
    as PWM (Pulse Width Modulation) output pins. Specifically, the pins labeled with
    a tilde symbol (**~**) as a prefix to the number have this capability: pins **~11**,
    **~10**, **~9**, **~6**, **~5** and **~3**. The following are the pins that compose
    the header from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: SCL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AREF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TX->1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RX<-0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next image shows the 14 digital I/O pins and the six PWM output pins labeled
    with a tilde symbol (**~**) as a prefix for the number. The first two pins, starting
    from the left are for the two I²C bus lines: **SCL** (**Serial CLock**) and **SDA**
    (**Serial DAta**). The last two pins, starting from the left, labeled **TX->1**
    and **RX<-0** are the UART 0 port pins. A **UART** port stands for **Universal
    Asynchronous Receiver/Transmitter**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the Input/Output and the Arduino 1.0 pinout](img/B05042_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The six analogous input pins numbered from **A0** to **A5** are located in
    the lower-right corner of the board, as in the Arduino Uno R3\. On the left-hand
    side of the analog input pins, we can see the following power pins that compose
    the power header:'
  prefs: []
  type: TYPE_NORMAL
- en: POWER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IOREF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.3V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VIN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **VIN** pin in the power header provides the input voltage that is supplied
    to the board through its power jack. The power supply included in the box provides
    12V. However, the board can operate with an input voltage ranging from 7V to 15V.
    The board also provides support to Power over Ethernet, also known as PoE, this
    passes the electrical power to the board along with data on the Ethernet cable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the power pins, also known as power headers,
    and the six analog input pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the Input/Output and the Arduino 1.0 pinout](img/B05042_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The board includes a jumper labeled **IOREF** that allows us to select between
    a 3.3V or 5V shield operation and provides voltage-level translation to all the
    I/O pins. Based on the jumper position, the board can work with either a 3.3V
    or 5V Arduino shield. By default, the **IOREF** jumper is set to the 5V position,
    and therefore, the initial setting allows us to work with 5V shields. The following
    screenshot shows the **IOREF** jumper set to the 5V position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the Input/Output and the Arduino 1.0 pinout](img/B05042_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **IOREF** pin in the power header provides the operational voltage reference
    based on the **IOREF** jumper position. Thus, based on the **IOREF** jumper position,
    the voltage reference in the **IOREF** pin can be either 5V or 3.3V.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the board, there is a 6 pin, specifically 2x3 pin,
    ICSP (In-Circuit Serial Programming) header, labeled **ICSP**. The location of
    this header is also compatible with the Arduino 1.0 pinout. The following screenshot
    shows the ICSP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the Input/Output and the Arduino 1.0 pinout](img/B05042_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recognizing additional expansion and connectivity capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The power jack is located on the left-hand side of the board and it is labeled
    **PWR**. Below the power jack, there is a microSD card connector, labeled **SDIO**.
    The microSD card connector supports microSD cards with a maximum support capacity
    of 32 GB. We will use the microSD card as our main storage to store the operating
    system, Python, and the necessary libraries. The board can boot from the microSD
    card. Thus, we can think of the microSD card as our main hard drive to work with
    IoT projects. The following screenshot shows the power jack with the power supply
    connected to it and the microSD card connector with an 8 GB microSD card being
    connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing additional expansion and connectivity capabilities](img/B05042_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Ethernet jack is located in the upper-left corner of the board, labeled
    **10/100 LAN**, above the power jack. The Ethernet port supports both the Ethernet
    and Fast Ethernet standards, and therefore, it can work with either 10 Mbps or
    100 Mbps nominal throughput rates. The Ethernet port is extremely useful to connect
    the board to our LAN and access it through an IP address. There is an adhesive
    label with the MAC (Media Access Control) address for the Ethernet onboard network
    interface card. The MAC address is also known as physical address.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows this adhesive label on the Ethernet jacket and
    a cable plugged in it. The MAC address for the board shown in the image is A1B2C3D4E5F6\.
    If we use the convention that expresses a MAC address as six groups of two hexadecimal
    digits separated by colons (:), the MAC address will be expressed as A1:B2:C3:D4:E5:F6\.
    The MAC address is extremely useful to identify the board in our LAN DHCP client
    list. For security reasons, the original MAC address has been erased and we use
    a fake MAC address for our example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing additional expansion and connectivity capabilities](img/B05042_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A six pin, 3.3V USB TTL UART header is located next to the Ethernet jack, specifically
    UART 1, the second UART port in the board. The six pin, 3.3V USB TTL UART header
    has the following labels on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: CTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TXO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RXI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No label (empty)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to the Ethernet jack and the UART header, there is a micro USB Type B connection,
    labeled **USB CLIENT**. We can use this connection to connect the computer to
    the board, in order to perform firmware updates or transfer sketches.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, it is important to know that you cannot power the board off USB. In
    addition to it, never connect a cable to the micro USB Type B connection before
    you connect the power supply to the board.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the micro USB connection, there is a USB 2.0 host connector, labeled
    **USB HOST**. The connector supports a maximum of 128 USB endpoint devices. We
    can use this connector to plug a USB thumb drive for additional storage, USB keyboard,
    USB mouse, or any other USB device that we might need. However, we must consider
    the necessary drivers and their compatibility with the Linux distribution that
    we will be using with the board, before we plug any device.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows the UART header, micro USB connector, and the USB
    2.0 port, from left to right, next to the Ethernet jack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing additional expansion and connectivity capabilities](img/B05042_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following image shows the side view with all the connectors and jacks. From
    left to right, the USB 2.0 port, the micro USB connector, the UART header, and
    the Ethernet jack with the green (SPEED) and yellow (LINK) LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing additional expansion and connectivity capabilities](img/B05042_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The back of the board provides a mini PCI Express slot, also known as the mPICe
    slot, compliant with PCIe 2.0 features, labeled **PCIE**. The slot is compatible
    with both full size and half size mPCIe modules that we can connect to the board
    to expand its capabilities. The half size mPCIe module requires an adapter to
    be connected to the slot on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to add another USB host port via the mPCIe slot. The mPCIe slot
    is extremely useful to provide WiFi, Bluetooth, and other types of connectivity
    that aren't included as onboard features.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the mPCIe slot, there is a 10-pin JTAG (Joint Test Action Group) header,
    labeled **JTAG**. It is possible to use the JTAG interface for debugging purposes
    in combination with debugging software that supports the Intel Quark SoC X1000
    application processor, such as the free and open source on-chip debugging software
    OpenOCD.
  prefs: []
  type: TYPE_NORMAL
- en: The next image shows the back-view for the board with mPCIe slot and the JTAG
    header.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing additional expansion and connectivity capabilities](img/B05042_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the buttons and the LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The front of the board provides two buttons located at the bottom labeled **REBOOT**
    and **RESET**. The following image shows these two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the buttons and the LEDs](img/B05042_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The button labeled **REBOOT** resets the Intel Quark SoC X1000 application processor.
    The button labeled **RESET** resets the sketch and any shield attached to the
    board. In this book, we won't be working with the Arduino sketches but we might
    need to reset a shield.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five rectangular LEDs located next to the USB 2.0 host connector:
    two LEDs on the left-hand side of the connector and three LEDs on the right-hand
    side. The following are the labels and the meaning of the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OC**: The LED signals over-current when the board is powered through the
    micro USB connector. However, this feature is not enabled on Intel Galileo Gen
    2 boards, and therefore, we just have the LED turned off. If the LED turns on,
    it means that the board is not working OK or the power supply is failing. This
    LED usually turns on when the board is bricked. We say a board is bricked when
    it doesn''t work anymore and is technologically as useful as a brick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USB**: It is the micro USB ready LED. The LED turns on after the board has
    finished the boot process and allows us to connect the micro USB cable to the
    micro USB connection labeled **USB CLIENT**. We should never connect a cable to
    the micro USB connection before this LED turns on because we can damage the board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: The LED is connected to pin 13 of the digital I/O pins, and therefore,
    a high level sent to pin 13 will turn on this LED and a low level will turn it
    off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ON**: It is a power LED and indicates that the board is connected to the
    power supply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SD**: The LED indicates I/O activity with the microSD card connector, labeled
    **SDIO**, and therefore, this LED will blink whenever the board is reading or
    writing on the microSD card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following image shows the **OC** and **USB** LEDs on the left-hand side
    of the USB 2.0 host connector and the **L**, **ON** and **SD** LEDs on its right-hand
    side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the buttons and the LEDs](img/B05042_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The board includes an integrated real-time clock, known as RTC. It is possible
    to connect a 3V coin-cell battery to keep the RTC operation between turn-on cycles.
    Unluckily, the battery is not included in the box. The two RTC coin-cell connector
    pins are located in the lower-left corner of the Intel Quark SoC X1000 application
    processor, labeled **COIN** and with a battery icon. The next image shows the
    two RTC coin-cell connector pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the buttons and the LEDs](img/B05042_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking and upgrading the board's firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the original firmware included in the board is the latest one available
    for Intel Galileo Gen 2\. However, in some cases, we might need a firmware update,
    and therefore it is always convenient to make sure that we are working with the
    latest available version for the onboard firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firmware updates solve bugs and compatibility issues. Thus, it is always convenient
    to work with the latest firmware. However, in case you don't feel sure about following
    the procedure to update the firmware, it is convenient to keep the version that
    came with the board. A wrong procedure while updating the firmware or a power
    loss during the process might damage the board, that is, it might transform the
    board into a bricked one. You definitely don't want this to happen to your board.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check the current firmware version and check whether it is necessary
    to upgrade the board''s firmware, you must follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Intel Galileo Firmware and Drivers download page at [http://downloadcenter.intel.com/download/24748/Intel-Galileo-Firmware-and-Drivers-1-0-4](http://downloadcenter.intel.com/download/24748/Intel-Galileo-Firmware-and-Drivers-1-0-4).
    The URL is for the latest firmware version at the time this book has been written:
    1.0.4\. However, always make sure that you are downloading the latest available
    version from Intel Drivers & Software Download Center. In case the version is
    higher than 1.0.4, the procedure will be the same but you just need to replace
    1.0.4 with the new version numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Web browser will display the available downloads for the supported operating
    systems. The Web page doesn''t detect the operating system you are using, and
    therefore, it offers the downloads for all the supported operating systems: Windows,
    Mac OS X, and Linux. The following image shows the contents for the Web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking and upgrading the board''s firmware](img/B05042_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will find a PDF user guide under **OS Independent**: **IntelGalileoFirmwareUpdaterUserGuide-1.0.4.pdf**.
    Click on the button, read and accept the Intel Software License Agreement, and
    read the Intel Galileo Firmware Updater Tool documentation. The documentation
    includes all the necessary steps to install the drivers in Windows and Linux.
    The Mac OS X doesn''t require any driver installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you install the drivers or start the process to check the firmware version
    in your board, remove all the connections from the board, such as the microUSB
    cable and any USB device plugged into the USB 2.0 host connector. Remove any sketches
    and also the microSD card. Your Intel Galileo Gen 2 board should be empty just
    as when you unboxed it.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the power supply to the board and wait a few seconds until the rectangular
    LED labeled **USB** turns on. Once this LED is turned on, the boot process has
    already finished and it is safe to connect a USB Type A to Micro-B USB cable from
    your computer to the micro USB connector labeled **USB CLIENT** in the board.
    Unluckily, the cable isn't included within the board's box. The following image
    shows an Intel Galileo Gen 2 board with the connections done and the firmware
    updater tool running on Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking and upgrading the board''s firmware](img/B05042_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In case you are working with either Windows or Linux, follow the procedure to
    install the necessary drivers as explained in the **IntelGalileoFirmwareUpdaterUserGuide-1.0.4.pdf**
    document.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You already have the board connected to your computer, and therefore, you can
    skip this step in the document. In fact, many versions of this document didn't
    explain that you had to wait for the USB LED to turn on before you can connect
    the board to a computer through the micro USB connector and that caused many boards
    to have unexpected problems.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the drivers installed in your computer and your board is connected
    to it, you can download and execute the ZIP file of the Intel Galileo Firmware
    Updater for your operating system. For Windows, the file is **IntelGalileoFirmwareUpdater-1.0.4-Windows.zip**.
    For Mac OS X, the file is **IntelGalileoFirmwareUpdater-1.0.4-OSX.zip**. You usually
    have to scroll down the Web page to find the appropriate file for your operating
    system. Once you click on the desired file button, it is necessary to read and
    accept the Intel Software License Agreement before you can download the zip file.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, download the **IntelGalileoFirmwareUpdater-1.0.4-Windows.zip** file,
    open it, and execute the **firmware-updater-1.0.4.exe** application included in
    the zip file. The **Intel Galileo Firmware Updater Tool** window will appear and
    it will automatically select the virtual COM port number, such as **COM3**, generated
    by the previously installed driver in the **Port** dropdown. The application will
    communicate with the board and then display the firmware version included with
    the tool in **Update Firmware Version** and the current board's firmware version
    in **Current Board Firmware**.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows the Intel Galileo Firmware Updater Tool running on
    Windows 10\. In this case, the tool has the newest version for the firmware because
    it offers version **1.0.4** and the current board's firmware is **1.0.2**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking and upgrading the board''s firmware](img/B05042_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Mac OS X, download the **IntelGalileoFirmwareUpdater-1.0.4- OSX.zip** file
    and then execute the downloaded **Firmware Updater** application. Take into account
    that you might need to authorize the operating system to run the application based
    on your security settings and your OS X version. The **Intel Galileo Firmware
    Updater Tool** window will appear and it will automatically select the generated
    USB modem device for the connected board, such as **/dev/cu.usbmodem1411**, in
    the **Port** dropdown. The application will communicate with the board and then
    it will display the firmware version included with the tool in **Update Firmware
    Version** and the current board's firmware version in **Current Board Firmware**.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows the Intel Galileo Firmware Updater Tool running on
    OS X El Capitan. In this case, the tool has the newest version for the firmware
    because it offers version **1.0.4** and the current board's firmware is **1.0.2**,
    as it happened with the Windows version.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking and upgrading the board''s firmware](img/B05042_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In case you decide that you need and want to update the firmware, considering
    the previously explained risks, you just need to click on the **Update Firmware**
    button and wait for the tool to indicate that the process has finished. The procedure
    is the same for either Windows or Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't unplug the USB cable from your computer connected to the board, don't
    disconnect the power supply from the board, and don't close the application until
    the tool indicates that the firmware update has finished. The safest way to perform
    a firmware update is to plug the power supply to a UPS (Uninterruptible Power
    Supply) to protect it from a power failure during the firmware update process.
  prefs: []
  type: TYPE_NORMAL
- en: Once the firmware update process has finished and the tool displays that you
    have the same firmware version on the board that the firmware version that the
    tool offers, you can close the application and disconnect the USB cable from your
    computer and the board. Make sure that you don't leave the USB cable connected
    to your board and then unplug the power supply.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Intel Galileo Gen 2 board includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WiFi connectivity onboard with three antennas.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ethernet connectivity onboard.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bluetooth connectivity onboard.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Intel Galileo Gen 2 board is hardware and pin compatible with a wide range
    of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arduino Uno R3 shields.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Arduino Pi shields.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Raspberry Pi shields.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The jumper labeled IOREF allows us to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select between 3.5V or 7V shield operation and provide voltage-level translation
    to all the I/O pins.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select between 3.3V or 5V shield operation and provide voltage-level translation
    to all the I/O pins.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the board.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The LED labeled L is connected to the following pins of the digital I/O pins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 11`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 12`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 13`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The back of the board provides the following slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mini PCI Express.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PCMCIA.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Thunderbolt.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt the different features offered by the Intel Galileo
    Gen 2 board. We visualized the different components of the board and we understood
    the meaning of the different pins, LEDs, and connectors. We also learned to check
    the board's firmware version and to update it in case it is necessary to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we recognize the different components of the board, we have to prepare
    it to work with Python as our main programming language, which is what we are
    going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
