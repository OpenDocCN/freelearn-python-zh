- en: '*Chapter 11:* Programming Tools and Methodologies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章：编程工具和方法论*'
- en: Now, it's time for us to take a closer look at the development cycle. Producing
    software is more than just writing code. We must plan what will be coded, write
    the code, integrate the code we write with already existing code, share our code
    with other developers, test the code, deploy the code so that the application
    can be accessed by the users, add new features to the application, and fix bugs
    and errors that will show up in the code that has been released.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们更深入地了解开发周期的时候了。生产软件不仅仅是编写代码。我们必须计划将要编写的代码，编写代码，将编写的代码与现有代码集成，与其他开发者共享代码，测试代码，部署代码以便用户可以访问应用程序，向应用程序添加新功能，并修复在已发布代码中出现的错误和漏洞。
- en: To accomplish this, a development team will typically use different tools and
    methodologies for how things will be done and in what order.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，开发团队通常会使用不同的工具和方法来决定如何进行以及顺序。
- en: In this chapter, we will look at all the components that are part of the development
    process that is not the actual coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨所有构成开发过程但不是实际编码的组成部分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding what a version control system is and what it can be used for
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解版本控制系统的概念及其用途
- en: Understanding unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单元测试
- en: Understanding integration tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解集成测试
- en: Understanding the concept of a release
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解版本的概念
- en: Understanding software deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件部署
- en: Understanding code maintenance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码维护
- en: Understanding software development process methodologies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件开发过程方法论
- en: 'We have lots to cover, so let''s start with an essential tool in software development:
    version control systems.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要介绍，所以让我们从软件开发中的一个基本工具：版本控制系统开始。
- en: Understanding version control systems
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解版本控制系统
- en: A **version control system** (**VCS**) is used to manage changes in documents,
    computer programs, or other collections of files. They are used by programmers
    to manage different revisions of their code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制系统**（**VCS**）用于管理文档、计算机程序或其他文件集合中的更改。程序员使用它们来管理其代码的不同版本。'
- en: It is possible to restore earlier reversions if needed. This makes it safer
    to edit files, as we always have a way for us to restore what we had if we decide
    that the changes we made need to be reset.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以恢复早期版本。这使得编辑文件更加安全，因为我们总有办法在决定需要重置所做的更改时恢复我们之前的状态。
- en: VCSs are also used so that developers can work together on the same project
    and, in a safe manner, work in the same source code files. Version control systems
    also keep track of who changed what in a document, and when the change was made.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: VCS也被用于让开发者能够共同在一个项目上工作，并且以安全的方式在相同的源代码文件中工作。版本控制系统还跟踪谁在文档中更改了什么，以及何时进行了更改。
- en: Files that are version controlled are stored in what is called a **repository**.
    When changes are made to a file, the user of the VCS can commit these changes
    to the repository, and by extension of that, create a reversion point. It is at
    these points where the version control system takes a snapshot of all the changes
    made.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 受版本控制的文件存储在称为**仓库**的地方。当对文件进行更改时，VCS用户可以将这些更改提交到仓库，并由此创建一个回滚点。在这些点上，版本控制系统会对所有更改进行快照。
- en: 'To illustrate how this works, we can use one of the most popular version control
    systems available: Git. Git was created by Linus Torvalds, the creator of Linux,
    in 2005\. It was initially created to be used by the programmers who were working
    on the Linux kernel code, but soon gained popularity outside the Linux project.
    Today, it is by far the most popular version control system.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，我们可以使用最流行的版本控制系统之一：Git。Git由Linux的创造者林纳斯·托瓦兹（Linus Torvalds）于2005年创建。最初是为了让在Linux内核代码上工作的程序员使用，但很快在Linux项目之外也获得了流行。如今，它是最受欢迎的版本控制系统。
- en: 'Let''s start by writing some code. Let''s say we have this code in a file called
    `calc.code`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一些代码开始。假设我们在一个名为`calc.code`的文件中有以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this file in an empty folder. We can now use the GIT software to create
    a repository. This means that we can start to version control the files within
    this folder. From the command line, we can do this by writing the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存在一个空文件夹中。现在我们可以使用GIT软件创建一个仓库。这意味着我们可以开始对这个文件夹内的文件进行版本控制。在命令行中，我们可以通过编写以下代码来完成：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, nothing is version controlled yet. We will need to tell GIT
    what files we want to add to version control. We can do that with the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有任何内容被版本控制。我们需要告诉GIT我们想要添加到版本控制中的文件。我们可以使用以下命令来做到这一点：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our file is now staged. This means that its changes will be tracked, but we
    will need to do one more thing to record the changes that have been made to our
    file. What we''ll do is called a **commit**. A commit will record our changes
    and store them in our repository. Let''s do that with the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的文件已经准备好。这意味着它的更改将被跟踪，但我们需要做一件事来记录对文件所做的更改。我们将要做的是**提交**。提交将记录我们的更改并将它们存储在我们的仓库中。让我们使用以下命令来执行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`-m` tells `git` that we will provide a commit message, and the message is
    what comes within the quotes. The messages will help us see what is changed in
    a commit, so we should take some time to come up with descriptive messages.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`告诉`git`我们将提供一个提交信息，信息就是引号内的内容。这些信息将帮助我们查看提交中的更改，因此我们应该花些时间来想出描述性的信息。'
- en: 'The changes we have made are now stored on what is called the *master branch*.
    The following diagram illustrates what this looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改现在存储在被称为*主分支*的地方。以下图表展示了它的样子：
- en: '![Figure 11.1 – The master branch after our initial commit](img/Figure_11.1_B15554.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 初始提交后的主分支](img/Figure_11.1_B15554.jpg)'
- en: Figure 11.1 – The master branch after our initial commit
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 初始提交后的主分支
- en: We would now like to continue to work on our program and add more code to this
    file. To make life a little bit safer, we can create a new branch and make our
    changes in this branch. We will soon see why this might be a good idea.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想继续我们的程序并添加更多代码到这个文件中。为了使生活更加安全，我们可以创建一个新分支并在该分支中进行更改。我们很快就会看到这可能是为什么。
- en: 'To create a new branch called `subtract`, we can use the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为`subtract`的新分支，我们可以使用以下命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Creating a new branch will give us an exact copy of the branch we created it
    from, which in this case is the master branch. This can be illustrated as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新分支将给我们一个从该分支创建的确切副本，在这个例子中是主分支。这可以如下表示：
- en: '![Figure 11.2 – Creating a new branch called subtract from the master branch](img/Figure_11.2_B15554.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 从主分支创建名为subtract的新分支](img/Figure_11.2_B15554.jpg)'
- en: Figure 11.2 – Creating a new branch called subtract from the master branch
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 从主分支创建名为subtract的新分支
- en: 'We are still on the master branch, so any changes we make will be on this branch.
    So, before we do anything else, we should switch branches. We can do that with
    the `checkout` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在主分支上，所以我们将做的任何更改都将在这个分支上。因此，在我们做任何其他事情之前，我们应该切换分支。我们可以使用`checkout`命令来做到这一点：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are now on the `subtract` branch. Now, we can update our source code file,
    so let''s add another function, making the file look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在`subtract`分支上了。现在，我们可以更新我们的源代码文件，所以让我们添加另一个函数，使文件看起来像这样：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we save these changes, we can add the file to the staging area and commit
    the changes with the following commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存这些更改，我们可以将文件添加到暂存区，并使用以下命令提交更改：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can illustrate this commit with another circle on the submit branch, as
    shown in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用提交分支上的另一个圆圈来表示这个提交，如下面的图表所示：
- en: '![Figure 11.3 – Committing to our new branch](img/Figure_11.3_B15554.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 向我们的新分支提交](img/Figure_11.3_B15554.jpg)'
- en: Figure 11.3 – Committing to our new branch
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 向我们的新分支提交
- en: 'Now that we have committed our changes to GIT, we can switch branches. Let''s
    do that with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将更改提交到GIT中，我们可以切换分支。让我们使用以下命令来执行：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we open our file now, we will see the following content:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开文件，我们将看到以下内容：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The changes we made are not here. This is because these changes are not in
    the master branch. Keeping the file open in our editor, we can now switch back
    to the `subtract` branch by using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改不在这里。这是因为这些更改不在主分支上。在编辑器中保持文件打开，我们现在可以通过使用以下命令切换回`subtract`分支：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like magic, the changes we made to the file are back, and the `subtract` function
    is as we left it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，我们对文件所做的更改又回来了，`subtract`函数就像我们离开时一样：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This illustrates that if we, for some reason, decide that the changes we made
    were no good, we can always go back to our master branch, and everything will
    be like it was before we started. However, if we, on the other hand, are happy
    with the changes, we can now bring the two branches together. In GIT, this is
    called a **merge**. The first thing we should do before merging the two branches
    is make sure that the branch we want to merge is active. In this case, it is the
    master branch, so we write the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明，如果我们出于某种原因决定我们所做的更改不好，我们总是可以回到我们的master分支，一切都会像我们开始之前一样。然而，如果我们对所做的更改感到满意，我们现在可以将两个分支合并在一起。在GIT中，这被称为**合并**。在合并两个分支之前，我们首先应该确保我们想要合并的分支是活动的。在这种情况下，它是master分支，所以我们写下以下内容：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are ready to merge the changes we made back into the master branch.
    We can do this with the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好将我们所做的更改合并回master分支。我们可以使用以下命令来完成此操作：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means we take the changes made in the branch called `subtract` and `merge`
    it with the content of the current branch, `master`. We can illustrate this with
    the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们取名为`subtract`的分支所做的更改，并将其与当前分支`master`的内容合并。我们可以用以下图表来表示这一点：
- en: '![Figure 11.4 – Merging the subtract branch with the master branch](img/Figure_11.4_B15554.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 将subtract分支与master分支合并](img/Figure_11.4_B15554.jpg)'
- en: Figure 11.4 – Merging the subtract branch with the master branch
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 将subtract分支与master分支合并
- en: This is how we can use version control with GIT on our local machine. Now, let's
    see how we can use it to collaborate with other programmers who work on the same
    project as us. For that, we will need not only our local repository but also a
    central repository that we can use to update the other on the changes we make.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在本地机器上使用GIT进行版本控制的方法。现在，让我们看看我们如何使用它来与其他程序员协作，他们与我们一样在同一个项目上工作。为此，我们不仅需要我们的本地仓库，还需要一个中央仓库，我们可以用它来更新我们所做的更改。
- en: Let's assume that Alice and Bob are both working on the same project and want
    to use GIT to update each other on the changes they make to any files in the project.
    They will not only have their local GIT repositories, as we saw in the preceding
    example, but they will also connect to a centralized repository. Any changes they
    make can now be pushed to this repository, and they can also pull down any changes
    the other person made from that repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设爱丽丝和鲍勃都在同一个项目上工作，并想使用GIT来更新他们在项目中任何文件所做的更改。他们不仅会有我们之前看到的本地GIT仓库，而且他们还会连接到一个集中式仓库。他们所做的任何更改现在都可以推送到这个仓库，他们也可以从该仓库拉取其他人所做的任何更改。
- en: 'This will look something like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能如下所示：
- en: '![Figure 11.5 – Two programmers connected to a central repository](img/Figure_11.5_B15554.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 两位程序员连接到中央仓库](img/Figure_11.5_B15554.jpg)'
- en: Figure 11.5 – Two programmers connected to a central repository
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 两位程序员连接到中央仓库
- en: 'We can now assume that they will both work on the same file we saw previously,
    `calc.code`, and that it has the same content as we left it with, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以假设他们都将工作在我们之前看到的同一个文件`calc.code`上，并且它具有我们离开时的相同内容，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The central repository is often referred to as the `multiply` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 中央仓库通常被称为`multiply`函数：
- en: 'The first thing she should do is pull down the latest version from the central
    repository (origin) with the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 她首先应该做的是使用以下命令从中央仓库（origin）拉取最新版本：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'She now has the latest version, and she can begin implementing her function.
    She decides to do this in a new branch, so she executes the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 她现在有了最新版本，她可以开始实现她的功能。她决定在一个新的分支上做这件事，因此她执行了以下命令：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'She will then switch to this branch with the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，她将使用以下命令切换到这个分支：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, she can make the necessary changes, so she adds the following code to
    the file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，她可以做出必要的更改，因此她将以下代码添加到文件中：
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's leave Alice here and check what Bob is doing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让爱丽丝留在这里，看看鲍勃在做什么。
- en: 'While Alice has started her work, Bob decides he wants to create a `divide`
    function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当爱丽丝开始她的工作时，鲍勃决定他想创建一个`divide`函数：
- en: 'Just like Alice, he will pull down the latest version of the `master` branch
    and create a new branch called `divide`, switch to it, and then change the `calc.code`
    file, so that it looks as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像爱丽丝一样，他将拉取`master`分支的最新版本，创建一个名为`divide`的新分支，切换到它，然后更改`calc.code`文件，使其看起来如下：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, Alice is happy with her changes, so she commits them to her branch
    and merges her branch with the master.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个时候，爱丽丝对她的更改感到满意，因此她将它们提交到她的分支，并将她的分支与主分支合并。
- en: 'Now, she wants to push these changes to the central repository. Before she
    does that, though, she wants to make sure that changes have been made to the central
    repository. So, first, she tries to pull down any changes to her repository with
    the same command she ran previously:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，她想要将这些更改推送到中央仓库。不过，在她这样做之前，她想要确保中央仓库已经进行了更改。因此，首先，她尝试使用之前运行的相同命令从她的仓库中拉取任何更改：
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since nothing has happened to the central repository since her last pull, nothing
    will happen. She can now push her changes with the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于自她上次拉取以来中央仓库没有发生任何变化，所以不会有任何变化。现在，她可以使用以下命令推送她的更改：
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, her changes are stored in the central repository. At this point, her local
    version of the `master` branch and the version stored in the central repository
    are identical.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，她的更改已存储在中央仓库中。在这个时候，她的本地`master`分支版本和存储在中央仓库中的版本是相同的。
- en: 'Let''s go back to Bob, who has finished his function. He commits his changes
    to his local repository in his branch and merges it into the master branch. Now,
    he is ready to commit his changes to the central repository:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到鲍勃，他已经完成了他的功能。他在自己的分支中将更改提交到本地仓库，并将其合并到主分支中。现在，他准备将更改提交到中央仓库：
- en: 'Just like Alice, first, he wants to make sure that he has the latest changes
    from the central repository, so he issues a `pull` command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像爱丽丝一样，首先，他想要确保他已经从中央仓库获取了最新的更改，因此他发出一个`pull`命令：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This time, things will not go so well. He gets a message that there has been
    a merge conflict. What''s that? He opens the code file, and he now sees this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，事情不会那么顺利。他收到一条消息，表示发生了合并冲突。那是什么？他打开代码文件，现在他看到这个：
- en: '[PRE23]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What happened was that he and Alice made changes to the same file on the same
    line, which is at the end of the file in this case.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生的事情是他和爱丽丝在同一行对同一文件进行了更改，在这种情况下是在文件的末尾。
- en: GIT became confused due to this and needs help to decide what will be in the
    file.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个原因，GIT变得困惑，需要帮助来决定文件中将包含什么。
- en: Bob looks at this and understands that Alice has added a function to the same
    location in the file that he did, and he understands that both functions should
    be there.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鲍勃看了看，理解了爱丽丝在文件中添加了一个函数，与他在同一位置添加的函数相同，他理解这两个函数都应该在那里。
- en: The `<<<<<<< HEAD` marker indicates the beginning of the conflict. What is between
    that line and the `=======` line is the changes he pulled down. The code between
    `=======` and  `>>>>>>> div` are his changes.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<<<<<<< HEAD`标记表示冲突的开始。在那一行和`=======`行之间的内容是他拉取的更改。在`=======`和`>>>>>>> div`之间的代码是他的更改。'
- en: 'Since he decides that both functions should be in this file, he removes the
    three marker lines from the file, so it now looks like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于他决定这两个函数都应该在这个文件中，他从文件中删除了三条标记行，所以现在它看起来像这样：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: He can now commit his changes to his local repository and then push the changes
    so that Alice can get the changes later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 他现在可以将更改提交到本地仓库，然后推送更改，以便爱丽丝稍后能够获取这些更改。
- en: This illustrates how a version control system can be used to share work between
    multiple programmers in a project. There are, of course, many other aspects of
    version control systems that we did not cover here, but now, you at least have
    an idea about what a version control system can do for you and how it can be used
    to share work with others.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了版本控制系统如何被用来在项目中的多个程序员之间共享工作。当然，版本控制系统还有许多其他方面我们没有在这里涵盖，但现在，你至少对版本控制系统能为你做什么以及如何用来与他人共享工作有一个概念。
- en: This tool is used throughout the development process. Now, let's look at what
    we do when the code is written, as well as how we can make sure that it is working
    before we push it to the central repository.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具在整个开发过程中都被使用。现在，让我们看看代码编写时我们做什么，以及我们如何确保在将其推送到中央仓库之前它能够正常工作。
- en: It's now time for unit testing!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行单元测试的时候了！
- en: Unit testing
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Testing our code is essential so that we can verify that it does what it should.
    We will also use tests to make sure that any changes we make to the code have
    not made things that previously worked stop working or behave in an undesired
    way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的代码是必要的，这样我们就可以验证它是否按预期工作。我们还将使用测试来确保我们对代码所做的任何更改都没有使之前工作正常的功能停止工作或以不期望的方式表现。
- en: Several kinds of testing can be done on our code, and the first type of test
    we will look at is called a **unit test**. The unit part indicates that the test
    will be done on a separate unit of our code. This is typically at a function level.
    This means that we will try to isolate one single function (or another small unit
    of code) and run our tests on just that unit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的代码进行几种测试，我们将首先查看的一种测试类型称为**单元测试**。单元部分表示测试将在我们的代码的单独单元上进行。这通常是在函数级别。这意味着我们将尝试隔离一个单独的函数（或另一个小的代码单元），并仅在这一点上运行我们的测试。
- en: These tests are typically written by the developer of the code unit to be tested
    and are often automated. This means that as soon as a block of code is ready to
    be committed to the version control system, it must first pass the unit test written
    for it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试通常由要测试的代码单元的开发者编写，并且通常是自动化的。这意味着一旦一段代码准备好提交到版本控制系统，它必须首先通过为其编写的单元测试。
- en: Since the unit test only tests a single code unit, they are typically rather
    trivial. To test our `calc` functions, we must first decide what we want to test.
    First, we can set up some test cases for valid input and match these inputs to
    some expected results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试只测试单个代码单元，因此它们通常是相当简单的。为了测试我们的`calc`函数，我们首先必须决定我们想要测试什么。首先，我们可以为有效输入设置一些测试用例，并将这些输入与一些预期的结果相匹配。
- en: 'We could do this in a table like this one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这样的表格来做这件事：
- en: '![Table 11.1 ](img/Chapter_11_table_1_01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![表11.1](img/Chapter_11_table_1_01.jpg)'
- en: Table 11.1
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1
- en: We can use this to write our tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来编写我们的测试。
- en: 'Unit tests are typically written in a separate file that will call the code
    to be tested. They might look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常是在一个单独的文件中编写的，该文件将调用要测试的代码。它们可能看起来像这样：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first argument, `assert.equal`, is what we expect as a result, and it is
    compared to the content of the `result` variable. If they match, this test will
    pass; if not, the test will fail. We can now go ahead and create tests in the
    same manner for the rest of our test cases:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`assert.equal`，是我们期望的结果，它被与`result`变量的内容进行比较。如果它们匹配，则此测试将通过；如果不匹配，则测试将失败。我们现在可以继续以相同的方式为其余的测试用例创建测试：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we are just listing the first ones, but we continue like that with the
    rest.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是列出了一些，但我们会继续这样做，直到列出所有剩余的。
- en: 'For simple tests like these, the structure will be the same—call the function
    we want to test, store the returned value in a variable, and compare the returned
    value with the expected one. We should also think of odd cases and what kind of
    result we expect to get. For example, what will happen if we make this call to
    `divide`? Here is how the code appears:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的简单测试，结构将是相同的——调用我们想要测试的函数，将返回的值存储在一个变量中，并将返回的值与预期的值进行比较。我们还应该考虑异常情况以及我们期望得到的结果。例如，如果我们调用`divide`函数会发生什么？以下是代码的显示方式：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we discussed in [*Chapter 9*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127),
    *When Things Go Wrong – Bugs and Exceptions*, we can't divide a number by zero.
    This will result in an exception. If we expect to get an exception when this is
    done, the function works, but if we expect the function to handle this case, it
    will need to be modified. This is done so that it returns whatever we decide it
    should return. This may happen if we decide that we should get another exception
    that indicates that we can't pass a 0 as the second argument. So, no matter what
    we expect, it should be tested.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第9章*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127)中讨论的，“当事情出错——错误和异常”，我们不能将一个数除以零。这将导致异常。如果我们期望在这样做时得到一个异常，则函数正常工作，但如果我们期望函数处理这种情况，则需要对其进行修改。这是为了使其返回我们决定它应该返回的任何内容。如果我们决定我们应该得到另一个表示我们不能将0作为第二个参数传递的异常，则可能会发生这种情况。所以，无论我们期望什么，都应该进行测试。
- en: This is one type of test that we should run on our code, but these tests will
    just test a single unit; that is, an isolated part of the application. We will
    also need to perform another type of test, called an integration test. We'll see
    what this is in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该在代码上运行的一种测试类型，但这些测试将只测试单个单元；也就是说，应用程序的一个隔离部分。我们还需要执行另一种类型的测试，称为集成测试。我们将在下一节中看到这是什么。
- en: Integration testing
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is about putting several units together and testing them
    so that they work correctly when they are no longer isolated, but work together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是将几个单元组合在一起并测试它们，以确保它们在不再隔离的情况下也能正确工作。
- en: Units that work together will need to communicate, and they will communicate
    by passing data between them. This means that integration testing is about checking
    that the data transfer and data representation aspects work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一起工作的单元需要相互通信，它们将通过在它们之间传递数据来进行通信。这意味着集成测试是关于检查数据传输和数据表示方面是否工作。
- en: 'Imagine that we are working on a project that is divided into several modules.
    To speed up development time, we let several programmers work on the separate
    modules. This might look something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在开发一个被划分为几个模块的项目。为了加快开发时间，我们让几个程序员分别处理不同的模块。这可能会看起来像这样：
- en: '![Figure 11.6 – Four developers working on four different modules](img/Figure_11.6_B15554.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 四位开发者正在处理四个不同的模块](img/Figure_11.6_B15554.jpg)'
- en: Figure 11.6 – Four developers working on four different modules
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 四位开发者正在处理四个不同的模块
- en: These four developers will now start to write their modules, and they will make
    sure that their modules meet the requirements by running unit tests on them. But
    the only thing these tests will show is that this module works in isolation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这四位开发者现在将开始编写他们的模块，并且他们会通过在模块上运行单元测试来确保它们满足要求。但这些测试唯一能显示的是这个模块在独立状态下是工作的。
- en: But in the final application, these modules will need to interact with each
    other, and when they do, they will need to send data back and forth. The problem
    here is that all four programmers are human, and humans tend to interpret even
    the most detailed description differently. So, if Carl needs to pass a value for
    a year to the module Alice is writing, he might pass it as a two-digit value,
    such as 23\. But Alice, who is writing the code receiving this data, might expect
    that the year comes in a four-digit format, so she expects 2023\.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但在最终的应用中，这些模块将需要相互交互，当它们这样做时，它们将需要来回发送数据。这里的问题是所有四位程序员都是人类，人类倾向于对即使是描述最详细的内容也有不同的解释。所以，如果卡尔需要将一个年份的值传递给爱丽丝正在编写的模块，他可能会将其作为两位数的值传递，例如23。但编写接收这些数据的代码的爱丽丝可能期望年份以四位数的格式出现，因此她期望是2023。
- en: 'If we trace the communication between the modules when they are put together,
    this might look something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们追踪模块组合在一起时的通信，这可能会看起来像这样：
- en: '![Figure 11.7 – Modules communicating](img/Figure_11.7_B15554.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 模块间的通信](img/Figure_11.7_B15554.jpg)'
- en: Figure 11.7 – Modules communicating
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 模块间的通信
- en: This is just a small example. In real applications, there will be many more
    modules and many more lines of communication. But the point is that we will need
    to verify that all the data that's passed back and forth is valid and works in
    all situations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小的例子。在实际应用中，将有更多的模块和更多的通信行。但重点是，我们需要验证所有传递来回复的数据都是有效的，并且在所有情况下都能正常工作。
- en: In this case, we will need to do what's called an **integration test**. This
    is when we test that different parts of the application are working when they're
    put together.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要进行所谓的**集成测试**。这是当我们测试当不同的应用部分组合在一起时是否正常工作时。
- en: 'This can be done in several ways. There is a big-bang approach we can take,
    which means that we wait for all the modules to be completed, and then we put
    them together and test them. The disadvantage of this is that the modules will
    not be ready at the same time. If Alice, who writes Module A, is done with her
    work, she will need Bob to finish his work before she can integration test her
    module, as her work is making a call to Bob''s work. The same goes for Bob: he
    needs Carl to finish his work before he can integrate his module into the application.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种方式来完成。我们可以采取一种大爆炸的方法，这意味着我们等待所有模块都完成，然后将它们组合在一起并测试它们。这种方法的不利之处在于模块不会同时准备好。如果编写模块A的爱丽丝完成了她的工作，她需要鲍勃完成他的工作，然后她才能集成测试她的模块，因为她的工作需要调用鲍勃的工作。对鲍勃来说也是如此：他需要在卡尔完成他的工作之前集成他的模块到应用中。
- en: There are other approaches where we don't wait for all the parts to be finished
    before we begin testing. Instead, we create *fake* modules, called **stubs** and
    **drivers**. A stub is a module that gets called by another module, while a driver
    is a module calling another module. We can create these to pass and accept data
    so that we can begin testing. They are not fully functional modules, but they
    act as the real modules for the sake of testing. As modules get completed, they
    can replace these stubs and drivers, and tests can then be performed on the real
    modules.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法，我们不需要等待所有部分都完成才开始测试。相反，我们创建*模拟*模块，称为**存根**和**驱动器**。存根是一个被另一个模块调用的模块，而驱动器是一个调用另一个模块的模块。我们可以创建这些模块来传递和接受数据，以便我们可以开始测试。它们不是完全功能的模块，但为了测试的目的，它们充当真实模块。随着模块的完成，它们可以替换这些存根和驱动器，然后可以在真实模块上进行测试。
- en: Having these tests in place is essential, partly because it verifies that the
    modules can interact with each other, but also for the future. When we add new
    functionality later, either by changing existing modules or adding new ones, we
    want to make sure that everything that worked previously still does. Inserting
    new code into an existing application can have unwanted side effects, and we must
    make sure that this has not happened.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些测试是必不可少的，部分原因是因为它验证了模块可以相互交互，但也为了未来。当我们后来添加新功能时，无论是通过更改现有模块还是添加新模块，我们都要确保之前工作的一切仍然有效。将新代码插入现有应用程序可能会产生不希望的结果，我们必须确保这种情况没有发生。
- en: Other types of tests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的测试
- en: Unit and integration testing are not the only types of tests we have. Depending
    on what kind of application we are creating and what requirements our software
    has when it comes to things such as data integrity, handling large workloads,
    compatibility with other applications, and so on, we can choose to expose the
    code for several different test types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单元和集成测试并不是我们拥有的唯一类型的测试。根据我们正在创建的应用程序类型以及我们的软件在数据完整性、处理大量工作负载、与其他应用程序兼容性等方面的要求，我们可以选择公开代码以进行几种不同的测试类型。
- en: Let's briefly look at some of these tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看这些测试。
- en: System testing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统测试
- en: System testing tests a system when it is completely integrated into its execution
    environment. Here, we will test things such as whether the login works, whether
    we can create and edit data in the application, whether the user interface presents
    data correctly, and whether we can delete entries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试在系统完全集成到其执行环境时进行测试。在这里，我们将测试诸如登录是否工作，我们是否可以在应用程序中创建和编辑数据，用户界面是否正确显示数据，以及我们是否可以删除条目等问题。
- en: These things are typically tested earlier in the development process too, but
    they need to be verified when the source code is in its live production environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情通常在开发过程的早期就进行测试，但需要在源代码处于其生产环境时进行验证。
- en: Acceptance testing
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验收测试
- en: 'Acceptance testing is often divided into four different types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通常分为四种不同类型：
- en: User acceptance testing
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: Operational acceptance testing
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作验收测试
- en: Constructional and regulatory acceptance testing
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和监管验收测试
- en: Alpha and beta testing
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿尔法测试和贝塔测试
- en: 'Let''s understand these in detail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解一下：
- en: '**User acceptance testing**: This is a way to verify that the solution created
    works for the end users of our application. The questions we are trying to answer
    with these tests are if the users can use the software, if it is what they asked
    for, whether they have any trouble using it, and if the application behaves as
    anticipated.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**：这是一种验证我们应用程序创建的解决方案是否适用于最终用户的方式。我们试图通过这些测试回答的问题包括用户是否可以使用软件，它是否是他们所要求的，他们是否在使用过程中遇到任何麻烦，以及应用程序是否按预期运行。'
- en: "**Operational acceptance testing**: This is done to verify the operational\
    \ readiness \Lof an application before it is released to end users."
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作验收测试**：这是在将应用程序发布给最终用户之前，验证应用程序操作准备就绪的。'
- en: '**Constructional and regulatory acceptance testing**: This is done to verify
    that the developed software fulfills the conditions specified in the agreement
    that was entered into with the organization that ordered the software. Regulatory
    testing verifies that the software conforms to the current regulations.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和监管验收测试**：这是为了验证所开发的软件是否符合与订购软件的组织签订的协议中规定的条件。监管测试验证软件是否符合当前的规定。'
- en: '**Alpha and beta testing**: These are two tests that are performed to verify
    and identify all possible issues and bugs. Alpha testing is performed early in
    the development process, while beta testing is done near the end of the development
    process. They are both conducted by potential users of the finished product or
    by a group of people with a similar skill level as the end users of the application.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**alpha和beta测试**：这是两种测试，用于验证和识别所有可能的问题和错误。alpha测试在开发过程的早期进行，而beta测试则在开发过程的后期进行。它们都是由最终产品的潜在用户或与应用最终用户具有相似技能水平的一组人执行的。'
- en: Regression testing
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression testing focuses on finding defects after a significant code change
    and seeks to uncover software regressions. A software regression is a bug that
    will make some features in an application stop functioning after the update. There
    is also software performance regression, where the software still operates correctly,
    but where an update harmed the system's performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试专注于在重大代码更改后寻找缺陷，并试图揭示软件回归。软件回归是在更新后使应用中某些功能停止工作的错误。还有软件性能回归，其中软件仍然正确运行，但更新损害了系统的性能。
- en: These were some other tests we can perform on our software. There are many more,
    but the ones we have covered here are among the most typical tests you will get
    exposed to as a software developer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以在我们的软件上执行的一些其他测试。还有很多，但我们在这里讨论的这些是最典型的测试，你作为软件开发者可能会遇到。
- en: When we have code that is tested, we can make it available to the end users
    of our application. Before we talk about how to make the code we have written
    available to our users, we should stop and talk about what a release is.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有经过测试的代码时，我们可以将其提供给应用的用户。在我们讨论如何将我们编写的代码提供给用户之前，我们应该停下来谈谈什么是发布。
- en: Software releases
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件发布
- en: When creating software, we don't want to start with an idea for the finished
    project and then get to work on everything that this application needs to do and,
    several years later, finally publish the finished software. The reason we don't
    want to do this is that during development time, several things will happen; for
    example, the requirements for this application might change, new laws can make
    us need to do things differently, and competing software solutions might be released,
    to name a few.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建软件时，我们不希望从一个关于最终项目的想法开始，然后着手完成这个应用需要做的所有事情，几年后最终发布完成的软件。我们不希望这样做的原因是在开发过程中，会发生几件事情；例如，这个应用的需求可能会改变，新的法律可能要求我们以不同的方式做事，竞争的软件解决方案可能已经发布，仅举几个例子。
- en: 'Instead, we want to implement some core features, release them to our users,
    and then immediately begin the development of the next release, which will contain
    some more features. This can be illustrated as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们希望实现一些核心功能，将它们发布给用户，然后立即开始开发下一个版本，这个版本将包含更多功能。这可以表示如下：
- en: '![Figure 11.8 – Development process through continuous iterations](img/Figure_11.8_B15554.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 通过持续迭代进行开发过程](img/Figure_11.8_B15554.jpg)'
- en: Figure 11.8 – Development process through continuous iterations
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 通过持续迭代进行开发过程
- en: We start with a vision or an idea. Then, we take some fundamental parts of this
    idea and implement them in what is called an **iteration**. During this iteration
    phase, we perform several steps, all of which we will look at in more detail soon.
    At the end of the iteration, we have code that works that we can release to our
    users. We then begin the next iteration, implementing more features that are released
    as soon as this iteration is complete.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个愿景或想法开始。然后，我们取这个想法的一些基本部分，并在所谓的**迭代**中实现它们。在迭代阶段，我们执行几个步骤，我们很快就会更详细地探讨这些步骤。在迭代结束时，我们有可以发布给用户的可工作代码。然后我们开始下一个迭代，实现更多将在迭代完成后发布的特性。
- en: 'The steps that are taken during an iteration will vary, depending on the development
    methodology, but commonly, it will be something similar to the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代过程中采取的步骤将因开发方法的不同而有所不同，但通常，它将类似于以下内容：
- en: '![Figure 11.9 – Typical steps during one iteration](img/Figure_11.9_B15554.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 单次迭代过程中的典型步骤](img/Figure_11.9_B15554.jpg)'
- en: Figure 11.9 – Typical steps during one iteration
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 单次迭代过程中的典型步骤
- en: 'Here, we can see that we take our ideas and requirements into the development
    cycle. First, we will perform an analysis and design the steps. Here, we are trying
    to answer two questions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将我们的想法和需求纳入开发周期。首先，我们将进行分析和设计步骤。在这里，我们试图回答两个问题：
- en: What is it that we will do (analysis)?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将做什么（分析）？
- en: How can we do it (design)?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们该如何做（设计）？
- en: When we know what we should do and how to do it, we can start to implement the
    different parts that go into this iteration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道我们应该做什么以及如何做时，我们就可以开始实施构成这一迭代的各个部分了。
- en: As we finish a section of code, it gets unit tested, and then all the code undergoes
    integration tests. Other tests might also be performed before the code is released
    to end users. Releasing the code is called a **deployment**, a step we will look
    closer at soon.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成一段代码后，它将进行单元测试，然后所有代码将进行集成测试。在代码发布给最终用户之前，也可能进行其他测试。发布代码被称为**部署**，这是我们很快将要更详细地探讨的步骤。
- en: What we have accomplished now is a release, and this means that our software
    now has some new features or bug fixes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所完成的是一次发布，这意味着我们的软件现在有一些新功能或错误修复。
- en: We can now begin the next iteration. This is completed by evaluating the iteration
    we just ended. This is done so that we can fine-tune our workflow, see whether
    we have discovered some problems during the last cycle, or any other issues that
    we need to consider in the next iteration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始下一轮迭代。这是通过评估刚刚结束的迭代来完成的。这样做是为了我们可以微调我们的工作流程，看看我们是否在上一轮周期中发现了某些问题，或者任何其他我们需要在下一轮迭代中考虑的问题。
- en: We can then specify what will go into the next iteration, and by using that
    repeat the whole process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以指定下一轮迭代中要包含的内容，并使用它重复整个过程。
- en: Now, let's take a closer look at the deployment phase to learn what it is and
    how it can be done.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看部署阶段，了解它是什么以及如何进行。
- en: Understanding software deployment
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件部署
- en: When we have some code to release, we will need to deploy it. Deployment is
    the process of making sure the software is installed in the right location, that
    it is secured to prevent any hacker attacks, and making sure that privileges are
    given to the software so that it can read and write files as needed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有代码要发布时，我们需要将其部署。部署是确保软件安装到正确位置的过程，确保它受到保护以防止任何黑客攻击，并确保软件被赋予必要的权限，以便它可以按需读取和写入文件。
- en: When the code is deployed, we usually want to test it again to make sure that
    everything is still working the way it is intended.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码部署后，我们通常想再次测试它，以确保一切仍然按预期工作。
- en: Deploying the code is usually done in several steps. Developers will typically
    have a server that's used during the development process. This is called the **development
    server**, and during development, the code can be executed and tested on this
    server. It will often come with a development database that, if the application
    we develop uses a database, is used to simulate the real data the application
    handles. Still, it can be modified any way the developer wants as it is detached
    from the real data the users see and work with.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部署通常分为几个步骤。开发者通常会有一个在开发过程中使用的服务器。这被称为**开发服务器**，在开发过程中，代码可以在这个服务器上执行和测试。它通常会附带一个开发数据库，如果开发的应用程序使用数据库，则用于模拟应用程序处理的真实数据。尽管如此，它可以按照开发者想要的任何方式修改，因为它与用户看到和工作的真实数据是分离的。
- en: Before the code is moved to the production server, that is, the server the application
    users will use to run the application, the code is usually moved to an intermediate
    server, often referred to as a **staging server**. The role of this server is
    to be as much like the production server as possible so that the new code can
    be tested alongside the code that was already released. The idea is to make sure
    that everything runs smoothly and that no bugs appear when the new code hits the
    live production server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码移动到生产服务器之前，即应用程序用户将使用它来运行应用程序的服务器，代码通常会被移动到一个中间服务器，通常被称为**预发布服务器**。这个服务器的角色是尽可能像生产服务器一样，以便新代码可以与已经发布的代码一起测试。目的是确保一切运行顺利，并且当新代码上线到生产服务器时不会出现任何错误。
- en: The staging server also has a database. The data in this database is often copied
    from the production database to make sure that everything is a mirror of the real
    server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 预发布服务器也有一个数据库。这个数据库中的数据通常是从生产数据库复制过来的，以确保一切都是真实服务器的镜像。
- en: 'Finally, when the team is confident that everything works correctly, the code
    is moved to the production server. Apart from moving the code, other adjustments
    might be needed, such as adding things to the production database that the new
    software version will need, adding other applications and code libraries that
    are used by the new code, and so on. This is depicted here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当团队确信一切正常时，代码将被移动到生产服务器。除了移动代码之外，可能还需要进行其他调整，例如向生产数据库添加新软件版本所需的元素，添加新代码使用的新应用程序和代码库等。这在此处展示：
- en: '![Figure 11.10 – Example of servers and their databases](img/Figure_11.10_B15554.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 服务器及其数据库的示例](img/Figure_11.10_B15554.jpg)'
- en: Figure 11.10 – Example of servers and their databases
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 服务器及其数据库的示例
- en: We must also have a strategy for how we can undo this deployment if needed.
    No matter how thorough our test has been, when the code hits production and users
    start to use it, things that we never imagined begin surfacing. Users might behave
    in unpredicted ways, and there might be differences in the production environment
    compared to the staging environment that we overlooked.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须有一个策略，以便在需要时能够撤销这次部署。无论我们的测试多么彻底，当代码进入生产并开始被用户使用时，我们从未想象到的问题开始浮现。用户可能会以不可预测的方式行事，与我们的预演环境相比，生产环境可能存在我们忽视的差异。
- en: We always hope for the best, but we will need a plan for what we will do if
    things backfire. What we want is a way to undo all the changes and go back to
    what we had before the deployment as quickly as possible. This is called a **rollback
    strategy**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是希望一切顺利，但如果我们遇到问题，我们需要有一个计划。我们希望的是能够尽快撤销所有更改，回到部署之前的状态。这被称为**回滚策略**。
- en: We can accomplish such a rollback in several ways. One of them would be to take
    a backup of the production database before the deployment occurs. This way, we
    can ensure that we have a snapshot of how all the data in the application was,
    before the release of the new code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式实现这样的回滚。其中一种方法是在部署发生之前备份生产数据库。这样，我们可以确保在发布新代码之前，我们有应用程序中所有数据的快照。
- en: The actual code is usually deployed to the server with the help of a VCS, so
    rolling back the actual code to a previous version is rather simple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实际代码通常在版本控制系统的帮助下部署到服务器上，因此将实际代码回滚到之前的版本相对简单。
- en: The steps involved in deploying code to the production environment are often
    automated, meaning that different tools and applications take care of all the
    steps. Let's see how this automation works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码部署到生产环境涉及的步骤通常都是自动化的，这意味着不同的工具和应用程序负责所有步骤。让我们看看这种自动化是如何工作的。
- en: Deployment automation
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署自动化
- en: It is often a good idea to automate as many of the deployment steps as possible.
    The reason is that there are usually many steps involved that need to be done
    in the correct order, a job ideally suited for automation. At the same time, it's
    something where humans often make mistakes by forgetting to do something or do
    something in the wrong order.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地自动化尽可能多的部署步骤通常是一个好主意。原因是通常涉及许多步骤，需要按正确的顺序执行，这是一项非常适合自动化的工作。同时，这也是人类经常因为忘记做某事或以错误的顺序做某事而出错的地方。
- en: Depending on the complexity of the system, we can use several tools that will
    help us accomplish automated deployment.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统的复杂性，我们可以使用多个工具来帮助我们实现自动化部署。
- en: Automating deployment will ensure that we have high-quality code since the automation
    process typically runs tests and lets the code through to the production server
    that passes the tests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化部署将确保我们拥有高质量的代码，因为自动化过程通常会运行测试，并允许通过测试的代码进入生产服务器。
- en: It will also save time as the deployment steps will be performed much faster
    by the deployment tools than they would be if humans performed them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将节省时间，因为部署步骤将由部署工具以比人工执行更快的方式完成。
- en: When the code is deployed, the work with it is not over. Deployed code must
    be maintained.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码部署后，与代码的工作并未结束。部署的代码必须得到维护。
- en: Code maintenance
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码维护
- en: A typical software developer will spend more time maintaining existing code
    than writing new exciting features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的软件开发者将花费更多的时间维护现有代码，而不是编写新的令人兴奋的功能。
- en: This is not very strange if we think about it. First, the lifespan of an application
    is typically much longer than the time it took to develop it. This means that
    there are more and more softwares out there that are running and performing their
    tasks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，这并不奇怪。首先，一个应用程序的寿命通常比开发它所花费的时间要长得多。这意味着越来越多的软件正在运行并执行它们的任务。
- en: Programs that are used will always need maintenance as users will find bugs
    that we must fix, new features will be added to the application as demands from
    users change, and old features must be updated and improved.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 被使用的程序将始终需要维护，因为用户会发现我们必须修复的bug，随着用户需求的变化，应用程序将添加新功能，而旧功能必须更新和改进。
- en: This means that developers spend most of their time in old code, fixing and
    updating it. This can be code written decades ago by someone who has left the
    company a long time ago, or it can be written by you just the other week.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着开发者大部分时间都在处理旧代码，修复和更新它。这可能是由很久以前离开公司的某人编写的几十年前的代码，或者是由你上周编写的代码。
- en: If you think ahead to what your life as a programmer will look like, you will
    most likely imagine yourself writing new, exciting software that uses the latest
    tools and features that are out there. Still, the fact is that it is much more
    likely that you will be poking around in code written a long time ago, in a version
    of the language that was released when you were in preschool.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提前思考你作为程序员的未来生活，你很可能会想象自己正在编写使用最新工具和功能的全新、令人兴奋的软件。然而，事实是，你更有可能正在探索很久以前编写的代码，那是在你上幼儿园时发布的语言版本。
- en: At times, you will have the chance to write that brand-new, cool, and shiny
    piece of software, but remember, if you do a good job, that code will live on
    and will need to be maintained by others (or yourself) in the future.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你将有机会编写全新的、酷炫的、闪亮的软件，但记住，如果你做得好，这段代码将延续下去，并将需要由其他人（或你自己）在未来进行维护。
- en: That is the life of a software developer. This means that we need to ensure
    that the code we write is as maintainable as possible. A skilled software developer
    is someone who writes highly maintainable code. This means that the code is clear,
    easy to understand, and easy to change, without the risk of people introducing
    some unwanted side effects in the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是软件开发者的生活。这意味着我们需要确保我们编写的代码尽可能可维护。一个熟练的软件开发者是编写高度可维护代码的人。这意味着代码清晰、易于理解，易于更改，而不会有人在不经意间在应用程序中引入一些不希望出现的副作用。
- en: 'There is a simple rule we can follow to help us create maintainable code: the
    boy scout rule.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循一条简单的规则来帮助我们创建可维护的代码：童子军规则。
- en: 'The legend of the boy scout rule says:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 童子军规则的传说如下：
- en: '*Leave the campground cleaner than you found it.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*离开营地时，让它比你来时更干净。*'
- en: I have no evidence that this rule was ever used by actual scouts. It is more
    likely a variant of a message the founder of the scout movement, Robert Baden-Powell,
    left to the movement before his death. In that message, he said, *Try to leave
    this world a little better than you found it.*
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有证据表明这条规则曾被实际的童子军使用过。更可能的是，这是童子军运动创始人罗伯特·巴登-鲍威尔在他去世前留给运动的信条的一个变体。在那封信中，他说：“尽力让这个世界比你所发现的时候更好。”
- en: In the book *Clean Code,* the author, Robert C. Martin, also known as Uncle
    Bob, transformed this rule so that it could be applied to code. He states that
    if we apply this rule when we maintain our code, we should always leave our code
    a little cleaner and better each time we maintain it so that its quality will
    increase over time. We can rephrase the boy scout rule in relation to software
    development so that it says, *Always leave the code you're editing a little better
    than you found it*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在《代码整洁之道》这本书中，作者罗伯特·C·马丁，也被称为Uncle Bob，将这条规则转化为可以应用于代码的形式。他提出，如果我们在我们维护代码时应用这条规则，我们应该在每次维护时都让我们的代码变得更加整洁和更好，这样它的质量就会随着时间的推移而提高。我们可以将童子军规则与软件开发联系起来重新表述，使其说：“始终让你所编辑的代码比你所发现的时候更好。”
- en: The changes do not have to be huge. You will not have to rewrite large sections
    of code. If you change a variable name to something that better describes the
    value it is holding, or adding documentation to a piece of code where it was missing
    previously will increase the code's quality slightly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化不必很大。你不必重写代码的大段内容。如果你将变量名改为更好地描述它所持有的值的名称，或者在一个代码片段中添加缺失的文档，这将略微提高代码的质量。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 12*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186), *Code Quality,*
    and [*Appendix A*](B15554_AppA_Final_NM_ePub.xhtml#_idTextAnchor210), *How To
    Translate the Pseudocode into Real Code*, we will dive deeper into how we can
    write high-quality code, among other things, while keeping maintainability in
    mind.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186) *代码质量* 和 [*附录A*](B15554_AppA_Final_NM_ePub.xhtml#_idTextAnchor210)
    *如何将伪代码转换为真实代码* 中，我们将深入了解我们如何编写高质量的代码，以及其他方面，同时考虑到可维护性。
- en: Now that we have an idea of how to get the software to our users, when we are
    done writing and testing it, we should take a closer look at the actual development
    process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将软件交付给用户，当我们完成编写和测试后，我们应该更仔细地看看实际的开发过程。
- en: Software development process methodologies
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发过程方法论
- en: Since the 1960s, different methodologies have been developed to help system
    developers be more productive, on target, and create higher quality code. Here,
    we will look at some of the more essential methodologies – some that are in use
    today and some that have been superseded by newer and more flexible ones.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自1960年代以来，已经开发出不同的方法论来帮助系统开发者更高效、更精准，并创建更高品质的代码。在这里，我们将探讨一些更基本的方法论——一些今天仍在使用的方法论，以及一些被更新、更灵活的方法论所取代的方法论。
- en: Waterfall development
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瀑布开发
- en: The waterfall development model is one that almost everyone loves to hate. We
    will look at it anyway, as many newer methodologies have been developed as a reaction
    to it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 水晶球开发模型是几乎每个人都爱恨交加的一种。无论如何，我们都会看看它，因为许多新的方法论都是作为对其的反应而开发的。
- en: The reason it is hated, is that it will not take changing requirements into
    account.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以受到厌恶，是因为它不会考虑需求的变化。
- en: 'In the waterfall model, several defined steps are completed, one preceding
    the next. An example of these steps can be seen in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在瀑布模型中，几个定义的步骤被完成，一个接一个。以下图表中可以看到这些步骤的例子：
- en: '![Figure 11.11 – The steps in the waterfall model](img/Figure_11.11_B15554.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 瀑布模型中的步骤](img/Figure_11.11_B15554.jpg)'
- en: Figure 11.11 – The steps in the waterfall model
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 瀑布模型中的步骤
- en: 'This is how the model works:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个模型的工作方式：
- en: First, we gather all the requirements needed for this application.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们收集这个应用程序所需的所有需求。
- en: After that, we make a system design, where we describe how different responsibilities
    will be divided between different parts of the application.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们进行系统设计，其中我们描述了不同的责任将如何在应用程序的不同部分之间分配。
- en: Then, we write the code.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们编写代码。
- en: During the verification phase, the code is tested.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证阶段，代码被测试。
- en: Finally, when the software is released, it goes into the maintenance phase,
    where it is maintained.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当软件发布后，它进入维护阶段，在那里它被维护。
- en: The main criticism of this model is that it will not capture new requirements
    that might (and often will) arise during the development phase. The process of
    going from an initial idea to a finalized product can be rather long, and during
    this time, a lot of things will happen that will have an impact on this application.
    New laws can come into place,  competing applications might be released, new versions
    of operating systems and other software that this application relies on might
    be released, and so on.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型的主要批评是它不会捕捉到在开发阶段可能（并且经常是）出现的新的需求。从最初的想法到最终产品的过程可能相当长，在这段时间里，会有很多事情发生，将对这个应用产生影响。新的法律可能会出台，竞争性的应用程序可能会发布，这个应用程序所依赖的操作系统和其他软件的新版本可能会发布，等等。
- en: If we have a development model that cannot capture these changes, we will most
    likely have developed a product that is outdated before it has even been released.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个无法捕捉这些变化的发展模型，我们很可能会开发出一个在发布之前就已经过时的产品。
- en: Now that we have looked at a methodology that is not in use anymore, or at least,
    no one will say that they are using it, we can look at some that are in use and
    that are created as a reaction to the waterfall model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了一种不再使用的方法论，或者至少，没有人会说自己在使用它，我们可以看看一些正在使用的方法论，这些方法论是作为对瀑布模型的反应而创建的。
- en: Spiral model
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 螺旋模型
- en: In 1986, the American software engineer Barry Boehm described and depicted a
    model that, instead of going from one phase to the next, was shaped as a spiral.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在1986年，美国软件工程师巴里·博姆描述并描绘了一个模型，这个模型不是从一个阶段到下一个阶段，而是呈螺旋形。
- en: This idea has since been developed and modified into several new methodologies.
    Still, the basic idea of driving the development process by a spiral has been
    prevalent since then.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法随后得到了发展和修改，形成了几种新的方法。然而，自那时以来，通过螺旋推动开发过程的基本思想一直很流行。
- en: One key concept in the spiral model is that risk is taken into consideration
    as a critical concept when developing software.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型中的一个关键概念是在开发软件时将风险作为一个关键概念来考虑。
- en: 'In the following diagram, we can see a simplified version of the spiral model:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到螺旋模型的简化版本：
- en: '![Figure 11.12 – A simplified version of the spiral model](img/Figure_11.12_B15554.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – 螺旋模型的简化版本](img/Figure_11.12_B15554.jpg)'
- en: Figure 11.12 – A simplified version of the spiral model
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 螺旋模型的简化版本
- en: 'Here, we have four distinct phases. Instead of going through them once in order,
    we will iterate through them over and over as many times as necessary until the
    application is developed. Let''s take a look:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有四个不同的阶段。我们不会按顺序一次性完成它们，而是会根据需要反复迭代，直到应用程序开发完成。让我们看看：
- en: In the first phase, we look at the objectives, as we see them at this point
    in the development process.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一阶段，我们查看目标，就像我们在开发过程中的这个阶段看到的那样。
- en: We then look at the risks. What can hinder us from succeeding in implementing
    the objectives we just determined? By identifying the risks, we have a higher
    chance of avoiding them or at least minimizing the impact they will have on our
    software.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们来看风险。什么可能阻碍我们成功实施刚刚确定的目标？通过识别风险，我们更有可能避免它们，或者至少最小化它们对我们软件的影响。
- en: When that is done, we will go ahead and develop and test the software.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这一切都完成时，我们将继续开发和测试软件。
- en: The last phase is a review phase. Here, we look back at what we have done in
    the other three phases during this iteration, including what went well and what
    problems we had. We can learn from this so that the next iteration is better.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的阶段是审查阶段。在这里，我们回顾在这个迭代过程中所做的一切，包括哪些做得好，哪些有问题。我们可以从中学习，以便下一个迭代做得更好。
- en: We will then start over with the objectives for the next iteration by determining
    the risks and developing and reviewing them repeatedly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从确定风险、开发和审查目标开始，为下一个迭代重新开始。
- en: The growing spiral illustrates that, for each iteration, more of the software
    has been created.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不断增长的螺旋图说明了，对于每个迭代，软件的创建量都在增加。
- en: Even if the spiral model was created as a reaction to the shortcomings of the
    waterfall model, this claim shows that the problem is not the Waterfall model
    in itself, but that the development process becomes very prolonged and therefore
    can't react to rapid changes in requirements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 即使螺旋模型是作为对瀑布模型不足的反应而创建的，这个说法表明问题不是瀑布模型本身，而是开发过程变得非常漫长，因此无法对需求的变化做出快速反应。
- en: The spiral model gave inspiration to several new methodologies, where the development
    process is divided into smaller iterations. The next one is one such example and
    the one that is currently the foundation of how most software projects are run.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型为几个新的方法提供了灵感，其中开发过程被划分为更小的迭代。下一个就是这样的一个例子，也是目前大多数软件项目运行的基础。
- en: Barry Boehm also said that this model is just a series of small waterfall models.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 巴里·博姆还说过，这个模型只是一系列小型的瀑布模型。
- en: Agile development
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷开发
- en: Agile software development refers to a group of software methodologies, all
    based on iterative development.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发是指一组基于迭代开发的软件方法。
- en: The term *agile* comes from a group of 17 software developers who met at a resort
    in Snowbird, Utah, in 2001\. After the meeting, they published *Manifesto for
    Agile Software Development*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**敏捷**来自2001年在犹他州Snowbird度假村相遇的17位软件开发者。会议结束后，他们发布了**敏捷软件开发宣言**。
- en: The manifesto is a short description of what should be prioritized during the
    software development process.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 宣言是对软件开发过程中应该优先考虑的内容的简要描述。
- en: It can be found at [https://agilemanifesto.org/](https://agilemanifesto.org/).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在[https://agilemanifesto.org/](https://agilemanifesto.org/)找到。
- en: This manifesto is then outlined in more detail by twelve principles, called
    *Principles behind the Agile Manifesto*, and they can be found here at [https://agilemanifesto.org/principles.html](https://agilemanifesto.org/principles.html).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宣言通过十二条原则进行了更详细的概述，称为**敏捷宣言背后的原则**，并且可以在[https://agilemanifesto.org/principles.html](https://agilemanifesto.org/principles.html)找到。
- en: These ideas had a significant impact on the software industry, and several new
    software development methodologies were developed in response to the manifesto.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法对软件行业产生了重大影响，并且根据宣言，开发了几种新的软件开发方法。
- en: Let's look at some of the more popular of these.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中一些更受欢迎的。
- en: Agile Scrum methodology
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏捷Scrum方法
- en: This methodology, better known as Scrum, is a lightweight project management
    framework that uses an iterative and incremental approach.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，更广为人知的是Scrum，是一个轻量级的项目管理框架，它采用迭代和增量方法。
- en: In Scrum, the product owner – a person with the power to decide what items will
    go into the application – plays a central role. This person needs to play an active
    role throughout the development process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scrum中，产品负责人——一个有权决定哪些条目将进入应用程序的人——扮演着核心角色。这个人需要在整个开发过程中发挥积极作用。
- en: The product owner works closely with the development team to create a prioritized
    list of system functionality, called the **product backlog**. The product backlog
    consists of whatever needs to be done to deliver a working software system successfully.
    The items in the backlog can be things such as the features of the application,
    bugs that need to be fixed, and non-functional requirements such as certification,
    accessibility, and data integrity.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 产品负责人与开发团队紧密合作，创建一个优先级列表的系统功能，称为**产品待办事项**。产品待办事项包括为了成功交付一个工作软件系统所需完成的任何事情。待办事项中的条目可以是应用程序的功能、需要修复的bug，以及非功能性需求，如认证、可访问性和数据完整性。
- en: When the properties in the backlog have been prioritized, a team of developers
    (and potentially other roles, if needed) will start to develop in what can be
    called *potentially shippable increments*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当待办事项中的属性被优先排序后，一个开发团队（如果需要，可能还有其他角色）将开始开发所谓的*可能发货的增量*。
- en: This means that the team will take some of the highest prioritized items from
    the backlog and start to implement them during a short time frame, known as a
    **sprint**. A sprint will typically last for somewhere between 14 and 30 days.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着团队将从待办事项中选取一些最高优先级的项目，并在一个称为**短跑**的短时间内开始实施它们。短跑通常持续14到30天。
- en: The outcome of the sprint is preferably fully functional so that it can immediately
    be put into production, and users can start using this functionality.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 短跑的结果最好是完全功能性的，以便它可以立即投入生产，并且用户可以开始使用这个功能。
- en: The team will then start over with a new sprint. This will be repeated as many
    times as necessary.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，团队将重新开始一个新的短跑。这需要重复进行，直到必要。
- en: Lean software development
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精益软件开发
- en: This Agile methodology is iterative, just like Scrum, and focuses on delivering
    fully functional batches. The methodology is highly flexible and does not have
    any rigid rules or guidelines.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种敏捷方法与Scrum一样是迭代的，并专注于交付完全功能性的批次。该方法非常灵活，没有任何严格的规定或指南。
- en: Its main idea is to eliminate what is called *waste*. This is done by letting
    users of the system select only the precious features for the system. These features
    are then prioritized and delivered in small batches.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要思想是消除所谓的*浪费*。这是通过让系统用户仅选择对系统宝贵的功能来实现的。然后，这些功能被优先排序，并以小批量交付。
- en: It relies on rapid and reliable feedback from the users of the software. In
    Lean development, the work is *pulled* by customer requests.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它依赖于来自软件用户的快速和可靠的反馈。在精益开发中，工作是由客户请求*拉动*的。
- en: Extreme Programming (XP)
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 极限编程（XP）
- en: This methodology was first described by Kent Beck, an American software engineer
    who took software best practices to an extreme level. One example of this is code
    review. Standard practice is that another developer should review all the code
    before it can be merged with the code that goes into a release. In XP, this is
    done by using the concept of *pair programming*. Pair programming is when two
    developers are using one computer to develop code. One is called the *driver*
    and is the one that will write the code. The other developer is called the *observer*
    or the *navigator* and will observe and review what the driver is doing. The two
    will frequently switch roles.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最初由肯特·贝克描述，他是一位美国软件工程师，将软件最佳实践推向了极致。其中一个例子是代码审查。标准做法是，在代码可以与发布版本中的代码合并之前，应由另一位开发者审查所有代码。在XP中，这是通过使用*结对编程*的概念来实现的。结对编程是指两位开发者使用一台计算机来编写代码。其中一位被称为*驾驶员*，是负责编写代码的人。另一位开发者被称为*观察者*或*导航者*，将观察并审查驾驶员的行为。两人将频繁地交换角色。
- en: Compared to the traditional code review process, this will speed things up as
    the review is done during the development phase. Other benefits of pair programming
    include the fact that the driver will consistently get input from the observer
    regarding how to solve the current task.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的代码审查过程相比，由于审查是在开发阶段进行的，这可以加快速度。结对编程的其他好处包括，驾驶员将始终从观察者那里获得关于如何解决当前任务的反馈。
- en: The goal of XP is to reduce the cost of changes in the requirements. To do this,
    XP uses short development cycles.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: XP的目标是降低需求变更的成本。为此，XP使用短的开发周期。
- en: In XP, changes in requirements are a natural, inescapable, and desirable aspect
    of software development.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在XP中，需求变更是软件开发的一个自然、不可避免且可取的方面。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some of the more essential concepts that go into
    software development that have nothing to do with the actual coding. Even if we
    are not working on large-scale, professional projects, we should still version
    control our code, write tests to verify that the code does what it is supposed
    to, and work iteratively.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了软件开发中的一些更基本的概念，这些概念与实际的编码无关。即使我们不在大型、专业项目中工作，我们也应该对代码进行版本控制，编写测试以验证代码是否按预期工作，并迭代工作。
- en: We began by learning that version control systems are a great tool that will
    help us not only be able to go back in time to an earlier version of the code,
    but also help us share our code with other developers in our team.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解到，版本控制系统是一个伟大的工具，它不仅可以帮助我们回到代码的早期版本，还可以帮助我们与其他团队成员共享代码。
- en: Then, we saw that to verify that the code we have written is doing what it is
    supposed to, we need to test it. In this case, we have something called unit tests
    and integration tests that we should perform to make sure that the application
    produces the correct result and that the new code does not produce any side effects,
    which would produce an undesirable result for a code that worked successfully
    in a previous version.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到为了验证我们编写的代码是否按预期工作，我们需要对其进行测试。在这种情况下，我们有一些称为单元测试和集成测试的内容，我们应该执行这些测试以确保应用程序产生正确的结果，并且新代码不会产生任何副作用，这会对在先前版本中成功工作的代码产生不良影响。
- en: After this, we saw that the software release life cycle defines what steps are
    to be performed to make a piece of code mature enough to be released to end users.
    When code is ready to be released, we need to deploy it to the environment (for
    example, as an application server) so that the end users of this application can
    access it. When the code is used, we need to maintain it. Bugs will be discovered,
    features will need to be added or changed, and so on.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到软件发布生命周期定义了要执行哪些步骤才能使代码成熟到可以发布给最终用户。当代码准备好发布时，我们需要将其部署到环境中（例如，作为应用程序服务器），以便最终用户可以访问它。当代码被使用时，我们需要维护它。将发现错误，需要添加或更改功能，等等。
- en: Lastly, we learned that to handle the development process, a software development
    team will typically use a development methodology. The methodology will describe
    in what order things should be done, how the team will cooperate to achieve a
    good result, and how to decide what will go into a software release.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解到，为了处理开发过程，软件开发团队通常会使用一种开发方法。这种方法将描述事情应该按照什么顺序进行，团队如何合作以实现良好的结果，以及如何决定什么内容将包含在软件版本中。
- en: In the next chapter, we will take a look at how we can write high-quality code,
    and what we mean by code quality.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何编写高质量的代码，以及我们所说的代码质量是什么意思。
