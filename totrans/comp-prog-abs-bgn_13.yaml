- en: '*Chapter 11:* Programming Tools and Methodologies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time for us to take a closer look at the development cycle. Producing
    software is more than just writing code. We must plan what will be coded, write
    the code, integrate the code we write with already existing code, share our code
    with other developers, test the code, deploy the code so that the application
    can be accessed by the users, add new features to the application, and fix bugs
    and errors that will show up in the code that has been released.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, a development team will typically use different tools and
    methodologies for how things will be done and in what order.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at all the components that are part of the development
    process that is not the actual coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a version control system is and what it can be used for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concept of a release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding software deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding code maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding software development process methodologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have lots to cover, so let''s start with an essential tool in software development:
    version control systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding version control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **version control system** (**VCS**) is used to manage changes in documents,
    computer programs, or other collections of files. They are used by programmers
    to manage different revisions of their code.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to restore earlier reversions if needed. This makes it safer
    to edit files, as we always have a way for us to restore what we had if we decide
    that the changes we made need to be reset.
  prefs: []
  type: TYPE_NORMAL
- en: VCSs are also used so that developers can work together on the same project
    and, in a safe manner, work in the same source code files. Version control systems
    also keep track of who changed what in a document, and when the change was made.
  prefs: []
  type: TYPE_NORMAL
- en: Files that are version controlled are stored in what is called a **repository**.
    When changes are made to a file, the user of the VCS can commit these changes
    to the repository, and by extension of that, create a reversion point. It is at
    these points where the version control system takes a snapshot of all the changes
    made.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this works, we can use one of the most popular version control
    systems available: Git. Git was created by Linus Torvalds, the creator of Linux,
    in 2005\. It was initially created to be used by the programmers who were working
    on the Linux kernel code, but soon gained popularity outside the Linux project.
    Today, it is by far the most popular version control system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing some code. Let''s say we have this code in a file called
    `calc.code`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file in an empty folder. We can now use the GIT software to create
    a repository. This means that we can start to version control the files within
    this folder. From the command line, we can do this by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, nothing is version controlled yet. We will need to tell GIT
    what files we want to add to version control. We can do that with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our file is now staged. This means that its changes will be tracked, but we
    will need to do one more thing to record the changes that have been made to our
    file. What we''ll do is called a **commit**. A commit will record our changes
    and store them in our repository. Let''s do that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`-m` tells `git` that we will provide a commit message, and the message is
    what comes within the quotes. The messages will help us see what is changed in
    a commit, so we should take some time to come up with descriptive messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes we have made are now stored on what is called the *master branch*.
    The following diagram illustrates what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The master branch after our initial commit](img/Figure_11.1_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The master branch after our initial commit
  prefs: []
  type: TYPE_NORMAL
- en: We would now like to continue to work on our program and add more code to this
    file. To make life a little bit safer, we can create a new branch and make our
    changes in this branch. We will soon see why this might be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new branch called `subtract`, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new branch will give us an exact copy of the branch we created it
    from, which in this case is the master branch. This can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Creating a new branch called subtract from the master branch](img/Figure_11.2_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Creating a new branch called subtract from the master branch
  prefs: []
  type: TYPE_NORMAL
- en: 'We are still on the master branch, so any changes we make will be on this branch.
    So, before we do anything else, we should switch branches. We can do that with
    the `checkout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now on the `subtract` branch. Now, we can update our source code file,
    so let''s add another function, making the file look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save these changes, we can add the file to the staging area and commit
    the changes with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can illustrate this commit with another circle on the submit branch, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Committing to our new branch](img/Figure_11.3_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Committing to our new branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have committed our changes to GIT, we can switch branches. Let''s
    do that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open our file now, we will see the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes we made are not here. This is because these changes are not in
    the master branch. Keeping the file open in our editor, we can now switch back
    to the `subtract` branch by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Like magic, the changes we made to the file are back, and the `subtract` function
    is as we left it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This illustrates that if we, for some reason, decide that the changes we made
    were no good, we can always go back to our master branch, and everything will
    be like it was before we started. However, if we, on the other hand, are happy
    with the changes, we can now bring the two branches together. In GIT, this is
    called a **merge**. The first thing we should do before merging the two branches
    is make sure that the branch we want to merge is active. In this case, it is the
    master branch, so we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to merge the changes we made back into the master branch.
    We can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we take the changes made in the branch called `subtract` and `merge`
    it with the content of the current branch, `master`. We can illustrate this with
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Merging the subtract branch with the master branch](img/Figure_11.4_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Merging the subtract branch with the master branch
  prefs: []
  type: TYPE_NORMAL
- en: This is how we can use version control with GIT on our local machine. Now, let's
    see how we can use it to collaborate with other programmers who work on the same
    project as us. For that, we will need not only our local repository but also a
    central repository that we can use to update the other on the changes we make.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that Alice and Bob are both working on the same project and want
    to use GIT to update each other on the changes they make to any files in the project.
    They will not only have their local GIT repositories, as we saw in the preceding
    example, but they will also connect to a centralized repository. Any changes they
    make can now be pushed to this repository, and they can also pull down any changes
    the other person made from that repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Two programmers connected to a central repository](img/Figure_11.5_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Two programmers connected to a central repository
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now assume that they will both work on the same file we saw previously,
    `calc.code`, and that it has the same content as we left it with, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The central repository is often referred to as the `multiply` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing she should do is pull down the latest version from the central
    repository (origin) with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'She now has the latest version, and she can begin implementing her function.
    She decides to do this in a new branch, so she executes the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'She will then switch to this branch with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, she can make the necessary changes, so she adds the following code to
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's leave Alice here and check what Bob is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Alice has started her work, Bob decides he wants to create a `divide`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like Alice, he will pull down the latest version of the `master` branch
    and create a new branch called `divide`, switch to it, and then change the `calc.code`
    file, so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, Alice is happy with her changes, so she commits them to her branch
    and merges her branch with the master.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, she wants to push these changes to the central repository. Before she
    does that, though, she wants to make sure that changes have been made to the central
    repository. So, first, she tries to pull down any changes to her repository with
    the same command she ran previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since nothing has happened to the central repository since her last pull, nothing
    will happen. She can now push her changes with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, her changes are stored in the central repository. At this point, her local
    version of the `master` branch and the version stored in the central repository
    are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to Bob, who has finished his function. He commits his changes
    to his local repository in his branch and merges it into the master branch. Now,
    he is ready to commit his changes to the central repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like Alice, first, he wants to make sure that he has the latest changes
    from the central repository, so he issues a `pull` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, things will not go so well. He gets a message that there has been
    a merge conflict. What''s that? He opens the code file, and he now sees this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happened was that he and Alice made changes to the same file on the same
    line, which is at the end of the file in this case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GIT became confused due to this and needs help to decide what will be in the
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob looks at this and understands that Alice has added a function to the same
    location in the file that he did, and he understands that both functions should
    be there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `<<<<<<< HEAD` marker indicates the beginning of the conflict. What is between
    that line and the `=======` line is the changes he pulled down. The code between
    `=======` and  `>>>>>>> div` are his changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since he decides that both functions should be in this file, he removes the
    three marker lines from the file, so it now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: He can now commit his changes to his local repository and then push the changes
    so that Alice can get the changes later.
  prefs: []
  type: TYPE_NORMAL
- en: This illustrates how a version control system can be used to share work between
    multiple programmers in a project. There are, of course, many other aspects of
    version control systems that we did not cover here, but now, you at least have
    an idea about what a version control system can do for you and how it can be used
    to share work with others.
  prefs: []
  type: TYPE_NORMAL
- en: This tool is used throughout the development process. Now, let's look at what
    we do when the code is written, as well as how we can make sure that it is working
    before we push it to the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time for unit testing!
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing our code is essential so that we can verify that it does what it should.
    We will also use tests to make sure that any changes we make to the code have
    not made things that previously worked stop working or behave in an undesired
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Several kinds of testing can be done on our code, and the first type of test
    we will look at is called a **unit test**. The unit part indicates that the test
    will be done on a separate unit of our code. This is typically at a function level.
    This means that we will try to isolate one single function (or another small unit
    of code) and run our tests on just that unit.
  prefs: []
  type: TYPE_NORMAL
- en: These tests are typically written by the developer of the code unit to be tested
    and are often automated. This means that as soon as a block of code is ready to
    be committed to the version control system, it must first pass the unit test written
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the unit test only tests a single code unit, they are typically rather
    trivial. To test our `calc` functions, we must first decide what we want to test.
    First, we can set up some test cases for valid input and match these inputs to
    some expected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do this in a table like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 11.1 ](img/Chapter_11_table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 11.1
  prefs: []
  type: TYPE_NORMAL
- en: We can use this to write our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests are typically written in a separate file that will call the code
    to be tested. They might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument, `assert.equal`, is what we expect as a result, and it is
    compared to the content of the `result` variable. If they match, this test will
    pass; if not, the test will fail. We can now go ahead and create tests in the
    same manner for the rest of our test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are just listing the first ones, but we continue like that with the
    rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple tests like these, the structure will be the same—call the function
    we want to test, store the returned value in a variable, and compare the returned
    value with the expected one. We should also think of odd cases and what kind of
    result we expect to get. For example, what will happen if we make this call to
    `divide`? Here is how the code appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in [*Chapter 9*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127),
    *When Things Go Wrong – Bugs and Exceptions*, we can't divide a number by zero.
    This will result in an exception. If we expect to get an exception when this is
    done, the function works, but if we expect the function to handle this case, it
    will need to be modified. This is done so that it returns whatever we decide it
    should return. This may happen if we decide that we should get another exception
    that indicates that we can't pass a 0 as the second argument. So, no matter what
    we expect, it should be tested.
  prefs: []
  type: TYPE_NORMAL
- en: This is one type of test that we should run on our code, but these tests will
    just test a single unit; that is, an isolated part of the application. We will
    also need to perform another type of test, called an integration test. We'll see
    what this is in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing is about putting several units together and testing them
    so that they work correctly when they are no longer isolated, but work together.
  prefs: []
  type: TYPE_NORMAL
- en: Units that work together will need to communicate, and they will communicate
    by passing data between them. This means that integration testing is about checking
    that the data transfer and data representation aspects work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are working on a project that is divided into several modules.
    To speed up development time, we let several programmers work on the separate
    modules. This might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Four developers working on four different modules](img/Figure_11.6_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Four developers working on four different modules
  prefs: []
  type: TYPE_NORMAL
- en: These four developers will now start to write their modules, and they will make
    sure that their modules meet the requirements by running unit tests on them. But
    the only thing these tests will show is that this module works in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: But in the final application, these modules will need to interact with each
    other, and when they do, they will need to send data back and forth. The problem
    here is that all four programmers are human, and humans tend to interpret even
    the most detailed description differently. So, if Carl needs to pass a value for
    a year to the module Alice is writing, he might pass it as a two-digit value,
    such as 23\. But Alice, who is writing the code receiving this data, might expect
    that the year comes in a four-digit format, so she expects 2023\.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we trace the communication between the modules when they are put together,
    this might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Modules communicating](img/Figure_11.7_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Modules communicating
  prefs: []
  type: TYPE_NORMAL
- en: This is just a small example. In real applications, there will be many more
    modules and many more lines of communication. But the point is that we will need
    to verify that all the data that's passed back and forth is valid and works in
    all situations.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will need to do what's called an **integration test**. This
    is when we test that different parts of the application are working when they're
    put together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done in several ways. There is a big-bang approach we can take,
    which means that we wait for all the modules to be completed, and then we put
    them together and test them. The disadvantage of this is that the modules will
    not be ready at the same time. If Alice, who writes Module A, is done with her
    work, she will need Bob to finish his work before she can integration test her
    module, as her work is making a call to Bob''s work. The same goes for Bob: he
    needs Carl to finish his work before he can integrate his module into the application.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other approaches where we don't wait for all the parts to be finished
    before we begin testing. Instead, we create *fake* modules, called **stubs** and
    **drivers**. A stub is a module that gets called by another module, while a driver
    is a module calling another module. We can create these to pass and accept data
    so that we can begin testing. They are not fully functional modules, but they
    act as the real modules for the sake of testing. As modules get completed, they
    can replace these stubs and drivers, and tests can then be performed on the real
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Having these tests in place is essential, partly because it verifies that the
    modules can interact with each other, but also for the future. When we add new
    functionality later, either by changing existing modules or adding new ones, we
    want to make sure that everything that worked previously still does. Inserting
    new code into an existing application can have unwanted side effects, and we must
    make sure that this has not happened.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit and integration testing are not the only types of tests we have. Depending
    on what kind of application we are creating and what requirements our software
    has when it comes to things such as data integrity, handling large workloads,
    compatibility with other applications, and so on, we can choose to expose the
    code for several different test types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly look at some of these tests.
  prefs: []
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System testing tests a system when it is completely integrated into its execution
    environment. Here, we will test things such as whether the login works, whether
    we can create and edit data in the application, whether the user interface presents
    data correctly, and whether we can delete entries.
  prefs: []
  type: TYPE_NORMAL
- en: These things are typically tested earlier in the development process too, but
    they need to be verified when the source code is in its live production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Acceptance testing is often divided into four different types:'
  prefs: []
  type: TYPE_NORMAL
- en: User acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operational acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructional and regulatory acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha and beta testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand these in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User acceptance testing**: This is a way to verify that the solution created
    works for the end users of our application. The questions we are trying to answer
    with these tests are if the users can use the software, if it is what they asked
    for, whether they have any trouble using it, and if the application behaves as
    anticipated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "**Operational acceptance testing**: This is done to verify the operational\
    \ readiness \Lof an application before it is released to end users."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructional and regulatory acceptance testing**: This is done to verify
    that the developed software fulfills the conditions specified in the agreement
    that was entered into with the organization that ordered the software. Regulatory
    testing verifies that the software conforms to the current regulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha and beta testing**: These are two tests that are performed to verify
    and identify all possible issues and bugs. Alpha testing is performed early in
    the development process, while beta testing is done near the end of the development
    process. They are both conducted by potential users of the finished product or
    by a group of people with a similar skill level as the end users of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regression testing focuses on finding defects after a significant code change
    and seeks to uncover software regressions. A software regression is a bug that
    will make some features in an application stop functioning after the update. There
    is also software performance regression, where the software still operates correctly,
    but where an update harmed the system's performance.
  prefs: []
  type: TYPE_NORMAL
- en: These were some other tests we can perform on our software. There are many more,
    but the ones we have covered here are among the most typical tests you will get
    exposed to as a software developer.
  prefs: []
  type: TYPE_NORMAL
- en: When we have code that is tested, we can make it available to the end users
    of our application. Before we talk about how to make the code we have written
    available to our users, we should stop and talk about what a release is.
  prefs: []
  type: TYPE_NORMAL
- en: Software releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating software, we don't want to start with an idea for the finished
    project and then get to work on everything that this application needs to do and,
    several years later, finally publish the finished software. The reason we don't
    want to do this is that during development time, several things will happen; for
    example, the requirements for this application might change, new laws can make
    us need to do things differently, and competing software solutions might be released,
    to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we want to implement some core features, release them to our users,
    and then immediately begin the development of the next release, which will contain
    some more features. This can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Development process through continuous iterations](img/Figure_11.8_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Development process through continuous iterations
  prefs: []
  type: TYPE_NORMAL
- en: We start with a vision or an idea. Then, we take some fundamental parts of this
    idea and implement them in what is called an **iteration**. During this iteration
    phase, we perform several steps, all of which we will look at in more detail soon.
    At the end of the iteration, we have code that works that we can release to our
    users. We then begin the next iteration, implementing more features that are released
    as soon as this iteration is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps that are taken during an iteration will vary, depending on the development
    methodology, but commonly, it will be something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Typical steps during one iteration](img/Figure_11.9_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Typical steps during one iteration
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that we take our ideas and requirements into the development
    cycle. First, we will perform an analysis and design the steps. Here, we are trying
    to answer two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is it that we will do (analysis)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we do it (design)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we know what we should do and how to do it, we can start to implement the
    different parts that go into this iteration.
  prefs: []
  type: TYPE_NORMAL
- en: As we finish a section of code, it gets unit tested, and then all the code undergoes
    integration tests. Other tests might also be performed before the code is released
    to end users. Releasing the code is called a **deployment**, a step we will look
    closer at soon.
  prefs: []
  type: TYPE_NORMAL
- en: What we have accomplished now is a release, and this means that our software
    now has some new features or bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin the next iteration. This is completed by evaluating the iteration
    we just ended. This is done so that we can fine-tune our workflow, see whether
    we have discovered some problems during the last cycle, or any other issues that
    we need to consider in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: We can then specify what will go into the next iteration, and by using that
    repeat the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a closer look at the deployment phase to learn what it is and
    how it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have some code to release, we will need to deploy it. Deployment is
    the process of making sure the software is installed in the right location, that
    it is secured to prevent any hacker attacks, and making sure that privileges are
    given to the software so that it can read and write files as needed.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is deployed, we usually want to test it again to make sure that
    everything is still working the way it is intended.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the code is usually done in several steps. Developers will typically
    have a server that's used during the development process. This is called the **development
    server**, and during development, the code can be executed and tested on this
    server. It will often come with a development database that, if the application
    we develop uses a database, is used to simulate the real data the application
    handles. Still, it can be modified any way the developer wants as it is detached
    from the real data the users see and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Before the code is moved to the production server, that is, the server the application
    users will use to run the application, the code is usually moved to an intermediate
    server, often referred to as a **staging server**. The role of this server is
    to be as much like the production server as possible so that the new code can
    be tested alongside the code that was already released. The idea is to make sure
    that everything runs smoothly and that no bugs appear when the new code hits the
    live production server.
  prefs: []
  type: TYPE_NORMAL
- en: The staging server also has a database. The data in this database is often copied
    from the production database to make sure that everything is a mirror of the real
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when the team is confident that everything works correctly, the code
    is moved to the production server. Apart from moving the code, other adjustments
    might be needed, such as adding things to the production database that the new
    software version will need, adding other applications and code libraries that
    are used by the new code, and so on. This is depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Example of servers and their databases](img/Figure_11.10_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Example of servers and their databases
  prefs: []
  type: TYPE_NORMAL
- en: We must also have a strategy for how we can undo this deployment if needed.
    No matter how thorough our test has been, when the code hits production and users
    start to use it, things that we never imagined begin surfacing. Users might behave
    in unpredicted ways, and there might be differences in the production environment
    compared to the staging environment that we overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: We always hope for the best, but we will need a plan for what we will do if
    things backfire. What we want is a way to undo all the changes and go back to
    what we had before the deployment as quickly as possible. This is called a **rollback
    strategy**.
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish such a rollback in several ways. One of them would be to take
    a backup of the production database before the deployment occurs. This way, we
    can ensure that we have a snapshot of how all the data in the application was,
    before the release of the new code.
  prefs: []
  type: TYPE_NORMAL
- en: The actual code is usually deployed to the server with the help of a VCS, so
    rolling back the actual code to a previous version is rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: The steps involved in deploying code to the production environment are often
    automated, meaning that different tools and applications take care of all the
    steps. Let's see how this automation works.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often a good idea to automate as many of the deployment steps as possible.
    The reason is that there are usually many steps involved that need to be done
    in the correct order, a job ideally suited for automation. At the same time, it's
    something where humans often make mistakes by forgetting to do something or do
    something in the wrong order.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the system, we can use several tools that will
    help us accomplish automated deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Automating deployment will ensure that we have high-quality code since the automation
    process typically runs tests and lets the code through to the production server
    that passes the tests.
  prefs: []
  type: TYPE_NORMAL
- en: It will also save time as the deployment steps will be performed much faster
    by the deployment tools than they would be if humans performed them.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is deployed, the work with it is not over. Deployed code must
    be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Code maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical software developer will spend more time maintaining existing code
    than writing new exciting features.
  prefs: []
  type: TYPE_NORMAL
- en: This is not very strange if we think about it. First, the lifespan of an application
    is typically much longer than the time it took to develop it. This means that
    there are more and more softwares out there that are running and performing their
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Programs that are used will always need maintenance as users will find bugs
    that we must fix, new features will be added to the application as demands from
    users change, and old features must be updated and improved.
  prefs: []
  type: TYPE_NORMAL
- en: This means that developers spend most of their time in old code, fixing and
    updating it. This can be code written decades ago by someone who has left the
    company a long time ago, or it can be written by you just the other week.
  prefs: []
  type: TYPE_NORMAL
- en: If you think ahead to what your life as a programmer will look like, you will
    most likely imagine yourself writing new, exciting software that uses the latest
    tools and features that are out there. Still, the fact is that it is much more
    likely that you will be poking around in code written a long time ago, in a version
    of the language that was released when you were in preschool.
  prefs: []
  type: TYPE_NORMAL
- en: At times, you will have the chance to write that brand-new, cool, and shiny
    piece of software, but remember, if you do a good job, that code will live on
    and will need to be maintained by others (or yourself) in the future.
  prefs: []
  type: TYPE_NORMAL
- en: That is the life of a software developer. This means that we need to ensure
    that the code we write is as maintainable as possible. A skilled software developer
    is someone who writes highly maintainable code. This means that the code is clear,
    easy to understand, and easy to change, without the risk of people introducing
    some unwanted side effects in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple rule we can follow to help us create maintainable code: the
    boy scout rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The legend of the boy scout rule says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Leave the campground cleaner than you found it.*'
  prefs: []
  type: TYPE_NORMAL
- en: I have no evidence that this rule was ever used by actual scouts. It is more
    likely a variant of a message the founder of the scout movement, Robert Baden-Powell,
    left to the movement before his death. In that message, he said, *Try to leave
    this world a little better than you found it.*
  prefs: []
  type: TYPE_NORMAL
- en: In the book *Clean Code,* the author, Robert C. Martin, also known as Uncle
    Bob, transformed this rule so that it could be applied to code. He states that
    if we apply this rule when we maintain our code, we should always leave our code
    a little cleaner and better each time we maintain it so that its quality will
    increase over time. We can rephrase the boy scout rule in relation to software
    development so that it says, *Always leave the code you're editing a little better
    than you found it*.
  prefs: []
  type: TYPE_NORMAL
- en: The changes do not have to be huge. You will not have to rewrite large sections
    of code. If you change a variable name to something that better describes the
    value it is holding, or adding documentation to a piece of code where it was missing
    previously will increase the code's quality slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186), *Code Quality,*
    and [*Appendix A*](B15554_AppA_Final_NM_ePub.xhtml#_idTextAnchor210), *How To
    Translate the Pseudocode into Real Code*, we will dive deeper into how we can
    write high-quality code, among other things, while keeping maintainability in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of how to get the software to our users, when we are
    done writing and testing it, we should take a closer look at the actual development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Software development process methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the 1960s, different methodologies have been developed to help system
    developers be more productive, on target, and create higher quality code. Here,
    we will look at some of the more essential methodologies – some that are in use
    today and some that have been superseded by newer and more flexible ones.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The waterfall development model is one that almost everyone loves to hate. We
    will look at it anyway, as many newer methodologies have been developed as a reaction
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it is hated, is that it will not take changing requirements into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the waterfall model, several defined steps are completed, one preceding
    the next. An example of these steps can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – The steps in the waterfall model](img/Figure_11.11_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – The steps in the waterfall model
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the model works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we gather all the requirements needed for this application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we make a system design, where we describe how different responsibilities
    will be divided between different parts of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we write the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the verification phase, the code is tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, when the software is released, it goes into the maintenance phase,
    where it is maintained.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main criticism of this model is that it will not capture new requirements
    that might (and often will) arise during the development phase. The process of
    going from an initial idea to a finalized product can be rather long, and during
    this time, a lot of things will happen that will have an impact on this application.
    New laws can come into place,  competing applications might be released, new versions
    of operating systems and other software that this application relies on might
    be released, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a development model that cannot capture these changes, we will most
    likely have developed a product that is outdated before it has even been released.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at a methodology that is not in use anymore, or at least,
    no one will say that they are using it, we can look at some that are in use and
    that are created as a reaction to the waterfall model.
  prefs: []
  type: TYPE_NORMAL
- en: Spiral model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1986, the American software engineer Barry Boehm described and depicted a
    model that, instead of going from one phase to the next, was shaped as a spiral.
  prefs: []
  type: TYPE_NORMAL
- en: This idea has since been developed and modified into several new methodologies.
    Still, the basic idea of driving the development process by a spiral has been
    prevalent since then.
  prefs: []
  type: TYPE_NORMAL
- en: One key concept in the spiral model is that risk is taken into consideration
    as a critical concept when developing software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see a simplified version of the spiral model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – A simplified version of the spiral model](img/Figure_11.12_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – A simplified version of the spiral model
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have four distinct phases. Instead of going through them once in order,
    we will iterate through them over and over as many times as necessary until the
    application is developed. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, we look at the objectives, as we see them at this point
    in the development process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then look at the risks. What can hinder us from succeeding in implementing
    the objectives we just determined? By identifying the risks, we have a higher
    chance of avoiding them or at least minimizing the impact they will have on our
    software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is done, we will go ahead and develop and test the software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last phase is a review phase. Here, we look back at what we have done in
    the other three phases during this iteration, including what went well and what
    problems we had. We can learn from this so that the next iteration is better.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then start over with the objectives for the next iteration by determining
    the risks and developing and reviewing them repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: The growing spiral illustrates that, for each iteration, more of the software
    has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the spiral model was created as a reaction to the shortcomings of the
    waterfall model, this claim shows that the problem is not the Waterfall model
    in itself, but that the development process becomes very prolonged and therefore
    can't react to rapid changes in requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The spiral model gave inspiration to several new methodologies, where the development
    process is divided into smaller iterations. The next one is one such example and
    the one that is currently the foundation of how most software projects are run.
  prefs: []
  type: TYPE_NORMAL
- en: Barry Boehm also said that this model is just a series of small waterfall models.
  prefs: []
  type: TYPE_NORMAL
- en: Agile development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agile software development refers to a group of software methodologies, all
    based on iterative development.
  prefs: []
  type: TYPE_NORMAL
- en: The term *agile* comes from a group of 17 software developers who met at a resort
    in Snowbird, Utah, in 2001\. After the meeting, they published *Manifesto for
    Agile Software Development*.
  prefs: []
  type: TYPE_NORMAL
- en: The manifesto is a short description of what should be prioritized during the
    software development process.
  prefs: []
  type: TYPE_NORMAL
- en: It can be found at [https://agilemanifesto.org/](https://agilemanifesto.org/).
  prefs: []
  type: TYPE_NORMAL
- en: This manifesto is then outlined in more detail by twelve principles, called
    *Principles behind the Agile Manifesto*, and they can be found here at [https://agilemanifesto.org/principles.html](https://agilemanifesto.org/principles.html).
  prefs: []
  type: TYPE_NORMAL
- en: These ideas had a significant impact on the software industry, and several new
    software development methodologies were developed in response to the manifesto.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the more popular of these.
  prefs: []
  type: TYPE_NORMAL
- en: Agile Scrum methodology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This methodology, better known as Scrum, is a lightweight project management
    framework that uses an iterative and incremental approach.
  prefs: []
  type: TYPE_NORMAL
- en: In Scrum, the product owner – a person with the power to decide what items will
    go into the application – plays a central role. This person needs to play an active
    role throughout the development process.
  prefs: []
  type: TYPE_NORMAL
- en: The product owner works closely with the development team to create a prioritized
    list of system functionality, called the **product backlog**. The product backlog
    consists of whatever needs to be done to deliver a working software system successfully.
    The items in the backlog can be things such as the features of the application,
    bugs that need to be fixed, and non-functional requirements such as certification,
    accessibility, and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: When the properties in the backlog have been prioritized, a team of developers
    (and potentially other roles, if needed) will start to develop in what can be
    called *potentially shippable increments*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the team will take some of the highest prioritized items from
    the backlog and start to implement them during a short time frame, known as a
    **sprint**. A sprint will typically last for somewhere between 14 and 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of the sprint is preferably fully functional so that it can immediately
    be put into production, and users can start using this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The team will then start over with a new sprint. This will be repeated as many
    times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Lean software development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This Agile methodology is iterative, just like Scrum, and focuses on delivering
    fully functional batches. The methodology is highly flexible and does not have
    any rigid rules or guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Its main idea is to eliminate what is called *waste*. This is done by letting
    users of the system select only the precious features for the system. These features
    are then prioritized and delivered in small batches.
  prefs: []
  type: TYPE_NORMAL
- en: It relies on rapid and reliable feedback from the users of the software. In
    Lean development, the work is *pulled* by customer requests.
  prefs: []
  type: TYPE_NORMAL
- en: Extreme Programming (XP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This methodology was first described by Kent Beck, an American software engineer
    who took software best practices to an extreme level. One example of this is code
    review. Standard practice is that another developer should review all the code
    before it can be merged with the code that goes into a release. In XP, this is
    done by using the concept of *pair programming*. Pair programming is when two
    developers are using one computer to develop code. One is called the *driver*
    and is the one that will write the code. The other developer is called the *observer*
    or the *navigator* and will observe and review what the driver is doing. The two
    will frequently switch roles.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the traditional code review process, this will speed things up as
    the review is done during the development phase. Other benefits of pair programming
    include the fact that the driver will consistently get input from the observer
    regarding how to solve the current task.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of XP is to reduce the cost of changes in the requirements. To do this,
    XP uses short development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: In XP, changes in requirements are a natural, inescapable, and desirable aspect
    of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the more essential concepts that go into
    software development that have nothing to do with the actual coding. Even if we
    are not working on large-scale, professional projects, we should still version
    control our code, write tests to verify that the code does what it is supposed
    to, and work iteratively.
  prefs: []
  type: TYPE_NORMAL
- en: We began by learning that version control systems are a great tool that will
    help us not only be able to go back in time to an earlier version of the code,
    but also help us share our code with other developers in our team.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we saw that to verify that the code we have written is doing what it is
    supposed to, we need to test it. In this case, we have something called unit tests
    and integration tests that we should perform to make sure that the application
    produces the correct result and that the new code does not produce any side effects,
    which would produce an undesirable result for a code that worked successfully
    in a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we saw that the software release life cycle defines what steps are
    to be performed to make a piece of code mature enough to be released to end users.
    When code is ready to be released, we need to deploy it to the environment (for
    example, as an application server) so that the end users of this application can
    access it. When the code is used, we need to maintain it. Bugs will be discovered,
    features will need to be added or changed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned that to handle the development process, a software development
    team will typically use a development methodology. The methodology will describe
    in what order things should be done, how the team will cooperate to achieve a
    good result, and how to decide what will go into a software release.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how we can write high-quality code,
    and what we mean by code quality.
  prefs: []
  type: TYPE_NORMAL
