- en: Graphs and Other Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图与其他算法
- en: In this chapter, we are going to talk about graphs. This is a concept that comes
    from the branch of mathematics called graph theory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论图。这是一个来自数学分支图论的概念。
- en: Graphs are used to solve a number of computing problems. They also have much
    less structure than other data structures we have looked at and things like traversal
    can be much more unconventional, as we shall see.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图被用来解决许多计算问题。它们比我们之前看到的其他数据结构结构简单得多，并且像遍历这样的操作可能更加不寻常，正如我们将看到的。
- en: 'By the end of this chapter, you should be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够做到以下几件事情：
- en: Understand what graphs are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图是什么
- en: Know the types of graphs and their constituents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图的类型及其组成部分
- en: Know how to represent a graph and traverse it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何表示图并遍历它
- en: Get a fundamental idea of what priority queues are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得对优先队列的基本理解
- en: Be able to implement a priority queue
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够实现优先队列
- en: Be able to determine the ith smallest element in a list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定列表中的第i个最小元素
- en: Graphs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: A graph is a set of vertices and edges that form connections between the vertices.
    In a more formal approach, a graph G is an ordered pair of a set V of vertices
    and a set E of edges given as `G = (V, E)` in formal mathematical notation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一组顶点和边，它们在顶点之间形成连接。在更正式的方法中，图G是一个顶点集合V和边集合E的有序对，用形式数学符号表示为`G = (V, E)`。
- en: 'An example of a graph is given here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出一个图的例子：
- en: '![](img/CH_08_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_08_01.png)'
- en: 'Let''s now go through some definitions of a graph:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来了解一下图的定义：
- en: '**Node or vertex**: A point, usually represented by a dot in a graph. The vertices
    or nodes are A, B, C, D, and E.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点或顶点**：一个点，通常在图中用点表示。顶点或节点是A、B、C、D和E。'
- en: '**Edge**: This is a connection between two vertices. The line connecting A
    and B is an example of an edge.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：这是两个顶点之间的连接。连接A和B的线条是一个边的例子。'
- en: '**Loop**: When an edge from a node is incident on itself, that edge forms a
    loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：当一个节点的边指向自身时，该边形成一个环。'
- en: '**Degree of a vertex**: This is the number of vertices that are incident on
    a given vertex. The degree of vertex B is `4`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点的度**：这是与给定顶点相关的顶点的数量。顶点B的度是`4`。'
- en: '**Adjacency**: This refers to the connection(s) between a node and its neighbor.
    The node C is adjacent to node A because there is an edge between them.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接**：这指的是节点与其邻居之间的连接。节点C与节点A相邻，因为它们之间有一条边。'
- en: '**Path**: A sequence of vertices where each adjacent pair is connected by an
    edge.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：一个顶点的序列，其中每个相邻对都通过一条边连接。'
- en: Directed and undirected graphs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向和无向图
- en: 'Graphs can be classified based on whether they are undirected or directed.
    An undirected graph simply represents edges as lines between the nodes. There
    is no additional information about the relationship between the nodes than the
    fact that they are connected:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们是无向的还是有向的，可以将图进行分类。无向图只是将边表示为节点之间的线条。除了节点之间有连接这一事实之外，没有关于节点之间关系的其他信息：
- en: '![](img/image_08_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_001.jpg)'
- en: 'In a directed graph, the edges provide orientation in addition to connecting
    nodes. That is, the edges, which will be drawn as lines with an arrow, will point
    in which direction the edge connects the two nodes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边除了连接节点外，还提供了方向。也就是说，作为线条带有箭头的边将指向边连接的两个节点的方向：
- en: '![](img/CH_08_06.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_08_06.png)'
- en: The arrow of an edge determines the flow of direction. One can only move from
    **A** to **B** in the preceding diagram. Not **B** to **A**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 边的箭头决定了方向的流动。在前面的图中，只能从**A**移动到**B**，不能从**B**移动到**A**。
- en: Weighted graphs
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权图
- en: 'A weighted graph adds a bit of extra information to the edges. This can be
    a numerical value that indicates something. Let''s say, for example, that the
    following graph indicates different ways to get from point **A** to point **D**.
    You can either go straight from **A** to **D**, or choose to pass through **B**
    and **C**. Associated with each edge is the amount of time in minutes the journey
    to the next node will take:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图在边中添加了一些额外的信息。这可以是一个表示某物的数值。比如说，以下图表示从点**A**到点**D**的不同方式。你可以直接从**A**到**D**，或者选择经过**B**和**C**。每个边都与到达下一个节点所需的时间（分钟）相关联：
- en: '![](img/image_08_002.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_002.jpg)'
- en: Perhaps the journey **AD** would require you to ride a bike (or walk). **B**
    and **C** might represent bus stops. At **B** you would have to change to a different
    bus. Finally, **CD** may be a short walk to reach **D**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也许 **AD** 的旅程需要你骑自行车（或步行）。**B** 和 **C** 可能代表公交车站。在 **B**，你可能需要换乘不同的公交车。最后，**CD**
    可能是一段短途步行即可到达 **D**。
- en: In this example, **AD** and **ABCD** represent two different paths. **A** path
    is simply a sequence of edges that you *pass through* between two nodes. Following
    these paths, you see that the total journey **AD** takes **40** minutes, whereas
    the journey **ABCD** takes **25** minutes. If your only concern is time, you would
    be better off traveling along **ABCD**, even with the added inconvenience of changing
    buses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**AD** 和 **ABCD** 代表两条不同的路径。**路径**简单地说是一系列边，你在两个节点之间通过这些边。沿着这些路径，你会发现
    **AD** 的总旅程需要 **40** 分钟，而 **ABCD** 的旅程需要 **25** 分钟。如果你的唯一关注点是时间，你最好沿着 **ABCD**
    行驶，即使有换乘公交车的额外不便。
- en: The fact that edges can be directed and may hold other information, such as
    time taken or whatever other value the move along a path is associated with, indicates
    something interesting. In previous data structures that we have worked with, the
    *lines* we have drawn between nodes have simply been connectors. Even when they
    had arrows pointing from a node to another, that was easy to represent in the
    node class by using `next` or `previous`, `parent` or `child`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 边可以是定向的，并且可能包含其他信息，如花费的时间或路径上移动关联的任何其他值，这表明了一些有趣的事情。在我们之前使用过的数据结构中，我们画在节点之间的“线”仅仅是连接器。即使它们有从节点指向另一个节点的箭头，这也很容易在节点类中使用
    `next` 或 `previous`、`parent` 或 `child` 来表示。
- en: With graphs, it makes sense to see edges as objects just as much as nodes. Just
    like nodes, edges can contain extra information that is necessary to follow a
    particular path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，将边视为对象与将节点视为对象一样有意义。就像节点一样，边可以包含必要的信息，以便遵循特定的路径。
- en: Graph representation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的表示
- en: Graphs can be represented in two main forms. One way is to use an adjacency
    matrix and the other is to use an adjacency list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以以两种主要形式表示。一种方式是使用邻接矩阵，另一种方式是使用邻接表。
- en: 'We shall be working with the following figure to develop both types of representation
    for graphs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下图形来开发图的两种表示类型：
- en: '![](img/CH_08_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_08_02.png)'
- en: Adjacency list
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'A simple list can be used to present a graph. The indices of the list will
    represent the nodes or vertices in the graph. At each index, the adjacent nodes
    to that vertex can be stored:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个简单的列表来表示图。列表的索引将代表图中的节点或顶点。在每个索引处，可以存储该顶点的相邻节点：
- en: '![](img/CH_08_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_08_03.png)'
- en: The numbers in the box represent the vertices. Index **0** represents vertex
    **A**, with its adjacent nodes being **B** and **C**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 方框中的数字代表顶点。索引 **0** 代表顶点 **A**，其相邻节点为 **B** 和 **C**。
- en: 'Using a list for the representation is quite restrictive because we lack the
    ability to directly use the vertex labels. A dictionary is therefore more suited.
    To represent the graph in the diagram, we can use the following statements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表进行表示非常受限，因为我们缺乏直接使用顶点标签的能力。因此，字典更适合。为了在图中表示图，我们可以使用以下语句：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we easy establish that vertex **A** has the adjacent vertices **B** and
    **C**. Vertex F has vertex **C** as its only neighbor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地确定顶点 **A** 的相邻顶点是 **B** 和 **C**。顶点 **F** 的唯一邻接顶点是 **C**。
- en: Adjacency matrix
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: Another approach by which a graph can be represented is by using an adjacency
    matrix. A matrix is a two-dimensional array. The idea here is to represent the
    cells with a 1 or 0 depending on whether two vertices are connected by an edge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示图的方法是使用邻接矩阵。矩阵是一个二维数组。这里的想法是根据两个顶点是否通过边连接，用 1 或 0 来表示单元格。
- en: 'Given an adjacency list, it should be possible to create an adjacency matrix.
    A sorted list of keys of graph is required:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个邻接表，应该可以创建一个邻接矩阵。需要一个排序后的图键列表：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The length of the keys is used to provide the dimensions of the matrix which
    are stored in `cols` and `rows`. These values in `cols` and `rows` are equal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 键的长度用于提供矩阵的维度，这些维度存储在 `cols` 和 `rows` 中。`cols` 和 `rows` 中的这些值是相等的：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then set up a `cols` by `rows` array, filling it with zeros. The `edges_list`
    variable will store the tuples that form the edges of in the graph. For example,
    an edge between node A and B will be stored as (A, B).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置一个`cols`乘以`rows`的数组，用零填充它。`edges_list`变量将存储构成图中边的元组。例如，节点A和B之间的边将被存储为(A,
    B)。
- en: 'The multidimensional array is filled using a nested for loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套`for`循环填充多维数组：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The neighbors of a vertex are obtained by `graph[key]`. The key in combination
    with the `neighbor` is then used to create the tuple stored in `edges_list`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`graph[key]`获取顶点的邻居。然后，使用`neighbor`与键结合来创建存储在`edges_list`中的元组。
- en: 'The output of the iteration is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代输出如下：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What needs to be done now is to fill the our multidimensional array by using
    1 to mark the presence of an edge with the line `adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要做的是通过使用1标记边的存在来填充我们的多维数组，使用以下行`adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `matrix_elements` array has its `rows` and `cols` starting from A through
    to E with the indices 0 through to 5\. The `for` loop iterates through our list
    of tuples and uses the `index` method to get the corresponding index where an
    edge is to be stored.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix_elements`数组从A到E的行和列开始，索引从0到5。`for`循环遍历我们的元组列表，并使用`index`方法获取要存储边的相应索引。'
- en: 'The adjacency matrix produced looks like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的邻接矩阵如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At column 1 and row 1, the 0 there represents the absence of an edge between
    A and A. On column 2 and row 3, there is an edge between C and B.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1列和第1行，那里的0表示A和A之间没有边。在第2列和第3行，C和B之间存在边。
- en: Graph traversal
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图遍历
- en: Since graphs don't necessarily have an ordered structure, traversing a graph
    can be more involving. Traversal normally involves keeping track of which nodes
    or vertices have already been visited and which ones have not. A common strategy
    is to follow a path until a dead end is reached, then walking back up until there
    is a point where there is an alternative path. We can also iteratively move from
    one node to another in order to traverse the full graph or part of it. In the
    next section, we will discuss breadth and depth-first search algorithms for graph
    traversal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图不一定有有序结构，遍历图可能更复杂。遍历通常涉及跟踪哪些节点或顶点已经被访问，哪些还没有。一种常见策略是沿着路径走，直到达到死胡同，然后返回直到有替代路径的点。我们也可以迭代地从节点移动到另一个节点，以遍历整个图或其部分。在下一节中，我们将讨论图遍历的广度和深度优先搜索算法。
- en: Breadth-first search
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: The breadth-first search algorithm starts at a node, chooses that node or vertex
    as its root node, and visits the neighboring nodes, after which it explores neighbors
    on the next level of the graph.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索算法从一个节点开始，选择该节点或顶点作为其根节点，然后访问相邻的节点，之后它探索图的下一级的邻居节点。
- en: 'Consider the following diagram as a graph:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图作为示例：
- en: '![](img/CH_08_05.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_08_05.png)'
- en: The diagram is an example of an undirected graph. We continue to use this type
    of graph to help make explanation easy without being too verbose.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该图是一个无向图的示例。我们继续使用这种类型的图来帮助解释，而不太冗长。
- en: 'The adjacency list for the graph is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该图的邻接表如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In trying to traverse this graph breadth first, we will employ the use of a
    queue. The algorithm creates a list to store the nodes that have been visited
    as the traversal process proceeds. We shall start our traversal from node A.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试广度优先遍历此图时，我们将使用队列。算法创建一个列表来存储在遍历过程中已访问的节点。我们将从节点A开始我们的遍历。
- en: Node A is queued and added to the list of visited nodes. Afterward, we use a
    `while` loop to effect traversal of the graph. In the `while` loop, node A is
    dequeued. Its unvisited adjacent nodes B, G, and D are sorted in alphabetical
    order and queued up. The queue will now contain the nodes B, D, and G. These nodes
    are also added to the list of visited nodes. At this point, we start another iteration
    of the `while` loop because the queue is not empty, which also means we are not
    really done with the traversal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 节点A被排队并添加到已访问节点的列表中。之后，我们使用`while`循环来实现图的遍历。在`while`循环中，节点A被出队。它的未访问相邻节点B、G和D按字母顺序排序并排队。现在队列将包含节点B、D和G。这些节点也被添加到已访问节点的列表中。此时，我们开始`while`循环的另一个迭代，因为队列不为空，这也意味着我们实际上还没有完成遍历。
- en: Node B is dequeued. Out of its adjacent nodes A, F, and E, node A has already
    been visited. Therefore, we only enqueue the nodes E and F in alphabetical order.
    Nodes E and F are then added to the list of visited nodes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 B 被出队。在其相邻节点 A、F 和 E 中，节点 A 已经被访问。因此，我们只按字母顺序入队节点 E 和 F。节点 E 和 F 然后添加到已访问节点列表中。
- en: 'Our queue now holds the following nodes at this point: D, G, E, and F. The
    list of visited nodes contains A, B, D, G, E, F.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的队列包含以下节点：D、G、E 和 F。已访问节点列表包含 A、B、D、G、E、F。
- en: Node D is dequeued but all of its adjacent nodes have been visited so we simply
    dequeue it. The next node at the front of the queue is G. We dequeue node G but
    we also find out that all its adjacent nodes have been visited because they are
    in the list of visited nodes. Node G is also dequeued. We dequeue node E too because
    all of its nodes have been visited. The only node in the queue now is node F.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 D 被出队，但所有相邻节点都已访问，所以我们只需将其出队。队列前面的下一个节点是 G。我们出队节点 G，但我们还发现所有相邻节点都已访问，因为它们在已访问节点列表中。节点
    G 也被出队。我们也出队节点 E，因为所有节点都已访问。现在队列中只剩节点 F。
- en: Node F is dequeued and we realize that out of its adjacent nodes B, D, and C,
    only node C has not been visited. We then enqueue node C and add it to the list
    of visited nodes. Node C is dequeued. Node C has the adjacent nodes F and H but
    F has already been visited, leaving node H. Node H is enqueued and added to the
    list of visited nodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 F 被出队，我们意识到在其相邻节点 B、D 和 C 中，只有节点 C 尚未访问。然后我们将节点 C 入队并添加到已访问节点列表中。节点 C 被出队。节点
    C 有相邻节点 F 和 H，但 F 已经被访问，留下节点 H。节点 H 被入队并添加到已访问节点列表中。
- en: Finally, the last iteration of the `while` loop will lead to node H being dequeued.
    Its only adjacent node C has already been visited. Once the queue is completely
    empty, the loop breaks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`while` 循环的最后一次迭代将导致节点 H 被出队。它的唯一相邻节点 C 已经被访问。一旦队列完全为空，循环就会中断。
- en: The output of the traversing the graph in the diagram is A, B, D, G, E, F, C,
    H.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图中遍历的输出为 A、B、D、G、E、F、C、H。
- en: 'The code for a breadth-first search is given as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索的代码如下：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we want to find out whether a set of nodes are in the list of visited nodes,
    we use the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
    This uses the set object's difference method to find the nodes that are in `adj_nodes`
    but not in `visited_vertices`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要找出是否有一组节点在已访问节点列表中时，我们使用语句 `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`。这使用集合对象的差集方法来找出在
    `adj_nodes` 中但不在 `visited_vertices` 中的节点。
- en: In the worst-case scenario, each vertex or node and edge will be traversed,
    thus the time complexity of the algorithm is `O(|V| + |E|)`, where `|V|` is the
    number of vertices or nodes while `|E|` is the number of edges in the graph.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，每个顶点或节点和边都将被遍历，因此算法的时间复杂度为 `O(|V| + |E|)`，其中 `|V|` 是顶点或节点的数量，而 `|E|`
    是图中边的数量。
- en: Depth-first search
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'As the name suggests, this algorithm traverses the depth of any particular
    path in the graph before traversing its breadth. As such, child nodes are visited
    first before sibling nodes. It works on finite graphs and requires the use of
    a stack to maintain the state of the algorithm:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此算法在遍历图的宽度之前先遍历任何特定路径的深度。因此，先访问子节点，然后访问兄弟节点。它适用于有限图，并需要使用栈来维护算法的状态：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The algorithm begins by creating a list to store the visited nodes. The `graph_stack`
    stack variable is used to aid the traversal process. For continuity's sake, we
    are using a regular Python list as a stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先创建一个列表来存储已访问的节点。`graph_stack` 栈变量用于辅助遍历过程。为了连续性，我们使用常规 Python 列表作为栈。
- en: 'The starting node, called `root`, is passed with the graph''s adjacency matrix,
    graph. `root` is pushed onto the stack. `node = root` holds the first node in
    the stack:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 起始节点，称为 `root`，与图的邻接矩阵 `graph` 一起传递。`root` 被压入栈中。`node = root` 保存栈中的第一个节点：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The body of the `while` loop will be executed provided the stack is not empty.
    If `node` is not in the list of visited nodes, we add it. All adjacent nodes to
    `node` are collected by `adj_nodes = graph[node]`. If all the adjacent nodes have
    been visited, we pop that node from the stack and set `node` to `graph_stack[-1]`.
    `graph_stack[-1]` is the top node on the stack. The `continue` statement jumps
    back to the beginning of the while loop's test condition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈不为空时，将执行`while`循环的主体。如果`node`不在已访问节点的列表中，我们将它添加进去。通过`adj_nodes = graph[node]`收集`node`的所有相邻节点。如果所有相邻节点都已访问，我们就从栈中弹出该节点，并将`node`设置为`graph_stack[-1]`。`graph_stack[-1]`是栈顶的节点。`continue`语句将跳回到`while`循环测试条件的开始。
- en: If, on the other hand, not all the adjacent nodes have been visited, the nodes
    that are yet to be visited are obtained by finding the difference between the
    `adj_nodes` and `visited_vertices` with the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是所有相邻节点都已访问，则通过使用语句`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`找到`adj_nodes`和`visited_vertices`之间的差异，以获取尚未访问的节点。
- en: The first item within `sorted(remaining_elements)` is assigned to `first_adj_node`,
    and pushed onto the stack. We then point the top of the stack to this node.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sorted(remaining_elements)`中的第一个项目分配给`first_adj_node`，并将其推入栈中。然后我们将栈顶指向该节点。
- en: When the `while` loop exists, we will return the `visited_vertices`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环退出时，我们将返回`visited_vertices`。
- en: 'Dry running the algorithm will prove useful. Consider the following graph:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实际运行算法将非常有用。考虑以下图：
- en: '![](img/CH_08_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_08_04.png)'
- en: 'The adjacency list of such a graph is given as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样图的邻接表如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Node A is chosen as our beginning node. Node A is pushed onto the stack and
    added to the `visisted_vertices` list. In doing so, we mark it as having been
    visited. The stack `graph_stack` is implemented with a simple Python list. Our
    stack now has A as its only element. We examine node A''s adjacent nodes B and
    S. To test whether all the adjacent nodes of A have been visited, we use the if
    statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 节点A被选为起始节点。节点A被推入栈中，并添加到`visisted_vertices`列表中。这样做时，我们将其标记为已访问。`graph_stack`栈使用简单的Python列表实现。我们的栈现在只有一个元素A。我们检查节点A的相邻节点B和S。为了测试A的所有相邻节点是否都已访问，我们使用if语句：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If all the nodes have been visited, we pop the top of the stack. If the stack
    `graph_stack` is not empty, we assign the node on top of the stack to `node` and
    start the beginning of another execution of the body of the `while` loop. The
    statement `set(adj_nodes).issubset(set(visited_vertices))` will evaluate to `True`
    if all the nodes in `adj_nodes` are a subset of `visited_vertices`. If the if
    statement fails, it means that some nodes remain to be visited. We obtain that
    list of nodes with `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已访问，我们就弹出栈顶。如果栈`graph_stack`不为空，我们将栈顶的节点赋值给`node`，并开始`while`循环主体的另一个执行。如果`set(adj_nodes).issubset(set(visited_vertices))`语句评估为`True`，则表示`adj_nodes`中的所有节点都是`visited_vertices`的子集。如果if语句失败，则意味着还有一些节点尚未访问。我们通过`remaining_elements
    = set(adj_nodes).difference(set(visited_vertices))`获取那些节点的列表。
- en: 'From the diagram, nodes **B** and **S** will be stored in `remaining_elements`.
    We will access the list in alphabetical order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，节点**B**和**S**将被存储在`remaining_elements`中。我们将按字母顺序访问该列表：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We sort `remaining_elements` and return the first node to `first_adj_node`.
    This will return B. We push node B onto the stack by appending it to the `graph_stack`.
    We prepare node B for access by assigning it to `node`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`remaining_elements`进行排序，并将第一个节点返回给`first_adj_node`。这将返回B。我们将节点B推入栈中，通过将其附加到`graph_stack`。我们通过将其赋值给`node`来准备节点B的访问。
- en: On the next iteration of the `while` loop, we add node B to the list of `visited
    nodes`. We discover that the only adjacent node to B, which is A, has already
    been visited. Because all the adjacent nodes of B have been visited, we pop it
    off the stack, leaving node A as the only element on the stack. We return to node
    A and examine whether all of its adjacent nodes have been visited. The node A
    now has S as the only unvisited node. We push S to the stack and begin the whole
    process again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的下一个迭代中，我们将节点B添加到`visited nodes`列表中。我们发现B的唯一相邻节点A已经被访问。因为B的所有相邻节点都已访问，所以我们将其从栈中弹出，留下A作为栈上的唯一元素。我们回到节点A，检查其所有相邻节点是否都已访问。现在节点A的唯一未访问节点是S。我们将S推入栈中，并再次开始整个过程。
- en: The output of the traversal is A-B-S-C-D-E-H-G-F.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的输出为A-B-S-C-D-E-H-G-F。
- en: Depth-first searches find application in solving maze problems, finding connected
    components, and finding the bridges of a graph, among others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索在解决迷宫问题、寻找连通分量和寻找图的桥等问题中都有应用。
- en: Other useful graph methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的图方法
- en: Very often, you are concerned with finding a path between two nodes. You may
    also want to find all the paths between nodes. Another useful method would be
    to find the shortest path between nodes. In an unweighted graph, this would simply
    be the path with the lowest number of edges between them. In a weighted graph,
    as you have seen, this could involve calculating the total weight of passing through
    a set of edges.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的是，你关心的是在两个节点之间找到路径。你也可能想找到节点之间的所有路径。另一种有用的方法是在节点之间找到最短路径。在无权图中，这将是它们之间边数最少的路径。在加权图中，正如你所看到的，这可能涉及到通过一系列边计算总权重。
- en: Of course, in a different situation, you may want to find the longest or shortest
    path.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在另一种情况下，你可能想找到最长或最短路径。
- en: Priority queues and heaps
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列和堆
- en: A priority queue is basically a type of queue that will always return items
    in order of priority. This priority could be, for example, that the lowest item
    is always popped off first. Although it is called a queue, priority queues are
    often implemented using a heap, since it is very efficient for this purpose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列基本上是一种队列，它将始终按优先级顺序返回项目。这种优先级可能是，例如，最低的项目总是首先弹出。尽管它被称为队列，但优先队列通常使用堆来实现，因为这对于此目的非常高效。
- en: Consider that, in a store, customers queue in a line where service is only rendered
    at the front of the queue. Each customer will spend some time in the queue to
    get served. If the waiting times for the customers in the queue are 4, 30, 2,
    and 1, then the average time spent in the queue becomes `(4 + 34 + 36 + 37)/4`,
    which is `27.75`. However, if we change the order of service such that customers
    with the least amount of waiting time are served first, then we obtain a different
    average waiting time. In doing so, we calculate our new average waiting time by
    `(1 + 3 + 7 + 37)/4`, which now equals `12`, a better average waiting time. Clearly,
    there is merit to serving the customers from the least waiting time upward. This
    method of selecting the next item by priority or some other criterion is the basis
    for creating priority queues.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到，在一家商店里，顾客排队等待服务，服务只在前面的队列中进行。每位顾客在等待服务的过程中都会花费一些时间。如果队列中顾客的等待时间分别是4、30、2和1，那么平均等待时间变为`(4
    + 34 + 36 + 37)/4`，即`27.75`。然而，如果我们改变服务的顺序，让等待时间最短的顾客先被服务，那么我们会得到不同的平均等待时间。这样做，我们通过`(1
    + 3 + 7 + 37)/4`来计算新的平均等待时间，现在等于`12`，这是一个更好的平均等待时间。显然，从最短等待时间开始服务顾客是有益的。通过优先级或其他标准选择下一个项目的方法是创建优先队列的基础。
- en: A heap is a data structure that satisfies the heap property. The heap property
    states that there must be a certain relationship between a parent node and its
    child nodes. This property must apply through the entire heap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一种满足堆属性的数据结构。堆属性表明，父节点和子节点之间必须存在某种关系。这个属性必须在整个堆中适用。
- en: In a min heap, the relationship between parent and children is that the parent
    must always be less than or equal to its children. As a consequence of this, the
    lowest element in the heap must be the root node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小堆中，父节点和子节点之间的关系是父节点必须始终小于或等于其子节点。因此，堆中的最小元素必须是根节点。
- en: In a max heap, on the other hand, the parent is greater than or equal to its
    child or its children. It follows from this that the largest value makes up the
    root node.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在最大堆中，父节点大于或等于其子节点或其子节点。由此可知，最大值构成了根节点。
- en: As you can see from what we just mentioned, heaps are trees and, to be more
    specific, binary trees.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，堆是树，更具体地说，是二叉树。
- en: 'Although we are going to use a binary tree, we will actually use a list to
    represent it. This is possible because the heap will store a complete binary tree.
    A complete binary tree is one in which each row must be fully filled before starting
    to fill the next row:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们打算使用二叉树，但实际上我们会使用列表来表示它。这是因为堆将存储一个完整的二叉树。一个完整的二叉树是指每一行在开始填充下一行之前必须完全填满：
- en: '![](img/image_08_003.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_003.jpg)'
- en: 'To make the math with indexes easier, we are going to leave the first item
    in the list (index 0) empty. After that, we place the tree nodes into the list,
    from top to bottom, left to right:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使使用索引的数学计算更简单，我们将保留列表中的第一个项目（索引 0）为空。之后，我们将树节点从上到下、从左到右放入列表中：
- en: '![](img/image_08_004.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_004.jpg)'
- en: If you observe carefully, you will notice that you can retrieve the children
    of any node n very easily. The left child is located at `2n` and the right child
    is located at `2n + 1`. This will always hold true.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到你可以非常容易地检索任何节点 n 的子节点。左子节点位于 `2n`，右子节点位于 `2n + 1`。这始终是正确的。
- en: 'We are going to look at a min heap implementation. It shouldn''t be difficult
    to reverse the logic in order to get a max heap:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨最小堆的实现。为了得到最大堆，反转逻辑并不困难：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We initialize our heap list with a zero to represent the dummy first element
    (remember that we are only doing this to make the math simpler). We also create
    a variable to hold the size of the heap. This would not be necessary as such,
    since we could check the size of the list, but we would always have to remember
    to reduce it by one. So we chose to keep a separate variable instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用零初始化我们的堆列表来表示虚拟的第一个元素（记住我们这样做是为了使数学计算更简单）。我们还创建了一个变量来保存堆的大小。这样做并非必需，因为我们本可以检查列表的大小，但我们总是需要记住减去一。因此，我们选择保留一个单独的变量。
- en: Inserting
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: Inserting an item is very simple in itself. We add the new element to the end
    of the list (which we understand to be the bottom of the tree). Then we increment
    the size of the heap by one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个项目本身非常简单。我们将新元素添加到列表的末尾（我们理解为树的底部）。然后我们增加堆的大小。
- en: 'But after each insert, we need to float the new element up if needed. Bear
    in mind that the lowest element in the min heap needs to be the root element.
    We first create a helper method called `float` that takes care of this. Let us
    look at how it is meant to behave. Imagine that we have the following heap and
    want to insert the value `2`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但在每次插入后，如果需要，我们需要将新元素向上浮动。请注意，最小堆中的最低元素需要是根元素。我们首先创建一个名为 `float` 的辅助方法来处理这个问题。让我们看看它应该如何表现。想象一下，我们有一个以下堆，并想要插入值
    `2`：
- en: '![](img/image_08_005.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_005.jpg)'
- en: 'The new element has occupied the last slot in the third row or level. Its index
    value is **7**. Now we compare that value with its parent. The parent is at index
    `7/2 = 3` (integer division). That element holds **6** so we swap the **2**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素已经占据了第三行或级别的最后一个槽位。它的索引值是**7**。现在我们将该值与其父元素进行比较。父元素位于索引 `7/2 = 3`（整数除法）。该元素持有**6**，因此我们交换**2**：
- en: '![](img/image_08_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_006.jpg)'
- en: 'Our new element has been swapped and moved up to index **3**. We have not reached
    the top of the heap yet (`3 / 2 > 0`), so we continue. The new parent of our element
    is at index `3/2 = 1`. So we compare and, if necessary, swap again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新元素已经交换并移动到了索引 **3**。我们还没有到达堆的顶部（`3 / 2 > 0`），所以我们继续。我们元素的新的父元素位于索引 `3/2
    = 1`。因此我们比较，并在必要时再次交换：
- en: '![](img/image_08_007.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_007.jpg)'
- en: 'After the final swap, we are left with the heap looking as follows. Notice
    how it adheres to the definition of a heap:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的交换之后，我们留下的堆看起来如下。注意它如何遵循堆的定义：
- en: '![](img/image_08_008.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_008.jpg)'
- en: 'Here follows an implementation of what we have just described:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现我们刚刚描述的内容：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are going to loop until we have reached the root node so that we can keep
    floating the element up as high as it needs to go. Since we are using integer
    division, as soon as we get below 2, the loop will break out:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环，直到我们达到根节点，这样我们就可以将元素向上浮动到它需要到达的高度。由于我们使用整数除法，一旦我们低于 2，循环就会退出：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compare parent and child. If the parent is greater than the child, swap the
    two values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 比较父元素和子元素。如果父元素大于子元素，则交换这两个值：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let''s not forget to move up the tree:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了将树向上移动：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This method ensures that the elements are ordered properly. Now we just need
    to call this from our `insert` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法确保元素按正确顺序排列。现在我们只需要从我们的 `insert` 方法中调用此方法：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the last line in insert calls the `float()` method to reorganize the
    heap as necessary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在插入中调用了 `float()` 方法来根据需要重新组织堆。
- en: Pop
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出
- en: Just like insert, `pop()` is by itself a simple operation. We remove the root
    node and decrement the size of the heap by one. However, once the root has been
    popped off, we need a new root node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像插入一样，`pop()` 本身是一个简单的操作。我们移除根节点并将堆的大小减一。然而，一旦根被弹出，我们需要一个新的根节点。
- en: 'To make this as simple as possible, we just take the last item in the list
    and make it the new root. That is, we move it to the beginning of the list. But
    now we might not have the lowest element at the top of the heap, so we perform
    the opposite of the float operation: we let the new root node sink down as required.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简单，我们只需取列表中的最后一个元素，将其作为新的根。也就是说，我们将其移动到列表的开头。但现在我们可能没有最低的元素在堆的顶部，所以我们需要执行与float操作相反的操作：我们让新的根节点按照需要下沉。
- en: 'As we did with insert, let us have a look at how the whole operation is meant
    to work on an existing heap. Imagine the following heap. We pop off the `root`
    element, leaving the heap temporarily rootless:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在插入时做的那样，让我们看看整个操作是如何在一个现有的堆上工作的。想象以下堆。我们弹出`root`元素，使堆暂时没有根：
- en: '![](img/image_08_009.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_009.jpg)'
- en: 'Since we cannot have a rootless heap, we need to fill this slot with something.
    If we choose to move up one of the children, we will have to figure out how to
    rebalance the entire tree structure. So instead, we do something really interesting.
    We move up the very last element in the list to fill the position of the `root`
    element:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能有一个没有根的堆，我们需要用某样东西来填充这个位置。如果我们选择移动其中一个子节点，我们就必须想出如何重新平衡整个树结构。所以，我们做了一些非常有趣的事情。我们将列表中的最后一个元素向上移动以填充`root`元素的位置：
- en: '![](img/image_08_010.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_010.jpg)'
- en: 'Now this element clearly is not the lowest in the heap. This is where we begin
    to sink it down. First we need to determine where to sink it down. We compare
    the two children, so that the lowest element will be the one to float up as the
    root sinks down:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个元素显然不是堆中的最低元素。这就是我们开始将其下沉的地方。首先我们需要确定将其下沉的位置。我们比较两个子树，这样最低的元素就会在根节点下沉时浮上来：
- en: '![](img/image_08_011.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_011.jpg)'
- en: 'The right child is clearly less. Its index is **3**, which represents the root
    index `* 2 + 1`. We go ahead and compare our new root node with the value at this
    index:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 右子树显然更小。它的索引是**3**，这代表了根索引`* 2 + 1`。我们继续比较我们的新根节点和这个索引处的值：
- en: '![](img/image_08_012.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_012.jpg)'
- en: 'Now our node has jumped down to index **3**. We need to compare it to the lesser
    of its children. However, now we only have one child, so we don''t need to worry
    about which child to compare against (for a min heap, it is always the lesser
    child):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的节点已经跳到了索引**3**。我们需要将其与它的较小子节点进行比较。然而，现在我们只有一个子节点，所以我们不需要担心比较哪个子节点（对于最小堆来说，总是较小的子节点）：
- en: '![](img/image_08_013.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_013.jpg)'
- en: There is no need to swap here. Since there are no more rows either, we are done.
    Notice again how, after the `sink()` operation is completed, our heap adheres
    to the definition of a heap.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有必要交换。由于没有更多的行，我们完成了。再次注意，在`sink()`操作完成后，我们的堆符合堆的定义。
- en: 'Now we can begin implementing this. Before we do the `sink()` method itself,
    notice how we need to determine which of the children to compare our parent node
    against. Well, let us put that selection in its own little method, just to make
    the code look a little simpler:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现了。在我们做`sink()`方法本身之前，注意我们需要确定比较父节点的子树是哪一个。好吧，让我们把这个选择放在它自己的小方法中，这样代码看起来会简单一些：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We may get beyond the end of the list, in which case we return the index of
    the left child:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会超出列表的末尾，在这种情况下，我们返回左子树的索引：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Otherwise, we simply return the index of the lesser of the two children:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们只需简单地返回两个子树中较小的一个的索引：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can create the `sink` function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`sink`函数：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As before, we are going to loop so that we can sink our element down as far
    as is needed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们将循环，这样我们就可以将元素下沉到所需的程度：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next we need to know which of the left or the right child to compare against.
    This is where we make use of the `minindex()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要知道是和左子树还是右子树进行比较。这就是我们使用`minindex()`函数的地方：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we did in the `float()` method, we compare parent and child to see whether
    we need to swap:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`float()`方法中所做的那样，我们比较父节点和子节点，以确定是否需要交换：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And we need to make sure that we move down the tree so that we don''t get stuck
    in a loop:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们沿着树向下移动，这样我们才不会陷入循环：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only thing remaining now is to implement `pop()` itself. This is very straightforward
    as the grunt work is performed by the `sink()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情就是实现`pop()`本身。这非常直接，因为脏活是由`sink()`方法来干的：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing the heap
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试堆
- en: 'Now we just need some code to test the heap. We begin by creating our heap
    and inserting some data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一些代码来测试堆。我们首先创建我们的堆并插入一些数据：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can print the heap list, just to inspect how the elements are ordered. If
    you redraw this as a tree structure, you should notice that it meets the required
    properties of a heap:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印堆列表，只是为了检查元素是如何排序的。如果你将其重新绘制为树结构，你应该注意到它符合堆所需的所有属性：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we will pop off the items, one at a time. Notice how the items come out
    in a sorted order, from lowest to highest. Also notice how the heap list changes
    after each pop. It is a good idea to take out a pen and paper and to redraw this
    list as a tree after each pop, to fully understand how the `sink()` method works:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐个弹出项目。注意项目是如何以排序顺序（从低到高）弹出的。同时注意堆列表在每次弹出后的变化。拿出笔和纸，在每次弹出后重新绘制这个列表作为树，以完全理解`sink()`方法是如何工作的：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the chapter on sorting algorithms, we will reorganize the code for the heap
    sort algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序算法章节中，我们将重新组织堆排序算法的代码。
- en: Once you have the min heap working properly and understand how it works, it
    should be a simple task to implement a max heap. All you have to do is to reverse
    the logic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确实现了最小堆并理解了它是如何工作的，实现最大堆应该是一个简单的任务。你所要做的就是反转逻辑。
- en: Selection algorithms
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: Selection algorithms fall under a class of algorithms that seek to answer the
    problem of finding the ith-smallest element in a list. When a list is sorted in
    ascending order, the first element in the list will be the smallest item in the
    list. The second element in the list will be the second-smallest element in the
    list. The last element in the list will be the last-smallest element in the list
    but that will also qualify as the largest element in the list.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法属于一类算法，旨在解决在列表中找到第i个最小元素的问题。当列表按升序排序时，列表中的第一个元素将是列表中最小的项。列表中的第二个元素将是列表中的第二个最小元素。列表中的最后一个元素将是列表中的最后一个最小元素，但这也将符合列表中的最大元素。
- en: In creating the heap data structure, we have come to the understanding that
    a call to the `pop` method will return the smallest element in the heap. The first
    element to pop off a min heap is the first-smallest element in the list. Similarly,
    the seventh element to be popped off the min heap will be the seventh-smallest
    element in the list. Therefore, to find the ith-smallest element in a list will
    require us to pop the heap *i* number of times. That is a very simple and efficient
    way of finding the ith-smallest element in a list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建堆数据结构时，我们达到了这样的理解：对`pop`方法的调用将返回堆中的最小元素。从最小堆中弹出的第一个元素是列表中的第一个最小元素。同样，从最小堆中弹出的第七个元素将是列表中的第七个最小元素。因此，要找到列表中的第i个最小元素，我们需要弹出堆*i*次。这是一个非常简单且高效的方法来找到列表中的第i个最小元素。
- en: But in [Chapter 11](8523afdb-a3e7-4ab8-b8a7-be7278a1c735.xhtml), *Selection
    Algorithms*, we will study another approach by which we can find the ith-smallest
    element in a list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但在[第11章](8523afdb-a3e7-4ab8-b8a7-be7278a1c735.xhtml)，“选择算法”中，我们将研究另一种方法，通过这种方法我们可以找到列表中的第i个最小元素。
- en: Selection algorithms have applications in filtering out noisy data, finding
    the median, smallest, and largest elements in a list, and can even be applied
    in computer chess programs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法在过滤噪声数据、找到列表中的中位数、最小和最大元素以及甚至可以应用于计算机棋类程序中都有应用。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Graphs and heaps have been treated in this chapter. We looked at ways to represent
    a graph in Python using lists and dictionaries. In order to traverse the graph,
    we looked at breadth-first searches and depth-first searches.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了图和堆。我们探讨了使用列表和字典在Python中表示图的方法。为了遍历图，我们研究了广度优先搜索和深度优先搜索。
- en: We then switched our attention to heaps and priority queues to understand their
    implementation. The chapter ended with using the concept of a heap to find the
    ith-smallest element in a list.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将注意力转向堆和优先队列，以理解它们的实现。本章以使用堆的概念在列表中找到第i个最小元素结束。
- en: The subject of graphs is very complicated and just one chapter will not do justice
    to it. The journey with nodes will end with this chapter. The next chapter will
    usher us into the arena of searching and the various means by which we can efficiently
    search for items in lists.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图论非常复杂，仅一章内容无法公正地对待它。以节点为旅程的旅程将在这个章节结束。下一章将引领我们进入搜索领域，以及我们如何在列表中高效搜索项目的各种方法。
